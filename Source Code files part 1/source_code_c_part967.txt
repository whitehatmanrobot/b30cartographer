         strRoot += L"\\";
               }
               //
               // These are the roots of the objects.
               // They are always containers
               //

               if (SCE_STATUS_NO_ACL_SUPPORT == pObject->Status) 
               {
                  folder = CreateAndAddOneNode(pFolder,
                                              // pObject->Name,
                                               strRoot,
                                               pBuf,
                                               newType,
                                               FALSE,
                                               GT_COMPUTER_TEMPLATE,
                                               pObject,
                                               pObject->Status);
               } 
               else 
               {
                  folder = CreateAndAddOneNode(
                                              pFolder,       // Parent folder
                                           //   pObject->Name, // Name
                                              strRoot,
                                              pBuf,          // Description
                                              newType,       // Folder Type
                                              TRUE,          // Has Children?
                                              GT_COMPUTER_TEMPLATE, // INF File
                                              pObject,       // Extra Data: the object
                                              pObject->Status); // Status
               }

               if(folder)
                  folder->SetDesc( pObject->Status, pObject->Count );
            }
         }
         return S_OK;

      case REG_OBJECTS:
      case FILE_OBJECTS:
         if ( SadHandle == NULL ) 
         {

            //
            // We shouldn't be able to get this far without a SadHandle
            //
            ASSERT(FALSE);
            return E_FAIL;
         }

         if ( type == REG_OBJECTS)
            status = AREA_REGISTRY_SECURITY;
         else if ( type == FILE_OBJECTS )
            status = AREA_FILE_SECURITY;
         else 
         {
            ASSERT(FALSE);
            return E_FAIL;
         }

         //
         // get the next level objects
         //
         rc = SceGetObjectChildren(SadHandle,                   // hProfile
                                   SCE_ENGINE_SAP,              // Profile type
                                   (AREA_INFORMATION)status,    // Area
                                   (LPTSTR)(pFolder->GetName()),// Object prefix
                                   &ObjectList,                 // Object list [out]
                                   &ErrBuf);                    // Error list [out]
         if ( ErrBuf ) 
         { // rc != SCESTATUS_SUCCESS ) {
            MyFormatResMessage(rc, IDS_ERROR_GETTING_LAST_ANALYSIS, ErrBuf, StrErr);

            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }
         if ( rc == SCESTATUS_SUCCESS &&
              ObjectList ) 
         {
            BOOL bContainer = FALSE;
            //
            // add the objects
            //
            PSCE_OBJECT_CHILDREN_NODE *pObjNode = &(ObjectList->arrObject);

            for (DWORD i=0; i<ObjectList->nCount;i++) 
            {
               //
               // These are the next level objects
               //
               if ( pObjNode[i] == NULL ||
                    pObjNode[i]->Name == NULL ) 
               {
                   continue;
               }

               if (SCE_STATUS_NO_ACL_SUPPORT == pObjNode[i]->Status) 
               {
                  // No ACL support, so don't add sub objects
                  continue;
               }

               //
               // If there are any mismatched child objects then we know
               // that this is a container, otherwise we have to check the
               // object on the system to find out if it is a container
               //
               if ( pObjNode[i]->Count > 0 ) 
                  bContainer = TRUE;
               else 
               {
                  if (FILE_OBJECTS == type) 
                  {
                     //
                     // Check if a file object is a container
                     //
                     CString strPath;
                     DWORD dwAttr = 0;

                     strPath = pFolder->GetName();
                     if (strPath.Right(1) != L"\\") 
                     {
                        strPath += L"\\";
                     }
                     strPath += pObjNode[i]->Name;

                     dwAttr = GetFileAttributes(strPath);
                     if (0xFFFFFFFF == dwAttr) 
                        bContainer = FALSE;
                     else 
                        bContainer = dwAttr & FILE_ATTRIBUTE_DIRECTORY;
                  } 
                  else 
                  {
                     //
                     // Always treat Registry Keys and DS Objects as containers
                     //
                     bContainer = TRUE;
                  }
               }
               if (bContainer) 
               {
                  StrErr = pFolder->GetName();
                  if (StrErr.Right(1) != L"\\")
                     StrErr += L"\\";
                  
                  StrErr += pObjNode[i]->Name;
                  folder = CreateAndAddOneNode(
                                              pFolder,       // Parent folder
                                              (LPTSTR)((LPCTSTR)StrErr),  // Name
                                              pBuf,          // Description
                                              type,          // Folder Type
                                              TRUE,          // Has Children?
                                              GT_COMPUTER_TEMPLATE, // INF File
                                              NULL,
                                              pObjNode[i]->Status); // Object Status
                  if(folder)
                  {
                     folder->SetDesc( pObjNode[i]->Status,
                                      pObjNode[i]->Count );
                  }
               }
            }
         }

         if ( ObjectList )
            SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );

         return S_OK;

      case CONFIGURATION: 
         {
         //
         // enumerate profile locations in registry
         //
         CString strLocations;

         m_ConfigFolder = pFolder;
         nCount = 0;

         if (strLocations.LoadString(IDS_TEMPLATE_LOCATION_KEY)) 
         {
            //
            // Bug 375324 - Merge HKCU locations with HKLM locations
            //
            status = RegOpenKeyEx( HKEY_CURRENT_USER,
                                   strLocations,
                                   0, KEY_READ, &hKey);

            if ( NO_ERROR == status ) 
            {
               nCount += AddLocationsToFolderList(hKey,dwMode,FALSE,pPos);
               RegCloseKey(hKey);
            }

            if ( 0 == nCount ) 
            {
               //
               // Empty location list, so add a default
               //
               CString strDefLoc;
               CString strDefLocEx;
               strDefLoc.LoadString(IDS_DEFAULT_LOCATION);
               int iLen = strDefLoc.GetLength()+MAX_PATH;
               LPWSTR pBuffer = strDefLocEx.GetBuffer(iLen);
               if (ExpandEnvironmentStrings(strDefLoc, pBuffer, iLen)) 
               {
                   //
                   // must use pBuffer here since strDefLocEx has not been released
                   //
                   AddTemplateLocation(pFolder,pBuffer,FALSE,TRUE);
               } 
               else
                   AddTemplateLocation(pFolder,strDefLoc,FALSE,TRUE);
               
               strDefLocEx.ReleaseBuffer();
            }
         }

         if ( Count != NULL )
            *Count = nCount;

         return hr;
      }

      case LOCATIONS:
         //
         // enumerate available profiles under the location (*.inf files)
         //

         //
         // pFolder is required in this case
         //
         if (!pFolder)
            return E_INVALIDARG;
         
         swprintf(pBuf, L"%s\\*.inf",
                  (LPTSTR)(pFolder->GetName()));
         bHasChildren = FALSE;

         hFile = _wfindfirst(pBuf, &findData);

         if ( hFile != -1) 
         {
            do {
                //
                // Don't add this item to the node if it is a subdirectory.
                //
                CString strDisplay;
                strDisplay.Format(
                   TEXT("%s\\%s"),
                   (LPCTSTR)(pFolder->GetName()),
                   findData.name);

                if( findData.attrib & _A_SUBDIR )
                   continue;

               //
               // get template's description
               //
               strDisplay = findData.name;
               //
               // GetLength has to be at least 4, since we searched on *.inf
               //
               strDisplay = strDisplay.Left(strDisplay.GetLength() - 4);
               swprintf(pBuf,
                        L"%s\\%s",
                        (LPTSTR)(pFolder->GetName()),
                        findData.name);
               if (! GetProfileDescription(pBuf, &Desc) ) 
                  Desc = NULL;
               else 
               {
                  //
                  // No problem; we just won't display a description
                  //
               }

               nCount++;
               folder = new CFolder();

               if (folder) 
               {
                  //
                  // Create the folder objects
                  // save full file name her
                  //
                  hr = folder->Create((LPCTSTR)strDisplay,         // Name
                                      Desc,                        // Description
                                      pBuf,                        // inf file name
                                      TEMPLATES_IDX,               // closed icon index
                                      TEMPLATES_IDX,               // open icon index
                                      PROFILE,                     // folder type
                                      bHasChildren,                // has children
                                      dwMode,                      // SCE Mode
                                      NULL);                       // Extra Data

                  if (SUCCEEDED(hr)) 
                  {
                     m_scopeItemList.AddTail(folder);

                     if ( nCount == 1 && NULL != pPos ) 
                     {
                        *pPos = m_scopeItemList.GetTailPosition();
                     }
                  } 
                  else 
                  {
                     delete folder;
                     folder = NULL;
                  }
               } 
               else
                  hr = E_OUTOFMEMORY;

               if (Desc) 
               {
                  LocalFree(Desc);
                  Desc = NULL;
               }
            } while ( _wfindnext(hFile, &findData) == 0 );
         }

         _findclose(hFile);

         if ( Count != NULL )
            *Count = nCount;

         return hr;

      case PROFILE: 
         {
         TCHAR pszGPTPath[MAX_PATH*5];
         SCESTATUS scestatus = 0;
         //
         // enumerate security areas for this profile
         //

         if (ModeBits & MB_NO_NATIVE_NODES) 
         {
            //
            //
            //
            nStart = nCount = 0;
            break;
         }

         //
         // Find the path to the SCE template within the GPT template
         //
         if (ModeBits & MB_GROUP_POLICY) 
         {
            //
            // get GPT root path
            //
            hr = m_pGPTInfo->GetFileSysPath(GPO_SECTION_MACHINE,
                                            pszGPTPath,
                                            ARRAYSIZE(pszGPTPath));
            if (SUCCEEDED(hr)) 
            {
               if (NULL == m_szSingleTemplateName) 
               {
                  //
                  // Allocate memory for the pszGPTPath + <backslash> + GPTSCE_TEMPLATE + <trailing nul>
                  //
                  m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(pszGPTPath)+lstrlen(GPTSCE_TEMPLATE)+2)*sizeof(TCHAR));
               }
               if (NULL != m_szSingleTemplateName) 
               {
                  lstrcpy(m_szSingleTemplateName,pszGPTPath);
                  lstrcat(m_szSingleTemplateName,L"\\" GPTSCE_TEMPLATE);

                      PSCE_PROFILE_INFO spi = NULL;
                      //
                      // Create a new template there if there isn't one already
                      //
                      if (!CreateNewProfile(m_szSingleTemplateName,&spi)) 
                      {
                         hr = E_FAIL;
                      } 
                      else 
                      {
                         if (!GetTemplate(m_szSingleTemplateName) && spi) 
                         {
                            //
                            // bug 265996
                            //
                            // The first time a GPO's Security Settings are opened we create
                            // the file, but if it's on a remote machine it may not have been
                            // created yet when we try to open it
                            //
                            // Since we know what's going to be in it once it's created we
                            // can skip the open step and just shove our template into the
                            // cache

                            //
                            // Allocate space for key.
                            //
                            LPTSTR szKey = new TCHAR[ lstrlen( m_szSingleTemplateName ) + 1];
                            if(!szKey)
                            {
                                return NULL;
                            }
                            lstrcpy(szKey, m_szSingleTemplateName);
                            _wcslwr( szKey );

                            //
                            // Create a new CEditTemplate
                            //

                            CEditTemplate *pTemplateInfo = new CEditTemplate;
                            if (pTemplateInfo) 
                            {
                               pTemplateInfo->SetInfFile(m_szSingleTemplateName);
                               pTemplateInfo->SetNotificationWindow(m_pNotifier);
                               pTemplateInfo->pTemplate = spi;
                               //
                               // This is a brand new template; ergo everything's loaded
                               //
                               pTemplateInfo->AddArea(AREA_ALL);


                               //
                               // Stick it in the cache
                               //
                               m_Templates.SetAt(szKey, pTemplateInfo);

                               //
                               // expand registry value section based on registry values list on local machine
                               //
                               SceRegEnumAllValues(
                                                  &(pTemplateInfo->pTemplate->RegValueCount),
                                                  &(pTemplateInfo->pTemplate->aRegValues));
                            }

                            if (szKey) 
                               delete[] szKey;
                         }
                      }
               } 
               else
                  hr = E_OUTOFMEMORY;
            }
         }

         nStart = FIRST_PROFILE_FOLDER;

            //
            // Display all but the DS Objects folder
            //
            nCount = LAST_PROFILE_NODS_FOLDER - FIRST_PROFILE_FOLDER +1;


         bHasChildren = FALSE;
         tmpstr = pFolder->GetInfFile(); // inf file full path name
         //
         // If this folder is in a write-through mode then set that
         // on the template
         //
         PEDITTEMPLATE pie;
         pie = GetTemplate(tmpstr);
         if ( pie ) 
         {
            if (ModeBits & MB_WRITE_THROUGH) 
            {
               pie->SetWriteThrough(TRUE);
            }
         } 
         else 
         {
            //
            // Mark as bad template.
            //
            pFolder->SetState( CFolder::state_InvalidTemplate );
            nCount = 0;
         }
         break;
      }

      case LOCALPOL: 
         {
         nStart = FIRST_PROFILE_FOLDER;
         nCount = LAST_LOCALPOL_FOLDER - FIRST_PROFILE_FOLDER +1;
         bHasChildren = FALSE;
         pFolder->SetInfFile(GT_LOCAL_POLICY);
         break;
      }

      case POLICY_ACCOUNT:
         if (!pFolder) 
         {
            return E_INVALIDARG;
         } 
         else 
         {
            tmpstr = pFolder->GetInfFile();
         }
         // fall through;
      case LOCALPOL_ACCOUNT:
      case POLICY_ACCOUNT_ANALYSIS:
         nStart = FIRST_ACCOUNT_FOLDER;
         if (ModeBits & MB_DS_OBJECTS_SECTION) 
         {
            //
            // Include the DC Specific folders
            //
            nCount = LAST_ACCOUNT_FOLDER - FIRST_ACCOUNT_FOLDER + 1;
         } 
         else 
         {
            //
            // Display all but the DC Specific folders
            //
            nCount = LAST_ACCOUNT_NODS_FOLDER - FIRST_ACCOUNT_FOLDER +1;
         }
         bHasChildren = FALSE;
         break;

      case POLICY_LOCAL:
         if (!pFolder) 
         {
            return E_INVALIDARG;
         } 
         else 
         {
            tmpstr = pFolder->GetInfFile();
         }
         // fall through;
      case LOCALPOL_LOCAL:
      case POLICY_LOCAL_ANALYSIS:
         nStart = FIRST_LOCAL_FOLDER;
         nCount = LAST_LOCAL_FOLDER - FIRST_LOCAL_FOLDER +1;
         bHasChildren = FALSE;
         break;

      case POLICY_EVENTLOG:
         if (!pFolder)
            return E_INVALIDARG;
         else
            tmpstr = pFolder->GetInfFile();
         // fall through;
      case LOCALPOL_EVENTLOG:
      case POLICY_EVENTLOG_ANALYSIS:
         nStart = FIRST_EVENTLOG_FOLDER;
         nCount = LAST_EVENTLOG_FOLDER - FIRST_EVENTLOG_FOLDER +1;
         bHasChildren = FALSE;
         break;

      default:
         break;
   }


   if ( Count != NULL )
      *Count = nCount;

   CString cStrName;
   CString cStrDesc;


   for (int i=nStart; i < nStart+nCount; i++) 
   {
      folder = new CFolder();

      if (!folder) 
      {
         //
         // What about other folders that we've created?
         //
         return E_OUTOFMEMORY;
      }
      if (!cStrName.LoadString(SecmgrFolders[i].ResID) ||
          !cStrDesc.LoadString(SecmgrFolders[i].DescID)) 
      {
         delete folder;
         return E_FAIL;
      }

      //
      // Create the folder objects with static data
      //
      if (type == ANALYSIS ||
          type == AREA_POLICY_ANALYSIS ||
          type == POLICY_ACCOUNT_ANALYSIS ||
          type == POLICY_LOCAL_ANALYSIS ||
          type == POLICY_EVENTLOG_ANALYSIS ) 
      {
         if (m_bIsLocked) 
         {
            nCount = 0;


            delete folder;
            // Should display an "in use" message in result pane

            //
            // We're not adding anything, but we're not actually failing
            //
            return S_OK;
         }

         switch (SecmgrFolders[i].type) 
         {
            case AREA_POLICY:
               newType = AREA_POLICY_ANALYSIS;
               break;

            case AREA_PRIVILEGE:
               newType = AREA_PRIVILEGE_ANALYSIS;
               break;

            case AREA_GROUPS:
               newType = AREA_GROUPS_ANALYSIS;
               break;

            case AREA_SERVICE:
               newType = AREA_SERVICE_ANALYSIS;
               tmpstr = GT_COMPUTER_TEMPLATE;
               break;

            case AREA_REGISTRY:
               newType = AREA_REGISTRY_ANALYSIS;
               break;

            case AREA_FILESTORE:
               newType = AREA_FILESTORE_ANALYSIS;
               break;

            case POLICY_ACCOUNT:
               newType = POLICY_ACCOUNT_ANALYSIS;
               break;

            case POLICY_LOCAL:
               newType = POLICY_LOCAL_ANALYSIS;
               break;

            case POLICY_EVENTLOG:
               newType = POLICY_EVENTLOG_ANALYSIS;
               break;

            case POLICY_PASSWORD:
               newType = POLICY_PASSWORD_ANALYSIS;
               break;

            case POLICY_KERBEROS:
               newType = POLICY_KERBEROS_ANALYSIS;
               break;

            case POLICY_LOCKOUT:
               newType = POLICY_LOCKOUT_ANALYSIS;
               break;

            case POLICY_AUDIT:
               newType = POLICY_AUDIT_ANALYSIS;
               break;

            case POLICY_OTHER:
               newType = POLICY_OTHER_ANALYSIS;
               break;

            case POLICY_LOG:
               newType = POLICY_LOG_ANALYSIS;
               break;

            default:
               newType = SecmgrFolders[i].type;
               break;
         }

        int nImage = GetScopeImageIndex(newType);

        hr = folder->Create(cStrName.GetBuffer(2),    // Name
                            cStrDesc.GetBuffer(2),    // Description
                            tmpstr,                   // inf file name
                            nImage,                   // closed icon index
                            nImage,                   // open icon index
                            newType,                  // folder type
                            bHasChildren,             // has children
                            dwMode,                   // SCE Mode
                            NULL);                    // Extra Data
      } 
      else if (type == LOCALPOL ||
             type == AREA_LOCALPOL ||
             type == LOCALPOL_ACCOUNT ||
             type == LOCALPOL_LOCAL ||
             type == LOCALPOL_EVENTLOG ) 
      {
            if (m_bIsLocked) 
            {
               nCount = 0;

               delete folder;
               // Should display an "in use" message in result pane

               //
               // We're not adding anything, but we're not actually failing
               //
               return S_OK;
            }

            tmpstr = GT_LOCAL_POLICY;
            switch (SecmgrFolders[i].type) 
            {
               case AREA_POLICY:
                  newType = AREA_LOCALPOL;
                  break;

               case POLICY_ACCOUNT:
                  newType = LOCALPOL_ACCOUNT;
                  break;

               case POLICY_LOCAL:
                  newType = LOCALPOL_LOCAL;
                  break;

               case POLICY_EVENTLOG:
                  newType = LOCALPOL_EVENTLOG;
                  break;

               case POLICY_PASSWORD:
                  newType = LOCALPOL_PASSWORD;
                  break;

               case POLICY_KERBEROS:
                  newType = LOCALPOL_KERBEROS;
                  break;

               case POLICY_LOCKOUT:
                  newType = LOCALPOL_LOCKOUT;
                  break;

               case POLICY_AUDIT:
                  newType = LOCALPOL_AUDIT;
                  break;

               case POLICY_OTHER:
                  newType = LOCALPOL_OTHER;
                  break;

               case POLICY_LOG:
                  newType = LOCALPOL_LOG;
                  break;

               case AREA_PRIVILEGE:
                  newType = LOCALPOL_PRIVILEGE;
                  break;

               default:
                  newType = SecmgrFolders[i].type;
                  break;
            }

         int nImage = GetScopeImageIndex(newType);

         hr = folder->Create(cStrName.GetBuffer(2),    // Name
                             cStrDesc.GetBuffer(2),    // Description
                             tmpstr,                   // inf file name
                             nImage,                   // closed icon index
                             nImage,                   // open icon index
                             newType,                  // folder type
                             bHasChildren,             // has children
                             dwMode,                   // SCE Mode
                             NULL);                    // Extra Data
      } 
      else 
      {
         int nImage = GetScopeImageIndex(SecmgrFolders[i].type);

         hr = folder->Create(cStrName.GetBuffer(2),    // Name
                             cStrDesc.GetBuffer(2),    // Description
                             tmpstr,                   // inf file name
                             nImage,                   // closed icon index
                             nImage,                   // open icon index
                             SecmgrFolders[i].type,    // folder type
                             bHasChildren,             // has children
                             dwMode,                   // SCE Mode
                             NULL);                    // Extra Data

      }
      if (SUCCEEDED(hr)) 
      {
         m_scopeItemList.AddTail(folder);
         if ( i == nStart && NULL != pPos ) 
         {
            *pPos = m_scopeItemList.GetTailPosition();
         }
      } 
      else 
      {
         delete folder;
         return hr;
      }
   }

   return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method:     EnumerateScopePane
//
//  Synopsis:   Add the child folders of cookie/pParent to MMC's scope pane tree
//
//  Arguments:  [cookie]  - The cookie representing the node's who we
//                          are enumerating
//              [pParent] - The id of the node we are enumerating
//              [dwMode]  - The mode SCE is operating under (only allowed for
//                                                           initial enumeration)
//
//  Returns:    none
//
//  Modifies:   m_ScopeItemList (via CreateFolderList)
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------

void CComponentDataImpl::EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
   int i = 0;
   ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface
   if (NULL == m_pScope)
      return;



   m_bEnumerateScopePaneCalled = true;


   //
   // Enumerate the scope pane
   //

   // Note - Each cookie in the scope pane represents a folder.
   // A released product may have more then one level of children.
   // This sample assumes the parent node is one level deep.

   ASSERT(pParent != 0);
   if (0 == pParent)
      return;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (m_scopeItemList.GetCount() == 0 ) 
   {
      CreateFolderList(NULL, ROOT, NULL, NULL);
   }

   //
   // Enumerate the scope pane
   // return the folder object that represents the cookie
   // Note - for large list, use dictionary
   //
   CFolder* pThis = FindObject(cookie, NULL);
   if (NULL == pThis) 
      pThis = m_AnalFolder;

   ASSERT(pThis);
   if ( NULL == pThis ) 
      return;

   //
   // Note - Each cookie in the scope pane represents a folder.
   //

   //
   // If we've already enumerated this folder then don't do it again
   //
   if ( pThis->IsEnumerated() )
      return;

   POSITION pos = NULL;
   int nCount = 0;
   CFolder *pFolder = 0;


   //
   // the pParent is the enumerated node's item ID, not its parent ID
   //
   pThis->GetScopeItem()->ID = pParent;
   if (SUCCEEDED(CreateFolderList( pThis,
             pThis->GetType(),
             &pos,
             &nCount )))  
   {
      for (i=0; (i < nCount) && (pos != NULL); i++ ) 
      {
         pFolder = m_scopeItemList.GetNext(pos);

         ASSERT(NULL != pFolder);
         if ( pFolder == NULL ) 
         {
            continue;
         }
         LPSCOPEDATAITEM pScope;
         pScope = pFolder->GetScopeItem();

         ASSERT(NULL != pScope);

         //
         // Set the parent
         //
         pScope->relativeID = pParent;

         //
         // Set the folder as the cookie
         //
         pScope->mask |= SDI_PARAM;
         pScope->lParam = reinterpret_cast<LPARAM>(pFolder);
         pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
         m_pScope->InsertItem(pScope);

         //
         // Note - On return, the ID member of 'm_pScopeItem'
         // contains the handle to the newly inserted item!
         //
         ASSERT(pScope->ID != NULL);
      }

      // This was commented out, but is needed to fix
      // 249158: SCE UI: Every time analysis is performed, another set of node appears
      // This flag will prevent the nodes from being re-enumerated.
      // If this doesn't work, then all the child nodes should be deleted before
      // reenumeration
      pThis->Set(TRUE);     // folder has been enumerated
   }
   else
   {
      //
      // Error creating folder list.  Make sure the folder isn't
      // marked as opened so that we can try to expand it again later
      //
      SCOPEDATAITEM item;

      ZeroMemory (&item, sizeof (item));
      item.mask = SDI_STATE;
      item.nState = 0;
      item.ID = pThis->GetScopeItem()->ID;
      //
      // Nothing else we can do if this returns a failure, so
      // don't worry about it
      //
      (void)m_pScope->SetItem (&item);
   }

}


/*------------------------------------------------------------------------------------------
CComponentDataImpl::GetColumnInfo

Synopsis:   Returns the column info for a folder type.

Arguments: [fType]  - The type of the CFolder item.

Returns:    a pointer to an int * where int[0] = the resource descritption into g_columnInfo.
                                        int[1] = the number of columns this array describes.
            NULL   - If there is no matching key.
------------------------------------------------------------------------------------------*/
PSCE_COLINFOARRAY CComponentDataImpl::GetColumnInfo( FOLDER_TYPES fType )
{
    PSCE_COLINFOARRAY pRet = NULL;
    if( m_mapColumns.Lookup(fType, pRet) )
    {
        return pRet;
    }
    return NULL;
}

/*------------------------------------------------------------------------------------------
CComponentDataImpl::SetColumnInfo

Synopsis:   Sets the column info for a certain type of folder.

Arguments: [fType]  - The type of the CFolder item.
           [pInfo]  - The new column info.
------------------------------------------------------------------------------------------*/
void CComponentDataImpl::SetColumnInfo( FOLDER_TYPES fType, PSCE_COLINFOARRAY pInfo)
{
    PSCE_COLINFOARRAY pCur = GetColumnInfo(fType);

    if(pCur)
    {
        LocalFree(pCur);
    }
    m_mapColumns.SetAt(fType, pInfo);
}

/*------------------------------------------------------------------------------------------
CComponentDataImpl::UpdateObjectStatus

Synopsis:   Updates the status of all objects under the child and parents if bUpdateThis
            is TRUE.

Arguments: [pParent]       - The Object to set status on
           [bUpdateThis]   - Weather to update the object or not.
------------------------------------------------------------------------------------------*/
DWORD CComponentDataImpl::UpdateObjectStatus(
   CFolder *pParent,
   BOOL bUpdateThis)
{
   if(!pParent)
      return ERROR_INVALID_PARAMETER;

   DWORD status = 0;
   TCHAR szBuf[50];

   switch(pParent->GetType())
   {
   case REG_OBJECTS:
      status = AREA_REGISTRY_SECURITY;
      break;

   case FILE_OBJECTS:
      status = AREA_FILE_SECURITY;
      break;

   default:
      return ERROR_INVALID_PARAMETER;
   }

   PSCE_OBJECT_CHILDREN     ObjectList  = NULL;
   PSCE_ERROR_LOG_INFO  ErrBuf      = NULL;
   SCESTATUS rc = 0;
   CString StrErr;
   SCOPEDATAITEM sci;

   HSCOPEITEM hItem = NULL;
   LONG_PTR pCookie = NULL;

   ZeroMemory(&sci, sizeof(SCOPEDATAITEM));
   sci.mask = SDI_STR | SDI_PARAM;

#define UPDATE_STATUS( X, O ) X->SetDesc( O->Status, O->Count );\
                           X->GetScopeItem()->nImage = GetScopeImageIndex( X->GetType(), O->Status);\
                           X->GetScopeItem()->nOpenImage = X->GetScopeItem()->nImage;

   LPCTSTR pszParent = NULL;
   if (bUpdateThis) 
   {
      CFolder *pCurrent = pParent;

      pParent->RemoveAllResultItems();
      m_pConsole->UpdateAllViews(NULL, (MMC_COOKIE)pParent, UAV_RESULTITEM_UPDATEALL);
      hItem = pCurrent->GetScopeItem()->ID;
      do {

         //
         // Walk up the items parent and update the items status.
         //
         if( m_pScope->GetParentItem( hItem, &hItem, &pCookie) == S_OK)
         {
            pszParent = (LPCTSTR)((CFolder *)pCookie)->GetName();
         } 
         else
            break;

         if(!pCookie)
            break;
         
         //
         // We are finished going up the parent.
         //

         switch( ((CFolder *)pCookie)->GetType() ) 
         {
            case AREA_REGISTRY_ANALYSIS:
            case AREA_FILESTORE_ANALYSIS:
               pszParent = NULL;
               break;

            default:
               break;
         }

         //
         // We have to get object information from the parent to the count parameter.
         //
         rc = SceGetObjectChildren(SadHandle,                   // hProfile
                                   SCE_ENGINE_SAP,              // Profile type
                                   (AREA_INFORMATION)status,    // Area
                                   (LPTSTR)pszParent,           // Object prefix
                                   &ObjectList,                 // Object list [out]
                                   &ErrBuf);
         if(ErrBuf)
         {
            SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
            ErrBuf = NULL;
         }

         if(SCESTATUS_SUCCESS != rc)
            break;

         //
         // Find object in link list.
         //
         DWORD i=0;

         sci.lParam = (LONG_PTR)pCurrent;
         GetDisplayInfo( &sci );

         PSCE_OBJECT_CHILDREN_NODE *pObjNode = &(ObjectList->arrObject);

         while(ObjectList && i<ObjectList->nCount)
         {
            if( pObjNode[i] &&
                pObjNode[i]->Name &&
                !lstrcmpi(sci.displayname, pObjNode[i]->Name) )
            {
               UPDATE_STATUS(pCurrent, pObjNode[i]);
               //
               // Update scopeItem.
               //
               m_pScope->SetItem(pCurrent->GetScopeItem());
               break;
            }
            i++;
         }

         if ( ObjectList ) 
         {
            SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );
            ObjectList = NULL;
         }

         pCurrent = (CFolder *)pCookie;
      } while( pszParent && hItem );
   }


   ObjectList = NULL;
   ErrBuf = NULL;

   //
   // Get Object children.
   //
   pszParent = pParent->GetName();
   rc = SceGetObjectChildren(SadHandle,                   // hProfile
                             SCE_ENGINE_SAP,              // Profile type
                             (AREA_INFORMATION)status,    // Area
                             (LPTSTR)pszParent,           // Object prefix
                             &ObjectList,                 // Object list [out]
                             &ErrBuf);
   //
   // Error list [out]
   //
   if ( ErrBuf ) 
   {
      MyFormatResMessage(rc, IDS_ERROR_GETTING_LAST_ANALYSIS, ErrBuf, StrErr);

      SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
      ErrBuf = NULL;
   }

   if ( SCESTATUS_SUCCESS == rc) 
   {
      //
      // Update all the children.
      //
      if( m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &hItem, &pCookie) == S_OK && pCookie)
      {
         sci.lParam = (LONG_PTR)pCookie;

         GetDisplayInfo(&sci);
         while(hItem)
         {
            pParent = reinterpret_cast<CFolder *>(pCookie);
            //
            // Find object in object list.
            //
            DWORD i=0;
            while( ObjectList && i<ObjectList->nCount )
            {
               if( (&(ObjectList->arrObject))[i] &&
                   (&(ObjectList->arrObject))[i]->Name &&
                   !lstrcmpi((&(ObjectList->arrObject))[i]->Name, (LPCTSTR)sci.displayname) )
               {
                  UPDATE_STATUS(pParent, (&(ObjectList->arrObject))[i]);
                  //
                  // Update this objects children.
                  //
                  UpdateObjectStatus( pParent, FALSE );

                  //
                  // Update the name space
                  //
                  pParent->RemoveAllResultItems();
                  m_pConsole->UpdateAllViews(NULL, (MMC_COOKIE)pParent, UAV_RESULTITEM_UPDATEALL);
                  m_pScope->SetItem(pParent->GetScopeItem());
                  break;
               }
               i++;
            }

            if(ObjectList == NULL || i >= ObjectList->nCount)
            {
               //
               // Couldn't find the item, so just stop.
               //
               break;
            }

            //
            // Next Scope item
            //
            if( m_pScope->GetNextItem(hItem, &hItem, &pCookie) != S_OK)
            {
               break;
            }
         }
      }
   }

   if ( ObjectList )
      SceFreeMemory((PVOID)ObjectList, SCE_STRUCT_OBJECT_CHILDREN );

   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\snapmgr.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef WSECMGR_SNAPMGR_H
#define WSECMGR_SNAPMGR_H

#include "resource.h"       // main symbols
#include "attr.h"

#ifdef INITGUID
#undef INITGUID
#endif
#include <gpedit.h>

#include "uithread.h"
#include "hidwnd.h"
#include "wmihooks.h"


#define MAX_CONTEXT_MENU_STRLEN 128

struct MENUDATARES
{
    WCHAR szBuffer[MAX_CONTEXT_MENU_STRLEN*2];
    UINT uResID;
};

struct MENUMAP
{
    MENUDATARES* dataRes;
    CONTEXTMENUITEM* ctxMenu;
};


#define DECLARE_MENU(theClass) \
class theClass \
{ \
public: \
    static LPCONTEXTMENUITEM GetContextMenuItem() { return GetMenuMap()->ctxMenu; }; \
    static MENUMAP* GetMenuMap(); \
};

#define BEGIN_MENU(theClass) \
     MENUMAP* theClass::GetMenuMap() {

#define BEGIN_CTX static CONTEXTMENUITEM ctx[] = {

#define CTX_ENTRY(cmdID, fFlags, fInsert) { L"",L"", cmdID, CCM_INSERTIONPOINTID_PRIMARY_TOP /*| fInsert*/, fFlags, 0 },

#define END_CTX { NULL, NULL, 0, 0, 0, 0} };

#define BEGIN_RES  static MENUDATARES dataRes[] = {

#define RES_ENTRY(resID) {L"", resID},

#define END_RES   { NULL, 0 }   };


#define END_MENU \
        static MENUMAP menuMap = { dataRes, ctx }; \
        return &menuMap; }

enum
{
    // Identifiers for each of the commands to be inserted into the context menu.
   IDM_ABOUT,
   IDM_ADD_ENTRY,
   IDM_ADD_FILES,
   IDM_ADD_GROUPS,
   IDM_ADD_REGISTRY,
   IDM_ADD_LOC,
   IDM_ANALYZE,
   IDM_APPLY,
   IDM_CUT,
   IDM_COPY,
   IDM_DELETE,
   IDM_GENERATE,
   IDM_NEW,
   IDM_PASTE,
   IDM_REAPPLY,
   IDM_REFRESH,
   IDM_RELOAD,
   IDM_REMOVE,
   IDM_REVERT,
   IDM_SAVE,
   IDM_SAVEAS,
   IDM_SUMMARY,
   IDM_ADD_FOLDER,
   IDM_ADD_ANAL_FILES,
   IDM_ADD_ANAL_FOLDER,
   IDM_ADD_ANAL_KEY,
   IDM_ASSIGN,
   IDM_SET_DB,
   IDM_NEW_DATABASE,
   IDM_OPEN_SYSTEM_DB,
   IDM_OPEN_PRIVATE_DB,
   IDM_OBJECT_SECURITY,
   IDM_DESCRIBE_LOCATION,
   IDM_DESCRIBE_PROFILE,
   IDM_IMPORT_POLICY,
   IDM_IMPORT_LOCAL_POLICY,
   IDM_EXPORT_POLICY,
   IDM_EXPORT_LOCALPOLICY,
   IDM_EXPORT_EFFECTIVE,
   IDM_VIEW_LOGFILE,
   IDM_SECURE_WIZARD,
   IDM_WHAT_ISTHIS
};


static HINSTANCE        g_hDsSecDll = NULL;

DECLARE_MENU(CSecmgrNodeMenuHolder)
DECLARE_MENU(CAnalyzeNodeMenuHolder)
DECLARE_MENU(CConfigNodeMenuHolder)
DECLARE_MENU(CLocationNodeMenuHolder)
DECLARE_MENU(CRSOPProfileNodeMenuHolder)
DECLARE_MENU(CSSProfileNodeMenuHolder)
DECLARE_MENU(CLocalPolNodeMenuHolder)
DECLARE_MENU(CProfileNodeMenuHolder)
DECLARE_MENU(CProfileAreaMenuHolder)
DECLARE_MENU(CProfileSubAreaMenuHolder)
DECLARE_MENU(CProfileSubAreaEventLogMenuHolder)
DECLARE_MENU(CAnalyzeAreaMenuHolder)
DECLARE_MENU(CAnalyzeGroupsMenuHolder)
DECLARE_MENU(CAnalyzeRegistryMenuHolder)
DECLARE_MENU(CAnalyzeFilesMenuHolder)
DECLARE_MENU(CProfileGroupsMenuHolder)
DECLARE_MENU(CProfileRegistryMenuHolder)
DECLARE_MENU(CProfileFilesMenuHolder)
DECLARE_MENU(CAnalyzeObjectsMenuHolder)

BOOL LoadContextMenuResources(MENUMAP* pMenuMap);


#define UAV_RESULTITEM_ADD        0x0001
#define UAV_RESULTITEM_REMOVE     0x0002
#define UAV_RESULTITEM_UPDATE     0x0004
#define UAV_RESULTITEM_UPDATEALL    0x0008
#define UAV_RESULTITEM_REDRAWALL 0x0010
class CFolder;

typedef struct _tag_SCE_COLUMNINFO {
    int colID;      // The column id.
    int nCols;      // Number of columns
    int nWidth;     // The width of the column
} SCE_COLUMNINFO, *PSCE_COLUMNINFO;

typedef struct _tag_SCE_COLINFOARRAY {
    int iIndex;
    int nCols;
    int nWidth[1];
} SCE_COLINFOARRAY, *PSCE_COLINFOARRAY;

/////////////////////////////////////////////////////////////////////////////
// Snapin

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public ISceSvcAttachmentData,
    public ISnapinHelp2,
    public CComObjectRoot
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISceSvcAttachmentData)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()
   
    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    virtual ~CComponentDataImpl();
public:

    static DWORD m_GroupMode;
    virtual const CLSID& GetCoClassID() = 0; // for both primary and extension implementation
    virtual const int GetImplType() = 0;     // for both primary and extension implementation

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

// ISceSvcAttachmentData
    STDMETHOD(GetData)(SCESVC_HANDLE sceHandle,
                       SCESVC_INFO_TYPE sceType,
                       PVOID *ppvData,
                       PSCE_ENUMERATION_CONTEXT psceEnumHandle);
    STDMETHOD(Initialize)(LPCTSTR ServiceName,
                          LPCTSTR TemplateName,
                          LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
                          SCESVC_HANDLE *sceHandle);
    STDMETHOD(FreeBuffer)(PVOID pvData);
    STDMETHOD(CloseHandle)(SCESVC_HANDLE sceHandle);

// ISnapinHelp2 helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)=0;
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile,LPCTSTR szFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// Notify handler declarations
private:
    HRESULT OnAdd(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnRename(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

    HRESULT OnCopyArea(LPCTSTR szTemplate,FOLDER_TYPES ft);
    HRESULT OnPasteArea(LPCTSTR szTemplate,FOLDER_TYPES ft);
    HRESULT OnOpenDataBase();
    HRESULT OnNewDatabase();
    HRESULT OnAssignConfiguration( SCESTATUS *pSceStatus);
    HRESULT OnSecureWizard();
    HRESULT OnSaveConfiguration();
    HRESULT OnImportPolicy(LPDATAOBJECT);
    HRESULT OnImportLocalPolicy(LPDATAOBJECT);
    HRESULT OnExportPolicy(BOOL bEffective);
    HRESULT OnAnalyze();
    BOOL GetFolderCopyPasteInfo(FOLDER_TYPES Folder,AREA_INFORMATION *Area, UINT *cf);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    CFolder* FindObject(MMC_COOKIE cookie, POSITION* thePos );
    HRESULT CreateFolderList(CFolder* pFolder, FOLDER_TYPES type, POSITION *pPos, INT *Count);
    INT CComponentDataImpl::AddLocationsToFolderList(HKEY hkey, DWORD dwMode, BOOL bCheckForDupes, POSITION *pPos);
    BOOL AddTemplateLocation(CFolder *pParent, CString szName, BOOL bIsFileName, BOOL bRefresh);
    BOOL IsNameInChildrenScopes(CFolder* pParent, LPCTSTR NameStr, MMC_COOKIE *theCookie);
    CFolder* CreateAndAddOneNode(CFolder* pParent, LPCTSTR Name, LPCTSTR Desc,
                             FOLDER_TYPES type, BOOL bChildren, LPCTSTR szInfFile = NULL,
                             PVOID pData = NULL,DWORD status = 0);
    void DeleteChildrenUnderNode(CFolder* pParent);
    void DeleteThisNode(CFolder* pNode);
    HRESULT DeleteOneTemplateNodes(MMC_COOKIE cookie);
    void DeleteList();
    void EnumerateScopePane(MMC_COOKIE cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    DWORD GetModeBits() 
    { 
        switch (m_Mode)
        {
            case SCE_MODE_DOMAIN_COMPUTER:
            case SCE_MODE_OU_COMPUTER:
            case SCE_MODE_LOCAL_COMPUTER:
            case SCE_MODE_REMOTE_COMPUTER:
                return m_computerModeBits;
                break;

            case SCE_MODE_REMOTE_USER:
            case SCE_MODE_LOCAL_USER:
            case SCE_MODE_DOMAIN_USER:
            case SCE_MODE_OU_USER:
                return m_userModeBits;
                break;

            default:
                return m_computerModeBits;
                break;
        }
    };

public:
    PEDITTEMPLATE GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiAirea = AREA_ALL, DWORD *idErr = NULL);
    BOOL RemovePolicyEntries(PEDITTEMPLATE pet);
    HRESULT ReloadLocation(CFolder *pFolder);
    void DeleteTemplate(CString infFile);
    static BOOL LoadResources();
    void LoadSadInfo(BOOL bRequireAnalysis);
    void UnloadSadInfo();
    void RefreshSadInfo(BOOL fRemoveAnalDlg = TRUE);
    BOOL GetSadLoaded() { return SadLoaded; };
    PVOID GetSadHandle() { return SadHandle; };
    BOOL GetSadTransStarted() { return SadTransStarted; };
    void SetSadTransStarted(BOOL bTrans) { SadTransStarted = bTrans; };
    BOOL EngineTransactionStarted();
    BOOL EngineCommitTransaction();
    BOOL EngineRollbackTransaction();
    HRESULT AddDsObjectsToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType, LPTSTR InfFile);
    HRESULT AddAnalysisFilesToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType);
    HRESULT AddAnalysisFolderToList(LPDATAOBJECT lpDataObject, MMC_COOKIE cookie, FOLDER_TYPES folderType);
    HRESULT UpdateScopeResultObject(LPDATAOBJECT pDataObj,MMC_COOKIE cookie, AREA_INFORMATION area);

    void AddPopupDialog(LONG_PTR nID, CDialog *pDlg);
    CDialog *GetPopupDialog(LONG_PTR nID);
    void RemovePopupDialog(LONG_PTR nID);

    CDialog *
    MatchNextPopupDialog(
        POSITION &pos,
        LONG_PTR priKey,
        LONG_PTR *thisPos
        );

    PSCE_COLINFOARRAY GetColumnInfo( FOLDER_TYPES pType );
    void SetColumnInfo( FOLDER_TYPES pType, PSCE_COLINFOARRAY pInfo);
    DWORD SerializeColumnInfo(IStream *pStm, ULONG *pTotalWrite, BOOL bRead);
    void CloseAnalysisPane();
    BOOL LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg = TRUE);
    HWND GetParentWindow() { return m_hwndParent; }
    LPNOTIFY GetNotifier() { return m_pNotifier; }

    DWORD UpdateObjectStatus( CFolder *pParent, BOOL bUpdateThis = FALSE );

    int
    RefreshAllFolders();

public:
   //
   // Information functions.
   //
   CFolder *GetAnalFolder()
      { return m_AnalFolder; };

   LPCONSOLENAMESPACE GetNameSpace()
      { return m_pScope; };

   DWORD GetComponentMode()
      { return m_Mode; };

   LPCONSOLE GetConsole()
      { return m_pConsole; };

   CWMIRsop * GetWMIRsop() {
      if (!m_pWMIRsop) {
         m_pWMIRsop = new CWMIRsop(m_pRSOPInfo);
      }
      return m_pWMIRsop;
   }

   void
   SetErroredLogFile( LPCTSTR pszFileName, LONG dwPosLow = 0);

   LPCTSTR GetErroredLogFile( LONG *dwPosLow = NULL)
      { if(dwPosLow) *dwPosLow = m_ErroredLogPos; return m_pszErroredLogFile; };

   void SetFlags( DWORD dwFlags, DWORD dwMask = -1)
      { m_dwFlags = dwFlags | (dwMask & m_dwFlags); };
public:
   //
   // UI add function helpers
   //
   HRESULT
   GetAddObjectSecurity(                  // Gets valid object security settings
      HWND hwndParent,
      LPCTSTR strFile,
      BOOL bContainer,
      SE_OBJECT_TYPE SeType,
      PSECURITY_DESCRIPTOR &pSelSD,
      SECURITY_INFORMATION &SelSeInfo,
      BYTE &ConfigStatus
      );

   BOOL GetWorkingDir(
      GWD_TYPES uIDDir,
      LPTSTR *pStr,
      BOOL bSet   = FALSE,
      BOOL bFile  = FALSE
      );
public:
    DWORD GetGroupMode();
   enum {
      flag_showLogFile  = 0x00000001
   };
   LPRSOPINFORMATION m_pRSOPInfo;

private:
    bool                   m_bEnumerateScopePaneCalled;
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;

    BOOL                    m_bIsDirty;
    BOOL                    m_bIsLocked;

    CString                 SadName;
    CString                 SadDescription;
    CString                 SadAnalyzeStamp;
    CString                 SadConfigStamp;
    BOOL                    SadLoaded;
    SCESTATUS               SadErrored;
    PVOID                   SadHandle;
    BOOL                    SadTransStarted;
    DWORD                   m_nNewTemplateIndex;
    DWORD                   m_Mode;         // The Mode we are in
    DWORD                   m_computerModeBits;     // Bits describing functionality changes in this mode
    DWORD                   m_userModeBits;     // Bits describing functionality changes in this mode
    // The name of the template file for MB_SINGLE_TEMPLATE_ONLY modes
    LPTSTR                  m_szSingleTemplateName;
    BOOL                    m_bDeleteSingleTemplate; // True if we need to delete the template on exit

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
    void AddScopeItemToResultPane(MMC_COOKIE cookie);
    HRESULT AddAttrPropPages(LPPROPERTYSHEETCALLBACK lpProvider,CFolder *pFolder,LONG_PTR handle);
    BOOL m_bComputerTemplateDirty;
    CMap<CString, LPCTSTR, PEDITTEMPLATE, PEDITTEMPLATE&> m_Templates;
    BOOL m_fSvcNotReady;
    HWND m_hwndParent;
    CHiddenWnd *m_pNotifier;

    CFolder * m_AnalFolder;
    CFolder * m_ConfigFolder;
    CList<CFolder*, CFolder*> m_scopeItemList;
    CMap<LONG_PTR, LONG_PTR, CDialog *, CDialog *&> m_scopeItemPopups;
    LPGPEINFORMATION m_pGPTInfo;
    CWinThread *m_pUIThread;  // The thread that creates dialog boxes for this component data item

    CString m_strDisplay;     // The static display string used for GetDisplayInfo
    CString m_strTempFile;    // The temporary file name to delete for HTML error pages
    LPTSTR  m_pszErroredLogFile;        // Error log.
    LONG    m_ErroredLogPos;            // The last write position of the error log file.
    DWORD   m_dwFlags;

    CMap<FOLDER_TYPES, FOLDER_TYPES, PSCE_COLINFOARRAY, PSCE_COLINFOARRAY&> m_mapColumns;
    CMap<UINT, UINT, LPTSTR, LPTSTR&> m_aDirs;
    CWMIRsop *m_pWMIRsop;

    CRITICAL_SECTION csAnalysisPane;
};

//
// define classes for differnt class IDs
//
#define SCE_IMPL_TYPE_EXTENSION     1
#define SCE_IMPL_TYPE_SCE           2
#define SCE_IMPL_TYPE_SAV           3
#define SCE_IMPL_TYPE_LS            4
#define SCE_IMPL_TYPE_RSOP          4

// extension snapin implementation
class CComponentDataExtensionImpl : public CComponentDataImpl,
                                   // public ISnapinHelp,
                                    public CComCoClass<CComponentDataExtensionImpl, &CLSID_Snapin>
{
//BEGIN_COM_MAP(CComponentDataExtensionImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.Extension.1"), _T("Wsecedit.Extension"), IDS_EXTENSION_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_EXTENSION; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// RSOP extension snapin implementation
class CComponentDataRSOPImpl : public CComponentDataImpl,
                                    public CComCoClass<CComponentDataRSOPImpl, &CLSID_RSOPSnapin>
{
//BEGIN_COM_MAP(CComponentDataRSOPImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.RSOP.1"), _T("Wsecedit.RSOP"), IDS_RSOP_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_RSOPSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_RSOP; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};


// SCE standalone snapin implementation
class CComponentDataSCEImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataSCEImpl, &CLSID_SCESnapin>
{
//BEGIN_COM_MAP(CComponentDataSCEImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.SCE.1"), _T("Wsecedit.SCE"), IDS_SCE_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_SCESnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_SCE; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// SAV standalone snapin implementation
class CComponentDataSAVImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataSAVImpl, &CLSID_SAVSnapin>
{
//BEGIN_COM_MAP(CComponentDataSAVImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.SAV.1"), _T("Wsecedit.SAV"), IDS_SAV_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_SAVSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_SAV; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};

// LS standalone snapin implementation
class CComponentDataLSImpl : public CComponentDataImpl,
                              public CComCoClass<CComponentDataLSImpl, &CLSID_LSSnapin>
{
//BEGIN_COM_MAP(CComponentDataLSImpl)
//    COM_INTERFACE_ENTRY(ISnapinHelp)
//END_COM_MAP()
public:
    DECLARE_REGISTRY(CSnapin, _T("Wsecedit.LS.1"), _T("Wsecedit.LS"), IDS_LS_DESC, THREADFLAGS_BOTH)

    virtual const CLSID & GetCoClassID() { return CLSID_LSSnapin; }
    virtual const int GetImplType() { return SCE_IMPL_TYPE_LS; }
// ISnapinHelp2
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
};


class CSnapin :
    public IComponent,
    public IExtendContextMenu,   // Step 3
    public IExtendPropertySheet,
    public IExtendControlbar,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
    CSnapin();
    virtual ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    friend class CComponentDataImpl;
    static long lDataObjectRefCount;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, LONG* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, MMC_COOKIE arg, MMC_COOKIE param);

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);
    int GetImplType()
    {
        CComponentDataImpl *pData =
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->GetImplType();

        return 0;
    }

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(LPDATAOBJECT pDataObj, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject,LPARAM data, LPARAM hint);
    HRESULT OnDeleteObjects(LPDATAOBJECT lpDataObject,DATA_OBJECT_TYPES cctType, MMC_COOKIE cookie, LPARAM arg, LPARAM param);
// IExtendContextMenu
public:
    PEDITTEMPLATE GetTemplate(LPCTSTR szInfFile, AREA_INFORMATION aiArea = AREA_ALL,DWORD *idErr = NULL);
    PSCE_PROFILE_INFO GetBaseInfo(PSCE_PROFILE_INFO *pBaseInfo, DWORD dwArea, PSCE_ERROR_LOG_INFO *ErrBuf =NULL );
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helper functions
protected:
    CResult* FindResult(MMC_COOKIE cookie, POSITION* thePos);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    void EnumerateResultPane(MMC_COOKIE cookie, HSCOPEITEM pParent, LPDATAOBJECT pDataObj);
    void CreateProfileResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj);
    void CreateLocalPolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pLocal, PEDITTEMPLATE pEffective,LPDATAOBJECT pDataObj);
    void CreateObjectResultList(MMC_COOKIE cookie, FOLDER_TYPES type, AREA_INFORMATION Area,
                               PSCE_OBJECT_CHILDREN pObjList, PVOID pHandle,
                               LPDATAOBJECT pDataObj );
    void CreateProfServiceResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisServiceResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,
                                   LPDATAOBJECT pDataObj );

    void DeleteServiceResultList(MMC_COOKIE);
    HRESULT EditThisService(CResult *pData, MMC_COOKIE cookie, RESULT_TYPES rsltType, HWND hwndParent);
    HRESULT GetDisplayInfoForServiceNode(RESULTDATAITEM *pResult, CFolder *pFolder, CResult *pData);
    void DeleteList(BOOL bDeleteResultItem);

    void CreateProfilePolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj);
    void CreateAnalysisPolicyResultList(MMC_COOKIE cookie, FOLDER_TYPES type,
                                   PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj );
    void CreateProfileRegValueList(MMC_COOKIE cookie, PEDITTEMPLATE pSceInfo,LPDATAOBJECT pDataObj );
    void CreateAnalysisRegValueList(MMC_COOKIE cookie, PEDITTEMPLATE pSceInfo, PEDITTEMPLATE pBase,LPDATAOBJECT pDataObj,RESULT_TYPES type );
    HRESULT EditThisRegistryValue(CResult *pData, MMC_COOKIE cookie, RESULT_TYPES rsltType);
    HRESULT AddAttrPropPages(LPPROPERTYSHEETCALLBACK lpProvider,CResult *pResult,LONG_PTR handle);

// Result pane helpers
public:
    void SetupLinkServiceNodeToBase(BOOL bAdd, LONG_PTR theNode);
    void AddServiceNodeToProfile(PSCE_SERVICES pNode);
    int SetAnalysisInfo(ULONG_PTR dwItem, ULONG_PTR dwNew, CResult *pResult = NULL);
    int SetLocalPolInfo(ULONG_PTR dwItem, ULONG_PTR dwNew);
    void TransferAnalysisName(LONG_PTR dwItem);
    BOOL UpdateLocalPolRegValue( CResult * );
    LPTSTR GetAnalTimeStamp();

    CResult * AddResultItem(LPCTSTR Attrib, LONG_PTR setting, LONG_PTR base,
                       RESULT_TYPES type, int status,MMC_COOKIE cookie,
                       BOOL bVerify = FALSE, LPCTSTR unit = NULL, LONG_PTR nID = -1,
                       PEDITTEMPLATE pBaseInfo = NULL,
                       LPDATAOBJECT pDataObj = NULL,
                       CResult *pResult = NULL
                       );

    CResult * AddResultItem(UINT rID, LONG_PTR setting, LONG_PTR base,
                       RESULT_TYPES type, int status, MMC_COOKIE cookie,
                       BOOL bVerify = FALSE, PEDITTEMPLATE pBaseInfo = NULL,
                       LPDATAOBJECT pDataObj = NULL);

    void AddResultItem(LPCTSTR szName,PSCE_GROUP_MEMBERSHIP grpTemplate,
                       PSCE_GROUP_MEMBERSHIP grpInspect,MMC_COOKIE cookie,
                       LPDATAOBJECT pDataObj);

    HRESULT InitializeBitmaps(MMC_COOKIE cookie);
    HWND GetParentWindow() { return m_hwndParent; }

    BOOL CheckEngineTransaction();

// UI Helpers
    void HandleStandardVerbs(LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(LPARAM arg, LPARAM param);

public:
    LPCONSOLE
    GetConsole()
        { return m_pConsole; };

    DWORD
    UpdateAnalysisInfo(                        // Effects priviledge areas only.
        CResult *pResult,
        BOOL bDelete,
        PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
        LPCTSTR pszName = NULL
        );
   DWORD
    UpdateLocalPolInfo(                        // Effects priviledge areas only.
        CResult *pResult,
        BOOL bDelete,
        PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
        LPCTSTR pszName = NULL
        );

   DWORD
   GetResultItemIDs(
      CResult *pResult,
      HRESULTITEM *pIDArray,
      int nIDArray
      );

   LPRESULTDATA
   GetResultPane()
      { return m_pResult; };

    CFolder* GetSelectedFolder()
    { 
       return m_pSelectedFolder; 
    };

    DWORD GetModeBits() 
    {
        switch (((CComponentDataImpl *)m_pComponentData)->m_Mode)
        {
            case SCE_MODE_DOMAIN_COMPUTER:
            case SCE_MODE_OU_COMPUTER:
            case SCE_MODE_LOCAL_COMPUTER:
            case SCE_MODE_REMOTE_COMPUTER:
                return ((CComponentDataImpl *)m_pComponentData)->m_computerModeBits;
                break;

            case SCE_MODE_REMOTE_USER:
            case SCE_MODE_LOCAL_USER:
            case SCE_MODE_DOMAIN_USER:
            case SCE_MODE_OU_USER:
                return ((CComponentDataImpl *)m_pComponentData)->m_userModeBits;
                break;

            default:
                return ((CComponentDataImpl *)m_pComponentData)->m_computerModeBits;
                break;
        }
    }

   CWMIRsop* GetWMIRsop() 
   {
      return ((CComponentDataImpl *)m_pComponentData)->GetWMIRsop();
   }

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LPTSTR              m_szAnalTimeStamp;

    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar

// Header titles for each nodetype(s)
protected:
    CString m_multistrDisplay;
    CString m_colName;      // Name
    CString m_colDesc;      // Description
    CString m_colAttr;      // Attribute
    CString m_colBaseAnalysis;      // Baseline setting for Analysis
    CString m_colBaseTemplate;      // Baseline setting for Template
    CString m_colLocalPol; // Local policy setting
    CString m_colSetting;   // Current Setting

// result data
private:
    HINSTANCE hinstAclUI;
    //CList<CResult*, CResult*> m_resultItemList;
    CMap<LONG_PTR, LONG_PTR, CAttribute *, CAttribute *&> m_resultItemPopups;
    CMap<LONG_PTR, LONG_PTR, CPropertySheet *, CPropertySheet *&> m_resultItemPropSheets;
    MMC_COOKIE m_ShowCookie;
    CWinThread *m_pUIThread;
    HWND m_hwndParent;
    CHiddenWnd *m_pNotifier;

   HANDLE   m_resultItemHandle;
   CFolder *m_pSelectedFolder;

   CString m_strDisplay;
   int m_nColumns;
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));
    ASSERT(hr == S_OK);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);


void ConvertNameListToString(PSCE_NAME_LIST pList, LPTSTR *sz);
int GetScopeImageIndex( FOLDER_TYPES type, DWORD status = -1 );
int GetResultImageIndex( CFolder* pFolder, CResult* pResult );

// Cliboard Types
// Policy Area includes the Privileges Area
#define CF_SCE_ACCOUNT_AREA TEXT("CF_SCE_ACCOUNT_AREA")
#define CF_SCE_EVENTLOG_AREA TEXT("CF_SCE_EVENTLOG_AREA")
#define CF_SCE_LOCAL_AREA TEXT("CF_SCE_LOCAL_AREA")
#define CF_SCE_GROUPS_AREA TEXT("CF_SCE_GROUPS_AREA")
#define CF_SCE_REGISTRY_AREA TEXT("CF_SCE_REGISTRY_AREA")
#define CF_SCE_FILE_AREA TEXT("CF_SCE_FILE_AREA")
#define CF_SCE_SERVICE_AREA TEXT("CF_SCE_SERVICE_AREA")

extern UINT cfSceAccountArea;           // in snapmgr.cpp
extern UINT cfSceEventLogArea;           // in snapmgr.cpp
extern UINT cfSceLocalArea;           // in snapmgr.cpp
extern UINT cfSceGroupsArea;           // in snapmgr.cpp
extern UINT cfSceRegistryArea;         // in snapmgr.cpp
extern UINT cfSceFileArea;             // in snapmgr.cpp
extern UINT cfSceServiceArea;          // in snapmgr.cpp

extern SCE_COLUMNINFO g_columnInfo[];   // Default column information.

#define MB_NO_NATIVE_NODES       0x00000001
#define MB_SINGLE_TEMPLATE_ONLY  0x00000002
#define MB_DS_OBJECTS_SECTION    0x00000004
#define MB_NO_TEMPLATE_VERBS     0x00000008
#define MB_STANDALONE_NAME       0x00000010
#define MB_WRITE_THROUGH         0x00000020
#define MB_ANALYSIS_VIEWER       0x00000040
#define MB_TEMPLATE_EDITOR       0x00000080
#define MB_LOCAL_POLICY          0x00000100
#define MB_GROUP_POLICY          0x00000200
#define MB_LOCALSEC              0x00000400
#define MB_READ_ONLY             0x00000800
#define MB_RSOP                  0x00001000

#define GT_COMPUTER_TEMPLATE (TEXT("[[ Computer Template (not for display) ]]"))
#define GT_LAST_INSPECTION (TEXT("[[ Last Inspected Template (not for display) ]]"))
#define GT_LOCAL_POLICY (TEXT("[[ Local Policy Template (not for display) ]]"))
#define GT_LOCAL_POLICY_DELTA (TEXT("[[ Local Policy Template Changes (not for display) ]]"))
#define GT_EFFECTIVE_POLICY (TEXT("[[ Effective Policy Template (not for display) ]]"))
#define GT_DEFAULT_TEMPLATE (TEXT("[[ Default Template (not for display) ]]"))
#define GT_RSOP_TEMPLATE (TEXT("[[ RSOP Template (not for display) ]]"))

#define SCE_REGISTRY_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit")
#define SCE_REGISTRY_DEFAULT_TEMPLATE TEXT("DefaultTemplate")

#define DEFAULT_LOCATIONS_KEY SCE_REGISTRY_KEY TEXT("\\DefaultLocations")
#define CONFIGURE_LOG_LOCATIONS_KEY TEXT("ConfigureLog")
#define ANALYSIS_LOG_LOCATIONS_KEY TEXT("AnalysisLog")
#define OPEN_DATABASE_LOCATIONS_KEY TEXT("Database")
#define IMPORT_TEMPLATE_LOCATIONS_KEY TEXT("ImportTemplate")
#define EXPORT_TEMPLATE_LOCATIONS_KEY TEXT("ExportTemplate")

#endif // !WSECMGR_SNAPMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\snapmgr.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       snapmgr.cpp
//
//  Contents:   Core CComponentDataImpl and CSnapin routines for
//              Security Configuration Modules (Editor, Manager, Extension)
//
//  History:
//
//---------------------------------------------------------------------------



#include "stdafx.h"
#include "afxcmn.h"
#include "afxdlgs.h"
#include "cookie.h"
#include "snapmgr.h"
#include "DataObj.h"
#include "resource.h"
#include "wrapper.h"
#include "util.h"
#include "RegDlg.h"
#include "savetemp.h"
#include "getuser.h"
#include "servperm.h"
#include "addobj.h"
#include "perfanal.h"
#include "newprof.h"
#include "AddGrp.h"
#include "dattrs.h"

#define INITGUID
#include "scesetup.h"
#include "userenv.h"
#undef INITGUID
#include <gpedit.h>
// #include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CF_MACHINE_NAME                     L"MMC_SNAPIN_MACHINE_NAME"



long CSnapin::lDataObjectRefCount = 0;

BOOL RegisterCheckListWndClass(void); // in chklist.cpp

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

static MMCBUTTON SnapinButtons[] =
{
   { 0, 1, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Folder"), _T("New Folder")},
   { 1, 2, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),  _T("Mail Inbox")},
   { 2, 3, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Outbox"), _T("Mail Outbox")},
   { 3, 4, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Send"),   _T("Send Message")},
   { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),      _T("")},
   { 4, 5, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Trash"),  _T("Trash")},
   { 5, 6, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Open"),   _T("Open Folder")},
   { 6, 7, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("News"),   _T("Today's News")},
   { 7, 8, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("INews"),  _T("Internet News")},

};

static MMCBUTTON SnapinButtons2[] =
{
   { 0, 10, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Compose"),   _T("Compose Message")},
   { 1, 20, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Print"),     _T("Print Message")},
   { 2, 30, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Find"),      _T("Find Message")},
   { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),         _T("")},
   { 3, 40, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),     _T("Inbox")},
   { 4, 50, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Smile"),     _T("Smile :-)")},
   { 5, 60, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply"),     _T("Reply")},
   { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP   , _T(" "),         _T("")},
   { 6, 70, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply All"), _T("Reply All")},

};

UINT cfSceAccountArea;
UINT cfSceEventLogArea;
UINT cfSceLocalArea;
UINT cfSceGroupsArea;
UINT cfSceRegistryArea;
UINT cfSceFileArea;
UINT cfSceServiceArea;
///////////////////////////////////////////////////////////////////////////////
// RESOURCES

BEGIN_MENU(CSecmgrNodeMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CAnalyzeNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_OPEN_PRIVATE_DB, 0, 0)
CTX_ENTRY(IDM_ANALYZE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_APPLY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_ASSIGN, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_GENERATE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_VIEW_LOGFILE, 0, CCM_INSERTIONPOINTID_PRIMARY_VIEW)
CTX_ENTRY(IDM_SECURE_WIZARD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_OPEN_DB)
RES_ENTRY(IDS_ANALYZE_PROFILE)
RES_ENTRY(IDS_APPLY_PROFILE)
RES_ENTRY(IDS_SAVE_PROFILE)
RES_ENTRY(IDS_ASSIGN_CONFIGURATION)
RES_ENTRY(IDS_GENERATE_PROFILE)
RES_ENTRY(IDS_VIEW_LOGFILE)
RES_ENTRY(IDS_SECURE_WIZARD)
END_RES
END_MENU


BEGIN_MENU(CConfigNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_LOC, 0, CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_LOCATION)
END_RES
END_MENU

BEGIN_MENU(CLocationNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_NEW, 0, CCM_INSERTIONPOINTID_PRIMARY_NEW)
//CTX_ENTRY(IDM_REMOVE, 0)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_DESCRIBE_LOCATION, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_NEW_PROFILE)
//RES_ENTRY(IDS_REMOVE_LOCATION)
RES_ENTRY(IDS_RELOAD_LOCATION)
RES_ENTRY(IDS_DESCRIBE)
END_RES
END_MENU

BEGIN_MENU(CSSProfileNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_IMPORT_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_EXPORT_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_IMPORT_POLICY)
RES_ENTRY(IDS_EXPORT_POLICY)
RES_ENTRY(IDS_REFRESH_TEMPLATE)
END_RES
END_MENU


BEGIN_MENU(CRSOPProfileNodeMenuHolder)
BEGIN_CTX
//CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
//RES_ENTRY(IDS_REFRESH_TEMPLATE)
END_RES
END_MENU

BEGIN_MENU(CLocalPolNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_IMPORT_LOCAL_POLICY, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_RELOAD, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_IMPORT_POLICY)
RES_ENTRY(IDS_REFRESH_LOCALPOL)
END_RES
END_MENU

BEGIN_MENU(CProfileNodeMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_DESCRIBE_PROFILE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVE, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
CTX_ENTRY(IDM_SAVEAS, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_DESCRIBE)
RES_ENTRY(IDS_SAVE_PROFILE)
RES_ENTRY(IDS_SAVEAS_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileAreaMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileSubAreaMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CProfileSubAreaEventLogMenuHolder) //Raid #253209, Yang Gao, 3/27/2001
BEGIN_CTX
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileGroupsMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_GROUPS, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_GROUP)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileRegistryMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_REGISTRY, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_KEY)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CProfileFilesMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_FOLDER, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
CTX_ENTRY(IDM_COPY, 0,0)
CTX_ENTRY(IDM_PASTE, 0,0)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_FILES_AND_FOLDERS)
RES_ENTRY(IDS_COPY_PROFILE)
RES_ENTRY(IDS_PASTE_PROFILE)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeAreaMenuHolder)
BEGIN_CTX
END_CTX
BEGIN_RES
END_RES
END_MENU

BEGIN_MENU(CAnalyzeGroupsMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_GROUPS, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_GROUP)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeFilesMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_ANAL_FOLDER, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_FILES_AND_FOLDERS)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeRegistryMenuHolder)
BEGIN_CTX
CTX_ENTRY(IDM_ADD_ANAL_KEY, 0,CCM_INSERTIONPOINTID_PRIMARY_NEW)
END_CTX
BEGIN_RES
RES_ENTRY(IDS_ADD_KEY)
END_RES
END_MENU

BEGIN_MENU(CAnalyzeObjectsMenuHolder)
BEGIN_CTX
//CTX_ENTRY(IDM_OBJECT_SECURITY,0,CCM_INSERTIONPOINTID_PRIMARY_TASK)
END_CTX
BEGIN_RES
//RES_ENTRY(IDS_SECURITY_MENU)
END_RES
END_MENU


////////////////////////////////////////////////////////////
// Implementation

template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf)
{
   ASSERT(lpDataObject != NULL);

   //Raid #202964, 4/17/2001
   if ( lpDataObject == NULL || (LPDATAOBJECT) MMC_MULTI_SELECT_COOKIE == lpDataObject )
   {
      return NULL;
   }
   TYPE* p = NULL;

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL};
   FORMATETC formatetc = {
      cf,
      NULL,
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   HRESULT hRet = S_OK;

   // Allocate memory for the stream
   stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(TYPE));

   // Attempt to get data from the object
   do {
      if (stgmedium.hGlobal == NULL)
         break;


   hRet = lpDataObject->GetDataHere(&formatetc, &stgmedium);
      //
      // So far there are only two conditions in which we want to check for a multi select
      // 1.  If the GetDataHere fails, then we should check to see if this is a mutli
      //     select case.
      // 2.  If GetDataHere succeeded but we got a specail cookie instead of a valid
      //     SCE cookie we again want to call GetData to see if we have mutli select data
      //     in the CDataObject.
      //

      if( FAILED(hRet) ||
         (formatetc.cfFormat == CDataObject::m_cfInternal &&
          IS_SPECIAL_COOKIE( ((INTERNAL *)stgmedium.hGlobal)->m_cookie) ) ) {

         GlobalFree(stgmedium.hGlobal);

         //
         // See if this data object is a mutli select.
         //
         ZeroMemory(&formatetc, sizeof(FORMATETC));

         formatetc.tymed = TYMED_HGLOBAL;
         formatetc.cfFormat = (CLIPFORMAT)::RegisterClipboardFormat( CCF_MULTI_SELECT_SNAPINS );
         stgmedium.hGlobal  = NULL;

         if( FAILED(hRet )){
            //
            // If get data here failed, then try to get the information by calling GetData.
            // In multi select mode we get a data object to the snapins that have the data objects.
            //
            if( SUCCEEDED( lpDataObject->GetData(&formatetc, &stgmedium) ) ){
               SMMCDataObjects *pObjects = (SMMCDataObjects *)GlobalLock( stgmedium.hGlobal );
               if(pObjects && pObjects->count){
                  lpDataObject = pObjects->lpDataObject[0];
                  GlobalUnlock( stgmedium.hGlobal );

                  if(lpDataObject){
                     ReleaseStgMedium( &stgmedium );
                     formatetc.cfFormat = (CLIPFORMAT)CDataObject::m_cfInternal;
                     stgmedium.hGlobal  = NULL;
                     lpDataObject->GetData(&formatetc, &stgmedium);
                  }
               }
            }
         } else {
            //
            // The data object is ours and a special cookie was recieved from GetDataHere.
            // this probably means that we have a mutli select, so look for it.
            //
            formatetc.cfFormat = (CLIPFORMAT)CDataObject::m_cfInternal;
            lpDataObject->GetData(&formatetc, &stgmedium);
         }

      }

      p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

      if (p == NULL)
         break;

   } while (FALSE);

   return p;
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
   return Extract<INTERNAL>(lpDataObject, (CLIPFORMAT) CDataObject::m_cfInternal);
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
   return Extract<GUID>(lpDataObject, (CLIPFORMAT)CDataObject::m_cfNodeType);
}

PWSTR ExtractMachineName(LPDATAOBJECT lpDataObject, CLIPFORMAT cf)
{
   if ( lpDataObject == NULL ) {
      return NULL;
   }

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL};
   FORMATETC formatetc = { cf, NULL,
      DVASPECT_CONTENT, -1, TYMED_HGLOBAL
   };
   //
   // Allocate memory for the stream
   //
   stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, (MAX_PATH+1)*sizeof(WCHAR));

   //
   // Attempt to get data from the object
   //
   HRESULT hr = S_FALSE;
   PWSTR p=NULL;

   do {
      if (stgmedium.hGlobal == NULL)
         break;

      if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium))) {
         GlobalFree(stgmedium.hGlobal);
         break;
      }

      p = reinterpret_cast<WCHAR*>(stgmedium.hGlobal);

      if (p == NULL)
         break;

   } while (FALSE);

   return p;
}


/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation
//+--------------------------------------------------------------------------------------
// CSnapin::GetResultViewType
//
// Since we need to display an HTML file for the error message, we check for errors
// in this function.
//
// If there is some error, this function writes a temporary HTML file, and sets
// the view type to an HTML file.
//
// Arguments:  [cookie]       - The cookie associated with the scope pane item being
//                               displyaed.
//             [ppViewType]   - The type of view we want.
//             [pViewOptions] - The options for the view.
//
// Returns:    S_OK  - We want MMC to display the specifide view type.
//---------------------------------------------------------------------------------------
STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
                                        LONG* pViewOptions)
{
#define pComponentImpl reinterpret_cast<CComponentDataImpl *>(m_pComponentData)

   CFolder *pFolder = reinterpret_cast<CFolder *>(cookie);


   CString sHtmlFile;
   FOLDER_TYPES fType = STATIC;
   HRESULT hr=S_OK;

   //
   // Delete the old temporary file.
   //
   if( !pComponentImpl->m_strTempFile.IsEmpty() ){
      DeleteFile( pComponentImpl->m_strTempFile );
   }

   //
   // What kind of error do we want to display.
   //
   if( pFolder ){
      fType = pFolder->GetType();
   } else {
      switch( GetImplType() ){
      case  SCE_IMPL_TYPE_SAV:
         fType = ANALYSIS;
         break;
      }
   }

   //
   // Errors supported. We have to create an html file and set sHtmlFile to a
   // valid source if we want an error to be displayed.
   //

   CWriteHtmlFile ht;
   switch(fType){
   case LOCATIONS:
      //
      // Need to check Location areas for permissions, and to see if it exists at all.
      //
      pFolder->GetDisplayName( sHtmlFile, 0 );

      //
      // Set the current working directory.
      //
      if( !SetCurrentDirectory( sHtmlFile ) ){
         //
         // Get the error message and write the HTML file.
         //
         LPTSTR pszMsg;
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPTSTR)&pszMsg,
                        0,
                        NULL
                        );
         ht.Create();
         ht.Write(IDS_BAD_LOCATION);

         if(pszMsg){
            ht.Write(pszMsg);
            LocalFree(pszMsg);
         }
         pFolder->SetState( CFolder::state_InvalidTemplate );
      } else {
         pFolder->SetState( 0, ~CFolder::state_InvalidTemplate );
      }
      break;
   case LOCALPOL_ACCOUNT:
   case LOCALPOL_LOCAL:
   case LOCALPOL_EVENTLOG:
   case LOCALPOL_PASSWORD:
   case LOCALPOL_KERBEROS:
   case LOCALPOL_LOCKOUT:
   case LOCALPOL_AUDIT:
   case LOCALPOL_OTHER:
   case LOCALPOL_LOG:
   case LOCALPOL_PRIVILEGE:
      //
      // Load the sad info.
      //
      pComponentImpl->LoadSadInfo(FALSE);
      break;
   case PROFILE:
      //
      // Template error messages.
      //
      if(pFolder->GetModeBits() & MB_NO_NATIVE_NODES ){
         break;
      }

      if( pFolder->GetState() & CFolder::state_Unknown ){
         // We must load the template and find out if it is a valid
         // configuration template.
         if(!GetTemplate( pFolder->GetInfFile(), AREA_USER_SETTINGS)){
            pFolder->SetState( CFolder::state_InvalidTemplate, ~CFolder::state_Unknown );
         } else {
            pFolder->SetState( 0, ~CFolder::state_Unknown );
         }
      }

      if( pFolder->GetState() & CFolder::state_InvalidTemplate ){
         ht.Create();
         ht.Write( IDS_ERROR_CANT_OPEN_PROFILE );
      }
      break;
   case ANALYSIS:
      //
      // Analysis Error messages.
      //
      if( pComponentImpl->m_bIsLocked ){
         //
         // We are configuring or analyzing the database
         //
         ht.Create();
         ht.Write( IDS_ERROR_ANALYSIS_LOCKED );
      } else if( pComponentImpl->SadName.IsEmpty() ){
         //
         // Display the start screen.
         //
         ht.Create();
         ht.Write( IDS_HTML_OPENDATABASE );
      } else if( pComponentImpl->m_dwFlags & CComponentDataImpl::flag_showLogFile &&
                 pComponentImpl->GetErroredLogFile() ){
         //
         // Display the error log file.
         //
         ht.Create();
         ht.Write( L"<B>" );
         ht.Write( IDS_VIEW_LOGFILE_TITLE );
         ht.Write( pComponentImpl->GetErroredLogFile() );
         ht.Write( L"</B><BR>" );
         ht.CopyTextFile( pComponentImpl->GetErroredLogFile(), pComponentImpl->m_ErroredLogPos );
      } else if( SCESTATUS_SUCCESS != pComponentImpl->SadErrored  ){

         ht.Create();
         ht.Write( L"<B>%s</B><BR><BR>", (LPCTSTR)pComponentImpl->SadName );

         //
         // This block of code will be removed as soon the engine returns us
         // a more useful error message if the database does not contain sad info.
         //
         WIN32_FIND_DATA fd;
         HANDLE handle = FindFirstFile( pComponentImpl->SadName, &fd );

         if(handle != INVALID_HANDLE_VALUE){
            FindClose(handle);
            if( pComponentImpl->SadErrored == SCESTATUS_PROFILE_NOT_FOUND ){
               ht.Write( IDS_DBERR5_NO_ANALYSIS );
            } else {
               goto write_normal_error;
            }
         } else {
write_normal_error:
            CString str;
            FormatDBErrorMessage( pComponentImpl->SadErrored, NULL, str);
            ht.Write( str );
         }
      }
      break;
   }

   DWORD dwSize = ht.GetFileName(NULL, 0);
   if(dwSize){
      //
      // We want to display an HTML file.
      //
      *ppViewType = (LPOLESTR)LocalAlloc( 0, sizeof(TCHAR) * (dwSize + 1));
      if(!*ppViewType){
         ht.Close( TRUE );
         goto normal;
      }

      ht.GetFileName( (LPTSTR)*ppViewType, dwSize + 1);
      pComponentImpl->m_strTempFile = *ppViewType;
      *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
   } else {
normal:
      //
      // Normal list view.
      //
      *ppViewType = NULL;
      *pViewOptions = MMC_VIEW_OPTIONS_NONE;

      //
      // S_FALSE means normal list view, S_OK means HTML or OCX
      //
      hr = S_FALSE;

      if(pFolder) {
         //
         // For mutli select, just add, or remove the case to enable multi select for a folder
         //
         switch( pFolder->GetType() ){
         case AREA_REGISTRY:
         case AREA_FILESTORE:
         case AREA_GROUPS:
         case AREA_GROUPS_ANALYSIS:
            *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
            break;
         }
      }
   }
   return hr;
#undef pComponentImpl
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
   ASSERT(lpConsole != NULL);

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Save the IConsole pointer
   m_pConsole = lpConsole;
   m_pConsole->AddRef();

   // Load resource strings
   LoadResources();

   // QI for a IHeaderCtrl
   HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                                           reinterpret_cast<void**>(&m_pHeader));

   // Give the console the header control interface pointer
   if (SUCCEEDED(hr)) {
      m_pConsole->SetHeader(m_pHeader);
   }
   if (!SUCCEEDED(m_pConsole->GetMainWindow(&m_hwndParent))) {
      m_pConsole->Release();
      return E_FAIL;
   }

   m_pConsole->QueryInterface(IID_IResultData,
                              reinterpret_cast<void**>(&m_pResult));

   hr = m_pConsole->QueryResultImageList(&m_pImageResult);
   ASSERT(hr == S_OK);

   hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
   ASSERT(hr == S_OK);


   return S_OK;
}


STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   HRESULT hr = S_FALSE;
   MMC_COOKIE cookie;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (event == MMCN_PROPERTY_CHANGE) {
      hr = OnPropertyChange(lpDataObject);
   } else if (event == MMCN_VIEW_CHANGE) {
      hr = OnUpdateView(lpDataObject,arg,param);
   } else {
      INTERNAL* pInternal = NULL;

      switch (event) {
         case MMCN_COLUMNS_CHANGED:
            hr = S_FALSE;
            break;

         case MMCN_ACTIVATE:
            break;

         case MMCN_CLICK:
         case MMCN_DBLCLICK:
            break;

         case MMCN_SHOW:
            // pass a file name and file handle
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            hr = OnShow(lpDataObject,pInternal->m_cookie, arg, param);
            break;

         case MMCN_MINIMIZED:
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            hr = OnMinimize(pInternal->m_cookie, arg, param);
            break;

         case MMCN_SELECT:
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            HandleStandardVerbs(arg, lpDataObject);
            break;

         case MMCN_BTN_CLICK:
            break;

         case MMCN_ADD_IMAGES: {
            InitializeBitmaps(NULL);
            break;
         }

         case MMCN_SNAPINHELP:
         case MMCN_CONTEXTHELP: {
            CString strTopic;
            CString strPath;
            LPTSTR szPath;
            LPDISPLAYHELP pDisplayHelp;

            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }

            hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                                            reinterpret_cast<void**>(&pDisplayHelp));
            ASSERT(hr == S_OK);
            if (SUCCEEDED(hr)) {
               szPath = strPath.GetBuffer(MAX_PATH);
               ::GetWindowsDirectory(szPath,MAX_PATH);
               strPath.ReleaseBuffer();
               FOLDER_TYPES type = ((CFolder *)pInternal->m_cookie)->GetType(); //Yanggao  1/31/2001 Bug258658
               switch (((CComponentDataImpl*)m_pComponentData)->GetImplType()) {
                  case SCE_IMPL_TYPE_SCE:
                     strTopic.LoadString(IDS_HTMLHELP_SCE_TOPIC);
                     break;
                  case SCE_IMPL_TYPE_SAV:
                     strTopic.LoadString(IDS_HTMLHELP_SCM_TOPIC);
                     break;
                  case SCE_IMPL_TYPE_EXTENSION:
                     {
                     // Raid #258658. 4/10/2001, Go to different .chm for security policy. 
                        CFolder* pFolder = (CFolder *) pInternal->m_cookie;
                        DWORD tempmode = pFolder->GetMode();
                        if( SCE_MODE_LOCAL_COMPUTER == tempmode ||
                             SCE_MODE_LOCAL_USER == tempmode )
                        {
                            strTopic.LoadString(IDS_HTMLHELP_LPPOLICY_TOPIC);
                        }
                        else
                        {
                            strTopic.LoadString(IDS_HTMLHELP_POLICY_TOPIC);
                        }
                        break;
                     }
                  case SCE_IMPL_TYPE_LS:
                     strTopic.LoadString(IDS_HTMLHELP_LS_TOPIC);
                  default:
                     ASSERT(0);
               }
               strPath += strTopic;
               szPath = (LPTSTR)CoTaskMemAlloc(sizeof(LPTSTR) * (strPath.GetLength()+1));
               if (szPath) {
                  lstrcpy(szPath,strPath);

                  hr = pDisplayHelp->ShowTopic(T2OLE((LPWSTR)(LPCWSTR)szPath));
               }
               pDisplayHelp->Release();
            }
            break;
         }

         case MMCN_DELETE:
            // add for delete operations
            // AfxMessageBox(_T("CSnapin::MMCN_DELETE"));
            pInternal = ExtractInternalFormat(lpDataObject);
            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }
            OnDeleteObjects(lpDataObject,
                            CCT_RESULT,
                            pInternal->m_cookie,
                            arg,
                            param);
            break;

         case MMCN_RENAME:
            //AfxMessageBox(_T("CSnapin::MMCN_RENAME\n"));
            break;

         case MMCN_PASTE:
            //         OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());
            break;

         case MMCN_QUERY_PASTE:
            break;
            // Note - Future expansion of notify types possible
         default: {
            }
            hr = E_UNEXPECTED;
            break;
      }

      if (pInternal) {
         FREE_INTERNAL(pInternal);
      }
   }

   //  if (m_pResult)
   //     m_pResult->SetDescBarText(_T("hello world"));
   return hr;
}

STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DeleteList(FALSE);

   // Release the interfaces that we QI'ed
   if (m_pConsole != NULL) {
      // Tell the console to release the header control interface
      m_pConsole->SetHeader(NULL);
      SAFE_RELEASE(m_pHeader);

      SAFE_RELEASE(m_pResult);
      SAFE_RELEASE(m_pImageResult);

      // Release the IConsole interface last
      SAFE_RELEASE(m_pConsole);
      SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

      SAFE_RELEASE(m_pConsoleVerb);
   }
   if (g_hDsSecDll) {
      FreeLibrary(g_hDsSecDll);
      g_hDsSecDll = NULL;
   }
   return S_OK;
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                      LPDATAOBJECT* ppDataObject)
{
   HRESULT hr = E_FAIL;

   // Delegate it to the IComponentData
   int iCnt = 0;
   if( cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE ){
      RESULTDATAITEM ri;
      ZeroMemory( &ri, sizeof(RESULTDATAITEM));
      ri.mask = RDI_INDEX | RDI_STATE;
      ri.nIndex = -1;
      ri.nState = LVIS_SELECTED;

      BOOL bCreate = TRUE;
      while( m_pResult->GetNextItem(&ri) == S_OK){
         iCnt++;
         if( ri.bScopeItem ){
            //
            // will not allow actions to be performed on scope items.
            //
            bCreate = FALSE;
            break;
         }
      }

      if(bCreate){
         ri.nIndex = -1;

         if( m_pResult->GetNextItem(&ri) == S_OK){

            cookie = (MMC_COOKIE)ri.lParam;
            type   = CCT_RESULT;

            CComObject<CDataObject>* pObject;

            hr = CComObject<CDataObject>::CreateInstance(&pObject);
            if (!SUCCEEDED(hr)) {
               return hr;
            }
            ASSERT(pObject != NULL);
            if (NULL == pObject) {
               return E_FAIL;
            }

            pObject->SetClsid( reinterpret_cast<CComponentDataImpl *>(m_pComponentData)->GetCoClassID() );

            if(m_pSelectedFolder){
               pObject->SetFolderType( m_pSelectedFolder->GetType() );
            }

            do {
               pObject->AddInternal( (MMC_COOKIE)ri.lParam, CCT_RESULT );
            } while( m_pResult->GetNextItem(&ri) == S_OK );

            return  pObject->QueryInterface(IID_IDataObject,
                                            reinterpret_cast<void**>(ppDataObject));
         }
      }

   }
   ASSERT(m_pComponentData != NULL);
   return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
{
   DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
   CSnapin::lDataObjectRefCount = 0;
   RegisterCheckListWndClass();
   Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
   ASSERT(dbg_cRef == 0);
#endif

   DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

   SAFE_RELEASE(m_pToolbar1);
   SAFE_RELEASE(m_pToolbar2);

   SAFE_RELEASE(m_pControlbar);
   SAFE_RELEASE(m_pConsoleVerb);
   SAFE_RELEASE(m_pImageResult);


   // Make sure the interfaces have been released
   ASSERT(m_pConsole == NULL);
   ASSERT(m_pHeader == NULL);
   ASSERT(m_pToolbar1 == NULL);
   ASSERT(m_pToolbar2 == NULL);

   delete m_pbmpToolbar1;
   delete m_pbmpToolbar2;

   if (m_szAnalTimeStamp) {
      LocalFree(m_szAnalTimeStamp);
      m_szAnalTimeStamp = NULL;
   }

   Construct();
   //If don't save template, CSnapin::lDataObjectRefCount will be 1 here.
   ASSERT(CSnapin::lDataObjectRefCount == 0 || CSnapin::lDataObjectRefCount == 1);

}

void CSnapin::Construct()
{
#if DBG==1
   dbg_cRef = 0;
#endif

   m_pConsole = NULL;
   m_pHeader = NULL;

   m_pResult = NULL;
   m_pImageResult = NULL;
   m_pComponentData = NULL;
   m_pToolbar1 = NULL;
   m_pToolbar2 = NULL;
   m_pControlbar = NULL;

   m_pbmpToolbar1 = NULL;
   m_pbmpToolbar2 = NULL;

   m_pConsoleVerb = NULL;
   m_szAnalTimeStamp = NULL;

   m_pNotifier = NULL;
   m_hwndParent = 0;
   m_pSelectedFolder = NULL;
   m_nColumns = 0;
}

void CSnapin::LoadResources()
{
   // Load strings from resources
   m_colName.LoadString(IDS_NAME);
   m_colDesc.LoadString(IDS_DESC);
   m_colAttr.LoadString(IDS_ATTR);
   m_colBaseAnalysis.LoadString(IDS_BASE_ANALYSIS);
   m_colBaseTemplate.LoadString(IDS_BASE_TEMPLATE);
   m_colLocalPol.LoadString(IDS_LOCAL_POLICY_COLUMN);
   m_colSetting.LoadString(IDS_SETTING);
}


//+--------------------------------------------------------------------------
//
//  Function:   GetDisplayInfo
//
//  Synopsis:   Get the string or icon to be displayed for a given result item
//
//  Arguments:  [pResult] - the result item to get display info for and the
//                          type of information to be retrieved
//
//  Returns:    The information to be retrieved in the appropriate field of
//              pResult (str for strings, nImage for icons)
//
//---------------------------------------------------------------------------
STDMETHODIMP CSnapin::GetDisplayInfo(RESULTDATAITEM *pResult)
{
   CString str;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ASSERT(pResult != NULL);

   m_strDisplay.Empty();
   LPTSTR szAlloc = NULL;

   if (pResult) 
   {
      CString  tmpstr;
      int      npos = 0;
      CFolder* pFolder = 0;
      CString  strIndent;

      if (pResult->bScopeItem == TRUE) 
      {
         //
         // pResult is a scope item, not a result item
         //

         pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
         if( pResult->mask & RDI_STR)
         {
            if( pFolder->GetDisplayName( m_strDisplay, pResult->nCol ) == ERROR_SUCCESS)
            {
                pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
            }

         }

         if ( pResult->mask & RDI_IMAGE ) 
         {
            pResult->nImage = pFolder->GetScopeItem()->nImage;
         }
      } 
      else 
      {
         CResult* pData = reinterpret_cast<CResult*>(pResult->lParam);
         pFolder = m_pSelectedFolder; //(CFolder*)(pData->GetCookie());

         if (pResult->mask & RDI_IMAGE) 
         {
            //
            // queries the icon index
            //
            int nImage = GetResultImageIndex(pFolder,
                                             pData);

            pResult->nImage = nImage;
         }
         if( pResult->mask & RDI_STR ) 
         {
            if ( pFolder && pResult->nCol &&
               ( pFolder->GetType() == AREA_SERVICE ||
                 pFolder->GetType() == AREA_SERVICE_ANALYSIS) ) 
            {
                  //
                  // service node
                  //
                  GetDisplayInfoForServiceNode(pResult, pFolder, pData);
            } 
            else if ( pData->GetDisplayName( pFolder, m_strDisplay, pResult->nCol ) == ERROR_SUCCESS )
            {
                if( pData->GetID() == SCE_REG_DISPLAY_MULTISZ ) //Bug349000, Yang Gao, 2/23/2001
                {
                   MultiSZToDisp(m_strDisplay, m_multistrDisplay);
                   pResult->str = (LPOLESTR)(LPCTSTR)m_multistrDisplay;
                }
                else
                {
                   pResult->str = (LPOLESTR)(LPCTSTR)m_strDisplay;
                }
            }
         }
      }
   }
   return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                   LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                   LONG* pInsertionAllowed)
{
   // if scope item, then call CComponentDataImpl.AddMenuItems
   // else build menu item here for result items.
   INTERNAL* pAllInternal = ExtractInternalFormat(pDataObject);
   INTERNAL* pInternal = NULL;

   CONTEXTMENUITEM cmi;
   HRESULT hr = S_OK;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   MMC_COOKIE cookie = NULL;
   DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;

   pInternal = pAllInternal;
   if (pAllInternal == NULL) {
      return S_OK;
   } else if(pAllInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE){

      //
      // Currently we do not support any options except for delete if there is a mutli select.
      // Remove the comment below to allow other menu items for the CCT_RESULT type.
      //pInternal++;
   }


   if (CCT_RESULT == pInternal->m_type) {
#if defined(USE_SECURITY_VERB)
      CResult *pResult;
      //
      // In the result pane add the Security... menu item
      //
      pResult = (CResult *)pInternal->m_cookie;

      if (pResult && (pResult->GetType() != ITEM_OTHER)) {
         //
         // It's an editable type, so add the menu item
         //
         CString strSecurity;
         CString strSecurityDesc;

         strSecurity.LoadString(IDS_SECURITY_MENU_ITEM);
         strSecurityDesc.LoadString(IDS_SECURITY_MENU_ITEM_DESC);

         ZeroMemory(&cmi,sizeof(cmi));
         cmi.strName = strSecurity.GetBuffer(0);;
         cmi.strStatusBarText = strSecurityDesc.GetBuffer(0);

         cmi.lCommandID = MMC_VERB_OPEN;

         cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
         cmi.fFlags = MF_ENABLED|MF_STRING;
         cmi.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;

         hr = pContextMenuCallback->AddItem(&cmi);
      }
#endif

   } else if(CCT_SCOPE == pInternal->m_type && (*pInsertionAllowed) & CCM_INSERTIONALLOWED_NEW ) {
      //
      // Insert menus for the scope item.
      //
      hr = ((CComponentDataImpl*)m_pComponentData)->AddMenuItems(pDataObject,
                                                                 pContextMenuCallback, pInsertionAllowed);
   }

   FREE_INTERNAL(pAllInternal);
   return hr;
}

STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
   // if scope item, then call CComponentDataImpl.AddMenuItems
   // else build menu item here for result items.

   INTERNAL* pAllInternal = ExtractInternalFormat(pDataObject);
   INTERNAL* pInternal = NULL;
   HRESULT hr=S_OK;

   int iCnt = 1;
   pInternal = pAllInternal;
   if (pInternal == NULL) {
      // Actually looking for our extension
      return S_OK;
   } else if( pInternal->m_cookie == MMC_MULTI_SELECT_COOKIE ){
      iCnt = (int)pInternal->m_type;
      pInternal++;
   }

   while( iCnt-- ){
      hr = ((CComponentDataImpl*)m_pComponentData)->Command(nCommandID, pDataObject);
      pInternal++;
   }

   if (pAllInternal) {
      FREE_INTERNAL(pAllInternal);
   }
   return hr;
}
/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                          LONG_PTR handle,
                                          LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (!lpDataObject || !lpProvider || !handle) {
      return E_INVALIDARG;
   }
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
   if (!pInternal) 
   {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) 
   {
      return S_FALSE;
   } 
   else if (pInternal->m_type == CCT_RESULT) 
   {
      return AddAttrPropPages(lpProvider,(CResult*)pInternal->m_cookie,handle);
   }

   return S_FALSE;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpDataObject) {
      return E_INVALIDARG;
   }

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   if (!pInternal) {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) {
      //
      // Don't currently support properties for multiselect or anything
      //
      return S_FALSE;
   } else {
      RESULT_TYPES type = ((CResult *)pInternal->m_cookie)->GetType();
      if (ITEM_OTHER != type) {
         return S_OK;
      } else {
         return S_FALSE;
      }
   }
   return S_FALSE;
}

DWORD CComponentDataImpl::m_GroupMode = SCE_MODE_UNKNOWN;
///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl() :
    m_computerModeBits (0),
    m_userModeBits (0),
    m_bEnumerateScopePaneCalled (false)
{
   DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

   m_pScope = NULL;
   m_pConsole = NULL;
   m_bIsDirty = FALSE;
   m_bIsLocked = FALSE;
   m_AnalFolder = NULL;
   m_szSingleTemplateName = NULL;
   m_bDeleteSingleTemplate = FALSE;
   m_pUIThread = NULL;
   m_pNotifier = NULL;

   SadName.Empty();
   SadLoaded = FALSE;
   SadHandle = NULL;
   SadErrored = SCESTATUS_PROFILE_NOT_FOUND;
   SadTransStarted = FALSE;

   m_pszErroredLogFile = NULL;
   m_dwFlags = 0;

   m_pGPTInfo = NULL;
   m_pRSOPInfo = NULL;
   m_pWMIRsop = NULL;

   cfSceAccountArea = RegisterClipboardFormat(CF_SCE_ACCOUNT_AREA);
   cfSceEventLogArea = RegisterClipboardFormat(CF_SCE_EVENTLOG_AREA);
   cfSceLocalArea = RegisterClipboardFormat(CF_SCE_LOCAL_AREA);
   cfSceGroupsArea = RegisterClipboardFormat(CF_SCE_GROUPS_AREA);
   cfSceRegistryArea = RegisterClipboardFormat(CF_SCE_REGISTRY_AREA);
   cfSceFileArea = RegisterClipboardFormat(CF_SCE_FILE_AREA);
   cfSceServiceArea = RegisterClipboardFormat(CF_SCE_SERVICE_AREA);

   InitializeCriticalSection(&csAnalysisPane);
}


CComponentDataImpl::~CComponentDataImpl()
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

   ASSERT(m_pScope == NULL);
   //If don't save template, CSnapin::lDataObjectRefCount will be 1 here.
   ASSERT(CSnapin::lDataObjectRefCount == 0 || CSnapin::lDataObjectRefCount == 1);


   if( m_pszErroredLogFile )
   {
      LocalFree( m_pszErroredLogFile );
   }

   //
   // NT5 only
   //
   if (m_szSingleTemplateName) 
   {

      if (m_bDeleteSingleTemplate) 
	  {
         DeleteFile(m_szSingleTemplateName);
      }
      LocalFree(m_szSingleTemplateName);
   }

   // Delete templates.
   POSITION pos = m_Templates.GetStartPosition();
   PEDITTEMPLATE pTemplate;
   CString strKey;
   while (pos) 
   {
      m_Templates.GetNextAssoc(pos,strKey,pTemplate);
      if (pTemplate && pTemplate->pTemplate) 
	  {
         SceFreeProfileMemory(pTemplate->pTemplate);
         pTemplate->pTemplate = NULL;
      }
      if (NULL != pTemplate) 
	  {
         delete pTemplate;
      }
   }

   if (NULL != m_pUIThread) 
   {
      delete m_pUIThread;
   }

   if( m_pNotifier ) //Memory leak, 4/27/2001
   {
      delete m_pNotifier;
   }
   // Delete column information structure.
   pos = m_mapColumns.GetStartPosition();
   FOLDER_TYPES fTypes;
   while(pos)
   {
       PSCE_COLINFOARRAY pCols;
       m_mapColumns.GetNextAssoc(pos, fTypes, pCols);
       if (pCols)
	   {
          LocalFree(pCols);
       }
   }
   m_mapColumns.RemoveAll();

   if (m_pWMIRsop) 
   {
      delete m_pWMIRsop;
   }
   DeleteCriticalSection(&csAnalysisPane);

   if ( m_pGPTInfo )
	   m_pGPTInfo->Release ();
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
   ASSERT(pUnknown != NULL);
   HRESULT hr;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   AfxInitRichEdit();

   m_pNotifier = new CHiddenWnd;
   if (NULL == m_pNotifier) {
      return E_FAIL;
   }


   // MMC should only call ::Initialize once!
   ASSERT(m_pScope == NULL);
   pUnknown->QueryInterface(IID_IConsoleNameSpace2,
                            reinterpret_cast<void**>(&m_pScope));

   // add the images for the scope tree
   CBitmap bmp16x16;
   CBitmap bmp32x32;
   LPIMAGELIST lpScopeImage;

   hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
   ASSERT(hr == S_OK);

   hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
   //
   // Create the hidden notifications window.  This window is so that our
   // secondary UI thread can post messages to the main thread which can
   // then be forwarded on to the otherwise unmarshalled MMC COM interfaces.
   //
   //   if (!m_pNotifier->Create(NULL,L"SCE Notifications Window",WS_OVERLAPPED,CRect(0,0,0,0),NULL,0)) {
   if (!m_pNotifier->CreateEx(0,
                              AfxRegisterWndClass(0),
                              L"SCE Notifications Window",
                              0,
                              0,0,0,0,
                              0,
                              0,
                              0)) {
      m_pConsole->Release();
      pUnknown->Release();
      delete m_pNotifier;
      m_pNotifier = NULL;
      return E_FAIL;
   }
   m_pNotifier->SetConsole(m_pConsole);
   m_pNotifier->SetComponentDataImpl(this);

   ASSERT(hr == S_OK);

   // Load the bitmaps from the dll
   bmp16x16.LoadBitmap(IDB_ICON16 /*IDB_16x16 */);
   bmp32x32.LoadBitmap(IDB_ICON32 /*IDB_32x32 */);

   // Set the images
   lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                                   reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                                   0, RGB(255, 0, 255));

   lpScopeImage->Release();

   m_pUIThread = AfxBeginThread(RUNTIME_CLASS(CUIThread));

   m_fSvcNotReady = FALSE;
   m_nNewTemplateIndex = 0;

   //
   // Create the root folder list, If the root isn't created, then when the user
   // right clicks to choose a database the menu command is not executed.
   //
   //
   if(GetImplType() == SCE_IMPL_TYPE_SAV)
      CreateFolderList( NULL, ROOT, NULL, NULL);

   return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
   ASSERT(ppComponent != NULL);

   CComObject<CSnapin>* pObject;

   HRESULT hr = CComObject<CSnapin>::CreateInstance(&pObject);
   if (!SUCCEEDED(hr))
      return hr;

   if (!SUCCEEDED(m_pConsole->GetMainWindow(&m_hwndParent))) 
   {
   }

   // Store IComponentData
   pObject->SetIComponentData(this);
   pObject->m_pUIThread = m_pUIThread;
   pObject->m_pNotifier = m_pNotifier;

   return  pObject->QueryInterface(IID_IComponent,
                                   reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   ASSERT(m_pScope != NULL);
   HRESULT hr = S_FALSE;
   //   CFolder* pFolder = NULL;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   INTERNAL* pInternal = NULL;

   // Since it's my folder it has an internal format.
   // Design Note: for extension.  I can use the fact, that the data object doesn't have
   // my internal format and I should look at the node type and see how to extend it.
   if (event == MMCN_PROPERTY_CHANGE) {
      hr = OnProperties(param);
   } else {
      /*
            INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

            if (pInternal == NULL) {
               // Actually looking for our extension
               return S_OK;
            }

            long cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
      */
      switch (event) {
         case MMCN_DELETE:
            hr = OnDelete(lpDataObject, arg, param);
            break;

         case MMCN_RENAME:
            hr = OnRename(lpDataObject, arg, param);
            break;

         case MMCN_EXPAND:
            hr = OnExpand(lpDataObject, arg, param);
            break;

         case MMCN_CONTEXTMENU:
            hr = OnContextMenu(lpDataObject, arg, param);
            break;

         case MMCN_BTN_CLICK:
            break;

         case MMCN_SELECT: {
               break;
            }
         case MMCN_PASTE: {
            pInternal = ExtractInternalFormat(lpDataObject);
               if (pInternal) {
                  MMC_COOKIE cookie = pInternal->m_cookie;

                  if ( cookie ) {
                      CFolder *pFolder = (CFolder*)cookie;
                      OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());
                  }
               }
               break;
            }
         case MMCN_REMOVE_CHILDREN: {
            if (NULL != m_pNotifier) {
               m_pNotifier->DestroyWindow();
               delete m_pNotifier;
               m_pNotifier = NULL;
            }

            POSITION pos;
            pos = m_scopeItemPopups.GetStartPosition();
            LONG_PTR key;
            CDialog *pDlg;
            while (pos) {
               m_scopeItemPopups.GetNextAssoc(pos,key,pDlg);
               if(m_pUIThread){
                   m_pUIThread->PostThreadMessage(SCEM_DESTROY_DIALOG, (WPARAM)pDlg, 0);
               }
               m_scopeItemPopups.RemoveKey(key);

            }
            break;

         }
         default:
            break;
      }

   }

   return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
   // Delete enumerated scope items
   // close profile handle if it is open
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //
   // Free the account type name list.
   //
   CGetUser::GetAccountType(NULL);

   if(!m_strTempFile.IsEmpty()){
      DeleteFile( m_strTempFile );
   }

   {
      CSaveTemplates pSaveTemplate;
      POSITION pos;
      PEDITTEMPLATE pTemplate;
      CString strKey;
      int nDirty;

      //
      // Bug #197054:
      //
      // Offer to save dirty templates before reporting if the console
      // itself is dirty and giving users a chance to save that.  If
      // we only save the templates when we save the console then users
      // can unknowingly decide not to save changes to the console and
      // discard all of their changes to the templates
      //
      AFX_MANAGE_STATE(AfxGetStaticModuleState());

      nDirty = 0;

      if (GetModeBits() & MB_TEMPLATE_EDITOR) {
         pos = m_Templates.GetStartPosition();
         while (pos) {
            m_Templates.GetNextAssoc(pos,strKey,pTemplate);
            if (pTemplate->IsDirty() && !pTemplate->QueryNoSave()) {
               pSaveTemplate.AddTemplate(strKey,pTemplate);
               nDirty++;
            }
         }

         if (nDirty) 
         {
            CThemeContextActivator activator;
            if (-1 == pSaveTemplate.DoModal()) 
            {
               CString str;
               str.LoadString(IDS_ERROR_CANT_SAVE);
               AfxMessageBox(str);
            }
         }
      } else if (GetModeBits() & MB_ANALYSIS_VIEWER) {
         pTemplate = GetTemplate(GT_COMPUTER_TEMPLATE);
         if (pTemplate && pTemplate->IsDirty()) {
            if (IDYES == AfxMessageBox(IDS_SAVE_DATABASE,MB_YESNO)) {
               pTemplate->Save();
            }
         }
      }
   }

   DeleteList();

   SAFE_RELEASE(m_pScope);
   SAFE_RELEASE(m_pConsole);


   if ( SadHandle ) {

      if ( SadTransStarted ) {

         EngineRollbackTransaction();

         SadTransStarted = FALSE;
      }
      EngineCloseProfile(&SadHandle);

      SadHandle = NULL;
   }
   if (g_hDsSecDll) {

      FreeLibrary(g_hDsSecDll);
      g_hDsSecDll = NULL;
   }

   return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
   HRESULT hr;
   ASSERT(ppDataObject != NULL);

   CComObject<CDataObject>* pObject;

   hr = CComObject<CDataObject>::CreateInstance(&pObject);
   if (!SUCCEEDED(hr)) {
      return hr;
   }
   if (NULL == pObject) {
      return E_FAIL;
   }

   // Save cookie and type for delayed rendering
   CFolder *pFolder;
   LPSCESVCATTACHMENTDATA pAttachData;

   pObject->SetType(type);
   pObject->SetCookie(cookie);

   //
   // Store the coclass with the data object
   //
   pObject->SetClsid(GetCoClassID());


   if (cookie && (CCT_SCOPE == type)) {
      pFolder = (CFolder *) cookie;
      pObject->SetFolderType(pFolder->GetType());
      if ((AREA_SERVICE == pFolder->GetType()) ||
          (AREA_SERVICE_ANALYSIS == pFolder->GetType())) {
         InternalAddRef();
         pObject->SetSceSvcAttachmentData(this);
      }
      pObject->SetMode(pFolder->GetMode());
      pObject->SetModeBits(pFolder->GetModeBits());

      pObject->SetGPTInfo(m_pGPTInfo);
      pObject->SetRSOPInfo(m_pRSOPInfo);
   }
   return  pObject->QueryInterface(IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
   ASSERT(pClassID != NULL);

   // Copy the CLSID for this snapin
   *pClassID = GetCoClassID();  // CLSID_Snapin;

   return E_NOTIMPL;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
   if (ThisIsDirty()) {
      return S_OK;
   }

   return S_FALSE;
}

//+--------------------------------------------------------------------------
// CComponentDataImpl::Load
//
// Loads configuration saved information from the MMC stream.
// SAD:{%s}          - The sad same, if any.
// LOGFILE:{%s}{%d}  - The log file last used for the database,
//                     and the position the was last written to by this
//                     remembered snapin.  If the user chooses not to save this
//                     information then, What is displayed will be out of date.
// SerializecolumnInfo() is called to create remembered column information.
//
// Arguments:  [pStm]   - The MMC stream to load from.
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
   ASSERT(pStm);

   //
   // Read sad name.
   //
   LPTSTR szSadName = NULL;
   if (0 < ReadSprintf(pStm,L"SAD:{%s}",&szSadName)) {
      SadName = szSadName;
      LocalFree(szSadName);

      LoadSadInfo(TRUE);
   }

   //
   // Read log file used and last position it was viewed from.
   //
   DWORD nPos;
   if( 0 < ReadSprintf(pStm, L"LOGFILE:{%s}{%d}", &szSadName, &nPos) ){
      SetErroredLogFile( szSadName, nPos);
      LocalFree( szSadName );
   }

   SerializeColumnInfo( pStm, NULL, TRUE );
   return S_OK;
}

//+--------------------------------------------------------------------------
// CComponentDataImpl::Save
//
// Saves configuration file information.
// SAD:{%s}          - The sad same, if any.
// LOGFILE:{%s}{%d}  - The log file last used for the database,
//                     and the position the was last written to by this
//                     remembered snapin.  If the user chooses not to save this
//                     information then, What is displayed will be out of date.
// SerializecolumnInfo() is called to save column information.
//
// Arguments:  [pStm]   - The MMC stream to save to
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   ASSERT(pStm);

   if (!SadName.IsEmpty() && !IsSystemDatabase(SadName)) {
      WriteSprintf(pStm,L"SAD:{%s}",(LPCTSTR)SadName);
   }

   if ( GetErroredLogFile() ){
      LONG uPos = 0;
      WriteSprintf(pStm, L"LOGFILE:{%s}{%d}", GetErroredLogFile(&uPos), uPos);
   }

   SerializeColumnInfo( pStm, NULL, FALSE );

   if (fClearDirty) {
      ClearDirty();
   }

   return S_OK;
}


//+--------------------------------------------------------------------------
// CComponentDataImpl::GetSizeMax
//
// Don't have a clue what the size will be of the string we want to save.
//
// Returns: S_OK     - Always.
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnAdd(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnRename(LPDATAOBJECT lpDataObject,LPARAM arg, LPARAM param)
{
   return E_UNEXPECTED;
}

//+--------------------------------------------------------------------------
//
//  Method:     OnExpand
//
//  Synopsis:   Expand a scope pane node and add its children folders
//
//  Arguments:  [lpDataObject]  - The data object for the node we're expanding
//              [arg] -    Whether or not initialize has been called
//              [param] -  The id of the node we're expanding
//
//
//  Modifies:
//
//  History:    12-15-1997   Robcap
//
//---------------------------------------------------------------------------
HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject,
                                     LPARAM arg,
                                     LPARAM param)
{
   CString strName;
   CString strDesc;
   DWORD dwMode = 0;
   SCESTATUS scestatus = SCESTATUS_SUCCESS;

   ASSERT(lpDataObject);

   if ( lpDataObject == NULL ) 
      return E_FAIL;

   HRESULT hr = S_OK;

   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   CFolder *pFolder = NULL;

   if (pInternal == NULL) 
   {
      //
      // The node doesn't have our internal format, so we must be extending
      // somebody else.  Figure out who we are extending and what mode we are in
      //
      GUID* nodeType = ExtractNodeType(lpDataObject);
      GUID guidMyComputer = structuuidNodetypeSystemTools;

      dwMode = SCE_MODE_UNKNOWN;
      if (!nodeType) 
      {
         //
         // This should never happen; nodeType should always be set here
         //
         ASSERT(FALSE);
         return E_FAIL;
      }

      //
      // MAX_PATH*5 is magic; GetDSPath and GetGPT path don't provide
      // a direct way to find out how long a path is needed
      //
      TCHAR pszDSPath[MAX_PATH*5];
      TCHAR pszGPTPath[MAX_PATH*5];

      if (::IsEqualGUID(*nodeType,NODEID_Machine) ||
          ::IsEqualGUID(*nodeType,NODEID_User)) 
      {
         //
         // GPE Extension
         //
         hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                                           reinterpret_cast<void**>(&m_pGPTInfo));

         if (SUCCEEDED(hr)) 
         {
            //
            // get ds root path
            //
            DWORD dwSection = 0;
            GROUP_POLICY_HINT_TYPE gpHint;
            GROUP_POLICY_OBJECT_TYPE gpType;

            //
            // Give the GPT Information to the hidden notifications window so
            // it can keep calls to it on this thread
            //
            m_pNotifier->SetGPTInformation(m_pGPTInfo);

            hr = m_pGPTInfo->GetType(&gpType);

            if ( SUCCEEDED(hr) ) 
            {
               switch ( gpType ) 
               {
               case GPOTypeLocal:

                  //
                  // We're editing a this machine's Policy, not Global Policy
                  //
                  if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                  {
                     //
                     // LPE Machine Node type
                     //
                     dwMode = SCE_MODE_LOCAL_COMPUTER;
                     ASSERT(m_pNotifier);

                  } 
                  else 
                  {
                     //
                     // LPE User Node type
                     //
                     dwMode = SCE_MODE_LOCAL_USER;
                  }
                  break;

               case GPOTypeRemote:
                  //
                  // We're editing a remote machine's Policy
                  //
                  if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                  {
                     //
                     // LPE Machine Node type
                     //
                     dwMode = SCE_MODE_REMOTE_COMPUTER;
                  } 
                  else 
                  {
                     //
                     // LPE User Node type
                     //
                     dwMode = SCE_MODE_REMOTE_USER;
                  }
                  break;

               default:
                  hr = m_pGPTInfo->GetHint(&gpHint);
                  if (SUCCEEDED(hr)) 
                  {
                     switch (gpHint) 
                     {
                     case GPHintMachine:
                     case GPHintUnknown:
                     case GPHintDomain:
                        //
                        // We're editing Global Domain Policy
                        //
                        if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                        {
                           //
                           // GPE Machine Node type
                           //
                           dwMode = SCE_MODE_DOMAIN_COMPUTER;
                        } 
                        else 
                        {
                           //
                           // GPE User Node type
                           //
                           dwMode = SCE_MODE_DOMAIN_USER;
                        }
                        break;

                     case GPHintSite:
                     case GPHintOrganizationalUnit:
                        //
                        // We're editing Global Domain Policy
                        //
                        if (::IsEqualGUID(*nodeType,NODEID_Machine)) 
                        {
                           //
                           // GPE Machine Node type
                           //
                           dwMode = SCE_MODE_OU_COMPUTER;
                        } 
                        else 
                        {
                           //
                           // GPE User Node type
                           //
                           dwMode = SCE_MODE_OU_USER;
                        }
                        break;

                     default:
                        //
                        // Should never get here
                        //
                        ASSERT(FALSE);
                        break;
                     }
                  }

                  break;
               }
               //
               // remember the root node's mode
               //
               m_Mode = dwMode;
               m_GroupMode = dwMode;

               switch (dwMode) 
               {
               case SCE_MODE_DOMAIN_COMPUTER:
               case SCE_MODE_OU_COMPUTER:
                  dwSection = GPO_SECTION_MACHINE;
                  break;

               case SCE_MODE_LOCAL_COMPUTER:
                  //
                  // For local use the policy database rather than a template
                  //
                  break;

               case SCE_MODE_REMOTE_COMPUTER:
               case SCE_MODE_REMOTE_USER:
               case SCE_MODE_LOCAL_USER:
               case SCE_MODE_DOMAIN_USER:
               case SCE_MODE_OU_USER:
                  //
                  // For now we don't support any native nodes in USER modes, so we
                  // don't need a template
                  //
                  break;

               default:
                  break;
               }
               //
               // Find the path to the SCE template within the GPT template
               //
               if (GPO_SECTION_MACHINE == dwSection) 
               {
                  //
                  // 156869  Default Domain and Default DC GPO's should only be modifiable on the FSMO PDC
                  //
                  TCHAR szGUID[MAX_PATH];
                  hr = m_pGPTInfo->GetName(szGUID,MAX_PATH);
                  if (SUCCEEDED(hr)) 
                  {
                     LPTSTR szDCGUID = TEXT("{") STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID TEXT("}");
                     LPTSTR szDomGUID = TEXT("{") STR_DEFAULT_DOMAIN_GPO_GUID TEXT("}");
                     if ((0 == lstrcmpi(szGUID, szDCGUID)) || (0 == lstrcmpi(szGUID, szDomGUID))) 
                     {
                        LPGROUPPOLICYOBJECT pGPO = NULL;

                        //
                        // Default Domain or Default DC GPO.  Make sure we're talking to the PDC
                        //
                        TCHAR szDCName[MAX_PATH];
                        hr = lpDataObject->QueryInterface(IID_IGroupPolicyObject,(LPVOID*)&pGPO);
                        if (SUCCEEDED(hr)) 
                        {
                           hr = pGPO->GetMachineName(szDCName,MAX_PATH);
                           pGPO->Release();
                        }
                        if (SUCCEEDED(hr)) 
                        {
                           DOMAIN_CONTROLLER_INFO *dci = 0;

                           if (NO_ERROR != DsGetDcName(szDCName,NULL,NULL,NULL,DS_PDC_REQUIRED,&dci))  
                           {
                              //
                              // We're not connected to the PDC (or we can't get info about who we're
                              // connected to, so assume the same
                              //
                              dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                           }
                           if(dci)
                              NetApiBufferFree(dci);
                        } 
                        else
                           dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                     }
                  } 
                  else 
                  {
                     //
                     // Can't get the name of the DC we're talking to, so assume it's not the PDC
                     //
                     dwMode = SCE_MODE_DOMAIN_COMPUTER_ERROR;
                  }

                  //
                  // get GPT root path
                  //

                  hr = m_pGPTInfo->GetFileSysPath(dwSection,
                                                  pszGPTPath,
                                                  ARRAYSIZE(pszGPTPath));
                  if (SUCCEEDED(hr)) 
                  {
                     //
                     // Allocate memory for the pszGPTPath + <backslash> + GPTSCE_TEMPLATE + <trailing nul>
                     //
                     m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(pszGPTPath)+lstrlen(GPTSCE_TEMPLATE)+2)*sizeof(TCHAR));
                     if (NULL != m_szSingleTemplateName) 
                     {
                        lstrcpy(m_szSingleTemplateName,pszGPTPath);
                        lstrcat(m_szSingleTemplateName,L"\\" GPTSCE_TEMPLATE);
                     } 
                     else
                        hr = E_OUTOFMEMORY;
                  }
               } 
               else 
               {
                  //
                  // else user section
                  //
               }
            } 
            else 
            {
               //
               // can't get GPT path, error is in hr
               ASSERT(FALSE);
               //
            }
         } 
         else 
         {
            //
            // else error in hr
            //
         }
      } else if (::IsEqualGUID(*nodeType,NODEID_RSOPMachine) ||
                 ::IsEqualGUID(*nodeType,NODEID_RSOPUser)) 
      {
         //
         // RSOP Extension
         //
         if (::IsEqualGUID(*nodeType,NODEID_RSOPMachine)) 
         {
            //
            // GPE Machine Node type
            //
            dwMode = SCE_MODE_RSOP_COMPUTER;
            m_szSingleTemplateName = (LPTSTR) LocalAlloc(LPTR,(lstrlen(GT_RSOP_TEMPLATE)+1)*sizeof(TCHAR));
            if (NULL != m_szSingleTemplateName) 
               lstrcpy(m_szSingleTemplateName,GT_RSOP_TEMPLATE);
            else
               hr = E_OUTOFMEMORY;
         } 
         else 
         {
            //
            // GPE User Node type
            //
            dwMode = SCE_MODE_RSOP_USER;
         }
         hr = lpDataObject->QueryInterface(IID_IRSOPInformation,
                                           reinterpret_cast<void**>(&m_pRSOPInfo));

      } 
      else 
      {
         //
         // We should never get into this state
         //
         ASSERT(0);
         hr = E_FAIL;
      }

      //
      // free node type buffer
      //

      if (nodeType)
         GlobalFree(nodeType);

      if ( FAILED(hr) ) 
      {
         //
         // free template buffer if allocated
         //
         if ( m_szSingleTemplateName )
            LocalFree(m_szSingleTemplateName);
         m_szSingleTemplateName = NULL;

         return hr;
      }

      //
      // As an extension snapin, the secedit root node should be added
      //
      pFolder = new CFolder();

      ASSERT(pFolder);

      if ( pFolder ) 
      {
         if (!pFolder->SetMode(dwMode)) 
         {
            //
            // This should never happen; we should always have a valid dwMode by now
            //
            ASSERT(FALSE);

            //
            // remember to free the memory
            //

            delete pFolder;
            return E_FAIL;
         }

         FOLDER_TYPES RootType = STATIC;
         LPTSTR szInfFile = NULL;

         DWORD* pdwModeBits = 0;
         switch (m_Mode)
         {
         case SCE_MODE_DOMAIN_COMPUTER:
         case SCE_MODE_OU_COMPUTER:
         case SCE_MODE_LOCAL_COMPUTER:
         case SCE_MODE_REMOTE_COMPUTER:
            pdwModeBits = &m_computerModeBits;
            break;

         case SCE_MODE_REMOTE_USER:
         case SCE_MODE_LOCAL_USER:
         case SCE_MODE_DOMAIN_USER:
         case SCE_MODE_OU_USER:
            pdwModeBits = &m_userModeBits;
            break;

         default:
            pdwModeBits = &m_computerModeBits;
            break;
         }

         *pdwModeBits = pFolder->GetModeBits();
         if (*pdwModeBits & MB_ANALYSIS_VIEWER) 
         {
            strName.LoadString(IDS_ANALYSIS_VIEWER_NAME);
            szInfFile = GT_COMPUTER_TEMPLATE;
            RootType = ANALYSIS;
         } 
         else if (*pdwModeBits & MB_TEMPLATE_EDITOR) 
         {
            strName.LoadString(IDS_TEMPLATE_EDITOR_NAME);
            RootType = CONFIGURATION;
         } 
         else if (*pdwModeBits & MB_LOCAL_POLICY) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = LOCALPOL;
         } 
         else if (*pdwModeBits & MB_STANDALONE_NAME) 
         {
            strName.LoadString(IDS_NODENAME);
            RootType = STATIC;
         } 
         else if (*pdwModeBits & MB_SINGLE_TEMPLATE_ONLY) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = PROFILE;
            szInfFile = m_szSingleTemplateName;
         } 
         else if (*pdwModeBits & MB_NO_NATIVE_NODES) 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
            RootType = PROFILE;
         } 
         else 
         {
            strName.LoadString(IDS_EXTENSION_NAME);
         }


         strDesc.LoadString(IDS_SECURITY_SETTING_DESC);  // only GPE extensions get here
         hr = pFolder->Create(strName,           // Name
                              strDesc,           // Description
                              szInfFile,         // inf file name
                              SCE_IMAGE_IDX,     // closed icon index
                              SCE_IMAGE_IDX,     // open icon index
                              RootType,          // folder type
                              TRUE,              // has children
                              dwMode,            // SCE Mode
                              NULL);             // Extra Data
         if (FAILED(hr)) 
         {
            delete pFolder;
            return hr;
         }

         m_scopeItemList.AddTail(pFolder);

         // Set the parent
         pFolder->GetScopeItem()->mask |= SDI_PARENT;
         pFolder->GetScopeItem()->relativeID = param;

         // Set the folder as the cookie
         pFolder->GetScopeItem()->mask |= SDI_PARAM;
         pFolder->GetScopeItem()->lParam = reinterpret_cast<LPARAM>(pFolder);
         pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));

         m_pScope->InsertItem(pFolder->GetScopeItem());
         //
         // Note - On return, the ID member of 'm_pScopeItem'
         // contains the handle to the newly inserted item!
         //
         ASSERT(pFolder->GetScopeItem()->ID != NULL);

      } 
      else
         return E_OUTOFMEMORY;

      return S_OK;
   } 
   else 
   {
      //
      // Expanding one of our own nodes
      MMC_COOKIE cookie = pInternal->m_cookie;
      FREE_INTERNAL(pInternal);

      if (arg != FALSE) 
      {
         //
         // Did Initialize get called?
         //
         ASSERT(m_pScope != NULL);
         EnumerateScopePane(cookie, param);
      }
   }
   return S_OK;
}

HRESULT CComponentDataImpl::OnSelect(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CComponentDataImpl::OnContextMenu(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
   return S_OK;
}

HRESULT CComponentDataImpl::OnProperties(LPARAM param)
{
   if (param == NULL)
      return S_OK;
   
   ASSERT(param != NULL);


   return S_OK;
}

void CComponentDataImpl::DeleteList()
{
   POSITION pos = m_scopeItemList.GetHeadPosition();

   while (pos)
      delete m_scopeItemList.GetNext(pos);
}

CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie, POSITION* thePos)
{
   POSITION pos = m_scopeItemList.GetHeadPosition();
   POSITION curPos;
   CFolder* pFolder = NULL;

   while (pos) {
      curPos = pos;
      // pos is already updated to the next item after this call
      pFolder = m_scopeItemList.GetNext(pos);

      //
      // The first folder in the list belongs to cookie 0
      //
      if (!cookie || (pFolder == (CFolder *)cookie)) {
         if ( thePos ) {
            *thePos = curPos;
         }

         return pFolder;
      }
   }

   if ( thePos ) {
      *thePos = NULL;
   }

   return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
   ASSERT(pScopeDataItem != NULL);
   if (pScopeDataItem == NULL)
      return E_POINTER;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

   ASSERT(pScopeDataItem->mask & SDI_STR);

   // MMC does not supprot call back on scope node image
   if ( pScopeDataItem->mask & SDI_IMAGE ) {

      //int nImage = GetScopeImageIndex(pFolder->GetType());
      pScopeDataItem->nImage = pFolder->GetScopeItem()->nImage;
   }

   m_strDisplay.Empty();
   if(pFolder){
      pFolder->GetDisplayName(m_strDisplay, 0);
      m_Mode = pFolder->GetMode(); //YangGao #332852 fix.
   }
   pScopeDataItem->displayname = (LPOLESTR)(LPCTSTR)m_strDisplay;
   ASSERT(pScopeDataItem->displayname != NULL);

   return S_OK;
}


STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
   if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

   // Make sure both data object are mine
   HRESULT hr = S_FALSE;

   INTERNAL *pA = ExtractInternalFormat(lpDataObjectA);
   INTERNAL *pB = ExtractInternalFormat(lpDataObjectB);

   if (pA != NULL && pB != NULL)
      hr = (*pA == *pB) ? S_OK : S_FALSE;

   FREE_INTERNAL(pA);
   FREE_INTERNAL(pB);

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                                     LONG_PTR handle,
                                                     LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if (!lpDataObject || !lpProvider || !handle) {
      return E_INVALIDARG;
   }
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
   if (!pInternal) {
      return E_UNEXPECTED;
   }
   if(pInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) {
      return S_FALSE;
   } else if (pInternal->m_type == CCT_SCOPE) {
      return AddAttrPropPages(lpProvider,(CFolder*)(pInternal->m_cookie),handle);
   }

   return S_FALSE;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   // Look at the data object and see if it an item in the scope pane
   return IsScopePaneNode(lpDataObject) ? S_OK : S_FALSE;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
   BOOL bResult = FALSE;
   INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

   // taking out m_cookie == NULL, should check foldertype ???
   if (pInternal->m_type == CCT_SCOPE) {
      bResult = TRUE;
   }

   FREE_INTERNAL(pInternal);

   return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
BOOL LoadContextMenuResources(MENUMAP* pMenuMap)
{
   HINSTANCE hInstance = _Module.GetModuleInstance();
   for (int i = 0; pMenuMap->ctxMenu[i].strName; i++) {
      if (0 == ::LoadString(hInstance, pMenuMap->dataRes[i].uResID, pMenuMap->dataRes[i].szBuffer, MAX_CONTEXT_MENU_STRLEN*2))
         return FALSE;
      pMenuMap->ctxMenu[i].strName = pMenuMap->dataRes[i].szBuffer;
      for (WCHAR* pCh = pMenuMap->dataRes[i].szBuffer; (*pCh) != NULL; pCh++) {
         if ( (*pCh) == L'\n') {
            pMenuMap->ctxMenu[i].strStatusBarText = (pCh+1);
            (*pCh) = NULL;
            break;
         }
      }
   }
   return TRUE;
}

BOOL CComponentDataImpl::LoadResources()
{

   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   return
   LoadContextMenuResources(CSecmgrNodeMenuHolder::GetMenuMap() ) &&
   LoadContextMenuResources(CAnalyzeNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CConfigNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CLocationNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CSSProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CRSOPProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CLocalPolNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileNodeMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileSubAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileSubAreaEventLogMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeAreaMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeGroupsMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeFilesMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeRegistryMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileGroupsMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileFilesMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CProfileRegistryMenuHolder::GetMenuMap()) &&
   LoadContextMenuResources(CAnalyzeObjectsMenuHolder::GetMenuMap());
}


STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG* pInsertionAllowed)
{
   HRESULT hr = S_OK;

   // Note - snap-ins need to look at the data object and determine
   // in what context, menu items need to be added.
   INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

   if (pInternal == NULL) 
   {
      //
      // Actually looking for our extension
      //
      return S_OK;
   }

   MMC_COOKIE cookie = pInternal->m_cookie;
   LPCONTEXTMENUITEM pContextMenuItem=NULL;

   CFolder *pFolder = NULL;
   if ( NULL == cookie ) 
   {
      //
      // root. IDS_ABOUT_SECMGR
      //

      //
      // either analysis node, or configuration node
      //
      if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_SAVSnapin) ) 
      {
          if ((NULL == SadHandle) && SadErrored != SCESTATUS_SUCCESS) 
          {
             LoadSadInfo(TRUE);
          }
          pContextMenuItem = CAnalyzeNodeMenuHolder::GetContextMenuItem();
      } 
      else if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_SCESnapin) ) 
          pContextMenuItem = CConfigNodeMenuHolder::GetContextMenuItem();
      else if ( ::IsEqualGUID(pInternal->m_clsid, CLSID_LSSnapin) )
          pContextMenuItem = CLocalPolNodeMenuHolder::GetContextMenuItem();

   } 
   else 
   {
      pFolder = (CFolder *)cookie;

      FOLDER_TYPES type = pFolder->GetType(); //pInternal->m_foldertype;


      switch (type) 
      {
      case CONFIGURATION:
         // IDS_ADD_LOCATION
         pContextMenuItem = CConfigNodeMenuHolder::GetContextMenuItem();
         break;

      case LOCATIONS:
         // IDS_NEW_PROFILE,
         pContextMenuItem = CLocationNodeMenuHolder::GetContextMenuItem();
         break;

      case ANALYSIS:
         // IDS_PROFILE_INFO
         if ((NULL == SadHandle) && SadErrored != SCESTATUS_SUCCESS) 
            LoadSadInfo(TRUE);
         pContextMenuItem = CAnalyzeNodeMenuHolder::GetContextMenuItem();
         break;

      case LOCALPOL:
         if( !(pFolder->GetState() & CFolder::state_InvalidTemplate))
            pContextMenuItem = CLocalPolNodeMenuHolder::GetContextMenuItem();
         break;

      case PROFILE:
         //
         // If we're in a mode that doesn't want template (aka profile) verbs
         // Then don't add the save, save as & configure verbs here
         //
         if (pFolder->GetState() & CFolder::state_InvalidTemplate)
             break;
         else if (!(pFolder->GetModeBits() & MB_NO_TEMPLATE_VERBS))
            pContextMenuItem = CProfileNodeMenuHolder::GetContextMenuItem();
         else if (GetModeBits() & MB_READ_ONLY)
            pContextMenuItem = CRSOPProfileNodeMenuHolder::GetContextMenuItem();
         else
            pContextMenuItem = CSSProfileNodeMenuHolder::GetContextMenuItem();
         break;

      case AREA_POLICY:
      case AREA_SERVICE:
      case POLICY_ACCOUNT:
      case POLICY_LOCAL:
      case POLICY_EVENTLOG:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
             pContextMenuItem = CProfileAreaMenuHolder::GetContextMenuItem();
         break;

      case AREA_PRIVILEGE:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
      case POLICY_AUDIT:
      case POLICY_OTHER:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY) 
             pContextMenuItem = CProfileSubAreaMenuHolder::GetContextMenuItem();
         break;

      case POLICY_LOG: //Raid #253209, Yang Gao, 3/27/2001.
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY) 
             pContextMenuItem = CProfileSubAreaEventLogMenuHolder::GetContextMenuItem();
         break;

      case AREA_GROUPS:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
             pContextMenuItem = CProfileGroupsMenuHolder::GetContextMenuItem();
         break;

      case AREA_REGISTRY:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
            pContextMenuItem = CProfileRegistryMenuHolder::GetContextMenuItem();
         break;

      case AREA_FILESTORE:
         if ((GetModeBits() & MB_READ_ONLY) != MB_READ_ONLY)
            pContextMenuItem = CProfileFilesMenuHolder::GetContextMenuItem();
         break;

      case AREA_POLICY_ANALYSIS:
      case AREA_PRIVILEGE_ANALYSIS:
      case AREA_SERVICE_ANALYSIS:
         // if under analysis info node, IDS_REFRESH_AREA
         pContextMenuItem = CAnalyzeAreaMenuHolder::GetContextMenuItem();
         break;

      case AREA_GROUPS_ANALYSIS:
         pContextMenuItem = CAnalyzeGroupsMenuHolder::GetContextMenuItem();
         break;
      case AREA_REGISTRY_ANALYSIS:
         pContextMenuItem = CAnalyzeRegistryMenuHolder::GetContextMenuItem();
         break;
      case AREA_FILESTORE_ANALYSIS:
         pContextMenuItem = CAnalyzeFilesMenuHolder::GetContextMenuItem();
         break;

      case REG_OBJECTS:
      case FILE_OBJECTS:
         pContextMenuItem = CAnalyzeObjectsMenuHolder::GetContextMenuItem();
         break;

      default:
         break;
      }
   }

   FREE_INTERNAL(pInternal);

   if ( NULL == pContextMenuItem ) 
      return hr;
   
   //
   // Loop through and add each of the menu items
   //
   PWSTR pstrWizardName = NULL;
   PWSTR pstrPathName=NULL;

   for ( LPCONTEXTMENUITEM m = pContextMenuItem; m->strName; m++) 
   {
      //
      // make a tempoary copy that can be modified
      //
      CONTEXTMENUITEM tempItem;
      ::memcpy(&tempItem, m, sizeof(CONTEXTMENUITEM));
      //
      // check each command's state ?
      //
      CString strInf;
      PEDITTEMPLATE pTemp = 0;

      switch (tempItem.lCommandID ) 
      {
      case IDM_RELOAD:
      case IDM_DESCRIBE_LOCATION:
      case IDM_NEW:
         if(pFolder &&
            pFolder->GetType() == LOCATIONS &&
            pFolder->GetState() & CFolder::state_InvalidTemplate )
         {
            tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_EXPORT_POLICY:
         //
         // Grey out export if we can't open a database.
         //
         if(!SadHandle)
            tempItem.fFlags = MF_GRAYED;
         break;

      case IDM_EXPORT_LOCALPOLICY:
      case IDM_EXPORT_EFFECTIVE:
         if(!SadHandle)
         {
            //
            // Don't try to insert these items.
            continue;
         }
         //
         // Sub items of effective policy.
         //
         tempItem.lInsertionPointID = IDM_EXPORT_POLICY;
         break;

      case IDM_SECURE_WIZARD:
          //
          // check if there is a secure wizard registered
          //

          GetSecureWizardName(&pstrPathName, &pstrWizardName);

          if ( pstrPathName ) 
          {
              //
              // if PathName is returned, the secure wizard is registered
              // but the display name may not be defined in the resource
              // in which case, the default "Secure Wizard" string is used.
              //
              if ( pstrWizardName )
                  tempItem.strName = pstrWizardName;

              LocalFree(pstrPathName);

          } 
          else
              continue;
          break;

      case IDM_PASTE: 
         {
            UINT cf = 0;
            AREA_INFORMATION Area;

            if (cookie && GetFolderCopyPasteInfo(((CFolder*)cookie)->GetType(),&Area,&cf)) 
            {
               OpenClipboard(NULL);
               if (!::IsClipboardFormatAvailable(cf))
                  tempItem.fFlags = MF_GRAYED;
               
               CloseClipboard();
            }
         }
         break;

      case IDM_SAVE:
         {
            CFolder *pFolder2 = (CFolder *)cookie;

            if ( pFolder2 && ANALYSIS != pFolder2->GetType() )
               strInf = pFolder2->GetInfFile();
            else 
            {
               //
               // analysis
               //
               strInf = GT_COMPUTER_TEMPLATE;
            }
            if ( strInf ) 
            {
               pTemp= GetTemplate(strInf);
               if( pTemp && pFolder2 ) //212287, Yanggao, 3/20/2001
               {
                  LPCTSTR des = pFolder2->GetDesc();
                  if( des )
                  {
                     if( pTemp->GetDesc() )
                     {
                        if( !wcscmp(des, pTemp->GetDesc()) )
                           pTemp->SetDescription(des);
                     }
                     else
                        pTemp->SetDescription(des);
                  }
               }
               if (!pTemp || !pTemp->IsDirty())
                  tempItem.fFlags = MF_GRAYED;
            } 
            else
               tempItem.fFlags = MF_GRAYED;

            if (m_bIsLocked)
               tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_ASSIGN:
         //
         // For NT5 this menu item should be grayed if we don't have a sad handle and if analysis is locked.
         //
         if (m_bIsLocked || (!SadHandle && SadName.IsEmpty()) ||
             SadErrored == SCESTATUS_ACCESS_DENIED) 
         {
            tempItem.fFlags = MF_GRAYED;
         }
         break;

      case IDM_VIEW_LOGFILE:
         if(!GetErroredLogFile())
            tempItem.fFlags = MF_GRAYED;
         else if (m_dwFlags & flag_showLogFile )
            tempItem.fFlags = MF_CHECKED;
         break;

      case IDM_SET_DB:
      case IDM_OPEN_PRIVATE_DB:
         if ( m_bIsLocked )
            tempItem.fFlags = MF_GRAYED;
         break;

      case IDM_SUMMARY:
      case IDM_APPLY:
      case IDM_GENERATE:
      case IDM_ANALYZE: 
         {
            WIN32_FIND_DATA fd;
            HANDLE handle = 0;
            //
            // Bug #156375
            //
            // don't gray out if we have a database file.  we can't open the
            // database (and therefore get a SadHandle) unless the database has
            // already been analyzed, which gives a chicken & egg problem with
            // requiring the SadHandle to enable IDM_ANALYZE or IDM_APPLY....
            // (if we have a SadHandle already then everything's fine, of course)
            //
            // If the database is corrupt or invalid then the actual action will
            // fail and we'll display an error then.
            //
            if (m_bIsLocked) 
            {
               tempItem.fFlags = MF_GRAYED;
               //
               // If we have a SadHandle then we're ok
               //
            } 
            else if (!SadHandle) 
            {
               //
               // Bug #387406
               //
               // If we don't have a SadHandle we can't generate a template
               // even if the database file exists
               //
               if (IDM_GENERATE == tempItem.lCommandID )
                  tempItem.fFlags = MF_GRAYED;
               else 
               {
                  //
                  // With no database handle & no assigned configuration then let the
                  // menu option be selected so long as the database file exists.
                  //
                  if (SadName.IsEmpty() || SadErrored == SCESTATUS_ACCESS_DENIED) 
                     tempItem.fFlags = MF_GRAYED;
                  else 
                  {
                     handle = FindFirstFile(SadName,&fd);
                     if (INVALID_HANDLE_VALUE == handle) 
                        tempItem.fFlags = MF_GRAYED;
                     else
                        FindClose(handle);
                  }
               }
            }
         }
         break;

      case IDM_ADD_LOC:
         if ( !m_bEnumerateScopePaneCalled )
            tempItem.fFlags = MF_GRAYED;
         break;

      default:
         break;
      }

      hr = pContextMenuCallback->AddItem(&tempItem);
      if (FAILED(hr))
         break;
   }

   if ( pstrWizardName ) 
      LocalFree(pstrWizardName);

   return hr;
}

DWORD DeleteLocationFromReg2(HKEY hKey,LPCTSTR KeyStr) 
{
   DWORD rc = 0;

   // replace the "\" with "/" because registry does not take "\" in a single key
   CString tmpstr = KeyStr;
   int npos = tmpstr.Find(L'\\');
   while (npos > 0) {
      *(tmpstr.GetBuffer(1)+npos) = L'/';
      npos = tmpstr.Find(L'\\');
   }
   rc = RegDeleteKey( hKey, (LPCTSTR)tmpstr);

   RegCloseKey(hKey);

   return rc;
}

DWORD DeleteLocationFromReg(LPCTSTR KeyStr)
{
   // delete the location to registry

   BOOL bSuccess = FALSE;
   HKEY hKey=NULL;

   DWORD rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\secmgr",
                            0, KEY_READ | KEY_WRITE,
                            &hKey);
   if (ERROR_SUCCESS == rc) {
      bSuccess = TRUE;
      DeleteLocationFromReg2(hKey,KeyStr);
   }

   //
   // Bug 375324: Delete from both system & local keys if possible
   //
   rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\secmgr",
                      0, KEY_READ | KEY_WRITE,
                      &hKey);
   if (ERROR_SUCCESS == rc) {
      DeleteLocationFromReg2(hKey,KeyStr);
   }

   //
   // If we succeeded the first key then we don't care what happened
   // for the second (it'll probably fail since the key didn't exist
   // there anyway)
   //
   if (bSuccess) {
      return ERROR_SUCCESS;
   } else {
      return rc;
   }
}


//+--------------------------------------------------------------------------
//
//  Method:     CloseAnalysisPane
//
//  Synopsis:   Close up the Analysis Pane and free any memory for folders that
//              we aren't using any longer.
//
//  History:   a-mthoge 06-09-1998 - _NT4BACK_PORT item to reinsert the scope
//                             item back into the tree.
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::CloseAnalysisPane() {
   SCOPEDATAITEM item;

   if (m_AnalFolder && m_AnalFolder->IsEnumerated()) {
      DeleteChildrenUnderNode(m_AnalFolder);
      m_AnalFolder->Set(FALSE);


      if (m_AnalFolder->GetScopeItem()) {
         //
         // Mark item as unexpanded so we can re expand it later
         //
         ZeroMemory (&item, sizeof (item));
         item.mask = SDI_STATE;
         item.nState = 0;
         item.ID = m_AnalFolder->GetScopeItem()->ID;

         (void)m_pScope->SetItem (&item);
     }

   }
}



//+--------------------------------------------------------------------------
//
//  Method:     LockAnalysisPane
//
//  Synopsis:   Lock the Analysis Pane so that it closes and won't reopen
//
//  Arguments:  [bLock] - [in] TRUE to lock the pane, FALSE to unlock it
//
//  Returns:    TRUE if the pane ends up locked, FALSE if it ends up unlocked
//
//  History:   a-mthoge 06-09-1998 - Added _NT4BACKPORT and SelectScopeItem
//                             berfore enumeration.
//
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::LockAnalysisPane(BOOL bLock, BOOL fRemoveAnalDlg) {
   TryEnterCriticalSection(&csAnalysisPane);
   m_bIsLocked = bLock;

   //
   // Close the Analysis Pane whichever way we're going
   // If we're locking then we want to close it to clear out any
   // now-invalid data.
   //
   // If we're unlocking then we want to make sure that the folder
   // is fresh and that MMC doesn't think it's already been expanded,
   // and refuse to expand it anew.
   //
   if (!bLock) {

      if (!m_AnalFolder) {
         goto ExitLockAnalysisPane;
      }

      if (!m_AnalFolder->GetScopeItem() ) {
         goto ExitLockAnalysisPane;
      }

      //
      // If we're unlocking it then enumerate its subfolders
      //
      RefreshSadInfo(fRemoveAnalDlg);
   }

ExitLockAnalysisPane:
   LeaveCriticalSection(&csAnalysisPane);

   return m_bIsLocked;
}

void CComponentDataImpl::RefreshSadInfo(BOOL fRemoveAnalDlg) 
{
   CPerformAnalysis *pPA = 0;

   UnloadSadInfo();

   LoadSadInfo( TRUE );


   //
   // No need to LoadSadInfo() since EnumerateScopePane will do it when it needs it
   //
   if(m_pConsole && m_AnalFolder)
   {
      EnumerateScopePane( (MMC_COOKIE)m_AnalFolder, m_AnalFolder->GetScopeItem()->ID );
      m_pConsole->SelectScopeItem(m_AnalFolder->GetScopeItem()->ID);
   }

   //
   // remove cached analysis popup since it has cached filenames
   //
   if (fRemoveAnalDlg) 
   {
       pPA = (CPerformAnalysis *) this->GetPopupDialog(IDM_ANALYZE);
       if (pPA != NULL) 
       {
          this->RemovePopupDialog(IDM_ANALYZE);
          delete(pPA);
       }
   }
}

void
CComponentDataImpl::UnloadSadInfo() {

   if (SadHandle) {

      if ( SadTransStarted ) {

         EngineRollbackTransaction();
         SadTransStarted = FALSE;

      }
      EngineCloseProfile(&SadHandle);
      //      SadName.Empty();
      SadDescription.Empty();
      SadAnalyzeStamp.Empty();
      SadConfigStamp.Empty();

      CloseAnalysisPane();
   }

   //
   // Dump our cached templates so they get reloaded with the
   // new Sad information when it is available
   //
   DeleteTemplate(GT_COMPUTER_TEMPLATE);
   DeleteTemplate(GT_LAST_INSPECTION);

   SadLoaded = FALSE;
   SadErrored = SCESTATUS_SUCCESS;
   SadTransStarted = FALSE;
   SadHandle = 0;
}

void CComponentDataImpl::LoadSadInfo(BOOL bRequireAnalysis)
{
   DWORD rc;

   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

   CWaitCursor wc;

   if (SadHandle) {
      return;
   }
   if (m_bIsLocked) {
      return;
   }

   //
   // get name again
   //
   LPWSTR FileName=NULL;
   LPWSTR FileDesc=NULL;
   LPWSTR FileStamp1=NULL;
   LPWSTR FileStamp2=NULL;
   DWORD RegType;

   if ( SadName.IsEmpty() && bRequireAnalysis) {

      //
      // SadName is required if Analysis is required, but not otherwise
      // as the engine will find the system database on its own if passed
      // a NULL file name
      //
      return;
   }

      SadErrored = EngineOpenProfile( (SadName.IsEmpty() ? NULL : (LPCTSTR)SadName),
                                      bRequireAnalysis ? OPEN_PROFILE_ANALYSIS : OPEN_PROFILE_LOCALPOL,
                                      &SadHandle );
     if (SadErrored == SCESTATUS_SUCCESS ) {

        EngineGetDescription( SadHandle, &FileDesc);
        if ( FileDesc ) {
        SadDescription = FileDesc;
          LocalFree(FileDesc);
        }

        SadLoaded = TRUE;
        SadTransStarted = TRUE;
        return;
      }

   if (FileName) {
     LocalFree(FileName);
   }
   SadTransStarted = FALSE;

   //
   // Bug #197052 - Should automatically analyze if no anal info is available
   //
   return;
}


//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   Callback procedure for File & Folder adding SHBrowseForFolder
//              to set the title bar appropriately
//
//  Arguments:  [hwnd]   - the hwnd of the browse dialog
//              [uMsg]   - the message from the dialog
//              [lParam] - message dependant
//              [pData]  - message dependant
//
//  Returns:    0
//
//---------------------------------------------------------------------------
int
BrowseCallbackProc(HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   switch(uMsg) {
      case BFFM_INITIALIZED: {
         CString strTitle;
         strTitle.LoadString(IDS_FILEFOLDER_BROWSE_TITLE);
         SetWindowText(hwnd,strTitle);
         break;
      }
      case BFFM_VALIDATEFAILED :{
         if( pData )
         {
            *(CString*)pData = (LPWSTR)(lParam);
            CString ptempstr = (LPWSTR)(lParam); //Raid #374069, 4/23/2001
            if( -1 != ptempstr.Find(L"\\\\") )
            {
                return 1;
            }    
         }
         break;   
      }
      default:
         break;
   }
   return 0;
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
   // Note - snap-ins need to look at the data object and determine
   // in what context the command is being called.

   // Handle each of the commands.

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

   if (pInternal == NULL) {
      // Actually looking for our extension
      return S_OK;
   }


   MMC_COOKIE cookie = pInternal->m_cookie;
   CFolder* pFolder;

   if ( cookie) {
       pFolder = (CFolder*)cookie;
/*
       if( m_pConsole && nCommandID != IDM_OBJECT_SECURITY) {
          m_pConsole->SelectScopeItem(pFolder->GetScopeItem()->ID);
       }
*/
   } else {
       pFolder = FindObject(cookie, NULL);
       if ( pFolder == NULL ) {
           return S_OK;
       }
   }

   FREE_INTERNAL(pInternal);

   LPWSTR Name=NULL, Desc=NULL;

   //
   // initialize SadName, SadDescription, and SadDateTime
   //
   if ( !SadHandle && (nCommandID == IDM_SUMMARY ||
//   if ( !SadLoaded && (nCommandID == IDM_SUMMARY ||   // HAPPYHAPPY
                       nCommandID == IDM_ANALYZE ||
                       nCommandID == IDM_APPLY ||
                       nCommandID == IDM_ASSIGN ||
                       nCommandID == IDM_GENERATE ) ) {
      if (pFolder->GetModeBits() & MB_LOCAL_POLICY) {
         LoadSadInfo(FALSE);
      } else {
         LoadSadInfo(TRUE);
      }
   }

   //
   // more variable definitions used inside case statements
   //
   PVOID pDlg;
   CString ResString, AreaString;
   CPropertySheet sheet;

   CString tmpstr;
   MMC_COOKIE FindCookie;
   struct _wfinddata_t findData;
   LONG    hFile;
   WCHAR   pBuf[MAX_PATH];
   HRESULT hr;
   HSCOPEITEM pItemChild;
   //   AREA_INFORMATION Area;

   switch (nCommandID) {
   case MMC_VERB_OPEN:
      break;

   case MMC_VERB_COPY:
   case  MMC_VERB_PASTE:
      break;

   case IDM_VIEW_LOGFILE:
      if (m_dwFlags & flag_showLogFile) {
         m_dwFlags &= ~flag_showLogFile;
      } else {
         m_dwFlags |= flag_showLogFile;
      }
      //
      // Force a repaint.
      //
      m_pConsole->SelectScopeItem( pFolder->GetScopeItem()->ID );
      break;

   case IDM_OPEN_SYSTEM_DB: {
      CString szSysDB;

      hr = GetSystemDatabase(&szSysDB); //Raid bug 261450, Yang Gao, 3/30/2001
      if (SUCCEEDED(hr)) {
         //
         // Don't change anything if nothing changes
         //
         if (SadName != szSysDB) {
            SadName = szSysDB;
            RefreshSadInfo();
         }
      }
      break;
   }

   case IDM_OPEN_PRIVATE_DB:
      hr = OnOpenDataBase();
      break;

   case IDM_NEW_DATABASE:
      hr = OnNewDatabase();
      break;

   case IDM_IMPORT_POLICY:
      hr = OnImportPolicy(pDataObject);
      break;

   case IDM_IMPORT_LOCAL_POLICY:
      hr = OnImportLocalPolicy(pDataObject);
      break;

   case IDM_EXPORT_LOCALPOLICY:
      hr = OnExportPolicy(FALSE);
      break;

   case IDM_EXPORT_EFFECTIVE:
      hr = OnExportPolicy(TRUE);
      break;

   case IDM_ANALYZE: {
     PEDITTEMPLATE pet;

     //
     // If the computer template has been changed then save it before we
     // can apply it so we don't lose any changes
     //
     pet = GetTemplate(GT_COMPUTER_TEMPLATE);
     if (pet && pet->IsDirty()) {
        pet->Save();
     }

      hr = OnAnalyze();
      break;
   }

   case IDM_DESCRIBE_PROFILE:
      m_pUIThread->PostThreadMessage(SCEM_DESCRIBE_PROFILE,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_DESCRIBE_LOCATION:
      m_pUIThread->PostThreadMessage(SCEM_DESCRIBE_LOCATION,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_NEW:
      m_pUIThread->PostThreadMessage(SCEM_NEW_CONFIGURATION,(WPARAM)pFolder,(LPARAM) this);
      break;

   case IDM_ADD_LOC: 
      {
         // add a location
         BROWSEINFO bi;
         LPMALLOC pMalloc = NULL;
         LPITEMIDLIST pidlLocation = NULL;
         CString strLocation;
         CString strTitle;
         BOOL bGotLocation = FALSE;
         HKEY hLocKey = NULL;
         HKEY hKey = NULL;
         DWORD dwDisp = 0;

         strTitle.LoadString(IDS_ADDLOCATION_TITLE);
         ZeroMemory(&bi,sizeof(bi));
         bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
         bi.lpszTitle = strTitle;
         bi.hwndOwner = m_hwndParent;
         pidlLocation = SHBrowseForFolder(&bi);
         if (pidlLocation) 
         {
            bGotLocation = SHGetPathFromIDList(pidlLocation,strLocation.GetBuffer(MAX_PATH));
            strLocation.ReleaseBuffer();

            if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
            {
               pMalloc->Free(pidlLocation);
               pMalloc->Release();
            }

            if (bGotLocation) 
            {
               //If a drive such as D: is selected, path comes as D:\
               //Remove trailing backslash
               if( strLocation[ strLocation.GetLength() -1 ] == '\\' )
                  strLocation.SetAt(strLocation.GetLength() - 1, 0 );




               AddTemplateLocation(pFolder,  // the parent folder
                                   strLocation, // the location name
                                   FALSE, // strLocationKey is a file name ?
                                   FALSE  // refresh this location if it already exists ?
                                  );
            } 
            else
               AfxMessageBox(IDS_ADD_LOC_FAILED);
         }
         break;
      }

   case IDM_ADD_FOLDER: 
      {
         BROWSEINFO bi;
         LPMALLOC pMalloc = NULL;
         LPITEMIDLIST pidlRoot = NULL;
         LPITEMIDLIST pidlLocation = NULL;
         CString strCallBack;
         CString strPath;
         LPTSTR szPath = NULL;
         CString strDescription;
         CString strTitle;
         CString strLocationKey;
         bool fDuplicate = false;

         ULONG strleng = MAX_PATH;
         
         SHGetSpecialFolderLocation(m_hwndParent,CSIDL_DRIVES,&pidlRoot);

         ZeroMemory(&bi,sizeof(bi));
         strTitle.LoadString(IDS_ADDFILESANDFOLDERS_TITLE);
         bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_BROWSEINCLUDEFILES | BIF_USENEWUI
                    | BIF_EDITBOX|BIF_VALIDATE |BIF_NEWDIALOGSTYLE;
         bi.lpfn = BrowseCallbackProc;

         bi.hwndOwner = m_hwndParent;
         bi.lpszTitle = strTitle;
         bi.pidlRoot = pidlRoot;
         bi.lParam = (LPARAM)&strCallBack;
         unsigned int i;

         pidlLocation = SHBrowseForFolder(&bi);
         if ( !pidlLocation && strCallBack.IsEmpty() )
         {
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
               pMalloc->Free(pidlLocation);
               pMalloc->Free(pidlRoot);
               pMalloc->Release();
            }
            break;
         }

         if( pidlLocation )
         {
            //Raid #374069, 6/13/2001, Yanggao
            if( FALSE == SHGetPathFromIDList(pidlLocation,strPath.GetBuffer(MAX_PATH)) )
            {
                strPath.ReleaseBuffer();
                strPath = strCallBack;
            }
            else
            {
                strPath.ReleaseBuffer();
                if(!strCallBack.IsEmpty()) //Raid #374069, 4/23/2001
                {
                    if( -1 != strCallBack.Find(L':') )
                    {
                        strPath = strCallBack;
                    }
                    else
                    {
                        if( L'\\' == strPath.GetAt(strPath.GetLength()-1) )
                        {
                            if( L'\\' == strCallBack.GetAt(0) )
                            {
                                strCallBack.Delete(0, 1);
                            }    
                        }
                        else
                        {
                            if( L'\\' != strCallBack.GetAt(0) )
                            {
                                strPath = strPath + L"\\";
                            }
                        }
                        strPath = strPath + strCallBack;
                        strCallBack.Empty();
                    }
                }
            }
         }
         else
         {
            strPath = strCallBack;
            strCallBack.Empty();
         }

         szPath = UnexpandEnvironmentVariables(strPath);
         if (szPath) {
            strPath = szPath;

            LocalFree(szPath);
            szPath = NULL;
         }

         if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
            pMalloc->Free(pidlLocation);
            pMalloc->Free(pidlRoot);
            pMalloc->Release();
         }

         if (!strPath) {
            break;
         }

         PEDITTEMPLATE pet;
         PSCE_OBJECT_ARRAY poa;

         pet = GetTemplate(pFolder->GetInfFile());

         //
         // Need to grow the template's PSCE_OBJECT_ARRAY and add the new file entry
         //
         if ( !pet || !pet->pTemplate ) {
            break;
         }

         poa = pet->pTemplate->pFiles.pAllNodes;

         if ( !poa ) {
            poa = (PSCE_OBJECT_ARRAY)LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY));
            if ( poa ) {
               poa->Count = 0;
               poa->pObjectArray = NULL;
            } else {
               break;
            }

            pet->pTemplate->pFiles.pAllNodes = poa;
         }

         //
         // Make sure this file isn't already in the list:
         //
         fDuplicate = false;
         for (i=0;i < poa->Count;i++) {
            if (lstrcmpi(poa->pObjectArray[i]->Name,strPath) == 0) {
               fDuplicate = true;
               break;
            }
         }
         if (fDuplicate) {
            break;
         }

         PSECURITY_DESCRIPTOR pSelSD;
         SECURITY_INFORMATION SelSeInfo;
         BYTE ConfigStatus;

         pSelSD=NULL;
         SelSeInfo=0;
         INT_PTR nRet;

         if( GetAddObjectSecurity(
                      m_hwndParent,
                      strPath,
                      TRUE,
                      SE_FILE_OBJECT,
                      pSelSD,
                      SelSeInfo,
                      ConfigStatus
              ) != S_OK ){
                 break;
         }

        if ( pSelSD && SelSeInfo ) {

           poa->Count++;

           PSCE_OBJECT_SECURITY *pCopy;

           pCopy = (PSCE_OBJECT_SECURITY *)LocalAlloc(LPTR,poa->Count*sizeof(PSCE_OBJECT_SECURITY));
           if (!pCopy) {
              poa->Count--;
              ErrorHandler();
              LocalFree(pSelSD);
              pSelSD = NULL;
              break;
           }

           for (i=0;i<(poa->Count -1);i++) {
              pCopy[i] = poa->pObjectArray[i];
           }
           if ( poa->pObjectArray ) {
              LocalFree(poa->pObjectArray);
           }
           poa->pObjectArray = pCopy;
           poa->pObjectArray[poa->Count-1] = (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
           if (poa->pObjectArray[poa->Count-1]) {
              poa->pObjectArray[poa->Count-1]->Name = (PWSTR) LocalAlloc(LPTR,(strPath.GetLength()+1)*sizeof(TCHAR));
              if (poa->pObjectArray[poa->Count-1]->Name) {

                 lstrcpy(poa->pObjectArray[poa->Count-1]->Name,strPath);
                 poa->pObjectArray[poa->Count-1]->IsContainer = TRUE;
                 poa->pObjectArray[poa->Count-1]->Status = ConfigStatus;

                 poa->pObjectArray[poa->Count-1]->pSecurityDescriptor = pSelSD;
                 pSelSD = NULL;
                 poa->pObjectArray[poa->Count-1]->SeInfo = SelSeInfo;

                 pet->pTemplate->pFiles.pAllNodes = poa;
                 pet->SetDirty(AREA_FILE_SECURITY);


                 ((CFolder *)cookie)->RemoveAllResultItems();
                 m_pConsole->UpdateAllViews(NULL, cookie, UAV_RESULTITEM_UPDATEALL);
              } else {
                 //
                 // Couldn't allocate memory for the object's name,
                 // so remove the object from the count & array
                 //
                 LocalFree(poa->pObjectArray[poa->Count-1]);
                 poa->pObjectArray[poa->Count-1] = 0;
                 poa->Count--;
              }
           } else {
              //
              // Couldn't allocate the new object, so remove it from the count
              //
              poa->Count--;
           }

        }

         if ( pSelSD ) {
            LocalFree(pSelSD);
            pSelSD = NULL;
         }
         if (pet->pTemplate->pFiles.pAllNodes == NULL) {
            LocalFree(poa);
         }

         break;
      }

   case IDM_ADD_GROUPS: {
       PSCE_NAME_LIST pName = NULL;
       CWnd cWnd;

       cWnd.Attach( m_hwndParent );
       CGetUser gu;
       CSCEAddGroup dlg( &cWnd );

       if( (pFolder->GetModeBits() & MB_LOCAL_POLICY) ||
           (pFolder->GetModeBits() & MB_ANALYSIS_VIEWER) ){
             if (gu.Create(m_hwndParent, SCE_SHOW_BUILTIN | SCE_SHOW_ALIASES | SCE_SHOW_LOCALONLY |
                           SCE_SHOW_SCOPE_LOCAL )) {
                 pName = gu.GetUsers();
             }
       } else {
          dlg.m_dwFlags = SCE_SHOW_BUILTIN | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL;
          if (pFolder->GetModeBits() & MB_GROUP_POLICY) {
             //
             // Set the scope flags explicitely because we want to limit the added groups
             // here to ones from our own domain.  If we SetModeBits then CSCEADDGroup
             // will allow restricting groups that don't belong to us.
             //
             // Allow free-text groups to be added if the admin knows that a group will
             // exist on machines within the OU.
             //
             dlg.m_dwFlags |= SCE_SHOW_SCOPE_DOMAIN;
          } else {
             ASSERT(pFolder->GetModeBits() & MB_TEMPLATE_EDITOR);
             //
             // Allow people to pick any group to restrict because we have no idea
             // where this template will be used.  It could conceivably be for a
             // GPO on another domain, etc.
             //
             dlg.m_dwFlags |= SCE_SHOW_SCOPE_ALL;
          }
          CThemeContextActivator activator;
          if(dlg.DoModal() == IDOK)
          {
             if(dlg.GetUsers()->Name )
                pName = dlg.GetUsers();
          }
       }
       cWnd.Detach();

       if(pName){
             PSCE_GROUP_MEMBERSHIP pgm,pGroup,pgmBase,pgmProfile;
             PEDITTEMPLATE pTemplate;
             BOOL fDuplicate;
             BOOL fAnalysis = FALSE;

             if (pFolder->GetType() == AREA_GROUPS_ANALYSIS) {
                pTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                if (pTemplate) {
                   pgmBase = pTemplate->pTemplate->pGroupMembership;
                } else {
                   break;
                }
                pTemplate = GetTemplate(GT_LAST_INSPECTION,AREA_GROUP_MEMBERSHIP);
                if (pTemplate) {
                   pgmProfile = pTemplate->pTemplate->pGroupMembership;
                } else {
                   break;
                }
                fAnalysis = TRUE;
             } else {
                pTemplate = GetTemplate(pFolder->GetInfFile());
                if (!pTemplate) {
                   break;
                }
                pgm = pTemplate->pTemplate->pGroupMembership;
                fAnalysis = FALSE;
             }

            while (pName) {
               //
               // Make sure this isn't a duplicate
               //
               if (fAnalysis) {
                  pGroup = pgmProfile;
               } else {
                  pGroup = pgm;
               }

               fDuplicate = false;
               while (pGroup) {
                  if (lstrcmp(pGroup->GroupName,pName->Name) == 0) {
                     fDuplicate = true;
                     break;
                  }
                  pGroup = pGroup->Next;
               }

               if (false != fDuplicate) {
                  pName = pName->Next;
                  continue;
               }

               pGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR,sizeof(SCE_GROUP_MEMBERSHIP));

               if ( pGroup ) {

                  pGroup->GroupName = (PWSTR) LocalAlloc(LPTR,(lstrlen(pName->Name)+1)*sizeof(TCHAR));

                  if ( pGroup->GroupName ) {

                     lstrcpy(pGroup->GroupName,pName->Name);
                     pGroup->pMembers=NULL;
                     pGroup->pMemberOf=NULL;

                     if (fAnalysis) {

                        //
                        // First add the group to the LAST_INSPECTION area
                        //
                        pGroup->Next = pgmProfile;
                        pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED;
                        pgmProfile = pGroup;

                        //
                        // Also, add this group to the computer template in case a save is done at this point.
                        //
                        PEDITTEMPLATE pTemp = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                        pGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR,sizeof(SCE_GROUP_MEMBERSHIP));

                        if ( pTemp && pGroup ) {

                            pGroup->GroupName = (PWSTR) LocalAlloc(LPTR,(lstrlen(pName->Name)+1)*sizeof(TCHAR));

                            if ( pGroup->GroupName ) {

                                lstrcpy(pGroup->GroupName,pName->Name);
                                pGroup->pMembers=NULL;
                                pGroup->pMemberOf=NULL;
                                pGroup->Next = pgmBase;
                                pGroup->Status = SCE_GROUP_STATUS_NOT_ANALYZED;
                                pTemp->pTemplate->pGroupMembership = pGroup;
                            }
                            else {
                                //
                                // no memory
                                //
                                LocalFree(pGroup);
                                break;
                            }
                        } else {
                            //
                            // no memory
                            //
                            if (pGroup)
                                LocalFree(pGroup);
                            break;

                        }

                     } else {

                        pGroup->Status = 0;
                        pGroup->Next = pgm;
                        pgm = pGroup;
                     }
                  } else {
                     //
                     // no memory
                     //
                     LocalFree(pGroup);
                     break;
                  }
               } else {
                  break;
               }
               pName = pName->Next;

            }

            if (fAnalysis)
            {
               //
               // add to the last inspection list with status
               // not analyzed
               //
               pTemplate->pTemplate->pGroupMembership = pgmProfile;
            }
            else
            {
               pTemplate->pTemplate->pGroupMembership = pgm;
            }

            //
            // Need to SetDirty AFTER making the changes, not before.
            // Otherwise modes which write the changes out immediately
            // won't have a chance at them. (Bug 396549)
            //
            if (pTemplate)
            {
               pTemplate->SetDirty(AREA_GROUP_MEMBERSHIP);
            }

            CString ObjName = pgm->GroupName;
            pFolder->RemoveAllResultItems();
            pFolder->SetViewUpdate(TRUE);
            m_pConsole->UpdateAllViews(NULL, (LONG_PTR)pFolder,UAV_RESULTITEM_UPDATEALL);

            //Raid #258237, Yang Gao, 3/28/2001
            BOOL bGP = ( (GetModeBits() & MB_SINGLE_TEMPLATE_ONLY) == MB_SINGLE_TEMPLATE_ONLY );
            CAttribute* pAttr = NULL;
            CResult* pResult = NULL;
            HANDLE handle;
            POSITION pos = NULL;
            int tempcount = pFolder->GetResultListCount(); 
            pFolder->GetResultItemHandle ( &handle );
            if(!handle)
            {
               break;
            }
            pFolder->GetResultItem (handle, pos, &pResult);
            while(pResult)
            {
               if(!pos)
               {
                  //Find the last one;
                  break;
               }
               pFolder->GetResultItem(handle, pos, &pResult);
            }
            pFolder->ReleaseResultItemHandle (handle);
            
            if( pResult && (pResult->GetType() == ITEM_PROF_GROUP) )
            {
               if( bGP )
                  pAttr = new CDomainGroup;
               else
                  pAttr = new CConfigGroup(0);
               
               if( pAttr )
               {
                  pAttr->SetSnapin(pResult->GetSnapin());
                  pAttr->Initialize(pResult);
                  pAttr->SetReadOnly(FALSE);
                  pAttr->SetTitle(pResult->GetAttrPretty());

                  HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);

                  PROPSHEETHEADER psh;
                  HPROPSHEETPAGE hpsp[1];

                  hpsp[0] = hPage;

                  ZeroMemory(&psh,sizeof(psh));

                  psh.dwSize = sizeof(psh);
                  psh.dwFlags = PSH_DEFAULT;
                  psh.nPages = 1;
                  psh.phpage = hpsp;

                  CString str=_T("");
                  str.LoadString(IDS_SECURITY_PROPERTIES);
                  ObjName = ObjName + str;

                  psh.pszCaption = (LPCTSTR)ObjName;

                  psh.hwndParent = pResult->GetSnapin()->GetParentWindow();  

                  int nRet = (int)PropertySheet(&psh);
               }
            }
       }

       break;
       }
   case IDM_SAVEAS: {
         PEDITTEMPLATE pTemplate;
         CString strDefExt;
         CString strFilters;
         CString strNewfile;
         HWND hwndParent;
         SCESTATUS status;

         PSCE_ERROR_LOG_INFO ErrLog;

         pTemplate = GetTemplate(pFolder->GetInfFile());

         strDefExt.LoadString(IDS_LOGFILE_DEF_EXT);
         strFilters.LoadString(IDS_PROFILE_FILTER);

         m_pConsole->GetMainWindow(&hwndParent);
         // Translate filter into commdlg format (lots of \0)
         LPTSTR szFilter = strFilters.GetBuffer(0); // modify the buffer in place
         LPTSTR pch = szFilter;
         // MFC delimits with '|' not '\0'
         while ((pch = _tcschr(pch, '|')) != NULL)
            *pch++ = '\0';
          // do not call ReleaseBuffer() since the string contains '\0' characters

         strNewfile = pFolder->GetInfFile();

         OPENFILENAME ofn;
         ::ZeroMemory (&ofn, sizeof (OPENFILENAME));
         ofn.lStructSize = sizeof(OPENFILENAME);
         ofn.lpstrFilter = szFilter;
         ofn.lpstrFile = strNewfile.GetBuffer(MAX_PATH),
         ofn.nMaxFile = MAX_PATH;
         ofn.lpstrDefExt = strDefExt,
         ofn.hwndOwner = m_hwndParent;
         ofn.Flags = OFN_HIDEREADONLY |
                     OFN_OVERWRITEPROMPT |
                     OFN_DONTADDTORECENT|
                     OFN_NOREADONLYRETURN |
                     OFN_PATHMUSTEXIST |
                     OFN_EXPLORER;

         if (GetSaveFileName(&ofn)) {
            strNewfile.ReleaseBuffer();

         //
         // No need to check if this is the same file or not since the
         // CEditTemplate::Save will handle that
         //
         if (!pTemplate->Save(strNewfile)) {
            MyFormatMessage(
                           SCESTATUS_ACCESS_DENIED,
                           0,
                           NULL,
                           strFilters
                           );

            strFilters += strNewfile;
            strNewfile.LoadString(IDS_SAVE_FAILED);
            ::MessageBox( hwndParent, strFilters, strNewfile, MB_OK );
         } 
         else 
         {
               //
               // At this point the new template has succesfully been written, so refresh
               // the template that was "save as'd" back to its original state.
               //
               if (0 != _wcsicmp(strNewfile, pTemplate->GetInfName())) 
               {
                   DWORD dwErr = pTemplate->RefreshTemplate(0);
                   if ( 0 != dwErr )
                   {
                       CString strErr;
 
                       MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
                       AfxMessageBox(strErr);
                       break;;
                   }
               }

               //
               // find the parent node and refresh locations.
               //
               if ( m_pScope ) 
               {
                  hr = m_pScope->GetParentItem(pFolder->GetScopeItem()->ID,
                                               &pItemChild,
                                               &FindCookie
                                              );

                  if ( SUCCEEDED(hr) ) 
                  {
                     //
                     // do not need to refresh the old location, just refresh the new location (maybe same)
                     //
                     int npos = strNewfile.ReverseFind(L'\\');
                     CString strOldfile = pFolder->GetInfFile();
                     int npos2 = strOldfile.ReverseFind(L'\\');

                     // TODO: check and see if npos should be compared to -1 here
                     if ( npos && (npos != npos2 ||
                                   _wcsnicmp((LPCTSTR)strNewfile,
                                             (LPCTSTR)strOldfile, npos) != 0) ) 
                     {
                        //
                        // a different location is specified
                        // find grand parent (in order to add the location)
                        //
                        HSCOPEITEM GrandParent;
                        MMC_COOKIE GrandCookie;

                        hr = m_pScope->GetParentItem(pItemChild,
                                                     &GrandParent,
                                                     &GrandCookie
                                                    );
                        if ( SUCCEEDED(hr) ) {

                           //
                           // check if a new location is specified,
                           // if it is, add the location to registry and scope pane
                           //
                           AddTemplateLocation((CFolder *)GrandCookie,
                                               strNewfile,
                                               TRUE, // this is a file name
                                               TRUE  // refresh this location if it already exists
                                              );

                        }
                     } else {
                        //
                        // a new template in the same location, refresh it
                        //
                        ReloadLocation((CFolder *)FindCookie);
                     }

                  }
               }
            }
         }
         break;
      }

   case IDM_SAVE: {

         PEDITTEMPLATE pTemplate;
         CString strInf;
         if ( ANALYSIS == pFolder->GetType() ) {
            //
            // analysis
            //
            strInf = GT_COMPUTER_TEMPLATE;
         } else {
            strInf = pFolder->GetInfFile();
         }

         pTemplate = GetTemplate(strInf);
         if (pTemplate && pTemplate->IsDirty()) {

            //               pTemplate->Save(pFolder->GetInfFile());
            pTemplate->Save(strInf);
         }
         break;
      }

   case IDM_ADD_REGISTRY:
   case IDM_ADD_ANAL_KEY: {
         // add a result entry
         CRegistryDialog rd;
         rd.SetConsole(m_pConsole);
         rd.SetComponentData(this);

         if ( IDM_ADD_REGISTRY == nCommandID ) {
            rd.SetProfileInfo(GetTemplate(pFolder->GetInfFile()),
                              pFolder->GetType() );
         } else {
            rd.SetProfileInfo(GetTemplate(GT_COMPUTER_TEMPLATE),
                              pFolder->GetType() );
            rd.SetHandle(SadHandle);
         }

         rd.SetCookie(cookie);
         CThemeContextActivator activator;
         rd.DoModal();

         break;
      }
   case IDM_ADD_ANAL_FILES:
   case IDM_ADD_ANAL_FOLDER:

      if ( IDM_ADD_ANAL_FILES == nCommandID ) {
         hr = AddAnalysisFilesToList(pDataObject, cookie,pFolder->GetType());

      } else if ( IDM_ADD_ANAL_FOLDER == nCommandID ) {
         hr = AddAnalysisFolderToList(pDataObject, cookie,pFolder->GetType());

      }
      if ( SUCCEEDED(hr) ) 
      {
         DeleteChildrenUnderNode(pFolder);
         if ( pFolder->IsEnumerated() ) 
         {
            pFolder->Set(FALSE);
            EnumerateScopePane(cookie,pFolder->GetScopeItem()->ID);
         }
      }

      break;

   case IDM_GENERATE:
         hr = OnSaveConfiguration();
         break;

   case IDM_ASSIGN:
         SCESTATUS sceStatus;
         hr = OnAssignConfiguration(&sceStatus);
         break;

   case IDM_SECURE_WIZARD: 
         hr = OnSecureWizard();
         break;

   case IDM_APPLY: 
      {
         //
         // If the computer template has been changed then save it before we
         // can apply it so we don't lose any changes
         //
         PEDITTEMPLATE pet = GetTemplate(GT_COMPUTER_TEMPLATE);
         if (pet && pet->IsDirty()) {
            pet->Save();
         }

         m_pUIThread->PostThreadMessage(SCEM_APPLY_PROFILE,(WPARAM)(LPCTSTR)SadName,(LPARAM)this);
         break;
      }
  case IDM_REMOVE:
      //
      // delete the location from registry
      //
      DeleteLocationFromReg(pFolder->GetName());
      // pFolder is not deleted after DeleteChildrenUnderNode
      DeleteChildrenUnderNode( pFolder );
      // set focus to the parent, then delete this node

      DeleteThisNode(pFolder);


      break;

   case IDM_DELETE: {
      tmpstr.LoadString(IDS_CONFIRM_DELETE_TEMPLATE);

      if ( IDNO == AfxMessageBox(tmpstr,MB_YESNO, 0) ) {
         return FALSE;
      }
      /*
          SHFILEOPSTRUCT sfo;
          TCHAR *szFile;

          // delete the file
          ZeroMemory(&sfo,sizeof(sfo));
          sfo.wFunc = FO_DELETE;
          sfo.fFlags = FOF_ALLOWUNDO;
          // Must be double NUL terminated;
          szFile = new TCHAR [ lstrlen(pFolder->GetName()) + 2 ];
          lstrcpy(szFile,pFolder->GetName());
          sfo.pFrom = szFile;
   */
      DeleteFile(pFolder->GetName());

      // SHFileOperation returns 0 on success
      //      if (!SHFileOperation(&sfo)) {
      // pFolder is not deleted after DeleteChildrenUnderNode
      DeleteChildrenUnderNode( pFolder );
      // set focus to the parent, then delete this node

      DeleteThisNode(pFolder);
      //      }

      //       delete[] szFile;
      break;
      }
   case IDM_RELOAD:
      if(pFolder->GetType() == LOCALPOL){
         //
         // Reload local policy.
         //
         UnloadSadInfo();

         DeleteTemplate( GT_LOCAL_POLICY );
         DeleteTemplate( GT_EFFECTIVE_POLICY );
         LoadSadInfo( FALSE );

         RefreshAllFolders();
      } else if (pFolder->GetType() == PROFILE) {
         //
         // bug 380290 - do the right thing when refreshing profiles
         //
         CEditTemplate *pet;
         int bSave;
         CString strSavep;
         pet = GetTemplate(pFolder->GetInfFile());
         if (pet->IsDirty()) {
            AfxFormatString1( strSavep, IDS_SAVE_P, pet->GetFriendlyName());
            bSave = AfxMessageBox(strSavep,MB_YESNOCANCEL|MB_ICONQUESTION);
            if (IDYES == bSave) {
               pet->Save();
            } else if (IDCANCEL == bSave) {
               break;
            }
         }
         
         DWORD dwErr = pet->RefreshTemplate(AREA_ALL);
         if ( 0 != dwErr )
         {
            CString strErr;

            MyFormatResMessage (SCESTATUS_SUCCESS, dwErr, NULL, strErr);
            AfxMessageBox(strErr);
            break;
         }
         RefreshAllFolders();
      } else if (pFolder->GetType() == LOCATIONS) {
         //
         // Refresh location.
         //
         hr = ReloadLocation(pFolder);
      } else {
         //
         // Should never get here
         //
      }
      break;

   case IDM_COPY: {
      if (!SUCCEEDED(OnCopyArea(pFolder->GetInfFile(),pFolder->GetType()))) {
         AfxMessageBox(IDS_COPY_FAILED);
      }
      break;
   }

   case IDM_CUT:
      break;

   case IDM_PASTE:
      OnPasteArea(pFolder->GetInfFile(),pFolder->GetType());

      //
      // after information is pasted, update all views related to the cookie
      //
      if ( m_pConsole ) {
         pFolder->RemoveAllResultItems();
         m_pConsole->UpdateAllViews(NULL , (LPARAM)pFolder, UAV_RESULTITEM_UPDATEALL);
      }

      break;

   default:
      ASSERT(FALSE); // Unknown command!
      break;
   }

   return S_OK;
}


//+------------------------------------------------------------------------------------------
// CComponentDataImpl::RefreshAllFolders
//
// Updates all folders that are enumerated and have result items.
//
// Returns: The number of folders updated, or -1 if there is an error.
//
//-------------------------------------------------------------------------------------------
int
CComponentDataImpl::RefreshAllFolders()
{
   if( !m_pScope ){
      return -1;
   }

   int icnt = 0;
   POSITION pos = m_scopeItemList.GetHeadPosition();
   while(pos){
      CFolder *pFolder = m_scopeItemList.GetNext(pos);
      if(pFolder && pFolder->GetResultListCount() ){
         pFolder->RemoveAllResultItems();
         m_pConsole->UpdateAllViews(NULL, (LPARAM)pFolder, UAV_RESULTITEM_UPDATEALL);
         icnt++;
      }
   }
   return icnt;
}

///////////////////////////////////////////////////////////////////////////
//  Method:     AddTemplateLocation
//
//  Synopsis:   Add a template location if it does not exist
//              and if requested, refresh the location if it exists.
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [NameStr]   - The display name of the new node
//              [theCookie] - the folder's cookie if it already exists, or NULL
//
//  Returns:    TRUE = the folder already exists
//              FALSE = the folder does not exist
//
////////////////////////////////////////////////////////////////////
BOOL
CComponentDataImpl::AddTemplateLocation(CFolder *pParent,
                                        CString szName,
                                        BOOL bIsFileName,
                                        BOOL bRefresh
                                       )
{

   int npos;

   if ( bIsFileName ) {
      npos = szName.ReverseFind(L'\\');

   } else {
      npos = szName.GetLength();
   }

   CString strTmp = szName.Left(npos);
   LPTSTR sz = strTmp.GetBuffer(MAX_PATH);

   //
   // Can't put '\' in the registry, so convert to '/'
   //
   while (sz = wcschr(sz,L'\\')) {
      *sz = L'/';
   }
   strTmp.ReleaseBuffer();

   CString strLocationKey;
   strLocationKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);

   BOOL bRet = FALSE;
   HKEY hLocKey = NULL;
   HKEY hKey = NULL;
   DWORD dwDisp = 0;
   DWORD rc = E_FAIL;

   //
   // Bug 119208: Store in HKCU rather than in HKLM
   //
   rc = RegCreateKeyEx(
                       HKEY_CURRENT_USER,
                       strLocationKey,
                       0,
                       L"",
                       0,
                       KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY  ,
                       NULL,
                       &hLocKey,
                       &dwDisp);

   if (ERROR_SUCCESS == rc) {
      if (ERROR_SUCCESS == RegCreateKeyEx(
                                         hLocKey,
                                         strTmp,
                                         0,
                                         L"",
                                         0,
                                         KEY_WRITE | KEY_CREATE_SUB_KEY,
                                         NULL,
                                         &hKey,
                                         &dwDisp)) {
         bRet = TRUE;
         RegCloseKey(hKey);
      }

      RegCloseKey(hLocKey);
   }

   if ( bRet ) {
      //
      // key is added to registry, create the node in scope pane
      //
      MMC_COOKIE FindCookie;

      CFolder *pNewParent;

      if (!pParent) {
         pNewParent = m_ConfigFolder;
      } else {
         pNewParent = pParent;
      }


      if (!IsNameInChildrenScopes(pNewParent, //pParent,
                                  szName.Left(npos),
                                  &FindCookie)) {
         CreateAndAddOneNode(pNewParent, //pParent,
                             (LPTSTR((LPCTSTR)(szName.Left(npos)))),
                             NULL,
                             LOCATIONS,
                             TRUE);
      }

      if ( FindCookie && bRefresh ) {

         ReloadLocation((CFolder *)FindCookie);

      }

   }

   return bRet;
}


///////////////////////////////////////////////////////////////////////////
//  Method:     IsNameInChildrenScopes
//
//  Synopsis:   detects if a node already exists under the subtree of this node.
//              The existence is determined by the folder name string comparison.
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [NameStr]   - The display name of the new node
//              [theCookie] - the folder's cookie if it already exists, or NULL
//
//  Returns:    TRUE = the folder already exists
//              FALSE = the folder does not exist
//
////////////////////////////////////////////////////////////////////
BOOL
CComponentDataImpl::IsNameInChildrenScopes(CFolder* pParent,
                                           LPCTSTR NameStr,
                                           MMC_COOKIE *theCookie)
{
   HSCOPEITEM        pItemChild=NULL;
   MMC_COOKIE        lCookie=NULL;
   CFolder*          pFolder = 0;
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   psdi = 0;
   HSCOPEITEM        hid = 0;

   if (pParent) 
   {
      psdi = pParent->GetScopeItem();
      if (psdi)
         hid = psdi->ID;
   }
   hr = m_pScope->GetChildItem(hid, &pItemChild, &lCookie);
   // find a child item
   while ( SUCCEEDED(hr) ) 
   {
      pFolder = (CFolder*)lCookie;
      if ( pFolder ) 
      {
         if ( _wcsicmp(pFolder->GetName(), NameStr) == 0 ) 
         {
            if ( theCookie )
               *theCookie = lCookie;
            return TRUE;
         }
      }
      hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);
   }

   if ( theCookie )
      *theCookie = NULL;

   return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Method:     CreateAndAddOneNode
//
//  Synopsis:   Creates and adds a folder to the scope pane
//
//
//  Arguments:  [pParent]   - The parent node under which to add the new node
//              [Name]      - The display name of the new node
//              [Desc]      - The description of the new node
//              [type]      - The folder type of the new node
//              [bChildren] - True if there are children folders under the new node
//              [szInfFile] - The name of the Inf file associated with the new node
//              [pData]     - A pointer to extra data
//
//  Returns:    The CFolder created if successful, NULL otherwise
//
//  History:
//
//---------------------------------------------------------------------------
CFolder*
CComponentDataImpl::CreateAndAddOneNode(CFolder* pParent,
                                        LPCTSTR Name,
                                        LPCTSTR Desc,
                                        FOLDER_TYPES type,
                                        BOOL bChildren,
                                        LPCTSTR szInfFile,
                                        LPVOID pData,
                                        DWORD status)
{
   DWORD dwMode;
   HRESULT hr;

   //
   // The new node inherits its parent's SCE mode
   //
   if (pParent) {
      dwMode = pParent->GetMode();
   } else {
      return NULL;
   }

   CFolder* folder = new CFolder();
   if (!folder) {
      return NULL;
   }

   //
   // Create the folder objects with static data
   //

   //
   // Find the icon index for the folder type
   //
   int nImage = GetScopeImageIndex(type, status);

   hr = folder->Create( Name,
                        Desc,
                        szInfFile,
                        nImage,
                        nImage,
                        type,
                        bChildren,
                        dwMode,
                        pData);
   if (FAILED(hr)) {
      delete folder;
      return NULL;
   }

   m_scopeItemList.AddTail(folder);

   HSCOPEITEM hItem = NULL;
   LONG_PTR pCookie;
   CString strThis, strNext;

   switch(type){
   case AREA_REGISTRY_ANALYSIS:
   case AREA_FILESTORE_ANALYSIS:
   case REG_OBJECTS:
   case FILE_OBJECTS:
      //
      // Insert items in alpha order.
      //
       if( m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &hItem, &pCookie) == S_OK && pCookie){

           folder->GetScopeItem()->lParam = (LPARAM)folder;
           folder->GetDisplayName( strThis, 0);
           folder->GetScopeItem()->mask &= ~(SDI_PARENT | SDI_PREVIOUS);

           while(hItem){
               reinterpret_cast<CFolder *>(pCookie)->GetDisplayName(strNext, 0);
               int i = lstrcmpi( strThis, strNext );
               if( i < 0  ){
                   folder->GetScopeItem()->relativeID = hItem;
                   folder->GetScopeItem()->mask |= SDI_NEXT;
                   break;
               }
               if( m_pScope->GetNextItem(hItem, &hItem, &pCookie) != S_OK){
                   hItem = NULL;
               }

           }

       }
       break;
   }
   if(hItem == NULL){
       folder->GetScopeItem()->mask &= ~(SDI_PREVIOUS | SDI_NEXT);
       folder->GetScopeItem()->mask |= SDI_PARENT;
       folder->GetScopeItem()->relativeID = pParent->GetScopeItem()->ID;
   }

   //
   // Set the folder as the cookie
   //
   folder->GetScopeItem()->displayname = MMC_CALLBACK;
   folder->GetScopeItem()->mask |= SDI_PARAM;
   folder->GetScopeItem()->lParam = reinterpret_cast<LPARAM>(folder);
   folder->SetCookie(reinterpret_cast<MMC_COOKIE>(folder));
   m_pScope->InsertItem(folder->GetScopeItem());

   folder->GetScopeItem()->relativeID = pParent->GetScopeItem()->ID;
   //
   // Note - On return, the ID member of 'GetScopeItem()'
   // contains the handle to the newly inserted item!
   //
   ASSERT(folder->GetScopeItem()->ID != NULL);
   return folder;

}

void CComponentDataImpl::DeleteChildrenUnderNode(CFolder* pParent)
{
   HSCOPEITEM pItemChild=NULL;
   MMC_COOKIE lCookie=NULL;
   CFolder*   pFolder=NULL;


   pItemChild = NULL;
   HRESULT hr = E_FAIL;

   if (pParent && pParent->GetScopeItem()) {
      hr = m_pScope->GetChildItem(pParent->GetScopeItem()->ID, &pItemChild, &lCookie);
   }
   // find a child item
   while ( pItemChild ) {
      pFolder = (CFolder*)lCookie;

      if ( pFolder )
         DeleteChildrenUnderNode(pFolder); // delete children first

      // get next pointer
      hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);

      // delete this node
      if ( pFolder)
         DeleteThisNode(pFolder);
   }
}

void CComponentDataImpl::DeleteThisNode(CFolder* pNode)
{
   ASSERT(pNode);

   POSITION pos=NULL;

   // delete from the m_scopeItemList
   if ( FindObject((MMC_COOKIE)pNode, &pos) ) {
      if ( pos ) {
         m_scopeItemList.RemoveAt(pos);
      }
   }

   pos = NULL;
   LONG_PTR fullKey;
   CDialog *pDlg = MatchNextPopupDialog(
                        pos,
                        (LONG_PTR)pNode,
                        &fullKey
                        );
   while( pDlg ){
        m_scopeItemPopups.RemoveKey( fullKey );
        pDlg->ShowWindow(SW_HIDE);

        if(m_pUIThread){
            m_pUIThread->PostThreadMessage(
                            SCEM_DESTROY_DIALOG,
                            (WPARAM)pDlg,
                            (LPARAM)this
                            );
        }
        pDlg = NULL;
        if(!pos){
            break;
        }
        pDlg = MatchNextPopupDialog(
                        pos,
                        (LONG_PTR)pNode,
                        &fullKey
                        );

   }

   if (m_pScope && pNode && pNode->GetScopeItem()) {
      HRESULT hr = m_pScope->DeleteItem(pNode->GetScopeItem()->ID, TRUE);
   }

   // delete the node
   delete pNode;

}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//
STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{

   TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);
   return S_FALSE;
}

STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
   HRESULT hr=S_FALSE;

   switch (event) {
      case MMCN_BTN_CLICK:
         TCHAR szMessage[MAX_PATH];
         wsprintf(szMessage, _T("CommandID %ld"),param);
         AfxMessageBox(szMessage);

         break;
      case MMCN_SELECT:
         // TRACE(_T("CSnapin::ControlbarNotify - MMCN_SEL_CHANGE\n"));
         HandleExtToolbars(arg, param);
         break;

         /* case MMCN_RENAME:
               TRACE(_T("CSnapin::ControlbarNotify - MMCN_RENAME (ignored)\n"));
               break;
            case MMCN_CLICK:
               TRACE(_T("CSnapin::ControlbarNotify - MMCN_CLICK (ignored)\n"));
               break;
            case MMCN_DELETE:
               TRACE(_T("CSnapin::ControlbarNotify - MMCN_DELETE (ignored)\n"));
               break;

            /*  TRACEMMCN(MMCN_ACTIVATE)
             TRACEMMCN(MMCN_ADD_IMAGES)
             TRACEMMCN(MMCN_CONTEXTMENU)
             TRACEMMCN(MMCN_DBLCLICK)
             TRACEMMCN(MMCN_EXPAND)
             TRACEMMCN(MMCN_MINIMIZED)
             TRACEMMCN(MMCN_PROPERTY_CHANGE)
             TRACEMMCN(MMCN_REMOVE_CHILDREN)
             TRACEMMCN(MMCN_SHOW)
             TRACEMMCN(MMCN_VIEW_CHANGE)
           */
      default:
         ASSERT(FALSE); // Unhandle event
   }


   return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
   if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

   // Make sure both data object are mine
   HRESULT hr = S_FALSE;

   INTERNAL *pA = ExtractInternalFormat(lpDataObjectA);
   INTERNAL *pB = ExtractInternalFormat(lpDataObjectB);

   if (pA != NULL && pB != NULL) {
      hr = (*pA == *pB) ? S_OK : S_FALSE;
   }

   FREE_INTERNAL(pA);
   FREE_INTERNAL(pB);

   return hr;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assum sort is ascending when comparing.

STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
   if (pnResult == NULL) {
      ASSERT(FALSE);
      return E_POINTER;
   }

   // check col range
   int nCol = *pnResult;
   ASSERT(nCol >=0 && nCol< 3);

   *pnResult = 0;
   if ( nCol < 0 || nCol >= 3)
      return S_OK;

   CString strA;
   CString strB;
   RESULTDATAITEM rid;

   CResult* pDataA = reinterpret_cast<CResult*>(cookieA);
   CResult* pDataB = reinterpret_cast<CResult*>(cookieB);


   ASSERT(pDataA != NULL && pDataB != NULL);

   ZeroMemory(&rid,sizeof(rid));
   rid.mask = RDI_STR;
   rid.bScopeItem = FALSE;
   rid.nCol = nCol;

   rid.lParam = cookieA;
   GetDisplayInfo(&rid);
   strA = rid.str;
   
   rid.lParam = cookieB;
   GetDisplayInfo(&rid);
   strB = rid.str;

   if (strA.IsEmpty()) {
      *pnResult = strB.IsEmpty() ? 0 : 1;
   } else if (strB.IsEmpty()) {
      *pnResult = -1;
   } else {
      //
      // Compare in a locale dependant manner
      //
      // Subtract 2 from CS to make result equivalent to strcmp
      //
      *pnResult = CompareString(LOCALE_SYSTEM_DEFAULT,
                                NORM_IGNORECASE,
                                (LPCTSTR)strA,-1, (LPCTSTR)strB,-1) -2;
   }

   return S_OK;
}

void CSnapin::HandleStandardVerbs(LPARAM arg, LPDATAOBJECT lpDataObject)
{

   if (lpDataObject == NULL) {
      return;
   }
   INTERNAL* pAllInternal = ExtractInternalFormat(lpDataObject);
   INTERNAL* pInternal = pAllInternal;

   if(pAllInternal &&
      pAllInternal->m_cookie == (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE ){
      pInternal++;
   }

   BOOL bSelect = HIWORD(arg);
   BOOL bScope = LOWORD(arg);

   if (!bSelect) {
      m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,HIDDEN,TRUE);
      m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE,HIDDEN,TRUE);
      m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN,HIDDEN,TRUE);
      return;
   }

   // You should crack the data object and enable/disable/hide standard
   // commands appropriately.  The standard commands are reset everytime you get
   // called. So you must reset them back.

   // arg == TRUE -> Selection occured in the Scope view
   // arg == FALSE -> Selection occured in the Result view

   // add for delete operations
   if (m_pConsoleVerb && pInternal) {

      m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);

      if (pInternal->m_type == CCT_SCOPE) {
         MMC_COOKIE cookie = pInternal->m_cookie;
         if ( cookie ) {
            CFolder *pFolder = (CFolder*)cookie;
            if (pFolder->GetType() == REG_OBJECTS ||
                pFolder->GetType() == FILE_OBJECTS) {
               m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,ENABLED,TRUE);
               m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            } else {
               m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,HIDDEN,TRUE);
               m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            }
         }

         m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN,ENABLED,TRUE);
      }

      if ( pInternal->m_type == CCT_RESULT ) {


         if ( pInternal->m_cookie != NULL ) {

            RESULT_TYPES type = ((CResult *)pInternal->m_cookie)->GetType();
            if ( type == ITEM_PROF_GROUP ||
                 type == ITEM_PROF_REGSD ||
                 type == ITEM_PROF_FILESD
                 ) {
               m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
            }
            if (type != ITEM_OTHER) {
               if (pInternal->m_cookie != (MMC_COOKIE)MMC_MULTI_SELECT_COOKIE) {
                  m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                  m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
               } else {
                  //
                  // Multi select properties not supported (yet)
                  //
                  m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
               }
            }
         }
      } else if ( pInternal->m_type == CCT_SCOPE ) {
         CFolder *pFolder = (CFolder *)pInternal->m_cookie;

         m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
         m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

         if( NONE == pInternal->m_foldertype && bSelect && bScope ) //Raid #257461, 4/19/2001
         {
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN,TRUE);
         }
         //
         // for scope nodes, only the location and template are allowed to delete
         //
         if ( pFolder != NULL ) {
            FOLDER_TYPES fType = pFolder->GetType();

            //
            // do not expose 'delete' menu option in single template mode
            //
            if ( LOCATIONS == fType || // PROFILE == fType) {
                 ( fType == PROFILE &&
                   !( pFolder->GetModeBits() & MB_SINGLE_TEMPLATE_ONLY )) ) {

                if(fType == PROFILE && (pFolder->GetState() & CFolder::state_Unknown) ){
                    // We must load the template and find out if it is a valid
                    // configuration template.
                    if(!GetTemplate( pFolder->GetInfFile(), AREA_USER_SETTINGS)){
                        pFolder->SetState( CFolder::state_InvalidTemplate, ~CFolder::state_Unknown );
                    } else {
                        pFolder->SetState( 0, ~CFolder::state_Unknown );
                    }
                }

                if( fType != PROFILE || !(pFolder->GetState() & CFolder::state_InvalidTemplate) ) {
                    if (CAttribute::m_nDialogs == 0) {
                       m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                       m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
                    }
                }
            }
         }
      }
   }

   if (pAllInternal) {
      FREE_INTERNAL(pAllInternal);
   }
}


void CSnapin::HandleExtToolbars(LPARAM arg, LPARAM param)
{
   /*
       static BOOL bSwap=FALSE;
       INTERNAL* pInternal = NULL;

       HRESULT hr;

       if (arg == TRUE) // Scope view selection.  [0] Old dataobject in selection
       {                //                        [1] New dataobject in selection

           LPDATAOBJECT rgpDataObject[2] = {NULL, NULL};
           LPDATAOBJECT* ppDataObject = reinterpret_cast<LPDATAOBJECT*>(param);
           rgpDataObject[0] = *ppDataObject;
           ppDataObject++;
           rgpDataObject[1] = *ppDataObject;

           if (rgpDataObject[1] != NULL)
               pInternal = ExtractInternalFormat(rgpDataObject[1]); // The new selection

           // Attach the toolbars to the window
           hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
           ASSERT(SUCCEEDED(hr));

           hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
           ASSERT(SUCCEEDED(hr));


       }
       else // Result view selection
       {
           LPDATAOBJECT lpDataObject = reinterpret_cast<LPDATAOBJECT>(param);

           if (lpDataObject != NULL)
               pInternal = ExtractInternalFormat(lpDataObject);

           // Attach the toolbars to the window
           hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
           ASSERT(SUCCEEDED(hr));

           hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
           ASSERT(SUCCEEDED(hr));

       }

       if (pInternal != NULL)
       {

           long cookie = pInternal->m_cookie;

           if (pInternal->m_type == CCT_SCOPE) // Scope Item
           {
               m_pToolbar1->SetButtonState(1, ENABLED,       FALSE);  // 1 = CMD ID
               m_pToolbar1->SetButtonState(2, CHECKED,       TRUE);  // 2 = CMD ID
               m_pToolbar1->SetButtonState(3, HIDDEN,        TRUE);  // 3 = CMD ID
               m_pToolbar1->SetButtonState(4, INDETERMINATE, TRUE);  // 4 = CMD ID
               m_pToolbar1->SetButtonState(5, BUTTONPRESSED, TRUE);  // 5 = CMD ID
           }
           else // Result Item
           {
               bSwap = !bSwap;
               // Above is the correct way
               m_pToolbar2->SetButtonState(20, CHECKED,       bSwap);
               m_pToolbar2->SetButtonState(30, HIDDEN,        bSwap);
               m_pToolbar2->SetButtonState(40, INDETERMINATE, bSwap);
               m_pToolbar2->SetButtonState(50, BUTTONPRESSED, bSwap);
           }
       }
       else
       {
           // We are no longer selected.
           // You could detach your toolbars at this point.  If you don't the
           // console will automatically do it for you.
       }

       if (pInternal)
           FREE_INTERNAL(pInternal);
   */
}


/*
template <> void AFXAPI DestructElements <CDialog> ( CDialog* pDlg, int nCount )
{
    for ( int i = 0; i < nCount; i++, pDlg++ )
    {
        delete pDlg;
    }
}*/


//+--------------------------------------------------------------------------
//
//  Method:     GetTemplate
//
//  Synopsis:   Get the CEditTemplate for the given INF file, checking first
//              in the cache of loaded CEditTemplates or creating a new one
//              if the INF file has not yet been loaded.
//
//  Arguments:  [szInfFile] - The path and name of the INF file to retrieve
//              [aiArea]    - The SCE area that we're interested for the template
//             *[pErr]      - [out] a PDWORD to get error information
//
//  Returns:    A pointer to the CEditTemplate requested, or NULL if it's not
//              available.
//              *[pErr]  - the resource id of an error string, if an error occurs
//
//
//  History:
//
//---------------------------------------------------------------------------
PEDITTEMPLATE
CComponentDataImpl::GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiArea, DWORD *pErr)
{
   PEDITTEMPLATE pTemplateInfo = NULL;
   BOOL bNewTemplate = FALSE;
   PVOID pHandle = NULL;
   SCESTATUS rc=0;
   LPTSTR szKey;

   if (pErr) {
      *pErr = 0;
   }

   ASSERT(szInfFile);
   if (!szInfFile) {
      return NULL;
   }

   //
   // Allocate space for key.
   //
   szKey = new TCHAR[ lstrlen( szInfFile ) + 1];
   if(!szKey){
       return NULL;
   }
   lstrcpy(szKey, szInfFile);
   _wcslwr( szKey );


   //
   // Find pTemplateInfo in our cache
   //
   m_Templates.Lookup(szKey, pTemplateInfo);

   //
   // If it's not there then create a new one
   //
   if (!pTemplateInfo) {
      bNewTemplate = TRUE;
      pTemplateInfo = new CEditTemplate;
      if (!pTemplateInfo) {
         if (pErr) {
            *pErr = IDS_ERROR_CANT_OPEN_PROFILE;
         }
         goto done;
      }
      pTemplateInfo->SetInfFile(szInfFile);
      pTemplateInfo->SetNotificationWindow(m_pNotifier);
      pTemplateInfo->pTemplate = NULL;
   }

   if (GetModeBits() & MB_WRITE_THROUGH) {
      pTemplateInfo->SetWriteThrough(TRUE);
   }

   //
   // Check that the pTemplateInfo has the area that we're looking for, otherwise
   // load that area
   //
   if (!pTemplateInfo->CheckArea(aiArea)) {
      //
      // Don't reload the areas we already have since they may be dirty and we'll have a
      // huge memory problem.
      //
      aiArea &= ~(pTemplateInfo->QueryArea());

      if ((lstrcmp(GT_COMPUTER_TEMPLATE,szInfFile) == 0) ||
          (lstrcmp(GT_LAST_INSPECTION,szInfFile) == 0)) {
         //
         // Analysis pane areas from jet database, not INF files
         //
         SCETYPE sceType;

         PSCE_ERROR_LOG_INFO perr = NULL;

         if (lstrcmp(GT_COMPUTER_TEMPLATE,szInfFile) == 0) {
            sceType = SCE_ENGINE_SMP;
         } else {
            sceType = SCE_ENGINE_SAP;
            pTemplateInfo->SetNoSave(TRUE);
         }
         pTemplateInfo->SetFriendlyName( SadName );
         pTemplateInfo->SetProfileHandle(SadHandle);
         pTemplateInfo->SetComponentDataImpl(this);
         rc = SceGetSecurityProfileInfo(SadHandle,                   // hProfile
                                        sceType,                     // Profile type
                                        aiArea,                      // Area
                                        &(pTemplateInfo->pTemplate), // SCE_PROFILE_INFO [out]
                                        &perr);                       // Error List [out]
         if (SCESTATUS_SUCCESS != rc) {
            if (bNewTemplate) {
               delete pTemplateInfo;
            }

            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            pTemplateInfo = NULL;
            goto done;
         }

      } else if ((lstrcmp(GT_LOCAL_POLICY,szInfFile) == 0) ||
          (lstrcmp(GT_EFFECTIVE_POLICY,szInfFile) == 0)) {
         //
         // Local Policy pane areas from jet database, not INF files
         //
         SCETYPE sceType;

         PSCE_ERROR_LOG_INFO perr = NULL;
         PVOID tempSad;

         tempSad = SadHandle;

         if (lstrcmp(GT_LOCAL_POLICY,szInfFile) == 0) {
            sceType = SCE_ENGINE_SYSTEM;
         } else {
            sceType = SCE_ENGINE_GPO;
         }
         pTemplateInfo->SetNoSave(TRUE);
         pTemplateInfo->SetProfileHandle(tempSad);
         pTemplateInfo->SetComponentDataImpl(this);
         rc = SceGetSecurityProfileInfo(tempSad,                   // hProfile
                                        sceType,                     // Profile type
                                        aiArea,                      // Area
                                        &(pTemplateInfo->pTemplate), // SCE_PROFILE_INFO [out]
                                        &perr);                       // Error List [out]

         if (SCESTATUS_SUCCESS != rc) {
            //
            // We don't really need the policy template, though it'd be nice
            // We'll be read-only as a non-admin anyway so they can't edit
            //
            // Likewise in a standalone machine the GPO won't be found so we
            // can just ignore that error as expected
            //

            if (sceType == SCE_ENGINE_GPO) {
               if (SCESTATUS_PROFILE_NOT_FOUND == rc) {
                  //
                  // No GPO, so we're on a standalone.  No need to give warnings
                  //
                  pTemplateInfo->SetTemplateDefaults();
                  rc = SCESTATUS_SUCCESS;
               } else if ((SCESTATUS_ACCESS_DENIED == rc) && pTemplateInfo->pTemplate) {
                  //
                  // We were denied in some sections, but not all.  Play on!
                  //
                  rc = SCESTATUS_SUCCESS;
               } else {
                  CString strMessage;
                  CString strFormat;
                  LPTSTR     lpMsgBuf=NULL;
                  //
                  // Real error of some sort.  Display a messagebox
                  //

                  //
                  // translate SCESTATUS into DWORD
                  //
                  DWORD win32 = SceStatusToDosError(rc);

                  //
                  // get error description of rc
                  //
                  FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 win32,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                 (LPTSTR)(PVOID)&lpMsgBuf,
                                 0,
                                 NULL
                               );
                  if ( lpMsgBuf != NULL ) {
                     if (IsAdmin()) {
                        strFormat.LoadString(IDS_ADMIN_NO_GPO);
                     } else {
                        strFormat.LoadString(IDS_NON_ADMIN_NO_GPO);
                     }
                     strMessage.Format(strFormat,lpMsgBuf);
                     LocalFree(lpMsgBuf);
                     lpMsgBuf = NULL;
                     AfxMessageBox(strMessage,MB_ICONEXCLAMATION|MB_OK);
                  }
                  //
                  // Ok.  We've notified them of the error, but don't otherwise care
                  // so pretend we got a valid but empty buffer
                  //
                  pTemplateInfo->SetTemplateDefaults();
                  rc = SCESTATUS_SUCCESS;
               }
            }
         }


      } else if (lstrcmp(GT_LOCAL_POLICY_DELTA,szInfFile) == 0) {
         //
         // Local Policy Changes.  Initialize everything to not changed
         //
         SCE_PROFILE_INFO *ppi;
         CString strLocalPol;

         strLocalPol.LoadString(IDS_LOCAL_POLICY_FRIENDLY_NAME);
         pTemplateInfo->SetFriendlyName( strLocalPol );
         pTemplateInfo->SetWriteThrough(TRUE);
         pTemplateInfo->SetProfileHandle(SadHandle);
         pTemplateInfo->SetComponentDataImpl(this);
         if (NULL == pTemplateInfo->pTemplate) {
            pTemplateInfo->pTemplate = (SCE_PROFILE_INFO*)LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
         }

         ppi = pTemplateInfo->pTemplate;
         if (NULL == ppi) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            return NULL;
         }
         ppi->Type = SCE_ENGINE_SCP;

         VerifyKerberosInfo( ppi );
         if (aiArea & AREA_SECURITY_POLICY) {
            pTemplateInfo->SetTemplateDefaults();
         }
         //
         // Further processing depends on rc == SCESTATUS_SUCCESS,
         // even though we didn't actually call the engine here
         //
         rc = SCESTATUS_SUCCESS;

      } else if (lstrcmp(GT_DEFAULT_TEMPLATE,szInfFile) == 0 ||
                 lstrcmp(GT_RSOP_TEMPLATE,szInfFile) == 0) {
         pTemplateInfo->SetComponentDataImpl(this);
         if (pTemplateInfo->RefreshTemplate(AREA_ALL)) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
            }
            return NULL;
         }
         rc = SCESTATUS_SUCCESS;
      } else {
         if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
            if (pErr) {
               *pErr = IDS_ERROR_CANT_OPEN_PROFILE;
            }
            if (bNewTemplate) {
               delete pTemplateInfo;
            }
            pTemplateInfo = NULL;
            goto done;
         }
         ASSERT(pHandle);

         if ((GetModeBits() & MB_GROUP_POLICY) == MB_GROUP_POLICY) {
            pTemplateInfo->SetPolicy(TRUE);
         }
         //
         // get information from this template
         //
         PSCE_ERROR_LOG_INFO errBuff;

         rc = SceGetSecurityProfileInfo(pHandle,
                                        SCE_ENGINE_SCP,
                                        aiArea,
                                        &(pTemplateInfo->pTemplate),
                                        &errBuff //NULL  // &ErrBuf do not care errors
                                       );

         SceCloseProfile(&pHandle);
         pHandle = NULL;
      }
      /*
            if do not care errors, no need to use this buffer

            if ( ErrBuf ) {
               SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
               ErrBuf = NULL;
            }
      */
      if (rc != SCESTATUS_SUCCESS) {
         if (pErr) {
            *pErr = IDS_ERROR_CANT_GET_PROFILE_INFO;
         }
         //
         // if we allocated pTemplateInfo then delete it.
         //
         if (bNewTemplate) {
            delete pTemplateInfo;
         }
         pTemplateInfo = NULL;
         goto done;

      }

      //
      // Set the area in the template
      //
      pTemplateInfo->AddArea(aiArea);

      //
      // add this template to the list
      //
      m_Templates.SetAt(szKey, pTemplateInfo);

      if ( aiArea & AREA_SECURITY_POLICY &&
           pTemplateInfo->pTemplate ) {
         //
         // expand registry value section based on registry values list on local machine
         //

         SceRegEnumAllValues(
                            &(pTemplateInfo->pTemplate->RegValueCount),
                            &(pTemplateInfo->pTemplate->aRegValues)
                            );
      }

   }


done:
   if(szKey){
       delete [] szKey;
   }
   return pTemplateInfo;
}

//+--------------------------------------------------------------------------
//
//  Method:     GetTemplate
//
//  Synopsis:   Get the CEditTemplate for the given INF file from the cache
//              maintained in m_pComponentData
//
//  Arguments:  [szInfFile] - The path and name of the INF file to retrieve
//              [aiArea]    - The SCE area that we're interested for the template
//             *[pErr]      - [out] a PDWORD to get error information
//
//  Returns:    A pointer to the CEditTemplate requested, or NULL if it's not
//              available.
//              *[pErr]  - the resource id of an error string, if an error occurs
//
//
//  History:
//
//---------------------------------------------------------------------------
PEDITTEMPLATE
CSnapin::GetTemplate(LPCTSTR szInfFile,AREA_INFORMATION aiArea,DWORD *pErr) {
   return ((CComponentDataImpl *)m_pComponentData)->GetTemplate(szInfFile,aiArea,pErr);
}

HRESULT
CComponentDataImpl::ReloadLocation(CFolder * pFolder)
{
   PEDITTEMPLATE pTemplate;
   POSITION pos;
   CString strKey;
   HSCOPEITEM pItemChild=NULL;
   MMC_COOKIE lCookie=NULL;
   CFolder    *pChild;
   CString strName,strNotSaved;
   LPTSTR szDesc = 0,szLoc = 0;
   DWORD nLoc = 0;

   HRESULT hr = S_OK;

   if (!m_pScope) 
      return E_FAIL;
   
   // Clear out this node
   DeleteChildrenUnderNode(pFolder);
   // Call EnumerateScopePane to reload it
   // Do we need to worry about saving changed templates?
   //  No: since they're saved by name when the template is opened up it'll pick up the
   //      proper changed template
   //  Yes: what about changed templates where the file no longer exists (or never has,
   //       for new templates?)  These will still show up in the save templates dialog,
   //       but won't be accessable for editing until then.
   //     Maybe loop through the changed templates and if they fall under this location
   //     and don't otherwise have a save file then add a folder for them?

   //
   // Set the folder not to be enumerated
   //
   pFolder->Set(FALSE);

   EnumerateScopePane((MMC_COOKIE)pFolder,pFolder->GetScopeItem()->ID);

   bool bFoundFolder;

   szLoc = pFolder->GetName();
   nLoc = lstrlen(szLoc);
   pos = m_Templates.GetStartPosition();
   while (pos) {
      m_Templates.GetNextAssoc(pos,strKey,pTemplate);

      //
      // If the template hasn't been changed then we don't care about it
      //
      if ( !pTemplate->IsDirty()
                 ) {
         continue;
      }

      //
      // We only care about templates in the location we are reloading
      //
      if (_wcsnicmp(strKey,szLoc,nLoc)) {
         bFoundFolder = false;
         hr = m_pScope->GetChildItem(pFolder->GetScopeItem()->ID, &pItemChild, &lCookie);
         //
         // find a child item
         //
         while ( SUCCEEDED(hr) ) {
            pChild = (CFolder*)lCookie;
            if ( pChild ) {
               if ( _wcsicmp(pChild->GetInfFile(), strKey) == 0 ) {
                  //
                  // The template has a folder here already, so we don't need to do anything
                  //
                  bFoundFolder = true;
                  break;
               }
            }
            hr = m_pScope->GetNextItem(pItemChild, &pItemChild, &lCookie);
         }
         if (!bFoundFolder) {
            //
            // We didn't find a folder for the template, so add one
            //

            //
            // The folder's name is its file part, less ".inf"
            //
            strName = strKey.Right(strName.GetLength() - nLoc);
            strName = strName.Left(strName.GetLength() - 4);
            // Since there's no file for this guy, mark it as not saved
            if (strNotSaved.LoadString(IDS_NOT_SAVED_SUFFIX)) {
               strName += strNotSaved;
            }
            if (! GetProfileDescription((LPCTSTR)strKey, &szDesc) ) {
               szDesc = NULL;
            }
            CreateAndAddOneNode(pFolder, (LPCTSTR)strName, szDesc, PROFILE, TRUE,strKey);
            if (szDesc) {
               LocalFree(szDesc);
               szDesc = NULL;
            }
         }
      }
   }

   return S_OK;
}

DWORD
CSnapin::GetResultItemIDs(
   CResult *pResult,
   HRESULTITEM *pIDArray,
   int nIDArray
   )
{
   if(!m_pResult){
      return ERROR_NOT_READY;
   }

   if(!pResult || !pIDArray || nIDArray <= 0){
      return ERROR_INVALID_PARAMETER;
   }

   ZeroMemory( pIDArray, sizeof(RESULTDATAITEM) * nIDArray );

   if(S_OK == m_pResult->FindItemByLParam(
      (LPARAM)pResult,
      pIDArray
      ) ){
      RESULTDATAITEM rdi;
      ZeroMemory(&rdi, sizeof(RESULTDATAITEM));
      rdi.mask = RDI_PARAM | RDI_INDEX;
      rdi.lParam = (LPARAM)pResult;
      rdi.itemID = pIDArray[0];

      if( m_pResult->GetItem( &rdi ) == S_OK ){
         for(int i = 1; i < nIDArray; i++) {
            if( m_pResult->GetNextItem(&rdi) == S_OK){
               pIDArray[i] = rdi.itemID;
            } else {
               break;
            }
         }
      }
   }

   return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------------
//Method:       CSnapin::UpdateAnalysisInfo
//
//Synopsis:     This function updates only priviledge assingedto area.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CSnapin::UpdateAnalysisInfo(
    CResult *pResult,
    BOOL bDelete,
    PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
    LPCTSTR pszName
    )
{
    PEDITTEMPLATE pBaseTemplate;

    pBaseTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
    if (!pBaseTemplate) {
      return ERROR_FILE_NOT_FOUND;
    }

    DWORD dwRet;
    dwRet = pBaseTemplate->UpdatePrivilegeAssignedTo(
                bDelete,
                pInfo,
                pszName
                );

    if(dwRet == ERROR_SUCCESS){
        pBaseTemplate->SetDirty(AREA_PRIVILEGES);
        //
        // Update the result item.
        //
        LONG_PTR dwBase =(LONG_PTR)(*pInfo);
        if(!dwBase){
            dwBase = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
        }

        if(*pInfo &&
            pResult->GetSetting() &&
            pResult->GetSetting() != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)
        ){
            (*pInfo)->Value = ((PSCE_PRIVILEGE_ASSIGNMENT)pResult->GetSetting())->Value;
        }

        AddResultItem(
             NULL,                      // The name of the attribute being added
             (LONG_PTR)pResult->GetSetting(),
                                        // The last inspected setting of the attribute
             (LONG_PTR)dwBase,          // The template setting of the attribute
             ITEM_PRIVS,                // The type of of the attribute's data
             pResult->GetStatus(),      // The mismatch status of the attribute
             pResult->GetCookie(),      // The cookie for the result item pane
             FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
             NULL,                      // The units the attribute is set in
             pResult->GetID(),          // An id to let us know where to save this attribute
             pResult->GetBaseProfile(), // The template to save this attribute in
             NULL,                  // The data object for the scope note who owns the result pane
             pResult
             );
    }

    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetAnalysisInfo
//
//  Synopsis:   Set a single policy entry to a new value in the Analysis
//              template.
//
//  Arguments:  [dwItem] - the id of the item to set
//              [dwNew]  - the new setting for that item
//              [pResult]- Pointer to the result item which is being updated.
//
//  Returns:    The new mismatch status of the item:
//                 -1 if the item wasn't found
//                 SCE_STATUS_GOOD if the items now match
//                 SCE_STATUS_MISMATCH if they are now different
//
//
//  Modifies:
//
//  History:    12-12-1997   Robcap
//
//---------------------------------------------------------------------------
int
CSnapin::SetAnalysisInfo(ULONG_PTR dwItem, ULONG_PTR dwNew, CResult *pResult)
{
   CString str;
   PSCE_PROFILE_INFO pProfileInfo;
   PSCE_PROFILE_INFO pBaseInfo;
   PEDITTEMPLATE pBaseTemplate;
   PEDITTEMPLATE pProfileTemplate;
   int nRet;

   pBaseTemplate = GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);
   if (!pBaseTemplate) {
      return -1;
   }
   pBaseInfo = pBaseTemplate->pTemplate;

   pProfileTemplate = GetTemplate(GT_LAST_INSPECTION,AREA_SECURITY_POLICY);
   if (!pProfileTemplate) {
      return -1;
   }
   pProfileInfo = pProfileTemplate->pTemplate;

   // If the Last Inspect (pProfileInfo) setting was SCE_NO_VALUE, then it was a match,
   // so copy the actual value from the Template (pBaseInfo) setting
   // Then copy the new value into the Template setting
   // Compare them; if they are the same then we have a match, so the Last Inspect should
   // be set back to SCE_NO_VALUE (is this last part necessary?), otherwise it's a mismatch
#ifdef UPDATE_ITEM
#undef UPDATE_ITEM
#endif
#define UPDATE_ITEM(X) pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);\
                       if( SCE_NO_VALUE == pProfileInfo->X ){\
                          pProfileInfo->X = pBaseInfo->X;\
                       }\
                       pBaseInfo->X = PtrToUlong((PVOID)dwNew); \
                       if (SCE_NOT_ANALYZED_VALUE == pProfileInfo->X ){\
                          nRet = SCE_STATUS_NOT_ANALYZED;\
                       } else if (SCE_NO_VALUE == PtrToUlong((PVOID)dwNew)) { \
                          nRet =  SCE_STATUS_NOT_CONFIGURED; \
                       } else if (SCE_NO_VALUE == pProfileInfo->X ){\
                          pProfileInfo->X = SCE_NOT_ANALYZED_VALUE;\
                          nRet = SCE_STATUS_NOT_ANALYZED;\
                       } else if (pBaseInfo->X == pProfileInfo->X) { \
                          nRet =  SCE_STATUS_GOOD; \
                       } else { \
                          nRet = SCE_STATUS_MISMATCH;\
                       }\
                       if(pResult){\
                          pResult->SetSetting( pProfileInfo->X );\
                       }




   nRet = -1;
   switch (dwItem) {
      case IDS_MAX_PAS_AGE:
         UPDATE_ITEM(MaximumPasswordAge);
         break;
      case IDS_MIN_PAS_AGE:
         UPDATE_ITEM(MinimumPasswordAge);
         break;
      case IDS_MIN_PAS_LEN:
         UPDATE_ITEM(MinimumPasswordLength);
         break;
      case IDS_PAS_UNIQUENESS:
         UPDATE_ITEM(PasswordHistorySize);
         break;
      case IDS_PAS_COMPLEX:
         UPDATE_ITEM(PasswordComplexity);
         break;
      case IDS_REQ_LOGON:
         UPDATE_ITEM(RequireLogonToChangePassword);
         break;
      case IDS_LOCK_COUNT:
         UPDATE_ITEM(LockoutBadCount);
         break;
      case IDS_LOCK_RESET_COUNT:
         UPDATE_ITEM(ResetLockoutCount);
         break;
      case IDS_LOCK_DURATION:
         UPDATE_ITEM(LockoutDuration);
         break;
      case IDS_FORCE_LOGOFF:
         UPDATE_ITEM(ForceLogoffWhenHourExpire);
         break;
      case IDS_ENABLE_ADMIN:
         UPDATE_ITEM(EnableAdminAccount);
         break;
      case IDS_ENABLE_GUEST:
         UPDATE_ITEM(EnableGuestAccount);
         break;
      case IDS_NEW_ADMIN:
      //
      // First copy the name if the analysis info used to be a match.
      // Then copy the new name to the configuration buffer.
      // Then get the status of the item.
      //
#define UPDATE_STRING( X ) if ( (pProfileInfo->X == (LPTSTR)ULongToPtr(SCE_NO_VALUE) ||\
                              pProfileInfo->X == NULL) &&\
                              (pBaseInfo->X != (LPTSTR)ULongToPtr(SCE_NO_VALUE) &&\
                              pBaseInfo->X != NULL) ) {\
                              pProfileInfo->X = (LPTSTR)LocalAlloc(0,  sizeof(TCHAR) * (lstrlen(pBaseInfo->X) + 1));\
                              if(pProfileInfo->X){\
                                 lstrcpy(pProfileInfo->X, pBaseInfo->X);\
                              }\
                           }\
                           if (pBaseInfo->X) {\
                              LocalFree(pBaseInfo->X);\
                           }\
                           if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {\
                              pBaseInfo->X =\
                                 (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));\
                              if (pBaseInfo->X) {\
                                 lstrcpy(pBaseInfo->X,(PWSTR)dwNew);\
                              } else {\
                                 return SCE_STATUS_NOT_CONFIGURED;\
                              }\
                           } else {\
                              pBaseInfo->X = NULL;\
                              return SCE_STATUS_NOT_CONFIGURED;\
                           }\
                           if (pProfileInfo->X &&\
                              _wcsicmp(pBaseInfo->X,pProfileInfo->X) == 0 ) {\
                              return SCE_STATUS_GOOD;\
                           } else {\
                              return SCE_STATUS_MISMATCH;\
                           }

         pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);
         UPDATE_STRING( NewAdministratorName );
         break;
      case IDS_NEW_GUEST:
         pBaseTemplate->SetDirty(AREA_SECURITY_POLICY);
         UPDATE_STRING( NewGuestName );
         break;
      case IDS_SYS_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         break;
      case IDS_SYSTEM_EVENT:
         UPDATE_ITEM(AuditSystemEvents);
         break;
      case IDS_LOGON_EVENT:
         UPDATE_ITEM(AuditLogonEvents);
         break;
      case IDS_OBJECT_ACCESS:
         UPDATE_ITEM(AuditObjectAccess);
         break;
      case IDS_PRIVILEGE_USE:
         UPDATE_ITEM(AuditPrivilegeUse);
         break;
      case IDS_POLICY_CHANGE:
         UPDATE_ITEM(AuditPolicyChange);
         break;
      case IDS_ACCOUNT_MANAGE:
         UPDATE_ITEM(AuditAccountManage);
         break;
      case IDS_PROCESS_TRACK:
         UPDATE_ITEM(AuditProcessTracking);
         break;
      case IDS_DIRECTORY_ACCESS:
         UPDATE_ITEM(AuditDSAccess);
         break;
      case IDS_ACCOUNT_LOGON:
         UPDATE_ITEM(AuditAccountLogon);
         break;
      case IDS_SYS_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_APP]);
         break;
      case IDS_CLEAR_PASSWORD:
         UPDATE_ITEM(ClearTextPassword);
         break;

      case IDS_KERBEROS_MAX_SERVICE:
         UPDATE_ITEM(pKerberosInfo->MaxServiceAge);
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         UPDATE_ITEM(pKerberosInfo->MaxClockSkew);
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         UPDATE_ITEM(pKerberosInfo->TicketValidateClient);
         break;

      case IDS_KERBEROS_MAX_AGE:
         UPDATE_ITEM(pKerberosInfo->MaxTicketAge);
         break;
      case IDS_KERBEROS_RENEWAL:
         UPDATE_ITEM(pKerberosInfo->MaxRenewAge);
         break;
      default:
         break;
   }
#undef UPDATE_ITEM
#undef UPDATE_STRING
   return nRet;
}

//+----------------------------------------------------------------------------------
//Method:       CSnapin::UpdateLocalPolInfo
//
//Synopsis:     This function update the priviledge unsigned to area of local
//          Policy.
//          First the local policy is updated to the database,
//          Then the template used for display is updated.
//          Last the CResult item is updated.
//
//Arguments:    [bRemove]   - Weither to remove or add an item.
//              [ppaLink]   - The link to be removed or added.  This paramter is
//                              set to NULL if remove is successful or a pointer
//                              to a new SCE_PRIVILEGE_ASSIGNMENT item.
//              [pszName]   - Only used when adding a new item.
//
//Returns:      ERROR_INVALID_PARAMETER     - [ppaLink] is NULL or if removing
//                                              [*ppaLink] is NULL.
//                                              if adding then if [pszName] is NULL
//              ERROR_RESOURCE_NOT_FOUND    - If the link could not be found
//                                              in this template.
//              E_POINTER                   - If [pszName] is a bad pointer or
//                                              [ppaLink] is bad.
//              E_OUTOFMEMORY               - Not enough resources to complete the
//                                              operation.
//              ERROR_SUCCESS               - The opration was successful.
//----------------------------------------------------------------------------------+
DWORD
CSnapin::UpdateLocalPolInfo(
    CResult *pResult,
    BOOL bDelete,
    PSCE_PRIVILEGE_ASSIGNMENT *pInfo,
    LPCTSTR pszName
    )
{
   PEDITTEMPLATE pLocalPol;

   if (!pszName && (NULL != pInfo) && (NULL != *pInfo)){
      pszName = (*pInfo)->Name;
   }
   //
   // Update changes only for the saved local policy section
   //
   pLocalPol = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_PRIVILEGES);
   if (!pLocalPol) {
      return ERROR_FILE_NOT_FOUND;
   }

   //
   // For local policy delta section mark the node to be deleted by the
   // engine, don't actually delete it from the list.
   //

   // Create new link
   DWORD dwRet;

   if(pInfo && *pInfo){
      //
      // Save values of privilege buffer.
      //
      dwRet = (*pInfo)->Status;
      PSCE_PRIVILEGE_ASSIGNMENT pNext = (*pInfo)->Next;

      (*pInfo)->Next = NULL;
      if(bDelete){
         (*pInfo)->Status = SCE_DELETE_VALUE;
      }
      //
      // Update the engine.
      //
      pLocalPol->pTemplate->OtherInfo.smp.pPrivilegeAssignedTo = *pInfo;
      pLocalPol->SetDirty(AREA_PRIVILEGES);

      (*pInfo)->Status = dwRet;
      (*pInfo)->Next = pNext;
   } else {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Update for the displayed Local Policy section
   //
   if( pInfo && ((!bDelete && !(*pInfo)) || (bDelete && *pInfo)) ){
      pLocalPol = GetTemplate(GT_LOCAL_POLICY,AREA_PRIVILEGES);
      if (!pLocalPol) {
        return ERROR_FILE_NOT_FOUND;
      }

      //
      // Only make a call to this function if we are updating the priviledge link list.
      //
      dwRet = pLocalPol->UpdatePrivilegeAssignedTo(
               bDelete,
               pInfo,
               pszName
               );
      pLocalPol->SetDirty(AREA_PRIVILEGES);
   }


    if(dwRet == ERROR_SUCCESS){
        //
        // Update the result item.
        //
        LONG_PTR dwBase =(LONG_PTR)(*pInfo);
        if(!dwBase){
            dwBase = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
        }

        if(*pInfo &&
            pResult->GetSetting() &&
            pResult->GetSetting() != (LONG_PTR)ULongToPtr(SCE_NO_VALUE) ){
            (*pInfo)->Value = ((PSCE_PRIVILEGE_ASSIGNMENT)pResult->GetSetting())->Value;
        }

        AddResultItem(
             NULL,                      // The name of the attribute being added
             (LONG_PTR)pResult->GetSetting(),
                                        // The last inspected setting of the attribute
             (LONG_PTR)dwBase,          // The template setting of the attribute
             ITEM_LOCALPOL_PRIVS,       // The type of of the attribute's data
             pResult->GetStatus(),      // The mismatch status of the attribute
             pResult->GetCookie(),      // The cookie for the result item pane
             FALSE,                     // True if the setting is set only if it differs from base (so copy the data)
             NULL,                      // The units the attribute is set in
             pResult->GetID(),          // An id to let us know where to save this attribute
             pResult->GetBaseProfile(), // The template to save this attribute in
             NULL,                      // The data object for the scope note who owns the result pane
             pResult
             );
    }

    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetLocalPolInfo
//
//  Synopsis:   Set a single policy entry to a new value in the local policy
//              template.  Update both the displayed local policy buffer and
//              the changes-only local policy buffer
//
//  Arguments:  [dwItem] - the id of the item to set
//              [dwNew]  - the new setting for that item
//
//  Returns:    The new mismatch status of the item:
//                 SCE_STATUS_GOOD if the items now match
//                 SCE_STATUS_MISMATCH if they are now different
//                 SCE_STATUS_NOT_CONFIGURED if the item is now non-configured
//                 SCE_ERROR_VALUE if there was an error saving
//
//
//  Modifies:
//
//  History:    12-12-1997   Robcap
//
//---------------------------------------------------------------------------
int
CSnapin::SetLocalPolInfo(ULONG_PTR dwItem, ULONG_PTR dwNew)
{
   CString str;
   PSCE_PROFILE_INFO pLocalInfo;
   PSCE_PROFILE_INFO pLocalDeltaInfo;
   PSCE_PROFILE_INFO pEffectiveInfo;
   PEDITTEMPLATE pLocalTemplate;
   PEDITTEMPLATE pLocalDeltaTemplate;
   PEDITTEMPLATE pEffectiveTemplate;
   int nRet;
   ULONG_PTR dwSave;
   ULONG_PTR dwSaveDelta;

   pEffectiveTemplate = GetTemplate(GT_EFFECTIVE_POLICY,AREA_SECURITY_POLICY);
   if (!pEffectiveTemplate) {
      return SCE_ERROR_VALUE;
   }
   pEffectiveInfo = pEffectiveTemplate->pTemplate;

   pLocalTemplate = GetTemplate(GT_LOCAL_POLICY,AREA_SECURITY_POLICY);
   if (!pLocalTemplate) {
      return SCE_ERROR_VALUE;
   }
   pLocalInfo = pLocalTemplate->pTemplate;
   if (!pLocalInfo) {
      return SCE_ERROR_VALUE;
   }

   pLocalDeltaTemplate = GetTemplate(GT_LOCAL_POLICY_DELTA,AREA_SECURITY_POLICY);
   if (!pLocalDeltaTemplate) {
      return SCE_ERROR_VALUE;
   }
   if ( !pLocalDeltaTemplate->IsLockedWriteThrough() )
       pLocalDeltaTemplate->SetTemplateDefaults();

   pLocalDeltaInfo = pLocalDeltaTemplate->pTemplate;
   if (!pLocalDeltaInfo) {
      return SCE_ERROR_VALUE;
   }


   // Compare them; if they are the same then we have a match, so the Last Inspect should
   // be set back to SCE_NO_VALUE (is this last part necessary?), otherwise it's a mismatch
   //
   // If the new value is different from the old value then call SetDirty after the changes
   // have been made, otherwise we may save things before that
   // Once the dirty bit has been set (causing the delta template to be immediately saved)
   // reset the changed item back to SCE_STATUS_NOT_CONFIGURED in that template
   //
   // If the SetDirty fails then undo the changes and return SCE_ERROR_VALUE
   //
#ifdef UPDATE_ITEM
#undef UPDATE_ITEM
#endif

#define UPDATE_ITEM(X) dwSave = pLocalInfo->X; \
                       dwSaveDelta = pLocalDeltaInfo->X; \
                       pLocalInfo->X = (DWORD)PtrToUlong((PVOID)dwNew); \
                       pLocalDeltaInfo->X = (DWORD)PtrToUlong((PVOID)dwNew); \
                       if (SCE_NO_VALUE == (DWORD)PtrToUlong((PVOID)dwNew)) { \
                          pLocalDeltaInfo->X = SCE_DELETE_VALUE; \
                          nRet = SCE_STATUS_NOT_CONFIGURED; \
                       } else if (pEffectiveInfo->X == pLocalInfo->X) { \
                          nRet = SCE_STATUS_GOOD; \
                       } else { \
                          nRet = SCE_STATUS_MISMATCH; \
                       } \
                       if (dwSave != (DWORD)PtrToUlong((PVOID)dwNew) && \
                           !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY)) { \
                          pLocalInfo->X = (DWORD)PtrToUlong((PVOID)dwSave); \
                          nRet = SCE_ERROR_VALUE; \
                       } \
                       if ( !pLocalDeltaTemplate->IsLockedWriteThrough() ) \
                           pLocalDeltaInfo->X = SCE_NO_VALUE;
// In order to batch dependent settings together (for write through mode), the delta info
// buffer should not be reset to "no value" since it may not be set in the SetDirty call
   CString oldstrName; //Yanggao 1/31/2001 Bug211219. For keeping original name.

   nRet = SCE_ERROR_VALUE;
   switch (dwItem) {
   case IDS_MAX_PAS_AGE:
         UPDATE_ITEM(MaximumPasswordAge);
         break;
      case IDS_MIN_PAS_AGE:
         UPDATE_ITEM(MinimumPasswordAge);
         break;
      case IDS_MIN_PAS_LEN:
         UPDATE_ITEM(MinimumPasswordLength);
         break;
      case IDS_PAS_UNIQUENESS:
         UPDATE_ITEM(PasswordHistorySize);
         break;
      case IDS_PAS_COMPLEX:
         UPDATE_ITEM(PasswordComplexity);
         break;
      case IDS_REQ_LOGON:
         UPDATE_ITEM(RequireLogonToChangePassword);
         break;
      case IDS_LOCK_COUNT:
         UPDATE_ITEM(LockoutBadCount);
         break;
      case IDS_LOCK_RESET_COUNT:
         UPDATE_ITEM(ResetLockoutCount);
         break;
      case IDS_LOCK_DURATION:
         UPDATE_ITEM(LockoutDuration);
         break;
      case IDS_FORCE_LOGOFF:
         UPDATE_ITEM(ForceLogoffWhenHourExpire);
         break;
      case IDS_ENABLE_ADMIN:
         UPDATE_ITEM(EnableAdminAccount);
         break;
      case IDS_ENABLE_GUEST:
         UPDATE_ITEM(EnableGuestAccount);
         break;
      case IDS_NEW_ADMIN:
         pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
         if (pLocalInfo->NewAdministratorName)
         {
            // Yanggao 1/31/2001. Bug211219.
            oldstrName = (LPCTSTR)(pLocalInfo->NewAdministratorName);
			LocalFree(pLocalInfo->NewAdministratorName);
            pLocalInfo->NewAdministratorName = NULL;
         }
         pLocalDeltaInfo->NewAdministratorName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);

         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
         {
            pLocalInfo->NewAdministratorName =
               (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));
            if (pLocalInfo->NewAdministratorName)
            {
               lstrcpy(pLocalInfo->NewAdministratorName,(PWSTR)dwNew);
               pLocalDeltaInfo->NewAdministratorName = pLocalInfo->NewAdministratorName;
            }
         }

         if( !pLocalInfo->NewAdministratorName )
         {
            nRet = SCE_STATUS_NOT_CONFIGURED;
         }
         else
         {
            if (pEffectiveInfo->NewAdministratorName &&
             _wcsicmp(pLocalInfo->NewAdministratorName,
                      pEffectiveInfo->NewAdministratorName) == 0 ) 
            {
                nRet = SCE_STATUS_GOOD;
            }
            else
            {
                nRet = SCE_STATUS_MISMATCH;
            }
         }
		 
         //Yanggao 1/31/2001 Bug211219. Recover original name if save failed.
         if( !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) &&
              SCE_STATUS_MISMATCH == nRet )
         {
             pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
             if (pLocalInfo->NewAdministratorName)
             {
                LocalFree(pLocalInfo->NewAdministratorName);
                pLocalInfo->NewAdministratorName = NULL;
             }
             pLocalDeltaInfo->NewAdministratorName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);
             LONG_PTR dwOld = (LONG_PTR)(LPCTSTR)oldstrName;
             if (dwOld && (dwOld != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
             {
                pLocalInfo->NewAdministratorName =
                   (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwOld)+1));
                if (pLocalInfo->NewAdministratorName)
                {
                   lstrcpy(pLocalInfo->NewAdministratorName,(PWSTR)dwOld);
                   pLocalDeltaInfo->NewAdministratorName = pLocalInfo->NewAdministratorName;
                }
             } 
             pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY);
         }
          
         break;
      case IDS_NEW_GUEST:
         pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
         if (pLocalInfo->NewGuestName)
         {
            //Yanggao 3/15/2001 Bug211219. Recover original name if save failed.
            oldstrName = (LPCTSTR)(pLocalInfo->NewGuestName);
			LocalFree(pLocalInfo->NewGuestName);
            pLocalInfo->NewGuestName = NULL;
         }
         pLocalDeltaInfo->NewGuestName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);

         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
         {
            pLocalInfo->NewGuestName =
               (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwNew)+1));
            if (pLocalInfo->NewGuestName)
            {
               lstrcpy(pLocalInfo->NewGuestName,(PWSTR)dwNew);
               pLocalDeltaInfo->NewGuestName = pLocalInfo->NewGuestName;
            }
         } 

         if( !pLocalInfo->NewGuestName )
         {
            nRet = SCE_STATUS_NOT_CONFIGURED;
         }
         else
         {
            if (pEffectiveInfo->NewGuestName &&
             _wcsicmp(pLocalInfo->NewGuestName,pEffectiveInfo->NewGuestName) == 0 )
            {
               nRet = SCE_STATUS_GOOD;
            }
            else
            {
               nRet = SCE_STATUS_MISMATCH;
            }
         }

         //Yanggao 3/15/2001 Bug211219. Recover original name if save failed.
         if( !pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY) &&
              SCE_STATUS_MISMATCH == nRet )
         {
             pLocalTemplate->SetDirty(AREA_SECURITY_POLICY);
             if (pLocalInfo->NewGuestName)
             {
                LocalFree(pLocalInfo->NewGuestName);
                pLocalInfo->NewGuestName = NULL;
             }
             pLocalDeltaInfo->NewGuestName = (LPTSTR)IntToPtr(SCE_DELETE_VALUE);
             LONG_PTR dwOld = (LONG_PTR)(LPCTSTR)oldstrName;
             if (dwOld && (dwOld != (LONG_PTR)ULongToPtr(SCE_NO_VALUE)))
             {
                pLocalInfo->NewGuestName =
                   (PWSTR)LocalAlloc(LPTR,sizeof(TCHAR)*(lstrlen((PWSTR)dwOld)+1));
                if (pLocalInfo->NewGuestName)
                {
                   lstrcpy(pLocalInfo->NewGuestName,(PWSTR)dwOld);
                   pLocalDeltaInfo->NewGuestName = pLocalInfo->NewGuestName;
                }
             } 
             pLocalDeltaTemplate->SetDirty(AREA_SECURITY_POLICY);
         }

         break;
      case IDS_SYS_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SYS_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         }
         break;
      case IDS_SYS_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SYSTEM]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_SECURITY]);
         break;
      case IDS_SEC_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         }
         break;
      case IDS_SEC_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_SECURITY]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_MAX:
         UPDATE_ITEM(MaximumLogSize[EVENT_TYPE_APP]);
         break;
      case IDS_APP_LOG_RET:
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         if (SCE_RETAIN_BY_DAYS != dwNew) {
            dwNew = SCE_NO_VALUE;
            UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         }
         break;
      case IDS_APP_LOG_DAYS:
         UPDATE_ITEM(RetentionDays[EVENT_TYPE_APP]);
         dwNew = SCE_RETAIN_BY_DAYS;
         UPDATE_ITEM(AuditLogRetentionPeriod[EVENT_TYPE_APP]);
         break;
      case IDS_SYSTEM_EVENT:
         UPDATE_ITEM(AuditSystemEvents);
         break;
      case IDS_LOGON_EVENT:
         UPDATE_ITEM(AuditLogonEvents);
         break;
      case IDS_OBJECT_ACCESS:
         UPDATE_ITEM(AuditObjectAccess);
         break;
      case IDS_PRIVILEGE_USE:
         UPDATE_ITEM(AuditPrivilegeUse);
         break;
      case IDS_POLICY_CHANGE:
         UPDATE_ITEM(AuditPolicyChange);
         break;
      case IDS_ACCOUNT_MANAGE:
         UPDATE_ITEM(AuditAccountManage);
         break;
      case IDS_PROCESS_TRACK:
         UPDATE_ITEM(AuditProcessTracking);
         break;
      case IDS_DIRECTORY_ACCESS:
         UPDATE_ITEM(AuditDSAccess);
         break;
      case IDS_ACCOUNT_LOGON:
         UPDATE_ITEM(AuditAccountLogon);
         break;
      case IDS_SYS_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SYSTEM]);
         break;
      case IDS_SEC_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_SECURITY]);
         break;
      case IDS_APP_LOG_GUEST:
         UPDATE_ITEM(RestrictGuestAccess[EVENT_TYPE_APP]);
         break;
      case IDS_CLEAR_PASSWORD:
         UPDATE_ITEM(ClearTextPassword);
         break;
      case IDS_KERBEROS_MAX_AGE:
#define CHECK_KERBEROS if( !pLocalInfo->pKerberosInfo ||\
                           !pLocalDeltaInfo->pKerberosInfo ||\
                           !pEffectiveInfo->pKerberosInfo ){\
                              break;\
                       }



         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxTicketAge);
         break;
      case IDS_KERBEROS_RENEWAL:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxRenewAge);
         break;
      case IDS_KERBEROS_MAX_SERVICE:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxServiceAge);
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->MaxClockSkew);
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         CHECK_KERBEROS
         UPDATE_ITEM(pKerberosInfo->TicketValidateClient);
         break;
      case IDS_LSA_ANON_LOOKUP: //Raid #324250, 4/5/2001
         UPDATE_ITEM(LSAAnonymousNameLookup);
         break;
#undef CHECK_KERBEROS
      default:
         break;
   }

   return nRet;
}


//+------------------------------------------------------------------------------
// GetImageOffset
//
// Returns the offset in the image index depending on the status of the item.
//
// Returns
//    Image offset, there is no error.
//-------------------------------------------------------------------------------
int
GetImageOffset(
   DWORD status
   )
{
   int nImage = 0;
   switch (status) {
      case SCE_STATUS_GOOD:
         nImage = IMOFFSET_GOOD;
         break;
      case SCE_STATUS_MISMATCH:
         nImage = IMOFFSET_MISMATCH;
         break;
      case SCE_STATUS_NOT_ANALYZED:
         nImage = IMOFFSET_NOT_ANALYZED;
         break;
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
         nImage = IMOFFSET_ERROR;
         break;
   }

   return nImage;
}

int
GetScopeImageIndex(
                  FOLDER_TYPES type,
                  DWORD status
                  )
/*
Get the right image icon for scope items based on the folder type
*/
{
   int nImage;

   switch ( type ) {
      case ROOT:
      case STATIC:
         nImage = SCE_IMAGE_IDX;
         break;
      case ANALYSIS:
         nImage = LAST_IC_IMAGE_IDX;
         break;
      case PROFILE:
         nImage = TEMPLATES_IDX;
         break;
      case CONFIGURATION:
      case LOCATIONS:
         nImage = CONFIG_FOLDER_IDX;
         break;
      case POLICY_ACCOUNT:
      case POLICY_PASSWORD:
      case POLICY_KERBEROS:
      case POLICY_LOCKOUT:
         nImage = CONFIG_ACCOUNT_IDX;
         break;
      case POLICY_ACCOUNT_ANALYSIS:
      case POLICY_PASSWORD_ANALYSIS:
      case POLICY_KERBEROS_ANALYSIS:
      case POLICY_LOCKOUT_ANALYSIS:
         nImage = CONFIG_ACCOUNT_IDX;
         break;
      case POLICY_LOCAL:
      case POLICY_EVENTLOG:
      case POLICY_AUDIT:
      case POLICY_OTHER:
      case POLICY_LOG:
      case AREA_PRIVILEGE:
         nImage = CONFIG_LOCAL_IDX;
         break;
      case POLICY_LOCAL_ANALYSIS:
      case POLICY_EVENTLOG_ANALYSIS:
      case POLICY_AUDIT_ANALYSIS:
      case POLICY_OTHER_ANALYSIS:
      case POLICY_LOG_ANALYSIS:
      case AREA_PRIVILEGE_ANALYSIS:
         nImage = CONFIG_LOCAL_IDX;
         break;
      case REG_OBJECTS:
         nImage = CONFIG_REG_IDX + GetImageOffset( status & 0xF );

         break;
      case FILE_OBJECTS:
         nImage = FOLDER_IMAGE_IDX + GetImageOffset( status & 0xF );

         break;
      default:
         nImage = CONFIG_FOLDER_IDX;
         break;
   }

   return nImage;
}

int
GetResultImageIndex(
                   CFolder* pFolder,
                   CResult* pResult
                   )
/*
Get the image icon for the result item, based on where the
result item belongs to (which folder), the type of the result item,
and the status of the result item
*/
{
   RESULT_TYPES rsltType;

   int nImage;
   BOOL bCheck = TRUE;

   if (!pFolder || !pResult ) {
      // don't know which scope it belongs to ?
      // should not occur
      nImage = BLANK_IMAGE_IDX;

   } else {
      rsltType = pResult->GetType();
      PSCE_GROUP_MEMBERSHIP pGroup;

      int ista;
      if ( pResult->GetStatus() == -1 ) {
         ista = -1;
      } else {
         ista = pResult->GetStatus() & 0x0F;
      }

      //
      // Get base image index.
      //
      switch ( pFolder->GetType() ) {
         case POLICY_KERBEROS:
         case POLICY_PASSWORD:
         case POLICY_LOCKOUT:
         case POLICY_PASSWORD_ANALYSIS:
         case POLICY_KERBEROS_ANALYSIS:
         case POLICY_LOCKOUT_ANALYSIS:
         case LOCALPOL_KERBEROS:
         case LOCALPOL_PASSWORD:
         case LOCALPOL_LOCKOUT:
            nImage = CONFIG_POLICY_IDX;
            break;
         case POLICY_AUDIT:
         case POLICY_LOG:
         case POLICY_OTHER:
         case AREA_PRIVILEGE:
         case POLICY_AUDIT_ANALYSIS:
         case POLICY_LOG_ANALYSIS:
         case POLICY_OTHER_ANALYSIS:
         case AREA_PRIVILEGE_ANALYSIS:
         case LOCALPOL_AUDIT:
         case LOCALPOL_LOG:
         case LOCALPOL_OTHER:
         case LOCALPOL_PRIVILEGE:
            nImage = CONFIG_POLICY_IDX;
            break;
         case AREA_GROUPS:
            nImage = CONFIG_GROUP_IDX;
            break;
         case AREA_SERVICE:
         case AREA_SERVICE_ANALYSIS:
            nImage = CONFIG_SERVICE_IDX;
            break;
         case AREA_FILESTORE:
         case AREA_FILESTORE_ANALYSIS:
            // container or file ???
            nImage = FOLDER_IMAGE_IDX;
            break;
         case AREA_REGISTRY:
         case AREA_REGISTRY_ANALYSIS:
            nImage = CONFIG_REG_IDX;
            break;
         case REG_OBJECTS:
            nImage = CONFIG_REG_IDX;
            break;
         case FILE_OBJECTS:
            nImage = CONFIG_FILE_IDX;
            break;
         case AREA_GROUPS_ANALYSIS:
            if ( rsltType == ITEM_GROUP ) {
               nImage = CONFIG_GROUP_IDX;
            } else {
               //
               // the members or memberof record
               //
               bCheck = FALSE;
               if ( SCE_STATUS_GOOD == ista ) {
                  nImage = SCE_OK_IDX;
               } else if ( SCE_STATUS_MISMATCH == ista ) {
                  nImage = SCE_CRITICAL_IDX;
               } else {
                  nImage = BLANK_IMAGE_IDX;
               }

            }
            break;
         default:
            bCheck = FALSE;
            nImage = BLANK_IMAGE_IDX;
            break;
      }

      //
      // Find the status icon.  The image map garentees the order of these images.
      // We don't need to check the status if we are in MB_TEMPLATE_EDITOR.
      //
      if( bCheck ){

         if( pFolder->GetModeBits() & (MB_ANALYSIS_VIEWER) ){
            nImage += GetImageOffset( ista );
         } else if( SCE_STATUS_ERROR_NOT_AVAILABLE == ista ){
            nImage = SCE_CRITICAL_IDX;
         }
      }

      if ((pFolder->GetModeBits() & MB_LOCALSEC) == MB_LOCALSEC) {
          if (pResult->GetType() == ITEM_LOCALPOL_REGVALUE) {
             SCE_REGISTRY_VALUE_INFO *pRegValue;
             pRegValue = (PSCE_REGISTRY_VALUE_INFO)pResult->GetSetting();
             if (!pRegValue || pRegValue->Status != SCE_STATUS_NOT_CONFIGURED) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if (pResult->GetType() == ITEM_LOCALPOL_SZ) {
             if (pResult->GetSetting()) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if (pResult->GetType() == ITEM_LOCALPOL_PRIVS) {
             //
             // If there is a setting it's a pointer; if not, it is NULL
             //
             if (pResult->GetSetting()) {
                nImage = LOCALSEC_POLICY_IDX;
             }
          } else if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != pResult->GetSetting()) {
             nImage = LOCALSEC_POLICY_IDX;
          }
      }

   }

   if ( nImage < 0 ) {
      nImage = BLANK_IMAGE_IDX;
   }
   return nImage;
}

//+--------------------------------------------------------------------------
//
//  Method:    GetPopupDialog
//
//  Synopsis:  Retrieve a popup dialog from the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//
//  Returns:   The dialog if it exists, NULL otherwise
//
//  History:
//
//---------------------------------------------------------------------------
CDialog *
CComponentDataImpl::GetPopupDialog(LONG_PTR nID) {
   CDialog *pDlg = NULL;
   if (m_scopeItemPopups.Lookup(nID,pDlg)) {
      return pDlg;
   } else {
      return NULL;
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    AddPopupDialog
//
//  Synopsis:  Set a popup dialog into the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//             [pDlg]    - The dialog
//
//  History:
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::AddPopupDialog(LONG_PTR nID,CDialog *pDlg) {
   if (pDlg) {
      m_scopeItemPopups.SetAt(nID,pDlg);
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    RemovePopupDialog
//
//  Synopsis:  Removes a popup dialog from the cache
//
//  Arguments: [nID]      - An identifier for the dialog
//
//  History:
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::RemovePopupDialog(LONG_PTR nID) {
   CDialog *pDlg = NULL;
   if (m_scopeItemPopups.Lookup(nID,pDlg)) {
      m_scopeItemPopups.RemoveKey(nID);
   }
}


//+--------------------------------------------------------------------------
//
//  Method:    EngineTransactionStarted
//
//  Synopsis:  Start transaction in the jet engine if one is not started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineTransactionStarted()
{
   if ( !SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      if ( SCESTATUS_SUCCESS == SceStartTransaction(SadHandle) ) {

         SadTransStarted = TRUE;
      }
   }

   return SadTransStarted;
}

//+--------------------------------------------------------------------------
//
//  Method:    EngineCommitTransaction
//
//  Synopsis:  Commit transaction in the jet engine if one is started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineCommitTransaction()
{

   if ( SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      if ( SCESTATUS_SUCCESS == SceCommitTransaction(SadHandle) ) {

         SadTransStarted = FALSE;
         return TRUE;
      }
   }

   return FALSE;
}
//+--------------------------------------------------------------------------
//
//  Method:    GetLinkedTopics
//
//  Synopsis:  Return full path of help file.
//
//  History:   Raid #258658, 4/10/2001
//
//---------------------------------------------------------------------------
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR *lpCompiledHelpFiles)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    if ( lpCompiledHelpFiles )
    {
        CString strLinkedTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strLinkedTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strLinkedTopic.ReleaseBuffer();
        if ( nLen )
        {
            CString strFile;

            if( SCE_MODE_LOCAL_COMPUTER == m_GroupMode || SCE_MODE_LOCAL_USER == m_GroupMode )
            {
                strFile.LoadString(IDS_HTMLHELP_LPPOLICY_TOPIC);
                strFile.Replace(L':', L'\0'); 
            }
            else
            {
                strFile.LoadString(IDS_HTMLHELP_POLICY_TOPIC); 
                strFile.Replace(L':', L'\0');
            }

            strLinkedTopic = strLinkedTopic + strFile;
            *lpCompiledHelpFiles = reinterpret_cast<LPOLESTR>
                    (CoTaskMemAlloc((strLinkedTopic.GetLength() + 1)* sizeof(wchar_t)));

            if ( *lpCompiledHelpFiles )
            {
                wcscpy(*lpCompiledHelpFiles, (PWSTR)(PCWSTR)strLinkedTopic);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }
    else
        return E_POINTER;


    return hr;
}
//+--------------------------------------------------------------------------
//
//  Method:    EngineRollbackTransaction
//
//  Synopsis:  Rollback transaction in the jet engine if one is started
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CComponentDataImpl::EngineRollbackTransaction()
{

   if ( SadTransStarted && SadHandle ) {
      //
      // start the transaction
      //
      SceRollbackTransaction(SadHandle);
      SadTransStarted = FALSE;

      return TRUE;
   }

   return FALSE;
}


CDialog *
CComponentDataImpl::MatchNextPopupDialog(
    POSITION &pos,
    LONG_PTR priKey,
    LONG_PTR *fullPos
    )
{
    if(pos == NULL){
        pos = m_scopeItemPopups.GetStartPosition();
    }

    LONG_PTR key;
    CDialog *pDlg = NULL;

    while(pos){
        m_scopeItemPopups.GetNextAssoc(pos, key, pDlg);

        if( DLG_KEY_PRIMARY(priKey) == DLG_KEY_PRIMARY(key) ){
            if(fullPos){
                *fullPos = key;
            }
            return pDlg;
        }
        pDlg = NULL;
    }

    return pDlg;
}

//+--------------------------------------------------------------------------
//
//  Method:    CheckEngineTransaction
//
//  Synopsis:  From CSnapin to check/start transaction in the jet engine
//
//  Arguments: None
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
CSnapin::CheckEngineTransaction()
{
   return ((CComponentDataImpl*)m_pComponentData)->EngineTransactionStarted();
}



//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//             szFile - [in] the file name of the help file for this snapin
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile, LPCTSTR szFile)
{
   CString sPath;
   LPTSTR szPath;

   if (lpCompiledHelpFile == NULL) {
      return E_POINTER;
   }

   szPath = sPath.GetBuffer(MAX_PATH);
   if (!szPath) {
      return E_OUTOFMEMORY;
   }
   if (!GetWindowsDirectory(szPath,MAX_PATH)) {
      return E_FAIL;
   }
   sPath.ReleaseBuffer();
   sPath += szFile;

   *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>
                         (CoTaskMemAlloc((sPath.GetLength() + 1)* sizeof(wchar_t)));

   if (*lpCompiledHelpFile == NULL) {
      return E_OUTOFMEMORY;
   }
   USES_CONVERSION;

   wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)sPath));

   return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Method:    CComponentDataImpl::SetErroredLogFile
//
//  Synopsis:  Sets the log file created by the engine.  We can then display
//             this log file later on, if there was an error performing the
//             analysis or configuration.
//
//  Arguments: [pszFileName]     - The file name to set.  This can be NULL.
//             [dwPosLow]        - The starting pos of the file. only supports files less then a
//                                  gigabyte.
//
//
//---------------------------------------------------------------------------
void
CComponentDataImpl::SetErroredLogFile( LPCTSTR pszFileName, LONG dwPosLow)
{
   if(m_pszErroredLogFile){
      LocalFree( m_pszErroredLogFile );
   }

   m_ErroredLogPos = dwPosLow;
   m_pszErroredLogFile = NULL;
   if(pszFileName ){
      DWORD dwRet = 0;

      __try {
         dwRet = lstrlen(pszFileName);
      } __except( EXCEPTION_CONTINUE_EXECUTION ){
         return;
      }

      m_pszErroredLogFile = (LPTSTR)LocalAlloc(0, sizeof(TCHAR) * (dwRet + 1) );
      if( !m_pszErroredLogFile ){
         return;
      }

      lstrcpy( m_pszErroredLogFile, pszFileName );
   }
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataSCEImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_SCE);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataSAVImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_SAV);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}
//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataLSImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_LS);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}

//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataRSOPImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   sFile.LoadString(IDS_HELPFILE_RSOP);
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}


//+--------------------------------------------------------------------------
//
//  Method:    GetHelpTopic
//
//  Synopsis:  Return the path to the help file for this snapin
//
//  Arguments: *lpCompiledHelpFile - [out] pointer to fill with the path to the help file
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
CComponentDataExtensionImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile) {
   CString sFile;

   //
   // Needed for Loadstring
   //
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //Raid #258658, 4/10/2001. If currently security setting node is not expanded, we
   //won't give them any helptopic. So after it is expanded, this function will be called
   //because it is only allowed calling one time.
   DWORD tempmode = CComponentDataImpl::GetGroupMode();
   if( SCE_MODE_UNKNOWN != tempmode )
   {
        if( SCE_MODE_LOCAL_COMPUTER == tempmode || 
            SCE_MODE_LOCAL_USER == tempmode )
            sFile.LoadString(IDS_HELPFILE_LOCAL_EXTENSION);
        else
            sFile.LoadString(IDS_HELPFILE_EXTENSION);
   }
   return CComponentDataImpl::GetHelpTopic(lpCompiledHelpFile,(LPCTSTR)sFile);
}


//+--------------------------------------------------------------------------
//
//  Method:    GetAnalTimeStamp
//
//  Synopsis:  Return the time of the last analysis
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
CSnapin::GetAnalTimeStamp() {
   PVOID SadHandle;
   CString strFormat;
   CString strTimeStamp;
   LPTSTR szAnalTimeStamp = NULL;


   //
   // Should cache this, but then we can't refresh it easily
   // when the system is re-analyzed.
   //
   if (m_szAnalTimeStamp) {
      LocalFree(m_szAnalTimeStamp);
      m_szAnalTimeStamp = NULL;

//      return m_szAnalTimeStamp;
   }

   SadHandle = ((CComponentDataImpl*)m_pComponentData)->SadHandle;
   if (!SadHandle) {
      return 0;
   }

   if (SCESTATUS_SUCCESS == SceGetTimeStamp(SadHandle,NULL,&szAnalTimeStamp)) {
      if (szAnalTimeStamp) {
      strFormat.LoadString(IDS_ANALTIMESTAMP);
      strTimeStamp.Format(strFormat,szAnalTimeStamp);
      m_szAnalTimeStamp = (LPTSTR) LocalAlloc(LPTR,(1+strTimeStamp.GetLength())*sizeof(TCHAR));
      if (m_szAnalTimeStamp) {
         lstrcpy(m_szAnalTimeStamp,strTimeStamp);
      }
         LocalFree(szAnalTimeStamp);
      }
   }

   return m_szAnalTimeStamp;
}

DWORD CComponentDataImpl::GetGroupMode()
{
    return m_GroupMode; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\svcattch.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       svcattch.cpp
//
//  Contents:   implementation of CComponentDataImpl
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "snapmgr.h"
#include <scesvc.h>

#define TEMPLATE_MAGIC_NUMBER (DWORD)-1

/*-------------------------------------------------------------------------------
This is a private structure used for SceSvcQueryInfo it expects the handle to
be one step above what it is now.
-------------------------------------------------------------------------------*/
typedef struct _tag_SCEP_HANDLE
{
    LPVOID hProfile;    // SCE_HANDLE
    PWSTR ServiceName;      // Service name.
} SCEP_HANDLE, *LPSCEP_HANDLE;


STDMETHODIMP
CComponentDataImpl::GetData (SCESVC_HANDLE sceHandle,
                             SCESVC_INFO_TYPE sceType,
                  PVOID *ppvData,
                  PSCE_ENUMERATION_CONTEXT psceEnumHandle) {
   SCESTATUS status;
   SCESVCP_HANDLE *scesvcHandle;

//   if (m_fSvcNotReady) {
//      return E_PENDING;
//   }

   if (!sceHandle) {
      return E_INVALIDARG;
   }

   if (!ppvData) {
      return E_POINTER;
   }

   scesvcHandle = (SCESVCP_HANDLE *) sceHandle;
   if (!scesvcHandle->ServiceName) {
      return E_INVALIDARG;
   }

   if (scesvcHandle->TemplateName &&
       lstrcmp(GT_COMPUTER_TEMPLATE, scesvcHandle->TemplateName) != 0 ) {

      if (psceEnumHandle &&
          *psceEnumHandle == TEMPLATE_MAGIC_NUMBER) {
         *ppvData = NULL;
         status = SCESTATUS_SUCCESS;
      } else {
         if (psceEnumHandle) {
            *psceEnumHandle = TEMPLATE_MAGIC_NUMBER;
         }
         status = SceSvcGetInformationTemplate(scesvcHandle->TemplateName,
                                            scesvcHandle->ServiceName,
                                            0,
                                            (PSCESVC_CONFIGURATION_INFO *) ppvData);
      }
   } else {
       //
       // This structure needs to be sent to SceSvcQueryInfo;
       //
       SCEP_HANDLE hScep;
       ZeroMemory(&hScep, sizeof(SCEP_HANDLE));
       hScep.hProfile = SadHandle;
       hScep.ServiceName = scesvcHandle->ServiceName;

       status = SceSvcQueryInfo((SCE_HANDLE)&hScep,sceType,0,0,ppvData,psceEnumHandle);
   }

   if (SCESTATUS_SUCCESS == status) {
      return S_OK;
   } else {
      return E_FAIL;
   }
}

STDMETHODIMP
CComponentDataImpl::Initialize(LPCTSTR ServiceName,
                    LPCTSTR TemplateName,
                    LPSCESVCATTACHMENTPERSISTINFO lpSceSvcPersistInfo,
                    SCESVC_HANDLE *sceHandle) {
   SCESVCP_HANDLE *scesvcHandle;
   CEditTemplate *pET;

   ASSERT(ServiceName);
   ASSERT(lpSceSvcPersistInfo);
   ASSERT(sceHandle);

   if (!ServiceName || !lpSceSvcPersistInfo || !sceHandle) {
      return E_POINTER;
   }

   *sceHandle = NULL;

   //
   // Cache Service & Template -> lpUnknown.
   //
   if (TemplateName && lstrlen(TemplateName)) {
      //
      // If TemplateName is not NULL then find the template and store it there
      //
      pET = GetTemplate(TemplateName);
      if (!pET) {
         return E_FAIL;
      }
      pET->AddService(ServiceName,lpSceSvcPersistInfo);
   } else {
      return E_INVALIDARG;
   }

   // Open & retrieve SCE_HANDLE
   scesvcHandle = new SCESVCP_HANDLE;
   if (!scesvcHandle) {
      return E_OUTOFMEMORY;
   }
   scesvcHandle->ServiceName = new TCHAR [ lstrlen(ServiceName)+1 ];
   if (!scesvcHandle->ServiceName) {
      delete scesvcHandle;
      return E_OUTOFMEMORY;
   }
   lstrcpy(scesvcHandle->ServiceName,ServiceName);
   if (TemplateName) {
      scesvcHandle->TemplateName = new TCHAR [ lstrlen(TemplateName)+1 ];
      if (!scesvcHandle->TemplateName) {
         delete [] scesvcHandle->ServiceName;
         delete scesvcHandle;
         return E_OUTOFMEMORY;
      }
      lstrcpy(scesvcHandle->TemplateName,TemplateName);
   } else {
      scesvcHandle->TemplateName = NULL;
   }
   *sceHandle = (SCESVC_HANDLE *) scesvcHandle;

   return S_OK;
}

STDMETHODIMP
CComponentDataImpl::FreeBuffer(PVOID pvData) {
   HRESULT hr;

   if (!pvData) {
      hr =  E_POINTER;
   } else if (SCESTATUS_SUCCESS == SceSvcFree(pvData)) {
      hr = S_OK;
   } else {
      hr = E_FAIL;
   }

   return hr;
}

STDMETHODIMP
CComponentDataImpl::CloseHandle(SCESVC_HANDLE sceHandle) {
   HRESULT hr;
   PSCESVCP_HANDLE pHandle;

   if (sceHandle) {
      pHandle = (PSCESVCP_HANDLE) sceHandle;
      // Free the handle
      if (pHandle->TemplateName) {
         delete[] pHandle->TemplateName;
      }
      delete[] pHandle->ServiceName;
      delete pHandle;
      hr =  S_OK;
   } else {
      hr =  E_INVALIDARG;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include <atlimpl.cpp>

//const CLSID CLSID_Snapin = {0x18731372,0x1D79,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on numeric format
//const GUID cNodeType = {0x44092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on string format
//const wchar_t*  cszNodeType = L"{44092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"WSECMGR_INTERNAL";

const CLSID CLSID_Snapin = { 0x803e14a0, 0xb4fb, 0x11d0, { 0xa0, 0xd0, 0x0, 0xa0, 0xc9, 0xf, 0x57, 0x4b } };

// Main NodeType GUID on numeric format
const GUID cNodeType = { 0x803e14a1, 0xb4fb, 0x11d0, { 0xa0, 0xd0, 0x0, 0xa0, 0xc9, 0xf, 0x57, 0x4b } };

// Main NodeType GUID on string format
const wchar_t*  cszNodeType = L"{803E14A1-B4FB-11d0-A0D0-00A0C90F574B}";


//
// class IDs for RSOP extenstion
//

// {FE883157-CEBD-4570-B7A2-E4FE06ABE626}
const CLSID CLSID_RSOPSnapin = 
{ 0xfe883157, 0xcebd, 0x4570, { 0xb7, 0xa2, 0xe4, 0xfe, 0x6, 0xab, 0xe6, 0x26 } };


// {F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}
const GUID cRSOPNodeType = 
//{ 0xf2e29987, 0x59e0, 0x47d0, { 0xb6, 0xd1, 0x4e, 0xcd, 0x9d, 0xfb, 0xcb, 0x20 } };
cNodeType;

// {F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}
const wchar_t* cszRSOPNodeType =  //L"{F2E29987-59E0-47d0-B6D1-4ECD9DFBCB20}";
cszNodeType;

//
// class IDs for SCE (standalone)
//
const CLSID CLSID_SCESnapin = { 0x5adf5bf6, 0xe452, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SCE NodeType GUID on numeric format
const GUID cSCENodeType = { 0xe10db5c6, 0xe450, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SCE NodeType GUID on string format
const wchar_t*  cszSCENodeType = L"{E10DB5C6-E450-11D1-945A-00C04FB984F9}";

// {2AABFCD0-1797-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SCEAbout =
{ 0x2aabfcd0, 0x1797, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {5C0786ED-1847-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SCMAbout =
{ 0x5c0786ed, 0x1847, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {5C0786EE-1847-11d2-ABA2-00C04FB6C6FA}
const GUID CLSID_SSAbout =
{ 0x5c0786ee, 0x1847, 0x11d2, { 0xab, 0xa2, 0x0, 0xc0, 0x4f, 0xb6, 0xc6, 0xfa } };

// {2E8EA1E5-F406-46f5-AF10-661FD6539F28}
const GUID CLSID_LSAbout =
{ 0x2e8ea1e5, 0xf406, 0x46f5, { 0xaf, 0x10, 0x66, 0x1f, 0xd6, 0x53, 0x9f, 0x28 } };

// {1B6FC61A-648A-4493-A303-A1A22B543F01}
const GUID CLSID_RSOPAbout = 
{ 0x1b6fc61a, 0x648a, 0x4493, { 0xa3, 0x3, 0xa1, 0xa2, 0x2b, 0x54, 0x3f, 0x1 } };


//
// class IDs for SAV (standalone)
//
const CLSID CLSID_SAVSnapin = { 0x011be22d, 0xe453, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SAV NodeType GUID on numeric format
const GUID cSAVNodeType = { 0xbd7d80a8, 0xe452, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xb9, 0x84, 0xf9 } };

// SAV NodeType GUID on string format
const wchar_t*  cszSAVNodeType = L"{BD7D80A8-E452-11D1-945A-00C04FB984F9}";

//
// class IDs for Local Security Settings (standalone)
//
// {CFF49D53-EE51-49f2-A807-7E3DF4EA36E3}
const CLSID CLSID_LSSnapin = 
{ 0xcff49d53, 0xee51, 0x49f2, { 0xa8, 0x7, 0x7e, 0x3d, 0xf4, 0xea, 0x36, 0xe3 } };

const wchar_t* cszLSNodeType = L"{C935FE05-7181-4926-B5E0-7A14477F98CC}";

const GUID cLSNodeType = 
{ 0xc935fe05, 0x7181, 0x4926, { 0xb5, 0xe0, 0x7a, 0x14, 0x47, 0x7f, 0x98, 0xcc } };

const TCHAR SNAPINS_KEY[]               = TEXT("Software\\Microsoft\\MMC\\SnapIns");
const TCHAR NODE_TYPES_KEY[]            = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR g_szExtensions[]            = TEXT("Extensions");
const TCHAR g_szNameSpace[]             = TEXT("NameSpace");

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\uithread.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       uithread.cpp
//
//  Contents:   implementation of CUIThread
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include <accctrl.h>
#include "servperm.h"
#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "UIThread.h"
#include "attr.h"
#include "aaudit.h"
#include "aenable.h"
#include "AMember.h"
#include "anumber.h"
#include "AObject.h"
#include "ARet.h"
#include "ARight.h"
#include "aservice.h"
#include "astring.h"
#include "CAudit.h"
#include "CEnable.h"
#include "CGroup.h"
#include "CName.h"
#include "CNumber.h"
#include "cobject.h"
#include "CPrivs.h"
#include "CRet.h"
#include "cservice.h"
#include "regvldlg.h"
#include "perfanal.h"
#include "applcnfg.h"
#include "wrapper.h"
#include "locdesc.h"
#include "profdesc.h"
#include "newprof.h"
#include "laudit.h"
#include "lenable.h"
#include "lret.h"
#include "lnumber.h"
#include "lstring.h"
#include "lright.h"
#include "achoice.h"
#include "cchoice.h"
#include "lchoice.h"
#include "dattrs.h"
#include "lflags.h"
#include "aflags.h"
#include "multisz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUIThread

IMPLEMENT_DYNCREATE(CUIThread, CWinThread)

CUIThread::CUIThread()
{
}

CUIThread::~CUIThread()
{
}

BOOL CUIThread::InitInstance()
{
   // TODO:  perform and per-thread initialization here
   return TRUE;
}

int CUIThread::ExitInstance()
{
   // TODO:  perform any per-thread cleanup here
   return CWinThread::ExitInstance();
}

BEGIN_MESSAGE_MAP(CUIThread, CWinThread)
   //{{AFX_MSG_MAP(CUIThread)
      // NOTE - the ClassWizard will add and remove mapping macros here.
   //}}AFX_MSG_MAP
   ON_THREAD_MESSAGE( SCEM_APPLY_PROFILE, OnApplyProfile)
   ON_THREAD_MESSAGE( SCEM_ANALYZE_PROFILE, OnAnalyzeProfile)
   ON_THREAD_MESSAGE( SCEM_DESCRIBE_PROFILE, OnDescribeProfile)
   ON_THREAD_MESSAGE( SCEM_DESCRIBE_LOCATION, OnDescribeLocation)
   ON_THREAD_MESSAGE( SCEM_DESTROY_DIALOG,    OnDestroyDialog)
   ON_THREAD_MESSAGE( SCEM_NEW_CONFIGURATION, OnNewConfiguration)
   ON_THREAD_MESSAGE( SCEM_ADD_PROPSHEET, OnAddPropSheet)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUIThread message handlers

//+--------------------------------------------------------------------------
//
//  Method:     DefaultLogFile
//
//  Synopsis:   Find the default log file for the inf file last applied
//  pass back the log file via the out parameter strLogFile
//
//---------------------------------------------------------------------------
void
CUIThread::DefaultLogFile(CComponentDataImpl *pCDI,GWD_TYPES LogID,LPCTSTR szBase, CString& strLogFile)
{
   //
   // Base log file on the db passed in
   //
   CString strDefExt;
   strDefExt.LoadString(IDS_LOGFILE_DEF_EXT);
   // make sure that the extension includes '.'
   if (strDefExt.GetLength() > 0 && strDefExt[0] != L'.')
   {
	   CString	tempExt = strDefExt;
	   strDefExt = L'.';
	   strDefExt += tempExt;
   }

   CString strInfFile = szBase;

   //
   // Get the default working directory
   //
   LPTSTR szDir = NULL;
   if (pCDI->GetWorkingDir(LogID,
                       &szDir,
                       FALSE,
                       FALSE)) {
      strLogFile = szDir;
      LocalFree(szDir);
      szDir = NULL;
   }

   if (strLogFile.Right(1) != TEXT("\\")) {
      strLogFile += L"\\";
   }

   if ( strInfFile.GetLength() < 5) {
     //
     // The default log file.
     //
     strLogFile += TEXT("SceStus") + strDefExt;
   } else {
      int nFilePartIndex = 0;
      int nFilePartCount = 0;
      //
      // +1 to change index base from 0 to 1 for the Mid
      //
      nFilePartIndex = strInfFile.ReverseFind(L'\\') +1;
      nFilePartCount = strInfFile.ReverseFind(L'.') - nFilePartIndex;
      strLogFile += strInfFile.Mid(nFilePartIndex,nFilePartCount) + strDefExt;
   }
}
//+--------------------------------------------------------------------------
//
//  Method:     OnApplyProfile
//
//  Synopsis:   Create and display a dialog for applying a profile to the
//              system
//
//  Arguments:  [uParam] - A string with the name of the database to assign to
//              [lParam] - A pointer to the CComponentDataImpl
//
//---------------------------------------------------------------------------
void
CUIThread::OnApplyProfile(WPARAM uParam, LPARAM lParam) {
   CComponentDataImpl *pCDI = NULL;
   CApplyConfiguration *pAP = NULL;
   CWnd cwndParent;

   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pAP = (CApplyConfiguration *)pCDI->GetPopupDialog(IDM_APPLY);
   if (NULL == pAP) {
      pAP = new CApplyConfiguration;
      if (NULL == pAP) {
         return;
      }
      pCDI->AddPopupDialog(IDM_APPLY,pAP);
   }

   pAP->m_strDataBase = reinterpret_cast<LPCTSTR>(uParam);
   DefaultLogFile(pCDI,GWD_CONFIGURE_LOG, pAP->m_strDataBase, pAP->m_strLogFile);
   pAP->SetComponentData(pCDI);

   if (!pAP->GetSafeHwnd()) 
   {
      cwndParent.Attach(pCDI->GetParentWindow());

      CThemeContextActivator activator;
      pAP->Create(IDD_APPLY_CONFIGURATION,&cwndParent);
      cwndParent.Detach();
   }

   pAP->UpdateData(FALSE);
   pAP->BringWindowToTop();
   pAP->ShowWindow(SW_SHOWNORMAL);
}

//+--------------------------------------------------------------------------
//
//  Method:     OnAnalyzeProfile
//
//  Synopsis:   Create and display a dialog for applying a profile to the
//              system
//
//  Arguments:  [uParam] - A string with the name of the database to assign to
//              [lParam] - A pointer to the CComponentDataImpl
//
//---------------------------------------------------------------------------
void
CUIThread::OnAnalyzeProfile(WPARAM uParam, LPARAM lParam) {
   CComponentDataImpl *pCDI = NULL;
   CPerformAnalysis *pPA = NULL;
   CWnd cwndParent;

   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pPA = (CPerformAnalysis *)pCDI->GetPopupDialog(IDM_ANALYZE);
   if (NULL == pPA) {
      pPA = new CPerformAnalysis (0, 0);
      if (NULL == pPA) {
         return;
      }

      pPA->m_strDataBase = reinterpret_cast<LPCTSTR>(uParam);
      DefaultLogFile(pCDI,GWD_ANALYSIS_LOG, pPA->m_strDataBase, pPA->m_strLogFile);
      pPA->SetComponentData(pCDI);

      pCDI->AddPopupDialog(IDM_ANALYZE,pPA);
   }

   if (!pPA->GetSafeHwnd()) 
   {
      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pPA->Create(IDD_PERFORM_ANALYSIS,&cwndParent);
      cwndParent.Detach();
   }

   pPA->BringWindowToTop();
   pPA->ShowWindow(SW_SHOWNORMAL);
}


//+--------------------------------------------------------------------------
//
//  Method:     OnDescribeProfile
//
//  Synopsis:   Create and display a dialog for editing a profile's description
//
//  Arguments:  [uParam] - A pointer to the CFolder for the object
//              [lParam] - The CComponentDataImpl owning the scope pane
//
//---------------------------------------------------------------------------
void
CUIThread::OnDescribeProfile(WPARAM uParam, LPARAM lParam) 
{
   CSetProfileDescription *pSPD;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CSetProfileDescription::IDD);

   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pSPD = (CSetProfileDescription *)pCDI->GetPopupDialog( dwKey );
   if (NULL == pSPD) {
      pSPD = new CSetProfileDescription;
      if (NULL == pSPD) {
         return;
      }

      pCDI->AddPopupDialog( dwKey, pSPD);
   }



   if (!pSPD->GetSafeHwnd()) 
   {
      if (GetProfileDescription(pFolder->GetInfFile(),&szDesc))
         pSPD->m_strDesc = szDesc;

      pSPD->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pSPD->Create(IDD_SET_DESCRIPTION,&cwndParent);
      cwndParent.Detach();
   }

   pSPD->UpdateData(FALSE);
   pSPD->BringWindowToTop();
   pSPD->ShowWindow(SW_SHOWNORMAL);

}



//+--------------------------------------------------------------------------
//
//  Method:     OnDescribeLocation
//
//  Synopsis:   Create and display a dialog for editing a Location's description
//
//  Arguments:  [uParam] - A pointer to the CFolder for the object
//              [lParam] - The CComponentDataImpl owning the scope pane
//
//---------------------------------------------------------------------------
void
CUIThread::OnDescribeLocation(WPARAM uParam, LPARAM lParam) {
   CSetLocationDescription *pSPD;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CSetLocationDescription::IDD);


   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pSPD = (CSetLocationDescription *)pCDI->GetPopupDialog( dwKey );
   if (NULL == pSPD) {
      pSPD = new CSetLocationDescription;
      if (NULL == pSPD) {
         return;
      }
      pCDI->AddPopupDialog(dwKey ,pSPD);
   }

//   pSPD->Initialize(pFolder,pCDI);


   if (!pSPD->GetSafeHwnd()) 
   {
      pSPD->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());
      CThemeContextActivator activator;
      pSPD->Create(IDD_SET_DESCRIPTION,&cwndParent);
      pSPD->SetWindowText(pFolder->GetName());
      cwndParent.Detach();
   }

   pSPD->UpdateData(FALSE);
   pSPD->BringWindowToTop();
   pSPD->ShowWindow(SW_SHOWNORMAL);

}

/*-----------------------------------------------------------------------------------
Method:     OnDestroyDialog

Synopsis:   Destroys and deletes the CAttribute object associated with [pDlg]

Arguments:  [pDlg]   - Is a pointer to the object to delete.

Histroy:
-----------------------------------------------------------------------------------*/
void CUIThread::OnDestroyDialog(WPARAM pDlg, LPARAM)
{
   if(pDlg){
      CAttribute *pAttr = reinterpret_cast<CAttribute *>(pDlg);

      delete pAttr;
   }
}


//+--------------------------------------------------------------------------
//
//  Method:     OnNewConfiguration
//
//  Synopsis:   Create and display a dialog for adding a new configuration file
//
//  Arguments:  [uParam] - A pointer to the CFolder parent of the new config file
//              [lParam] - A pointer to the CComponentDataItem
//
//---------------------------------------------------------------------------
void
CUIThread::OnNewConfiguration(WPARAM uParam, LPARAM lParam)
{
   CNewProfile *pNP;
   CFolder *pFolder;
   CComponentDataImpl *pCDI;
   CWnd cwndParent;

   LPTSTR szDesc;

   pFolder = reinterpret_cast<CFolder*>(uParam);
   pCDI = reinterpret_cast<CComponentDataImpl*>(lParam);
   LONG_PTR dwKey = DLG_KEY(pFolder, CNewProfile::IDD);


   //
   // Look for a preexisting version of this dialog in pCDI's cache.
   // If it's not there then create a new one and add it.
   //
   pNP = (CNewProfile *)pCDI->GetPopupDialog( dwKey);
   if (NULL == pNP) {
      pNP = new CNewProfile;
      if (NULL == pNP) {
         return;
      }
      pCDI->AddPopupDialog( dwKey, pNP);
   }

//   pNP->Initialize(pFolder,pCDI);


   if (!pNP->GetSafeHwnd()) {
      pNP->Initialize(pFolder,pCDI);

      cwndParent.Attach(pCDI->GetParentWindow());

      CThemeContextActivator activator;
      pNP->Create(IDD_NEW_PROFILE,&cwndParent);
      pNP->SetWindowText(pFolder->GetName());
      cwndParent.Detach();
   }

   pNP->UpdateData(FALSE);
   pNP->BringWindowToTop();
   pNP->ShowWindow(SW_SHOWNORMAL);

}

//+--------------------------------------------------------------------------
// Method:     OnAddPropsheet
//
// Synopsis:   Adds a property sheet to the list of sheets to which to pass messages
//             in PreTranslateMessage
//
// Arguments:  [wParam] - HWND of the added property sheet
//             [lParam] - unused
//
//---------------------------------------------------------------------------
void CUIThread::OnAddPropSheet(WPARAM wParam, LPARAM lParam)
{
   if (IsWindow((HWND)wParam)) {
      m_PSHwnds.AddHead((HWND)wParam);
   }
}


BOOL CUIThread::PreTranslateMessage(MSG* pMsg)
{
   //
   // check PropSheet_GetCurrentPageHwnd to see if we need to destroy
   // one of our modeless property sheets
   //

   POSITION pos;
   POSITION posCur;
   HWND hwnd;

   pos= m_PSHwnds.GetHeadPosition();
   while (pos) {
      posCur = pos;
      hwnd = m_PSHwnds.GetNext(pos);

      if (!IsWindow(hwnd)) {
         m_PSHwnds.RemoveAt(posCur);
      } else if (NULL == PropSheet_GetCurrentPageHwnd(hwnd)) {
         //
         // hwnd is a closed property sheet.  destroy it and remove it from the list
         //
         DestroyWindow(hwnd);
         m_PSHwnds.RemoveAt(posCur);
      }

      if (PropSheet_IsDialogMessage(hwnd,pMsg)) {
         //
         // Message has been handled, so don't do anything else with it
         //
         return TRUE;
      }
   }

   return CWinThread::PreTranslateMessage(pMsg);
}

/////////////////////////////////////////////////////////////////////////////
// CModelessDlgUIThread implementation

IMPLEMENT_DYNCREATE(CModelessDlgUIThread, CUIThread)

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CModelessDlgUIThread::CModelessDlgUIThread()
{
    m_hReadyForMsg = ::CreateEvent(NULL, TRUE, FALSE, NULL);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CModelessDlgUIThread::~CModelessDlgUIThread()
{
    if (NULL != m_hReadyForMsg)
        ::CloseHandle(m_hReadyForMsg);
}

BEGIN_MESSAGE_MAP(CModelessDlgUIThread, CUIThread)
    //{{AFX_MSG_MAP(CModelessDlgUIThread)
       // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
    ON_THREAD_MESSAGE( SCEM_CREATE_MODELESS_SHEET, OnCreateModelessSheet)
    ON_THREAD_MESSAGE( SCEM_DESTROY_WINDOW, OnDestroyWindow)
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
int CModelessDlgUIThread::Run()
{
    if (m_hReadyForMsg)
        ::SetEvent(m_hReadyForMsg);

    return CWinThread::Run();
}

//------------------------------------------------------------------------------
// wparam is PMLSHEET_DATA, and lparam is not used and can be used in the future
// for telling what property sheet is to be created (right now, it only works
// for ACL editor)
//------------------------------------------------------------------------------
void CModelessDlgUIThread::OnCreateModelessSheet(WPARAM wparam, LPARAM lparam)
{
    PMLSHEET_DATA pSheetData = (PMLSHEET_DATA)wparam;
    if (pSheetData)
    {
        HWND hSheet = (HWND)MyCreateSecurityPage2(pSheetData->bIsContainer,
                                                pSheetData->ppSeDescriptor,
                                                pSheetData->pSeInfo,
                                                pSheetData->strObjectName,
                                                pSheetData->SeType,
                                                pSheetData->flag,
                                                pSheetData->hwndParent,
                                                TRUE);
        *(pSheetData->phwndSheet) = hSheet;

        OnAddPropSheet((WPARAM)hSheet, 0);
    }
}

//------------------------------------------------------------------------------
// wparam is the window handle and lparam is not used at this time
// Since destroying a window must happen on the thread where it is contructed,
// this is necessary. Basic window management rules must be followed, e.g.,
// don't ask this thread to destroy windows that is not created by it
//------------------------------------------------------------------------------
void CModelessDlgUIThread::OnDestroyWindow(WPARAM wparam, LPARAM lparam)
{
    if (::IsWindow((HWND)wparam))
    {
        DestroyWindow((HWND)wparam);
    }
}

//------------------------------------------------------------------------------
// immediately after this thread object is created, creating thread needs to
// wait by calling this function so that the newly created thread has a chance
// to be scheduled to run.
//------------------------------------------------------------------------------
void CModelessDlgUIThread::WaitTillRun()
{
    if (NULL != m_hReadyForMsg)
    {
        // $UNDONE:shawnwu I found that MMC runs at THREAD_PRIORITY_ABOVE_NORMAL (or higher) priority
        // becaues only when I run this UI thread at THREAD_PRIORITY_HIGHEST will this thread schedule to run.
        // But running at that level of priority makes me feel a little bit nervous. I thus
        // leave this sleep(10) code here. Up to the UI team to decide.
        ::Sleep(10);
        ::WaitForSingleObject(m_hReadyForMsg, INFINITE);        // don't care about result of this waiting
        // now the event is useless. To reduce resource overhead, close the handle
        ::CloseHandle(m_hReadyForMsg);
        m_hReadyForMsg = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\util.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       util.cpp
//
//  Contents:   Miscellaneous utility functions
//
//  History:
//
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "util.h"
#include "wrapper.h"
#include "defvals.h"
#include "resource.h"
#include <io.h>
#include "snapmgr.h"
extern "C" {
#include "getuser.h"
}



//////////////////////////////////////////////////////////////////////////////////////////
// CWriteHmtlFile body.
//

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::CWriteHtmlFile
//
// Initialize the class.
//
//--------------------------------------------------------------------------------------------
CWriteHtmlFile::CWriteHtmlFile()
{
   m_hFileHandle = INVALID_HANDLE_VALUE;
   m_bErrored = FALSE;
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::~CWriteHtmlFile
//
// Write the end of the html file and close the handle.
//
//--------------------------------------------------------------------------------------------
CWriteHtmlFile::~CWriteHtmlFile()
{
   //
   // Close the file handle, but don't delete the HTML file, unless there was an
   // error during some write proccess.
   //
   Close(m_bErrored);
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Close
//
// Closes the HTML file handle, if [bDelete] is true then the file is deleted.
//
// Arguments:  [bDelete]  - Close and delete the file.
//
// Returns:    ERROR_SUCCESS;
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Close( BOOL bDelete )
{
   if(m_hFileHandle == INVALID_HANDLE_VALUE){
      return ERROR_SUCCESS;
   }

   if(bDelete){
      CloseHandle(m_hFileHandle);
      DeleteFile(m_strFileName );
   } else {
      Write( IDS_HTMLERR_END );
      CloseHandle( m_hFileHandle );
   }

   m_hFileHandle = INVALID_HANDLE_VALUE;
   return ERROR_SUCCESS;
}



//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::GetFileName
//
// Copies the file name associated with this class to [pstrFileName].
//
// Arguments:  [pstrFileName] - A CString object which will contain the file name
//                               on return.
//
// Returns:    0   - If Create has not been called, or the HTML file is invalid for
//                   some reason.  This could be caused by a bad write.
//             The size in characters of the file name.
//
//--------------------------------------------------------------------------------------------
int CWriteHtmlFile::GetFileName( LPTSTR pszFileName, UINT nSize )
{
   if(m_strFileName.IsEmpty() || m_hFileHandle == INVALID_HANDLE_VALUE || m_bErrored){
      return 0;
   }

   if(pszFileName && (int)nSize > m_strFileName.GetLength()){
      lstrcpy(pszFileName, m_strFileName);
   }

   return m_strFileName.GetLength();
}


//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Write
//
// Writes a string resource to the html file at the current file position.
//
// Arguments:  [uRes] - The String resource to load and write to the html.
//
// Returns:    If the string can't be loaded then an error will be returned.
//             See CWriteHtmlFile::Write( LPCTSTR ) for other errors.
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Write( UINT uRes )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   CString str;
   if( !str.LoadString(uRes) ){
      return GetLastError();
   }

#if defined(UNICODE) || defined(_UNICODE)
   if ( uRes == IDS_HTMLERR_HEADER ){
      WCHAR wszByteOrderMark[2] = {0xFEFF, 0x0000};
      CString strByteOrderMark = wszByteOrderMark;
      return Write( strByteOrderMark + str );
   } else
#endif
   return Write( str );
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Write
//
// Writes a string to an html file.
//
// Arguments:  [pszString] - The string to write.
//
// Returns:    ERROR_NOT_READ    - if Create has not been called, or the file could not
//                                  not be created.
//             Other errors returned by WriteFile();
//--------------------------------------------------------------------------------------------
DWORD
CWriteHtmlFile::Write(LPCTSTR pszString, ... )
{
   if(m_hFileHandle == INVALID_HANDLE_VALUE)
   {
      return ERROR_NOT_READY;
   }

   TCHAR szWrite[2048];

   va_list marker;
   va_start(marker, pszString);

#if defined(UNICODE) || defined(_UNICODE)
   vswprintf( szWrite, pszString, marker );
#else
   vsprintf( szWrite, pszString, marker );
#endif
   va_end(marker);

   DWORD dwRight;
   if( !WriteFile( m_hFileHandle, szWrite, sizeof(TCHAR) * lstrlen(szWrite), &dwRight, NULL) )
   {
      //
      // Check the error state of the right.  Set m_bErrored if there was something wrong
      // with the write.
      //
      dwRight = GetLastError();
      if(dwRight != ERROR_SUCCESS)
      {
         m_bErrored = TRUE;
      }
   } 
   else
   {
      dwRight = ERROR_SUCCESS;
   }

   return dwRight;
}

DWORD
CWriteHtmlFile::CopyTextFile(
   LPCTSTR pszFile,
   DWORD dwPosLow,
   BOOL bInterpret
   )
{
   HANDLE handle;

   //
   // Try to open the file for reading.
   //
   handle = ExpandAndCreateFile( pszFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
   if(handle == INVALID_HANDLE_VALUE)
   {
      return GetLastError();
   }

   LONG dwPosHigh = 0;
   WCHAR szText[256];
   char szRead[256];

   BOOL IsMulti;
   DWORD isUnicode;

   //
   // Determine if the file is a unicode text file.
   //
   ReadFile(handle, szText, 100 * sizeof(WCHAR), (DWORD *)&dwPosHigh, NULL );
   if(dwPosHigh )
   {
      isUnicode = IsTextUnicode( szText, dwPosHigh, NULL );
   }

   //
   // Set the pos we want to start from
   //
   dwPosHigh = 0;
   SetFilePointer( handle, dwPosLow, &dwPosHigh, FILE_BEGIN );
   if( GetLastError() != ERROR_SUCCESS )
   {
      return GetLastError();
   }

   DWORD dwErr = ERROR_SUCCESS;
   do 
   {
start:
      //
      // Read 254 total bytes from the file.  We don't care about the error returned
      // by read, as long as read does not set dwPosHigh to something.
      //
      dwPosHigh = 0;
      ReadFile( handle, szRead, 254, (DWORD *)&dwPosHigh, NULL );

      //
      // If the file is not considered unicode then convert it to a unicode file.
      //
      ZeroMemory(szText, sizeof(WCHAR) * 256);
      if(!isUnicode)
      {
         dwPosHigh = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szRead, dwPosHigh, szText, 255 );
      }
      else
      {
         //
         // Just copy the text to the szText buffer and get the number of UNICODE
         // characters.
         //
         memcpy(szText, szRead, dwPosHigh);
         dwPosHigh = wcslen(szText);
      }

      PWSTR pszWrite = szText;
      LONG i = 0;
      if( bInterpret )
      {
         //
         // Write out line breaks.
         //
         for(;i < dwPosHigh; i++)
         {
            //Bug 141526, Yanggao, 3/20/2001
            if( L'<' == szText[i] )
            {
               szText[i] = 0;
               Write(pszWrite);
               Write(L"&lt");
               pszWrite = &(szText[i + 1]);
            }

            if( L'\r' == szText[i] || L'\n' == szText[i] )
            {
               if( i + 1 >= dwPosHigh )
               {
                  szText[i] = 0;
                  Write(pszWrite);

                  SetFilePointer( handle, -(isUnicode ? 2:1), NULL, FILE_CURRENT);
                  //
                  // Read once again.
                  //
                  goto start;
               }

               //
               // Check to see if this is a valid line break
               //
               i++;
               if( L'\r' == szText[i] || L'\n' == szText[i] &&
                  szText[i] != szText[i - 1] )
               {
                  szText[i - 1] = 0;

                  dwErr = Write( pszWrite );
                  if( dwErr != ERROR_SUCCESS)
                  {
                     break;
                  }
                  dwErr = Write( L"<BR>" );
                  if( dwErr != ERROR_SUCCESS)
                  {
                     break;
                  }

                  pszWrite = &(szText[i + 1]);
               }
               else
               {
                  //
                  // This is not a valid line break, contintue with check with next character
                  //
                  i--;
               }
            }
         }
      }

      //
      // Write the rest of the text.
      //
      if(dwErr == ERROR_SUCCESS)
      {
         Write( pszWrite );
      }
      else
      {
         break;
      }

   } while( dwPosHigh );

   CloseHandle(handle );
   return ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------------------------
// CWriteHtmlFile::Create
//
// Creates an html file, and starts the write proccess.  If [pszFile] is null, then
// this function creates a temporary file in the GetTempPath() directory with a name
// like SCE###.HTM
//
// Arguments:  [pszFile] - Optional parameter for file name
//
// returns:    ERROR_SUCCESS  - If creating the file was successful.
//             If the file exists then ERROR_FILE_EXISTS is returned.
//
//--------------------------------------------------------------------------------------------
DWORD CWriteHtmlFile::Create(LPCTSTR pszFile )
{
   if(!pszFile){
      //
      // Create a temporary file name.
      //
      DWORD dwSize = GetTempPath(0, NULL);
      if(dwSize){
         TCHAR szTempFile[512];

         //
         // Get the temp path.
         //
         LPTSTR pszPath = (LPTSTR)LocalAlloc( 0, (dwSize + 1) * sizeof(TCHAR));
         if(!pszPath){
            return ERROR_OUTOFMEMORY;
         }
         GetTempPath( dwSize + 1, pszPath );

         pszPath[dwSize - 1] = 0;
         if( GetTempFileName( pszPath, TEXT("SCE"), 0, szTempFile) ){
            LocalFree(pszPath);

            //
            // Create the temporary file.
            //
            DeleteFile( szTempFile );
            int i = lstrlen(szTempFile);
            while(i--){
               if( szTempFile[i] == L'.' ){
                  break;
               }
            }

            if(i + 3 >= lstrlen(szTempFile)){
               return ERROR_OUTOFMEMORY;
            }

            //
            // We want to create an html file.
            //
            i++;
            szTempFile[i]     = L'h';
            szTempFile[i + 1] = L't';
            szTempFile[i + 2] = L'm';

            m_strFileName = szTempFile;
         } else {
            LocalFree(pszPath);
         }
      }
   } else {
      m_strFileName = pszFile;
   }

   if(m_strFileName.IsEmpty()){
      return ERROR_FILE_NOT_FOUND;
   }

   //
   // Open the file for writing
   //
   m_hFileHandle  = ExpandAndCreateFile( m_strFileName,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         CREATE_ALWAYS,
                                         FILE_ATTRIBUTE_TEMPORARY,
                                         NULL
                                         );
   if(m_hFileHandle  == INVALID_HANDLE_VALUE){
      return GetLastError();
   }

   //
   // Write HTML header
   //
   return Write( IDS_HTMLERR_HEADER );
}



//+--------------------------------------------------------------------------
//
//  Function:   MyRegQueryValue
//
//  Synopsis:  Reads a registry value into [*Value]
//
//
//  Arguments:  [hKeyRoot] -
//              [SubKey]  -
//              [ValueName]  -
//              [Value]  -
//              [pRegType]  -
//
//  Modifies:   *[Value]
//              *[pRegType]
//
//  History:
//
//---------------------------------------------------------------------------

DWORD MyRegQueryValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       PVOID *Value,
                       LPDWORD pRegType )
{
   DWORD   Rcode;
   DWORD   dSize=0;
   HKEY    hKey=NULL;
   BOOL    FreeMem=FALSE;

   if (( Rcode = RegOpenKeyEx(hKeyRoot, SubKey, 0,
                              KEY_READ, &hKey )) == ERROR_SUCCESS ) {

      if (( Rcode = RegQueryValueEx(hKey, ValueName, 0,
                                    pRegType, NULL,
                                    &dSize )) == ERROR_SUCCESS ) {
         switch (*pRegType) {
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:

               Rcode = RegQueryValueEx(hKey, ValueName, 0,
                                       pRegType, (BYTE *)(*Value),
                                       &dSize );
               if ( Rcode != ERROR_SUCCESS ) {

                  if ( *Value != NULL )
                     *((BYTE *)(*Value)) = 0;
               }
               break;

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
               if ( *Value == NULL ) {
                  *Value = (PVOID)LocalAlloc( LPTR, (dSize+1)*sizeof(TCHAR));
                  FreeMem = TRUE;
               }

               if ( *Value == NULL ) {
                  Rcode = ERROR_NOT_ENOUGH_MEMORY;
               } else {
                  Rcode = RegQueryValueEx(hKey,ValueName,0,
                                          pRegType,(BYTE *)(*Value),
                                          &dSize );

                  if ( (Rcode != ERROR_SUCCESS) && FreeMem ) {
                     LocalFree(*Value);
                     *Value = NULL;
                  }
               }

               break;
            default:

               Rcode = ERROR_INVALID_DATATYPE;

               break;
         }
      }
   }

   if ( hKey ) {
      RegCloseKey( hKey );
   }

   return(Rcode);
}


//+--------------------------------------------------------------------------
//
//  Function:   MyRegSetValue
//
//  Synopsis:  Writes a registry value into [*Value]
//
//
//  Arguments:  [hKeyRoot] -
//              [SubKey]  -
//              [ValueName]  -
//              [Value]  -
//              [cbValue]  -
//              [pRegType]  -
//
//
//  History:
//
//---------------------------------------------------------------------------

DWORD MyRegSetValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       const BYTE *Value,
                       const DWORD cbValue,
                       const DWORD pRegType )
{
   DWORD   Rcode=0;
   HKEY    hKey=NULL;
   BOOL    FreeMem=FALSE;


   if (( Rcode = RegCreateKeyEx(hKeyRoot,
                                SubKey,
                                0,
                                0,
                                                                0,
                                                                KEY_READ|KEY_SET_VALUE|KEY_CREATE_SUB_KEY,
                                NULL,
                                                                &hKey,
                                                                NULL)) == ERROR_SUCCESS ) {
      Rcode = RegSetValueEx(hKey,
                            ValueName,
                            0,
                            pRegType,
                            Value,
                            cbValue );
   }

   if ( hKey ) {
      RegCloseKey( hKey );
   }

   return(Rcode);
}

BOOL FilePathExist(LPCTSTR Name, BOOL IsPath, int Flag)
// Flag = 0 - check file, Flag = 1 - check path
{
   // TODO:
   struct _wfinddata_t FileInfo;
   intptr_t        hFile;
   BOOL            bExist = FALSE;

   if ( (IsPath && Flag == 1) ||
        (!IsPath && Flag == 0) ) {
      // must be exact match
      hFile = _wfindfirst((LPTSTR)Name, &FileInfo);
      if ( hFile != -1 ) {// find it
         if ( FileInfo.attrib & _A_SUBDIR ) {
            if ( Flag == 1)
               bExist = TRUE;
         } else if ( Flag == 0 )
            bExist = TRUE;
      }
      _findclose(hFile);
      return bExist;
   }

   if ( IsPath && Flag == 0 ) {
      // invalid parameter
      return bExist;
   }

   // IsPath = FALSE and Flag == 1 (a file name is passed in and search for its path)
   CString tmpstr = CString(Name);
   int nPos = tmpstr.ReverseFind(L'\\');

   if ( nPos > 2 ) {
      hFile = _wfindfirst(tmpstr.GetBufferSetLength(nPos), &FileInfo);
      if ( hFile != -1 && FileInfo.attrib & _A_SUBDIR )
         bExist = TRUE;

      _findclose(hFile);
   } else if ( nPos == 2 && Name[1] == L':')
      bExist = TRUE;

   return bExist;
}


//+--------------------------------------------------------------------------
//
//  Function:   MyFormatResMessage
//
//  Synopsis:   Creates an error message combining a description of an error
//              returned from an SCE function (in rc), the extended description
//              of that error (in errBuf), and a custom error message
//              (in residMessage)
//
//  Arguments:  [rc]      - The return code of an SCE function
//              [residMessage] - the resource id of the base error message
//              [errBuf]  - Extended error info returned from an SCE function
//              [strOut]  - A CString to hold the formatted message
//
//  Modifies:   [strOut]
//
//  History:
//
//---------------------------------------------------------------------------
void
MyFormatResMessage(SCESTATUS rc,              // in
                   UINT residMessage,         // in
                   PSCE_ERROR_LOG_INFO errBuf,// in, optional
                   CString& strOut)           // out
{
   CString strMessage;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   //
   // If the LoadResource fails then strMessage will be empty
   // It'll still be better to format the rest of the message than
   // to return an empty strOut.
   //
   strMessage.LoadString(residMessage);

   MyFormatMessage(rc,strMessage,errBuf,strOut);
}


//+--------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Creates an error message combining a description of an error
//              returned from an SCE function (in rc), the extended description
//              of that error (in errBuf), and a custom error message (in mes)
//
//  Arguments:  [rc]      - The return code of an SCE function
//              [mes]     - The base message
//              [errBuf]  - Extended error info returned from an SCE function
//              [strOut]  - A CString to hold the formatted message
//
//  Modifies:   [strOut]
//
//  History:
//
//---------------------------------------------------------------------------
void
MyFormatMessage(SCESTATUS rc,                 // in
                LPCTSTR mes,                  // in
                PSCE_ERROR_LOG_INFO errBuf,   // in, optional
                CString& strOut)              // out
{
   LPVOID     lpMsgBuf=NULL;

   if ( rc != SCESTATUS_SUCCESS ) {

      //
      // translate SCESTATUS into DWORD
      //
      DWORD win32 = SceStatusToDosError(rc);

      //
      // get error description of rc
      //
      FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                     NULL,
                     win32,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                     (LPTSTR)&lpMsgBuf,
                     0,
                     NULL
                   );
   }

   if ( lpMsgBuf != NULL ) {
      strOut = (LPTSTR)lpMsgBuf;
      LocalFree(lpMsgBuf);
      lpMsgBuf = NULL;
   } else {
      strOut.Empty();
   }

   strOut += mes;
   strOut += L"\n";

   //
   // Loop through the error buffers and append each of them to strOut
   //
   for (PSCE_ERROR_LOG_INFO pErr = errBuf;
       pErr != NULL;
       pErr = pErr->next) {

      if (NULL == pErr) {
         continue;
      }
      if ( pErr->rc != NO_ERROR) {
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        pErr->rc,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR)&lpMsgBuf,
                        0,
                        NULL
                      );
         if ( lpMsgBuf ) {
            strOut += (LPTSTR)lpMsgBuf;
            LocalFree(lpMsgBuf);
            lpMsgBuf = NULL;
         }
      }
      if (pErr->buffer) {
         strOut += pErr->buffer;
         strOut += L"\n";
      }

   }
}

DWORD
FormatDBErrorMessage(
   SCESTATUS sceStatus,
   LPCTSTR pszDatabase,
   CString &strOut
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   UINT    uErr    = 0;

   switch (sceStatus) {
   case SCESTATUS_SUCCESS:
      return ERROR_INVALID_PARAMETER;
   case SCESTATUS_INVALID_DATA:
      uErr = IDS_DBERR_INVALID_DATA;
      break;
   case SCESTATUS_PROFILE_NOT_FOUND:
      uErr = IDS_DBERR5_PROFILE_NOT_FOUND;
      break;
   case SCESTATUS_BAD_FORMAT:
      uErr = IDS_DBERR_BAD_FORMAT;
      break;
   case SCESTATUS_BUFFER_TOO_SMALL:
   case SCESTATUS_NOT_ENOUGH_RESOURCE:
      uErr = IDS_DBERR_NOT_ENOUGH_RESOURCE;
      break;
   case SCESTATUS_ACCESS_DENIED:
      uErr = IDS_DBERR5_ACCESS_DENIED;
      break;
   case SCESTATUS_NO_TEMPLATE_GIVEN:
      uErr = IDS_DBERR_NO_TEMPLATE_GIVEN;
      break;
   case SCESTATUS_SPECIAL_ACCOUNT: //Raid #589139,XPSP1 DCR, yanggao, 4/12/2002.
      uErr = IDS_DBERR5_ACCESS_DENIED;
      break;
   default:
      uErr = IDS_DBERR_OTHER_ERROR;
   }

   if ( strOut.LoadString(uErr) ) {
      return ERROR_SUCCESS;
   }
   return ERROR_INVALID_PARAMETER;
}

DWORD SceStatusToDosError(SCESTATUS SceStatus)
{
   switch (SceStatus) {

      case SCESTATUS_SUCCESS:
         return(NO_ERROR);

      case SCESTATUS_OTHER_ERROR:
         return(ERROR_EXTENDED_ERROR);

      case SCESTATUS_INVALID_PARAMETER:
         return(ERROR_INVALID_PARAMETER);

      case SCESTATUS_RECORD_NOT_FOUND:
         return(ERROR_RESOURCE_DATA_NOT_FOUND);

      case SCESTATUS_INVALID_DATA:
         return(ERROR_INVALID_DATA);

      case SCESTATUS_OBJECT_EXIST:
         return(ERROR_FILE_EXISTS);

      case SCESTATUS_BUFFER_TOO_SMALL:
         return(ERROR_INSUFFICIENT_BUFFER);

      case SCESTATUS_PROFILE_NOT_FOUND:
         return(ERROR_FILE_NOT_FOUND);

      case SCESTATUS_BAD_FORMAT:
         return(ERROR_BAD_FORMAT);

      case SCESTATUS_NOT_ENOUGH_RESOURCE:
         return(ERROR_NOT_ENOUGH_MEMORY);

      case SCESTATUS_ACCESS_DENIED:
      case SCESTATUS_SPECIAL_ACCOUNT: //Raid #589139,XPSP1 DCR, yanggao, 4/12/2002.
         return(ERROR_ACCESS_DENIED);

      case SCESTATUS_CANT_DELETE:
         return(ERROR_CURRENT_DIRECTORY);

      case SCESTATUS_PREFIX_OVERFLOW:
         return(ERROR_BUFFER_OVERFLOW);

      case SCESTATUS_ALREADY_RUNNING:
         return(ERROR_SERVICE_ALREADY_RUNNING);

      default:
         return(ERROR_EXTENDED_ERROR);
   }
}


//+--------------------------------------------------------------------------
//
//  Function:   CreateNewProfile
//
//  Synopsis:   Create a new tempate with default values in the ProfileName location
//
//  Returns:  TRUE if a template ends up in the ProfileName file
//            FALSE otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL CreateNewProfile(CString ProfileName,PSCE_PROFILE_INFO *ppspi)
{
   SCESTATUS status;
   SCE_PROFILE_INFO *pTemplate;
   //
   // profile name must end with .inf
   //
   int	nLen = ProfileName.GetLength ();
   // start searching at the last 4 position
   if ( ProfileName.Find (L".inf", nLen-4) != nLen-4 ) 
   {
      return FALSE;
   }

   //
   // if the profile already exists then we don't need to do anything
   //
   if ( FilePathExist( (LPCTSTR)ProfileName, FALSE, 0) ) {
      return TRUE;
   }

   //
   // Make sure the directory for the profile exists
   //
   status = SceCreateDirectory(ProfileName,FALSE,NULL);
   if (SCESTATUS_SUCCESS != status) {
      return FALSE;
   }

   pTemplate = (SCE_PROFILE_INFO*)LocalAlloc(LPTR,sizeof(SCE_PROFILE_INFO));
   if (!pTemplate) {
      return FALSE;
   }

#ifdef FILL_WITH_DEFAULT_VALUES
   SCE_PROFILE_INFO *pDefault = GetDefaultTemplate();
   //
   // Fill with default values
   //
   pTemplate->Type = SCE_ENGINE_SCP;

#define CD(X) pTemplate->X = pDefault->X;
#else // !FILL_WITH_DEFAULT_VALUES
#define CD(X) pTemplate->X = SCE_NO_VALUE;
#endif // !FILL_WITH_DEFAULT_VALUES

   CD(MinimumPasswordAge);
   CD(MaximumPasswordAge);
   CD(MinimumPasswordLength);
   CD(PasswordComplexity);
   CD(PasswordHistorySize);
   CD(LockoutBadCount);
   CD(ResetLockoutCount);
   CD(LockoutDuration);
   CD(RequireLogonToChangePassword);
   CD(ForceLogoffWhenHourExpire);
   CD(EnableAdminAccount);
   CD(EnableGuestAccount);

   // These members aren't declared in NT4
   CD(ClearTextPassword);
   CD(AuditDSAccess);
   CD(AuditAccountLogon);
   CD(LSAAnonymousNameLookup);

   CD(MaximumLogSize[0]);
   CD(MaximumLogSize[1]);
   CD(MaximumLogSize[2]);
   CD(AuditLogRetentionPeriod[0]);
   CD(AuditLogRetentionPeriod[1]);
   CD(AuditLogRetentionPeriod[2]);
   CD(RetentionDays[0]);
   CD(RetentionDays[1]);
   CD(RetentionDays[2]);
   CD(RestrictGuestAccess[0]);
   CD(RestrictGuestAccess[1]);
   CD(RestrictGuestAccess[2]);
   CD(AuditSystemEvents);
   CD(AuditLogonEvents);
   CD(AuditObjectAccess);
   CD(AuditPrivilegeUse);
   CD(AuditPolicyChange);
   CD(AuditAccountManage);
   CD(AuditProcessTracking);

#ifdef FILL_WITH_DEFAULT_VALUES
   //
   // These two are strings rather than DWORDs
   //
   if (pDefault->NewAdministratorName) {
      pTemplate->NewAdministratorName =
         (LPTSTR) LocalAlloc(LPTR,(lstrlen(pDefault->NewAdministratorName)+1)*sizeof(TCHAR));
      if (pTemplate->NewAdministratorName) {
         lstrcpy(pTemplate->NewAdministratorName,
                 pDefault->NewAdministratorName);
      }
   }
   if (pDefault->NewGuestName) {
      pTemplate->NewGuestName =
         (LPTSTR) LocalAlloc(LPTR,(lstrlen(pDefault->NewGuestName)+1)*sizeof(TCHAR));
      if (pTemplate->NewGuestName) {
         lstrcpy(pTemplate->NewGuestName,
                 pDefault->NewGuestName);
      }
   }
#endif // FILL_WITH_DEFAULT_VALUES

#undef CD
   status = SceWriteSecurityProfileInfo(ProfileName,
                                        AREA_ALL,
                                        pTemplate,
                                        NULL);
   if (ppspi) {
      *ppspi = pTemplate;
   } else {
      SceFreeProfileMemory(pTemplate);
   }

   return (SCESTATUS_SUCCESS == status);
}

BOOL
VerifyKerberosInfo(PSCE_PROFILE_INFO pspi) {
   if (pspi->pKerberosInfo) {
      return TRUE;
   }
   pspi->pKerberosInfo = (PSCE_KERBEROS_TICKET_INFO)
                         LocalAlloc(LPTR,sizeof(SCE_KERBEROS_TICKET_INFO));

   if (pspi->pKerberosInfo) {
       pspi->pKerberosInfo->MaxTicketAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxRenewAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxServiceAge = SCE_NO_VALUE;
       pspi->pKerberosInfo->MaxClockSkew = SCE_NO_VALUE;
       pspi->pKerberosInfo->TicketValidateClient = SCE_NO_VALUE;
      return TRUE;
   }
   return FALSE;
}

BOOL
SetProfileInfo(LONG_PTR dwItem,LONG_PTR dwNew,PEDITTEMPLATE pEdit) {
   if (!pEdit) {
      return FALSE;
   }
   pEdit->SetDirty(AREA_SECURITY_POLICY);

   switch (dwItem) {
      case IDS_MAX_PAS_AGE:
         pEdit->pTemplate->MaximumPasswordAge = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_MIN_PAS_AGE:
         pEdit->pTemplate->MinimumPasswordAge = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_MIN_PAS_LEN:
         pEdit->pTemplate->MinimumPasswordLength = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PAS_UNIQUENESS:
         pEdit->pTemplate->PasswordHistorySize = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PAS_COMPLEX:
         pEdit->pTemplate->PasswordComplexity = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_REQ_LOGON:
         pEdit->pTemplate->RequireLogonToChangePassword = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_COUNT:
         pEdit->pTemplate->LockoutBadCount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_RESET_COUNT:
         pEdit->pTemplate->ResetLockoutCount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOCK_DURATION:
         pEdit->pTemplate->LockoutDuration = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_FORCE_LOGOFF:
         pEdit->pTemplate->ForceLogoffWhenHourExpire = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ENABLE_ADMIN:
         pEdit->pTemplate->EnableAdminAccount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ENABLE_GUEST:
         pEdit->pTemplate->EnableGuestAccount = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LSA_ANON_LOOKUP:
         pEdit->pTemplate->LSAAnonymousNameLookup = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_NEW_ADMIN:
         if (pEdit->pTemplate->NewAdministratorName) {
            LocalFree(pEdit->pTemplate->NewAdministratorName);
         }
         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {
            pEdit->pTemplate->NewAdministratorName = (PWSTR)LocalAlloc(LPTR,(lstrlen((PWSTR)dwNew)+1)*sizeof(WCHAR));
            if (pEdit->pTemplate->NewAdministratorName) {
               lstrcpy(pEdit->pTemplate->NewAdministratorName,(PWSTR)dwNew);
            }
         } else {
            pEdit->pTemplate->NewAdministratorName = NULL;
         }
         break;
      case IDS_NEW_GUEST:
         if (pEdit->pTemplate->NewGuestName) {
            LocalFree(pEdit->pTemplate->NewGuestName);
         }
         if (dwNew && (dwNew != (LONG_PTR)ULongToPtr(SCE_NO_VALUE))) {
            pEdit->pTemplate->NewGuestName = (PWSTR)LocalAlloc(LPTR,(lstrlen((PWSTR)dwNew)+1)*sizeof(WCHAR));
            if (pEdit->pTemplate->NewGuestName) {
               lstrcpy(pEdit->pTemplate->NewGuestName,(PWSTR)dwNew);
            }
         } else {
            pEdit->pTemplate->NewGuestName = NULL;
         }
         break;
      case IDS_SYS_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_MAX:
         pEdit->pTemplate->MaximumLogSize[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_RET:
         pEdit->pTemplate->AuditLogRetentionPeriod[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_DAYS:
         pEdit->pTemplate->RetentionDays[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYSTEM_EVENT:
         pEdit->pTemplate->AuditSystemEvents = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_LOGON_EVENT:
         pEdit->pTemplate->AuditLogonEvents = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_OBJECT_ACCESS:
         pEdit->pTemplate->AuditObjectAccess = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PRIVILEGE_USE:
         pEdit->pTemplate->AuditPrivilegeUse = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_POLICY_CHANGE:
         pEdit->pTemplate->AuditPolicyChange = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ACCOUNT_MANAGE:
         pEdit->pTemplate->AuditAccountManage = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_PROCESS_TRACK:
         pEdit->pTemplate->AuditProcessTracking = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_DIRECTORY_ACCESS:
         pEdit->pTemplate->AuditDSAccess = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_ACCOUNT_LOGON:
         pEdit->pTemplate->AuditAccountLogon = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SYS_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_SYSTEM] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_SEC_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_SECURITY] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_APP_LOG_GUEST:
         pEdit->pTemplate->RestrictGuestAccess[EVENT_TYPE_APP] = (DWORD)PtrToUlong((PVOID)dwNew);
         break;
      case IDS_CLEAR_PASSWORD:
         pEdit->pTemplate->ClearTextPassword = (DWORD)PtrToUlong((PVOID)dwNew);
         break;

      case IDS_KERBEROS_MAX_SERVICE:
         if (VerifyKerberosInfo(pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxServiceAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_MAX_CLOCK:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxClockSkew = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_VALIDATE_CLIENT:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->TicketValidateClient = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;

      case IDS_KERBEROS_MAX_AGE:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxTicketAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      case IDS_KERBEROS_RENEWAL:
         if (VerifyKerberosInfo(   pEdit->pTemplate)) {
            pEdit->pTemplate->pKerberosInfo->MaxRenewAge = (DWORD)PtrToUlong((PVOID)dwNew);
         }
         break;
      default:
         return FALSE;
   }
   return TRUE;

}


//
//  FUNCTION:   ErrorHandlerEx(WORD, LPSTR)
//
//  PURPOSE:    Calls GetLastError() and uses FormatMessage() to display the
//              textual information of the error code along with the file
//              and line number.
//
//  PARAMETERS:
//      wLine    - line number where the error occured
//      lpszFile - file where the error occured
//
//  RETURN VALUE:
//      none
//
//  COMMENTS:
//      This function has a macro ErrorHandler() which handles filling in
//      the line number and file name where the error occured.  ErrorHandler()
//      is always used instead of calling this function directly.
//

void ErrorHandlerEx( WORD wLine, LPTSTR lpszFile )
{
   LPVOID lpvMessage;
   DWORD  dwError;
   TCHAR  szBuffer[256];

   // The the text of the error message
   dwError = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           GetLastError(),
                           MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                           (LPTSTR)&lpvMessage,
                           0,
                           NULL);

   // Check to see if an error occured calling FormatMessage()
   if (0 == dwError) {
      wsprintf(szBuffer, TEXT("An error occured calling FormatMessage().")
               TEXT("Error Code %d"), GetLastError());
      MessageBox(NULL, szBuffer, TEXT("Security Configuration Editor"), MB_ICONSTOP |
                 MB_ICONEXCLAMATION);
      return;
   }

   // Display the error message
   wsprintf(szBuffer, TEXT("Generic, Line=%d, File=%s"), wLine, lpszFile);
   MessageBox(NULL, (LPTSTR)lpvMessage, szBuffer, MB_ICONEXCLAMATION | MB_OK);

   return;
}

BOOL
GetSceStatusString(SCESTATUS status, CString *strStatus) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
   if (!strStatus || (status > SCESTATUS_SERVICE_NOT_SUPPORT)) {
      return false;
   }
   return strStatus->LoadString(status + IDS_SCESTATUS_SUCCESS);
}


//+---------------------------------------------------------------------------------------------
// EnumLangProc
//
// Creates the lanuage ID for the resource attached to the DLL. The function only enumerates
// on lanuage.
//
// Arguments:  - See help on EnumResLangProc in the SDK Doc.
//
// Returns:    - Returns FALSE because we only want the very first lanuage enumerated.
//
//+---------------------------------------------------------------------------------------------
BOOL CALLBACK EnumLangProc(
                  HMODULE hMod,
                  LPCTSTR pszType,
                  LPCTSTR pszName,
                  WORD wIDLanguage,
                  LONG_PTR lParam
                  )
{
   //
   // We only want the very first enumerated type, so create the language ID
   // and exit this enumeration.
   //
   *((DWORD *)lParam) = wIDLanguage;
   return FALSE;
}

bool
GetRightDisplayName(LPCTSTR szSystemName, LPCTSTR szName, LPTSTR szDisp, LPDWORD lpcbDisp) {
   LPTSTR szLCName;
   DWORD dwLang;
   int i;

   if (!szDisp || !szName) {
      return false;
   }

   //
   // Enumerate our resource to find out what language the resource is in.
   //
   DWORD dwDefaultLang;

   if( !EnumResourceLanguages(
         (HMODULE)AfxGetInstanceHandle(),
         MAKEINTRESOURCE(RT_VERSION),
         MAKEINTRESOURCE(VS_VERSION_INFO),
         &EnumLangProc,
         (LPARAM)&dwDefaultLang
         ) ){

      if(GetLastError() != ERROR_SUCCESS){
         //
         // Default to system language if enumerating the version language
         // was unsuccessful.
         dwDefaultLang = MAKELANGID(LANG_NEUTRAL, 0);
      }
   }

   dwDefaultLang = MAKELANGID( dwDefaultLang, SUBLANG_DEFAULT);
   LCID langID = MAKELCID( dwDefaultLang, SORT_DEFAULT);

   LCID langDefault = GetThreadLocale();
   SetThreadLocale( langID );
   *lpcbDisp = dwDefaultLang;

   DWORD cBufSize=*lpcbDisp;
   BOOL bFound;

   bFound = LookupPrivilegeDisplayName(szSystemName,szName,szDisp,lpcbDisp,&dwLang);
   if ( bFound && dwDefaultLang != dwLang && szSystemName ) {
      // not the language I am looking for
      // search on local system
      *lpcbDisp = cBufSize;
      bFound = LookupPrivilegeDisplayName(NULL,szName,szDisp,lpcbDisp,&dwLang);
   }
   SetThreadLocale(langDefault);

   if (!bFound) {
      if (0 == lstrcmpi(szName,L"senetworklogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_NETWORK_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"seinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_INTERACTIVE_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sebatchlogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_BATCH_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"seservicelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_SE_SERVICE_LOGON_RIGHT,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sedenyinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_LOCALLY,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sedenynetworklogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_NETWORK,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sedenyservicelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_SERVICE,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sedenybatchlogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_LOGON_BATCH,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"sedenyremoteinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_DENY_REMOTE_INTERACTIVE_LOGON,szDisp,*lpcbDisp);
      } else if (0 == lstrcmpi(szName,L"seremoteinteractivelogonright")) {
         LoadString(AfxGetInstanceHandle(),IDS_REMOTE_INTERACTIVE_LOGON,szDisp,*lpcbDisp);
      } else {
         lstrcpyn(szDisp,szName,*lpcbDisp);
      }
   }
   return true;
}

#define DPI(X) {str.Format(L"%S: %d\n",#X,pInfo->X);OutputDebugString(str);}
void DumpProfileInfo(PSCE_PROFILE_INFO pInfo) {
   CString str;
   PSCE_PRIVILEGE_ASSIGNMENT ppa;
   PSCE_NAME_LIST pName;
   PSCE_GROUP_MEMBERSHIP pgm;

   if (!pInfo) {
      return;
   }

   DPI(MinimumPasswordAge);
   DPI(MaximumPasswordAge);
   DPI(MinimumPasswordLength);
   DPI(PasswordComplexity);
   DPI(PasswordHistorySize);
   DPI(LockoutBadCount);
   DPI(ResetLockoutCount);
   DPI(LockoutDuration);
   DPI(RequireLogonToChangePassword);
   DPI(ForceLogoffWhenHourExpire);
   DPI(EnableAdminAccount);
   DPI(EnableGuestAccount);
   DPI(ClearTextPassword);
   DPI(AuditDSAccess);
   DPI(AuditAccountLogon);
   DPI(LSAAnonymousNameLookup);
   //    DPI(EventAuditingOnOff);
   DPI(AuditSystemEvents);
   DPI(AuditLogonEvents);
   DPI(AuditObjectAccess);
   DPI(AuditPrivilegeUse);
   DPI(AuditPolicyChange);
   DPI(AuditAccountManage);
   DPI(AuditProcessTracking);

   if (pInfo->NewGuestName) {
      OutputDebugString(L"NewGuestName: ");
      if ((DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == (DWORD_PTR)pInfo->NewGuestName) {
         OutputDebugString(L"[[undefined]]");
      } else {
         OutputDebugString(pInfo->NewGuestName);
      }
      OutputDebugString(L"\n");
   } else {
      OutputDebugString(L"NewGuestName: [[absent]]\n");
   }
   if (pInfo->NewAdministratorName) {
      OutputDebugString(L"NewAdministratorName: ");
      if ((DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == (DWORD_PTR)pInfo->NewAdministratorName) {
         OutputDebugString(L"[[undefined]]");
      } else {
         OutputDebugString(pInfo->NewAdministratorName);
      }
      OutputDebugString(L"\n");
   } else {
      OutputDebugString(L"NewGuestName: [[absent]]\n");
   }


   OutputDebugString(L"\n");

   switch(pInfo->Type) {
      case SCE_ENGINE_SCP:
         ppa = pInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SAP:
         ppa = pInfo->OtherInfo.sap.pPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SMP:
         ppa = pInfo->OtherInfo.smp.pPrivilegeAssignedTo;
         break;
      case SCE_ENGINE_SYSTEM:
         ppa = NULL;
         break;
      default:
         OutputDebugString(L"!!!Unknown Template Type!!!\n");
         ppa = NULL;
         break;
   }
   while(ppa) {
      OutputDebugString(ppa->Name);
      OutputDebugString(L":");
      pName = ppa->AssignedTo;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      ppa = ppa->Next;
      OutputDebugString(L"\n");
   }
   OutputDebugString(L"\n");

   PSCE_REGISTRY_VALUE_INFO    aRegValues;
   for(DWORD i = 0; i< pInfo->RegValueCount;i++) {
      OutputDebugString(pInfo->aRegValues[i].FullValueName);
      OutputDebugString(L":");
      switch(pInfo->aRegValues[i].ValueType) {
         case SCE_REG_DISPLAY_STRING:
            OutputDebugString(pInfo->aRegValues[i].Value);
            break;
         default:
            str.Format(L"%d",(ULONG_PTR)pInfo->aRegValues[i].Value);
            OutputDebugString(str);
      }
      OutputDebugString(L"\n");
   }
   OutputDebugString(L"\n");

   pgm = pInfo->pGroupMembership;
   while(pgm) {
      OutputDebugString(L"\nGROUP: ");
      OutputDebugString(pgm->GroupName);
      OutputDebugString(L"\nMembers: ");
      pName = pgm->pMembers;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      OutputDebugString(L"\nMember Of: ");
      pName = pgm->pMemberOf;
      while(pName) {
         OutputDebugString(pName->Name);
         OutputDebugString(L",");
         pName = pName->Next;
      }
      OutputDebugString(L"\n");
      pgm = pgm->Next;
   }
   OutputDebugString(L"\nGROUP: ");
}

HRESULT MyMakeSelfRelativeSD(
                            PSECURITY_DESCRIPTOR  psdOriginal,
                            PSECURITY_DESCRIPTOR* ppsdNew )
{
   ASSERT( NULL != psdOriginal );

   if ( NULL == psdOriginal || NULL == ppsdNew ) {
      return E_INVALIDARG;
   }

   // we have to find out whether the original is already self-relative
   SECURITY_DESCRIPTOR_CONTROL sdc = 0;
   DWORD dwRevision = 0;
   if ( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
      ASSERT( FALSE );
      DWORD err = GetLastError();
      return HRESULT_FROM_WIN32( err );
   }

   DWORD cb = GetSecurityDescriptorLength( psdOriginal ) + 20;
   PSECURITY_DESCRIPTOR psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_ZEROINIT, cb );
   if (NULL == psdSelfRelativeCopy) {
      return E_UNEXPECTED; // just in case the exception is ignored
   }

   if ( sdc & SE_SELF_RELATIVE )
   // the original is in self-relative format, just byte-copy it
   {
      memcpy( psdSelfRelativeCopy, psdOriginal, cb - 20 );
   } else if ( !MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) )
   // the original is in absolute format, convert-copy it
   {
      ASSERT( FALSE );
      VERIFY( NULL == LocalFree( psdSelfRelativeCopy ) );
      DWORD err = GetLastError();
      return HRESULT_FROM_WIN32( err );
   }
   *ppsdNew = psdSelfRelativeCopy;
   return S_OK;
}

PSCE_NAME_STATUS_LIST
MergeNameStatusList(PSCE_NAME_LIST pTemplate, PSCE_NAME_LIST pInspect)
{
   PSCE_NAME_LIST pTemp1;
   PSCE_NAME_STATUS_LIST plMerge=NULL, pTemp2;
   SCESTATUS rc=SCESTATUS_SUCCESS;

   for ( pTemp1=pTemplate; pTemp1; pTemp1=pTemp1->Next ) {

      rc = SceAddToNameStatusList(&plMerge, pTemp1->Name, 0, MERGED_TEMPLATE );
      if ( SCESTATUS_SUCCESS != rc )
         break;
   }
   if ( SCESTATUS_SUCCESS == rc ) {
      for ( pTemp1=pInspect; pTemp1; pTemp1=pTemp1->Next ) {

         for ( pTemp2=plMerge; pTemp2 != NULL ; pTemp2=pTemp2->Next ) {
            if ( pTemp2->Status & MERGED_INSPECT ) {
               // this one is processed
               continue;
            } else if ( _wcsicmp(pTemp1->Name, pTemp2->Name) == 0 ) {
               // find a match
               pTemp2->Status = MERGED_TEMPLATE | MERGED_INSPECT;
               break;
            }
         }
         if ( !pTemp2 ) {
            // did not find the match, add this one in
            rc = SceAddToNameStatusList(&plMerge, pTemp1->Name, 0, MERGED_INSPECT );
            if ( SCESTATUS_SUCCESS != rc )
               break;
         }
      }
   }
   if ( SCESTATUS_SUCCESS == rc ) {
      return plMerge;
   } else {
      SceFreeMemory(plMerge, SCE_STRUCT_NAME_STATUS_LIST);
      return NULL;
   }
}


SCESTATUS
ConvertMultiSzToDelim(
                     IN PWSTR pValue,
                     IN DWORD Len,
                     IN WCHAR DelimFrom,
                     IN WCHAR Delim
                     )
/*
Convert the multi-sz delimiter \0 to space
*/
{
   DWORD i;

   for ( i=0; i<Len && pValue; i++) {
      //        if ( *(pValue+i) == L'\0' && *(pValue+i+1) != L'\0') {
      if ( *(pValue+i) == DelimFrom && i+1 < Len &&
           *(pValue+i+1) != L'\0' ) {
         //
         // a NULL delimiter is encounted and it's not the end (double NULL)
         //
         *(pValue+i) = Delim;
      }
   }

   return(SCESTATUS_SUCCESS);
}

DWORD
SceRegEnumAllValues(
                   IN OUT PDWORD  pCount,
                   IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
                   )
/*
*/
{
   DWORD   Win32Rc;
   HKEY    hKey=NULL;
   PSCE_NAME_STATUS_LIST pnsList=NULL;
   DWORD   nAdded=0;


   Win32Rc = RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         SCE_ROOT_REGVALUE_PATH,
                         0,
                         KEY_READ,
                         &hKey
                         );

   DWORD cSubKeys = 0;
   DWORD nMaxLen;

   if ( Win32Rc == ERROR_SUCCESS ) {

      //
      // enumerate all subkeys of the key
      //

      Win32Rc = RegQueryInfoKey (
                                hKey,
                                NULL,
                                NULL,
                                NULL,
                                &cSubKeys,
                                &nMaxLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );
   }

   if ( Win32Rc == ERROR_SUCCESS && cSubKeys > 0 ) {

      PWSTR   szName = (PWSTR)LocalAlloc(0, (nMaxLen+2)*sizeof(WCHAR));

      if ( !szName ) {
         Win32Rc = ERROR_NOT_ENOUGH_MEMORY;

      } else {

         DWORD   BufSize;
         DWORD   index = 0;
         DWORD   RegType;

         do {

            BufSize = nMaxLen+1;
            Win32Rc = RegEnumKeyEx(
                                  hKey,
                                  index,
                                  szName,
                                  &BufSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

            if ( ERROR_SUCCESS == Win32Rc ) {

               index++;

               //
               // get the full registry key name and Valuetype
               //
               cSubKeys = REG_SZ;
               PDWORD pType = &cSubKeys;

               //
               // query ValueType, if error, default REG_SZ
               //
               MyRegQueryValue( hKey,
                                szName,
                                SCE_REG_VALUE_TYPE,
                                (PVOID *)&pType,
                                &RegType );

               if ( cSubKeys < REG_SZ || cSubKeys > REG_MULTI_SZ ) {
                  cSubKeys = REG_SZ;
               }

               //
               // convert the path name
               //
               ConvertMultiSzToDelim(szName, BufSize, L'/', L'\\');

               //
               // compare with the input array, if not exist,
               // add it
               //
               for ( DWORD i=0; i<*pCount; i++ ) {
                  if ( (*paRegValues)[i].FullValueName &&
                       _wcsicmp(szName, (*paRegValues)[i].FullValueName) == 0 ) {
                     break;
                  }
               }

               if ( i >= *pCount ) {
                  //
                  // did not find a match, add it
                  //
                  if ( SCESTATUS_SUCCESS != SceAddToNameStatusList(&pnsList,
                                                                   szName,
                                                                   BufSize,
                                                                   cSubKeys) ) {

                     Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
                  nAdded++;
               }

            } else if ( ERROR_NO_MORE_ITEMS != Win32Rc ) {
               break;
            }

         } while ( Win32Rc != ERROR_NO_MORE_ITEMS );

         if ( Win32Rc == ERROR_NO_MORE_ITEMS ) {
            Win32Rc = ERROR_SUCCESS;
         }


         //
         // free the enumeration buffer
         //
         LocalFree(szName);
      }
   }

   if ( hKey ) {

      RegCloseKey(hKey);
   }


   if ( ERROR_SUCCESS == Win32Rc ) {
      //
      // add the name list to the output arrays
      //
      DWORD nNewCount = *pCount + nAdded;
      PSCE_REGISTRY_VALUE_INFO aNewArray;

      if ( nNewCount ) {

         aNewArray = (PSCE_REGISTRY_VALUE_INFO)LocalAlloc(0, nNewCount*sizeof(SCE_REGISTRY_VALUE_INFO));
         if ( aNewArray ) {
            ZeroMemory(aNewArray, nNewCount * sizeof(SCE_REGISTRY_VALUE_INFO));

            memcpy( aNewArray, *paRegValues, *pCount * sizeof( SCE_REGISTRY_VALUE_INFO ) );
            DWORD i;

            i=0;
            for ( PSCE_NAME_STATUS_LIST pns=pnsList;
                pns; pns=pns->Next ) {

               if ( pns->Name && i < nAdded ) {

                  aNewArray[*pCount+i].FullValueName = pns->Name;
                  pns->Name = NULL;
                  aNewArray[*pCount+i].Value = NULL;
                  aNewArray[*pCount+i].ValueType = pns->Status;
                  aNewArray[*pCount+i].Status = SCE_STATUS_NOT_CONFIGURED;
                  i++;

               }
            }

            //
            // free the original array
            // all components in the array are already transferred to the new array
            //
            LocalFree(*paRegValues);
            *pCount = nNewCount;
            *paRegValues = aNewArray;

         } else {

            Win32Rc = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   //
   // free the name status list
   //
   SceFreeMemory(pnsList, SCE_STRUCT_NAME_STATUS_LIST);

   return( Win32Rc );

}


DWORD
GetGroupStatus(
              DWORD status,
              int flag
              )
{

   DWORD NewStatus;

   switch ( flag ) {
      case STATUS_GROUP_RECORD:
         if (status & SCE_GROUP_STATUS_NC_MEMBERS) {

            NewStatus = SCE_STATUS_NOT_CONFIGURED;

         } else if ( (status & SCE_GROUP_STATUS_MEMBERS_MISMATCH) ||
                     (status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH)) {

            NewStatus = SCE_STATUS_MISMATCH;

         } else if (status & SCE_GROUP_STATUS_NOT_ANALYZED) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;

         } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {

            NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;

         } else {
            NewStatus = SCE_STATUS_GOOD;
         }
         break;

      case STATUS_GROUP_MEMBERS:

         if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;  //do not display any status;

         } else {
            if ( status & SCE_GROUP_STATUS_NC_MEMBERS ) {

               NewStatus = SCE_STATUS_NOT_CONFIGURED;

            } else if ( status & SCE_GROUP_STATUS_MEMBERS_MISMATCH ) {
               NewStatus = SCE_STATUS_MISMATCH;
            } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {
                NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;

            } else {
               NewStatus = SCE_STATUS_GOOD;
            }
         }
         break;

      case STATUS_GROUP_MEMBEROF:

         if ( status & SCE_GROUP_STATUS_NOT_ANALYZED ) {

            NewStatus = SCE_STATUS_NOT_ANALYZED;  // do not display any status;

         } else {
            if ( status & SCE_GROUP_STATUS_NC_MEMBEROF ) {

               NewStatus = SCE_STATUS_NOT_CONFIGURED;

            } else if ( status & SCE_GROUP_STATUS_MEMBEROF_MISMATCH ) {
               NewStatus = SCE_STATUS_MISMATCH;
            } else if (status & SCE_GROUP_STATUS_ERROR_ANALYZED) {
               NewStatus = SCE_STATUS_ERROR_NOT_AVAILABLE;
            } else {
               NewStatus = SCE_STATUS_GOOD;
            }
         }
         break;
      default:
         NewStatus = 0;
         break;
   }

   return NewStatus;
}


//+--------------------------------------------------------------------------
//
//  Function: AllocGetTempFileName
//
//  Synopsis: Allocate and return a string with a temporary file name.
//
//  Returns:  The temporary file name, or 0 if a temp file can't be found
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
AllocGetTempFileName() {
   DWORD dw;
   CString strPath;
   CString strFile;
   LPTSTR szPath;
   LPTSTR szFile;

   //
   // Get a temporary directory path in strPath
   // If our buffer isn't large enough then keep reallocating until it is
   //
   dw = MAX_PATH;
   do {
      szPath = strPath.GetBuffer(dw);
      dw = GetTempPath(MAX_PATH,szPath);
      strPath.ReleaseBuffer();
   } while (dw > (DWORD)strPath.GetLength() );

   //
   // Can't get a path to the temporary directory
   //
   if (!dw) {
      return 0;
   }

   //
   // Get a temporary file in that directory
   //
   szFile = strFile.GetBuffer(dw+MAX_PATH);
   if (!GetTempFileName(szPath,L"SCE",0,szFile)) {
      return 0;
   }
   strFile.ReleaseBuffer();

   szFile = (LPTSTR)LocalAlloc(LPTR,(strFile.GetLength()+1)*sizeof(TCHAR));
   if (!szFile) {
      return 0;
   }
   lstrcpy(szFile,(LPCTSTR)strFile);
   return szFile;
}

//  If the given environment variable exists as the first part of the path,
//  then the environment variable is inserted into the output buffer.
//
//  Returns TRUE if pszResult is filled in.
//
//  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SYSTEMROOT%
//            Output -- %SYSTEMROOT%\SYSTEM32\FOO.TXT

BOOL UnExpandEnvironmentString(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
   TCHAR szEnvVar[MAX_PATH];
   DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)) - 1; // don't count the NULL

   if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                     szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) {
      if (lstrlen(pszPath) + dwEnvVar < cbResult) {
         lstrcpy(pszResult, pszEnvVar);
         lstrcat(pszResult, pszPath + dwEnvVar);
         return TRUE;
      }
   }
   return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Function: UnexpandEnvironmentVariables
//
//  Synopsis: Given a path, contract any leading members to use matching
//            environment variables, if any
//
//  Arguments:
//            [szPath] - The path to expand
//
//  Returns:  The newly allocated path (NULL if no changes are made)
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR
UnexpandEnvironmentVariables(LPCTSTR szPath) {
   UINT   cbNew;
   LPTSTR szNew;
   LPTSTR mszEnvVars;
   LPTSTR szEnvVar;
   DWORD  dwEnvType;
   BOOL   bExpanded;
   CString strKey;
   CString strValueName;

   CString str;

   AFX_MANAGE_STATE(AfxGetStaticModuleState());


   if (!strKey.LoadString(IDS_SECEDIT_KEY) ||
       !strValueName.LoadString(IDS_ENV_VARS_REG_VALUE)) {
      return NULL;
   }

   //
   // Allocate memory for the new path
   //
   cbNew = lstrlen(szPath)+MAX_PATH+1;
   szNew = (LPTSTR) LocalAlloc(LPTR,cbNew * sizeof(TCHAR));
   if (!szNew) {
      return NULL;
   }


   //
   // Get Vars to expand from the registry
   //
   mszEnvVars = NULL;
   if (ERROR_SUCCESS != MyRegQueryValue(HKEY_LOCAL_MACHINE,     // hKeyRoot
                                        strKey,                 // SubKey
                                        strValueName,           // ValueName
                                        (LPVOID *)&mszEnvVars,  // Value
                                        &dwEnvType)) {          // Reg Type
      //
      // Can't get any variables to expand
      //
      LocalFree(szNew);
      return NULL;
   }

   //
   // We need a multi-sz with the variables to replace in it
   //
   if (REG_MULTI_SZ != dwEnvType || mszEnvVars == NULL) //Bug350194, Yang Gao, 3/23/2001
   {
      LocalFree(szNew);
      return NULL;
   }

   bExpanded = FALSE;

   //
   // Start at the beginning of the multi-sz block
   //
   szEnvVar = mszEnvVars;
   while (*szEnvVar) {
      if (UnExpandEnvironmentString(szPath,szEnvVar,szNew,cbNew)) {
         //
         // We can only unexpand (successfully) once
         //
         bExpanded = TRUE;
         break;
      }
      //
      // Advance szEnvVar to the end of this string
      //
      while (*szEnvVar) {
         szEnvVar++;
      }
      //
      // And the beginning of the next
      //
      szEnvVar++;
   }


   if (mszEnvVars) {
      LocalFree(mszEnvVars);
   }

   if (!bExpanded) {
      LocalFree(szNew);
      szNew = NULL;
   }


   return szNew;
}



//+--------------------------------------------------------------------------
//
//  Function: IsSystemDatabase
//
//  Synopsis: Determine if a specific databse is the system database or a private one
//
//  Arguments:
//            [szDBPath] - The database path to check
//
//  Returns:  True if szDBPath is the system database, false otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL
IsSystemDatabase(LPCTSTR szDBPath) {
   CString szSysDB;
   BOOL bIsSysDB;
   DWORD rc;
   DWORD RegType;

   if (!szDBPath) {
      return FALSE;
   }

   //Raid bug 261450, Yang Gao, 3/30/2001
   if (FAILED(GetSystemDatabase(&szSysDB))) {
      return FALSE;
   }

   //
   // We found an appropriate szSysDB, so compare it with szDBPath
   //
   if (lstrcmp(szDBPath,szSysDB) == 0) {
      bIsSysDB = TRUE;
   } else {
      bIsSysDB = FALSE;
   }

   return bIsSysDB;
}

//+--------------------------------------------------------------------------
//
//  Function: GetSystemDatabase
//
//  Synopsis: Get the name of the current system database
//
//  Arguments:
//            [szDBPath] - [in/out] a pointer for the name of the system database
//                               The caller is responsible for freeing it.
//
//
//  Returns:  S_OK if the system database is found, otherwise an error
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT
GetSystemDatabase(CString *szDBPath) 
{
   if (!szDBPath) 
   {
      return E_INVALIDARG;
   }

   //Raid bug 261450, Yang Gao, 3/30/2001
   CString sAppend;
   sAppend.LoadString( IDS_DB_DEFAULT );

   PWSTR pszPath = (LPTSTR)LocalAlloc( 0, (MAX_PATH +  sAppend.GetLength() + 1) * sizeof(WCHAR));
   if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_WINDOWS, NULL, 0, pszPath)))
   {
      wcscpy( &(pszPath[lstrlen(pszPath)]), sAppend );
      *szDBPath = pszPath;
      if (pszPath)
      {
         LocalFree(pszPath);
         pszPath = NULL;
      }
      return S_OK;
   }

   if (pszPath) 
   {
      LocalFree(pszPath);
      pszPath = NULL;
   }
   return E_FAIL;
}


//+--------------------------------------------------------------------------
//
//  Function: ObjectStatusToString
//
//  Synopsis: Convert an object status value to a printable string
//
//  Arguments:
//            [status] - [in]  The status value to convert
//            [str]    - [out] The string to store the value in
//
//
//---------------------------------------------------------------------------
UINT
ObjectStatusToString(DWORD status, CString *strStatus) {
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   if ( status & SCE_STATUS_PERMISSION_MISMATCH ) {
      status = IDS_MISMATCH;
   } else if (status & SCE_STATUS_AUDIT_MISMATCH) {
      status = IDS_MISMATCH;
   } else {
      status &= 0x0F;
      switch(status){
      case SCE_STATUS_NOT_ANALYZED:
         status = IDS_NOT_ANALYZED;
         break;
      case SCE_STATUS_GOOD:
         status = IDS_OK ;
         break;
      case SCE_STATUS_MISMATCH:
         status = IDS_MISMATCH;
         break;
      case SCE_STATUS_NOT_CONFIGURED:
         //
         // BUG 119215: The Analysis UI should never show "Not Defined"
         //             for the security of existing system objects
         //
         status = IDS_NOT_ANALYZED;
         break;
      case SCE_STATUS_CHILDREN_CONFIGURED:
         status = IDS_CHILDREN_CONFIGURED;
         break;
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
         status = IDS_NOT_AVAILABLE;
         break;
      case SCE_STATUS_NEW_SERVICE:
         status = IDS_NEW_SERVICE;
         break;
      default:
         //
         // We shouldn't get here, but for some reason we keep doing so
         //
         status = IDS_MISMATCH;
         break;
      }
   }

   if(strStatus){
      strStatus->LoadString(status);
   }
   return status;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsSecurityTemplate
//
//  Synopsis:   Validates a file to see if the file is a security template.
//
//  Arguments:  [pszFileName]   - The full path to the file to check.
//
//  Returns:    FALSE if the file does not exist or is not a valid
//                              security template.
//
//                              TRUE if successful.
//  History:
//
//---------------------------------------------------------------------------
BOOL
IsSecurityTemplate(
        LPCTSTR pszFileName
        )
{
        if(!pszFileName){
                return FALSE;
        }

        HANDLE hProfile;
        SCESTATUS rc;

        //
        // Open the profile.
        //
        rc = SceOpenProfile(
                                        pszFileName,
                                        SCE_INF_FORMAT,
                                        &hProfile
                                        );
        if(rc == SCESTATUS_SUCCESS && hProfile){

                PSCE_PROFILE_INFO ProfileInfo = NULL;
                PSCE_ERROR_LOG_INFO ErrBuf    = NULL;

                //
                // The profile will be validated by trying to load all the security areas.
                //
                rc = SceGetSecurityProfileInfo(hProfile,
                              SCE_ENGINE_SCP,
                              AREA_ALL,
                              &ProfileInfo,
                                      &ErrBuf);
                if(ErrBuf){
                        rc = SCESTATUS_INVALID_DATA;
                }

                //
                // Free up the memory.
                //
                SceFreeMemory((PVOID)ErrBuf, SCE_STRUCT_ERROR_LOG_INFO);
        ErrBuf = NULL;

        if ( ProfileInfo != NULL ) {
            SceFreeMemory((PVOID)ProfileInfo, AREA_ALL);
            LocalFree(ProfileInfo);
        }
        SceCloseProfile(&hProfile);

                //
                // return TRUE if everything is successful.
                //
                if(rc != SCESTATUS_INVALID_DATA){
                        return TRUE;
                }

        }

        return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Function:   WriteSprintf
//
//  Synopsis:   Writes formated [pszStr] to [pStm].
//
//  Arguments:  [pStm]      - Stream to write to.
//              [pszStr]    - Format string to write.
//              [...]       - printf formating
//
//  Returns:    The total number of bytes written.
//
//  History:
//
//---------------------------------------------------------------------------
int WriteSprintf( IStream *pStm, LPCTSTR pszStr, ...)
{
    TCHAR szWrite[512];
    va_list marker;
    va_start(marker, pszStr);

    vswprintf(szWrite, pszStr, marker);
    va_end(marker);

    ULONG nBytesWritten;
    int iLen = lstrlen(szWrite);

    if(pStm){
        pStm->Write( szWrite, iLen * sizeof(TCHAR), &nBytesWritten );
        return nBytesWritten;
    }
    return iLen;
}

//+--------------------------------------------------------------------------
//
//  Function:   ReadSprintf
//
//  Synopsis:   Reads formated [pszStr] from [pStm].
//              supported character switches are
//              'd' - integer pointer.
//
//  Arguments:  [pStm]      - Stream to read from.
//              [pszStr]    - Format string to test.
//              [...]       - pointer to the types defined by format
//                              specification types.
//
//  Returns:    Total number of bytes read from the stream
//
//  History:
//
//---------------------------------------------------------------------------
int
ReadSprintf( IStream *pStm, LPCTSTR pszStr, ...)
{

    if(!pStm || !pszStr){
        return -1;
    }

    va_list marker;
    va_start(marker, pszStr);

    TCHAR szRead[256];
    TCHAR szConv[512];
    ULONG uRead = 0;

    int i = 0;
    LPCTSTR pszNext = szRead;
    int iTotalRead = 0;

    // Get the current seek position.
    ULARGE_INTEGER liBack = { 0 };
    LARGE_INTEGER liCur = { 0 };
    pStm->Seek( liCur, STREAM_SEEK_CUR, &liBack);

#define INCBUFFER(sz)\
    if(uRead){\
        (sz)++;\
        uRead--;\
    } else {\
        pStm->Read(szRead, 256 * sizeof(TCHAR), &uRead);\
        uRead = uRead/sizeof(TCHAR);\
        (sz) = szRead;\
    }\
    iTotalRead++;

    while(*pszStr){
        if(!uRead){
            // Read information into buffer.
            pStm->Read( szRead, 256 * sizeof(TCHAR), &uRead);
            pszNext = szRead;

            uRead = uRead/sizeof(TCHAR);
            if(!uRead){
                iTotalRead = -1;
                break;
            }
        }

        if(*pszStr == '%'){
            pszStr++;
            switch( *pszStr ){
            case 'd':
                // read integer.
                pszStr++;
                i = 0;

                // copy number to our own buffer.
                while( (*pszNext >= L'0' && *pszNext <= L'9') ){
                    szConv[i++] = *pszNext;
                    INCBUFFER( pszNext );
                }

                szConv[i] = 0;

                // convert string to integer.
                *(va_arg(marker, int *)) = _wtol(szConv);
                continue;
               case 's':
                pszStr++;
                i = 0;
                // we have to have some kind of terminating character se we will use the
                // next value in pszStr.
                while( *pszNext && (*pszNext != *pszStr) ){
                    szConv[i++] = *pszNext;

                    INCBUFFER( pszNext );
                }

                if(*pszNext == *pszStr){
                    INCBUFFER( pszNext );
                }

                // copy the string value.
                szConv[i] = 0;
                if( i ){
                    LPTSTR pNew = (LPTSTR)LocalAlloc(0, sizeof(TCHAR) * (i + 1));
                    if(NULL != pNew){
                        lstrcpy(pNew, szConv);
                    }

                    LPTSTR *pArg;
                    pArg = (va_arg(marker, LPTSTR *));
                    if (pArg) {
                       *pArg = pNew;
                    }
                } else {
                    va_arg(marker, LPTSTR *);
                }
                pszStr++;
                continue;
            }
        }
        // check to make sure we are at the correct position in the file.
        if(*pszStr != *pszNext){
            iTotalRead = -1;
            break;
        }
        pszStr++;

        // increment buffer pointer.
        INCBUFFER( pszNext );
    }

    va_end(marker);

    // Reset streem seek pointer.
    liCur.LowPart  = liBack.LowPart;
    if(iTotalRead >= 0){
        liCur.LowPart += iTotalRead * sizeof(TCHAR);
    }
    liCur.HighPart = liBack.HighPart;
    pStm->Seek(liCur, STREAM_SEEK_SET, NULL);

    return iTotalRead;
#undef INCBUFFER
}


//+--------------------------------------------------------------------------------
// FileCreateError
//
// This function tries to create a new file use [pszFile].  It will display a
// message to the user if the file cannot be created.
//
// Arguments:  [pszFile]   - Full path of file to create.
//             [dwFlags]   - Flags
//                           FCE_IGNORE_FILEEXISTS - Ignore File exists error, and
//                                                   delete the file.
//
// Returns:    IDYES the file can be created
//             IDNo  The file cannot be created
DWORD
FileCreateError(
   LPCTSTR pszFile,
   DWORD dwFlags
   )
{
   if(!pszFile){
      return ERROR_INVALID_PARAMETER;
   }
   HANDLE hFile;
   DWORD dwErr = IDNO;
   //
   // Try to create the file.
   //
   hFile = ExpandAndCreateFile(
                            pszFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_ARCHIVE,
                            NULL
                            );
   if(hFile == INVALID_HANDLE_VALUE){
      //
      // Post error message to user.
      //
      dwErr = GetLastError();
      LPTSTR pszErr;
      CString strErr;

      FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER |
         FORMAT_MESSAGE_FROM_SYSTEM,
         NULL,
         dwErr,
         0,
         (LPTSTR)&pszErr,
         0,
         NULL
         );

      strErr = pszErr;
      strErr += pszFile;

      if(pszErr){
         LocalFree(pszErr);
      }

      switch(dwErr){
      case ERROR_ALREADY_EXISTS:
      case ERROR_FILE_EXISTS:
         if( dwFlags & FCE_IGNORE_FILEEXISTS ){
            dwErr = IDYES;
            break;
         }
         //
         // Confirm overwrite.
         //
         strErr.Format(IDS_FILE_EXISTS_FMT, pszFile);
         dwErr = AfxMessageBox(
                  strErr,
                  MB_YESNO
                  );
         break;
      default:
         //
         // The file cannot be created.
         //
         AfxMessageBox(
                  strErr,
                  MB_OK
                  );
         dwErr = IDNO;
         break;
      }

   } else {
      //
      // It's OK to create the file.
      //
      ::CloseHandle( hFile );
      DeleteFile(pszFile);

      dwErr = IDYES;
   }

   return dwErr;
}


//+--------------------------------------------------------------------------
//
//  Function:  IsDBCSPath
//
//  Synopsis:  Check if a path contains DBCS characters
//
//  Arguments: [pszFile] - [in]  The path to check
//
//  Returns:   TRUE if pszFile contains characters that can't be
//                  represented by a LPSTR
//
//             FALSE if pszFile only contains characters that can
//                   be represented by a LPSTR
//
//
//+--------------------------------------------------------------------------
BOOL
IsDBCSPath(LPCTSTR szWideFile) {
   while(*szWideFile) {
      if (*szWideFile >= 256) {
         return TRUE;
      }
      szWideFile++;
   }
   return FALSE;

/*
   LPSTR szMBFile;
   int nMBFile;
   BOOL bUsedDefaultChar = FALSE;

   nMBFile = sizeof(LPSTR)*(lstrlen(szWideFile));
   szMBFile = (LPSTR)LocalAlloc(LPTR,nMBFile+1);

   if (szMBFile) {
      WideCharToMultiByte( CP_ACP,
                           0,
                           szWideFile,
                           -1,
                           szMBFile,
                           nMBFile,
                           NULL,
                           &bUsedDefaultChar);

      LocalFree(szMBFile);
   }

   return bUsedDefaultChar;
*/
}

//+--------------------------------------------------------------------------
//
//  Function:  GetSeceditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetSeceditHelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH);
       helpFileName.ReleaseBuffer ();

       helpFileName += L"\\help\\wsecedit.hlp";
   }

   return helpFileName;
}

//+--------------------------------------------------------------------------
//
//  Function:  GetGpeditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetGpeditHelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH);
       helpFileName.ReleaseBuffer ();

       helpFileName += L"\\help\\gpedit.hlp";
   }

   return helpFileName;
}
//+--------------------------------------------------------------------------
//
//  Function:  ExpandEnvironmentStringWrapper
//
//  Synopsis:  Takes an LPTSTR and expands the enviroment variables in it
//
//  Arguments: Pointer to the string to expand.
//
//  Returns:   a CString containing the fully expanded string.
//
//+--------------------------------------------------------------------------
CString ExpandEnvironmentStringWrapper(LPCTSTR psz)
{
    LPTSTR  pszBuffer = NULL;
    DWORD   dwExpanded = 0;
    CString sz;

    dwExpanded = ExpandEnvironmentStrings(psz, NULL, 0);

    pszBuffer = sz.GetBuffer(dwExpanded);
    ExpandEnvironmentStrings(psz, pszBuffer, dwExpanded);
    sz.ReleaseBuffer(dwExpanded);

    return (sz);
}

//+--------------------------------------------------------------------------
//
//  Function:  ExpandAndCreateFile
//
//  Synopsis:  Just does a normal CreateFile(), but expands the filename before
//             creating the file.
//
//  Arguments: Same as CreateFile().
//
//  Returns:   HANDLE to the created file.
//
//+--------------------------------------------------------------------------
HANDLE WINAPI ExpandAndCreateFile (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HANDLE  hRet = INVALID_HANDLE_VALUE;
    CString sz;

    sz = ExpandEnvironmentStringWrapper(lpFileName);

    return (CreateFile(
                sz,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile));
}

   //**********************************************************************
   //
   //  FUNCTION:     IsAdmin - This function checks the token of the
   //                calling thread to see if the caller belongs to
   //                the Administrators group.
   //
   //  PARAMETERS:   none
   //
   //  RETURN VALUE: TRUE if the caller is an administrator on the local
   //                machine.  Otherwise, FALSE.
   //
   //**********************************************************************

   BOOL IsAdmin(void) {

      HANDLE        hAccessToken = NULL;
      PTOKEN_GROUPS ptgGroups    = NULL;
      DWORD         cbGroups     = 0;
      PSID          psidAdmin    = NULL;
      UINT          i;

      SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

      // assume the caller is not an administrator
      BOOL bIsAdmin = FALSE;

      __try {

         if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
               &hAccessToken)) {

            if (GetLastError() != ERROR_NO_TOKEN)
               __leave;

            // retry against process token if no thread token exists
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
                  &hAccessToken))
               __leave;
         }

         // determine required size of buffer for token information
         if (GetTokenInformation(hAccessToken, TokenGroups, NULL, 0,
               &cbGroups)) {

            // call should have failed due to zero-length buffer
            __leave;

         } else {

            // call should have failed due to zero-length buffer
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
               __leave;
         }

         // allocate a buffer to hold the token groups
         ptgGroups = (PTOKEN_GROUPS) HeapAlloc(GetProcessHeap(), 0,
            cbGroups);
         if (!ptgGroups)
            __leave;

         // call GetTokenInformation() again to actually retrieve the groups
         if (!GetTokenInformation(hAccessToken, TokenGroups, ptgGroups,
               cbGroups, &cbGroups))
            __leave;

         // create a SID for the local administrators group
         if (!AllocateAndInitializeSid(&siaNtAuthority, 2,
               SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0, &psidAdmin))
            __leave;

         // scan the token's groups and compare the SIDs to the admin SID
         for (i = 0; i < ptgGroups->GroupCount; i++) {
            if (EqualSid(psidAdmin, ptgGroups->Groups[i].Sid)) {
               bIsAdmin = TRUE;
               break;
            }
         }

      } __finally {

         // free resources
         if (hAccessToken)
            CloseHandle(hAccessToken);

         if (ptgGroups)
            HeapFree(GetProcessHeap(), 0, ptgGroups);

         if (psidAdmin)
            FreeSid(psidAdmin);
      }

      return bIsAdmin;
   }



//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToSZ
//
//  Synopsis:  Converts a multiline string to a comma delimited normal string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR MultiSZToSZ(PCWSTR sz)
{
   PWSTR szOut = NULL;

   ASSERT(sz);
   if (!sz)
   {
      return NULL;
   }
   //Bug 349000, Yang Gao, 3/23/2001 
   long i = 0;
   long j = 0;
   while( L'\0' != sz[i] )
   {
      if( L',' == sz[i] )
         j++;
      i++;
   }

   szOut = (PWSTR) LocalAlloc(LPTR,(lstrlen(sz)+j*2+1)*sizeof(wchar_t)); //Raid #376228, 4/25/2001
   if (!szOut)
   {
      return NULL;
   }

   for(i=0,j=0; sz[i] != L'\0'; i++)
   {
      if( L'\n' == sz[i] )
      {
         szOut[j++] = MULTISZ_DELIMITER;
         continue;
      } 
      
      if( L'\r' == sz[i] ) 
      {
         continue;   // ignore it
      } 
      
      if( L',' == sz[i] )
      {
         szOut[j++] = MULTISZ_QUOTE;
         szOut[j++] = sz[i];
         szOut[j++] = MULTISZ_QUOTE;
         continue;
      }

      szOut[j++] = sz[i];
   }

   return szOut;
}

//+--------------------------------------------------------------------------
//
//  Function:  SZToMultiSZ
//
//  Synopsis:  Converts a comma delimited string to a multiline string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR SZToMultiSZ(PCWSTR sz) 
{
   PWSTR szOut = NULL;

   ASSERT(sz);
   if (!sz)
   {
      return NULL;
   }
   //
   // Calculate the length of the expanded string
   //
   int cSZ = 0;
   for (int i = 0;sz[i] != L'\0'; i++)
   {
      if (MULTISZ_DELIMITER == sz[i])
      {
         //
         // Delimiter expands into an extra character so count it twice
         //
         cSZ++;
      }
      cSZ++;
   }

   szOut = (PWSTR) LocalAlloc(LPTR,(cSZ+1)*sizeof(wchar_t));
   if (!szOut)
   {
      return NULL;
   }

   BOOL qflag = FALSE;
   for(int i=0, c=0; sz[i] != L'\0'; i++)
   {
      //Bug 349000, Yang Gao, 3/23/2001
      if( MULTISZ_QUOTE == sz[i] && MULTISZ_DELIMITER == sz[i+1] )
      {
         qflag = TRUE;
         continue;
      }
      if( MULTISZ_DELIMITER == sz[i] && MULTISZ_QUOTE == sz[i+1] && qflag )
      {
         szOut[c++] = sz[i];
         i++;
         qflag = FALSE;
         continue;
      }
      qflag = FALSE;
      if (MULTISZ_DELIMITER == sz[i])
      {
         szOut[c++] = L'\r';
         szOut[c++] = L'\n';
      }
      else
      {
         szOut[c++] = sz[i];
      }
   }

   return szOut;
}

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToDisp
//
//  Synopsis:  Converts a comma delimited multiline string to a display string
//
//  Returns:   The converted string
//  Bug 349000, Yang Gao, 3/23/2001
//+--------------------------------------------------------------------------
void MultiSZToDisp(PCWSTR sz, CString &pszOut)
{

   ASSERT(sz);
   if (!sz)
   {
      return;
   }
   //
   // Calculate the length of the expanded string
   //
   int cSZ = 0;
   for (int i = 0;sz[i] != L'\0'; i++)
   {
      if (MULTISZ_DELIMITER == sz[i])
      {
         //
         // Delimiter expands into an extra character so count it twice
         //
         cSZ++;
      }
      cSZ++;
   }

   PWSTR szOut;
   szOut = (PWSTR) LocalAlloc(LPTR,(cSZ+1)*sizeof(wchar_t));
   if (!szOut)
   {
      return;
   }

   BOOL qflag = FALSE;
   for(int i=0, c=0; sz[i] != L'\0'; i++)
   {
      if( MULTISZ_QUOTE == sz[i] && MULTISZ_DELIMITER == sz[i+1] )
      {
         qflag = TRUE;
         continue;
      }
      if( MULTISZ_DELIMITER == sz[i] && MULTISZ_QUOTE == sz[i+1] && qflag )
      {
         szOut[c++] = sz[i];
         i++;
         qflag = FALSE;
         continue;
      }
      qflag = FALSE;
      szOut[c++] = sz[i];
   }

   pszOut = szOut;
   LocalFree(szOut);
   
   return;
}

SCE_PROFILE_INFO *g_pDefaultTemplate = NULL;

SCE_PROFILE_INFO *
GetDefaultTemplate() {
   SCE_PROFILE_INFO *pspi = NULL;
   DWORD RegType = 0;
   SCESTATUS rc = 0;
   LPTSTR szInfFile = NULL;
   PVOID pHandle = NULL;

   if (g_pDefaultTemplate) {
      return g_pDefaultTemplate;
   }

   rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                   SCE_REGISTRY_KEY,
                   SCE_REGISTRY_DEFAULT_TEMPLATE,
                   (PVOID *)&szInfFile,
                   &RegType );

   if (ERROR_SUCCESS != rc) {
      if (szInfFile) {
         LocalFree(szInfFile);
         szInfFile = NULL;
      }
      return NULL;
   }
   if (EngineOpenProfile(szInfFile,OPEN_PROFILE_CONFIGURE,&pHandle) != SCESTATUS_SUCCESS) {
      LocalFree(szInfFile);
      szInfFile = NULL;
      return NULL;
   }
   LocalFree(szInfFile);
   szInfFile = NULL;
   rc = SceGetSecurityProfileInfo(pHandle,
                                  SCE_ENGINE_SCP,
                                  AREA_ALL,
                                  &pspi,
                                  NULL
                                 );

   SceCloseProfile(&pHandle);
   if (SCESTATUS_SUCCESS != rc) {
      //
      // expand registry value section based on registry values list on local machine
      //

      SceRegEnumAllValues(
                         &(pspi->RegValueCount),
                         &(pspi->aRegValues)
                         );


#define PD(X,Y) if (pspi->X == SCE_NO_VALUE) { pspi->X = Y; }
      PD(MaximumPasswordAge,MAX_PASS_AGE_DEFAULT)
      PD(MinimumPasswordAge,MIN_PASS_AGE_DEFAULT)
      PD(MinimumPasswordLength,MIN_PASS_LENGTH_DEFAULT)
      PD(PasswordHistorySize,PASS_HISTORY_SIZE_DEFAULT)
      PD(PasswordComplexity,PASS_COMPLEXITY_DEFAULT)
      PD(RequireLogonToChangePassword,REQUIRE_LOGIN_DEFAULT)
      PD(LockoutBadCount,LOCKOUT_BAD_COUNT_DEFAULT)
      PD(ResetLockoutCount,RESET_LOCKOUT_COUNT_DEFAULT)
      PD(LockoutDuration,LOCKOUT_DURATION_DEFAULT)
      PD(AuditSystemEvents,AUDIT_SYSTEM_EVENTS_DEFAULT)
      PD(AuditLogonEvents,AUDIT_LOGON_EVENTS_DEFAULT)
      PD(AuditObjectAccess,AUDIT_OBJECT_ACCESS_DEFAULT)
      PD(AuditPrivilegeUse,AUDIT_PRIVILEGE_USE_DEFAULT)
      PD(AuditPolicyChange,AUDIT_POLICY_CHANGE_DEFAULT)
      PD(AuditAccountManage,AUDIT_ACCOUNT_MANAGE_DEFAULT)
      PD(AuditProcessTracking,AUDIT_PROCESS_TRACKING_DEFAULT)
      PD(AuditDSAccess,AUDIT_DS_ACCESS_DEFAULT)
      PD(AuditAccountLogon,AUDIT_ACCOUNT_LOGON_DEFAULT)
      PD(ForceLogoffWhenHourExpire,FORCE_LOGOFF_DEFAULT)
      PD(EnableAdminAccount,ENABLE_ADMIN_DEFAULT)
      PD(EnableGuestAccount,ENABLE_GUEST_DEFAULT)
      PD(LSAAnonymousNameLookup,LSA_ANON_LOOKUP_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_SYSTEM],SYS_MAX_LOG_SIZE_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_APP],APP_MAX_LOG_SIZE_DEFAULT)
      PD(MaximumLogSize[EVENT_TYPE_SECURITY],SEC_MAX_LOG_SIZE_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_SYSTEM],SYS_LOG_RETENTION_PERIOD_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_APP],APP_LOG_RETENTION_PERIOD_DEFAULT)
      PD(AuditLogRetentionPeriod[EVENT_TYPE_SECURITY],SEC_LOG_RETENTION_PERIOD_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_APP],APP_LOG_RETENTION_DAYS_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_SYSTEM],SYS_LOG_RETENTION_DAYS_DEFAULT)
      PD(RetentionDays[EVENT_TYPE_SECURITY],SEC_LOG_RETENTION_DAYS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_APP],APP_RESTRICT_GUEST_ACCESS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_SYSTEM],SYS_RESTRICT_GUEST_ACCESS_DEFAULT)
      PD(RestrictGuestAccess[EVENT_TYPE_SECURITY],SEC_RESTRICT_GUEST_ACCESS_DEFAULT)

      if (pspi->pFiles.pAllNodes->Count == 0) {
         DWORD SDSize = 0;
         pspi->pFiles.pAllNodes->Count = 1;
         pspi->pFiles.pAllNodes->pObjectArray[0] =
            (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
         if (pspi->pFiles.pAllNodes->pObjectArray[0]) {
            SceSvcConvertTextToSD (
               FILE_SYSTEM_SECURITY_DEFAULT,
               &(pspi->pFiles.pAllNodes->pObjectArray[0]->pSecurityDescriptor),
               &SDSize,
               &(pspi->pFiles.pAllNodes->pObjectArray[0]->SeInfo)
               );
         }
      }

      if (pspi->pRegistryKeys.pAllNodes->Count == 0) {
         DWORD SDSize = 0;
         pspi->pRegistryKeys.pAllNodes->Count = 1;
         pspi->pRegistryKeys.pAllNodes->pObjectArray[0] =
            (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR,sizeof(SCE_OBJECT_SECURITY));
         if (pspi->pRegistryKeys.pAllNodes->pObjectArray[0]) {
            SceSvcConvertTextToSD (
               REGISTRY_SECURITY_DEFAULT,
               &(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->pSecurityDescriptor),
               &SDSize,
               &(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->SeInfo)
               );
         }
      }

      if (pspi->pServices->General.pSecurityDescriptor == NULL) {
         DWORD SDSize = 0;
         SceSvcConvertTextToSD (
               SERVICE_SECURITY_DEFAULT,
               &(pspi->pServices->General.pSecurityDescriptor),
               &SDSize,
               &(pspi->pServices->SeInfo)
               );
      }
   }
   g_pDefaultTemplate = pspi;
   return pspi;
}


HRESULT
GetDefaultFileSecurity(PSECURITY_DESCRIPTOR *ppSD,
                       SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pFiles.pAllNodes) {
      return E_FAIL;
   }
   if (pspi->pFiles.pAllNodes->Count == 0) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pFiles.pAllNodes->pObjectArray[0]->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pFiles.pAllNodes->pObjectArray[0]->pSecurityDescriptor,
                             ppSD);
}

HRESULT
GetDefaultRegKeySecurity(PSECURITY_DESCRIPTOR *ppSD,
                         SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pRegistryKeys.pAllNodes) {
      return E_FAIL;
   }
   if (pspi->pRegistryKeys.pAllNodes->Count == 0) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pRegistryKeys.pAllNodes->pObjectArray[0]->pSecurityDescriptor,
                             ppSD);
}

HRESULT
GetDefaultServiceSecurity(PSECURITY_DESCRIPTOR *ppSD,
                          SECURITY_INFORMATION *pSeInfo) {
   SCE_PROFILE_INFO *pspi = NULL;

   ASSERT(ppSD);
   ASSERT(pSeInfo);
   if (!ppSD || !pSeInfo) {
      return E_INVALIDARG;
   }

   pspi = GetDefaultTemplate();
   *ppSD = NULL;
   *pSeInfo = 0;

   if (!pspi) {
      return E_FAIL;
   }
   if (!pspi->pServices) {
      return E_FAIL;
   }
   *pSeInfo = pspi->pServices->SeInfo;

   return MyMakeSelfRelativeSD(pspi->pServices->General.pSecurityDescriptor,
                             ppSD);
}


BOOL
GetSecureWizardName(
    OUT LPTSTR *ppstrPathName OPTIONAL,
    OUT LPTSTR *ppstrDisplayName OPTIONAL
    )
{
    BOOL b=FALSE;

    if ( ppstrPathName == NULL && ppstrDisplayName == NULL) return FALSE;

    if ( ppstrPathName )
        *ppstrPathName = NULL;

    if ( ppstrDisplayName )
        *ppstrDisplayName = NULL;


#define SCE_WIZARD_PATH     SCE_ROOT_PATH TEXT("\\Wizard")

    DWORD rc;
    DWORD RegType;
    LPVOID pValue=NULL;
    PWSTR pPathName = NULL;

    rc = MyRegQueryValue(HKEY_LOCAL_MACHINE,
                         SCE_WIZARD_PATH,
                         TEXT("Path"),
                         &pValue,
                         &RegType
                        );

    if ( ERROR_SUCCESS == rc && pValue &&
         (RegType == REG_SZ ||
          RegType == REG_EXPAND_SZ) ) {


        if ( RegType == REG_EXPAND_SZ ) {
            //
            // Expand the environment variable
            //
            DWORD dSize = ExpandEnvironmentStrings((LPTSTR)pValue, NULL, 0);

            if ( dSize > 0 ) {
                pPathName = (PWSTR)LocalAlloc(LPTR, (dSize+1)*sizeof(WCHAR));

                if ( pPathName ) {

                    ExpandEnvironmentStrings((LPTSTR)pValue, pPathName, dSize);

                } else {
                    LocalFree(pValue);
                    return FALSE;
                }

            } else {

                LocalFree(pValue);
                return FALSE;
            }

        } else {

            //
            // just simply take the string
            //
            pPathName = (LPTSTR)pValue;
            pValue = NULL;
        }

        if ( ppstrDisplayName ) {
            //
            // now query the display name (menu name) from the binary
            // binary name is stored in pPathName (can't be NULL)
            //
            DWORD dwHandle=0;

            DWORD dwSize = GetFileVersionInfoSize(pPathName, &dwHandle);

            if ( dwSize > 0 ) {

                LPVOID pBuffer = (LPVOID)LocalAlloc(LPTR, dwSize+1);

                if ( pBuffer ) {
                    if ( GetFileVersionInfo(pPathName, 0, dwSize, pBuffer) ) {

                        PVOID   lpInfo = 0;
                        UINT    cch = 0;
                        CString key;
                        WCHAR   szBuffer[10];
                        CString keyBase;

                        wsprintf (szBuffer, L"%04X", GetUserDefaultLangID ());
                        wcscat (szBuffer, L"04B0");

                        keyBase = L"\\StringFileInfo\\";
                        keyBase += szBuffer;
                        keyBase += L"\\";


                        key = keyBase + L"FileDescription";
                        if ( VerQueryValue (pBuffer, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) ) {

                            *ppstrDisplayName = (PWSTR)LocalAlloc(LPTR,(cch+1)*sizeof(WCHAR));
                            if ( *ppstrDisplayName ) {
                                wcscpy(*ppstrDisplayName, (PWSTR)lpInfo);

                                b=TRUE;
                            }
                        }
                    }

                    LocalFree(pBuffer);

                }
            }
        }

        //
        // get the binary name
        //
        if ( ppstrPathName ) {
            *ppstrPathName = pPathName;
            pPathName = NULL;

            b=TRUE;
        }

    }

    if ( pPathName && (pPathName != pValue ) ) {
        LocalFree(pPathName);
    }

    if ( pValue ) {
        LocalFree(pValue);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\uithread.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       uithread.h
//
//  Contents:   definition of CUIThread
//
//----------------------------------------------------------------------------
#if !defined(AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
#define AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "attr.h"

/////////////////////////////////////////////////////////////////////////////
// CUIThread thread
#define DLG_KEY_PRIMARY(x)   ( (PtrToUlong((PVOID)(x))) & 0x00FFFFFF )
#define DLG_KEY_SECONDARY(x) ( (PtrToUlong((PVOID)(x)) << 24 ) & 0xFF000000 )
#define DLG_KEY( x, y ) (LONG_PTR)( DLG_KEY_PRIMARY( x ) | DLG_KEY_SECONDARY(y) )

class CUIThread : public CWinThread
{
   DECLARE_DYNCREATE(CUIThread)
protected:
   CUIThread();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CUIThread)
   public:
   virtual BOOL InitInstance();
   virtual int ExitInstance();
   virtual BOOL PreTranslateMessage(MSG* pMsg);
   //}}AFX_VIRTUAL

// Implementation
protected:
   virtual ~CUIThread();

   // Generated message map functions
   //{{AFX_MSG(CUIThread)
      // NOTE - the ClassWizard will add and remove member functions here.
   //}}AFX_MSG
   afx_msg void OnApplyProfile( WPARAM, LPARAM );
   afx_msg void OnAssignProfile( WPARAM, LPARAM );
   afx_msg void OnAnalyzeProfile( WPARAM, LPARAM );
   afx_msg void OnDescribeProfile( WPARAM, LPARAM );
   afx_msg void OnDescribeLocation( WPARAM, LPARAM );
   afx_msg void OnDestroyDialog(WPARAM, LPARAM);
   afx_msg void OnNewConfiguration(WPARAM, LPARAM);
   afx_msg void OnAddPropSheet(WPARAM, LPARAM);
   DECLARE_MESSAGE_MAP()

   void DefaultLogFile(CComponentDataImpl *pCDI,GWD_TYPES LogType,LPCTSTR szBase, CString& strLogFile);


private:
   CList<HWND,HWND> m_PSHwnds;
};

// this class is created for modeless dialog's thread inside MMC
class CModelessDlgUIThread : public CUIThread
{
    DECLARE_DYNCREATE(CModelessDlgUIThread)
protected:
    CModelessDlgUIThread();  // protected constructor used by dynamic creation

// Operations
public:
    virtual ~CModelessDlgUIThread();
    void WaitTillRun();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CModelessDlgUIThread)
    public:
    virtual int Run( );
    //}}AFX_VIRTUAL

    // Generated message map functions
    //{{AFX_MSG(CModelessDlgUIThread)
       // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    afx_msg void OnCreateModelessSheet(WPARAM, LPARAM);
    afx_msg void OnDestroyWindow(WPARAM, LPARAM);
    DECLARE_MESSAGE_MAP()

private:
    HANDLE  m_hReadyForMsg;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#define SCEM_APPLY_PROFILE     (WM_APP+2)
#define SCEM_ASSIGN_PROFILE    (WM_APP+3)
#define SCEM_ANALYZE_PROFILE   (WM_APP+4)
#define SCEM_DESCRIBE_PROFILE  (WM_APP+6)
#define SCEM_DESCRIBE_LOCATION (WM_APP+7)
#define SCEM_DESTROY_DIALOG    (WM_APP+8)
#define SCEM_NEW_CONFIGURATION (WM_APP+9)
#define SCEM_ADD_PROPSHEET     (WM_APP+10)
#define SCEM_DESTROY_SCOPE_DIALOG (WM_APP+11)
#define SCEM_CREATE_MODELESS_SHEET  (WM_APP+12)
#define SCEM_DESTROY_WINDOW         (WM_APP+13)
#endif // !defined(AFX_UITHREAD_H__69D140AE_B23D_11D1_AB7B_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef STDAFX_H
#define STDAFX_H

#pragma warning(push,3)

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <atlbase.h>
#include <afxdlgs.h>
#include <afxole.h>
#include <shlobj.h>
#include <tchar.h>
#include "resource.h"
//#include <xstring>
#include <list>
#include <vector>
#include <algorithm>
#include <functional>
#include <string>

#include <dsgetdc.h>
#include <sceattch.h>
#include <io.h>
#include <basetsd.h>
#include <lm.h>
#include <shlwapi.h>
#include <shlwapip.h>

using namespace std;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

/* Bug 424909, Yanggao, 6/29/2001
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>

extern"C" {

#include <wtypes.h>
#include <ntsecapi.h>
#include <secedit.h>
#include "edittemp.h"
#include <scesvc.h>
#include <compuuid.h> // UUIDS for computer management

#include "hlpids.h"
#include "hlparray.h"

#include <stdlib.h>
#include <wbemidl.h>
#include <aclapi.h>
#include <activeds.h>
#include <sddl.h>
#include <winldap.h>
#include <afxmt.h>

}
#include <comdef.h>
#include <accctrl.h>
#include <dssec.h>
#include <gpedit.h>
#include <objsel.h>
#include <aclui.h>

// for theme-enabling
#include <shfusion.h>

#include "debug.h"

#pragma warning(pop)

const long UNINITIALIZED = -1;

// This should be in secedit.h, but isn't
// is now! const SCE_FOREVER_VALUE = -1;

// Security Area types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
    ROOT,
    ANALYSIS,
    CONFIGURATION,
    LOCATIONS,
    PROFILE,
    LOCALPOL,
    AREA_POLICY,
    POLICY_ACCOUNT,
    POLICY_LOCAL,
    POLICY_EVENTLOG,
    POLICY_PASSWORD,
    POLICY_KERBEROS,
    POLICY_LOCKOUT,
    POLICY_AUDIT,
    POLICY_OTHER,
    POLICY_LOG,
    AREA_PRIVILEGE,
    AREA_GROUPS,
    AREA_SERVICE,
    AREA_REGISTRY,
    AREA_FILESTORE,
    AREA_POLICY_ANALYSIS,
    POLICY_ACCOUNT_ANALYSIS,
    POLICY_LOCAL_ANALYSIS,
    POLICY_EVENTLOG_ANALYSIS,
    POLICY_PASSWORD_ANALYSIS,
    POLICY_KERBEROS_ANALYSIS,
    POLICY_LOCKOUT_ANALYSIS,
    POLICY_AUDIT_ANALYSIS,
    POLICY_OTHER_ANALYSIS,
    POLICY_LOG_ANALYSIS,
    AREA_PRIVILEGE_ANALYSIS,
    AREA_GROUPS_ANALYSIS,
    AREA_SERVICE_ANALYSIS ,
    AREA_REGISTRY_ANALYSIS,
    AREA_FILESTORE_ANALYSIS ,
    REG_OBJECTS,
    FILE_OBJECTS,
    AREA_LOCALPOL,
    LOCALPOL_ACCOUNT,
    LOCALPOL_LOCAL,
    LOCALPOL_EVENTLOG,
    LOCALPOL_PASSWORD,
    LOCALPOL_KERBEROS,
    LOCALPOL_LOCKOUT,
    LOCALPOL_AUDIT,
    LOCALPOL_OTHER,
    LOCALPOL_LOG,
    LOCALPOL_PRIVILEGE,
    LOCALPOL_LAST,
    AREA_LAST,
    NONE = 0xFFFF
};

enum RESULT_TYPES
{
    ITEM_FIRST_POLICY = 0x8000,
    ITEM_BOOL,
    ITEM_DW,
    ITEM_SZ,
    ITEM_RET,
    ITEM_BON,
    ITEM_B2ON,
    ITEM_REGCHOICE,
    ITEM_REGFLAGS,
    ITEM_REGVALUE,

    ITEM_PROF_BOOL,
    ITEM_PROF_DW,
    ITEM_PROF_SZ,
    ITEM_PROF_RET,
    ITEM_PROF_BON,
    ITEM_PROF_B2ON,
    ITEM_PROF_REGCHOICE,
    ITEM_PROF_REGFLAGS,
    ITEM_PROF_REGVALUE,

    ITEM_LOCALPOL_BOOL,
    ITEM_LOCALPOL_DW,
    ITEM_LOCALPOL_SZ,
    ITEM_LOCALPOL_RET,
    ITEM_LOCALPOL_BON,
    ITEM_LOCALPOL_B2ON,
    ITEM_LOCALPOL_REGCHOICE,
    ITEM_LOCALPOL_REGFLAGS,
    ITEM_LOCALPOL_REGVALUE,
    ITEM_LAST_POLICY,

    ITEM_LOCALPOL_PRIVS,
    ITEM_PROF_PRIVS,
    ITEM_PRIVS,

    ITEM_GROUP,
    ITEM_GROUP_MEMBERS,
    ITEM_GROUP_MEMBEROF,
    ITEM_GROUPSTATUS,
    ITEM_PROF_GROUP,
    ITEM_PROF_GROUPSTATUS,

    ITEM_REGSD,
    ITEM_PROF_REGSD,

    ITEM_FILESD,
    ITEM_PROF_FILESD,

    ITEM_PROF_SERV,
    ITEM_ANAL_SERV,

    ITEM_OTHER = 0xFFFF
};

enum EVENT_TYPES
{
   EVENT_TYPE_SYSTEM = 0,
   EVENT_TYPE_SECURITY = 1,
   EVENT_TYPE_APP = 2,
};

enum POLICY_SETTINGS {
   AUDIT_SUCCESS = 1,
   AUDIT_FAILURE = 2,
};

enum RETENTION {
   SCE_RETAIN_AS_NEEDED = 0,
   SCE_RETAIN_BY_DAYS = 1,
   SCE_RETAIN_MANUALLY = 2,
};

enum GWD_TYPES {
   GWD_CONFIGURE_LOG = 1,
   GWD_ANALYSIS_LOG,
   GWD_OPEN_DATABASE,
   GWD_IMPORT_TEMPLATE,
   GWD_EXPORT_TEMPLATE
};

// Note - This is the offset in my image list that represents the folder
#define IMOFFSET_MISMATCH     1
#define IMOFFSET_GOOD         2
#define IMOFFSET_NOT_ANALYZED 3
#define IMOFFSET_ERROR        4

const CONFIG_LOCAL_IDX        = 0;
const MISMATCH_LOCAL_IDX      = 1;
const MATCH_LOCAL_IDX         = 2;
const CONFIG_ACCOUNT_IDX      = 5;
const MISMATCH_ACCOUNT_IDX    = 6;
const MATCH_ACCOUNT_IDX       = 7;
const CONFIG_FILE_IDX         = 10;
const MISMATCH_FILE_IDX       = 11;
const MATCH_FILE_IDX          = 12;
const FOLDER_IMAGE_IDX        = 15;
const MISMATCH_FOLDER_IDX     = 16;
const MATCH_FOLDER_IDX        = 17;
const CONFIG_GROUP_IDX        = 20;
const MISMATCH_GROUP_IDX      = 21;
const MATCH_GROUP_IDX         = 22;
const CONFIG_REG_IDX          = 25;
const MISMATCH_REG_IDX        = 26;
const MATCH_REG_IDX           = 27;
const CONFIG_SERVICE_IDX      = 30;
const MISMATCH_SERVICE_IDX    = 31;
const MATCH_SERVICE_IDX       = 32;
const CONFIG_POLICY_IDX       = 35;
const MISMATCH_POLICY_IDX     = 36;
const MATCH_POLICY_IDX        = 37;
const BLANK_IMAGE_IDX         = 45;
const SCE_OK_IDX              = 46;
const SCE_CRITICAL_IDX        = 47;
const SCE_IMAGE_IDX           = 50;
const CONFIG_FOLDER_IDX       = 51;
const TEMPLATES_IDX           = 52;
const LAST_IC_IMAGE_IDX       = 53;
const OPEN_FOLDER_IMAGE_IDX   = 54;
const LOCALSEC_POLICY_IDX     = CONFIG_ACCOUNT_IDX;
const LOCALSEC_LOCAL_IDX      = CONFIG_LOCAL_IDX;

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

// security settings (extension of GPE)
extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// security settings (extension of RSOP)
extern const CLSID CLSID_RSOPSnapin;    // In-Proc server GUID
extern const GUID cRSOPNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszRSOPNodeType; // Main NodeType GUID on string format

// SCE (standalone)
extern const CLSID CLSID_SCESnapin;    // In-Proc server GUID
extern const GUID cSCENodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszSCENodeType; // Main NodeType GUID on string format

// SAV (standalone)
extern const CLSID CLSID_SAVSnapin;    // In-Proc server GUID
extern const GUID cSAVNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszSAVNodeType; // Main NodeType GUID on string format

// Local security (standalone)
extern const CLSID CLSID_LSSnapin;     // In-Proc server GUID
extern const GUID cLSNodeType;         // Main NodeType GUID on numeric format
extern const wchar_t*  cszLSNodeType;  // Main NodeType GUID on string format

extern const CLSID CLSID_SCEAbout;
extern const CLSID CLSID_SCMAbout;
extern const CLSID CLSID_SSAbout;
extern const CLSID CLSID_LSAbout;
extern const CLSID CLSID_RSOPAbout;

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

EXTERN_C const TCHAR SNAPINS_KEY[];
EXTERN_C const TCHAR NODE_TYPES_KEY[];
EXTERN_C const TCHAR g_szExtensions[];
EXTERN_C const TCHAR g_szNameSpace[];

struct INTERNAL
{
    INTERNAL() 
    { 
       m_type = CCT_UNINITIALIZED; 
       m_cookie = -1; 
       m_foldertype = NONE; 
    };
    virtual ~INTERNAL() 
    {
    }

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    FOLDER_TYPES        m_foldertype;
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_foldertype = rhs.m_foldertype;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_cookie == m_cookie;
    }

};

typedef struct {
   LPTSTR TemplateName;
   LPTSTR ServiceName;
} SCESVCP_HANDLE, *PSCESVCP_HANDLE;

typedef struct RegChoiceList{
   LPTSTR szName;
   DWORD dwValue;
   struct RegChoiceList *pNext;
} REGCHOICE, *PREGCHOICE, REGFLAGS, *PREGFLAGS;

// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif

// For theme-enabling
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#define SCE_MODE_DOMAIN_COMPUTER_ERROR 9999999

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif // STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wmihooks.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wmihooks.h
//
//  Contents:   definition of CWMIRsop
//
//----------------------------------------------------------------------------
#ifndef WMIHOOKS_H
#define WMIHOOKS_H

using namespace std;
#define MAX_REG_VALUE_NUM 100

typedef struct _RSOP_INFO
{
    ULONG precedence;
    ULONG status;
    ULONG error;
    LPWSTR pszGPOID;
}RSOP_INFO, *PRSOP_INFO;

VOID FreeRI(PRSOP_INFO ptr);

typedef struct _WMI_SCE_PROFILE_INFO: public SCE_PROFILE_INFO
{
    PRSOP_INFO   pInfo;

    PRSOP_INFO   pRIMinimumPasswordAge;
    PRSOP_INFO   pRIMaximumPasswordAge;
    PRSOP_INFO   pRIMinimumPasswordLength;
    PRSOP_INFO   pRIPasswordComplexity;
    PRSOP_INFO   pRIPasswordHistorySize;
    PRSOP_INFO   pRILockoutBadCount;
    PRSOP_INFO   pRIResetLockoutCount;
    PRSOP_INFO   pRILockoutDuration;
    PRSOP_INFO   pRIRequireLogonToChangePassword;
    PRSOP_INFO   pRIForceLogoffWhenHourExpire;
    PRSOP_INFO   pRIEnableAdminAccount;
    PRSOP_INFO   pRIEnableGuestAccount;
    PRSOP_INFO   pRILSAAnonymousNameLookup;
    PRSOP_INFO   pRINewAdministratorName;
    PRSOP_INFO   pRINewGuestName;
    PRSOP_INFO   pRISecureSystemPartition;
    PRSOP_INFO   pRIClearTextPassword;
    //RSOPINFO for pKerberosInfo
    PRSOP_INFO   pRIMaxTicketAge;
    PRSOP_INFO   pRIMaxRenewAge;
    PRSOP_INFO   pRIMaxServiceAge;
    PRSOP_INFO   pRIMaxClockSkew;
    PRSOP_INFO   pRITicketValidateClient;
    //This is a link list. corresponding to  pInfPrivilegeAssignedTo
    //in otherinfo
    list<PRSOP_INFO> listRIInfPrivilegeAssignedTo;
    list<PRSOP_INFO> listRIGroupMemebership;
    list<PRSOP_INFO> listRIServices;
    vector<PRSOP_INFO> vecRIFiles;
    vector<PRSOP_INFO> vecRIReg;
    PRSOP_INFO   pRIAuditSystemEvents;
    PRSOP_INFO   pRIAuditLogonEvents;
    PRSOP_INFO   pRIAuditObjectAccess;
    PRSOP_INFO   pRIAuditPrivilegeUse;
    PRSOP_INFO   pRIAuditPolicyChange;
    PRSOP_INFO   pRIAuditAccountManage;
    PRSOP_INFO   pRIAuditProcessTracking;
    PRSOP_INFO   pRIAuditDSAccess;
    PRSOP_INFO   pRIAuditAccountLogon;
    PRSOP_INFO   pRICrashOnAuditFull;
    vector<PRSOP_INFO> vecRIRegValues;

    // Event Log Numeric
    PRSOP_INFO   pRIMaximumLogSize[3];
    PRSOP_INFO   pRIAuditLogRetentionPeriod[3];
    PRSOP_INFO   pRIRetentionDays[3];

    // Event Log Boolean
    PRSOP_INFO   pRIRestrictGuestAccess[3];
}WMI_SCE_PROFILE_INFO, *PWMI_SCE_PROFILE_INFO;

VOID InitWMI_SEC_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo);

VOID FreeList(list<PRSOP_INFO> * li);

VOID FreeVector(vector<PRSOP_INFO> * li);

VOID FreeWMI_SCE_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo);

class CWMIRsop
{
public:
    CWMIRsop(LPRSOPINFORMATION pRSOP):
                     m_cRegValueSize(MAX_REG_VALUE_NUM),
                     m_cFileSize(MAX_REG_VALUE_NUM),
                     m_cRegArrayCount(MAX_REG_VALUE_NUM),
                     m_pSvc(NULL),
                     m_vecAllRSOPCache(NULL),
                     m_pRSOPInformation(pRSOP)
    {};
    virtual ~CWMIRsop();

    HRESULT GetPrecedenceOneRSOPInfo(PWMI_SCE_PROFILE_INFO* ppProfileInfo);
    HRESULT GetAllRSOPInfo(vector<PWMI_SCE_PROFILE_INFO> *vecInfo);
    HRESULT GetGPOFriendlyName (LPTSTR lpGPOID, PWSTR *pGPOName);
private:
    IWbemServices *m_pSvc;
    LPRSOPINFORMATION m_pRSOPInformation;
    vector<PWMI_SCE_PROFILE_INFO> *m_vecAllRSOPCache;

    ULONG m_cRegValueSize;  //current capacity of array aRegValues
    ULONG m_cFileSize;      //current capacity of array in pFiles
    ULONG m_cRegArrayCount; //current capacity of array in pRegistryKeys

    //Connect to WMI and Get IWbemServices
    HRESULT Initialize();
    HRESULT EnumeratePrecedenceOne(IEnumWbemClassObject **ppEnum);
    HRESULT EnumerateAll(IEnumWbemClassObject **ppEnum);
    HRESULT GetNextInstance(IEnumWbemClassObject *pEnum,
                            IWbemClassObject** rsopInstance);
    HRESULT GetRSOPInfo(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo);

    HRESULT GetClass(IWbemClassObject* rsopInstance,
                     LPWSTR *ppClass);
    HRESULT AddInstance(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo,
                        PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddNumericSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddEventLogNumericSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddBooleanSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddEventLogBooleanSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddAuditSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddUserRightSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddRegValSetting(IWbemClassObject *rsopInstance,
                             PRSOP_INFO pInfo,
                             PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddRestrictedGroupSetting(IWbemClassObject *rsopInstance,
                                      PRSOP_INFO pInfo,
                                      PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddServiceSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddFileSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    HRESULT AddRegSetting(IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);

    HRESULT AddStringSetting (IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo);
    
};

#endif // WMIHOOKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wmihooks.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wmihooks.cpp
//
//  Contents:   implementation of CWMIRsop
//
//----------------------------------------------------------------------------
#include <stdafx.h>
#include <wmihooks.h>
#include "util.h"

WCHAR const QUERY_LANG[]            = L"WQL";
WCHAR const WMI_CLASS[]             = L"__CLASS";
WCHAR const RSOP_NAME_SPACE[]       = L"root\\rsop\\computer";
WCHAR const RSOP_PREC_ONE_QUERY[]   = L"select * from RSOP_SecuritySettings where precedence=1";
WCHAR const RSOP_ALL_QUERY[]        = L"select * from RSOP_SecuritySettings";
WCHAR const RSOP_STATUS[]           = L"Status";
WCHAR const RSOP_ERROR[]            = L"ErrorCode";
WCHAR const RSOP_PRECEDENCE[]       = L"precedence";
WCHAR const RSOP_GPOID[]            = L"GPOID";
WCHAR const RSOP_KEYNAME[]          = L"KeyName";
WCHAR const RSOP_SETTING[]          = L"Setting";
WCHAR const RSOP_USERRIGHT[]        = L"UserRight";
WCHAR const RSOP_ACCOUNTLIST[]      = L"AccountList";
WCHAR const RSOP_EVENTLOG_TYPE[]    = L"Type";

//String Constants for RSOP_classNames
WCHAR const RSOP_SEC_NUM[]          = TEXT("RSOP_SecuritySettingNumeric");
WCHAR const RSOP_SEC_BOOL[]         = TEXT("RSOP_SecuritySettingBoolean");
WCHAR const RSOP_SCE_STRING[]       = TEXT("RSOP_SecuritySettingString");
WCHAR const RSOP_AUDIT[]            = TEXT("RSOP_AuditPolicy");
WCHAR const RSOP_EVENT_NUM[]        = TEXT("RSOP_SecurityEventLogSettingNumeric");
WCHAR const RSOP_EVENT_BOOL[]       = TEXT("RSOP_SecurityEventLogSettingBoolean");
WCHAR const RSOP_REG_VAL[]          = TEXT("RSOP_RegistryValue");
WCHAR const RSOP_USER_RIGHT[]       = TEXT("RSOP_UserPrivilegeRight");
WCHAR const RSOP_RGROUPS[]          = TEXT("RSOP_RestrictedGroup");
WCHAR const RSOP_SERVICE[]          = TEXT("RSOP_SystemService");
WCHAR const RSOP_FILE[]             = TEXT("RSOP_File");
WCHAR const RSOP_REG[]              = TEXT("RSOP_RegistryKey");

//KeyNames
WCHAR const MIN_PASS_AGE[]          = TEXT("MinimumPasswordAge");
WCHAR const MAX_PASS_AGE[]          = TEXT("MaximumPasswordAge");
WCHAR const MIN_PASS_LEN[]          = TEXT("MinimumPasswordLength");
WCHAR const PASS_HIS_SIZE[]         = TEXT("PasswordHistorySize");
WCHAR const REQUIRE_LOGON_TO_CHANGE_PASS[] = TEXT("RequireLogonToChangePassword");
WCHAR const LOCKOUT_COUNT[]         = TEXT("LockoutBadCount");
WCHAR const RESET_LOCKOUT_COUNT[]   = TEXT("ResetLockoutCount");
WCHAR const LOCKOUT_DURATION[]      = TEXT("LockoutDuration");
WCHAR const MAX_TICKET_AGE[]        = TEXT("MaxTicketAge");
WCHAR const MAX_RENEW_AGE[]         = TEXT("MaxRenewAge");
WCHAR const MAX_SERVICE_AGE[]       = TEXT("MaxServiceAge");
WCHAR const MAX_CLOCK_SKEW[]        = TEXT("MaxClockSkew");
WCHAR const VALIDATE_CLIENT[]       = TEXT("TicketValidateClient");
WCHAR const PASS_COMPLEX[]          = TEXT("PasswordComplexity");
WCHAR const FORCE_LOGOFF[]          = TEXT("ForceLogOffWhenHourExpire");
WCHAR const ENABLE_ADMIN[]         = TEXT("EnableAdminAccount");
WCHAR const ENABLE_GUEST[]         = TEXT("EnableGuestAccount");
WCHAR const LSA_ANON_LOOKUP[]       = TEXT("LSAAnonymousNameLookup");
WCHAR const CLEAR_TEXT_PASS[]       = TEXT("ClearTextPassword");
WCHAR const AUDIT_SYSTEM_EVENTS[]   = TEXT("AuditSystemEvents");
WCHAR const AUDIT_LOGON_EVENTS[]    = TEXT("AuditLogonEvents");
WCHAR const AUDIT_OBJECT_ACCESS[]   = TEXT("AuditObjectAccess");
WCHAR const AUDIT_PRIVILEGE_USE[]   = TEXT("AuditPrivilegeUse");
WCHAR const AUDIT_POLICY_CHANGE[]   = TEXT("AuditPolicyChange");
WCHAR const AUDIT_ACCOUNT_MANAGE[]  = TEXT("AuditAccountManage");
WCHAR const AUDIT_PROCESS_TRAKING[] = TEXT("AuditProcessTracking");
WCHAR const AUDIT_DS_ACCESS[]       = TEXT("AuditDSAccess");
WCHAR const AUDIT_ACCOUNT_LOGON[]   = TEXT("AuditAccountLogon");

WCHAR const MAX_LOG_SIZE[]          = TEXT("MaximumLogSize");
WCHAR const AUDIT_LOG_RETENTION_PERIOD[] = TEXT ("AuditLogRetentionPeriod");
WCHAR const RETENTION_DAYS[]        = TEXT ("RetentionDays");
WCHAR const RESTRICT_GUEST_ACCESS[] = TEXT ("RestrictGuestAccess");
WCHAR const NEW_GUEST_NAME[]        = TEXT ("NewGuestName");
WCHAR const NEW_ADMINISTRATOR_NAME[] = TEXT ("NewAdministratorName");

VOID FreeRI(PRSOP_INFO ptr)
{
    if(ptr)
    {
        if(ptr->pszGPOID)
            LocalFree(ptr->pszGPOID);
        LocalFree(ptr);
    }
}


VOID InitWMI_SEC_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    memset(pProfileInfo,0,sizeof(SCE_PROFILE_INFO));
    pProfileInfo->MinimumPasswordAge = SCE_NO_VALUE;
    pProfileInfo->MaximumPasswordAge = SCE_NO_VALUE;
    pProfileInfo->MinimumPasswordLength = SCE_NO_VALUE;
    pProfileInfo->PasswordComplexity = SCE_NO_VALUE;
    pProfileInfo->PasswordHistorySize = SCE_NO_VALUE;
    pProfileInfo->LockoutBadCount = SCE_NO_VALUE;
    pProfileInfo->ResetLockoutCount = SCE_NO_VALUE;
    pProfileInfo->LockoutDuration = SCE_NO_VALUE;
    pProfileInfo->RequireLogonToChangePassword = SCE_NO_VALUE;
    pProfileInfo->ForceLogoffWhenHourExpire = SCE_NO_VALUE;
    pProfileInfo->NewAdministratorName = 0;
    pProfileInfo->NewGuestName = 0;
    pProfileInfo->EnableAdminAccount = SCE_NO_VALUE;
    pProfileInfo->EnableGuestAccount = SCE_NO_VALUE;
    pProfileInfo->LSAAnonymousNameLookup = SCE_NO_VALUE;
    pProfileInfo->ClearTextPassword = SCE_NO_VALUE;
    pProfileInfo->AuditDSAccess = SCE_NO_VALUE;
    pProfileInfo->AuditAccountLogon = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[0] = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[1] = SCE_NO_VALUE;
    pProfileInfo->MaximumLogSize[2] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[0] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[1] = SCE_NO_VALUE;
    pProfileInfo->AuditLogRetentionPeriod[2] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[0] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[1] = SCE_NO_VALUE;
    pProfileInfo->RetentionDays[2] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[0] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[1] = SCE_NO_VALUE;
    pProfileInfo->RestrictGuestAccess[2] = SCE_NO_VALUE;
    pProfileInfo->AuditSystemEvents = SCE_NO_VALUE;
    pProfileInfo->AuditLogonEvents = SCE_NO_VALUE;
    pProfileInfo->AuditObjectAccess = SCE_NO_VALUE;
    pProfileInfo->AuditPrivilegeUse = SCE_NO_VALUE;
    pProfileInfo->AuditPolicyChange = SCE_NO_VALUE;
    pProfileInfo->AuditAccountManage = SCE_NO_VALUE;
    pProfileInfo->AuditProcessTracking = SCE_NO_VALUE;

    pProfileInfo->pInfo=NULL;
    pProfileInfo->pRIMinimumPasswordAge=NULL;
    pProfileInfo->pRIMaximumPasswordAge=NULL;
    pProfileInfo->pRIMinimumPasswordLength=NULL;
    pProfileInfo->pRIPasswordComplexity=NULL;
    pProfileInfo->pRIPasswordHistorySize=NULL;
    pProfileInfo->pRILockoutBadCount=NULL;
    pProfileInfo->pRIResetLockoutCount=NULL;
    pProfileInfo->pRILockoutDuration=NULL;
    pProfileInfo->pRIRequireLogonToChangePassword=NULL;
    pProfileInfo->pRIForceLogoffWhenHourExpire=NULL;
    pProfileInfo->pRIEnableAdminAccount=NULL;
    pProfileInfo->pRIEnableGuestAccount=NULL;
    pProfileInfo->pRILSAAnonymousNameLookup=NULL;
    pProfileInfo->pRINewAdministratorName=NULL;
    pProfileInfo->pRINewGuestName=NULL;
    pProfileInfo->pRIClearTextPassword=NULL;
    pProfileInfo->pRIMaxTicketAge=NULL;
    pProfileInfo->pRIMaxRenewAge=NULL;
    pProfileInfo->pRIMaxServiceAge=NULL;
    pProfileInfo->pRIMaxClockSkew=NULL;
    pProfileInfo->pRITicketValidateClient=NULL;
    pProfileInfo->pRIAuditSystemEvents=NULL;
    pProfileInfo->pRIAuditLogonEvents=NULL;
    pProfileInfo->pRIAuditObjectAccess=NULL;
    pProfileInfo->pRIAuditPrivilegeUse=NULL;
    pProfileInfo->pRIAuditPolicyChange=NULL;
    pProfileInfo->pRIAuditAccountManage=NULL;
    pProfileInfo->pRIAuditProcessTracking=NULL;
    pProfileInfo->pRIAuditDSAccess=NULL;
    pProfileInfo->pRIAuditAccountLogon=NULL;
    pProfileInfo->pRIMaximumLogSize[0]=NULL;
    pProfileInfo->pRIMaximumLogSize[1]=NULL;
    pProfileInfo->pRIMaximumLogSize[2]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[0]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[1]=NULL;
    pProfileInfo->pRIAuditLogRetentionPeriod[2]=NULL;
    pProfileInfo->pRIRetentionDays[0]=NULL;
    pProfileInfo->pRIRetentionDays[1]=NULL;
    pProfileInfo->pRIRetentionDays[2]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[0]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[1]=NULL;
    pProfileInfo->pRIRestrictGuestAccess[2]=NULL;
}

VOID FreeList(list<PRSOP_INFO> * li)
{
    for(list<PRSOP_INFO>::iterator i = li->begin();
                                               i != li->end();
                                               ++i )
    {
        FreeRI(*i);
    }
    li->erase(li->begin(),li->end());
}

VOID FreeVector(vector<PRSOP_INFO> * li)
{
    for(vector<PRSOP_INFO>::iterator i = li->begin();
                                               i != li->end();
                                               ++i )
    {
        FreeRI(*i);
    }
    li->erase(li->begin(),li->end());
}

VOID FreeWMI_SCE_PROFILE_INFO(PWMI_SCE_PROFILE_INFO pProfileInfo)
{
   if (!pProfileInfo) {
      return;
   }
    //TODO
    //Use the code to Free SCE_PROFILE_INFO
    FreeRI(pProfileInfo->pInfo);
    FreeRI(pProfileInfo->pRIMinimumPasswordAge);
    FreeRI(pProfileInfo->pRIMaximumPasswordAge);
    FreeRI(pProfileInfo->pRIMinimumPasswordLength);
    FreeRI(pProfileInfo->pRIPasswordComplexity);
    FreeRI(pProfileInfo->pRIPasswordHistorySize);
    FreeRI(pProfileInfo->pRILockoutBadCount);
    FreeRI(pProfileInfo->pRIResetLockoutCount);
    FreeRI(pProfileInfo->pRILockoutDuration);
    FreeRI(pProfileInfo->pRIRequireLogonToChangePassword);
    FreeRI(pProfileInfo->pRIForceLogoffWhenHourExpire);
    FreeRI(pProfileInfo->pRIEnableAdminAccount);
    FreeRI(pProfileInfo->pRIEnableGuestAccount);
    FreeRI(pProfileInfo->pRILSAAnonymousNameLookup);
    FreeRI(pProfileInfo->pRINewAdministratorName);
    FreeRI(pProfileInfo->pRINewGuestName);
    FreeRI(pProfileInfo->pRIClearTextPassword);
    FreeRI(pProfileInfo->pRIMaxTicketAge);
    FreeRI(pProfileInfo->pRIMaxRenewAge);
    FreeRI(pProfileInfo->pRIMaxServiceAge);
    FreeRI(pProfileInfo->pRIMaxClockSkew);
    FreeRI(pProfileInfo->pRITicketValidateClient);
    FreeRI(pProfileInfo->pRIAuditSystemEvents);
    FreeRI(pProfileInfo->pRIAuditLogonEvents);
    FreeRI(pProfileInfo->pRIAuditObjectAccess);
    FreeRI(pProfileInfo->pRIAuditPrivilegeUse);
    FreeRI(pProfileInfo->pRIAuditPolicyChange);
    FreeRI(pProfileInfo->pRIAuditAccountManage);
    FreeRI(pProfileInfo->pRIAuditProcessTracking);
    FreeRI(pProfileInfo->pRIAuditDSAccess);
    FreeRI(pProfileInfo->pRIAuditAccountLogon);
    FreeRI(pProfileInfo->pRIMaximumLogSize[0]);
    FreeRI(pProfileInfo->pRIMaximumLogSize[1]);
    FreeRI(pProfileInfo->pRIMaximumLogSize[2]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[0]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[1]);
    FreeRI(pProfileInfo->pRIAuditLogRetentionPeriod[2]);
    FreeRI(pProfileInfo->pRIRetentionDays[0]);
    FreeRI(pProfileInfo->pRIRetentionDays[1]);
    FreeRI(pProfileInfo->pRIRetentionDays[2]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[0]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[1]);
    FreeRI(pProfileInfo->pRIRestrictGuestAccess[2]);

    FreeList(&(pProfileInfo->listRIInfPrivilegeAssignedTo));
    FreeList(&(pProfileInfo->listRIGroupMemebership));
    FreeList(&(pProfileInfo->listRIServices));
    FreeVector(&(pProfileInfo->vecRIFiles));
    FreeVector(&(pProfileInfo->vecRIReg));

    SceFreeProfileMemory(pProfileInfo);
}

CWMIRsop::~CWMIRsop() {
   if (m_vecAllRSOPCache) {
      for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = m_vecAllRSOPCache->begin();
                                                  i != m_vecAllRSOPCache->end();
                                                  ++i )
      {
         PWMI_SCE_PROFILE_INFO pProfileInfo = *i;
         FreeWMI_SCE_PROFILE_INFO(pProfileInfo);
      }
   }

   delete m_vecAllRSOPCache;
   m_vecAllRSOPCache = NULL;    // be extra carefull because the old code is not to delete it at all.

   if (m_pSvc) {
      m_pSvc->Release();
   }
}

HRESULT CWMIRsop::Initialize()
{
    HRESULT hr = S_OK;
    IWbemLocator *pLoc = NULL;

    //Already initialized
    if(m_pSvc)
        return hr;

    if (!m_pRSOPInformation) 
    {
       return E_FAIL;
    }


    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLoc);
    if (FAILED(hr))
    {
        return hr;
    }


    const int cchMaxLength = 512;
    WCHAR szNameSpace[cchMaxLength];//LPOLESTR pszNameSpace = (LPOLESTR) LocalAlloc (LPTR, cchMaxLength * sizeof (WCHAR));

    hr = m_pRSOPInformation->GetNamespace (
               GPO_SECTION_MACHINE,
               szNameSpace,
               cchMaxLength);
    szNameSpace[cchMaxLength - 1] = L'\0';

       if (SUCCEEDED(hr)) 
       {
          BSTR bstrNameSpace = SysAllocString (szNameSpace);
          if (bstrNameSpace) 
          {
             hr = pLoc->ConnectServer(bstrNameSpace,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL,
                                      0,
                                      0,
                                      &m_pSvc
                                      );

             SysFreeString(bstrNameSpace);
          }
          else
              hr = E_OUTOFMEMORY;
       }

    if (SUCCEEDED(hr))
    {
        // Set the proxy so that impersonation of the client occurs.
        hr = CoSetProxyBlanket(m_pSvc,
                          RPC_C_AUTHN_WINNT,
                          RPC_C_AUTHZ_NONE,
                          NULL,
                          RPC_C_AUTHN_LEVEL_CALL,
                          RPC_C_IMP_LEVEL_IMPERSONATE,
                          NULL,
                          EOAC_NONE);
    }

    pLoc->Release();
    return hr;   // Program successfully completed.
}

HRESULT CWMIRsop::EnumeratePrecedenceOne(IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = m_pSvc->ExecQuery(_bstr_t(QUERY_LANG),
                           _bstr_t(RSOP_PREC_ONE_QUERY),
                           WBEM_FLAG_FORWARD_ONLY,
                           NULL,
                           ppEnum);

    return hr;
}

HRESULT CWMIRsop::EnumerateAll(IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = m_pSvc->ExecQuery(_bstr_t(QUERY_LANG),
                           _bstr_t(RSOP_ALL_QUERY),
                           WBEM_FLAG_FORWARD_ONLY,
                           NULL,
                           ppEnum);

    return hr;
}

HRESULT CWMIRsop::GetNextInstance(IEnumWbemClassObject *pEnum,
                          IWbemClassObject** rsopInstance)
{
    HRESULT hr = WBEM_S_FALSE;
    ULONG returnedNum = 0;
    if(pEnum)
    {
        hr = pEnum->Next(WBEM_INFINITE,
                         1,
                         rsopInstance,
                         &returnedNum);
        if( FAILED(hr) )
            return hr;

        if (returnedNum == 0)
            hr = WBEM_S_FALSE;
    }
    return hr;
}

HRESULT CWMIRsop::GetClass(IWbemClassObject* rsopInstance,
                   LPWSTR *ppClass)
{
    PTSTR pszClassName;
    VARIANT value;

    HRESULT hr = rsopInstance->Get(_bstr_t(WMI_CLASS),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr) || value.vt != VT_BSTR || value.bstrVal == NULL)
        return hr;

    pszClassName = (PTSTR) V_BSTR(&value);
    ULONG uLen = wcslen(pszClassName);
    *ppClass = (LPWSTR)LocalAlloc(LPTR, (uLen + 1) * sizeof(WCHAR));
    if( *ppClass == NULL )
    {
       VariantClear(&value);
       return E_OUTOFMEMORY;
    }
    wcscpy(*ppClass,pszClassName);
    VariantClear(&value);
    return hr;
}

HRESULT CWMIRsop::GetRSOPInfo(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo)
{

    HRESULT hr = S_OK;
    PTSTR pszGPOID = 0;
    UINT status = 0;
    UINT precedence = 0;
    VARIANT value;

    //Get Status
    hr = rsopInstance->Get(_bstr_t(RSOP_STATUS),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr))
        return hr;

    pInfo->status = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get Error
    hr = rsopInstance->Get(_bstr_t(RSOP_ERROR),
                           0,
                           &value,
                           NULL,
                           NULL);

    if(FAILED(hr))
        return hr;

    pInfo->error = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get Precedence
    hr = rsopInstance->Get(_bstr_t(RSOP_PRECEDENCE),
                    0,
                    &value,
                    NULL,
                    NULL);

    if(FAILED(hr))
        return hr;

    pInfo->precedence = (ULONG) V_UINT(&value);
    VariantClear(&value);

    //Get GPOID
    hr =    rsopInstance->Get(_bstr_t(RSOP_GPOID),
                              0,
                              &value,
                              NULL,
                              NULL);

    if(FAILED(hr) || value.vt != VT_BSTR || (value.vt == VT_BSTR && value.bstrVal == NULL) )
        return hr;

    pszGPOID = (PTSTR) V_BSTR(&value);
    ULONG uLen = wcslen(pszGPOID);
    pInfo->pszGPOID = (LPWSTR)LocalAlloc(LPTR, (uLen + 1) * sizeof(WCHAR));
    if( pInfo->pszGPOID == NULL )
    {
       VariantClear(&value);
       return E_OUTOFMEMORY;
    }
    wcscpy(pInfo->pszGPOID, pszGPOID);
    VariantClear(&value);

    return hr;
}

HRESULT CWMIRsop::GetPrecedenceOneRSOPInfo(PWMI_SCE_PROFILE_INFO *ppProfileInfo)
{
    HRESULT hr = S_OK;
    IWbemClassObject *rsopInstance = NULL;
    IEnumWbemClassObject *pEnumObject = NULL;
    PWMI_SCE_PROFILE_INFO pTempProfileInfo = NULL;
    PRSOP_INFO pInfo = NULL;

    hr = Initialize();
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = EnumeratePrecedenceOne(&pEnumObject);
    if( FAILED(hr) )
        goto exit_gracefully;

    pTempProfileInfo = new WMI_SCE_PROFILE_INFO;
    if( !pTempProfileInfo )
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    InitWMI_SEC_PROFILE_INFO(pTempProfileInfo);

    //Get each instance
    while( ((hr = GetNextInstance(pEnumObject, &rsopInstance)) != WBEM_S_FALSE) && !FAILED(hr) )
    {
        pInfo = (PRSOP_INFO)LocalAlloc(LPTR, sizeof(RSOP_INFO));
        if(pInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        //Get RSOP_INFO
        hr = GetRSOPInfo(rsopInstance, pInfo);
        if( FAILED(hr) )
            goto exit_gracefully;

        hr = AddInstance(rsopInstance,
                         pInfo,
                         pTempProfileInfo);
        if( FAILED(hr) )
            goto exit_gracefully;
        rsopInstance->Release();
        rsopInstance = NULL;
        pInfo = NULL;
    }


exit_gracefully:
    if(FAILED(hr))
    {
        if (rsopInstance)
            rsopInstance->Release();    // if while loop somehow terminate to here, rsopInstance is never released there
        if(pEnumObject)
            pEnumObject->Release();

        FreeRI(pInfo);
        //Free pTempProfileInfo
        FreeWMI_SCE_PROFILE_INFO(pTempProfileInfo);
        pTempProfileInfo = NULL;
    }
    *ppProfileInfo = pTempProfileInfo;
    return hr;
}

PWMI_SCE_PROFILE_INFO SearchProfileInList(vector<PWMI_SCE_PROFILE_INFO> *vecInfo,
                                          PRSOP_INFO pInfo)
{

    for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
    {
        PWMI_SCE_PROFILE_INFO pProfileInfo = *i;
        if(_wcsicmp(pProfileInfo->pInfo->pszGPOID,pInfo->pszGPOID) == 0 )
            return pProfileInfo;
    }
    return NULL;
}

//Function Object Used for sorting vector
struct less_mag : public binary_function<PWMI_SCE_PROFILE_INFO, PWMI_SCE_PROFILE_INFO, bool> {
    bool operator()(PWMI_SCE_PROFILE_INFO x, PWMI_SCE_PROFILE_INFO y)
    { return x->pInfo->precedence < y->pInfo->precedence; }
};

HRESULT CWMIRsop::GetAllRSOPInfo(vector<PWMI_SCE_PROFILE_INFO> *vecInfo)
{
    HRESULT hr = S_OK;
    IWbemClassObject *rsopInstance = NULL;
    IEnumWbemClassObject *pEnumObject = NULL;
    PRSOP_INFO pInfo = NULL;
    PWMI_SCE_PROFILE_INFO pProfileInfo = NULL;

    if (NULL == vecInfo) {
       return E_INVALIDARG;
    }

    //
    // If we've alrady cached the info from WMI then just return it
    // don't try and get it again
    //
    if (m_vecAllRSOPCache) 
    {
       for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = m_vecAllRSOPCache->begin();
                                               i != m_vecAllRSOPCache->end();
                                               ++i )
       {
          vecInfo->push_back(*i);
       }
       return S_OK;
    }

    hr = Initialize();
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = EnumerateAll(&pEnumObject);
    if( FAILED(hr) )
        goto exit_gracefully;

    //Get each instance
    while( ((hr = GetNextInstance(pEnumObject, &rsopInstance)) != WBEM_S_FALSE) && !FAILED(hr) )
    {
        pInfo = (PRSOP_INFO)LocalAlloc(LPTR, sizeof(RSOP_INFO));
        if(pInfo == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        //Get RSOP_INFO
        hr = GetRSOPInfo(rsopInstance, pInfo);
        if( FAILED(hr) )
            goto exit_gracefully;

        pProfileInfo = SearchProfileInList(vecInfo,pInfo);
        if(!pProfileInfo)
        {
            pProfileInfo = new WMI_SCE_PROFILE_INFO;
            if(!pProfileInfo)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            InitWMI_SEC_PROFILE_INFO(pProfileInfo);
            pProfileInfo->pInfo = (PRSOP_INFO)LocalAlloc(LPTR,sizeof(RSOP_INFO));
            if(!pProfileInfo->pInfo)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            pProfileInfo->pInfo->pszGPOID = (LPWSTR)LocalAlloc(LPTR, (wcslen(pInfo->pszGPOID)+1)*sizeof(WCHAR));
            if(!pProfileInfo->pInfo->pszGPOID)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            wcscpy(pProfileInfo->pInfo->pszGPOID,pInfo->pszGPOID);
            vecInfo->push_back(pProfileInfo);
        }

        if( pProfileInfo->pInfo->precedence < pInfo->precedence )
            pProfileInfo->pInfo->precedence = pInfo->precedence;

        hr = AddInstance(rsopInstance,
                         pInfo,
                         pProfileInfo);
        if(FAILED(hr))
            goto exit_gracefully;
        rsopInstance->Release();
        rsopInstance = NULL;
        pInfo = NULL;
    }

    sort(vecInfo->begin(),vecInfo->end(),less_mag());

    m_vecAllRSOPCache = new vector<PWMI_SCE_PROFILE_INFO>;
    if (m_vecAllRSOPCache) 
    {
       for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
       {
          m_vecAllRSOPCache->push_back(*i);
       }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        FreeRI(pInfo);
        //Free the vector
        for(vector<PWMI_SCE_PROFILE_INFO>::iterator i = vecInfo->begin();
                                               i != vecInfo->end();
                                               ++i )
        {
            PWMI_SCE_PROFILE_INFO pProfileInfo = *i;
            FreeWMI_SCE_PROFILE_INFO(pProfileInfo);
        }
    }
    if(pEnumObject)
        pEnumObject->Release();
    if(rsopInstance)
        rsopInstance->Release();

    return hr;
}

HRESULT CWMIRsop::AddNumericSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT bSettingValue;
    DWORD settingValue;

   _TRACE (1, L"Entering CWMIRsop::AddNumericSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    settingValue = V_UINT(&bSettingValue);

    if(!_wcsicmp(keyName, MIN_PASS_AGE))
    {
        pProfileInfo->MinimumPasswordAge = settingValue;
        pProfileInfo->pRIMinimumPasswordAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_PASS_AGE))
    {
        pProfileInfo->MaximumPasswordAge = settingValue;
        pProfileInfo->pRIMaximumPasswordAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MIN_PASS_LEN))
    {
        pProfileInfo->MinimumPasswordLength = settingValue;
        pProfileInfo->pRIMinimumPasswordLength = pInfo;
    }
    else if(!_wcsicmp(keyName, PASS_HIS_SIZE))
    {
        pProfileInfo->PasswordHistorySize = settingValue;
        pProfileInfo->pRIPasswordHistorySize = pInfo;
    }
    else if(!_wcsicmp(keyName, LOCKOUT_COUNT))
    {
        pProfileInfo->LockoutBadCount = settingValue;
        pProfileInfo->pRILockoutBadCount = pInfo;
    }
    else if(!_wcsicmp(keyName, RESET_LOCKOUT_COUNT))
    {
        pProfileInfo->ResetLockoutCount = settingValue;
        pProfileInfo->pRIResetLockoutCount = pInfo;
    }
    else if(!_wcsicmp(keyName, LOCKOUT_DURATION))
    {
        pProfileInfo->LockoutDuration = settingValue;
        pProfileInfo->pRILockoutDuration = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_TICKET_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxTicketAge = settingValue;
        pProfileInfo->pRIMaxTicketAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_RENEW_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxRenewAge = settingValue;
        pProfileInfo->pRIMaxRenewAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_SERVICE_AGE))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxServiceAge = settingValue;
        pProfileInfo->pRIMaxServiceAge = pInfo;
    }
    else if(!_wcsicmp(keyName, MAX_CLOCK_SKEW))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->MaxClockSkew = settingValue;
        pProfileInfo->pRIMaxClockSkew = pInfo;
    }
    else
    {
        _ASSERT (FALSE); // key name not accounted for
    }


exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);

   _TRACE (-1,L"Leaving CWMIRsop::AddNumericSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddEventLogNumericSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bKeyName;
    VARIANT bSettingValue;
    VARIANT bType;

   _TRACE (1, L"Entering CWMIRsop::AddEventLogNumericSetting\n");
    HRESULT hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_EVENTLOG_TYPE,
                          0,
                          &bType,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


   PTSTR keyName = V_BSTR(&bKeyName);
   DWORD settingValue = V_UINT(&bSettingValue);
   PTSTR typeValue = V_BSTR(&bType);

   unsigned long ulType = wcstoul (typeValue, L'\0', 10);
	ASSERT (ulType <= 2);
	if ( ulType <= 2 )
	{
      if ( !_wcsicmp(keyName, MAX_LOG_SIZE) )
      {
			pProfileInfo->MaximumLogSize[ulType] = settingValue;
			pProfileInfo->pRIMaximumLogSize[ulType] = pInfo;
		}
      else if ( !_wcsicmp(keyName, AUDIT_LOG_RETENTION_PERIOD) )
      {
			pProfileInfo->AuditLogRetentionPeriod[ulType] = settingValue;
			pProfileInfo->pRIAuditLogRetentionPeriod[ulType] = pInfo;
		}
      else if ( !_wcsicmp(keyName, RETENTION_DAYS) )
      {
			pProfileInfo->RetentionDays[ulType] = settingValue;
			pProfileInfo->pRIRetentionDays[ulType] = pInfo;
		}
      else
      {
         _ASSERT (FALSE); // key name not accounted for
      }
   }
	else
	   hr = E_FAIL;

exit_gracefully:
    VariantClear (&bKeyName);
    VariantClear (&bSettingValue);
    VariantClear (&bType);
   _TRACE (-1,L"Leaving CWMIRsop::AddEventLogNumericSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddEventLogBooleanSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PTSTR keyName = 0;
    VARIANT bSettingValue;
   DWORD settingValue;
    BOOL boolVal = FALSE;
    VARIANT bType;
    PTSTR   typeValue = 0;

   _TRACE (1, L"Entering CWMIRsop::AddEventLogBooleanSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_EVENTLOG_TYPE,
                          0,
                          &bType,
                          NULL,
                          NULL);
    if( FAILED(hr) )
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    boolVal = V_BOOL(&bSettingValue);
    settingValue = (boolVal)? 1:0;
    typeValue = V_BSTR(&bType);


   unsigned long ulType = wcstoul (typeValue, L'\0', 10);
	ASSERT (ulType <= 2);
	if ( ulType <= 2 )
	{
      if ( !_wcsicmp(keyName, RESTRICT_GUEST_ACCESS) )
      {
			pProfileInfo->RestrictGuestAccess[ulType] = settingValue;
			pProfileInfo->pRIRestrictGuestAccess[ulType] = pInfo;
		}
      else
      {
         _ASSERT (FALSE); // key name not accounted for
      }
   }
	else
	   hr = E_FAIL;

exit_gracefully:
    VariantClear (&bKeyName);
    VariantClear (&bSettingValue);
    VariantClear (&bType);
   _TRACE (-1,L"Leaving CWMIRsop::AddEventLogBooleanSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddBooleanSetting(IWbemClassObject *rsopInstance,
                          PRSOP_INFO pInfo,
                          PWMI_SCE_PROFILE_INFO pProfileInfo)
{

    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT bSettingValue;
    BOOL boolVal;
    DWORD settingValue;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddBooleanSetting\n");

    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                           0,
                           &bKeyName,
                           NULL,
                           NULL);
    if(FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                           0,
                           &bSettingValue,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;

    keyName = (PTSTR) V_BSTR(&bKeyName);

    boolVal = V_BOOL(&bSettingValue);

    settingValue = (boolVal)? 1:0;

    if(!_wcsicmp(keyName, PASS_COMPLEX))
    {
        pProfileInfo->PasswordComplexity = settingValue;
        pProfileInfo->pRIPasswordComplexity = pInfo;
    }
    else if(!_wcsicmp(keyName, FORCE_LOGOFF))
    {
        pProfileInfo->ForceLogoffWhenHourExpire = settingValue;
        pProfileInfo->pRIForceLogoffWhenHourExpire = pInfo;
    }
    else if(!_wcsicmp(keyName, ENABLE_ADMIN))
    {
        pProfileInfo->EnableAdminAccount = settingValue;
        pProfileInfo->pRIEnableAdminAccount = pInfo;
    }
    else if(!_wcsicmp(keyName, ENABLE_GUEST))
    {
        pProfileInfo->EnableGuestAccount = settingValue;
        pProfileInfo->pRIEnableGuestAccount = pInfo;
    }
    else if(!_wcsicmp(keyName, LSA_ANON_LOOKUP))
    {
        pProfileInfo->LSAAnonymousNameLookup = settingValue;
        pProfileInfo->pRILSAAnonymousNameLookup = pInfo;
    }
    else if(!_wcsicmp(keyName, CLEAR_TEXT_PASS))
    {
        pProfileInfo->ClearTextPassword = settingValue;
        pProfileInfo->pRIClearTextPassword = pInfo;
    }
    else if (!_wcsicmp(keyName, REQUIRE_LOGON_TO_CHANGE_PASS))
    {
        pProfileInfo->RequireLogonToChangePassword = settingValue;
        pProfileInfo->pRIRequireLogonToChangePassword = pInfo;
    }
    else if(!_wcsicmp(keyName, VALIDATE_CLIENT))
    {
        if(!pProfileInfo->pKerberosInfo)
        {
            pProfileInfo->pKerberosInfo =
                (PSCE_KERBEROS_TICKET_INFO) LocalAlloc(LPTR, sizeof(SCE_KERBEROS_TICKET_INFO));
            if(pProfileInfo->pKerberosInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
        }
        pProfileInfo->pKerberosInfo->TicketValidateClient = settingValue;
        pProfileInfo->pRITicketValidateClient = pInfo;
    }
    else
    {
       _ASSERT (FALSE); // key name not accounted for
    }
exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);
   _TRACE (-1,L"Leaving CWMIRsop::AddBooleanSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddAuditSetting(IWbemClassObject *rsopInstance,
                          PRSOP_INFO pInfo,
                          PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bCategoryName;
    PTSTR categoryName;
    VARIANT vSuccessVal;
    VARIANT vFailVal;
    BOOL successVal;
    BOOL failVal;
    DWORD settingVal = 0;
    HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddAuditSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("Category")),
                0,
                &bCategoryName,
                NULL,
                NULL
                );

    if(FAILED(hr) || bCategoryName.vt != VT_BSTR || bCategoryName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Success")),
                0,
                &vSuccessVal,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Failure")),
            0,
            &vFailVal,
            NULL,
            NULL
            );
    if(FAILED(hr))
        goto exit_gracefully;



    categoryName = (PTSTR) V_BSTR(&bCategoryName);

    successVal = V_BOOL(&vSuccessVal);

    failVal = V_BOOL(&vFailVal);

    if (successVal) 
        settingVal |= 1;
    if (failVal) 
        settingVal |= 2;

    if(!_wcsicmp(categoryName, AUDIT_SYSTEM_EVENTS))
    {
        pProfileInfo->AuditSystemEvents = settingVal;
        pProfileInfo->pRIAuditSystemEvents = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_LOGON_EVENTS))
    {
        pProfileInfo->AuditLogonEvents = settingVal;
        pProfileInfo->pRIAuditLogonEvents = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_OBJECT_ACCESS))
    {
        pProfileInfo->AuditObjectAccess = settingVal;
        pProfileInfo->pRIAuditObjectAccess = pInfo;
    }
    else if (!_wcsicmp(categoryName, AUDIT_PRIVILEGE_USE))
    {
        pProfileInfo->AuditPrivilegeUse = settingVal;
        pProfileInfo->pRIAuditPrivilegeUse = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_POLICY_CHANGE))
    {
        pProfileInfo->AuditPolicyChange = settingVal;
        pProfileInfo->pRIAuditPolicyChange = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_ACCOUNT_MANAGE))
    {
        pProfileInfo->AuditAccountManage = settingVal;
        pProfileInfo->pRIAuditAccountManage = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_PROCESS_TRAKING))
    {
        pProfileInfo->AuditProcessTracking = settingVal;
        pProfileInfo->pRIAuditProcessTracking = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_DS_ACCESS))
    {
        pProfileInfo->AuditDSAccess = settingVal;
        pProfileInfo->pRIAuditDSAccess = pInfo;
    }
    else if(!_wcsicmp(categoryName, AUDIT_ACCOUNT_LOGON))
    {
        pProfileInfo->AuditAccountLogon = settingVal;
        pProfileInfo->pRIAuditAccountLogon = pInfo;
    }
    else
    {
      _ASSERT (FALSE); // key name not accounted for
    }

exit_gracefully:

    VariantClear(&bCategoryName);
    VariantClear(&vSuccessVal);
    VariantClear(&vFailVal);
   _TRACE (-1,L"Leaving CWMIRsop::AddAuditSetting\n");

    return hr;
}


HRESULT CWMIRsop::AddUserRightSetting(
                    IWbemClassObject *rsopInstance,
                    PRSOP_INFO pInfo,
                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bUserRight;
    PTSTR userRight = NULL;
    VARIANT vAccountList;
   HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddUserRightSetting\n");

    hr = rsopInstance->Get(_bstr_t(RSOP_USERRIGHT),
                      0,
                      &bUserRight,
                      NULL,
                      NULL);
    if( FAILED(hr) || bUserRight.vt != VT_BSTR || bUserRight.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(RSOP_ACCOUNTLIST),
                      0,
                      &vAccountList,
                      NULL,
                      NULL);
    if( FAILED(hr) )
        goto exit_gracefully;

    DWORD len;
    len  = wcslen((PTSTR) V_BSTR(&bUserRight));
     userRight = (PTSTR) LocalAlloc(LPTR, (len+1) * sizeof(WCHAR) );
    if(!userRight)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy(userRight, (PTSTR) V_BSTR(&bUserRight));



    PSCE_PRIVILEGE_ASSIGNMENT head;
    head = pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo;

    if (!head)
    {
        head = (pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo =
            (PSCE_PRIVILEGE_ASSIGNMENT) LocalAlloc(LPTR, sizeof(SCE_PRIVILEGE_ASSIGNMENT)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_PRIVILEGE_ASSIGNMENT current;
        current = (PSCE_PRIVILEGE_ASSIGNMENT) LocalAlloc(LPTR, sizeof(SCE_PRIVILEGE_ASSIGNMENT));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        current->Next = head;
        head = current;
        pProfileInfo->OtherInfo.scp.u.pInfPrivilegeAssignedTo = head;
    }

    head->Name = userRight;
    userRight = NULL;

    if(V_VT(&vAccountList) != VT_NULL)
    {
        SAFEARRAY* ptempArray;
        ptempArray = NULL;
        BSTR tempString;
        long lowerBoundray=0, upperBoundray=0, loopCount=0;
        ptempArray = V_ARRAY(&vAccountList);

        if ( FAILED(SafeArrayGetLBound(ptempArray, 1, &lowerBoundray)) ) lowerBoundray = 0;
        if ( FAILED(SafeArrayGetUBound(ptempArray, 1, &upperBoundray)) ) upperBoundray = 0;

        PSCE_NAME_LIST nameHead = head->AssignedTo;
        for (loopCount = lowerBoundray; loopCount <= upperBoundray; loopCount++)
        {
            hr = SafeArrayGetElement(ptempArray,
                                    &loopCount,
                                    &tempString);

            if ( FAILED(hr) ) goto exit_gracefully;

            if(!nameHead)
            {
                nameHead =
                    (head->AssignedTo = (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST)));
                if(!nameHead)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
            }
            else
            {
                PSCE_NAME_LIST currentName =
                    (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST));
                if(!currentName)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }

                currentName->Next = nameHead;
                nameHead = currentName;
                head->AssignedTo = nameHead;
            }

            DWORD nameLen = wcslen((PTSTR) tempString);
            nameHead->Name = (PTSTR) LocalAlloc(LPTR, (nameLen+1) *sizeof(WCHAR) );
            if(!nameHead->Name)
            {
                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            wcscpy(nameHead->Name, (PTSTR) tempString);
        }
    }

        //Set other info
    pProfileInfo->listRIInfPrivilegeAssignedTo.push_front(pInfo);


exit_gracefully:
    if(FAILED(hr) && (userRight != NULL))
    {
        LocalFree(userRight);
    }
    VariantClear(&bUserRight);
    VariantClear(&vAccountList);
   _TRACE (-1,L"Leaving CWMIRsop::AddUserRightSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddRegValSetting(IWbemClassObject *rsopInstance,
                           PRSOP_INFO pInfo,
                           PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bKeyName;
    PTSTR keyName;
    VARIANT vSettingValue;
    VARIANT vType;
    PTSTR settingValue;
    DWORD type;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddRegValSetting\n");

    hr  = rsopInstance->Get(_bstr_t(TEXT("Path")),
                            0,
                            &bKeyName,
                            NULL,
                            NULL);
    if(FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Data")),
                            0,
                            &vSettingValue,
                            NULL,
                            NULL);
    if(FAILED(hr) || vSettingValue.vt != VT_BSTR || vSettingValue.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Type")),
                            0,
                            &vType,
                            NULL,
                            NULL);
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bKeyName));
    keyName = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!keyName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }

    wcscpy(keyName,(PTSTR) V_BSTR(&bKeyName));

    len = wcslen((PTSTR) V_BSTR(&vSettingValue));
    settingValue = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!settingValue)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }

    wcscpy(settingValue,(PTSTR) V_BSTR(&vSettingValue));

    type = (DWORD) V_I4(&vType);


    DWORD arrayIndex;
    if ((arrayIndex = pProfileInfo->RegValueCount) == 0)
    {
        pProfileInfo->aRegValues =
            (PSCE_REGISTRY_VALUE_INFO) LocalAlloc(LPTR, sizeof(SCE_REGISTRY_VALUE_INFO)* m_cRegValueSize);
        if(!pProfileInfo->aRegValues)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }

    //double the array preserving the content
    if( arrayIndex >= m_cRegValueSize )
    {
        PSCE_REGISTRY_VALUE_INFO temp = (PSCE_REGISTRY_VALUE_INFO) LocalAlloc(LPTR, sizeof(SCE_REGISTRY_VALUE_INFO)* m_cRegValueSize * 2);
        if(!temp)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        memcpy(temp,pProfileInfo->aRegValues,sizeof(SCE_REGISTRY_VALUE_INFO)*arrayIndex);
        LocalFree(pProfileInfo->aRegValues);
        pProfileInfo->aRegValues = temp;
        m_cRegValueSize *= 2;
    }

    pProfileInfo->aRegValues[arrayIndex].FullValueName = keyName;
    pProfileInfo->aRegValues[arrayIndex].Value = settingValue;
    pProfileInfo->aRegValues[arrayIndex].ValueType = type;
    pProfileInfo->RegValueCount += 1;

        //Store RSOP_INFO
    pProfileInfo->vecRIRegValues.push_back(pInfo);


exit_gracefully:

    VariantClear(&bKeyName);
    VariantClear(&vSettingValue);
    VariantClear(&vType);

   _TRACE (-1,L"Leaving CWMIRsop::AddRegValSetting\n");
    return hr;

}

HRESULT CWMIRsop::AddRestrictedGroupSetting(IWbemClassObject *rsopInstance,
                                    PRSOP_INFO pInfo,
                                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bRGroup;
    PTSTR RGroup;
    VARIANT vMembers;
    HRESULT hr = S_OK;

    _TRACE (1, L"Entering CWMIRsop::AddRestrictedGroupSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("GroupName")),
                0,
                &bRGroup,
                NULL,
                NULL
                );
    if(FAILED(hr) || bRGroup.vt != VT_BSTR || bRGroup.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("Members")),
                0,
                &vMembers,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bRGroup));
    RGroup = (PTSTR) LocalAlloc(LPTR, (len+1) * sizeof(WCHAR));
    if(!RGroup)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy(RGroup, (PTSTR) V_BSTR(&bRGroup));

    PSCE_GROUP_MEMBERSHIP head;
    head = pProfileInfo->pGroupMembership;

    if (!head)
    {
        head = (pProfileInfo->pGroupMembership =
            (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR, sizeof(SCE_GROUP_MEMBERSHIP)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_GROUP_MEMBERSHIP current =
            (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LPTR, sizeof(SCE_GROUP_MEMBERSHIP));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        current->Next = head;
        head = current;
        pProfileInfo->pGroupMembership = head;
    }

    head->GroupName = RGroup;

    if(V_VT(&vMembers) != VT_NULL)
    {
        SAFEARRAY* ptempArray = NULL;
        BSTR tempString;
        long lowerBoundray=0, upperBoundray=0, loopCount=0;
        ptempArray = V_ARRAY(&vMembers);

        if ( FAILED(SafeArrayGetLBound(ptempArray, 1, &lowerBoundray)) ) lowerBoundray = 0;
        if ( FAILED(SafeArrayGetUBound(ptempArray, 1, &upperBoundray)) ) upperBoundray = 0;

        PSCE_NAME_LIST nameHead = head->pMembers;
        for (loopCount = lowerBoundray; loopCount <= upperBoundray; loopCount++){

            hr = SafeArrayGetElement(ptempArray,
                                &loopCount,
                                &tempString);

            if ( FAILED(hr) ) goto exit_gracefully;

            if(!nameHead)
            {
                nameHead =
                    (head->pMembers = (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST)));
                if(!nameHead)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
            }
            else
            {
                PSCE_NAME_LIST currentName =
                    (PSCE_NAME_LIST) LocalAlloc(LPTR, sizeof(SCE_NAME_LIST));
                if(!currentName)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit_gracefully;
                }
                currentName->Next = nameHead;
                nameHead = currentName;
                head->pMembers = nameHead;
            }

            DWORD nameLen = wcslen((PTSTR) tempString);
            nameHead->Name = (PTSTR) LocalAlloc(LPTR, (nameLen+1) *sizeof(WCHAR) );
            if ( !(nameHead->Name) ) {

                hr = E_OUTOFMEMORY;
                goto exit_gracefully;
            }
            wcscpy(nameHead->Name, (PTSTR) tempString);
        }
    }

        //Add RSOP info
    pProfileInfo->listRIGroupMemebership.push_front(pInfo);


exit_gracefully:
    VariantClear(&bRGroup);
    VariantClear(&vMembers);
   _TRACE (-1,L"Leaving CWMIRsop::AddRestrictedGroupSetting\n");
    return hr;
}

HRESULT CWMIRsop::AddServiceSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bServiceName;
    PTSTR serviceName;
    VARIANT vSDDL;
    VARIANT vStartup;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD startup;
    HRESULT hr = S_OK;


   _TRACE (1, L"Entering CWMIRsop::AddServiceSetting\n");

    hr = rsopInstance->Get(_bstr_t(TEXT("Service")),
                           0,
                           &bServiceName,
                           NULL,
                           NULL);
    if(FAILED(hr) || bServiceName.vt != VT_BSTR || bServiceName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get(_bstr_t(TEXT("SDDLString")),
                           0,
                           &vSDDL,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("StartupMode")),
                           0,
                           &vStartup,
                           NULL,
                           NULL);
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bServiceName));
    serviceName = (PTSTR) LocalAlloc(LPTR, (len+1) *sizeof(WCHAR));
    if(!serviceName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy(serviceName,(PTSTR) V_BSTR(&bServiceName));

    ULONG sdLen;
    sdLen = 0;
    if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
        (PTSTR) V_BSTR(&vSDDL),
        SDDL_REVISION_1,
        &SDDL,
        &sdLen
        ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit_gracefully;
    }


    startup = (DWORD) V_I4(&vStartup);


    PSCE_SERVICES head;
    head = pProfileInfo->pServices;

    if (!head)
    {
        head = (pProfileInfo->pServices =
            (PSCE_SERVICES) LocalAlloc(LPTR, sizeof(SCE_SERVICES)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else
    {
        PSCE_SERVICES current =
            (PSCE_SERVICES) LocalAlloc(LPTR, sizeof(SCE_SERVICES));
        if(!current)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        current->Next = head;
        head = current;
        pProfileInfo->pServices = head;
    }

    head->ServiceName = serviceName;
    head->General.pSecurityDescriptor = SDDL;
    head->Startup = (BYTE) startup; //no data loss value is <= 4

    //Add RSOP info
    pProfileInfo->listRIServices.push_front(pInfo);

exit_gracefully:
    VariantClear(&bServiceName);
    VariantClear(&vSDDL);
    VariantClear(&vStartup);
   _TRACE (-1,L"Leaving CWMIRsop::AddServiceSetting\n");

    return hr;
}

HRESULT CWMIRsop::AddFileSetting(IWbemClassObject *rsopInstance,
                            PRSOP_INFO pInfo,
                            PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    VARIANT bFileName;
    PTSTR fileName = NULL;
    VARIANT vSDDL;
    VARIANT vMode;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD mode = 0;

   _TRACE (1, L"Entering CWMIRsop::AddFileSetting\n");

    HRESULT hr = S_OK;


    hr = rsopInstance->Get((BSTR)(TEXT("Path")),
                0,
                &bFileName,
                NULL,
                NULL
                );
    if(FAILED(hr) || bFileName.vt != VT_BSTR || bFileName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("Mode")),
                0,
                &vMode,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("SDDLString")),
                0,
                &vSDDL,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;


    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bFileName));
    fileName = (PTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR) + 2);
    if(!fileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy(fileName, (PTSTR) V_BSTR(&bFileName));


    mode = (DWORD) V_I4(&vMode);


    if (mode != 1)
    {

        ULONG sdLen = 0;
        if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            (PTSTR) V_BSTR(&vSDDL),
            SDDL_REVISION_1,
            &SDDL,
            &sdLen
            ))
        {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit_gracefully;
        }
    }


    PSCE_OBJECT_ARRAY head;
    head = pProfileInfo->pFiles.pAllNodes;

    if(!head)
    {
        head =  (pProfileInfo->pFiles.pAllNodes =
            (PSCE_OBJECT_ARRAY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cFileSize);
        if(!head->pObjectArray)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else if(head->Count >= m_cFileSize)
    {
        PSCE_OBJECT_SECURITY* temp = (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cFileSize*2);
        if(!temp)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        memcpy(temp,head->pObjectArray,head->Count *sizeof(PSCE_OBJECT_SECURITY));
        LocalFree(head->pObjectArray);
        head->pObjectArray = temp;
        m_cFileSize *=2;
    }

    DWORD index;
    index = head->Count;

    head->pObjectArray[index] =
        (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_SECURITY));
    if(!head->pObjectArray[index])
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    head->pObjectArray[index]->Name = fileName;
    head->pObjectArray[index]->pSecurityDescriptor = SDDL;
    head->pObjectArray[index]->Status = (BYTE) mode;
    head->Count++;

    //SET RSOP INFO
    pProfileInfo->vecRIFiles.push_back(pInfo);

exit_gracefully:
    VariantClear(&bFileName);
    VariantClear(&vMode);
    if(mode != 1){
        VariantClear(&vSDDL);
    }
   _TRACE (-1,L"Leaving CWMIRsop::AddFileSetting\n");

    return hr;
}


HRESULT CWMIRsop::AddRegSetting(IWbemClassObject *rsopInstance,
                        PRSOP_INFO pInfo,
                        PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    PTSTR gpoID = NULL;
    VARIANT bFileName;
    PTSTR fileName = NULL;
    VARIANT vSDDL;
    VARIANT vMode;
    PSECURITY_DESCRIPTOR SDDL = NULL;
    DWORD mode = 0;
    static DWORD multiplier = 1;

    HRESULT hr = S_OK;

   _TRACE (1, L"Entering CWMIRsop::AddRegSetting\n");

    hr = rsopInstance->Get((BSTR)(TEXT("Path")),
                0,
                &bFileName,
                NULL,
                NULL
                );
    if(FAILED(hr) || bFileName.vt != VT_BSTR || bFileName.bstrVal == NULL )
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("Mode")),
                0,
                &vMode,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)(TEXT("SDDLString")),
                0,
                &vSDDL,
                NULL,
                NULL
                );
    if(FAILED(hr))
        goto exit_gracefully;



    DWORD len;
    len = wcslen((PTSTR) V_BSTR(&bFileName));
    fileName = (PTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR) + 2);
    if(!fileName)
    {
        hr = E_OUTOFMEMORY;
        goto exit_gracefully;
    }
    wcscpy(fileName, (PTSTR) V_BSTR(&bFileName));

    mode = (DWORD) V_I4(&vMode);


    if (mode != 1)
    {

        ULONG sdLen = 0;
        if( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            (PTSTR) V_BSTR(&vSDDL),
            SDDL_REVISION_1,
            &SDDL,
            &sdLen
            ))
        {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit_gracefully;
        }
    }


    PSCE_OBJECT_ARRAY head;
    head = pProfileInfo->pRegistryKeys.pAllNodes;

    if(!head){
        head = (pProfileInfo->pRegistryKeys.pAllNodes =
            (PSCE_OBJECT_ARRAY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_ARRAY)));
        if(!head)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cRegArrayCount);
        if(!head->pObjectArray)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
    }
    else if(head->Count >= m_cRegArrayCount){
        PSCE_OBJECT_SECURITY* temp = head->pObjectArray;
        head->pObjectArray =
            (PSCE_OBJECT_SECURITY*) LocalAlloc(LPTR, sizeof(PSCE_OBJECT_SECURITY)*m_cRegArrayCount*2);
        if(!head->pObjectArray)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }
        memcpy(head->pObjectArray,temp,head->Count *sizeof(PSCE_OBJECT_SECURITY));
        LocalFree(temp);
        m_cRegArrayCount *= 2;
    }

   //
   // Can't initialize at declaration since this is skipped by gotos
   //
    DWORD index;
   index = head->Count;

    head->pObjectArray[index] =
        (PSCE_OBJECT_SECURITY) LocalAlloc(LPTR, sizeof(SCE_OBJECT_SECURITY));
   if (head->pObjectArray[index]) {
    head->pObjectArray[index]->Name = fileName;
    head->pObjectArray[index]->pSecurityDescriptor = SDDL;
    head->pObjectArray[index]->Status = (BYTE) mode;
    head->Count++;
   }
    //add rsop info
    pProfileInfo->vecRIReg.push_back(pInfo);


exit_gracefully:
    VariantClear(&bFileName);
    VariantClear(&vMode);
    if(mode != 1){
        VariantClear(&vSDDL);
    }

   _TRACE (-1, L"Leaving CWMIRsop::AddRegSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddStringSetting (IWbemClassObject *rsopInstance,
                              PRSOP_INFO pInfo,
                              PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    VARIANT bKeyName;
    PWSTR   keyName = 0;
    VARIANT bSettingValue;
    PWSTR   settingValue = 0;

   _TRACE (1, L"Entering CWMIRsop::AddStringSetting\n");
    hr = rsopInstance->Get((BSTR)RSOP_KEYNAME,
                          0,
                          &bKeyName,
                          NULL,
                          NULL);
    if( FAILED(hr) || bKeyName.vt != VT_BSTR || bKeyName.bstrVal == NULL)
        goto exit_gracefully;

    hr = rsopInstance->Get((BSTR)RSOP_SETTING,
                          0,
                          &bSettingValue,
                          NULL,
                          NULL);
    if( FAILED(hr) || bSettingValue.vt != VT_BSTR || bSettingValue.bstrVal == NULL)
        goto exit_gracefully;


    keyName = V_BSTR(&bKeyName);
    settingValue = V_BSTR(&bSettingValue);

    if (!_wcsicmp(keyName, NEW_GUEST_NAME))
    {
        if ( 0 != pProfileInfo->NewGuestName )
        {
            LocalFree (pProfileInfo->NewGuestName);
            pProfileInfo->NewGuestName = 0;
        }

        size_t len = wcslen (settingValue);
        pProfileInfo->NewGuestName = (PWSTR) LocalAlloc (LPTR, (len + 1) * sizeof (TCHAR));
        if ( pProfileInfo->NewGuestName )
        {
            wcscpy (pProfileInfo->NewGuestName, settingValue);
        }
        else
            hr = E_OUTOFMEMORY;

        pProfileInfo->pRINewGuestName = pInfo;
    }
    else if (!_wcsicmp(keyName, NEW_ADMINISTRATOR_NAME))
    {
        if ( 0 != pProfileInfo->NewAdministratorName )
        {
            LocalFree (pProfileInfo->NewAdministratorName);
            pProfileInfo->NewAdministratorName = 0;
        }

        size_t len = wcslen (settingValue);
        pProfileInfo->NewAdministratorName = (PWSTR) LocalAlloc (LPTR, (len + 1) * sizeof (TCHAR));
        if ( pProfileInfo->NewAdministratorName )
        {
            wcscpy (pProfileInfo->NewAdministratorName, settingValue);
        }
        else
            hr = E_OUTOFMEMORY;

        pProfileInfo->pRINewAdministratorName = pInfo;
    }
    else
    {
       _ASSERT (FALSE); // key name not accounted for
    }


exit_gracefully:
    VariantClear(&bKeyName);
    VariantClear(&bSettingValue);

   _TRACE (-1,L"Leaving CWMIRsop::AddStringSetting\n");
    return hr;
}


HRESULT CWMIRsop::AddInstance(IWbemClassObject *rsopInstance,
                    PRSOP_INFO pInfo,
                    PWMI_SCE_PROFILE_INFO pProfileInfo)
{
    HRESULT hr = S_OK;
    LPWSTR className = NULL;

    _TRACE (1, L"Entering CWMIRsop::AddInstance\n");

    //Get RSOP_Class Name
    hr = GetClass(rsopInstance, &className);
    if( FAILED(hr) )
        goto exit_gracefully;


    if(!_wcsicmp(className, RSOP_SEC_NUM))
    {
        hr = AddNumericSetting(rsopInstance,
                               pInfo,
                               pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SEC_BOOL))
    {
        hr = AddBooleanSetting(rsopInstance,
                               pInfo,
                               pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SCE_STRING))
    {
       hr = AddStringSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_AUDIT))
    {
        hr = AddAuditSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_EVENT_NUM))
    {
        hr = AddEventLogNumericSetting (rsopInstance, pInfo, pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_EVENT_BOOL))
    {
        hr = AddEventLogBooleanSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_REG_VAL))
    {
        hr = AddRegValSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_USER_RIGHT))
    {
        hr = AddUserRightSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_RGROUPS))
    {
        hr = AddRestrictedGroupSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_SERVICE))
    {
        hr = AddServiceSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_FILE))
    {
        hr = AddFileSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else if(!_wcsicmp(className, RSOP_REG))
    {
        hr = AddRegSetting(rsopInstance,pInfo,pProfileInfo);
    }
    else
    {
        _ASSERT (FALSE); // class not accounted for
    }
exit_gracefully:
    _TRACE (-1,L"Exiting CWMIRsop::AddInstance\n");
    LocalFree(className);
return hr;
}

HRESULT
CWMIRsop::GetGPOFriendlyName (PWSTR lpGPOID, PWSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;

    //
    // Set the default
    //

    *pGPOName = NULL;

    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for unicode query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
       _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = m_pSvc->ExecQuery (_bstr_t(QUERY_LANG), pQuery,
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL, &pEnum);


    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to query for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    VariantInit(&varGPOName);
    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        _TRACE (0, L"CWMIRsop::GetGPOFriendlyName: Failed to allocate memory for GPO Name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    hr = S_OK;

Exit:
    VariantClear (&varGPOName);

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wrapper.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wrapper.cpp
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "util.h"
#include "resource.h"
#include "winreg.h"
#include "areaprog.h"
#include "wrapper.h"

#include "dsgetdc.h"

typedef DWORD  (WINAPI *PFNDSGETDCNAME)(LPCWSTR, LPCWSTR, GUID *, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW *);

typedef struct {
   LPCWSTR szProfile;
   LPCWSTR szDatabase;
   LPCWSTR szLog;
   AREA_INFORMATION Area;
   LPVOID  *pHandle;
   PSCE_AREA_CALLBACK_ROUTINE pCallback;
   HANDLE hWndCallback;
   DWORD   dwFlags;
} ENGINEARGS;

BOOL
PostProgressArea(
   IN HANDLE CallbackHandle,
   IN AREA_INFORMATION Area,
   IN DWORD TotalTicks,
   IN DWORD CurrentTicks
   );

static BOOL bRangeSet=FALSE;

CRITICAL_SECTION csOpenDatabase;
#define OPEN_DATABASE_TIMEOUT INFINITE

//
// Helper functions to call the engine from a secondary thread:
//
DWORD WINAPI
InspectSystemEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc;
   ea = (ENGINEARGS *)lpv;

   DWORD dWarning=0;
   rc = SceAnalyzeSystem(NULL,
                         ea->szProfile,
                         ea->szDatabase,
                         ea->szLog,
                         SCE_UPDATE_DB|SCE_VERBOSE_LOG,
                         ea->Area,
                         ea->pCallback,
                         ea->hWndCallback,
                         &dWarning  // this is required (by RPC)
                         );
   return rc;
}

//
// call to SCE engine to apply the template
//

DWORD WINAPI
ApplyTemplateEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc;
   ea = (ENGINEARGS *)lpv;

   rc = SceConfigureSystem(NULL,
                           ea->szProfile,
                           ea->szDatabase,
                           ea->szLog,
                           SCE_OVERWRITE_DB|SCE_VERBOSE_LOG,
                           ea->Area,
                           ea->pCallback,
                           ea->hWndCallback,
                           NULL
                           );

   return rc;
}


WINBASEAPI
BOOL
WINAPI
TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

/*------------------------------------------------------------------------------
Method:     OpenDatabaseEx

Synopsis:   open database on a separate thread

Arugments:

Returns:

History: a-mthoge 06-09-1998 - Added the _NT4BACK_PORT compile condition.
------------------------------------------------------------------------------*/
DWORD
WINAPI
OpenDatabaseEx(LPVOID lpv) {

   if ( lpv == NULL ) return ERROR_INVALID_PARAMETER;

   ENGINEARGS *ea;
   SCESTATUS rc=0;


   if (TryEnterCriticalSection(&csOpenDatabase)) {
      ea = (ENGINEARGS *)lpv;

      rc = SceOpenProfile(ea->szProfile,
                          (SCE_FORMAT_TYPE) ea->dwFlags,  // SCE_JET_FORMAT || SCE_JET_ANALYSIS_REQUIRED
                          ea->pHandle
                          );

      LeaveCriticalSection(&csOpenDatabase);
   } else {
      rc = SCESTATUS_OTHER_ERROR;
   }
   return rc;
}

//
// Assign a template to the system without configuring it
//
SCESTATUS
AssignTemplate(LPCWSTR szTemplate,
               LPCWSTR szDatabase,
               BOOL bIncremental) {
   SCESTATUS rc;

   rc = SceConfigureSystem(NULL,
                           szTemplate,
                           szDatabase,
                           NULL,
                           (bIncremental ? SCE_UPDATE_DB : SCE_OVERWRITE_DB) | SCE_NO_CONFIG | SCE_VERBOSE_LOG,
                           AREA_ALL,
                           NULL,
                           NULL,
                           NULL
                           );

   return rc;
}

//
// apply a template to the system
//
DWORD
ApplyTemplate(
    LPCWSTR szProfile,
    LPCWSTR szDatabase,
    LPCWSTR szLogFile,
    AREA_INFORMATION Area
    )
{
   // Spawn a thread to call the engine & apply the profile, since this can
   // take a while and we want to stay responsive & have a change to provide
   // feedback.

   ENGINEARGS ea;
   HANDLE hThread=NULL;

   ea.szProfile = szProfile;
   ea.szDatabase = szDatabase;
   ea.szLog = szLogFile;
   ea.Area = Area;

   //
   // this is the progress call back dialog which
   // will be passed to SCE client stub for progress
   // callback
   //
   AreaProgress *ap = new AreaProgress;
   if ( ap ) {

       CString strTitle;
       CString strVerb;
       strTitle.LoadString(IDS_CONFIGURE_PROGRESS_TITLE);
       strVerb.LoadString(IDS_CONFIGURE_PROGRESS_VERB);

       ap->Create(IDD_ANALYZE_PROGRESS);
       ap->SetWindowText(strTitle);
       ap->SetDlgItemText(IDC_VERB,strVerb);
       ap->ShowWindow(SW_SHOW);
       bRangeSet = FALSE;
   }

   ea.pCallback = (PSCE_AREA_CALLBACK_ROUTINE)PostProgressArea;
   ea.hWndCallback = (HANDLE)ap;

   hThread = CreateThread(NULL,0,ApplyTemplateEx,&ea,0,NULL);

   DWORD dw=0;
   if ( hThread ) {

       MSG msg;

       DWORD dwTotalTicks=100;
       do {

          dw = MsgWaitForMultipleObjects(1,&hThread,0,INFINITE,QS_ALLINPUT);
          while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
          }
       } while (WAIT_OBJECT_0 != dw);

       GetExitCodeThread(hThread,&dw);

       CloseHandle(hThread);

   } else {

       dw = GetLastError();

       CString str;
       str.LoadString(IDS_CANT_CREATE_THREAD);
       AfxMessageBox(str);
   }

   //
   // free the dialog if it's created
   //
   if ( ap ) {
       if ( ap->GetSafeHwnd() )
           ap->DestroyWindow();
       delete ap;
   }

   return dw;
}

//
// post progress
//
BOOL
PostProgressArea(
   IN HANDLE CallbackHandle,
   IN AREA_INFORMATION Area,
   IN DWORD TotalTicks,
   IN DWORD CurrentTicks
   )
{
   if ( CallbackHandle ) {

       AreaProgress *ap = (AreaProgress *)CallbackHandle;

       ap->ShowWindow(SW_SHOW);

       if ( !bRangeSet ) {
           ap->SetMaxTicks(TotalTicks);
           bRangeSet = TRUE;
       }
       ap->SetCurTicks(CurrentTicks);
       ap->SetArea(Area);

       return TRUE;

   } else {

       return FALSE;
   }
}

//
// inspect a system
//
DWORD
InspectSystem(
    LPCWSTR szProfile,
    LPCWSTR szDatabase,
    LPCWSTR szLogFile,
    AREA_INFORMATION Area
    )
{
   // Spawn a thread to call the engine & inspect the system, since this can
   // take a while and we want to stay responsive & have a change to provide
   // feedback.

    ENGINEARGS ea;
    HANDLE hThread=NULL;

    ea.szProfile = szProfile;
    ea.szDatabase = szDatabase;
    ea.szLog = szLogFile;
    ea.Area = Area;

   AreaProgress *ap = new AreaProgress;
   if ( ap ) {

       ap->Create(IDD_ANALYZE_PROGRESS);
       ap->ShowWindow(SW_SHOW);
       bRangeSet = FALSE;
   }

   ea.pCallback = (PSCE_AREA_CALLBACK_ROUTINE)PostProgressArea;
   ea.hWndCallback = (HANDLE)ap;


  // return InspectSystemEx(&ea);


   hThread = CreateThread(NULL,0,InspectSystemEx,&ea,0,NULL);
   if (!hThread) {
       DWORD rc = GetLastError();

       CString str;
       str.LoadString(IDS_CANT_CREATE_THREAD);
       AfxMessageBox(str);
      // Display an error

      if ( ap ) {
          if ( ap->GetSafeHwnd() )
               ap->DestroyWindow();
          delete ap;
      }
      return rc;
   }

   MSG msg;
   DWORD dw=0;

   DWORD dwTotalTicks=100;
   int n = 0;
   do {
      dw = MsgWaitForMultipleObjects(1,&hThread,0,100,QS_ALLINPUT);
      while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }

   } while (WAIT_OBJECT_0 != dw);

   GetExitCodeThread(hThread,&dw);

   CloseHandle(hThread);

   if ( ap ) {
       if ( ap->GetSafeHwnd() )
            ap->DestroyWindow();
       delete ap;
   }

   return dw;

}

BOOL GetProfileDescription(LPCTSTR ProfileName, LPWSTR* Description)
// Description must be freed by LocalFree
// This should only be called for INF format profiles
{
   PVOID hProfile=NULL;
   SCESTATUS rc;

   if (EngineOpenProfile(ProfileName,OPEN_PROFILE_CONFIGURE,&hProfile) == SCESTATUS_SUCCESS) {
      rc = SceGetScpProfileDescription(
                 hProfile,
                 Description);

      SceCloseProfile(&hProfile);

      if ( rc == SCESTATUS_SUCCESS ) {
         return(TRUE);
      } else {
         return(FALSE);
      }
   } else {
       return FALSE;
   }
}

SCESTATUS
EngineOpenProfile(
        LPCWSTR FileName OPTIONAL,
        int format,
        PVOID* hProfile
        )
{
   SCESTATUS status;
   ENGINEARGS ea;
   DWORD dw;
   HANDLE hThread=NULL;
   CString str;

   if ( !hProfile ) {  // do not check !FileName because it's optional now
     return SCESTATUS_PROFILE_NOT_FOUND;
   }

   if ( (OPEN_PROFILE_LOCALPOL != format) &&
        !FileName ) {
       return SCESTATUS_PROFILE_NOT_FOUND;
   }

   ZeroMemory(&ea, sizeof( ENGINEARGS ) );

   // This is multithreaded for responsiveness, since a
   // crashed jet database can take forever and a day to open.

   // If we can open it quickly (where quickly is defined as within
   // OPEN_DATABASE_TIMEOUT milliseconds then
   if ( (OPEN_PROFILE_ANALYSIS == format) ||
        (OPEN_PROFILE_LOCALPOL == format)) {// JET {
      ea.szProfile = FileName;
      ea.pHandle = hProfile;
      if (OPEN_PROFILE_LOCALPOL == format) {
         ea.dwFlags = SCE_JET_FORMAT;
      } else {
         ea.dwFlags = SCE_JET_ANALYSIS_REQUIRED;
      }

#if SPAWN_OPEN_DATABASE_THREAD
      hThread = CreateThread(NULL,0,OpenDatabaseEx,&ea,0,NULL);

      if ( hThread ) {

          dw = MsgWaitForMultipleObjects(1,&hThread,0,OPEN_DATABASE_TIMEOUT,0);
          if (WAIT_TIMEOUT == dw) {
             status = SCESTATUS_OTHER_ERROR;
          } else {
             GetExitCodeThread(hThread,&status);
          }

          CloseHandle(hThread);

      } else {
          status = GetLastError();
      }
#else
      status = OpenDatabaseEx(&ea);
#endif
      if( status != SCESTATUS_SUCCESS && *hProfile ){
          status = SCESTATUS_INVALID_DATA;
      }

   } else {    // INF
      status = SceOpenProfile( FileName, SCE_INF_FORMAT, hProfile );
   }

   if ( status != SCESTATUS_SUCCESS ){
      *hProfile = NULL;
   }

   return status;
}

void EngineCloseProfile(PVOID* hProfile)
{
    if ( hProfile ) {
        SceCloseProfile(hProfile);
    }
    *hProfile = NULL;
}

BOOL EngineGetDescription(PVOID hProfile, LPWSTR* Desc)
{
    if ( SceGetScpProfileDescription( hProfile, Desc) != SCESTATUS_SUCCESS ) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL IsDomainController( LPCTSTR pszComputer )
{
    //
    // for remote computers, connect to the remote registry
    // currently this api only works for local computer
    //
    SCE_SERVER_TYPE ServerType = SCESVR_UNKNOWN;
        SCESTATUS rc = SceGetServerProductType((LPTSTR)pszComputer, &ServerType);
    return ( (SCESTATUS_SUCCESS == rc) && (SCESVR_DC_WITH_DS == ServerType) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       util.h
//
//  Contents:   definition of CWriteHtmlFile
//
//----------------------------------------------------------------------------
#ifndef __SECMGR_UTIL__
#define __SECMGR_UTIL__

#define MULTISZ_DELIMITER L','
#define MULTISZ_QUOTE L'"'

#define DIALOG_TYPE_ANALYZE     0
#define DIALOG_TYPE_APPLY       1
#define DIALOG_DEFAULT_ANALYZE  2
#define DIALOG_TYPE_REAPPLY     3
#define DIALOG_TYPE_ADD_LOCATION    4
#define DIALOG_FULLPATH_PROFILE     5
#define DIALOG_TYPE_PROFILE     6
#define DIALOG_SAVE_PROFILE     7


#define DW_VALUE_FOREVER    1
#define DW_VALUE_NEVER      2
#define DW_VALUE_NOZERO     4
#define DW_VALUE_OFF        8

#define MERGED_TEMPLATE 1
#define MERGED_INSPECT  2

/////////////////////////////////////////////////////////////////////////////////////////
// CWriteHtmlFile
// Class for writting an html file.
//
// Call Create to create an html file.  If [pszFile] is NULL then, a temporary SCE###.htm
// file is created in the GetTempPath() directory.
//
// After Create has been called, Call Write to write the body of the HTML.
// After the class has been destroyed, the file will be closed.
//
// Get the file name of the HTML by called GetFileName().
class CWriteHtmlFile
{
public:
   CWriteHtmlFile();
   virtual ~CWriteHtmlFile();
   DWORD Create(LPCTSTR pszFile = NULL);
   DWORD Write( LPCTSTR pszString, ... );
   DWORD Write( UINT uRes );
   DWORD CopyTextFile( LPCTSTR pszFile, DWORD dwPosLow = 0, BOOL gInterpret = TRUE);
   DWORD Close( BOOL bDelete );
public:
   int GetFileName( LPTSTR pszFileName, UINT nSize );

protected:
   HANDLE m_hFileHandle;      // The handle of the file.
   BOOL   m_bErrored;         // This is true if an operation fails.
   CString m_strFileName;     // The file name.
};


DWORD MyRegSetValue( HKEY hKeyRoot,
                       LPCTSTR SubKey,
                       LPCTSTR ValueName,
                       const BYTE *Value,
                       const DWORD cbValue,
                       const DWORD pRegType );

DWORD MyRegQueryValue( HKEY hKeyRoot, LPCTSTR SubKey,
                 LPCTSTR ValueName, PVOID *Value, LPDWORD pRegType );
BOOL FilePathExist(LPCTSTR Name, BOOL IsPath, int Flag);

void MyFormatResMessage(SCESTATUS rc, UINT residMessage, PSCE_ERROR_LOG_INFO errBuf,
                     CString& strOut);
void MyFormatMessage(SCESTATUS rc, LPCTSTR mes, PSCE_ERROR_LOG_INFO errBuf,
                     CString& strOut);
DWORD SceStatusToDosError(SCESTATUS SceStatus);

BOOL CreateNewProfile(CString ProfileName, PSCE_PROFILE_INFO *ppspi = NULL);
BOOL SetProfileInfo(LONG_PTR,LONG_PTR,PEDITTEMPLATE);


BOOL GetSceStatusString(SCESTATUS status, CString *strStatus);

void ErrorHandlerEx(WORD, LPTSTR);
#define ErrorHandler() ErrorHandlerEx(__LINE__,TEXT( __FILE__))

bool GetRightDisplayName(LPCTSTR szSystemName, LPCTSTR szName, LPTSTR szDisp, LPDWORD cbDisp);

void DumpProfileInfo(PSCE_PROFILE_INFO pInfo);

HRESULT MyMakeSelfRelativeSD(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew );

PSCE_NAME_STATUS_LIST
MergeNameStatusList(PSCE_NAME_LIST pTemplate, PSCE_NAME_LIST pInspect);

BOOL VerifyKerberosInfo(PSCE_PROFILE_INFO pspi);

DWORD
SceRegEnumAllValues(
    IN OUT PDWORD  pCount,
    IN OUT PSCE_REGISTRY_VALUE_INFO    *paRegValues
    );

#define STATUS_GROUP_MEMBERS    1
#define STATUS_GROUP_MEMBEROF   2
#define STATUS_GROUP_RECORD     3

#define MY__SCE_MEMBEROF_NOT_APPLICABLE  (DWORD)-100

DWORD
GetGroupStatus(
    DWORD status,
    int flag
    );


//+--------------------------------------------------------------------------
//
//  Function: AllocGetTempFileName
//
//  Synopsis: Allocate and return a string with a temporary file name.
//
//  Returns:  The temporary file name, or 0 if a temp file can't be found
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR AllocGetTempFileName();


//+--------------------------------------------------------------------------
//
//  Function: UnexpandEnvironmentVariables
//
//  Synopsis: Given a path, contract any leading members to use matching
//            environment variables, if any
//
//  Arguments:
//            [szPath] - The path to expand
//
//  Returns:  The newly allocated path (NULL if it can't allocate memory)
//
//  History:
//
//---------------------------------------------------------------------------
LPTSTR UnexpandEnvironmentVariables(LPCTSTR szPath);

//
// change system database reg value from "DefaultProfile" to "SystemDatabase"
// temporarily - until UI design change is checked in.
//
#define SYSTEM_DB_REG_VALUE     TEXT("DefaultProfile")

//+--------------------------------------------------------------------------
//
//  Function: IsSystemDatabase
//
//  Synopsis: Determine if a specific databse is the system database or a private one
//
//  Arguments:
//            [szDBPath] - The database path to check
//
//  Returns:  True if szDBPath is the system database, false otherwise
//
//  History:
//
//---------------------------------------------------------------------------
BOOL IsSystemDatabase(LPCTSTR szDBPath);


//+--------------------------------------------------------------------------
//
//  Function: GetSystemDatabase
//
//  Synopsis: Get the name of the current system database
//
//  Arguments:
//            [szDBPath] - [in/out] a pointer for the name of the system database
//                               The caller is responsible for freeing it.
//
//
//  Returns:  S_OK if the system database is found, otherwise an error
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT GetSystemDatabase(CString *szDBPath);



//+--------------------------------------------------------------------------
//
//  Function: ObjectStatusToString
//
//  Synopsis: Convert an object status value to a printable string
//
//  Arguments:
//            [status] - [in]  The status value to convert
//            [str]    - [out] The string to store the value in
//
//
//---------------------------------------------------------------------------
UINT ObjectStatusToString(DWORD status, CString *str);

BOOL
IsSecurityTemplate(                             // Returns TRUE if [pszFileName] is a valid security template
        LPCTSTR pszFileName
        );

DWORD
FormatDBErrorMessage(                   // Returns the string error message for a database return code
        SCESTATUS sceStatus,
        LPCTSTR pszDatabase,
        CString &strOut
        );


int
WriteSprintf(                           // Write format string to file
    IStream *pStm,
    LPCTSTR pszStr,
    ...
    );

int
ReadSprintf(                            // Read format string from IStream
    IStream *pStm,
    LPCTSTR pszStr,
    ...
    );

#define FCE_IGNORE_FILEEXISTS 0x0001   // Ignore file exists problem and delete the
                                       // the file.
DWORD
FileCreateError(
   LPCTSTR pszFile,
   DWORD dwFlags
   );



//+--------------------------------------------------------------------------
//
//  Function:  IsDBCSPath
//
//  Synopsis:  Check if a path contains DBCS characters
//
//  Arguments: [pszFile] - [in]  The path to check
//
//  Returns:   TRUE if pszFile contains characters that can't be
//                  represented by a LPSTR
//
//             FALSE if pszFile only contains characters that can
//                   be represented by a LPSTR
//
//
//+--------------------------------------------------------------------------
BOOL
IsDBCSPath(LPCTSTR pszFile);


//+--------------------------------------------------------------------------
//
//  Function:  GetSeceditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString
GetSeceditHelpFilename();

//+--------------------------------------------------------------------------
//
//  Function:  GetGpeditHelpFilename
//
//  Synopsis:  Return the fully qualified path the help file for Secedit
//
//  Arguments: None
//
//  Returns:   a CString containing the fully qualified help file name.
//
//
//+--------------------------------------------------------------------------
CString GetGpeditHelpFilename();

//+--------------------------------------------------------------------------
//
//  Function:  ExpandEnvironmentStringWrapper
//
//  Synopsis:  Takes an LPTSTR and expands the enviroment variables in it
//
//  Arguments: Pointer to the string to expand.
//
//  Returns:   a CString containing the fully expanded string.
//
//+--------------------------------------------------------------------------
CString ExpandEnvironmentStringWrapper(LPCTSTR psz);

//+--------------------------------------------------------------------------
//
//  Function:  ExpandAndCreateFile
//
//  Synopsis:  Just does a normal CreateFile(), but expands the filename before
//             creating the file.
//
//  Arguments: Same as CreateFile().
//
//  Returns:   HANDLE to the created file.
//
//+--------------------------------------------------------------------------
HANDLE WINAPI ExpandAndCreateFile (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );



//+--------------------------------------------------------------------------
//
//  Function:  GetDefault
//
//  Synopsis:  Find the default values for undefined policies
//
//  Arguments: The IDS_* for the name of the policy
//
//  Returns:   The DWORD to assign as the default value for the policy.
//
//+--------------------------------------------------------------------------
DWORD GetDefault(DWORD dwPolicy);


//+--------------------------------------------------------------------------
//
//  Function:  GetRegDefault
//
//  Synopsis:  Free the default values for undefined policies
//
//  Arguments: The PSCE_REGISTRY_VALUE to find the default for
//
//  Returns:   The DWORD to assign as the default value for the policy.
//
//+--------------------------------------------------------------------------
DWORD GetRegDefault(PSCE_REGISTRY_VALUE_INFO pRV);

//+--------------------------------------------------------------------------
//
//  Function:  IsAdmin
//
//  Synopsis:  Detects if the process is being run in an admin context
//
//  Returns:   TRUE if an admin, FALSE otherwise
//
//+--------------------------------------------------------------------------
BOOL IsAdmin(void);

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToSZ
//
//  Synopsis:  Converts a multiline string to a comma delimited normal string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR MultiSZToSZ(PCWSTR sz);

//+--------------------------------------------------------------------------
//
//  Function:  SZToMultiSZ
//
//  Synopsis:  Converts a comma delimited string to a multiline string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
PWSTR SZToMultiSZ(PCWSTR sz);

//+--------------------------------------------------------------------------
//
//  Function:  MultiSZToDisp
//
//  Synopsis:  Converts a comma delimited multiline string to a display string
//
//  Returns:   The converted string
//
//+--------------------------------------------------------------------------
void MultiSZToDisp(PCWSTR sz, CString &pszOut);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultTemplate
//
//  Synopsis:  Retrieves the default template from the system
//
//  Returns:   The template
//
//+--------------------------------------------------------------------------
SCE_PROFILE_INFO *GetDefaultTemplate();

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultFileSecurity
//
//  Synopsis:  Retrieves the default file security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultFileSecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultRegKeySecurity
//
//  Synopsis:  Retrieves the default registry key security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultRegKeySecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);

//+--------------------------------------------------------------------------
//
//  Function:  GetDefaultserviceSecurity
//
//  Synopsis:  Retrieves the default service security from the system.  The
//             caller is responsible for freeing ppSD and pSeInfo
//
//+--------------------------------------------------------------------------
HRESULT GetDefaultServiceSecurity(PSECURITY_DESCRIPTOR *ppSD, SECURITY_INFORMATION *pSeInfo);


BOOL
LookupRegValueProperty(
    IN LPTSTR RegValueFullName,
    OUT LPTSTR *pDisplayName,
    OUT PDWORD displayType,
    OUT LPTSTR *pUnits OPTIONAL,
    OUT PREGCHOICE *pChoices OPTIONAL,
    OUT PREGFLAGS *pFlags OPTIONAL
    );

BOOL
GetSecureWizardName(
    OUT LPTSTR *ppstrPathName OPTIONAL,
    OUT LPTSTR *ppstrDisplayName OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wrapper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       wrapper.h
//
//----------------------------------------------------------------------------
#ifndef _SECMGR_WRAPPER_H
#define _SECMGR_WRAPPER_H

DWORD ApplyTemplate(LPCWSTR szProfile,LPCWSTR szDatabase, LPCWSTR szLogFile, AREA_INFORMATION Area);

DWORD InspectSystem(LPCWSTR szProfile,LPCWSTR szDatabase, LPCWSTR szLogFile, AREA_INFORMATION Area);
SCESTATUS AssignTemplate(LPCWSTR szTemplate, LPCWSTR szDatabase, BOOL bIncremental);

SCESTATUS EngineOpenProfile(LPCWSTR FileName, int format, PVOID* hProfile);
void EngineCloseProfile(PVOID* hProfile);
BOOL EngineGetDescription(PVOID hProfile, LPWSTR* Desc);

#define ENGINE_DEFAULT_PROFILE      0  // Template being used.
#define ENGINE_DEFAULT_DATABASE     1  // Database being used.

BOOL GetProfileDescription(LPCTSTR ProfileName, LPWSTR* Description);
BOOL IsDomainController( LPCTSTR pszServer = NULL);
extern CRITICAL_SECTION csOpenDatabase;


#define OPEN_PROFILE_ANALYSIS  0
#define OPEN_PROFILE_LOCALPOL  1
#define OPEN_PROFILE_CONFIGURE 2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wsecmgr.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f Snapinps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cookie.h"
#include <scesvc.h>
#include "Snapmgr.h"
#include "wrapper.h"
#include "sceattch.h"
#include "about.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Snapin, CComponentDataExtensionImpl)
    OBJECT_ENTRY(CLSID_SCESnapin, CComponentDataSCEImpl)
    OBJECT_ENTRY(CLSID_SAVSnapin, CComponentDataSAVImpl)
    OBJECT_ENTRY(CLSID_LSSnapin, CComponentDataLSImpl)
    OBJECT_ENTRY(CLSID_RSOPSnapin, CComponentDataRSOPImpl)
    OBJECT_ENTRY(CLSID_SCEAbout, CSCEAbout)
    OBJECT_ENTRY(CLSID_SCMAbout, CSCMAbout)
    OBJECT_ENTRY(CLSID_SSAbout, CSSAbout)
    OBJECT_ENTRY(CLSID_LSAbout, CLSAbout)
    OBJECT_ENTRY(CLSID_RSOPAbout, CRSOPAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT RegisterSnapin(const GUID* pSnapinCLSID,
                       const GUID* pStaticNodeGUID,
                       const GUID* pSnapinAboutGUID,
                       const int nNameResource,
//                       LPCTSTR lpszNameStringNoValueName,
                        LPCTSTR lpszVersion,
                       BOOL bExtension);
HRESULT RegisterSnapin(LPCTSTR lpszSnapinClassID,
                        LPCTSTR lpszStaticNodeGuid,
                       LPCTSTR lpszSnapingAboutGuid,
                       const int nNameResource,
                       LPCTSTR lpszVersion,
                       BOOL bExtension);

HRESULT UnregisterSnapin(const GUID* pSnapinCLSID);
HRESULT UnregisterSnapin(LPCTSTR lpszSnapinClassID);

HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid, LPCTSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription);

HRESULT UnregisterNodeType(const GUID* pGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid);
HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid);

HRESULT RegisterDefaultTemplate(LPCTSTR lpszTemplateDir);
HRESULT RegisterEnvVarsToExpand();

class CSnapinApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CSnapinApp theApp;
const int iStrGuidLen = 128;

BOOL CSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);
    if (!CComponentDataImpl::LoadResources())
        return FALSE;


    InitializeCriticalSection(&csOpenDatabase);

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
    SHFusionUninitialize();

    DeleteCriticalSection(&csOpenDatabase); //Raid #379167, 4/27/2001

    _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{

   // registers object, but not typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CString str;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //
    // unregister some nodes then re-register
    // because some are changed here
    //

    hr = UnregisterSnapin(&CLSID_Snapin);

// not an extension of computer management
    hr = UnregisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin);

    //
    // register the snapin into the console snapin list as SCE
    hr = RegisterSnapin(&CLSID_SCESnapin, &cSCENodeType, &CLSID_SCEAbout,
                        IDS_TEMPLATE_EDITOR_NAME, _T("1.0"), FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    //
    // register the snapin into the console snapin list as SAV
    hr = RegisterSnapin(&CLSID_SAVSnapin, &cSAVNodeType, &CLSID_SCMAbout,
                        IDS_ANALYSIS_VIEWER_NAME, _T("1.0"), FALSE);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    hr = RegisterSnapin(&CLSID_Snapin, &cNodeType, &CLSID_SSAbout,
                        IDS_EXTENSION_NAME, _T("1.0"), TRUE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    hr = RegisterSnapin(&CLSID_RSOPSnapin, &cRSOPNodeType, &CLSID_RSOPAbout,
                        IDS_EXTENSION_NAME, _T("1.0"), TRUE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

#ifdef USE_SEPARATE_LOCALSEC
    hr = RegisterSnapin(&CLSID_LSSnapin, &cLSNodeType, &CLSID_LSAbout,
                        IDS_LOCAL_SECURITY_NAME, _T("1.0"), FALSE );
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
#endif
    // no need to register as extension of computer management snapin
//    str.LoadString(IDS_ANALYSIS_VIEWER_NAME);
//    hr = RegisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin, (LPCTSTR)str);

    //
    // register GPE extension
    // register the snapin as an extension of GPT's Machine node
    //
    OLECHAR szGuid[iStrGuidLen];

    if (0 != ::StringFromGUID2(NODEID_Machine,szGuid,iStrGuidLen))
	{
		str.LoadString(IDS_EXTENSION_NAME);
		hr = RegisterNodeType(szGuid, &CLSID_Snapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    // register the snapin as an extension of GPT's User node
    if (0 != ::StringFromGUID2(NODEID_User,szGuid,iStrGuidLen))
	{
		hr = RegisterNodeType(szGuid, &CLSID_Snapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    if (0 != ::StringFromGUID2(NODEID_RSOPMachine,szGuid,iStrGuidLen))
	{
		str.LoadString(IDS_EXTENSION_NAME);
		hr = RegisterNodeType(szGuid, &CLSID_RSOPSnapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

    // register the snapin as an extension of GPT's User node
    if (0 != ::StringFromGUID2(NODEID_RSOPUser,szGuid,iStrGuidLen))
	{
		hr = RegisterNodeType(szGuid, &CLSID_RSOPSnapin, (LPCTSTR)str);
		if (FAILED(hr))
			return hr;
	}

   //
   // register the default template path
   //
   CString str2;
   LPTSTR sz;
   sz = str.GetBuffer(MAX_PATH);
   if ( 0 == GetWindowsDirectory(sz,MAX_PATH) ) sz[0] = L'\0';
   str.ReleaseBuffer();
   str2.LoadString(IDS_DEFAULT_TEMPLATE_DIR);
   str += str2;

   sz=str.GetBuffer(str.GetLength());
   // Can't put '\' in the registry, so convert to '/'
   while(sz = wcschr(sz,L'\\')) {
      *sz = L'/';
   }
   str.ReleaseBuffer();

   str2.LoadString(IDS_TEMPLATE_LOCATION_KEY);
   str2 += L"\\";
   str2 += str;
   hr = RegisterDefaultTemplate(str2);

   if (FAILED(hr)) {
      return hr;
   }

   hr = RegisterEnvVarsToExpand();
   return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    OLECHAR szGuid[iStrGuidLen];

    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    // unregister the snapin extension nodes

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_SCESnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_SAVSnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_Snapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_LSSnapin);

    // un register the snapin
    hr = UnregisterSnapin(&CLSID_RSOPSnapin);

    // unregister the SCE snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceTemplateServices);

    // unregister the SAV snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceAnalysisServices);

    // unregister the snapin nodes
    hr = UnregisterNodeType(lstruuidNodetypeSceTemplate);

// not an extension of computer management
//    hr = UnregisterNodeType(TEXT(struuidNodetypeSystemTools), &CLSID_Snapin);

    ::StringFromGUID2(NODEID_Machine,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_Snapin);
    ::StringFromGUID2(NODEID_User,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_Snapin);

    ::StringFromGUID2(NODEID_RSOPMachine,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_RSOPSnapin);
    ::StringFromGUID2(NODEID_RSOPUser,szGuid,iStrGuidLen);
    hr = UnregisterNodeType(szGuid, &CLSID_RSOPSnapin);
/*
/*
    // unregister the SCE snapin nodes
    hr = UnregisterNodeType(&cSCENodeType);
    ASSERT(SUCCEEDED(hr));

    // unregister the SAV snapin nodes
    hr = UnregisterNodeType(&cSAVNodeType);
    ASSERT(SUCCEEDED(hr));

    // unregister the snapin nodes
    hr = UnregisterNodeType(&cNodeType);
    ASSERT(SUCCEEDED(hr));
*/

    return S_OK;
}

HRESULT RegisterSnapin(const GUID* pSnapinCLSID, const GUID* pStaticNodeGUID,
                       const GUID* pSnapinAboutGUID,
                       const int nNameResource,
                      // LPCTSTR lpszNameString,
                       LPCTSTR lpszVersion, BOOL bExtension)
{
    USES_CONVERSION;
    OLECHAR szSnapinClassID[iStrGuidLen], szStaticNodeGuid[iStrGuidLen], szSnapinAboutGuid[iStrGuidLen];

    if (0 != ::StringFromGUID2(*pSnapinCLSID, szSnapinClassID, iStrGuidLen)			&&
		0 != ::StringFromGUID2(*pStaticNodeGUID, szStaticNodeGuid, iStrGuidLen)		&&
		0 != ::StringFromGUID2(*pSnapinAboutGUID, szSnapinAboutGuid, iStrGuidLen)		)
	{

		return RegisterSnapin(szSnapinClassID,
							  szStaticNodeGuid,
							  szSnapinAboutGuid,
							  nNameResource,
							  // lpszNameString,
							  lpszVersion,
							  bExtension);
	}
	else
		return E_OUTOFMEMORY;
}

////////////////////////////////////////////////////////////////////////
//
// Registry SCE related reg keys under MMC snapins key
//
//
////////////////////////////////////////////////////////////////////////
HRESULT
RegisterSnapin(LPCTSTR lpszSnapinClassID,
               LPCTSTR lpszStaticNodeGuid,
               LPCTSTR lpszSnapinAboutGuid,
               const int nNameResource,
               LPCTSTR lpszVersion,
               BOOL    bExtension)
{
    //
    // open the MMC Snapins root key
    //

    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE,
                                   SNAPINS_KEY);

    if (lRes != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(lRes); // failed to open
    }

    //
    // create SCE subkey, if already exist, just open it
    //

    CRegKey regkeyThisSnapin;
    lRes = regkeyThisSnapin.Create(regkeySnapins,
                                   lpszSnapinClassID);

    if (lRes == ERROR_SUCCESS) {

        //
        // set values for SCE root key
        //

       //
       // 97068 MUI:MMC:Security:Security Configuration and Analysis Snap-in store its information in the registry
       // 99392 MUI:MMC:Security:Security Templates Snap-in store its information in the registry
       // 97167 MUI:GPE:GPE Extension: Group policy Secuirty snap-in ext name string is stored in the registry
       //
       // MMC now supports NameStringIndirect
       //
       TCHAR achModuleFileName[MAX_PATH+20];
       if (0 < ::GetModuleFileName(
                 AfxGetInstanceHandle(),
                 achModuleFileName,
                 sizeof(achModuleFileName)/sizeof(TCHAR) ))
       {
          CString strNameIndirect;
          strNameIndirect.Format( _T("@%s,-%d"),
                            achModuleFileName,
                            nNameResource);
          lRes = regkeyThisSnapin.SetValue(strNameIndirect,
                                   TEXT("NameStringIndirect"));
       }

        lRes = regkeyThisSnapin.SetValue(lpszStaticNodeGuid,
                                  TEXT("NodeType"));

        lRes = regkeyThisSnapin.SetValue(lpszSnapinAboutGuid,
                                  TEXT("About"));

        lRes = regkeyThisSnapin.SetValue(_T("Microsoft"),
                                  _T("Provider"));

        lRes = regkeyThisSnapin.SetValue(lpszVersion,
                                  _T("Version"));


        //
        // create "NodeTypes" subkey
        //

        CRegKey regkeyNodeTypes;
        lRes = regkeyNodeTypes.Create(regkeyThisSnapin,
                                      TEXT("NodeTypes"));

        if (lRes == ERROR_SUCCESS) {

            //
            // create subkeys for all node types supported by SCE
            //
            // including: services under configuration,
            //            services under analysis
            //            GPT extensions
            //

            lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceTemplateServices,
                                               TEXT("SCE Service Template Extensions"));
            if (lRes == ERROR_SUCCESS) {

                lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceAnalysisServices,
                                                   TEXT("SCE Service Inspection Extensions"));

            }

            if ( bExtension &&
                 lRes == ERROR_SUCCESS ) {

                //
                // NOTE: standalone snapin do not support public key extensions
                //
                // node type for one template in SCE standalone mode,
                // or the root node of SCE under GPE
                //
                CString str;
                str.LoadString(IDS_EXTENSION_NAME);
                lRes = regkeyNodeTypes.SetKeyValue(lstruuidNodetypeSceTemplate,
                                                   (LPCTSTR)str);
                if (lRes == ERROR_SUCCESS) {

                    lRes = RegisterNodeType(lstruuidNodetypeSceTemplate,
                                            (LPCTSTR)str);
                }
            } else if (lRes == ERROR_SUCCESS) {
                //
                // create "Standalone" subkey
                //

                CRegKey regkeyStandalone;
                lRes = regkeyStandalone.Create(regkeyThisSnapin,
                                               TEXT("Standalone"));
                if ( lRes == ERROR_SUCCESS ) {
                    regkeyStandalone.Close();
                }
            }

            //
            // register supported node types to MMC NodeTypes key
            // including all the above node types
            //

            if ( lRes == ERROR_SUCCESS ) {
                lRes = RegisterNodeType(lstruuidNodetypeSceTemplateServices,
                                    TEXT("SCE Service Template Extensions"));
                if (lRes == ERROR_SUCCESS) {

                    lRes = RegisterNodeType(lstruuidNodetypeSceAnalysisServices,
                                            TEXT("SCE Service Analysis Extensions"));
                }
            }

            regkeyNodeTypes.Close();

        }

        regkeyThisSnapin.Close();
    }

    regkeySnapins.Close();

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT UnregisterSnapin(const GUID* pSnapinCLSID)
{
    USES_CONVERSION;
    OLECHAR szSnapinClassID[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,iStrGuidLen))
		return UnregisterSnapin(szSnapinClassID);
	else
		return E_INVALIDARG;
}

HRESULT UnregisterSnapin(LPCTSTR lpszSnapinClassID)
{
    //
    // open MMC Snapins key
    //
    CRegKey regkeySnapins;
    LONG lRes = regkeySnapins.Open(HKEY_LOCAL_MACHINE,
                                   SNAPINS_KEY);

    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    //
    // delete SCE sub key (and all related subkeys under SCE)
    //
    lRes = regkeySnapins.RecurseDeleteKey(lpszSnapinClassID);

    regkeySnapins.Close();

    if ( lRes == ERROR_FILE_NOT_FOUND )
        return S_OK;

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterNodeType(const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return RegisterNodeType(OLE2T(szGuid), lpszNodeDescription);
	else
		return E_INVALIDARG;
}


HRESULT RegisterNodeType(LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    CRegKey regkeyThisNodeType;
    lRes = regkeyThisNodeType.Create(regkeyNodeTypes, lpszNodeGuid);
    ASSERT(lRes == ERROR_SUCCESS);

    if (lRes == ERROR_SUCCESS) {

        lRes = regkeyThisNodeType.SetValue(lpszNodeDescription);

        regkeyThisNodeType.Close();
    }

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT RegisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid, LPCTSTR lpszNodeDescription)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return RegisterNodeType(lpszNodeType, OLE2T(szGuid), lpszNodeDescription);
	else
		return E_INVALIDARG;
}


HRESULT RegisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid, LPCTSTR lpszNodeDescription)
{

    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    if (lRes == ERROR_SUCCESS) {

        CRegKey regkeyThisNodeType;
        lRes = regkeyThisNodeType.Create(regkeyNodeTypes, lpszNodeType );

        if (lRes == ERROR_SUCCESS) {

            CRegKey regkeyExtensions;

            lRes = regkeyExtensions.Create(regkeyThisNodeType, g_szExtensions);

            if ( lRes == ERROR_SUCCESS ) {

                CRegKey regkeyNameSpace;

                lRes = regkeyNameSpace.Create(regkeyExtensions, g_szNameSpace);

                if ( lRes == ERROR_SUCCESS ) {

                    lRes = regkeyNameSpace.SetValue( lpszNodeDescription, lpszNodeGuid );

                    regkeyNameSpace.Close();
                }
                regkeyExtensions.Close();
            }

            regkeyThisNodeType.Close();
        }

        regkeyNodeTypes.Close();

    }
    ASSERT(lRes == ERROR_SUCCESS);

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(const GUID* pGuid)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return UnregisterNodeType(OLE2T(szGuid));
	else
		return E_INVALIDARG;
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeGuid)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);

    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open

    lRes = regkeyNodeTypes.RecurseDeleteKey(lpszNodeGuid);

    regkeyNodeTypes.Close();

    if ( lRes == ERROR_FILE_NOT_FOUND )
        return S_OK;

    return HRESULT_FROM_WIN32(lRes);
}


HRESULT RegisterDefaultTemplate(LPCTSTR lpszTemplateDir)
{
   CRegKey regkeyTemplates;
   CString strKey;
   LONG lRes;

   strKey.LoadString(IDS_TEMPLATE_LOCATION_KEY);

   /*
   lRes = regkeyTemplates.Open(HKEY_LOCAL_MACHINE, strKey);
   ASSERT(lRes == ERROR_SUCCESS);
    if (lRes != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(lRes); // failed to open
    */
   lRes = regkeyTemplates.Create(HKEY_LOCAL_MACHINE,lpszTemplateDir);
    ASSERT(lRes == ERROR_SUCCESS);
    return HRESULT_FROM_WIN32(lRes);
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, const GUID* pGuid)
{
    USES_CONVERSION;
    OLECHAR szGuid[iStrGuidLen];
    if (0 != ::StringFromGUID2(*pGuid,szGuid,iStrGuidLen))
		return UnregisterNodeType(lpszNodeType, OLE2T(szGuid));
	else
		return E_INVALIDARG;
}

HRESULT UnregisterNodeType(LPCTSTR lpszNodeType, LPCTSTR lpszNodeGuid)
{
    CRegKey regkeyNodeTypes;
    LONG lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );

    if (lRes == ERROR_SUCCESS) {

        CRegKey regkeyThisNodeType;
        lRes = regkeyThisNodeType.Open(regkeyNodeTypes, lpszNodeType );

        if (lRes == ERROR_SUCCESS) {

            CRegKey regkeyExtensions;

            lRes = regkeyExtensions.Open(regkeyThisNodeType, g_szExtensions);

            if ( lRes == ERROR_SUCCESS ) {

                CRegKey regkeyNameSpace;

                lRes = regkeyNameSpace.Open(regkeyExtensions, g_szNameSpace);

                if ( lRes == ERROR_SUCCESS ) {

                    lRes = regkeyNameSpace.DeleteValue( lpszNodeGuid );

                    regkeyNameSpace.Close();
                }
                regkeyExtensions.Close();
            }

            regkeyThisNodeType.Close();
        }

        regkeyNodeTypes.Close();


    }

    if ( lRes == ERROR_FILE_NOT_FOUND ) {
        return S_OK;

    } else
        return HRESULT_FROM_WIN32(lRes);

}

HRESULT
RegisterEnvVarsToExpand() {
   CString strKey;
   CString strValue;
   CString strEnvVars;
   TCHAR *pch;
   HRESULT hr;
   HKEY hKey;
   LONG status;

   if (!strKey.LoadString(IDS_SECEDIT_KEY)) {
      return E_FAIL;
   }
   if (!strValue.LoadString(IDS_ENV_VARS_REG_VALUE)) {
      return E_FAIL;
   }
   if (!strEnvVars.LoadString(IDS_DEF_ENV_VARS)) {
      return E_FAIL;
   }

   //
   // Convert strEnvVars' | to '\0' to be a proper multi-sz
   //
   for (int i = 0; i < strEnvVars.GetLength(); i++)
   {
	   if (strEnvVars[i] == L'|')
		   strEnvVars.SetAt(i, L'\0');
   }

   //
   // Open up the key we keep our Environment Variables in
   //
   status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         strKey,
                         0,      // Reserved
                         NULL,   // Class
                         0,      // Options
                         KEY_WRITE,
                         NULL,   // Security
                         &hKey,
                         NULL);

   if (ERROR_SUCCESS != status) {
      return HRESULT_FROM_WIN32(status);
   }

   int iLenth = strEnvVars.GetLength();
   BYTE* pbBufEnvVars = (BYTE*)(strEnvVars.GetBuffer(iLenth));
   status = RegSetValueEx(hKey,
                          strValue,
                          NULL,
                          REG_MULTI_SZ,
                          pbBufEnvVars,
                          iLenth * sizeof(WCHAR));

   strEnvVars.ReleaseBuffer();

   if (ERROR_SUCCESS != status) {
      return HRESULT_FROM_WIN32(status);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\exgrp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
	ExGrp.cpp : implementation file

	CPropertyPage support for Group management wizard
    
    FILE HISTORY:
		Jony		Apr-1996	created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "userlist.h"
#include "ExGrp.h"

#include <lmaccess.h>
#include <lmcons.h>
#include <lmapibuf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExGrp property page

IMPLEMENT_DYNCREATE(CExGrp, CPropertyPage)

CExGrp::CExGrp() : CPropertyPage(CExGrp::IDD)
{
	//{{AFX_DATA_INIT(CExGrp)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pApp = (CRomaineApp*)AfxGetApp();
}

CExGrp::~CExGrp()
{
}

void CExGrp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExGrp)
	DDX_Control(pDX, IDC_GROUP_LIST, m_lbGroupList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExGrp, CPropertyPage)
	//{{AFX_MSG_MAP(CExGrp)
	ON_BN_CLICKED(IDC_ADD_NEW_BUTTON, OnAddNewButton)
	ON_BN_CLICKED(IDC_DELETE_BUTTON, OnDeleteButton)
	ON_WM_SHOWWINDOW()
	ON_LBN_DBLCLK(IDC_GROUP_LIST, OnDblclkGroupList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExGrp message handlers

BOOL CExGrp::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   /*
	int nVal = ClassifyGroup();
	if (nVal == 1) 
		{
		pApp->m_nGroupType = 0;
		pApp->m_cps1.SetActivePage(6); // global group
		}

	else if (nVal == 3)
		{
		pApp->m_nGroupType = 1;
		pApp->m_cps1.SetActivePage(5); // local Group
		}
				*/
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CExGrp::OnWizardNext() 
{
	UpdateData(TRUE);
	USHORT sSel = m_lbGroupList.GetCurSel();

	if (sSel == -1)
		{
		AfxMessageBox(IDS_NO_GROUP_SELECTED);
		return -1;
		}
	
	m_pApp->m_csGroupName = m_lbGroupList.GetGroupName(sSel);

	int sSelType = m_lbGroupList.GetSelType(sSel);
	if (sSelType == 1) 
		{
		m_pApp->m_nGroupType = 0;
		return IDD_GLOBAL_USERS; // global group
		}

	else 
		{
		m_pApp->m_nGroupType = 1;
		return IDD_LOCAL_USERS; // local Group
		}
		
	return CPropertyPage::OnWizardNext();
}

void CExGrp::OnAddNewButton() 
{
	m_pApp->m_cps1.SetActivePage(1);

}

void CExGrp::OnDeleteButton() 
{
	UpdateData(TRUE);

	if (AfxMessageBox(IDS_DELETE_GROUP_CONFIRM, MB_YESNO) != IDYES) return;

	TCHAR* pServer = m_pApp->m_csServer.GetBuffer(m_pApp->m_csServer.GetLength());
	m_pApp->m_csServer.ReleaseBuffer();

	USHORT sSel = m_lbGroupList.GetCurSel();
	if (sSel == -1)
		{
		AfxMessageBox(IDS_NO_GROUP_SELECTED);
		return;
		}

	CString csGroupName = m_lbGroupList.GetGroupName(sSel);
	TCHAR* pGroupName = csGroupName.GetBuffer(csGroupName.GetLength());
	csGroupName.ReleaseBuffer();

	int sSelType = m_lbGroupList.GetSelType(sSel);
	if (sSelType == 1)  // global group
		{
		if (NetGroupDel(pServer, pGroupName) == 0L)
			{
			m_lbGroupList.DeleteString(sSel);
			AfxMessageBox(IDS_GROUP_DELETED);
			}
		else AfxMessageBox(IDS_GROUP_NOT_DELETED);
		}

	else 	 // local Group
		{
		if (NetLocalGroupDel(pServer, pGroupName) == 0L)
			{
			m_lbGroupList.DeleteString(sSel);
			AfxMessageBox(IDS_GROUP_DELETED);
			}
		else AfxMessageBox(IDS_GROUP_NOT_DELETED);
		}

// set a new selection
	 if (m_lbGroupList.GetCount() > 0)
		 {
		 if (sSel == 0) m_lbGroupList.SetCurSel(0);
		 else m_lbGroupList.SetCurSel(sSel - 1);
		 }
	 else m_pApp->m_cps1.SetWizardButtons(PSWIZB_BACK);


}

int CExGrp::ClassifyGroup()
{
	UpdateData(TRUE);

	if (m_pApp->m_csCmdLineGroupName == L"") return 0;

	unsigned short sCount = m_lbGroupList.GetCount();
	unsigned short sCount2 = 0;

	while (sCount2 < sCount)
		{
		if (m_lbGroupList.GetGroupName(sCount2) == m_pApp->m_csCmdLineGroupName)
			return m_lbGroupList.GetSelType(sCount2);

		sCount2++;
		}
	return 0;
}

LRESULT CExGrp::OnWizardBack() 
{
	return IDD_LR_DIALOG;
}

void CExGrp::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	CWaitCursor wait;
	if (bShow) 
		{
// start fresh each time
		m_lbGroupList.ResetContent();

		DWORD dwEntriesRead;
		DWORD dwTotalEntries;
		DWORD dwResumeHandle = 0;

		TCHAR* pServer = m_pApp->m_csServer.GetBuffer(m_pApp->m_csServer.GetLength());
		m_pApp->m_csServer.ReleaseBuffer();

		PLOCALGROUP_INFO_1 pInfo;
		NET_API_STATUS nApi = NetLocalGroupEnum(pServer, (DWORD)1, 
			(PBYTE*)&pInfo,	(DWORD)5000, &dwEntriesRead,
			 &dwTotalEntries, &dwResumeHandle);

		unsigned long sIndex;
		for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
			{
			wchar_t sTemp[150];

			swprintf(sTemp, TEXT("%s;%s"), pInfo[sIndex].lgrpi1_name, pInfo[sIndex].lgrpi1_comment);
			m_lbGroupList.AddString(3, sTemp);
			}

		NetApiBufferFree(pInfo);

		while (dwResumeHandle != 0)
			{
			nApi = NetLocalGroupEnum(pServer, (DWORD)1, 
				(PBYTE*)&pInfo,	(DWORD)5000, &dwEntriesRead,
				 &dwTotalEntries, &dwResumeHandle);

			for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
				{
				wchar_t sTemp[150];

				swprintf(sTemp, TEXT("%s;%s"), pInfo[sIndex].lgrpi1_name, pInfo[sIndex].lgrpi1_comment);
				m_lbGroupList.AddString(3, sTemp);
				}

			NetApiBufferFree(pInfo);
			}

		if (m_pApp->m_bDomain)
			{
			PGROUP_INFO_1 pGInfo1;
			nApi = NetGroupEnum(pServer, (DWORD)1, 
			(PBYTE*)&pGInfo1,	(DWORD)5000, &dwEntriesRead,
			 &dwTotalEntries, &dwResumeHandle);

			for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
				{
				wchar_t sTemp[150];

				swprintf(sTemp, TEXT("%s;%s"), pGInfo1[sIndex].grpi1_name, pGInfo1[sIndex].grpi1_comment);
				m_lbGroupList.AddString(1, sTemp);
				}

			NetApiBufferFree(pGInfo1);

			while (dwResumeHandle != 0)
				{
				nApi = NetGroupEnum(pServer, (DWORD)1, 
				(PBYTE*)&pGInfo1,	(DWORD)5000, &dwEntriesRead,
				 &dwTotalEntries, &dwResumeHandle);

				for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
					{
					wchar_t sTemp[150];

					swprintf(sTemp, TEXT("%s;%s"), pGInfo1[sIndex].grpi1_name, pGInfo1[sIndex].grpi1_comment);
					m_lbGroupList.AddString(1, sTemp);
					}

				NetApiBufferFree(pGInfo1);
				}
			}
		m_lbGroupList.SetCurSel(0);

		if (m_pApp->m_csCmdLine != L"") m_pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
		else  m_pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
		}
	else  m_pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
	
}

void CExGrp::OnDblclkGroupList() 
{
	UpdateData(TRUE);
	USHORT sSel = m_lbGroupList.GetCurSel();
	
	m_pApp->m_csGroupName = m_lbGroupList.GetGroupName(sSel);

	int sSelType = m_lbGroupList.GetSelType(sSel);
	if (sSelType == 1) 
		{
		m_pApp->m_nGroupType = 0;
		m_pApp->m_cps1.SetActivePage(7); // global group
		}

	else 
		{
		m_pApp->m_nGroupType = 1;
		m_pApp->m_cps1.SetActivePage(6); // local Group
		}

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\exgrp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ExGrp.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CExGrp dialog

class CExGrp : public CPropertyPage
{
	DECLARE_DYNCREATE(CExGrp)

// Construction
public:
	CExGrp();
	~CExGrp();

// Dialog Data
	//{{AFX_DATA(CExGrp)
	enum { IDD = IDD_GROUP_LIST_DIALOG };
	CUserList	m_lbGroupList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CExGrp)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CRomaineApp* m_pApp;
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CExGrp)
	virtual BOOL OnInitDialog();
	afx_msg void OnAddNewButton();
	afx_msg void OnDeleteButton();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnDblclkGroupList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int ClassifyGroup();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\wsecmgr\wsecmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
 */
/* Compiler settings for Snapin.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#pragma warning(push,3)

#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif  /* __IComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IComponent : public IUnknown
    {
    public:
    };

#else   /* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IComponent __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IComponent __RPC_FAR * This);

        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)    \
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif  /* C style interface */




#endif  /* __IComponent_INTERFACE_DEFINED__ */



#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SNAPINLib
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_SNAPINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Snapin;
EXTERN_C const CLSID CLSID_LSSnapin;
EXTERN_C const CLSID CLSID_SCESnapin;
EXTERN_C const CLSID CLSID_SAVSnapin;

class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}

#endif
#pragma warning(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\finish.cpp ===
// Finish.cpp : implementation file
//

#include "stdafx.h"
#include "Romaine.h"
#include "Finish.h"
#include "transbmp.h"

#include <lmcons.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <winnetwk.h>
#include <ntsecapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

NTSTATUS OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle);    // resultant policy handle
    

void InitLsaString(
	PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String);                  // source (Unicode)
    
 
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif
 

/////////////////////////////////////////////////////////////////////////////
// CFinish property page

IMPLEMENT_DYNCREATE(CFinish, CPropertyPage)

CFinish::CFinish() : CPropertyPage(CFinish::IDD)
{
	//{{AFX_DATA_INIT(CFinish)
	m_csGroupType = _T("");
	m_csGroupLocation = _T("");
	m_csStaticText1 = _T("");
	m_csStaticText2 = _T("");
	//}}AFX_DATA_INIT
}

CFinish::~CFinish()
{
}

void CFinish::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinish)
	DDX_Text(pDX, IDC_GROUP_TYPE_STATIC, m_csGroupType);
	DDX_Text(pDX, IDC_LOCATION_STATIC, m_csGroupLocation);
	DDX_Text(pDX, IDC_STATIC1, m_csStaticText1);
	DDX_Text(pDX, IDC_STATIC2, m_csStaticText2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinish, CPropertyPage)
	//{{AFX_MSG_MAP(CFinish)
	ON_WM_SHOWWINDOW()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinish message handlers

BOOL CFinish::OnWizardFinish() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	CWaitCursor wait;
	
	UINT uiMessage;
	short sStatus = 0;

	if (pApp->m_nGroupType == 0) 
		{
		TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		pApp->m_csServer.ReleaseBuffer();

		TCHAR* pGroupName = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
		pApp->m_csGroupName.ReleaseBuffer();

// create the global group
		if (pApp->m_sMode == 0)
			{
			PGROUP_INFO_1 gi = (PGROUP_INFO_1)malloc(sizeof(GROUP_INFO_1));
			gi->grpi1_name = pGroupName;
			gi->grpi1_comment = pApp->m_csGroupDesc.GetBuffer(pApp->m_csGroupDesc.GetLength());
			pApp->m_csGroupDesc.ReleaseBuffer();

			DWORD dwErr = NetGroupAdd(pServer,
						1, (LPBYTE)gi, NULL);
			free(gi);
				   
			if (dwErr == 2223)
				{
				AfxMessageBox(IDS_GROUP_EXISTS);
				pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
				pApp->m_cps1.SetActivePage(1);
				return FALSE;
				}

			else if (dwErr == 5)
				{
				AfxMessageBox(IDS_INSUFFICIENT_PERMISSION);
				pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
				pApp->m_cps1.SetActivePage(2);
				return FALSE;
				}
			else if ((dwErr == 1379) || (dwErr == NERR_GroupExists))
				{
				AfxMessageBox(IDS_GROUP_EXISTS);
				pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
				pApp->m_cps1.SetActivePage(1);
				return FALSE;
				}
			else if (dwErr != NERR_Success) 
				{
				AfxMessageBox(IDS_UNKNOWN_ERROR);
				return CPropertyPage::OnWizardFinish();
				}
			}

// build the array of users
		POSITION pos;
		CString csName;

		short sCount = pApp->m_csaNames.GetCount();
		GROUP_USERS_INFO_0* pUsers = (GROUP_USERS_INFO_0*)malloc(sCount * sizeof(GROUP_USERS_INFO_0));
		GROUP_USERS_INFO_0* ppUsers = pUsers;
		for (pos = pApp->m_csaNames.GetHeadPosition(); pos != NULL;)
			{
			csName = pApp->m_csaNames.GetNext(pos);
			TCHAR* pName = (TCHAR*)csName.GetBuffer(csName.GetLength());
			csName.ReleaseBuffer();

			pUsers->grui0_name = (LPTSTR)GlobalAlloc(GPTR, (csName.GetLength() + 1) * sizeof(TCHAR));
			_tcscpy(pUsers->grui0_name, pName);
			pUsers++;
			}

		DWORD dwErr = NetGroupSetUsers(pServer,
				pGroupName,
				0, 
				(BYTE*)ppUsers,
				sCount);

		if (dwErr == NERR_Success) sStatus = 0; // success
		else sStatus = 1; //failure

		void* pTemp = ppUsers;
// clean up names buffer
		while (sCount > 0)
			{
			GlobalFree((HGLOBAL)ppUsers->grui0_name);
			ppUsers++;
			sCount--;
			}	
		free(pTemp);

		}
	else 
		{
		TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		pApp->m_csServer.ReleaseBuffer();

		TCHAR* pGroupName = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
		pApp->m_csGroupName.ReleaseBuffer();

// create the local group
		if (pApp->m_sMode == 0)
			{
			PLOCALGROUP_INFO_1 gi = (PLOCALGROUP_INFO_1)malloc(sizeof(LOCALGROUP_INFO_1));
			gi->lgrpi1_name = pGroupName;
			gi->lgrpi1_comment = pApp->m_csGroupDesc.GetBuffer(pApp->m_csGroupDesc.GetLength());
			DWORD dwErr = NetLocalGroupAdd(pServer,
										1, (LPBYTE)gi, NULL);

			pApp->m_csGroupDesc.ReleaseBuffer();
			free(gi);

			if ((dwErr == 1379)	|| (dwErr == 2223))
				{
				AfxMessageBox(IDS_GROUP_EXISTS);
				pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
				pApp->m_cps1.SetActivePage(1);
				return FALSE;
				}

			else if (dwErr == 5)
				{
				AfxMessageBox(IDS_INSUFFICIENT_PERMISSION);
				pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
				pApp->m_cps1.SetActivePage(2);
				return FALSE;
				}
			else if (dwErr != NERR_Success) 
				{
				AfxMessageBox(IDS_UNKNOWN_ERROR);
				return CPropertyPage::OnWizardFinish();
				}
			}
  
		short sCount = pApp->m_csaNames.GetCount();
		LOCALGROUP_MEMBERS_INFO_0* pMembers = (LOCALGROUP_MEMBERS_INFO_0*)malloc(sCount * sizeof(LOCALGROUP_MEMBERS_INFO_0));
		LOCALGROUP_MEMBERS_INFO_0* ppMembers = pMembers;

// go through the user list and get a SID for each member
		POSITION pos;
		CString csName;
		USHORT uCount = 0;
		for (pos = pApp->m_csaNames.GetHeadPosition(); pos != NULL;)
			{
			CString csName = pApp->m_csaNames.GetNext(pos);
			CString csNameLocation = csName.Left(csName.Find(L"\\"));
// if the account comes from a domain, we need a DC name
			if ((csNameLocation != (pApp->m_csCurrentMachine.Right(pApp->m_csCurrentMachine.GetLength() - 2))) &&
				(csNameLocation != (pApp->m_csServer.Right(pApp->m_csServer.GetLength() - 2))))
				{
				TCHAR* pDCName;
				NET_API_STATUS nAPI = NetGetDCName(NULL,
					csNameLocation.GetBuffer(csNameLocation.GetLength()),
					(LPBYTE*)&pDCName);
				csNameLocation.ReleaseBuffer();
				csNameLocation = pDCName;
				NetApiBufferFree(pDCName);

				if (nAPI != ERROR_SUCCESS)
					{
					AfxMessageBox(IDS_CANT_ADDNAME);
					continue;
					}
				}
			else csNameLocation = pApp->m_csCurrentMachine;

			csName = csName.Right(csName.GetLength() - (csName.Find(L"\\") + 1));

			TCHAR* pNameLocation = csNameLocation.GetBuffer(csNameLocation.GetLength());
			csNameLocation.ReleaseBuffer();

			DWORD sidSize = 0;
			DWORD strSize = 80;
			TCHAR str[80];
			SID_NAME_USE sidType;
			DWORD ret = LookupAccountName(pNameLocation, (LPCTSTR)csName, NULL, &sidSize, str, &strSize, &sidType);

			pMembers->lgrmi0_sid = (PSID)GlobalAlloc(GPTR, sidSize);
			strSize = 80;
			ret=LookupAccountName(pNameLocation, (LPCTSTR)csName, pMembers->lgrmi0_sid, &sidSize, str, &strSize, &sidType);

			pMembers++;
			uCount++;
			} 
			   
		DWORD err = NetLocalGroupSetMembers(pServer,        
                                   pGroupName,
                                   0,                   
                                   (LPBYTE)ppMembers, 
                                   sCount); 
	
		if (err == NERR_Success) uiMessage = IDS_SUCCESS;
		else if ((err == NERR_GroupExists) || (err == 1376) || (err == 1379))
			{
			AfxMessageBox(IDS_GROUP_EXISTS);
			pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
			pApp->m_cps1.SetActivePage(1);
			return FALSE;
			}

		else if (err == 2220) sStatus = 1;
		else sStatus = 1;
		 

#ifdef _DEBUG
		TCHAR tErr[20];
		swprintf(tErr, L"Error = %d\n\r", err);
		TRACE(tErr);
#endif 
		pApp->m_csGroupName.ReleaseBuffer();
		pApp->m_csServer.ReleaseBuffer();	  

		void* pTemp = ppMembers;
// clean up names buffer
		while (uCount > 0)
			{
			GlobalFree(ppMembers->lgrmi0_sid);
			ppMembers++;
			uCount--;
			}	
		free(pTemp);
		}	   

	if (pApp->m_csCmdLine != L"") //cmdline - no restart
		{
		if (pApp->m_sMode == 0)//create new
			{
			if (sStatus == 0) uiMessage = IDS_SUCCESS;
			else uiMessage = IDS_CANT_ADD_NAMES;
			}
		else // modify
			{
			if (sStatus == 0) uiMessage = IDS_SUCCESS;
			else uiMessage = IDS_CANT_ADD_NAMES;
			}

		AfxMessageBox(uiMessage);
		return CPropertyPage::OnWizardFinish();
		}

	else
		{
		if (pApp->m_sMode == 0)//create new
			{
			if (sStatus == 0) 
				{
// clear out old values
				pApp->m_csGroupName = L"";
				pApp->m_csGroupDesc = L"";

				uiMessage = IDS_SUCCESS_CREATE_RETRY;
				}
			else uiMessage = IDS_CANT_ADD_NAMES_CREATE_RETRY;
			}
		else // modify
			{
			if (sStatus == 0) 
				{
// clear out old values
				pApp->m_csGroupName = L"";
				pApp->m_csGroupDesc = L"";

				uiMessage = IDS_SUCCESS_MODIFY_RETRY;
				}
			else uiMessage = IDS_CANT_ADD_NAMES_MODIFY_RETRY;
			}

		if (AfxMessageBox(uiMessage, MB_YESNO | MB_ICONEXCLAMATION) == IDYES) 
			{

		// clear out old info
			pApp->m_csaNames.RemoveAll();
			pApp->bRestart1 = TRUE;
			pApp->bRestart2 = TRUE;
			pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
			pApp->m_cps1.SetActivePage(1);
			return FALSE;
			}
		}

	return CPropertyPage::OnWizardFinish();
}

void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String)
{
    DWORD StringLength;
 
    if (String == NULL) 
		{
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
		}
 
    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}
 
NTSTATUS OpenPolicy(LPWSTR ServerName, DWORD DesiredAccess,	PLSA_HANDLE PolicyHandle)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
 
    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
 
    if (ServerName != NULL) 
		{
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
		}
 
    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle);
}

void CFinish::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (bShow)
		{
		if (pApp->m_nGroupType == 1)
			m_csGroupType.LoadString(IDS_LOCAL_GROUP);
		else
			m_csGroupType.LoadString(IDS_GLOBAL_GROUP);

		m_csGroupType += pApp->m_csGroupName;

		if (pApp->m_bDomain)
			m_csGroupLocation = pApp->m_csDomain;
		else
			m_csGroupLocation = pApp->m_csServer;

		if (pApp->m_sMode == 1) 
			{
			m_csStaticText1.LoadString(IDS_MODIFY_TEXT);
			m_csStaticText2.LoadString(IDS_MODIFY_TEXT2);
			}
		else
			{
			m_csStaticText1.LoadString(IDS_CREATE_TEXT);
			m_csStaticText2.LoadString(IDS_CREATE_TEXT2);
			}

		UpdateData(FALSE);
		}
	
}

void CFinish::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	CTransBmp* pBitmap = new CTransBmp;
	pBitmap->LoadBitmap(IDB_END_FLAG);

	pBitmap->DrawTrans(&dc, 0,0);
	delete pBitmap;

}

LRESULT CFinish::OnWizardBack() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	
	if (pApp->m_nGroupType == 0) return IDD_GLOBAL_USERS;
	else return IDD_LOCAL_USERS;

}


// im using the LSA functions as the std LookupAccountName doesn't work on Local Users
	/*
		LSA_HANDLE Policy_Handle;
		NTSTATUS Status;

		LPTSTR lpServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		Status = OpenPolicy(lpServer, POLICY_LOOKUP_NAMES, &Policy_Handle);

// Did OpenPolicy work?
		if (Status != STATUS_SUCCESS) 
			{
			AfxMessageBox(IDS_CANT_ADD_NAMES);
			pApp->m_csServer.ReleaseBuffer();
			return CPropertyPage::OnWizardFinish();
			}

		POSITION pos;
		CString csName;
		LPWSTR lpName;
		USHORT uCount = 0;
	    LSA_UNICODE_STRING lusName;
	    PLSA_UNICODE_STRING plusName = NULL;
		BYTE domainbuffer[1000];
 		PLSA_REFERENCED_DOMAIN_LIST lsarDomainList = (PLSA_REFERENCED_DOMAIN_LIST)&domainbuffer;

		BYTE sidbuffer[100];
		PLSA_TRANSLATED_SID lsatSID = (PLSA_TRANSLATED_SID)&sidbuffer;

		for (pos = pApp->m_csaNames.GetHeadPosition(); pos != NULL;)
			{
			csName = pApp->m_csaNames.GetNext(pos);
			lpName = csName.GetBuffer(csName.GetLength());
			InitLsaString(&lusName, lpName);	// Make a LSA_UNICODE_STRING out of the LPWSTR passed in
			plusName = &lusName;

			Status = LsaLookupNames(Policy_Handle,
				1,								// count
				plusName,						// LSA_UNICODE_STRING
				&lsarDomainList,
				&lsatSID);

			ULONG uErr = LsaNtStatusToWinError(Status);
			if (!uErr) // success
				{
				NetLocalGroupAddMember(lpServer,
					pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength()),


				}
			csName.ReleaseBuffer();
			}  		

		
		pApp->m_csServer.ReleaseBuffer();	
					  */
/*	BYTE sidbuffer[100];
	PSID pSID = (PSID)&sidbuffer; 
	DWORD cbSID = 100;
	TCHAR domainBuffer[80];
	DWORD domainBufferSize = 80;
	SID_NAME_USE snu;

	BOOL bRet = LookupAccountName((const TCHAR*)pApp->m_csServer,
		L"Guest", 
		pSID, 
		&cbSID,
		domainBuffer,
		&domainBufferSize,
		&snu);

	TRACE(L"blob");	  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\gusers.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
	GUsers.cpp : implementation file

	CPropertyPage support for Group management wizard
    
    FILE HISTORY:
		Jony		Apr-1996	created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "userlist.h"
#include "GUsers.h"

#include <lmcons.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <winnetwk.h>
#include <winreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGUsers property page

IMPLEMENT_DYNCREATE(CGUsers, CPropertyPage)

CGUsers::CGUsers() : CPropertyPage(CGUsers::IDD)
{
	//{{AFX_DATA_INIT(CGUsers)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CGUsers::~CGUsers()
{
}

void CGUsers::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGUsers)
	DDX_Control(pDX, IDC_SELECTED_MEMBERS_LIST, m_lbSelectedUsers);
	DDX_Control(pDX, IDC_AVAILABLE_MEMBERS_LIST, m_lbAvailableUsers);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGUsers, CPropertyPage)
	//{{AFX_MSG_MAP(CGUsers)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_LBN_SETFOCUS(IDC_AVAILABLE_MEMBERS_LIST, OnSetfocusAvailableMembersList)
	ON_LBN_SETFOCUS(IDC_SELECTED_MEMBERS_LIST, OnSetfocusSelectedMembersList)
	ON_WM_SHOWWINDOW()
	ON_LBN_DBLCLK(IDC_AVAILABLE_MEMBERS_LIST, OnDblclkAvailableMembersList)
	ON_LBN_DBLCLK(IDC_SELECTED_MEMBERS_LIST, OnDblclkSelectedMembersList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGUsers message handlers
// enum users thread
void CGUsers::EnumUsers(TCHAR* lpszPrimaryDC)
{
	CString csTemp;

// now enumerate the users on that machine
	void* netUserBuffer;
	DWORD dwReturnedEntries;
	DWORD err = NetQueryDisplayInformation(lpszPrimaryDC, 1,
		0, 100, 100 * sizeof(NET_DISPLAY_USER),
		&dwReturnedEntries, &netUserBuffer);

// check return for error
	if (err != NERR_Success && err != ERROR_MORE_DATA) return;

// add these users to the dialog
	DWORD dwCurrent;
	NET_DISPLAY_USER* netUser;
	netUser = (NET_DISPLAY_USER*)netUserBuffer;
	for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
		{
		csTemp = netUser->usri1_name;
		if (netUser->usri1_flags & UF_NORMAL_ACCOUNT) m_lbAvailableUsers.AddString(0, csTemp);
//		else m_lbAvailableUsers.AddString(4, csTemp);
		
		netUser++;
		}
			
// add more users?
	DWORD dwNext;
	while (err == ERROR_MORE_DATA)
		{
		netUser--;
		NetGetDisplayInformationIndex(lpszPrimaryDC, 1, netUser->usri1_name, &dwNext);
		NetApiBufferFree(netUserBuffer);
		err = NetQueryDisplayInformation(lpszPrimaryDC, 1,
			dwNext, 100, 32767,
			&dwReturnedEntries, &netUserBuffer);

// check return for error
		if (err != NERR_Success && err != ERROR_MORE_DATA) return;

		netUser = (NET_DISPLAY_USER*)netUserBuffer;
		for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
			{
			csTemp = netUser->usri1_name;
			if (netUser->usri1_flags & UF_NORMAL_ACCOUNT) m_lbAvailableUsers.AddString(0, csTemp);
//			else m_lbAvailableUsers.AddString(4, csTemp);
			netUser++;
			}
		}

	NetApiBufferFree(netUserBuffer);
						 
}

LRESULT CGUsers::OnWizardBack() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (pApp->m_bServer) return IDD_GROUP_TYPE_DLG;
	else if (pApp->m_csCmdLine != L"") return IDD_GROUP_LIST_DIALOG;
	else if (pApp->m_sMode == 1) return IDD_GROUP_LIST_DIALOG;
	else return IDD_LR_DIALOG;
	
}

void CGUsers::OnAddButton() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbAvailableUsers.GetCurSel();
	if (usSel == 65535) 
		{
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		m_lbSelectedUsers.SetCurSel(0);
		return;
		}

	CString csSel;
	m_lbAvailableUsers.GetText(usSel, csSel);
	ULONG ulBmp = m_lbAvailableUsers.GetItemData(usSel);
	m_lbSelectedUsers.AddString(csSel, ulBmp);
	m_lbAvailableUsers.DeleteString(usSel);

// anybody left?
	if (m_lbAvailableUsers.GetCount() != 0)
		m_lbAvailableUsers.SetCurSel(0);

	else
		{
		m_lbSelectedUsers.SetCurSel(0);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		m_lbAvailableUsers.SetHorizontalExtent(0);
		}

}

void CGUsers::OnRemoveButton() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbSelectedUsers.GetCurSel();
	if (usSel == 65535) 
		{
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		m_lbAvailableUsers.SetCurSel(0);
		return;
		}

	CString csSel;
	m_lbSelectedUsers.GetText(usSel, csSel);
	ULONG ulBmp = m_lbSelectedUsers.GetItemData(usSel);
	m_lbAvailableUsers.AddString(csSel, ulBmp);
	m_lbSelectedUsers.DeleteString(usSel);

// anybody left?
	if (m_lbSelectedUsers.GetCount() != 0)
		m_lbSelectedUsers.SetCurSel(0);

	else
		{
		m_lbAvailableUsers.SetCurSel(0);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		m_lbSelectedUsers.SetHorizontalExtent(0);
		}

}

void CGUsers::OnSetfocusAvailableMembersList() 
{
	CWnd* pWnd = GetDlgItem(IDC_ADD_BUTTON);
	pWnd->EnableWindow(TRUE);

	pWnd = GetDlgItem(IDC_REMOVE_BUTTON);
	pWnd->EnableWindow(FALSE);

	m_lbSelectedUsers.SetCurSel(-1);
	
}

void CGUsers::OnSetfocusSelectedMembersList() 
{
	CWnd* pWnd = GetDlgItem(IDC_ADD_BUTTON);
	pWnd->EnableWindow(FALSE);

	pWnd = GetDlgItem(IDC_REMOVE_BUTTON);
	pWnd->EnableWindow(TRUE);
	
	m_lbAvailableUsers.SetCurSel(-1);
}

LRESULT CGUsers::OnWizardNext() 
{
	UpdateData(TRUE);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_cps1.SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);
	

// empty the list
	pApp->m_csaNames.RemoveAll();

// fill with new names.
	USHORT us;
	CString csTemp;
	for (us = 0; us < m_lbSelectedUsers.GetCount(); us++)
		{
		m_lbSelectedUsers.GetText(us, csTemp);
		pApp->m_csaNames.AddHead(csTemp);
		}
	return CPropertyPage::OnWizardNext();
}

void CGUsers::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();

	CWaitCursor wait;
	if (bShow)
		{
		if (m_csServer != pApp->m_csServer) 
			{
			m_csServer = pApp->m_csServer;
			m_lbSelectedUsers.ResetContent();
			}
// on a rerun clean out the members from the last group
		else if (pApp->bRestart2) 
			{
			m_lbSelectedUsers.ResetContent();
			pApp->bRestart2 == FALSE;
			}
		else return;

		m_lbAvailableUsers.ResetContent();
		TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		pApp->m_csServer.ReleaseBuffer();
		EnumUsers(pServer);

// editing a group? add the current members
		if (pApp->m_sMode == 1)
			{
			DWORD dwEntriesRead;
			DWORD dwTotalEntries;
			DWORD dwResumeHandle = 0;
			
			m_lbSelectedUsers.ResetContent();

			TCHAR* pGroup = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
			pApp->m_csGroupName.ReleaseBuffer();

			PGROUP_USERS_INFO_0 pMembers;
			NET_API_STATUS nApi = NetGroupGetUsers(pServer,
				pGroup,
				0,
				(LPBYTE*)&pMembers,
				5000,
				&dwEntriesRead,
				&dwTotalEntries, 
				&dwResumeHandle);
			if (nApi != ERROR_SUCCESS) 
				{
				AfxMessageBox(IDS_CANT_GET_USERS);
				goto keepgoing;
				}

			USHORT sIndex;
			for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
				{
				wchar_t sTemp[150];
				swprintf(sTemp, TEXT("%s"), pMembers[sIndex].grui0_name);

				m_lbSelectedUsers.AddString(0, sTemp);
				}

			NetApiBufferFree(pMembers);

			while (dwResumeHandle != 0)
				{
				nApi = NetGroupGetUsers(pServer,
					pGroup,
					0,
					(LPBYTE*)&pMembers,
					5000,
					&dwEntriesRead,
					&dwTotalEntries, 
					&dwResumeHandle);
				if (nApi != ERROR_SUCCESS) 
					{
					AfxMessageBox(IDS_CANT_GET_USERS);
					goto keepgoing;
					}

				USHORT sIndex;
				for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
					{
					wchar_t sTemp[150];
					swprintf(sTemp, TEXT("%s"), pMembers[sIndex].grui0_name);

					m_lbSelectedUsers.AddString(0, sTemp);
					}
				NetApiBufferFree(pMembers);
				}
			}


keepgoing:
		m_lbSelectedUsers.SetHorizontalExtent(200);
		m_lbAvailableUsers.SetHorizontalExtent(200);

// now clean up list to remove those users already added
		USHORT sValueCount = m_lbSelectedUsers.GetCount();
		USHORT sCount, sSel;
		CString csValue;
		for (sCount = 0; sCount < sValueCount; sCount++)
			{
			m_lbSelectedUsers.GetText(sCount, csValue);
			m_lbAvailableUsers.SelectString(-1, csValue);
			sSel = m_lbAvailableUsers.GetCurSel();
			m_lbAvailableUsers.DeleteString(sSel);
			}

		m_lbAvailableUsers.SetCurSel(0);
		}
	
}

void CGUsers::OnDblclkAvailableMembersList() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbAvailableUsers.GetCurSel();
	CString csSel;
	m_lbAvailableUsers.GetText(usSel, csSel);
	ULONG ulBmp = m_lbAvailableUsers.GetItemData(usSel);
	m_lbSelectedUsers.AddString(csSel, ulBmp);
	m_lbAvailableUsers.DeleteString(usSel);

// anybody left?
	if (m_lbAvailableUsers.GetCount() != 0)
		m_lbAvailableUsers.SetCurSel(0);

	else
		{
		m_lbSelectedUsers.SetCurSel(0);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		m_lbAvailableUsers.SetHorizontalExtent(0);
		}
	
}

void CGUsers::OnDblclkSelectedMembersList() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbSelectedUsers.GetCurSel();
	CString csSel;
	m_lbSelectedUsers.GetText(usSel, csSel);
	ULONG ulBmp = m_lbSelectedUsers.GetItemData(usSel);
	m_lbAvailableUsers.AddString(csSel, ulBmp);
	m_lbSelectedUsers.DeleteString(usSel);

// anybody left?
	if (m_lbSelectedUsers.GetCount() != 0)
		m_lbSelectedUsers.SetCurSel(0);

	else
		{
		m_lbAvailableUsers.SetCurSel(0);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		m_lbSelectedUsers.SetHorizontalExtent(0);
		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\finish.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Finish.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CFinish dialog

class CFinish : public CPropertyPage
{
	DECLARE_DYNCREATE(CFinish)

// Construction
public:
	CFinish();
	~CFinish();

// Dialog Data
	//{{AFX_DATA(CFinish)
	enum { IDD = IDD_FINISH_DLG };
	CString	m_csGroupType;
	CString	m_csGroupLocation;
	CString	m_csStaticText1;
	CString	m_csStaticText2;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinish)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinish)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\lrem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    LRem.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CLRem dialog

class CLRem : public CPropertyPage
{
	DECLARE_DYNCREATE(CLRem)

// Construction
public:
	CLRem();
	~CLRem();

// Dialog Data
	//{{AFX_DATA(CLRem)
	enum { IDD = IDD_LR_DIALOG };
	int		m_nLocation;
	CString	m_csStatic1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLRem)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLRem)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\gusers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    GUsers.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CGUsers dialog

class CGUsers : public CPropertyPage
{
	DECLARE_DYNCREATE(CGUsers)

// Construction
public:
	CGUsers();
	~CGUsers();

// Dialog Data
	//{{AFX_DATA(CGUsers)
	enum { IDD = IDD_GLOBAL_USERS };
	CUserList	m_lbSelectedUsers;
	CUserList	m_lbAvailableUsers;
	//}}AFX_DATA

	int m_nMax;
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGUsers)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
private:
	void EnumUsers(TCHAR* lpszPrimaryDC);
	CString m_csServer;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGUsers)
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnSetfocusAvailableMembersList();
	afx_msg void OnSetfocusSelectedMembersList();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnDblclkAvailableMembersList();
	afx_msg void OnDblclkSelectedMembersList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\lrem.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
	LRem.cpp : implementation file

	CPropertyPage support for Group management wizard
    
    FILE HISTORY:
		Jony		Apr-1996	created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "LRem.h"

#include <lmcons.h>
#include <lmaccess.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern int ClassifyMachine(CString& csMachineName);

/////////////////////////////////////////////////////////////////////////////
// CLRem property page

IMPLEMENT_DYNCREATE(CLRem, CPropertyPage)

CLRem::CLRem() : CPropertyPage(CLRem::IDD)
{
	//{{AFX_DATA_INIT(CLRem)
	m_nLocation = 0;
	m_csStatic1 = _T("");
	//}}AFX_DATA_INIT
}

CLRem::~CLRem()
{
}

void CLRem::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLRem)
	DDX_Radio(pDX, IDC_LOCAL_RADIO, m_nLocation);
	DDX_Text(pDX, IDC_STATIC1, m_csStatic1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLRem, CPropertyPage)
	//{{AFX_MSG_MAP(CLRem)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLRem message handlers

LRESULT CLRem::OnWizardNext() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();

	UpdateData(TRUE);
	if (m_nLocation == 0)
		{
		int nVal = ClassifyMachine(pApp->m_csCurrentMachine);

	// if we are creating a new group, go ahead and check the name for uniqueness
		if (pApp->m_sMode == 0)
			{
			TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
			pApp->m_csServer.ReleaseBuffer();

			TCHAR* pGroupName = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
			pApp->m_csGroupName.ReleaseBuffer();

			GROUP_INFO_0* pInfo;
			NET_API_STATUS nAPI = NetGroupGetInfo(pServer,
				pGroupName,
				0,
				(LPBYTE*)&pInfo);

			if (nAPI == ERROR_SUCCESS)
				{
				AfxMessageBox(IDS_GROUP_EXISTS);
				return IDD_NAME_DLG;
				}

			LOCALGROUP_INFO_0* pLInfo;
			nAPI = NetLocalGroupGetInfo(pServer,
				pGroupName,
				0,
				(LPBYTE*)&pLInfo);

			if (nAPI == ERROR_SUCCESS)
				{
				AfxMessageBox(IDS_GROUP_EXISTS);
				return IDD_NAME_DLG;
				}
			}
		return nVal;
		}

	else return IDD_MACHINE_DLG;
	
}

void CLRem::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	UpdateData(TRUE);
	if (bShow)
		{
		CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
		if (pApp->m_sMode == 1) m_csStatic1.LoadString(IDS_MODIFY3);
		else m_csStatic1.LoadString(IDS_CREATE3);
		UpdateData(FALSE);
		}
	
}

LRESULT CLRem::OnWizardBack() 
{
	UpdateData(TRUE);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (pApp->m_sMode == 1) return IDD_WELCOME_DLG;
	else return IDD_NAME_DLG;

	return CPropertyPage::OnWizardBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\lusers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    LUsers.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CLUsers dialog

class CLUsers : public CPropertyPage
{
	DECLARE_DYNCREATE(CLUsers)

// Construction
public:
	CLUsers();
	~CLUsers();

// Dialog Data
	//{{AFX_DATA(CLUsers)
	enum { IDD = IDD_LOCAL_USERS };
	CUserList	m_lbAddedUserList;
	CUserList	m_lbAvailableUserList;
	CComboBox	m_csDomainList;
	CString	m_csDomainName;
	CString	m_csAvailableUserList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLUsers)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLUsers)
	virtual BOOL OnInitDialog();
	afx_msg void OnAddButton();
	afx_msg void OnSelchangeDomainCombo();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnDblclkAddedLocalUsers();
	afx_msg void OnDblclkAvailableLocalUsers();
	afx_msg void OnSetfocusAvailableLocalUsers();
	afx_msg void OnSetfocusAddedLocalUsers();
	afx_msg void OnRemoveButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void LoadDomainList();
	void CatalogAccounts(const TCHAR* lpDomain, CUserList& pListBox, BOOL bLocal = FALSE);

	CStringArray m_csaDomainList;
	CString m_csMyMachineName; 
	CString m_csPrimaryDomain;
	CString	m_csServer;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\lusers.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
	LUsers.cpp : implementation file

	CPropertyPage support for Group management wizard
    
    FILE HISTORY:
		Jony		Apr-1996	created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "userlist.h"
#include "LUsers.h"
#include "trstlist.h"

#include <winreg.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <winnetwk.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// some global objects used in the EnumUsers and EnumGroups threads
CStringList csaNames;
CStringList csaLNames;
CStringList csaGroups;
void EnumGroups(DWORD pDCName);
void EnumLocalGroups(DWORD pDCName);
void EnumUsers(DWORD pDCName);

/////////////////////////////////////////////////////////////////////////////
// CLUsers property page

IMPLEMENT_DYNCREATE(CLUsers, CPropertyPage)

CLUsers::CLUsers() : CPropertyPage(CLUsers::IDD)
{
	//{{AFX_DATA_INIT(CLUsers)
	m_csDomainName = _T("");
	m_csAvailableUserList = _T("");
	//}}AFX_DATA_INIT
}

CLUsers::~CLUsers()
{
}

void CLUsers::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLUsers)
	DDX_Control(pDX, IDC_ADDED_LOCAL_USERS, m_lbAddedUserList);
	DDX_Control(pDX, IDC_AVAILABLE_LOCAL_USERS, m_lbAvailableUserList);
	DDX_Control(pDX, IDC_DOMAIN_COMBO, m_csDomainList);
	DDX_CBString(pDX, IDC_DOMAIN_COMBO, m_csDomainName);
	DDX_LBString(pDX, IDC_AVAILABLE_LOCAL_USERS, m_csAvailableUserList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLUsers, CPropertyPage)
	//{{AFX_MSG_MAP(CLUsers)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_CBN_SELCHANGE(IDC_DOMAIN_COMBO, OnSelchangeDomainCombo)
	ON_WM_SHOWWINDOW()
	ON_LBN_DBLCLK(IDC_ADDED_LOCAL_USERS, OnDblclkAddedLocalUsers)
	ON_LBN_DBLCLK(IDC_AVAILABLE_LOCAL_USERS, OnDblclkAvailableLocalUsers)
	ON_LBN_SETFOCUS(IDC_AVAILABLE_LOCAL_USERS, OnSetfocusAvailableLocalUsers)
	ON_LBN_SETFOCUS(IDC_ADDED_LOCAL_USERS, OnSetfocusAddedLocalUsers)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLUsers message handlers

BOOL CLUsers::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


// launch two threads to enumerate the global groups and user accounts in the selected domain
void CLUsers::CatalogAccounts(const TCHAR* lpDomain, CUserList& pListBox, BOOL bLocal /* = FALSE*/)
{
	CWaitCursor wait;
	wchar_t lpwDomain[255];
	 _tcscpy(lpwDomain, lpDomain);
 	
	wchar_t* lpszPrimaryDC = NULL;

	NET_API_STATUS err = 0;
// first get the name of the PDC machine
   	if (bLocal) 
		{
		lpszPrimaryDC = (TCHAR*)malloc((_tcslen(lpDomain) + 1)* sizeof(TCHAR));
		_tcscpy(lpszPrimaryDC, lpDomain);
		}

	else
		err = NetGetDCName( NULL,                        // Local Machine 
			                lpwDomain,                  // Domain Name
				            (LPBYTE *)&lpszPrimaryDC );  // returned PDC *
 
// empty the listbox
	pListBox.ResetContent();

	if (err != 0)
		{
		AfxMessageBox(IDS_GENERIC_NO_PDC, MB_ICONEXCLAMATION);
		return;
		}

	csaNames.RemoveAll();
	csaLNames.RemoveAll();
	csaGroups.RemoveAll();

// create a thread each for names and groups. Run them simultaneously to save some time.
	HANDLE hThreads[2];
	USHORT usObjCount = 2;
	DWORD dwThreadID;
	hThreads[0] = ::CreateThread(NULL, 100, 
		(LPTHREAD_START_ROUTINE)EnumUsers,
		lpszPrimaryDC,
		0,
		&dwThreadID);

	if (!bLocal) 
		{
		hThreads[1] = ::CreateThread(NULL, 100, 
		(LPTHREAD_START_ROUTINE)EnumGroups,
		lpszPrimaryDC,
		0,
		&dwThreadID);
		}
	else usObjCount = 1;
		 
// when both threads return, add all the names to the listbox.
	DWORD dwWait = WaitForMultipleObjects(usObjCount,
		hThreads,
		TRUE,
		INFINITE);

	POSITION pos;
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();

	for (pos = csaNames.GetHeadPosition(); pos != NULL;)
		pListBox.AddString(0, csaNames.GetNext(pos));

	if (!bLocal)
		{
		for (pos = csaGroups.GetHeadPosition(); pos != NULL;)
			pListBox.AddString(1, csaGroups.GetNext(pos));
		}
	
	if (!bLocal) NetApiBufferFree( lpszPrimaryDC );
	else free(lpszPrimaryDC);
				
}


// enum users thread
void EnumUsers(DWORD pDCName)
{
	wchar_t* lpszPrimaryDC = NULL;
	lpszPrimaryDC = (TCHAR*)pDCName;
	CString csTemp;

// now enumerate the users on that machine
	void* netUserBuffer;
	DWORD dwReturnedEntries;
	DWORD err = NetQueryDisplayInformation(lpszPrimaryDC, 1,
		0, 100, 100 * sizeof(NET_DISPLAY_USER),
		&dwReturnedEntries, &netUserBuffer);

// check return for error
	if (err != NERR_Success && err != ERROR_MORE_DATA) return;

// add these users to the dialog
	DWORD dwCurrent;
	NET_DISPLAY_USER* netUser;
	netUser = (NET_DISPLAY_USER*)netUserBuffer;
	for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
		{
		csTemp = netUser->usri1_name;
		csTemp += ";";
		csTemp += netUser->usri1_comment;

		if (netUser->usri1_flags & UF_NORMAL_ACCOUNT) csaNames.AddHead(csTemp);
		else csaLNames.AddHead(csTemp);

		netUser++;
		}
	
// add more users?
	DWORD dwNext;
	while (err == ERROR_MORE_DATA)
		{
		netUser--;
		NetGetDisplayInformationIndex(lpszPrimaryDC, 1, netUser->usri1_name, &dwNext);
		NetApiBufferFree(netUserBuffer);
		err = NetQueryDisplayInformation(lpszPrimaryDC, 1,
			dwNext, 100, 32767,
			&dwReturnedEntries, &netUserBuffer);

// check return for error
		if (err != NERR_Success && err != ERROR_MORE_DATA) return;

		netUser = (NET_DISPLAY_USER*)netUserBuffer;
		for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
			{
			csTemp = netUser->usri1_name;
			csTemp += ";";
			csTemp += netUser->usri1_comment;

			if (netUser->usri1_flags & UF_NORMAL_ACCOUNT) csaNames.AddHead(csTemp);
			else csaLNames.AddHead(csTemp);
			netUser++;
			}
		}

	NetApiBufferFree(netUserBuffer);

}


void EnumGroups(DWORD pDCName)
{
	wchar_t* lpszPrimaryDC = NULL;
	lpszPrimaryDC = (TCHAR*)pDCName;
	CString csTemp;

	void* netGroupBuffer;
	DWORD dwReturnedEntries;
	DWORD dwCurrent;
	DWORD dwNext;
// now enumerate the groups on that machine
	DWORD err = NetQueryDisplayInformation(lpszPrimaryDC, 3,
		0, 100, 100 * sizeof(NET_DISPLAY_GROUP),
		&dwReturnedEntries, &netGroupBuffer);

// check return for error
	if (err != NERR_Success && err != ERROR_MORE_DATA) return;

	NET_DISPLAY_GROUP* netGroup;
	netGroup = (NET_DISPLAY_GROUP*)netGroupBuffer;

// add these names to the dialog
	netGroup = (NET_DISPLAY_GROUP*)netGroupBuffer;
	for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
		{
		csTemp = netGroup->grpi3_name;
		csTemp += ";";
		csTemp += netGroup->grpi3_comment;
		csaGroups.AddHead(csTemp);
		netGroup++;
		}

// add more names?
	while (err == ERROR_MORE_DATA)
		{
		netGroup--;
		NetGetDisplayInformationIndex(lpszPrimaryDC, 3, netGroup->grpi3_name, &dwNext);
		NetApiBufferFree(netGroupBuffer);
		err = NetQueryDisplayInformation(lpszPrimaryDC, 3,
			dwNext, 100, 32767,
			&dwReturnedEntries, &netGroupBuffer);

// check return for error
		if (err != NERR_Success && err != ERROR_MORE_DATA) return;

		netGroup = (NET_DISPLAY_GROUP*)netGroupBuffer;
		for (dwCurrent = 0; dwCurrent < dwReturnedEntries; dwCurrent++)
			{
			csTemp = netGroup->grpi3_name;
			csTemp += ";";
			csTemp += netGroup->grpi3_comment;
			csaGroups.AddHead(csTemp);
			netGroup++;
			}
		}
 	NetApiBufferFree(netGroupBuffer);

}



void CLUsers::OnAddButton() 
{
	UpdateData(TRUE);

// start with the domain or machine name to create the account information
	CString csValue = m_csDomainName;
	if (csValue.Left(2) == _T("\\\\"))
		csValue = csValue.Right(csValue.GetLength() - 2);

	csValue += "\\";
	csValue += m_csAvailableUserList.Left(m_csAvailableUserList.Find(_T(";")));;

	if (m_lbAddedUserList.FindString(-1, csValue) == LB_ERR) 
		m_lbAddedUserList.AddString(csValue, m_lbAvailableUserList.GetItemData(m_lbAvailableUserList.GetCurSel()));
	
/*
// start with the domain or machine name to create the account information
	CString csValue = m_csDomainName;
	if (csValue.Left(2) == _T("\\\\"))
		csValue = csValue.Right(csValue.GetLength() - 2);
	csValue += "\\";

	INT* pnItems;
	m_lbAvailableUserList.GetSelItems(1024, pnItems);
	USHORT sCount = 0;
	while (sCount < m_lbAvailableUserList.GetSelCount())
		{
		CString csUserName = csValue;
		CString csSelItem;
		m_lbAvailableUserList.GetText(*pnItems, csSelItem);

		csUserName += csSelItem.Left(csSelItem.Find(_T(";")));

		if (m_lbAddedUserList.FindString(-1, csUserName) == LB_ERR) 
			m_lbAddedUserList.AddString(csUserName, 
				m_lbAvailableUserList.GetItemData(*pnItems));

		pnItems++;
		sCount++;
		}
	*/
}

LRESULT CLUsers::OnWizardBack() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (pApp->m_bServer) return IDD_GROUP_TYPE_DLG;
	else if (pApp->m_csCmdLine != L"") return IDD_GROUP_LIST_DIALOG;
	else if (pApp->m_sMode == 1) return IDD_GROUP_LIST_DIALOG;
	else return IDD_LR_DIALOG;

}

LRESULT CLUsers::OnWizardNext() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_cps1.SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);

// empty the list
	pApp->m_csaNames.RemoveAll();

// fill with new names.
	USHORT us;
	CString csTemp;
	for (us = 0; us < m_lbAddedUserList.GetCount(); us++)
		{
		m_lbAddedUserList.GetText(us, csTemp);
		pApp->m_csaNames.AddHead(csTemp);
		}

	return IDD_FINISH_DLG;
}

void CLUsers::OnSelchangeDomainCombo() 
{
	UpdateData(TRUE); 	   
	m_lbAvailableUserList.ResetContent();
	if (m_csDomainName.Left(2) == "\\\\")
		CatalogAccounts((const TCHAR*)m_csDomainName, m_lbAvailableUserList, TRUE);	 
	else
		CatalogAccounts((const TCHAR*)m_csDomainName, m_lbAvailableUserList);	 
//#ifdef KKBUGFIX
	m_lbAvailableUserList.SetCurSel(0);
//#endif
		
}

void CLUsers::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();	

	CWaitCursor wait;
	if (bShow)
		{
		if (m_csServer != pApp->m_csServer) 
			{
			m_csServer = pApp->m_csServer;
			m_lbAddedUserList.ResetContent();
			}
// on a rerun clean out the members from the last group
		else if (pApp->bRestart2) 
			{
			m_lbAddedUserList.ResetContent();
			pApp->bRestart2 = FALSE;
			}
		else return;

		m_csDomainList.ResetContent();
// get domain list
		CWaitCursor wait;

		CTrustList pList;
		if (!pList.BuildTrustList((LPTSTR)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength()))) 
			{
			AfxMessageBox(IDS_NO_WKSALLOWED);
			pApp->m_cps1.SetActivePage(1);
			return;
			}

		UINT i;
		for(i = 0 ; i < pList.m_dwTrustCount ; i++)
			m_csDomainList.AddString(pList.m_ppszTrustList[i]);

// remove the current machine from the list
		if ((i = m_csDomainList.FindStringExact(-1, pApp->m_csServer.Right(pApp->m_csServer.GetLength() - 2))) != LB_ERR)
			m_csDomainList.DeleteString(i);

// put machine name into list (assuming we are adding to a machine and not a domain)
		if (!pApp->m_bDomain) m_csDomainList.AddString(pApp->m_csServer);

// get primary domain
		DWORD dwRet;
		HKEY hKey;
		DWORD cbProv = 0;
		TCHAR* lpProv = NULL;

		CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
		long lRet = RegConnectRegistry(
			(LPTSTR)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength()), 
			HKEY_LOCAL_MACHINE,
			&hKey);
		
		dwRet = RegOpenKey(hKey,
			TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), &hKey );

		TCHAR* lpPrimaryDomain = NULL;
		if ((dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
			{
			lpPrimaryDomain = (TCHAR*)malloc(cbProv);
			if (lpPrimaryDomain == NULL)
				{
				AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
				exit(1);
				}

			dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, (LPBYTE) lpPrimaryDomain, &cbProv );

			}

		m_csPrimaryDomain = lpPrimaryDomain;
		free(lpPrimaryDomain);
		RegCloseKey(hKey);

		CatalogAccounts((const TCHAR*)m_csPrimaryDomain, m_lbAvailableUserList);
//#ifdef KKBUGFIX
		if (m_csDomainList.SelectString(-1, (const TCHAR*)m_csPrimaryDomain ) == CB_ERR)
			{
			CatalogAccounts((const TCHAR*)m_csServer, m_lbAvailableUserList,TRUE);
			m_csDomainList.SelectString(-1, (const TCHAR*)m_csServer);
			}
//#else
		else m_csDomainList.SelectString(-1, (const TCHAR*)m_csPrimaryDomain);
//#endif
		GetDlgItem(IDC_AVAILABLE_LOCAL_USERS)->SetFocus();
		m_lbAvailableUserList.SetCurSel(0);

// editing a group? add the current members
		if (pApp->m_sMode == 1)
			{
			DWORD dwEntriesRead;
			DWORD dwTotalEntries;
			DWORD dwResumeHandle = 0;
	//		m_lbAddedUserList.ResetContent();
			
			TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
			pApp->m_csServer.ReleaseBuffer();

			TCHAR* pGroup = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
			pApp->m_csGroupName.ReleaseBuffer();

			PLOCALGROUP_MEMBERS_INFO_1 pMembers;
			NET_API_STATUS nApi = NetLocalGroupGetMembers(pServer,
				pGroup,
				1,
				(LPBYTE*)&pMembers,
				5000,
				&dwEntriesRead,
				&dwTotalEntries, 
				&dwResumeHandle);

			if (nApi != ERROR_SUCCESS) return;

			USHORT sIndex;
			for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
				{
				TCHAR pName[50];
				DWORD dwNameSize = 50;
				TCHAR pDomain[50];
				DWORD dwDomainNameSize = 50;
				SID_NAME_USE pUse;
				LookupAccountSid(pServer, pMembers[sIndex].lgrmi1_sid,
					pName, &dwNameSize,
					pDomain, &dwDomainNameSize,
					&pUse);
				
				wchar_t sTemp[150];
				swprintf(sTemp, TEXT("%s\\%s"), pDomain, pName);

				if (pUse == 1) m_lbAddedUserList.AddString(0, sTemp);
				else m_lbAddedUserList.AddString(1, sTemp);
				}

			NetApiBufferFree(pMembers);

			while (dwResumeHandle != 0)
				{
				nApi = NetLocalGroupGetMembers(pServer,
					pGroup,
					1,
					(LPBYTE*)&pMembers,
					5000,
					&dwEntriesRead,
					&dwTotalEntries, 
					&dwResumeHandle);

				if (nApi != ERROR_SUCCESS) return;

				USHORT sIndex;
				for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
					{
					TCHAR pName[50];
					DWORD dwNameSize = 50;
					TCHAR pDomain[50];
					DWORD dwDomainNameSize = 50;
					SID_NAME_USE pUse;
					LookupAccountSid(pServer, pMembers[sIndex].lgrmi1_sid,
						pName, &dwNameSize,
						pDomain, &dwDomainNameSize,
						&pUse);
								
					wchar_t sTemp[150];
					swprintf(sTemp, TEXT("%s\\%s"), pDomain, pName);

					if (pUse == 1) m_lbAddedUserList.AddString(0, sTemp);
					else m_lbAddedUserList.AddString(1, sTemp);

					}
				NetApiBufferFree(pMembers);
				}
			}
		}
	   
}


void CLUsers::OnDblclkAddedLocalUsers() 
{
//	CString csSelItem;
//	int nSel = m_lbAddedUserList.GetCaretIndex();
//	m_lbAddedUserList.DeleteString(nSel);
	m_lbAddedUserList.DeleteString(m_lbAddedUserList.GetCurSel());

}

void CLUsers::OnDblclkAvailableLocalUsers() 
{
	UpdateData(TRUE);
// start with the domain or machine name to create the account information
	CString csValue = m_csDomainName;
	if (csValue.Left(2) == _T("\\\\"))
		csValue = csValue.Right(csValue.GetLength() - 2);

	csValue += "\\";
	csValue += m_csAvailableUserList.Left(m_csAvailableUserList.Find(_T(";")));;

	if (m_lbAddedUserList.FindString(-1, csValue) == LB_ERR) 
		m_lbAddedUserList.AddString(csValue, m_lbAvailableUserList.GetItemData(m_lbAvailableUserList.GetCurSel()));
// start with the domain or machine name to create the account information
/*	CString csValue = m_csDomainName;
	if (csValue.Left(2) == _T("\\\\"))
		csValue = csValue.Right(csValue.GetLength() - 2);

	csValue += "\\";

	CString csSelItem;
	int nSel = m_lbAvailableUserList.GetCaretIndex();
	m_lbAvailableUserList.GetText(nSel, csSelItem);
	csValue += csSelItem.Left(csSelItem.Find(_T(";")));

	if (m_lbAddedUserList.FindString(-1, csValue) == LB_ERR) 
		m_lbAddedUserList.AddString(csValue, m_lbAvailableUserList.GetItemData(nSel));
		*/

	
}

void CLUsers::OnSetfocusAvailableLocalUsers() 
{
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	m_lbAddedUserList.SetCurSel(-1);
	
}

void CLUsers::OnSetfocusAddedLocalUsers() 
{
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
	m_lbAvailableUserList.SetCurSel(-1);
	
}

void CLUsers::OnRemoveButton() 
{
/*	INT* pnItems;
	m_lbAddedUserList.GetSelItems(1024, pnItems);
	USHORT sCount = 0;
	while (sCount < m_lbAddedUserList.GetSelCount())
		{
	//	m_lbAddedUserList.DeleteString(*pnItems);
		TRACE(L"Item = %d\n\r", *pnItems);

		pnItems++;
		sCount++;
		}
		 */
	m_lbAddedUserList.DeleteString(m_lbAddedUserList.GetCurSel());
	m_lbAddedUserList.SetCurSel(0);
		 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\nettree.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NetTree.h : header file

File History:

	Randyfe	Jan-96	created

--*/


// NetTree.h : header file
//
/////////////////////////////////////////////////////////////////////////////
// Global declarations

UINT FillTree(LPVOID pParam);


/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl window

class CNetTreeCtrl : public CTreeCtrl
{
// Construction
public:
	CNetTreeCtrl();
	virtual ~CNetTreeCtrl();

// Data members
public:
	enum 
	{
		ROOT_LEVEL = 0x0,
		DOMAIN_LEVEL = 0x1,
		SERVER_LEVEL = 0x2,

		BUFFER_SIZE = 0x4000,
		MAX_STRING = 0x100,

		IMG_ROOT = 0,
		IMG_DOMAIN = 1,
		IMG_SERVER = 2,

		IMG_SIZE = 16,
		IMG_GROW = 3,
		IMG_MASK = RGB(0xFF, 0xFF, 0xFF)
	};

public:
	HANDLE m_hHeap;
	CImageList m_imagelist;
	CTypedPtrList<CPtrList, LPNETRESOURCE> m_ptrlistContainers;
	CTypedPtrList<CPtrList, LPTSTR> m_ptrlistStrings;
	CWinThread* m_pThread;
	CEvent m_event;
	BOOL m_bExitThread;

// Attributes
public:

// Operations
public:
	BOOL PopulateTree(BOOL bExpand= TRUE, const HTREEITEM hParentBranch = TVI_ROOT, DWORD dwBufSize = BUFFER_SIZE);
	void ErrorHandler(const DWORD dwCode);
	void NotifyThread(BOOL bExit);

protected:
	void PumpMessages();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CNetTreeCtrl)
	afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\nettree.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
	NetTree.cpp : implementation file
    
    FILE HISTORY:
        Randyfe     Jan-1996     created for Licence compliancy wizard
		Jony		Apr-1996	modified to fit this wizard
*/


#include "stdafx.h"
#include "Romaine.h"
#include "resource.h"
#include "NetTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global variables

extern TCHAR pszTreeEvent[];

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl

CNetTreeCtrl::CNetTreeCtrl()
: m_pThread(NULL), m_bExitThread(FALSE), m_event(TRUE, TRUE, pszTreeEvent)
{
	// Get a handle to the process heap
	m_hHeap = ::GetProcessHeap();

	ASSERT(m_hHeap != NULL);
}

CNetTreeCtrl::~CNetTreeCtrl()
{
	// Make sure the tree thread knows it's time to exit.
	NotifyThread(TRUE);

	// Create an event object to match the tree thread event object.
	CEvent event(TRUE, TRUE, pszTreeEvent);

	// Create a lock object for the event object.
	CSingleLock lock(&event);

	// Lock the lock object and make the main thread wait for the
	// threads to signal their event objects.
	lock.Lock();

	// Free all of the pointers to LPTSTRs in the list
	POSITION pos = m_ptrlistStrings.GetHeadPosition();

	while (pos != NULL)
	{
		// Memory deallocation fails if there's a null char
		// at the end of the string.
		LPTSTR psz = m_ptrlistStrings.GetNext(pos);
		*(::_tcslen(psz) + psz) = (TCHAR)0xFD;
		delete[] psz;
	}

	// Free all of the pointers to NETRESOURCE structs in the list
	pos = m_ptrlistContainers.GetHeadPosition();

	while (pos != NULL)
	{
		delete m_ptrlistContainers.GetNext(pos);
	}
}


BEGIN_MESSAGE_MAP(CNetTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CNetTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
	ON_WM_SETCURSOR()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global functions

UINT FillTree(LPVOID pParam)
{
	CEvent event(TRUE, TRUE, pszTreeEvent);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	PTREEINFO pti = (PTREEINFO)pParam;
	CNetTreeCtrl* pTree = (CNetTreeCtrl*)pti->pTree;
	BOOL bResult = FALSE;
	DWORD dwEntries = 0xFFFFFFFF;
	LPVOID lpvBuffer = NULL;
	HANDLE hEnum = NULL;

	// Because this function may call itself, keep a usage count
	// so that pti is freed only when the first instance returns.
	static USHORT uUsage = 0;

	// Keep a handle to the heap in case the CNetTreeCtrl object
	// goes away before the thread ends.
	HANDLE hHeap = pTree->m_hHeap;
	DWORD dwResult;
	LPNETRESOURCE pnrRoot;
	HTREEITEM hTreeItem, hTreeExpand;

	hTreeItem = hTreeExpand = NULL;

	try
	{
		// Unsignal the event object.
		event.ResetEvent();

		// Show the wait cursor
		pTree->BeginWaitCursor();

		// Exit if the handle to the heap is invalid.
		if (hHeap == NULL)
			goto ExitFunction;

		if (pti->hTreeItem == TVI_ROOT)
		{
			pnrRoot = NULL;
			if (pTree->m_imagelist.Create(IDB_NET_TREE, 16, 3, CNetTreeCtrl::IMG_MASK))
			{
				pTree->SetImageList(&(pTree->m_imagelist), TVSIL_NORMAL);
				pTree->m_imagelist.SetBkColor(CLR_NONE);
			}
		}
		else
			pnrRoot = (LPNETRESOURCE)pTree->GetItemData(pti->hTreeItem);

		// Get an enumeration handle.
		if ((dwResult = ::WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 
								  RESOURCEUSAGE_CONTAINER, pnrRoot, &hEnum)) != NO_ERROR)
		{
			// Exit if WNetOpenEnum fails.
			dwResult = ::GetLastError();
			goto ExitFunction;
		}

		// Allocate a buffer for enumeration.
		if ((lpvBuffer = ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, pti->dwBufSize)) == NULL)
			// Exit if memory allocation failed
			goto ExitFunction;

		// Retrieve a block of network entries.
		while ((dwResult = ::WNetEnumResource(hEnum, &dwEntries, lpvBuffer, &(pti->dwBufSize))) != ERROR_NO_MORE_ITEMS)
		{
			// See if it's time to exit.
			if (pTree->m_bExitThread)
			{
				pTree->NotifyThread(FALSE);
				bResult = TRUE;
				goto ExitFunction;
			}

			// Exit if WNetEnumResource failed.
			if (dwResult != NO_ERROR)
			{
				dwResult = ::GetLastError();
				goto ExitFunction;
			}

			LPNETRESOURCE pnrLeaf = (LPNETRESOURCE)lpvBuffer;
			TV_INSERTSTRUCT tviLeaf;

			// Fill in the TV_INSERTSTRUCT members.
			tviLeaf.hParent = pti->hTreeItem;
			tviLeaf.hInsertAfter = TVI_SORT;
			tviLeaf.item.hItem = NULL;
			tviLeaf.item.state = 0;
			tviLeaf.item.stateMask = 0;
			tviLeaf.item.cchTextMax = 0;
			tviLeaf.item.iSelectedImage = 0;

			// Set the correct image for the leaf.
			switch (pnrLeaf->dwDisplayType)
			{
				case RESOURCEDISPLAYTYPE_DOMAIN:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_DOMAIN;
					break;
					
				case RESOURCEDISPLAYTYPE_SERVER:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_SERVER;
					break;

				default:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_ROOT;
			}

			// Fool the tree into thinking that this leaf has children
			// since we don't know initially.
			if (pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 0;
			}
			else
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 1;
			}

			// Add leaves to the branch.
			for (DWORD i = 0; i < dwEntries; i++)
			{
				// See if it's time to exit.
				if (pTree->m_bExitThread)
				{
					pTree->NotifyThread(FALSE);
					bResult = TRUE;
					goto ExitFunction;
				}

				// Create a permanent NETRESOURCE struct for later use.
				LPNETRESOURCE pnrTemp = new NETRESOURCE;
				pTree->m_ptrlistContainers.AddTail(pnrTemp);

				::memcpy(pnrTemp, pnrLeaf, sizeof(NETRESOURCE));

				if (pnrLeaf->lpRemoteName != NULL)
				{
					pnrTemp->lpRemoteName = new TCHAR[::_tcslen(pnrLeaf->lpRemoteName) + 1];
					::_tcscpy(pnrTemp->lpRemoteName, pnrLeaf->lpRemoteName);
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpRemoteName);
				}

				if (pnrLeaf->lpProvider != NULL)
				{
					pnrTemp->lpProvider = new TCHAR[::_tcslen(pnrLeaf->lpProvider) + 1];
					::_tcscpy(pnrTemp->lpProvider, pnrLeaf->lpProvider);
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpProvider);
				}

				// Increment the buffer pointer.
				pnrLeaf++;

				// Use "Enterprise" as the item text if this is the root.
				if (pti->hTreeItem == TVI_ROOT)
				{
					CString strRoot;

					tviLeaf.item.pszText = new TCHAR[::_tcslen(pnrTemp->lpProvider) + 1];
					::_tcscpy(tviLeaf.item.pszText, (LPCTSTR)pnrTemp->lpProvider);
				}
				else if (pnrTemp->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
				{
					// Skip the initial backslashes before adding the server
					// name to the tree.
					tviLeaf.item.pszText = pnrTemp->lpRemoteName;// + 2;
				}
				else
					tviLeaf.item.pszText = pnrTemp->lpRemoteName;

				tviLeaf.item.lParam = (LPARAM)(LPVOID)pnrTemp;

				// Make sure the pointer to the tree control is still valid.
				if (::IsWindow(pTree->m_hWnd))
				{
					hTreeItem = pTree->InsertItem(&tviLeaf);
				}
				else	// Otherwise, exit the thread.
				{
					bResult = TRUE;
					goto ExitFunction;
				}

				// Delete the string allocated for the root node text.
				if (pti->hTreeItem == TVI_ROOT)
					delete tviLeaf.item.pszText;

				// See if the lpRemoteName member is equal to the default domain
				// name.
				if (!_tcscmp(pnrTemp->lpRemoteName, pApp->m_csCurrentDomain) ||
					pti->hTreeItem == TVI_ROOT)
				{
					
					// Store the handle.
					hTreeExpand = hTreeItem;
				}

				// Select the name of the license server in the tree.
				if (!_tcscmp(pnrTemp->lpRemoteName, pApp->m_csCurrentMachine))
				{
					pTree->SelectItem(hTreeItem);
					pTree->SetFocus();
				}						   
			}

			// Everything went all right.
			bResult = TRUE;
		}

		// Expand the branch but only if it isn't the root.
		// The root item thinks it has children, but really doesn't the first time through.
		if (pti->hTreeItem != TVI_ROOT && pTree->ItemHasChildren(pti->hTreeItem))
		{
			// Indicate that the branch has been expanded once.
			pTree->SetItemState(pti->hTreeItem, TVIS_EXPANDEDONCE, TVIS_EXPANDEDONCE);
			pTree->Expand(pti->hTreeItem, TVE_EXPAND);
		}

		// Fill the branch for the current domain if the bExpand member is TRUE.
		if (hTreeExpand != NULL && pti->bExpand)
		{
			TREEINFO ti;

			ti.hTreeItem = hTreeExpand;
			ti.dwBufSize = pti->dwBufSize;
			ti.pTree = pti->pTree;
			ti.bExpand = TRUE;

			// Increment the usage count.
			uUsage++;

			::FillTree((LPVOID)&ti);

			// Decrement the usage count.
			uUsage--;
		}
		
	ExitFunction:
		// Display a message if an error occurred.
		if (!bResult)
			pTree->ErrorHandler(dwResult);

		// Close the enumeration handle.
		if (hEnum != NULL)
			if (!(bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer only if the usage count is zero.
		if (uUsage == 0)
			delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Make sure the tree control still exists before posting a message.
		if (::IsWindow(pTree->m_hWnd))
			pTree->PostMessage(WM_SETCURSOR);

		// Signal the event object.
		if (uUsage == 0)
			event.SetEvent();

		return (UINT)!bResult;
	}
	catch(...)
	{
		// Close the enumeration handle.
		if (hEnum != NULL)
			if (!(bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer
		delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Signal the event object.
		event.SetEvent();

		return (UINT)2;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl member functions

BOOL CNetTreeCtrl::PopulateTree(BOOL bExpand /* = TRUE */, const HTREEITEM hParentBranch /* = TVI_ROOT */, 
								DWORD dwBufSize /* = BUFFER_SIZE */)
{
	PTREEINFO pti = new TREEINFO;

	pti->hTreeItem = hParentBranch;
	pti->dwBufSize = dwBufSize;
	pti->pTree = this;
	pti->bExpand = bExpand;

	// Don't begin a new thread until the last one has ended.
	if (m_pThread != NULL)
	{
		NotifyThread(TRUE);

		CEvent event(TRUE, TRUE, pszTreeEvent);
		CSingleLock lock(&event);

		// Wait.
		lock.Lock();
	}

	m_pThread = AfxBeginThread((AFX_THREADPROC)::FillTree, (LPVOID)pti);

	return TRUE;
}

void CNetTreeCtrl::ErrorHandler(const DWORD dwCode)
{
	CString strError;
	BOOL bNetError = FALSE;

#ifdef _DEBUG
	switch (dwCode)
	{
		case ERROR_MORE_DATA:
			strError = "ERROR_MORE_DATA";
			break;

		case ERROR_INVALID_HANDLE:
			strError = "ERROR_INVALID_HANDLE";
			break;

		case ERROR_NOT_CONTAINER:
			strError = "ERROR_NOT_CONTAINER";
			break;

		case ERROR_INVALID_PARAMETER:
			strError = "ERROR_INVALID_PARAMETER";
			break;

		case ERROR_NO_NETWORK:
			strError = "ERROR_NO_NETWORK";
			break;

		case ERROR_EXTENDED_ERROR:
			strError = "ERROR_EXTENDED_ERROR";
			break;

		default:
		{
#endif // _DEBUG
			DWORD dwErrCode;
			CString strErrDesc, strProvider;
			LPTSTR pszErrDesc = strErrDesc.GetBuffer(MAX_STRING);
			LPTSTR pszProvider = strProvider.GetBuffer(MAX_STRING);

			if (::WNetGetLastError(&dwErrCode, pszErrDesc, MAX_STRING,
								   pszProvider, MAX_STRING) == NO_ERROR)
			{
				strErrDesc.ReleaseBuffer();
				strProvider.ReleaseBuffer();

				CString strErrMsg;

				// Don't display the WNetGetLastError message if dwErrCode == 0.
				if (dwErrCode)
				{	
					// Trim of any leading or trailing white space.
					strProvider.TrimRight();
					strProvider.TrimLeft();
					strErrDesc.TrimRight();
					strErrDesc.TrimLeft();
					strErrMsg.Format(IDS_NET_ERROR, strProvider, strErrDesc);
				}
				else
					strErrMsg.LoadString(IDS_NET_NO_SERVERS);
				
				MessageBox(strErrMsg, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);

				bNetError = TRUE;
			}
			else
				strError.LoadString(IDS_ERROR);
#ifdef _DEBUG
		}
	}
#endif // _DEBUG

	if (!bNetError)
		AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl functions

void CNetTreeCtrl::NotifyThread(BOOL bExit)
{
	CCriticalSection cs;

	if (cs.Lock())
	{
		m_bExitThread = bExit;
		cs.Unlock();
	}
}

void CNetTreeCtrl::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;
    // Handle dialog messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if(!IsDialogMessage(&msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);  
      }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl message handlers

void CNetTreeCtrl::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	// Exit and stop expansion if the thread is running.
	if (m_pThread != NULL)
	{
		*pResult = TRUE;
		return;
	}

	// Exit if this branch has been expanded once.
	if (!(pNMTreeView->itemNew.state & TVIS_EXPANDEDONCE))
	{
		// Add new leaves to the branch.
		if (pNMTreeView->itemNew.mask & TVIF_HANDLE)
		{
			PopulateTree(FALSE, pNMTreeView->itemNew.hItem);
			pNMTreeView->itemNew.mask |= TVIS_EXPANDEDONCE;
		}
	}
	
	*pResult = FALSE;
}

BOOL CNetTreeCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	if (m_pThread == NULL)	
	{
		return CTreeCtrl::OnSetCursor(pWnd, nHitTest, message);
	}
	else
	{
		// Restore the wait cursor if the thread is running.
		RestoreWaitCursor();

		return TRUE;
	}
}

void CNetTreeCtrl::OnDestroy() 
{
	NotifyThread(TRUE);
	PumpMessages();

	CTreeCtrl::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    stdafx.cpp

// stdafx.cpp : source file that includes just the standard includes
//	Romaine.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

    
    FILE HISTORY:
        jony     Apr-1996     created
*/


#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\romaine.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    stdafx.cpp

	Romaine.cpp : Defines the class behaviors for the application.
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "NetTree.h"
#include "Romaine.h"
#include "Welcome.h"
#include "Where.h"
#include "Type.h"
#include "What.h"
#include "userlist.h"
#include "LUsers.h"
#include "GUsers.h"
#include "finish.h"
#include "ExGrp.h"
#include "LRem.h"

#include <winreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TCHAR pszTreeEvent[] =  _T("TreeThread");
extern int ClassifyMachine(CString& csMachine);

/////////////////////////////////////////////////////////////////////////////
// CRomaineApp

BEGIN_MESSAGE_MAP(CRomaineApp, CWinApp)
	//{{AFX_MSG_MAP(CRomaineApp)
	//}}AFX_MSG
//	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRomaineApp construction

CRomaineApp::CRomaineApp()
{
	bRestart1 = FALSE;
	bRestart2 = FALSE;

// get our primary domain and save it for NETTREE
	DWORD dwRet;
	HKEY hKey;
	DWORD cbProv = 0;
	TCHAR* lpProv = NULL;

	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	
	dwRet = RegOpenKey(HKEY_LOCAL_MACHINE,
		TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), &hKey );

	TCHAR* lpPrimaryDomain = NULL;
	if ((dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpPrimaryDomain = (TCHAR*)malloc(cbProv);
		if (lpPrimaryDomain == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			exit(1);
			}

		dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, (LPBYTE) lpPrimaryDomain, &cbProv );

		}

	RegCloseKey(hKey);

	pApp->m_csCurrentDomain = lpPrimaryDomain;

// store the machine name too
	CString csMachineName;
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
	GetComputerName(csMachineName.GetBufferSetLength(MAX_COMPUTERNAME_LENGTH + 1), &dwSize);

	pApp->m_csCurrentMachine = "\\\\";
	pApp->m_csCurrentMachine += csMachineName;

	free(lpPrimaryDomain);


}

/////////////////////////////////////////////////////////////////////////////
// The one and only CRomaineApp object

CRomaineApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CRomaineApp initialization
BOOL CRomaineApp::IsSecondInstance()
{
    HANDLE hSem;

       //create a semaphore object with max count of 1
    hSem = CreateSemaphore(NULL, 0, 1, L"Group Wizard Semaphore");
    if (hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hSem);
		CString csAppName;
		csAppName.LoadString(AFX_IDS_APP_TITLE);
        CWnd* pWnd = CWnd::FindWindow(NULL, (LPCTSTR)csAppName);

        if (pWnd)
           pWnd->SetForegroundWindow();
        return TRUE;
    }

    return FALSE;
}

BOOL CRomaineApp::InitInstance()
{
// check for OS version
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(os);
	GetVersionEx(&os);

	if (os.dwMajorVersion < 4) 
		{
		AfxMessageBox(IDS_BAD_VERSION, MB_ICONSTOP);
		ExitProcess(0);
		}

	if (IsSecondInstance())
        return FALSE;

// if there is a directory name on the command line, load an extra class
	if (m_lpCmdLine[0] != '\0')
		{
		m_csCmdLine = m_lpCmdLine;
		m_sCmdLine = __argc;

		TCHAR* pFolder = _tcstok(m_lpCmdLine, L" ");
		if (_tcsicmp(pFolder, L"/folder")) return FALSE;  // anything else on the cmdline and boot it out

		m_sMode = 1;
		if (m_sCmdLine == 3) 
			{
			TCHAR* pParam3 = _tcstok(NULL, L" ");
			if (*(pParam3 + 1) == 'g') 
				{
				pParam3+=3;
				m_csCmdLineGroupName = pParam3;
				}
			else 
				{
				pParam3+=3;
				m_csServer = pParam3;
				if (ClassifyMachine(m_csServer) == -1) ExitProcess(1);
				}
			}

		if (m_sCmdLine == 4) 
			{
			TCHAR* pParam3 = _tcstok(NULL, L" ");
			TCHAR* pParam4 = _tcstok(NULL, L" ");
			if (*(pParam3 + 1) == 'g') 
				{
				pParam3+=3;
				pParam4+=3;
				m_csCmdLineGroupName = pParam3;
				m_csServer = pParam4;
				}
			else 
				{
				pParam3+=3;
				pParam4+=3;
				m_csServer = pParam3;
				m_csCmdLineGroupName = pParam4;
				}

			if (ClassifyMachine(m_csServer) == -1) ExitProcess(1);
			}
		}

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

// create the property sheet,set 'wizmode' & set app icon
	m_cps1.SetTitle(TEXT("Group Management Wizard"), 0);

	m_cps1.SetWizardMode();

	CWelcome* pWelcome = new CWelcome;
	CLRem* pLRem = new CLRem;
	CWhere* pWhere = new CWhere;
	CType* pType = new CType;
	CWhat* pWhat = new CWhat;
	CExGrp* pEx = new CExGrp;

	CLUsers* pLUsers = new CLUsers;
	CGUsers* pGUsers = new CGUsers;
	CFinish* pFinish = new CFinish;

// add pages
	m_cps1.AddPage(pEx);

	m_cps1.AddPage(pWelcome);
	m_cps1.AddPage(pWhat);
	m_cps1.AddPage(pLRem);
	m_cps1.AddPage(pWhere);
	m_cps1.AddPage(pType);
	m_cps1.AddPage(pLUsers);
	m_cps1.AddPage(pGUsers);
	m_cps1.AddPage(pFinish);

// show the wizard
	if (m_csServer != L"") m_cps1.SetActivePage(0);
	else m_cps1.SetActivePage(1);

	m_cps1.DoModal();
	
// clean up
	delete pWelcome;
	delete pWhere;
	delete pLRem;
	delete pType;
	delete pWhat;
	delete pLUsers;
	delete pGUsers;
	delete pFinish;
	delete pEx;

	return FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CMySheet

IMPLEMENT_DYNAMIC(CMySheet, CPropertySheet)

CMySheet::CMySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CMySheet::CMySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CMySheet::CMySheet() : CPropertySheet()
{
}

CMySheet::~CMySheet()
{
}


BEGIN_MESSAGE_MAP(CMySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMySheet)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMySheet message handlers

BOOL CMySheet::OnInitDialog() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	HICON hIcon = LoadIcon(pApp->m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));
	::SetClassLong(m_hWnd, GCL_HICON, (long)hIcon);
	
	return CPropertySheet::OnInitDialog();
}

int CMySheet::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;
	
//	lpCreateStruct->style = WS_OVERLAPPEDWINDOW;
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\transbmp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    transbmp.cpp

// transbmp.cpp : implementation of the CTransBmp class
//
// support for transparent CBitmap objects. Used in the CUserList class.
// Based on a class from MSDN 7/95

    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "transbmp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Colors
#define rgbWhite RGB(255,255,255)
// Raster op codes
#define DSa     0x008800C6L
#define DSx     0x00660046L


/////////////////////////////////////////////////////////////////////////////
// CTransBmp construction/destruction

CTransBmp::CTransBmp()
{
    m_iWidth = 0;
    m_iHeight = 0;
	m_hbmMask = NULL;
}

CTransBmp::~CTransBmp()
{
	if (m_hbmMask != NULL) delete m_hbmMask;
}

void CTransBmp::GetMetrics()
{
    // Get the width and height
    BITMAP bm;
    GetObject(sizeof(bm), &bm);
    m_iWidth = bm.bmWidth;
    m_iHeight = bm.bmHeight;
}


int CTransBmp::GetWidth()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iWidth;
}

int CTransBmp::GetHeight()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iHeight;
}


void CTransBmp::CreateMask(CDC* pDC)
{
	m_hbmMask = new CBitmap;    
// Nuke any existing mask
    if (m_hbmMask) m_hbmMask->DeleteObject();

// Create memory DCs to work with
	CDC* hdcMask = new CDC;
	CDC* hdcImage = new CDC;

    hdcMask->CreateCompatibleDC(pDC);
    hdcImage->CreateCompatibleDC(pDC);

// Create a monochrome bitmap for the mask
    m_hbmMask->CreateBitmap(GetWidth(),
                               GetHeight(),
                               1,
                               1,
                               NULL);

// Select the mono bitmap into its DC
    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);
// Select the image bitmap into its DC
    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

// Set the transparency color to be the top-left pixel
    hdcImage->SetBkColor(hdcImage->GetPixel(0, 0));
// Make the mask
    hdcMask->BitBlt(0, 0,
             GetWidth(), GetHeight(),
             hdcImage,
             0, 0,
             SRCCOPY);
// clean up
    hdcMask->SelectObject(hbmOldMask);
    hdcImage->SelectObject(hbmOldImage);
    delete hdcMask;
    delete hdcImage;
}

// draw the transparent bitmap using the created mask
void CTransBmp::DrawTrans(CDC* pDC, int x, int y)
{
    if (m_hbmMask == NULL) CreateMask(pDC);

    int dx = GetWidth();
    int dy = GetHeight();

// Create a memory DC to do the drawing to
	CDC* hdcOffScr = new CDC;
	hdcOffScr->CreateCompatibleDC(pDC);

// Create a bitmap for the off-screen DC that is really
// color compatible with the destination DC.
	CBitmap hbmOffScr;
	hbmOffScr.CreateBitmap(dx, dy, 
						pDC->GetDeviceCaps(PLANES),
						pDC->GetDeviceCaps(BITSPIXEL),
						NULL);
                             
// Select the buffer bitmap into the off-screen DC
    HBITMAP hbmOldOffScr = (HBITMAP)hdcOffScr->SelectObject(hbmOffScr);

// Copy the image of the destination rectangle to the
// off-screen buffer DC so we can play with it
    hdcOffScr->BitBlt(0, 0, dx, dy, pDC, x, y, SRCCOPY);

// Create a memory DC for the source image
	CDC* hdcImage = new CDC;
	hdcImage->CreateCompatibleDC(pDC);

    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

    // Create a memory DC for the mask
    CDC* hdcMask = new CDC;
	hdcMask->CreateCompatibleDC(pDC);

    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);

    // XOR the image with the destination
    hdcOffScr->SetBkColor(rgbWhite);
    hdcOffScr->BitBlt(0, 0, dx, dy ,hdcImage, 0, 0, DSx);
    // AND the destination with the mask
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcMask, 0,0, DSa);
    // XOR the destination with the image again
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcImage, 0, 0, DSx);

    // Copy the resultant image back to the screen DC
    pDC->BitBlt(x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

    // Tidy up
    hdcOffScr->SelectObject(hbmOldOffScr);
    hdcImage->SelectObject(hbmOldImage);
    hdcMask->SelectObject(hbmOldMask);

	delete hdcOffScr;
	delete hdcImage;
	delete hdcMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Romaine.rc
//
#define IDS_GENERIC_NO_HEAP             1
#define IDS_GENERIC_NO_PDC              2
#define IDS_GENERIC_BAD_MACHINE         3
#define IDS_NO_GROUP_NAME               4
#define IDS_GROUP_INVALID_NAME          5
#define IDS_DOMAIN_SET                  6
#define IDS_TREE_ROOT                   7
#define IDS_NET_ERROR                   8
#define IDS_NET_NO_SERVERS              9
#define IDS_ERROR                       10
#define IDS_GROUP_EXISTS                11
#define IDS_INSUFFICIENT_PERMISSION     12
#define IDS_CANT_ADD_NAMES              13
#define IDS_LOCAL_GROUP                 14
#define IDS_GLOBAL_GROUP                15
#define IDS_NO_MACHINE_NAME             16
#define IDS_SUCCESS                     17
#define IDS_NO_DC                       18
#define IDS_NO_GROUP_SELECTED           19
#define IDS_GROUP_DELETED               20
#define IDS_GROUP_NOT_DELETED           21
#define IDD_ROMAINE_DIALOG              102
#define IDD_WELCOME_DLG                 102
#define IDD_NAME_DLG                    106
#define IDR_MAINFRAME                   128
#define IDD_MACHINE_DLG                 130
#define IDD_GROUP_TYPE_DLG              131
#define IDD_LOCAL_USERS                 132
#define IDD_GLOBAL_USERS                133
#define IDB_WORLD                       133
#define IDB_USER_BITMAP                 134
#define IDD_FINISH_DLG                  134
#define IDB_LOCAL_GROUP_BITMAP          135
#define IDB_GLOBAL_GROUP_BITMAP         136
#define IDB_LUSER_BITMAP                137
#define IDB_NET_TREE                    138
#define IDB_BITMAP1                     143
#define IDD_GROUP_LIST_DIALOG           144
#define IDD_LR_DIALOG                   145
#define IDB_END_FLAG                    148
#define IDC_PICTURE_BOX                 1000
#define IDC_MACHINE_NAME                1001
#define IDC_GROUP_NAME                  1002
#define IDC_GROUP_TYPE_RADIO            1003
#define IDC_RADIO2                      1004
#define IDC_AVAILABLE_LOCAL_USERS       1005
#define IDC_ADDED_LOCAL_USERS           1006
#define IDC_ADD_BUTTON                  1007
#define IDC_DOMAIN_COMBO                1008
#define IDC_AVAILABLE_MEMBERS_LIST      1009
#define IDC_SELECTED_MEMBERS_LIST       1010
#define IDC_REMOVE_BUTTON               1012
#define IDC_DESCRIPTION                 1013
#define IDC_SERVER_TREE                 1014
#define IDC_GROUP_STATIC                1015
#define IDC_GROUP_TYPE_STATIC           1016
#define IDC_LOCATION_STATIC             1017
#define IDC_NEW_GROUP_RADIO             1018
#define IDC_LOCAL_RADIO                 1019
#define IDC_REMOTE_RADIO                1020
#define IDC_GROUP_LIST                  1021
#define IDC_ADD_NEW_BUTTON              1022
#define IDC_DELETE_BUTTON               1023
#define IDC_STATIC1                     1025
#define IDC_STATIC2                     1026
#define IDC_WELCOME                     1028
#define IDC_FILE_TREE                   1100
#define IDC_FILE_LIST                   1101
#define IDD_MACHINEDLG                  1102
#define IDP_OLE_INIT_FAILED             1103
#define IDS_INVOKECMD_FAILED            1104
#define IDS_GETUIOBJOF_FAILED           1105
#define IDS_BAD_VERSION                 1106
#define IDS_ANOTHER_TRY                 57345
#define IDS_CREATE_TEXT                 57346
#define IDS_MODIFY_TEXT                 57347
#define IDS_CREATE_TEXT2                57348
#define IDS_MODIFY_TEXT2                57349
#define IDS_WELCOME                     57350
#define IDS_MODIFY3                     57351
#define IDS_CREATE3                     57352
#define IDS_SUCCESS_CREATE_RETRY        57353
#define IDS_CANT_ADD_NAMES_CREATE_RETRY 57354
#define IDS_SUCCESS_MODIFY_RETRY        57355
#define IDS_CANT_ADD_NAMES_MODIFY_RETRY 57356
#define IDS_UNKNOWN_ERROR               57357
#define IDS_DELETE_GROUP_CONFIRM        57358
#define IDS_CANT_ADDNAME                57359
#define IDS_CANT_GET_USERS              57360
#define IDS_NO_WKSALLOWED               57361
#define IDS_GROUP                       57362

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        149
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\transbmp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    transbmp.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////

class CTransBmp : public CBitmap
{
public:
    CTransBmp();
    ~CTransBmp();
    void Draw(HDC hDC, int x, int y);
    void Draw(CDC* pDC, int x, int y);
    void DrawTrans(HDC hDC, int x, int y);
    void DrawTrans(CDC* pDC, int x, int y);
    int GetWidth();
    int GetHeight();

private:
    int m_iWidth;
    int m_iHeight;
    CBitmap* m_hbmMask;    // handle to mask bitmap

    void GetMetrics();
    void CreateMask(HDC hDC);
	void CreateMask(CDC* pDC);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently

File History:

	JonY	Apr-96	created

--*/


//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxtempl.h>		// MFC templated classes

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxmt.h>			// MFC synchronization classes
#include <winnetwk.h>
#include <shlobj.h>			// Shell objects
#include <afxpriv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\romaine.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Romaine.h : main header file for the ROMAINE application

File History:

	JonY	Apr-96	created

--*/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMySheet

class CMySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMySheet)

// Construction
public:
	CMySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMySheet();

// Attributes
public:

// Operations
public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMySheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CRomaineApp:
// See Romaine.cpp for the implementation of this class
//

typedef struct tagTREEINFO
{
	HTREEITEM	hTreeItem;
	DWORD		dwBufSize;
	CObject*	pTree;
	BOOL		bExpand;
}
TREEINFO, *PTREEINFO;

class CRomaineApp : public CWinApp
{
public:
	CRomaineApp();

	CMySheet m_cps1;

	BOOL m_bServer;
	BOOL m_bDomain;
	CString m_csServer;
	CString m_csDomain;
	CString m_csCurrentDomain;
	CString m_csCurrentMachine;

// group attributes
	CString m_csGroupName;
	CString m_csGroupDesc;

	int m_nGroupType;

	CStringList m_csaNames;

// cmdline stuff
	CString m_csCmdLine;
	short m_sCmdLine;
	CString m_csCmdLineGroupName;

	USHORT m_sMode;

	CPropertyPage* pMach;
	BOOL bRestart2;
	BOOL bRestart1;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRomaineApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CRomaineApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   BOOL IsSecondInstance();

};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\trstlist.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disptrus.c(pp)

Author:

    Scott Field (sfield) 16-Mar-96

Revision:
	JonY	16-Apr-96	Modified to .cpp

--*/

#include "stdafx.h"
#include "trstlist.h"


#define RTN_OK 0
#define RTN_ERROR 13

//
// if you have the ddk, include ntstatus.h
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#endif


#define ELEMENT_COUNT 64    // number of array elements to allocate

CTrustList::CTrustList()
{
    m_dwTrustCount = 0;
    m_ppszTrustList = (LPWSTR *)HeapAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY,
        ELEMENT_COUNT * sizeof(LPWSTR)
        );
}

CTrustList::~CTrustList()
{
    //
    // free trust list
    //
	unsigned int i;
    for(i = 0 ; i < m_dwTrustCount ; i++) {
        if(m_ppszTrustList[i] != NULL)
            HeapFree(GetProcessHeap(), 0, m_ppszTrustList[i]);
    }

    HeapFree(GetProcessHeap(), 0, m_ppszTrustList);

}

BOOL
CTrustList::BuildTrustList(
    LPTSTR Target
    )
{
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;

    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain;
    BOOL bDC;
    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    //
    // open the policy on the specified machine
    //
    Status = OpenPolicy(
                Target,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if(Status != STATUS_SUCCESS) {
        SetLastError( LsaNtStatusToWinError(Status) );
        return FALSE;
    }

    //
    // obtain the AccountDomain, which is common to all three cases
    //
    Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (LPVOID*)&AccountDomain
                );

    if(Status != STATUS_SUCCESS)
        goto cleanup;

    //
    // Note: AccountDomain->DomainSid will contain binary Sid
    //
    AddTrustToList(&AccountDomain->DomainName);

    //
    // free memory allocated for account domain
    //
    LsaFreeMemory(AccountDomain);

    //
    // find out if the target machine is a domain controller
    //
    if(!IsDomainController(Target, &bDC)) {
        ////
        goto cleanup;
    }

    if(!bDC) {
        PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
        TCHAR* szPrimaryDomainName = NULL;
        TCHAR* DomainController = NULL;

        //
        // get the primary domain
        //
        Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyPrimaryDomainInformation,
                (LPVOID*)&PrimaryDomain
                );

        if(Status != STATUS_SUCCESS)
            goto cleanup;

        //
        // if the primary domain Sid is NULL, we are a non-member, and
        // our work is done.
        //
        if(PrimaryDomain->Sid == NULL) {
            LsaFreeMemory(PrimaryDomain);
            bSuccess = TRUE;
            goto cleanup;
        }

        AddTrustToList(&PrimaryDomain->Name);

        //
        // build a copy of what we just added.  This is necessary in order
        // to lookup the domain controller for the specified domain.
        // the Domain name must be NULL terminated for NetGetDCName(),
        // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
        // terminated.  Note that in a practical implementation, we
        // could just extract the element we added, since it ends up
        // NULL terminated.
        //

        szPrimaryDomainName = (LPTSTR)HeapAlloc(
            GetProcessHeap(), 0,
            PrimaryDomain->Name.Length + sizeof(WCHAR) // existing length + NULL
            );

        if(szPrimaryDomainName != NULL) {
            //
            // copy the existing buffer to the new storage, appending a NULL
            //
            _tcsncpy(
                szPrimaryDomainName,
                PrimaryDomain->Name.Buffer,
                (PrimaryDomain->Name.Length / 2) + 1
                );
        }

        LsaFreeMemory(PrimaryDomain);

        if(szPrimaryDomainName == NULL) goto cleanup;

        //
        // get the primary domain controller computer name
        //
        nas = NetGetDCName(
            NULL,
            szPrimaryDomainName,
            (LPBYTE *)&DomainController
            );

        HeapFree(GetProcessHeap(), 0, szPrimaryDomainName);

        if(nas != NERR_Success)
            goto cleanup;

        //
        // close the policy handle, because we don't need it anymore
        // for the workstation case, as we open a handle to a DC
        // policy below
        //
        LsaClose(PolicyHandle);
        PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

        //
        // open the policy on the domain controller
        //
        Status = OpenPolicy(
                    DomainController,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &PolicyHandle
                    );

        //
        // free the domaincontroller buffer
        //
        NetApiBufferFree(DomainController);

        if(Status != STATUS_SUCCESS)
            goto cleanup;
    }
				  
    //
    // build additional trusted domain(s) list and indicate if successful
    //
    bSuccess = EnumTrustedDomains(PolicyHandle);

cleanup:

    //
    // close the policy handle
    //
    if(PolicyHandle != INVALID_HANDLE_VALUE)
        LsaClose(PolicyHandle);

    if(!bSuccess) {
        if(Status != STATUS_SUCCESS)
            SetLastError( LsaNtStatusToWinError(Status) );
        else if(nas != NERR_Success)
            SetLastError( nas );
    }

    return bSuccess;
}

BOOL
CTrustList::EnumTrustedDomains(
    LSA_HANDLE PolicyHandle
    )
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // counter for items returned
    NTSTATUS Status;

    do {
        Status = LsaEnumerateTrustedDomains(
                        PolicyHandle,   // open policy handle
                        &lsaEnumHandle, // enumeration tracker
                        (LPVOID*)&TrustInfo,     // buffer to receive data
                        32000,          // recommended buffer size
                        &ulReturned     // number of items returned
                        );
        //
        // get out if an error occurred
        //
        if( (Status != STATUS_SUCCESS) &&
            (Status != STATUS_MORE_ENTRIES) &&
            (Status != STATUS_NO_MORE_ENTRIES)
            ) {
            SetLastError( LsaNtStatusToWinError(Status) );
            return FALSE;
        }

        //
        // Display results
        // Note: Sids are in TrustInfo[ulCounter].Sid
        //
        for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
            AddTrustToList(&TrustInfo[ulCounter].Name);

        //
        // free the buffer
        //
        LsaFreeMemory(TrustInfo);

    } while (Status != STATUS_NO_MORE_ENTRIES);

    return TRUE;
}

BOOL
CTrustList::IsDomainController(
    LPTSTR Server,
    LPBOOL bDomainController
    )
{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (LPBYTE *)&si101
        );

    if(nas != NERR_Success) {
        SetLastError(nas);
        return FALSE;
    }

    if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {
        //
        // we are dealing with a DC
        //
        *bDomainController = TRUE;
    } else {
        *bDomainController = FALSE;
    }

    NetApiBufferFree(si101);

    return TRUE;
}

BOOL
CTrustList::AddTrustToList(
    PLSA_UNICODE_STRING UnicodeString
    )
{
    if(m_dwTrustCount > ELEMENT_COUNT) return FALSE;

    //
    // allocate storage for array element
    //
    m_ppszTrustList[m_dwTrustCount] = (LPWSTR)HeapAlloc(
        GetProcessHeap(), 0,
        UnicodeString->Length + sizeof(WCHAR) // existing length + NULL
        );

    if(m_ppszTrustList[m_dwTrustCount] == NULL) return FALSE;

    //
    // copy the existing buffer to the new storage, appending a NULL
    //
    lstrcpynW(
        m_ppszTrustList[m_dwTrustCount],
        UnicodeString->Buffer,
        (UnicodeString->Length / 2) + 1
        );

    m_dwTrustCount++; // increment the trust count

    return TRUE;
}

void
CTrustList::InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPTSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = _tcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
}

NTSTATUS
CTrustList::OpenPolicy(
    LPTSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if(ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);

        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\trstlist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Trstlist.h : header file

File History:

	JonY	Apr-96	created

--*/

#include <windows.h>
#include <lm.h>
#include <ntsecapi.h> // \mstools\security\ntsecapi.h
#include <tchar.h>

class CTrustList
{
	public:
		TCHAR** m_ppszTrustList;        // array of trust elements
		DWORD m_dwTrustCount;         // number of elements in m_ppszTrustList

		CTrustList();
		~CTrustList();

		BOOL BuildTrustList(LPTSTR Target);

	private:
		BOOL IsDomainController(LPTSTR Server,
			LPBOOL bDomainController);

		BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle);

		BOOL AddTrustToList(PLSA_UNICODE_STRING UnicodeString);

		//
		// helper functions
		//

		void InitLsaString(PLSA_UNICODE_STRING LsaString,
			LPTSTR String);

		NTSTATUS OpenPolicy(LPTSTR ServerName,
			DWORD DesiredAccess,
			PLSA_HANDLE PolicyHandle);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\type.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Type.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CType dialog

class CType : public CPropertyPage
{
	DECLARE_DYNCREATE(CType)

// Construction
public:
	CType();
	~CType();

// Dialog Data
	//{{AFX_DATA(CType)
	enum { IDD = IDD_GROUP_TYPE_DLG };
	int		m_nGroupType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CType)
	public:
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CType)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\userlist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    UserList.cpp

	CListBox class for owner draw list that displays users and groups
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "resource.h"
#include "UserList.h"

const unsigned short BITMAP_HEIGHT = 18;
const unsigned short BITMAP_WIDTH = 18;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUserList

CUserList::CUserList()
{	 
	m_pBitmap[0] = new CTransBmp;
	m_pBitmap[0]->LoadBitmap(IDB_USER_BITMAP);

	m_pBitmap[1] = new CTransBmp;
	m_pBitmap[1]->LoadBitmap(IDB_GLOBAL_GROUP_BITMAP);

	m_pBitmap[2] = new CTransBmp;
	m_pBitmap[2]->LoadBitmap(IDB_WORLD);

	m_pBitmap[3] = new CTransBmp;
	m_pBitmap[3]->LoadBitmap(IDB_LOCAL_GROUP_BITMAP);

	m_pBitmap[4] = new CTransBmp;
	m_pBitmap[4]->LoadBitmap(IDB_LUSER_BITMAP);

	m_sHScrollWidth = 0;
}

CUserList::~CUserList()
{
	delete m_pBitmap[0];
	delete m_pBitmap[1];
	delete m_pBitmap[2];
	delete m_pBitmap[3];
	delete m_pBitmap[4];

}


BEGIN_MESSAGE_MAP(CUserList, CListBox)
	//{{AFX_MSG_MAP(CUserList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUserList message handlers
void CUserList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
// is this a valid item?
	if ((GetCount() == LB_ERR) || (lpDrawItemStruct->itemID > (UINT)GetCount())) return;

	COLORREF crefOldText;
	COLORREF crefOldBk;

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	pDC->SetBkMode(TRANSPARENT);
 
	HBRUSH hBrush;
	CTransBmp* pTempBmp = (CTransBmp*)lpDrawItemStruct->itemData;

	switch (lpDrawItemStruct->itemAction)
		{
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
// Display the text associated with the item. 
			HBITMAP hBitmapOld;

// Is the item selected?
            if (lpDrawItemStruct->itemState & ODS_SELECTED)
				{
				hBrush = CreateSolidBrush( GetSysColor(COLOR_HIGHLIGHT));
                hBitmapOld = (HBITMAP)pDC->SelectObject(pTempBmp);
                
                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT) );
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT) );
				}
            else
				{
                hBrush = (HBRUSH)GetStockObject( GetSysColor(COLOR_WINDOW));
                hBitmapOld = (HBITMAP)pDC->SelectObject(pTempBmp);

                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
				
				}		  

			pDC->FillRect(&(lpDrawItemStruct->rcItem), CBrush::FromHandle(hBrush));

// display text
// split apart the string to put the comments out to the side
			TCHAR* pName = (TCHAR*)malloc(255 * sizeof(TCHAR));
			if (pName == NULL)
				{
				AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
				exit(1);
				}

			GetText(lpDrawItemStruct->itemID, pName);
			
			TCHAR* pName2;
			pName = _tcstok(pName, _T(";"));	 // gets the name
			pName2 = _tcstok(NULL, _T(";"));	// gets the comment

// format the name + comment
            int nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top) / 2;
            pDC->TextOut(BITMAP_WIDTH + 6,
                (nTop - 8),
                pName);

			if (pName2 != NULL) pDC->TextOut(200,
											(nTop - 8),
											pName2);

// calculate width for horizontal scrolling
			CSize cs;
			cs = pDC->GetTextExtent(pName2);
			short nWidth = cs.cx + 200;
 
			if (nWidth > m_sHScrollWidth) 
				{
				m_sHScrollWidth = nWidth;
				SetHorizontalExtent(m_sHScrollWidth);
				}

			free(pName);

// Display bitmap
			nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top - BITMAP_HEIGHT) / 2;

			pTempBmp->DrawTrans(pDC, lpDrawItemStruct->rcItem.left,	nTop); 

			pDC->SetBkColor(crefOldBk );
            pDC->SetTextColor(crefOldText );
            pDC->SelectObject(hBitmapOld);
										 
            break;
		}

}

int CUserList::GetSelType(short sSel)
{
	int sCount = 0;
	while (sCount < 5)
		{
		if (m_pBitmap[sCount] == (CTransBmp*)GetItemData(sSel)) return sCount;
		sCount ++;
		}
	return -1;

}

CString CUserList::GetGroupName(short sSel)
{
	CString csText;
	GetText(sSel, csText);
	
	csText = csText.Left(csText.Find(L";"));
	return csText;
}

int CUserList::AddString(short nType, LPCTSTR lpItem)
{
	int nPos = CListBox::AddString((const TCHAR*) lpItem);
	if (nPos == LB_ERR) return LB_ERR;
	SetItemData(nPos, (DWORD)m_pBitmap[nType]); 

	return nPos;
}

int CUserList::AddString(LPCTSTR lpItem, DWORD dwBitmap)
{
	int nPos = CListBox::AddString((const TCHAR*) lpItem);
	if (nPos == LB_ERR) return LB_ERR;
	SetItemData(nPos, dwBitmap); 

	return nPos;
}

void CUserList::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	lpMeasureItemStruct->itemHeight = 18;	
}


int CUserList::VKeyToItem(UINT nKey, UINT nIndex) 
{
	// TODO: Add your code to handle a particular virtual key
	// return -1 = default action
	// return -2 = no further action
	// return index = perform default action for keystroke on
	//                item specified by index

	if (nKey == 46) DeleteString(GetCurSel());
	return -1;
}


int CUserList::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{

	TCHAR* pName1 = (TCHAR*)malloc(255 * sizeof(TCHAR));
	if (pName1 == NULL)
		{
		AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
		ExitProcess(1);
		}

	GetText(lpCompareItemStruct->itemID1, pName1);


	TCHAR* pName2 = (TCHAR*)malloc(255 * sizeof(TCHAR));
	if (pName2 == NULL)
		{
		AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
		ExitProcess(1);
		}

	GetText(lpCompareItemStruct->itemID2, pName2);

	int nRet = _tcsicmp(pName1, pName2);

	free(pName1);
	free(pName2);

	return nRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\type.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    Type.cpp

	CPropertyPage support for Group management wizard
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "Type.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CType property page

IMPLEMENT_DYNCREATE(CType, CPropertyPage)

CType::CType() : CPropertyPage(CType::IDD)
{
	//{{AFX_DATA_INIT(CType)
	m_nGroupType = 0;
	//}}AFX_DATA_INIT
}

CType::~CType()
{
}

void CType::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CType)
	DDX_Radio(pDX, IDC_GROUP_TYPE_RADIO, m_nGroupType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CType, CPropertyPage)
	//{{AFX_MSG_MAP(CType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CType message handlers

LRESULT CType::OnWizardNext() 
{
	UpdateData(TRUE);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_nGroupType = m_nGroupType;
	if (m_nGroupType == 0) return IDD_GLOBAL_USERS;
	else return IDD_LOCAL_USERS;
	
	return CPropertyPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\welcome.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    Welcome.cpp

	Property Page support for Group management wizard
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "Welcome.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWelcome property page

IMPLEMENT_DYNCREATE(CWelcome, CPropertyPage)

CWelcome::CWelcome() : CPropertyPage(CWelcome::IDD)
{
	//{{AFX_DATA_INIT(CWelcome)
	m_nMode = 0;
	//}}AFX_DATA_INIT
	m_pApp = (CRomaineApp*)AfxGetApp();
	m_pFont = NULL;

}

CWelcome::~CWelcome()
{
	if (m_pFont != NULL) delete m_pFont;
}

void CWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWelcome)
	DDX_Radio(pDX, IDC_NEW_GROUP_RADIO, m_nMode);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWelcome, CPropertyPage)
	//{{AFX_MSG_MAP(CWelcome)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcome message handlers
LRESULT CWelcome::OnWizardNext() 
{
	UpdateData(TRUE);
	m_pApp->m_sMode = m_nMode;

	m_pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	if (m_nMode == 1) 
		{
		m_pApp->m_csGroupName = L"";
		return IDD_LR_DIALOG;
		}

	else return IDD_NAME_DLG;
}

BOOL CWelcome::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	m_pFont = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  
	_tcscpy(lf.lfFaceName, L"MS Sans Serif");  
	lf.lfWeight = 700;
	m_pFont->CreateFontIndirect(&lf);    // Create the font.

	CString cs;
	cs.LoadString(IDS_WELCOME);
	CWnd* pWnd = GetDlgItem(IDC_WELCOME);
	pWnd->SetWindowText(cs);
	pWnd->SetFont(m_pFont);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWelcome::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	if (bShow) m_pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\welcome.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Welcome.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CWelcome dialog

class CWelcome : public CPropertyPage
{
	DECLARE_DYNCREATE(CWelcome)

// Construction
public:
	CWelcome();
	~CWelcome();

// Dialog Data
	//{{AFX_DATA(CWelcome)
	enum { IDD = IDD_WELCOME_DLG };
	int		m_nMode;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWelcome)
	public:
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CRomaineApp* m_pApp;
	CFont* m_pFont;
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWelcome)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\what.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    What.cpp

	Property Page support for Group management wizard
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "What.h"

#include <lmcons.h>
#include <lmaccess.h>
#include <lmerr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWhat property page

IMPLEMENT_DYNCREATE(CWhat, CPropertyPage)

CWhat::CWhat() : CPropertyPage(CWhat::IDD)
{
	//{{AFX_DATA_INIT(CWhat)
	m_csGroupName = _T("");
	m_csDescription = _T("");
	//}}AFX_DATA_INIT
}

CWhat::~CWhat()
{
}

void CWhat::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhat)
	DDX_Text(pDX, IDC_GROUP_NAME, m_csGroupName);
	DDX_Text(pDX, IDC_DESCRIPTION, m_csDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWhat, CPropertyPage)
	//{{AFX_MSG_MAP(CWhat)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWhat message handlers

LRESULT CWhat::OnWizardNext() 
{
	UpdateData(TRUE);
	CWnd* pWnd = GetDlgItem(IDC_GROUP_NAME);
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();

	if (m_csGroupName == "")
		{
		AfxMessageBox(IDS_NO_GROUP_NAME);
		pWnd->SetFocus();
		return -1;
		}
	
	if (m_csGroupName.FindOneOf(L"\"\\/[];:|=,+*?<>") != -1)
		{
		AfxMessageBox(IDS_GROUP_INVALID_NAME);
		pWnd->SetFocus();
		return -1;
		}

	if (m_csGroupName.GetLength() > 20)
		{
		AfxMessageBox(IDS_GROUP_INVALID_NAME);
		pWnd->SetFocus();
		return -1;
		}

	pApp->m_csGroupName = m_csGroupName;
	pApp->m_csGroupDesc = m_csDescription;

	return CPropertyPage::OnWizardNext();
}

void CWhat::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (bShow) 
		{
		GetDlgItem(IDC_GROUP_NAME)->SetFocus();
		pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
		if (pApp->bRestart1 == TRUE)
			{
			m_csGroupName = _T("");
			m_csDescription = _T("");
			UpdateData(FALSE);
			pApp->bRestart1 == FALSE;
			}
		}
	
}

LRESULT CWhat::OnWizardBack() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
	
	return CPropertyPage::OnWizardBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\userlist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    UserList.h : header file

File History:

	JonY	Apr-96	created

--*/

#include "transbmp.h"
/////////////////////////////////////////////////////////////////////////////
// CUserList window

class CUserList : public CListBox
{
// Construction
public:
	CUserList();

// Attributes
public:
private:
	CTransBmp* m_pBitmap[7];
	unsigned short m_sHScrollWidth;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUserList)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int VKeyToItem(UINT nKey, UINT nIndex);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CUserList();
	int AddString(short nType, LPCTSTR lpItem);
	int AddString(LPCTSTR lpItem, DWORD dwBitmap);
	int GetSelType(short sSel);
	CString GetGroupName(short sSel);

	// Generated message map functions
protected:
	//{{AFX_MSG(CUserList)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\accexp.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    AccExp.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "AccExp.h"

#include <winreg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAccExp property page

IMPLEMENT_DYNCREATE(CAccExp, CWizBaseDlg)

CAccExp::CAccExp() : CWizBaseDlg(CAccExp::IDD)
{
	//{{AFX_DATA_INIT(CAccExp)
	m_sDayEdit = 0;
	m_sYearEdit = 0;
	m_sMonthEdit = 0;
	//}}AFX_DATA_INIT
	CTime t = CTime::GetCurrentTime();

	m_sDayEdit = t.GetDay();
	m_sMonthEdit = t.GetMonth();
	m_sYearEdit = t.GetYear() + 1;
}

CAccExp::~CAccExp()
{
}

void CAccExp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAccExp)
	DDX_Control(pDX, IDC_STATIC2, m_cStatic2);
	DDX_Control(pDX, IDC_STATIC1, m_cStatic1);
	DDX_Control(pDX, IDC_DATE_SPIN, m_sbSpin);
	DDX_Text(pDX, IDC_MONTH_EDIT, m_csMonthEdit);
	DDX_Text(pDX, IDC_DAY_EDIT, m_csDayEdit);
	DDX_Text(pDX, IDC_YEAR_EDIT, m_csYearEdit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAccExp, CWizBaseDlg)
	//{{AFX_MSG_MAP(CAccExp)
	ON_EN_SETFOCUS(IDC_DAY_EDIT, OnSetfocusDayEdit)
	ON_EN_SETFOCUS(IDC_MONTH_EDIT, OnSetfocusMonthEdit)
	ON_EN_SETFOCUS(IDC_YEAR_EDIT, OnSetfocusYearEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAccExp message handlers

BOOL CAccExp::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();
	
	GetDlgItem(IDC_DAY_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_MONTH_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_YEAR_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_DATE_SPIN)->EnableWindow(TRUE);

// get date format from registry
	DWORD dwRet;
	HKEY hKey;
	DWORD cbProv = 0;
	TCHAR* lpProv = NULL;

    dwRet = RegOpenKey(HKEY_CURRENT_USER,
		TEXT("Control Panel\\International"), &hKey );

	TCHAR* lpSep;

// date separator
	if ((dwRet = RegQueryValueEx( hKey, TEXT("sDate"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpSep = (TCHAR*)malloc(cbProv);
		if (lpSep == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			ExitProcess(1);
			}
		dwRet = RegQueryValueEx( hKey, TEXT("sDate"), NULL, NULL, (LPBYTE) lpSep, &cbProv );
		}

	m_cStatic2.m_csDateSep = lpSep;

// only use one char
	m_cStatic2.m_csDateSep = m_cStatic2.m_csDateSep.Left(1);
	m_cStatic1.m_csDateSep = m_cStatic2.m_csDateSep;

// date order
	TCHAR* lpTemp;
	if ((dwRet = RegQueryValueEx( hKey, TEXT("sShortDate"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpTemp = (TCHAR*)malloc(cbProv);
		if (lpTemp == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			ExitProcess(1);
			}
		dwRet = RegQueryValueEx( hKey, TEXT("sShortDate"), NULL, NULL, (LPBYTE) lpTemp, &cbProv );
		}

// determine the order
	TCHAR* pTemp = _tcstok(lpTemp, lpSep);
	USHORT xPos = 170; // left most control
	USHORT yPos = 41;
	USHORT sCount = 0;
	while(pTemp != NULL)
		{
		CRect cr;
		if ((*pTemp == 'm') || (*pTemp == 'M')) 
			{
			GetDlgItem(IDC_MONTH_EDIT)->SetWindowPos(0, xPos, yPos, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			GetDlgItem(IDC_MONTH_EDIT)->GetWindowRect(&cr);
			xPos += cr.Width();
			}

		else if ((*pTemp == 'd') || (*pTemp == 'D')) 
			{
			GetDlgItem(IDC_DAY_EDIT)->SetWindowPos(0, xPos, yPos, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			GetDlgItem(IDC_DAY_EDIT)->GetWindowRect(&cr);
			xPos += cr.Width();
			}

		else if ((*pTemp == 'y') || (*pTemp == 'Y')) 
			{
			GetDlgItem(IDC_YEAR_EDIT)->SetWindowPos(0, xPos, yPos, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			GetDlgItem(IDC_YEAR_EDIT)->GetWindowRect(&cr);
			xPos += cr.Width();
			}
		
		if (sCount == 0) 
			{
			GetDlgItem(IDC_STATIC1)->SetWindowPos(0, xPos, yPos, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			GetDlgItem(IDC_STATIC1)->GetWindowRect(&cr);
			xPos += cr.Width();
			}

		if (sCount == 1) 
			{
			GetDlgItem(IDC_STATIC2)->SetWindowPos(0, xPos, yPos, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			GetDlgItem(IDC_STATIC2)->GetWindowRect(&cr);
			xPos += cr.Width();
			}
		
		pTemp = _tcstok(NULL, lpSep);
		sCount++;
		}

	free(lpTemp);
	free(lpSep);
	RegCloseKey(hKey);

// put the initial numeric values into the edit controls
	TCHAR pTemp2[4];
	wsprintf(pTemp2, L"%d", m_sDayEdit);
	m_csDayEdit = pTemp2;
	wsprintf(pTemp2, L"%d", m_sMonthEdit);
	m_csMonthEdit = pTemp2;
	wsprintf(pTemp2, L"%d", m_sYearEdit);
	m_csYearEdit = pTemp2;

	UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAccExp::OnSetfocusDayEdit() 
{
	m_sbSpin.SetBuddy(GetDlgItem(IDC_DAY_EDIT));
	m_sbSpin.SetRange(1,31);
}

void CAccExp::OnSetfocusMonthEdit() 
{
	m_sbSpin.SetBuddy(GetDlgItem(IDC_MONTH_EDIT));
	m_sbSpin.SetRange(1,12);
}

void CAccExp::OnSetfocusYearEdit() 
{
	m_sbSpin.SetBuddy(GetDlgItem(IDC_YEAR_EDIT));
	m_sbSpin.SetRange(1996, 2030);
}


LRESULT CAccExp::OnWizardNext() 
{
	UpdateData(TRUE);

// get the numberic values back out of the edit control(s)
	m_sDayEdit = _wtoi((LPCTSTR)m_csDayEdit);
	m_sMonthEdit = _wtoi((LPCTSTR)m_csMonthEdit);
	m_sYearEdit = _wtoi((LPCTSTR)m_csYearEdit);

// check for valid values
	USHORT sDays[] = {31,28,31,30,31,30,31,31,30,31,30,31};

// leap year?
	if (((m_sYearEdit - 1992) % 4) == 0) sDays[1] = 29;

	if ((m_sDayEdit > sDays[m_sMonthEdit - 1]) || (m_sDayEdit < 1))
		{
		AfxMessageBox(IDS_INVALID_DAY);
		GetDlgItem(IDC_DAY_EDIT)->SetFocus();
		return -1;
		}

	if ((m_sMonthEdit > 12) || (m_sMonthEdit < 1))
		{
		AfxMessageBox(IDS_INVALID_MONTH);
		GetDlgItem(IDC_MONTH_EDIT)->SetFocus();
		return -1;
		}

	if ((m_sYearEdit > 2030) || (m_sYearEdit < 1970))
		{
		AfxMessageBox(IDS_INVALID_YEAR);
		GetDlgItem(IDC_YEAR_EDIT)->SetFocus();
		return -1;
		}

	CTime t = CTime::GetCurrentTime();
	CTime tSet = CTime(m_sYearEdit, m_sMonthEdit, m_sDayEdit + 1, 23, 59, 59);

	if (tSet < t) 
		{
		if (AfxMessageBox(IDS_ALREADY_EXPIRED, MB_YESNO) != IDYES) return -1;
		}

// convert both values to GMT
	struct tm* GMTTime;
	GMTTime	= tSet.GetGmtTm(NULL);
	CTime tGMTSet = CTime((GMTTime->tm_year + 1900),
		GMTTime->tm_mon + 1,
		GMTTime->tm_mday,
		0, 0, 30, GMTTime->tm_isdst);

	CTime tStart = CTime(1970, 1, 1, 0, 0, 0);
	GMTTime	= tStart.GetGmtTm(NULL);
	CTime tGMTStart = CTime((GMTTime->tm_year + 1900),
		GMTTime->tm_mon + 1,
		GMTTime->tm_mday,
		0, 0, 0, GMTTime->tm_isdst);

	CTimeSpan ct = tGMTSet - tGMTStart;

	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	pApp->m_dwExpirationDate = ct.GetTotalSeconds();

	if (pApp->m_bHours) return IDD_HOURS_DLG;
	else if (pApp->m_bWorkstation) return IDD_LOGONTO_DLG;
	else if (pApp->m_bNW) return IDD_NWLOGON_DIALOG;
	else return IDD_FINISH;
	return CWizBaseDlg::OnWizardNext();
}

LRESULT CAccExp::OnWizardBack() 
{
	return IDD_RESTRICTIONS_DIALOG;
}


/////////////////////////////////////////////////////////////////////////////
// CStaticDelim

CStaticDelim::CStaticDelim()
{
	m_pFont = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  
	_tcscpy(lf.lfFaceName, TEXT("Arial"));  
	lf.lfWeight = 100;
	m_pFont->CreateFontIndirect(&lf);    // Create the font.

}

CStaticDelim::~CStaticDelim()
{
	delete m_pFont;
}


BEGIN_MESSAGE_MAP(CStaticDelim, CStatic)
	//{{AFX_MSG_MAP(CStaticDelim)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStaticDelim message handlers

void CStaticDelim::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	dc.SetBkColor(RGB(255, 255, 255));

	dc.SelectObject(m_pFont);
	dc.TextOut(0, 0, m_csDateSep);
	// Do not call CStatic::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\what.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    What.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CWhat dialog

class CWhat : public CPropertyPage
{
	DECLARE_DYNCREATE(CWhat)

// Construction
public:
	CWhat();
	~CWhat();

// Dialog Data
	//{{AFX_DATA(CWhat)
	enum { IDD = IDD_NAME_DLG };
	CString	m_csGroupName;
	CString	m_csDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWhat)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWhat)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\where.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    where.cpp

	Property Page support for Group management wizard
    
    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "Romaine.h"
#include "NetTree.h"
#include "Where.h"

#include <winreg.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <winnetwk.h>
#include <lmserver.h>

#ifdef _DEBUG
#define new DEBUG_NEW			  
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

unsigned int WhichNTProduct(CString& lpMachineName);
int ClassifyMachine(CString& csMachineName);

/////////////////////////////////////////////////////////////////////////////
// CWhere property page

IMPLEMENT_DYNCREATE(CWhere, CPropertyPage)

CWhere::CWhere() : CPropertyPage(CWhere::IDD)
{
	//{{AFX_DATA_INIT(CWhere)
	m_csMachineName = _T("");
	//}}AFX_DATA_INIT
	m_bExpandedOnce = 0;
}

CWhere::~CWhere()
{
}

void CWhere::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhere)
	DDX_Control(pDX, IDC_SERVER_TREE, m_ctServerTree);
	DDX_Text(pDX, IDC_MACHINE_NAME, m_csMachineName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWhere, CPropertyPage)
	//{{AFX_MSG_MAP(CWhere)
	ON_WM_SHOWWINDOW()
	ON_NOTIFY(TVN_SELCHANGED, IDC_SERVER_TREE, OnSelchangedServerTree)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWhere message handlers

LRESULT CWhere::OnWizardNext() 
{	
	UpdateData(TRUE);

	if (m_csMachineName == "")
		{
		AfxMessageBox(IDS_NO_MACHINE_NAME);
		CWnd* pWnd = GetDlgItem(IDC_MACHINE_NAME);
		pWnd->SetFocus();
		return -1;
		}

	int nVal = ClassifyMachine(m_csMachineName);

	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	pApp->m_csServer = m_csMachineName;
// go ahead and check the name for uniqueness
	TCHAR* pServer = m_csMachineName.GetBuffer(m_csMachineName.GetLength());
	m_csMachineName.ReleaseBuffer();

	TCHAR* pGroupName = pApp->m_csGroupName.GetBuffer(pApp->m_csGroupName.GetLength());
	pApp->m_csGroupName.ReleaseBuffer();

	GROUP_INFO_0* pInfo;
	NET_API_STATUS nAPI = NetGroupGetInfo(pServer,
		pGroupName,
		0,
		(LPBYTE*)&pInfo);

	if (nAPI == ERROR_SUCCESS)
		{
		AfxMessageBox(IDS_GROUP_EXISTS);
		return IDD_NAME_DLG;
		}

	LOCALGROUP_INFO_0* pLInfo;
	nAPI = NetLocalGroupGetInfo(pServer,
		pGroupName,
		0,
		(LPBYTE*)&pLInfo);

	if (nAPI == ERROR_SUCCESS)
		{
		AfxMessageBox(IDS_GROUP_EXISTS);
		return IDD_NAME_DLG;
		}

	return nVal;

}

int ClassifyMachine(CString& csMachineName)
{
	UINT ui;
	HKEY hKey;
	DWORD dwRet;
	DWORD cbProv = 0;

	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	csMachineName.MakeUpper();
// if a machine name is entered we need to know the domain
// if a domain name is entered we need to know the DC name
	if (csMachineName.Left(2) == "\\\\")
		{
		pApp->m_bDomain = FALSE;
		ui = WhichNTProduct(csMachineName);
// depending on the server type, provide an option for group type
		if ((ui == 2) || (ui == 1))	 // standalone server or wks
			{
			pApp->m_bServer = FALSE;
			pApp->m_csServer = csMachineName;
			pApp->m_nGroupType = 1;
			if (pApp->m_sMode == 0) return IDD_LOCAL_USERS;
			else return IDD_GROUP_LIST_DIALOG;
			}
		else if (ui == 3)	//pdc \ bdc
			{
			AfxMessageBox(IDS_DOMAIN_SET);

// find out what domain this is a server for
			TCHAR* lpProv = NULL;

			CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
			long lRet = RegConnectRegistry(
				(LPTSTR)csMachineName.GetBuffer(csMachineName.GetLength()), 
				HKEY_LOCAL_MACHINE,
				&hKey);
			
			dwRet = RegOpenKey(hKey,
				TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), &hKey );

			TCHAR* lpPrimaryDomain = NULL;
			if ((dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
				{
				lpPrimaryDomain = (TCHAR*)malloc(cbProv);
				if (lpPrimaryDomain == NULL)
					{
					AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
					ExitProcess(1);
					}

				dwRet = RegQueryValueEx( hKey, TEXT("CachePrimaryDomain"), NULL, NULL, (LPBYTE) lpPrimaryDomain, &cbProv );

				}

			RegCloseKey(hKey);

			TCHAR* lpszPrimaryDC;
			DWORD err = NetGetDCName(NULL,   
							lpPrimaryDomain,                  // Domain Name
							(LPBYTE *)&lpszPrimaryDC );  // returned PDC *

			pApp->m_csDomain = lpPrimaryDomain;
			pApp->m_csServer = lpszPrimaryDC;
			pApp->m_bDomain = TRUE;
			pApp->m_bServer = FALSE;
			free(lpPrimaryDomain);
			if (pApp->m_sMode == 0) return IDD_GROUP_TYPE_DLG;
			else return IDD_GROUP_LIST_DIALOG;
			}
		else 
			{
			AfxMessageBox(IDS_GENERIC_BAD_MACHINE);
			return -1;
			}
		}

	else
		{
		pApp->m_bDomain = TRUE;
		pApp->m_bServer = FALSE;
		TCHAR* lpszPrimaryDC;
		TCHAR* lpwDomain = csMachineName.GetBuffer(csMachineName.GetLength());
		DWORD err = NetGetDCName(NULL,   
			            lpwDomain,                  // Domain Name
				        (LPBYTE *)&lpszPrimaryDC );  // returned PDC *

		csMachineName.ReleaseBuffer();

		if (err == 2453)
			{
			AfxMessageBox(IDS_NO_DC);
			return -1;
			}

		pApp->m_csDomain = csMachineName;
		pApp->m_csServer = lpszPrimaryDC;
		if (pApp->m_sMode == 0) return IDD_GROUP_TYPE_DLG;
		else return IDD_GROUP_LIST_DIALOG;
		}
	return -1;
}
			
// given a machine name, return whether its a server or wks
unsigned int WhichNTProduct(CString& csMachineName)
{
	UINT uiRetVal = 0;
	PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        (LPTSTR)csMachineName.GetBuffer(csMachineName.GetLength()),
        101,    // info-level
        (LPBYTE *)&si101
        );

    if(nas != NERR_Success) 
		{
		NetApiBufferFree(si101);
        SetLastError(nas);
        return 0;
		}

    if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) 
		uiRetVal = 3;
	else if (si101->sv101_type & SV_TYPE_WORKSTATION) uiRetVal = 2;  //wks
	else if (si101->sv101_type & SV_TYPE_SERVER) uiRetVal = 1;		// server

 	NetApiBufferFree(si101);
 
    // else return Unknown
    return uiRetVal;
}

void CWhere::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
// Do the default domain expansion only once.
	if ((bShow) && (!m_bExpandedOnce))
	{
		m_bExpandedOnce = TRUE;
		m_ctServerTree.PopulateTree();
	}
	
}

void CWhere::OnSelchangedServerTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	HTREEITEM hItem = m_ctServerTree.GetSelectedItem();

	int nImage;
	m_ctServerTree.GetItemImage(hItem, nImage, nImage);
	if (nImage > 0)
		{
		CString csName;
		csName = m_ctServerTree.GetItemText(hItem);
		
		m_csMachineName = csName;
		}
	UpdateData(FALSE);

	
	*pResult = 0;
}

LRESULT CWhere::OnWizardBack() 
{
	CRomaineApp* pApp = (CRomaineApp*)AfxGetApp();
	if (pApp->m_sMode == 1) return IDD_WELCOME_DLG;
	else return CPropertyPage::OnWizardBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\accexp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    AccExp.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CStaticDelim window

class CStaticDelim : public CStatic
{
// Construction
public:
	CStaticDelim();
	CString m_csDateSep;

// Attributes
public:

// Operations
public:
   CFont* m_pFont;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStaticDelim)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStaticDelim();

	// Generated message map functions
protected:
	//{{AFX_MSG(CStaticDelim)
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CAccExp dialog

class CAccExp : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CAccExp)

// Construction
public:
	CAccExp();
	~CAccExp();

// Dialog Data
	//{{AFX_DATA(CAccExp)
	enum { IDD = IDD_ACCOUNT_EXP_DIALOG };
	CStaticDelim	m_cStatic2;
	CStaticDelim	m_cStatic1;
	CSpinButtonCtrl	m_sbSpin;
	CString	m_csDayEdit;
	CString	m_csYearEdit;
	CString	m_csMonthEdit;
	//}}AFX_DATA

	short	m_sDayEdit;
	short	m_sYearEdit;
	short	m_sMonthEdit;
			  
	// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAccExp)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAccExp)
	virtual BOOL OnInitDialog();
	afx_msg void OnSetfocusDayEdit();
	afx_msg void OnSetfocusMonthEdit();
	afx_msg void OnSetfocusYearEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addgrpw\where.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Where.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CWhere dialog

class CWhere : public CPropertyPage
{
	DECLARE_DYNCREATE(CWhere)

// Construction
public:
	CWhere();
	~CWhere();

// Dialog Data
	//{{AFX_DATA(CWhere)
	enum { IDD = IDD_MACHINE_DLG };
	CNetTreeCtrl	m_ctServerTree;
	CString	m_csMachineName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWhere)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
private:
	BOOL m_bExpandedOnce;
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWhere)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSelchangedServerTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\exch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Exch.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CExch dialog

class CExch : public CPropertyPage
{
	DECLARE_DYNCREATE(CExch)

// Construction
public:
	CExch();
	~CExch();

// Dialog Data
	//{{AFX_DATA(CExch)
	enum { IDD = IDD_EXCHANGE_DIALOG };
	CString	m_csDomainName;
	CString	m_csServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CExch)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

private:
	CString m_csDomain;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CExch)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\exch.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Exch.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "speckle.h"
#include "Exch.h"

#include "sadapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif







/////////////////////////////////////////////////////////////////////////////
// CExch property page

IMPLEMENT_DYNCREATE(CExch, CPropertyPage)

CExch::CExch() : CPropertyPage(CExch::IDD)
{
	//{{AFX_DATA_INIT(CExch)
	m_csDomainName = _T("");
	m_csServerName = _T("");
	//}}AFX_DATA_INIT
}

CExch::~CExch()
{
}

void CExch::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExch)
	DDX_Text(pDX, IDC_STATIC_DOMAIN, m_csDomainName);
	DDX_Text(pDX, IDC_SERVERNAME_EDIT, m_csServerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExch, CPropertyPage)
	//{{AFX_MSG_MAP(CExch)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExch message handlers

LRESULT CExch::OnWizardNext() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	UpdateData(TRUE);
	if (m_csServerName == L"")
		{
		AfxMessageBox(IDS_NO_EXCH_SERVER);
		GetDlgItem(IDC_SERVERNAME_EDIT)->SetFocus();
		return -1;
		}

	pApp->m_csExchangeServer = m_csServerName;
	return IDD_RESTRICTIONS_DIALOG;

}

LRESULT CExch::OnWizardBack() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;

}


void CExch::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
		m_csDomainName = pApp->m_csDomain;
		UpdateData(FALSE);

// bind to the first Exch server
/*		PRPCBINDINFO pBindInfo = new RPCBINDINFO;
		ZeroMemory(pBindInfo, sizeof(RPCBINDINFO));

		TCHAR wszServer[256];
//		ZeroMemory(wszServer, 256);
		_tcscpy(wszServer, L"");

		RPC_SC rVal = SAD_ScBind(pBindInfo, wszServer);
		if (rVal != ERROR_SUCCESS)
			{
			AfxMessageBox(L"cant bind");
			return;
			}

// using the first server, enumerate the rest
		BackupListNode* BackupNode = NULL;
		rVal = SAD_ScGetBackupListNodeW(pBindInfo->wszServer, &BackupNode);

		SAD_FreeBackupListNode(BackupNode);
		SAD_Unbind(pBindInfo);

		delete pBindInfo; 	*/
		 
			 		 
   	 /*
		RPC_NS_HANDLE		ic;
		RPC_STATUS			rpcstat;
		RPC_BINDING_HANDLE	h;
		BackupListNode *	pBLN = NULL;		

#define	szRPCEntryNameSAA	L"/.:/MSExchangeSAA"

		// create context for looking up entries in the RPC name service
	    rpcstat = RpcNsBindingImportBegin(RPC_C_NS_SYNTAX_DEFAULT,
										  szRPCEntryNameSAA,
										  TriggerBackupRPC_ClientIfHandle,
										  NULL,	
										  &ic);

		if (rpcstat == RPC_S_OK)
			{
				do
				{
					FreeBackupListNode(pBLN);
					pBLN = NULL;

					// bind to a server somewhere out there
					rpcstat = RpcNsBindingImportNext(ic, &h);
					if (rpcstat == RPC_S_OK)
					{
						// bind successful - try to get the list of servers
						RPC_SC rVal = ScGetBackupListNode(h, &pBLN);
						RpcBindingFree(&h);
						if (pBLN != NULL)
						{
							ASSERT(0);
							break;
						}
					}
				}
				while (rpcstat != RPC_S_NO_MORE_BINDINGS);
				RpcNsBindingImportDone(&ic);
			}	  */
		}		  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\fpinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    FPInfo.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "FPInfo.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFPInfo property page

IMPLEMENT_DYNCREATE(CFPInfo, CWizBaseDlg)

CFPInfo::CFPInfo() : CWizBaseDlg(CFPInfo::IDD)
{
	//{{AFX_DATA_INIT(CFPInfo)
	m_nGraceLogins = 0;
	m_nConcurrentConnections = 0;
	m_csCaption = _T("");
	m_sAllowedGraceLogins = 6;
	m_sConcurrentConnections = 1;
	//}}AFX_DATA_INIT
}
CFPInfo::~CFPInfo()
{
}

void CFPInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFPInfo)
	DDX_Control(pDX, IDC_CONCURRENT_CONNECTIONS_SPIN, m_sbConconSpin);
	DDX_Control(pDX, IDC_GRACE_LOGIN_SPIN, m_sbGraceLogins);
	DDX_Radio(pDX, IDC_GRACE_LOGIN_RADIO, m_nGraceLogins);
	DDX_Radio(pDX, IDC_CONCURRENT_CONNECTIONS_RADIO1, m_nConcurrentConnections);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	DDX_Text(pDX, IDC_ALLOWED_GRACE_LOGINS_EDIT, m_sAllowedGraceLogins);
	DDV_MinMaxUInt(pDX, m_sAllowedGraceLogins, 0, 200);
	DDX_Text(pDX, IDC_CONCURRENT_CONNECTIONS_EDIT, m_sConcurrentConnections);
	DDV_MinMaxUInt(pDX, m_sConcurrentConnections, 1, 1000);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFPInfo, CWizBaseDlg)
	//{{AFX_MSG_MAP(CFPInfo)
	ON_BN_CLICKED(IDC_GRACE_LOGIN_RADIO, OnGraceLoginRadio)
	ON_BN_CLICKED(IDC_GRACE_LOGIN_RADIO2, OnGraceLoginRadio2)
	ON_BN_CLICKED(IDC_CONCURRENT_CONNECTIONS_RADIO1, OnConcurrentConnectionsRadio)
	ON_BN_CLICKED(IDC_CONCURRENT_CONNECTIONS_RADIO2, OnConcurrentConnectionsRadio2)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFPInfo message handlers

// Disable the contents of the group control
void CFPInfo::OnGraceLoginRadio() 
{
	m_nGraceLogins = 0;
	GetDlgItem(IDC_ALLOWED_GRACE_LOGINS_EDIT)->EnableWindow(FALSE);
	GetDlgItem(IDC_GRACE_LOGIN_SPIN)->EnableWindow(FALSE);
	
}

// Enable the contents of the group control
void CFPInfo::OnGraceLoginRadio2() 
{
	m_nGraceLogins = 1;
	GetDlgItem(IDC_ALLOWED_GRACE_LOGINS_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_GRACE_LOGIN_SPIN)->EnableWindow(TRUE);

	m_sbGraceLogins.SetRange(0,200);
	
}

BOOL CFPInfo::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();

// set group box defaults
	GetDlgItem(IDC_ALLOWED_GRACE_LOGINS_EDIT)->EnableWindow(FALSE);
	GetDlgItem(IDC_GRACE_LOGIN_SPIN)->EnableWindow(FALSE);

	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_EDIT)->EnableWindow(FALSE);
	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_SPIN)->EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

// disable			 
void CFPInfo::OnConcurrentConnectionsRadio() 
{
	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_EDIT)->EnableWindow(FALSE);
	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_SPIN)->EnableWindow(FALSE);
}

// enable
void CFPInfo::OnConcurrentConnectionsRadio2() 
{
	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_CONCURRENT_CONNECTIONS_SPIN)->EnableWindow(TRUE);
	m_sbConconSpin.SetRange(1, 1000);
}

LRESULT CFPInfo::OnWizardNext() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	UpdateData(TRUE);

	if (m_nGraceLogins != 0) // limited
		{
		pApp->m_sNWAllowedGraceLogins = m_sAllowedGraceLogins;
		pApp->m_sNWRemainingGraceLogins = m_sAllowedGraceLogins;
		}
	else					// unlimited
		{
		pApp->m_sNWAllowedGraceLogins = 0x6;
		pApp->m_sNWRemainingGraceLogins = 0xff;
		}

	if (m_nConcurrentConnections == 0) pApp->m_sNWConcurrentConnections = 0xffff;
	else pApp->m_sNWConcurrentConnections = m_sConcurrentConnections;
	
	if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;
	
}

LRESULT CFPInfo::OnWizardBack() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;
	
}

void CFPInfo::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_FPNW_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\finish.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Finish.h : header file

File History:

	JonY	Apr-96	created

--*/


// Finish.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFinish dialog

// these will have to be revised for NTBUILD
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;


class CFinish : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CFinish)

// Construction
public:
	CFinish();
	~CFinish();
	virtual BOOL OnWizardFinish();
// Dialog Data
	//{{AFX_DATA(CFinish)
	enum { IDD = IDD_FINISH };
	CString	m_csCaption;
	//}}AFX_DATA

	DWORD dwPasswordFlags();
	BOOL bAddLocalGroups(LPWSTR lpwGroupName);
	BOOL bAddGlobalGroups(LPWSTR lpwGroupName);
	LRESULT OnWizardBack();


	ULONG ReturnNetwareEncryptedPassword(DWORD UserId,
							   LPWSTR pszUserName,
							   BOOL bDomain,	
							   LPCTSTR clearTextPassword,
							   UCHAR* NetwareEncryptedPassword );		// 16 byte encrypted password

	BOOL SetUserParam(UNICODE_STRING uString, LPWSTR lpwProp);
	DWORD SetNWWorkstations( const TCHAR * pchNWWorkstations);
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinish)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinish)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\fpinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    FPInfo.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CFPInfo dialog

class CFPInfo : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CFPInfo)

// Construction
public:
	CFPInfo();
	~CFPInfo();

// Dialog Data
	//{{AFX_DATA(CFPInfo)
	enum { IDD = IDD_FPNW_DLG };
	CSpinButtonCtrl	m_sbConconSpin;
	CSpinButtonCtrl	m_sbGraceLogins;
	BOOL	m_bExpireNWPassword;
	int		m_nGraceLogins;
	int		m_nConcurrentConnections;
	CString	m_csCaption;
	UINT	m_sAllowedGraceLogins;
	UINT	m_sConcurrentConnections;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFPInfo)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFPInfo)
	afx_msg void OnGraceLoginRadio();
	afx_msg void OnGraceLoginRadio2();
	virtual BOOL OnInitDialog();
	afx_msg void OnConcurrentConnectionsRadio();
	afx_msg void OnConcurrentConnectionsRadio2();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\finish.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Finish.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

    JonY    Apr-96  created

--*/


#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Finish.h"
#include "transbmp.h"

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmcons.h>

typedef long NTSTATUS;

extern "C"
{
    #include <fpnwcomm.h>
    #include <usrprop.h>
}
#include <rassapi.h>
#include "dapi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef ULONG (*SWAPOBJECTID) (ULONG);
typedef ULONG (*MAPRIDTOOBJECTID) (DWORD, LPWSTR, BOOL, BOOL);
typedef NTSTATUS (*GETREMOTENCPSECRETKEY) (PUNICODE_STRING, CHAR *);
typedef NTSTATUS (*RETURNNETWAREFORM)(const char *, DWORD, const WCHAR *, UCHAR *);
typedef NTSTATUS (*SETUSERPROPERTY)(LPWSTR, LPWSTR, UNICODE_STRING, WCHAR, LPWSTR*, BOOL*);

typedef DWORD (*RASADMINGETUSERACCOUNTSERVER)(const WCHAR*, const WCHAR*, LPWSTR);
typedef DWORD (*RASADMINUSERSETINFO)(const WCHAR*, const WCHAR*, const PRAS_USER_0);

typedef DWORD (*BATCHIMPORT) (LPBIMPORT_PARMSW);

/////////////////////////////////////////////////////////////////////////////
// CFinish property page

IMPLEMENT_DYNCREATE(CFinish, CWizBaseDlg)

CFinish::CFinish() : CWizBaseDlg(CFinish::IDD)
{
    //{{AFX_DATA_INIT(CFinish)
    m_csCaption = _T("");
    //}}AFX_DATA_INIT
}

CFinish::~CFinish()
{
}

void CFinish::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFinish)
    DDX_Text(pDX, IDC_STATIC1, m_csCaption);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinish, CWizBaseDlg)
    //{{AFX_MSG_MAP(CFinish)
    ON_WM_SHOWWINDOW()
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinish message handlers
BOOL CFinish::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CFinish::OnWizardBack()
{
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
    pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    if (pApp->m_bNW & pApp->m_bEnableRestrictions) return IDD_NWLOGON_DIALOG;
    else if (pApp->m_bWorkstation & pApp->m_bEnableRestrictions) return IDD_LOGONTO_DLG;
    else if (pApp->m_bHours & pApp->m_bEnableRestrictions) return IDD_HOURS_DLG;
    else if (pApp->m_bExpiration & pApp->m_bEnableRestrictions) return IDD_ACCOUNT_EXP_DIALOG;
    return IDD_RESTRICTIONS_DIALOG;

}

BOOL CFinish::OnWizardFinish()
{
    CString csSuccess, csTemp;

    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

    CWaitCursor wait;

    TCHAR* pDomainServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());

    PUSER_INFO_3 pui1 = (PUSER_INFO_3)VirtualAlloc(NULL, sizeof(_USER_INFO_3), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    pui1->usri3_name = pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength());
    pui1->usri3_password = pApp->m_csPassword1.GetBuffer(pApp->m_csPassword1.GetLength());
    pui1->usri3_priv = USER_PRIV_USER;
    pui1->usri3_comment = pApp->m_csDescription.GetBuffer(pApp->m_csDescription.GetLength());
    pui1->usri3_flags = dwPasswordFlags();
// availability hours - has to stay here to get the proper defaults!
    if (pApp->m_bHours) pui1->usri3_logon_hours = NULL;

    DWORD dwRet;
    NET_API_STATUS napi = NetUserAdd((unsigned short*)pDomainServer, (DWORD)1, (unsigned char*)pui1, &dwRet);
    VirtualFree(pui1, 0, MEM_RELEASE | MEM_DECOMMIT);
    if (napi != 0)
        {
        csTemp.LoadString(IDS_NO_NEW_USER);
        csSuccess.Format(csTemp, pApp->m_csFullName, pApp->m_csUserName);
        if (AfxMessageBox(csSuccess, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
            {
            pApp->m_cps1.SetActivePage(0);
            return FALSE;
            }
        else return TRUE;
        }

// set local group memberships
    short sGroupCount = pApp->m_csaSelectedLocalGroups.GetSize();
    short sCount;
    CString csVal;
    for (sCount = 0; sCount < sGroupCount; sCount++)
        {
        csVal = pApp->m_csaSelectedLocalGroups.GetAt(sCount);
        if (!bAddLocalGroups(csVal.GetBuffer(csVal.GetLength())))
            {
            AfxMessageBox(IDS_NO_LOCAL_GROUP);
            break;
            }
        }

// set global group memberships
    sGroupCount = pApp->m_csaSelectedGlobalGroups.GetSize();
    for (sCount = 0; sCount < sGroupCount; sCount++)
        {
        csVal = pApp->m_csaSelectedGlobalGroups.GetAt(sCount);
        if (!bAddGlobalGroups(csVal.GetBuffer(csVal.GetLength())))
            {
            AfxMessageBox(IDS_NO_GLOBAL_GROUP);
            break;
            }
        }

    pApp->m_csUserName.ReleaseBuffer();
    pApp->m_csPassword1.ReleaseBuffer();
    pApp->m_csDescription.ReleaseBuffer();

// more information to be set
    PUSER_INFO_3 pui2 = (PUSER_INFO_3)VirtualAlloc(NULL, sizeof(_USER_INFO_3), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    napi = NetUserGetInfo((unsigned short*)pDomainServer,
        pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength()),
        3,
        (LPBYTE*)&pui2);

    if (napi != ERROR_SUCCESS) goto failure;

    if (pApp->m_bHours) pui2->usri3_logon_hours = pApp->m_pHours;

// full name
    pui2->usri3_full_name = pApp->m_csFullName.GetBuffer(pApp->m_csFullName.GetLength());
    pApp->m_csFullName.ReleaseBuffer();

// seconds till expiration
    if (pApp->m_bExpiration) pui2->usri3_acct_expires = pApp->m_dwExpirationDate;

    if (pApp->m_bLoginScript)
        {
        pui2->usri3_script_path = pApp->m_csLogonScript.GetBuffer(pApp->m_csLogonScript.GetLength());
        pApp->m_csLogonScript.ReleaseBuffer();
        }

    if (pApp->m_bHomeDir)
        {
        pui2->usri3_home_dir = pApp->m_csHomeDir.GetBuffer(pApp->m_csHomeDir.GetLength());
        pApp->m_csHomeDir.ReleaseBuffer();
        }

    if (pApp->m_bProfile)
        {
        pui2->usri3_profile = pApp->m_csProfilePath.GetBuffer(pApp->m_csProfilePath.GetLength());
        pApp->m_csProfilePath.ReleaseBuffer();
        }

// home dir drive
    if (pApp->m_bHomeDir)
        {
        pui2->usri3_home_dir_drive = pApp->m_csHome_dir_drive.GetBuffer(pApp->m_csHome_dir_drive.GetLength());
        pApp->m_csHome_dir_drive.ReleaseBuffer();
        }

// available workstations
    if (pApp->m_bWorkstation)
        {
        pui2->usri3_workstations = pApp->m_csAllowedMachines.GetBuffer(pApp->m_csAllowedMachines.GetLength());
        pApp->m_csAllowedMachines.ReleaseBuffer();
        }

    if (pApp->m_bMust_Change_PW) pui2->usri3_password_expired = 1;

// primary group id //accept the default! will become domain users.
    pui2->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

    DWORD dwBuf;
    napi = NetUserSetInfo((unsigned short*)pDomainServer,
        pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength()),
        3,
        (LPBYTE)pui2,
        &dwBuf);

    VirtualFree(pui2, 0, MEM_RELEASE | MEM_DECOMMIT);
    if (napi != ERROR_SUCCESS) goto failure;

// NetWare compatible?
    if (pApp->m_bNW)
        {
        TCHAR* pUsername = pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength());
        pApp->m_csUserName.ReleaseBuffer();

        // get NWSETINFO fn
        HINSTANCE hLib = LoadLibrary(L"fpnwclnt.dll");

        //
        //  SetUserProperty has been moved from fpnwclnt.dll to netapi32.dll
        //  for the RAS guys.  We no longer have to dynamically link it in.
        //

#if 0
        SETUSERPROPERTY pSetUserProperty = (SETUSERPROPERTY)GetProcAddress(hLib, "SetUserProperty");
#endif
        UNICODE_STRING uString;
        BOOL bRet;

// first set the password
        CString ucPW = pApp->m_csPassword1;
        ucPW.MakeUpper();
        UCHAR* pNWPW = (UCHAR*)malloc(16);
        ULONG ulRet = ReturnNetwareEncryptedPassword(pui2->usri3_user_id,
                               pui2->usri3_name,
                               pApp->m_bDomain,
                               (LPCTSTR)ucPW,
                               pNWPW);

        if (ulRet != 0)
            {
            AfxMessageBox(IDS_NW_PW_ERROR);
            goto failure;
            }

        try
            {
            uString.Length = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
            uString.MaximumLength = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
            uString.Buffer = (PWCHAR)pNWPW;

            bRet = SetUserParam(uString, NWPASSWORD);
            }
        catch(...)
            {
            AfxMessageBox(IDS_NW_PW_ERROR);
            goto failure;
            }

// grace logins - allowed
        try
            {
            uString.Length = 2;
            uString.MaximumLength = 2;
            uString.Buffer = &pApp->m_sNWRemainingGraceLogins;
            bRet = SetUserParam(uString, GRACELOGINREMAINING);

            uString.Buffer = &pApp->m_sNWAllowedGraceLogins;
            bRet = SetUserParam(uString, GRACELOGINALLOWED);
            }
        catch(...)
            {
            AfxMessageBox(IDS_NW_GRACELOGIN_ERROR);
            goto failure;
            }

// concurrent connections
        try
            {
            uString.Length = 2;
            uString.MaximumLength = 2;
            uString.Buffer = &pApp->m_sNWConcurrentConnections;

            bRet = SetUserParam(uString, MAXCONNECTIONS);
            }
        catch(...)
            {
            AfxMessageBox(IDS_NW_CONCON_ERROR);
            goto failure;
            }

// set allowed machines
        try
            {
            TCHAR* pNWWks = pApp->m_csAllowedLoginFrom.GetBuffer(pApp->m_csAllowedLoginFrom.GetLength());
            pApp->m_csAllowedLoginFrom.ReleaseBuffer();

            if (SetNWWorkstations(pNWWks) != ERROR_SUCCESS)
                {
                AfxMessageBox(IDS_NOFP_WS);
                goto failure;
                }
            }
        catch(...)
            {
            AfxMessageBox(IDS_NOFP_WS);
            goto failure;
            }

// all done?
        FreeLibrary(hLib);
        if (pNWPW != NULL) free(pNWPW);
        }

// RAS
    HINSTANCE hLib;
    if ((hLib = LoadLibrary(L"rassapi.dll")) != NULL && pApp->m_bRAS)
        {
        RASADMINGETUSERACCOUNTSERVER pRasAdminGetUserAccountServer = (RASADMINGETUSERACCOUNTSERVER)GetProcAddress(hLib, "RasAdminGetUserAccountServer");
        RASADMINUSERSETINFO pRasAdminUserSetInfo = (RASADMINUSERSETINFO)GetProcAddress(hLib, "RasAdminUserSetInfo");

        TCHAR pAccount[30];
        TCHAR* pDomain = pApp->m_csDomain.GetBuffer(pApp->m_csDomain.GetLength());
        pApp->m_csDomain.ReleaseBuffer();

        DWORD dwErr = pRasAdminGetUserAccountServer(pDomain, pDomainServer, pAccount);

        PRAS_USER_0 pBit = (PRAS_USER_0)malloc(sizeof(_RAS_USER_0) + 1);
ZeroMemory(pBit, sizeof(RAS_USER_0));
        pBit->bfPrivilege = 0;

// this is always set since they selected RAS in the first place
        pBit->bfPrivilege |= RASPRIV_DialinPrivilege;

        switch(pApp->m_sCallBackType)
            {
            case 0:
                pBit->bfPrivilege |= RASPRIV_NoCallback;
                break;

            case 1:
                pBit->bfPrivilege |= RASPRIV_CallerSetCallback;
                break;

            case 2:
                pBit->bfPrivilege |= RASPRIV_AdminSetCallback;
                _tcscpy(pBit->szPhoneNumber, (LPCTSTR)pApp->m_csRasPhoneNumber);
                break;
            }

        dwErr = pRasAdminUserSetInfo(pAccount, pui1->usri3_name, pBit);
        if (dwErr != ERROR_SUCCESS)
            {
            AfxMessageBox(IDS_RAS_ERROR);
DWORD dd = GetLastError();
CString cs;
cs.Format(L"getlasterror = %d, dwerr = %d", dd, dwErr);
AfxMessageBox(cs);
            goto failure;
            }

        FreeLibrary(hLib);
        free(pBit);
        }


// exchange?
    if (pApp->m_bExchange)
        {
//      pApp->m_csExchangeServer = L"IRIS2";
        // first create the script file
        TCHAR lpPath[MAX_PATH];
        UINT ui = GetTempFileName(L".", L"auw", 0, lpPath);
        if (ui == 0)
            goto failure;

        HANDLE hFile = CreateFile(lpPath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFile == INVALID_HANDLE_VALUE)
            goto failure;

        TCHAR pHeader[] = L"OBJ-CLASS, Common-Name, Home-Server, Comment, Hide-from-address-book, Display-name\n\r";
        DWORD dwLen = _tcslen(pHeader) * sizeof(TCHAR);
        DWORD dwBytesWritten;
        BOOL bVal = WriteFile(hFile,
            pHeader,
            dwLen,
            &dwBytesWritten,
            NULL);

        if (!bVal)
            goto failure;

        // now write the user's info
        CString csExchangeVal;
        csExchangeVal.Format(L"MAILBOX, %s, %s, %s, 0, %s",
            pApp->m_csUserName,
            pApp->m_csExchangeServer,
            pApp->m_csDescription,
            pApp->m_csFullName);

        bVal = WriteFile(hFile,
            (LPCTSTR)csExchangeVal,
            csExchangeVal.GetLength() * sizeof(TCHAR),
            &dwBytesWritten,
            NULL);

        if (!bVal)
            goto failure;

        // batch import function
        BIMPORT_PARMSW* pBImport = (BIMPORT_PARMSW*)malloc(sizeof(BIMPORT_PARMSW) * sizeof(TCHAR));
        ZeroMemory(pBImport, sizeof(BIMPORT_PARMSW) * sizeof(TCHAR));

        pBImport->dwDAPISignature = DAPI_SIGNATURE;
        pBImport->dwFlags = DAPI_YES_TO_ALL | DAPI_SUPPRESS_PROGRESS |
            DAPI_SUPPRESS_COMPLETION | DAPI_SUPPRESS_ARCHIVES;
        pBImport->hwndParent = GetSafeHwnd();
        pBImport->pszImportFile = lpPath;       // path to filename
        pBImport->uCodePage = DAPI_UNICODE_FILE; // UNICODE file
        pBImport->pszDSAName = pApp->m_csExchangeServer.GetBuffer(pApp->m_csExchangeServer.GetLength());       // this is the exchange server we are adding to
        pApp->m_csExchangeServer.ReleaseBuffer();
        pBImport->pszBasePoint = NULL;
        pBImport->pszContainer = L"Recipients";
        pBImport->chColSep = DAPI_DEFAULT_DELIMW;  // default column sep
        pBImport->chQuote = DAPI_DEFAULT_QUOTEW;    // default quote mark
        pBImport->chMVSep = DAPI_DEFAULT_MV_SEPW;       // multi value column sep
        pBImport->pszNTDomain = pApp->m_csDomain.GetBuffer(pApp->m_csDomain.GetLength());// Domain to lookup accounts in
        pApp->m_csDomain.ReleaseBuffer();
        pBImport->pszCreateTemplate = NULL; // template user

        HINSTANCE hExLib = LoadLibrary(L"dapi.dll");
        if (hExLib == NULL)
            goto failure;

        BATCHIMPORT pBatchImport = (BATCHIMPORT)GetProcAddress(hExLib, "BatchImportW@4");
        if (pBatchImport == NULL)
            goto failure;

        CloseHandle(hFile);// have to close the file before exch can see it
        DWORD dw = pBatchImport(pBImport);

// don't forget to delete the tmp file
        FreeLibrary(hExLib);
        DeleteFile(lpPath);
        free(pBImport);

        if (dw != ERROR_SUCCESS) goto failure;
        }

    if (pApp->m_csFullName != L"")
        {
        csTemp.LoadString(IDS_SUCCESS);
        csSuccess.Format(csTemp, pApp->m_csFullName, pApp->m_csUserName);
        }
    else
        {
        csTemp.LoadString(IDS_SUCCESS2);
        csSuccess.Format(csTemp, pApp->m_csUserName);
        }

    if (AfxMessageBox(csSuccess, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
        {
        pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
        pApp->m_cps1.SetActivePage(0);
        pApp->m_bPRSReset = TRUE;
        pApp->m_bPWReset = TRUE;
//      pApp->m_bGReset = TRUE;
        return FALSE;
        }
    else return TRUE;

failure:
    if (pApp->m_csFullName != L"")
        {
        csTemp.LoadString(IDS_BAD_USER_DATA);
        csSuccess.Format(csTemp, pApp->m_csFullName, pApp->m_csUserName);
        }
    else
        {
        csTemp.LoadString(IDS_BAD_USER_DATA2);
        csSuccess.Format(csTemp, pApp->m_csUserName);
        }

    csSuccess.Format(csTemp, pApp->m_csFullName, pApp->m_csUserName);
    if (AfxMessageBox(csSuccess, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
        {
        pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
        pApp->m_cps1.SetActivePage(0);
        pApp->m_bPRSReset = TRUE;
        pApp->m_bPWReset = TRUE;

        return FALSE;
        }
    else return TRUE;

}

DWORD CFinish::dwPasswordFlags()
{
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

    DWORD dwFlags = UF_SCRIPT;

    if (pApp->m_bDisabled) dwFlags |= UF_ACCOUNTDISABLE;
    if (!pApp->m_bChange_Password) dwFlags |= UF_PASSWD_CANT_CHANGE;
    if (pApp->m_bPW_Never_Expires) dwFlags |= UF_DONT_EXPIRE_PASSWD;

    return dwFlags;

}

BOOL CFinish::bAddLocalGroups(LPWSTR lpwGroupName)
{
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
    TCHAR* pDomainServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());

    LOCALGROUP_MEMBERS_INFO_3 localgroup_members;

    localgroup_members.lgrmi3_domainandname = pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength());

    DWORD err = NetLocalGroupAddMembers( (unsigned short*)pDomainServer,        /* PDC name */
                                   lpwGroupName,       /* group name */
                                   3,                    /* passing in name */
                                   (LPBYTE)&localgroup_members, /* Buffer */
                                   1 );                  /* count passed in */

    pApp->m_csUserName.ReleaseBuffer();
    pApp->m_csServer.ReleaseBuffer();

    if (err != 0) return FALSE;
    return TRUE;
}

BOOL CFinish::bAddGlobalGroups(LPTSTR lpwGroupName)
{
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
    TCHAR* pDomainServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());

    DWORD dwErr = NetGroupAddUser((LPTSTR)pDomainServer,
        lpwGroupName,
        pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength()));

    pApp->m_csUserName.ReleaseBuffer();
    pApp->m_csServer.ReleaseBuffer();

    if ((dwErr != 0) && (dwErr != 2236)) return FALSE;
    return TRUE;
}



ULONG
CFinish::ReturnNetwareEncryptedPassword(DWORD UserId,
                               LPWSTR pszUserName,
                               BOOL bDomain,
                               LPCTSTR clearTextPassword,
                               UCHAR* NetwareEncryptedPassword )        // 16 byte encrypted password
{
    char lsaSecret[20];
    NTSTATUS status;
    ULONG objectId;

    HINSTANCE hLib = LoadLibrary(L"fpnwclnt.dll");
    if (hLib == NULL) return 1;

// if this is a server, modify the User ID:
    if (bDomain) UserId |= 0x10000000;

// get lsa key from GetNcpSecretKey
    GETREMOTENCPSECRETKEY pGetRemoteNcpSecretKey = (GETREMOTENCPSECRETKEY)GetProcAddress(hLib, "GetRemoteNcpSecretKey");
    if (pGetRemoteNcpSecretKey == NULL) return 1;

    UNICODE_STRING usServer;
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
    usServer.Length = pApp->m_csServer.GetLength() * sizeof(WCHAR);
    usServer.MaximumLength = pApp->m_csServer.GetLength() * sizeof(WCHAR);
    usServer.Buffer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
    pApp->m_csServer.ReleaseBuffer();

    status = (*pGetRemoteNcpSecretKey)( &usServer, lsaSecret );
    if (status != ERROR_SUCCESS) return 1;

// Convert rid to object id
    MAPRIDTOOBJECTID pMapRidToObjectId = (MAPRIDTOOBJECTID)GetProcAddress(hLib, "MapRidToObjectId");
    if (pMapRidToObjectId == NULL) return 1;

    objectId = (*pMapRidToObjectId)( UserId, pszUserName, bDomain, FALSE );

// now get the password
    RETURNNETWAREFORM pReturnNetwareForm = (RETURNNETWAREFORM)GetProcAddress(hLib, "ReturnNetwareForm");
    if (pReturnNetwareForm == NULL) return 1;

    try
        {
        status = (*pReturnNetwareForm)( lsaSecret,
                    objectId,
                    clearTextPassword,
                    NetwareEncryptedPassword);
        }
    catch(...)
        {
        FreeLibrary(hLib);
        return 1L;
        }

    // clean up
    FreeLibrary(hLib);

    return 0L;

}


BOOL CFinish::SetUserParam(UNICODE_STRING uString, LPWSTR lpwProp)
{
// get existing prop value
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
    TCHAR* pUsername = pApp->m_csUserName.GetBuffer(pApp->m_csUserName.GetLength());
    pApp->m_csUserName.ReleaseBuffer();

    TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
    pApp->m_csServer.ReleaseBuffer();

    PUSER_INFO_3 pui2 = (PUSER_INFO_3)VirtualAlloc(NULL, sizeof(_USER_INFO_3), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    NET_API_STATUS napi = NetUserGetInfo(pServer,
        pUsername,
        3,
        (LPBYTE*)&pui2);

// set NW prop
    //
    //  SetUserProperty has been moved from fpnwclnt.dll to netapi32.dll
    //  for the RAS guys.  We no longer have to dynamically link it in.
    //
#if 0
    HINSTANCE hLib = LoadLibrary(L"fpnwclnt.dll");
    SETUSERPROPERTY pSetUserProperty = (SETUSERPROPERTY)GetProcAddress(hLib, "SetUserProperty");
#endif

    LPWSTR lpNewProp = NULL;
    BOOL bUpdate;

    NTSTATUS status = NetpParmsSetUserProperty((LPWSTR)pui2->usri3_parms,
        (LPWSTR)lpwProp,
        uString,
        USER_PROPERTY_TYPE_ITEM,
        &lpNewProp,
        &bUpdate);

    if (status != ERROR_SUCCESS) return FALSE;

// reset user prop
    DWORD dwBuf;
    if (bUpdate)
        {
        pui2->usri3_parms = lpNewProp;
        napi = NetUserSetInfo(pServer,
            pUsername,
            3,
            (LPBYTE)pui2,
            &dwBuf);

        }

    if (lpNewProp != NULL) NetpParmsUserPropertyFree(lpNewProp);
    VirtualFree(pui2, 0, MEM_RELEASE | MEM_DECOMMIT);
//  FreeLibrary(hLib);
    return TRUE;

}

void CFinish::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CWizBaseDlg::OnShowWindow(bShow, nStatus);
    CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

    if (bShow)
        {
        pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);

        CString csTemp;
        csTemp.LoadString(IDS_FINISH_CAPTION);

        CString csTemp2;
        csTemp2.Format(csTemp, pApp->m_csUserName);
        m_csCaption = csTemp2;
        UpdateData(FALSE);
        }
//  else pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

}

/*******************************************************************

    NAME:   USER_NW::SetNWWorkstations

    SYNOPSIS:   Store NetWare allowed workstation addresses to UserParms
                If pchNWWorkstations is NULL, this function will delete
                "NWLgonFrom" field from UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

DWORD CFinish::SetNWWorkstations( const TCHAR * pchNWWorkstations)
{
    DWORD err = ERROR_SUCCESS;
    UNICODE_STRING uniNWWorkstations;
    CHAR * pchTemp = NULL;

    if (pchNWWorkstations == NULL)
    {
        uniNWWorkstations.Buffer = NULL;
        uniNWWorkstations.Length =  0;
        uniNWWorkstations.MaximumLength = 0;
    }
    else
    {
        BOOL fDummy;
        INT  nStringLength = lstrlen(pchNWWorkstations) + 1;
        pchTemp = (CHAR *) LocalAlloc (LPTR, nStringLength);

        if ( pchTemp == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;

        if ( err == ERROR_SUCCESS &&
             !WideCharToMultiByte (CP_ACP,
                                   0,
                                   pchNWWorkstations,
                                   nStringLength,
                                   pchTemp,
                                   nStringLength,
                                   NULL,
                                   &fDummy))
        {
            err = ::GetLastError();
        }

        if ( err == ERROR_SUCCESS )
        {
            uniNWWorkstations.Buffer = (WCHAR *) pchTemp;
            uniNWWorkstations.Length =  nStringLength;
            uniNWWorkstations.MaximumLength = nStringLength;
        }
    }

    if (!SetUserParam(uniNWWorkstations, NWLOGONFROM)) err = 1;
    else err = ERROR_SUCCESS;

    if (pchTemp != NULL)
    {
        LocalFree (pchTemp);
    }

    return err;
}

void CFinish::OnPaint()
{
    CPaintDC dc(this); // device context for painting

    CTransBmp* pBitmap = new CTransBmp;
    pBitmap->LoadBitmap(IDB_ENDFLAG);

    pBitmap->DrawTrans(&dc, 0,0);
    delete pBitmap;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\ginfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ginfo.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "Speckle.h"
#include "userlist.h"
#include "wizbased.h"
#include "ginfo.h"

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupInfo property page

IMPLEMENT_DYNCREATE(CGroupInfo, CWizBaseDlg)

CGroupInfo::CGroupInfo() : CWizBaseDlg(CGroupInfo::IDD)
{
	//{{AFX_DATA_INIT(CGroupInfo)
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

CGroupInfo::~CGroupInfo()
{
}

void CGroupInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupInfo)
	DDX_Control(pDX, IDC_GROUP_MEMBER_LIST, m_lbSelectedGroups);
	DDX_Control(pDX, IDC_GROUP_AVAILABLE_LIST, m_lbAvailableGroups);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupInfo, CWizBaseDlg)
	//{{AFX_MSG_MAP(CGroupInfo)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_LBN_SETFOCUS(IDC_GROUP_AVAILABLE_LIST, OnSetfocusGroupAvailableList)
	ON_LBN_SETFOCUS(IDC_GROUP_MEMBER_LIST, OnSetfocusGroupMemberList)
	ON_LBN_SELCHANGE(IDC_GROUP_MEMBER_LIST, OnSelchangeGroupMemberList)
	ON_WM_SHOWWINDOW()
	ON_LBN_DBLCLK(IDC_GROUP_AVAILABLE_LIST, OnDblclkGroupAvailableList)
	ON_LBN_DBLCLK(IDC_GROUP_MEMBER_LIST, OnDblclkGroupMemberList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGroupInfo message handlers

BOOL CGroupInfo::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGroupInfo::OnAddButton() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbAvailableGroups.GetCurSel();
	if (usSel == LB_ERR) 
		{
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		m_lbSelectedGroups.SetCurSel(0);
		return;
		}

	CString csSel;
	m_lbAvailableGroups.GetText(usSel, csSel);
	USHORT usBmp = m_lbAvailableGroups.GetBitmapID(usSel);
	m_lbSelectedGroups.AddString(csSel, usBmp);
	m_lbAvailableGroups.DeleteString(usSel);

// anybody left?
	if (m_lbAvailableGroups.GetCount() != 0)
		m_lbAvailableGroups.SetCurSel(0);

	else
		{
		m_lbSelectedGroups.SetCurSel(0);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		m_lbAvailableGroups.SetHorizontalExtent(0);
		}


}

void CGroupInfo::OnRemoveButton() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbSelectedGroups.GetCurSel();
	if (usSel == 65535) 
		{
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		m_lbAvailableGroups.SetCurSel(0);
		return;
		}

	CString csSel;
	m_lbSelectedGroups.GetText(usSel, csSel);

	USHORT usBmp = m_lbSelectedGroups.GetBitmapID(usSel);
	m_lbAvailableGroups.AddString(csSel, usBmp);
	m_lbSelectedGroups.DeleteString(usSel);

// anybody left?
	if (m_lbSelectedGroups.GetCount() != 0)
		m_lbSelectedGroups.SetCurSel(0);

	else
		{
		m_lbAvailableGroups.SetCurSel(0);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		m_lbSelectedGroups.SetHorizontalExtent(0);
		}	
}

LRESULT CGroupInfo::OnWizardBack() 
{
	return CPropertyPage::OnWizardBack();
}

LRESULT CGroupInfo::OnWizardNext() 
{
	UpdateData(TRUE);
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

// add selected groups to list
	pApp->m_csaSelectedLocalGroups.RemoveAll();
	pApp->m_csaSelectedGlobalGroups.RemoveAll();
	short sGroupCount = m_lbSelectedGroups.GetCount();
	short sCount;
	CString csVal;
	for (sCount = 0; sCount < sGroupCount; sCount++)
		{
		USHORT usBmp = m_lbSelectedGroups.GetBitmapID(sCount);
		m_lbSelectedGroups.GetText(sCount, csVal);
		
		if (usBmp == 3) pApp->m_csaSelectedLocalGroups.Add(csVal);
		else if (usBmp == 1) pApp->m_csaSelectedGlobalGroups.Add(csVal);
		}

	pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);

	return CPropertyPage::OnWizardNext();
}

void CGroupInfo::OnSetfocusGroupAvailableList() 
{
	m_lbSelectedGroups.SetCurSel(-1);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	
}

void CGroupInfo::OnSetfocusGroupMemberList() 
{
	UpdateData(TRUE);
	m_lbAvailableGroups.SetCurSel(-1);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);

}

void CGroupInfo::OnSelchangeGroupMemberList() 
{
	UpdateData(TRUE);
}

void CGroupInfo::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (!bShow) return;
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (!pApp->m_bGReset) return;
	pApp->m_bGReset = FALSE;
	m_lbAvailableGroups.ResetContent();
	m_lbSelectedGroups.ResetContent();

	CWaitCursor wait;

	DWORD dwEntriesRead = 0;
	DWORD dwTotalEntries = 0;
	DWORD dwResumeHandle = 0;

	NET_API_STATUS nApi;
	unsigned long sIndex;

	TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
	pApp->m_csServer.ReleaseBuffer();

// if this is on a domain, check for global groups
	if (pApp->m_bDomain)
		{
		PGROUP_INFO_1 pInfo;

		do 
			{
			nApi = NetGroupEnum(pServer,
				(DWORD)1, 
				(PBYTE*)&pInfo,	
				(DWORD)5000, 
				&dwEntriesRead,
				&dwTotalEntries, 
				&dwResumeHandle);

			for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
				{
				TCHAR sTemp[50];

				swprintf(sTemp, TEXT("%s"), pInfo[sIndex].grpi1_name);
				m_lbAvailableGroups.AddString(1, sTemp);
				}

			NetApiBufferFree(pInfo);
			} while (dwResumeHandle != 0);

//		m_lbSelectedGroups.AddString(1, TEXT("Domain Users"));

		UpdateData(FALSE);
		}

	PLOCALGROUP_INFO_1 pLocalInfo;
	dwResumeHandle = 0;
	do 
		{
		nApi = NetLocalGroupEnum(pServer,
			(DWORD)1, 
			(PBYTE*)&pLocalInfo,
			(DWORD)5000, 
			&dwEntriesRead,
			&dwTotalEntries, 
			&dwResumeHandle);

		for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
			{
			TCHAR sTemp[50];

			swprintf(sTemp, TEXT("%s"), pLocalInfo[sIndex].lgrpi1_name);
			m_lbAvailableGroups.AddString(3, sTemp);
			}

		NetApiBufferFree(pLocalInfo);
		}  while (dwResumeHandle != 0);

	m_lbAvailableGroups.SetCurSel(0);

// set caption text
	CString csTemp;
	csTemp.LoadString(IDS_GROUP_CAPTION);

	CString csTemp2;
	csTemp2.Format(csTemp, pApp->m_csUserName);
	m_csCaption = csTemp2;
	UpdateData(FALSE);
	
}

void CGroupInfo::OnDblclkGroupAvailableList() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbAvailableGroups.GetCurSel();
	CString csSel;
	m_lbAvailableGroups.GetText(usSel, csSel);
	USHORT usBmp = m_lbAvailableGroups.GetBitmapID(usSel);
	m_lbSelectedGroups.AddString(csSel, usBmp);
	m_lbAvailableGroups.DeleteString(usSel);

// anybody left?
	if (m_lbAvailableGroups.GetCount() != 0)
		m_lbAvailableGroups.SetCurSel(0);

	else
		{
		m_lbSelectedGroups.SetCurSel(0);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
		m_lbAvailableGroups.SetHorizontalExtent(0);
		}
	
}

void CGroupInfo::OnDblclkGroupMemberList() 
{
	UpdateData(TRUE);
	USHORT usSel = m_lbSelectedGroups.GetCurSel();
	CString csSel;
	m_lbSelectedGroups.GetText(usSel, csSel);

	USHORT usBmp = m_lbSelectedGroups.GetBitmapID(usSel);
	m_lbAvailableGroups.AddString(csSel, usBmp);
	m_lbSelectedGroups.DeleteString(usSel);

// anybody left?
	if (m_lbSelectedGroups.GetCount() != 0)
		m_lbSelectedGroups.SetCurSel(0);

	else
		{
		m_lbAvailableGroups.SetCurSel(0);
		GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
		m_lbSelectedGroups.SetHorizontalExtent(0);
		}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\fpnwcomm.h ===
/*++

Copyright (c) 1993-1995 Microsoft Corporation

Module Name:

    nw\inc\ncmcomm.h

Abstract:

    This module contains common constants and types for the NCP server.

Author:

    Shawn Walker (vswalk) 06-17-1993
    Andy Herron  (andyhe)

Revision History:

--*/

#ifndef _NCPCOMM_
#define _NCPCOMM_

//
// signature for pserver
//
#define NCP_PSERVER_SIGNATURE   L"PS_"

//
// well known object IDs
//
#define NCP_WELL_KNOWN_SUPERVISOR_ID            (ULONG) 0x00000001
#define NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED    (ULONG) 0x01000000
#define NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO    (ULONG) 0x00010000
#define NCP_WELL_KNOWN_PSERVER_ID               (ULONG) 0x00000002

//
// misc macros that are useful
//
#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))

#define SWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID) ?           \
				NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED :      \
				MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))

#define UNSWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED || id == NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO) ?\
				NCP_WELL_KNOWN_SUPERVISOR_ID :              \
				MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))


//
// misc masks/bits for Object ID munging
//

#define BINDLIB_ID_MASK                         0xF0000000

#define BINDLIB_NCP_SAM                         0x00000000

//
//  This bit is set when the server is running on a NTAS machine or
//  the object is from a trusted domain.
//
//  !! Note that there are places where we check this bit to see if either
//  !! BINDLIB_REMOTE_DOMAIN_BIAS or BINDLIB_LOCAL_USER_BIAS is set.
//

#define BINDLIB_REMOTE_DOMAIN_BIAS              0x10000000

//
//  If the client is from the builtin domain, this bit will be set.  This
//  is opposed to the local domain, which is different.
//

#define BINDLIB_BUILTIN_BIAS                    0x20000000

//
//  If the client is from a trusted domain and the rid is from the
//  local domain and the client's rid is the same as the rid from the
//  sid, we will mark that the rid is the same as the local user's sid.
//
//  !! Note... this is a value, not a flag.  This will require special casing
//  !! everywhere but we can't spare any more bits.
//

#define BINDLIB_LOCAL_USER_BIAS                 0x70000000

//
//  User defined objects that is stored in the registry.
//

#define BINDLIB_NCP_USER_DEFINED                0x40000000

//
//  Print Queues and Print Servers that is stored in the registry.
//  The bindery keeps a list of print queues in a link list so that
//  the bindery does not have to go look in the registry all the time.
//

#define BINDLIB_NCP_REGISTRY                    0x80000000

//
//  The SAP Agent uses these bits.  The SAP Agent cannot go any higher
//  than the value below.
//

#define BINDLIB_NCP_SAP                         0xC0000000
#define BINDLIB_NCP_MAX_SAP                     0xCFFFFFFF

//
//  We have some reserved fields for unknown users that will go into the
//  following range....
//

#define NCP_UNKNOWN_USER                            0xD0000000
#define NCP_SAME_RID_AS_CLIENT_BUT_LOCAL            0xDFFFFFFF
#define NCP_USER_IS_CONNECTED_BUT_REMOTE(connid)    (0xD0000000 | (connid))
#define NCP_WELL_KNOWN_RID(rid)                     (0xD1000000 | (rid))

//
//  Chicago will use a range of object ids that start at the below value
//  and go to 0xFFFFFFFF.  We should never see these on our server when
//  a chicago server is passing through to us.
//

#define BINDLIB_CHICAGO                         0xE0000000

//
//  This is used to remove the domain bias from a object id.
//

#define BINDLIB_MASK_OUT_DOMAIN_BIAS            0x70000000


#define NCP_INITIAL_SEARCH                      (ULONG) 0xFFFFFFFF
#define NCP_ANY_TARGET_SERVER                   (ULONG) 0xFFFFFFFF

#define NCP_OBJECT_HAS_PROPERTIES               (UCHAR) 0xFF
#define NCP_OBJECT_HAS_NO_PROPERTIES            (UCHAR) 0

#define NCP_PROPERTY_HAS_VALUE                  (UCHAR) 0xFF
#define NCP_PROPERTY_HAS_NO_VALUE               (UCHAR) 0

#define NCP_MORE_PROPERTY                       (UCHAR) 0xFF
#define NCP_NO_MORE_PROPERTY                    (UCHAR) 0

#define NCP_MORE_SEGMENTS                       (UCHAR) 0xFF
#define NCP_NO_MORE_SEGMENTS                    (UCHAR) 0

#define NCP_DO_REMOVE_REMAINING_SEGMENTS        (UCHAR) 0
#define NCP_DO_NOT_REMOVE_REMAINING_SEGMENTS    (UCHAR) 0xFF


/*++
*******************************************************************
	Maximum length for the Bindery
*******************************************************************
--*/

#define NETWARE_OBJECTNAMELENGTH                47
#define NETWARE_PROPERTYNAMELENGTH              16
#define NETWARE_PROPERTYVALUELENGTH             128
#define NETWARE_TIME_RESTRICTION_LENGTH         42

#define NETWARE_PASSWORDLENGTH                  128
#define NCP_MAX_ENCRYPTED_PASSWORD_LENGTH       16

#define NETWARE_MAX_OBJECT_IDS_IN_SET           32

#define NETWARE_SERVERNAMELENGTH                48
#define NETWARE_VOLUMENAMELENGTH                16
#define NETWARE_MAX_PATH_LENGTH                 255


/*++
*******************************************************************
	Well known NetWare object types
*******************************************************************
--*/

#define NCP_OT_WILD                       0xFFFF
#define NCP_OT_UNKNOWN                    0x0000
#define NCP_OT_USER                       0x0001
#define NCP_OT_USER_GROUP                 0x0002
#define NCP_OT_PRINT_QUEUE                0x0003
#define NCP_OT_FILE_SERVER                0x0004
#define NCP_OT_JOB_SERVER                 0x0005
#define NCP_OT_GATEWAY                    0x0006
#define NCP_OT_PRINT_SERVER               0x0007
#define NCP_OT_ARCHIVE_QUEUE              0x0008
#define NCP_OT_ARCHIVE_SEVER              0x0009
#define NCP_OT_JOB_QUEUE                  0x000A
#define NCP_OT_ADMINISTRATION             0x000B
#define NCP_OT_SNA_GATEWAY                0x0021
#define NCP_OT_REMOTE_BRIDGE              0x0024
#define NCP_OT_REMOTE_BRIDGE_SERVER       0x0026
#define NCP_OT_ADVERTISING_PRINT_SERVER   0x0047


/*++
*******************************************************************
	Bindery flags
*******************************************************************
--*/

/** NetWare Bindery Flags **/

#define NCP_STATIC          0x00    /* Property or Object exists until it
				       is deleted with Delete Property or
				       Object */
#define NCP_DYNAMIC         0x01    /* Property or Object is deleted from
				       bindery when file server is started */
#define NCP_ITEM            0x00    /* Values are defined and interpreted by
				       applications or by APIs */
#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
				       bytes long */

/** NetWare Bindery Security Flags **/

#define NCP_ANY_READ        0x00    /* Readable by anyone */
#define NCP_LOGGED_READ     0x01    /* Must be logged in to read */
#define NCP_OBJECT_READ     0x02    /* Readable by same object or super */
#define NCP_BINDERY_READ    0x04    /* Readable only by the bindery */

#define NCP_SUPER_READ      NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ALL_READ        NCP_ANY_READ | NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ANY_WRITE       0x00    /* Writeable by anyone */
#define NCP_LOGGED_WRITE    0x10    /* Must be logged in to write */
#define NCP_OBJECT_WRITE    0x20    /* Writeable by same object or super */
#define NCP_BINDERY_WRITE   0x40    /* Writeable only by the bindery */

#define NCP_SUPER_WRITE     NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

#define NCP_ALL_WRITE       NCP_ANY_WRITE | NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

//  File Attributes

#define NW_ATTRIBUTE_SHARABLE       0x80
#define NW_ATTRIBUTE_ARCHIVE        0x20
#define NW_ATTRIBUTE_DIRECTORY      0x10
#define NW_ATTRIBUTE_EXECUTE_ONLY   0x08
#define NW_ATTRIBUTE_SYSTEM         0x04
#define NW_ATTRIBUTE_HIDDEN         0x02
#define NW_ATTRIBUTE_READ_ONLY      0x01

//  Open Flags

#define NW_OPEN_EXCLUSIVE           0x10
#define NW_DENY_WRITE               0x08
#define NW_DENY_READ                0x04
#define NW_OPEN_FOR_WRITE           0x02
#define NW_OPEN_FOR_READ            0x01

//
//  Connection status flags
//

#define NCP_STATUS_BAD_CONNECTION   0x01
#define NCP_STATUS_NO_CONNECTIONS   0x02
#define NCP_STATUS_SERVER_DOWN      0x04
#define NCP_STATUS_MSG_PENDING      0x08

//
//  Special values for SmallWorld PDC object and property name
//

#define MS_WINNT_NAME      "MS_WINNT"
#define MS_SYNC_PDC_NAME   "SYNCPDC"
#define MS_WINNT_OBJ_TYPE  0x06BB

//
//  User Property values (ie. User Parms stuff)
//

#define USER_PROPERTY_SIGNATURE     L'P'

#define NWPASSWORD                  L"NWPassword"
#define OLDNWPASSWORD               L"OldNWPassword"
#define MAXCONNECTIONS              L"MaxConnections"
#define NWTIMEPASSWORDSET           L"NWPasswordSet"
#define SZTRUE                      L"TRUE"
#define GRACELOGINALLOWED           L"GraceLoginAllowed"
#define GRACELOGINREMAINING         L"GraceLoginRemaining"
#define NWLOGONFROM                 L"NWLogonFrom"
#define NWHOMEDIR                   L"NWHomeDir"
#define NW_PRINT_SERVER_REF_COUNT   L"PSRefCount"

#define SUPERVISOR_USERID               NCP_WELL_KNOWN_SUPERVISOR_ID
#define SUPERVISOR_NAME_STRING      L"Supervisor"
#define SYSVOL_NAME_STRING              L"SYS"
#define NWENCRYPTEDPASSWORDLENGTH   8
#define NO_LIMIT                    0xffff

#define DEFAULT_MAXCONNECTIONS      NO_LIMIT
#define DEFAULT_NWPASSWORDEXPIRED   FALSE
#define DEFAULT_GRACELOGINALLOWED   6
#define DEFAULT_GRACELOGINREMAINING 6
#define DEFAULT_NWLOGONFROM         NULL
#define DEFAULT_NWHOMEDIR           NULL

#define USER_PROPERTY_TYPE_ITEM     1
#define USER_PROPERTY_TYPE_SET      2

#endif /* _NCPCOMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\homedir.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    HomeDir.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "HomeDir.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHomeDir property page

IMPLEMENT_DYNCREATE(CHomeDir, CWizBaseDlg)

CHomeDir::CHomeDir() : CWizBaseDlg(CHomeDir::IDD)
{
	//{{AFX_DATA_INIT(CHomeDir)
	m_csHome_dir_drive = _T("");
	m_csRemotePath = _T("");
	m_rbPathLocale = 0;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

CHomeDir::~CHomeDir()
{
}

void CHomeDir::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHomeDir)
	DDX_Control(pDX, IDC_DRIVE_LETTER, m_cbDriveLetter);
	DDX_CBString(pDX, IDC_DRIVE_LETTER, m_csHome_dir_drive);
	DDX_Text(pDX, IDC_REMOTE_PATH, m_csRemotePath);
	DDX_Radio(pDX, IDC_LOCAL_PATH_BUTTON, m_rbPathLocale);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHomeDir, CWizBaseDlg)
	//{{AFX_MSG_MAP(CHomeDir)
	ON_WM_SHOWWINDOW()
	ON_BN_CLICKED(IDC_LOCAL_PATH_BUTTON, OnLocalPathButton)
	ON_BN_CLICKED(IDC_REMOTE_PATH_BUTTON, OnRemotePathButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHomeDir message handlers
LRESULT CHomeDir::OnWizardNext()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	UpdateData(TRUE);
	if (m_rbPathLocale == 0) // local
		{
		pApp->m_csHomeDir = L""; // leave this empty per JonN and spec
		pApp->m_csHome_dir_drive = "";
		}
	else					// remote
		{
		if (m_csRemotePath.Left(2) != L"\\\\")
			{
			AfxMessageBox(IDS_INVALID_PATH);
			GetDlgItem(IDC_REMOTE_PATH)->SetFocus();
			return -1;
			}

		if (m_csHome_dir_drive == L"")
			{
			AfxMessageBox(IDS_NO_HOMEDIR_DRIVE_LETTER);		  
			GetDlgItem(IDC_DRIVE_LETTER)->SetFocus();
			return -1;
			}

		CWaitCursor wait;
// make sure directory exists
		if (CreateFile((const TCHAR*)m_csRemotePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL) == INVALID_HANDLE_VALUE)
			{
			DWORD dwErr = GetLastError();
			if (dwErr == 5) // access denied
				{
				AfxMessageBox(IDS_NO_DIR_PERMISSION, MB_ICONSTOP);
				return -1;
				}
				   
// store the current dir so it can be restored
			CString csCurDir;
			GetCurrentDirectory(256, csCurDir.GetBufferSetLength(256));
			csCurDir.ReleaseBuffer();

			CString csMessage;
			AfxFormatString1(csMessage, IDS_INVALID_DIRECTORY_NAME, m_csRemotePath);
			if (AfxMessageBox(csMessage, MB_YESNO) != IDYES) return -1;
			if (!CreateNewDirectory((const TCHAR*)m_csRemotePath))
				{
				if (AfxMessageBox(IDS_CANT_CREATE_DIRECTORY, MB_YESNO) != IDYES) return -1;
				}
			SetCurrentDirectory((LPCTSTR)csCurDir);
			}			  

		pApp->m_csHomeDir = m_csRemotePath;
		GetDlgItem(IDC_DRIVE_LETTER)->GetWindowText(pApp->m_csHome_dir_drive);
		pApp->m_csHome_dir_drive = pApp->m_csHome_dir_drive.Left(2); // trim off trailing blank
		pApp->m_csHome_dir_drive.MakeUpper();
		}		  

	if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;

}

BOOL CHomeDir::CreateNewDirectory(const TCHAR* m_csDirectoryName)
{
// first remove the \\server\share info and CD to it
	CString csDir = m_csDirectoryName;
	csDir = csDir.Right(csDir.GetLength() - 2);
	CString csServer = csDir.Left(csDir.Find(L"\\"));
	csDir = csDir.Right((csDir.GetLength() - csServer.GetLength()) - 1);
	CString csShare = csDir.Left(csDir.Find(L"\\"));
	csDir = csDir.Right((csDir.GetLength() - csShare.GetLength()) - 1);

	CString csPath;
	csPath.Format(L"\\\\%s\\%s", csServer, csShare); 
	if (!SetCurrentDirectory(csPath)) return FALSE;

// parse out the individual path names and cd / md them
	TCHAR* pDirectory = new TCHAR[_tcslen(csDir) * sizeof(TCHAR)];
	_tcscpy(pDirectory, csDir);
	TCHAR* ppDir = pDirectory;

	TCHAR* pDir;
	pDir = _tcstok(pDirectory, L"\\");

	while (pDir != NULL)
		{
		if (!SetCurrentDirectory(pDir))
			{
			CreateDirectory(pDir, NULL);
			if (!SetCurrentDirectory(pDir)) 
				{
				delete ppDir;
				return FALSE;
				}
			}
		pDir = _tcstok(NULL, L"\\");
		}
			
	delete ppDir;

	TCHAR pCurDir[256];
	GetCurrentDirectory(256, pCurDir);
	CString csNewDir, csTemp;
	csTemp.LoadString(IDS_NEW_DIR_CREATED);
	csNewDir.Format(csTemp, pCurDir);
	AfxMessageBox(csNewDir);
	return TRUE;
}


LRESULT CHomeDir::OnWizardBack()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;

}

BOOL CHomeDir::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();
	
//	m_csLocalPath = "c:\\users\\default";

// create list of available drives
	int drive;
	TCHAR tDrive[3];

	for( drive = 3; drive <= 26; drive++ )
	   {
	   swprintf(tDrive, L"%c: ", drive + 'A' - 1 );
	   m_cbDriveLetter.AddString(tDrive);
	   }
			
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CHomeDir::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_HOMEDIR_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}

	
}

void CHomeDir::OnLocalPathButton() 
{
	GetDlgItem(IDC_DRIVE_LETTER)->EnableWindow(FALSE);
	GetDlgItem(IDC_REMOTE_PATH)->EnableWindow(FALSE);
	
}

void CHomeDir::OnRemotePathButton() 
{
	GetDlgItem(IDC_DRIVE_LETTER)->EnableWindow(TRUE);
	GetDlgItem(IDC_REMOTE_PATH)->EnableWindow(TRUE);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\hours.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Hours.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Timelist.h"
#include "Hours.h"
#include "hours1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHoursDlg property page

IMPLEMENT_DYNCREATE(CHoursDlg, CWizBaseDlg)

CHoursDlg::CHoursDlg() : CWizBaseDlg(CHoursDlg::IDD)
{
	//{{AFX_DATA_INIT(CHoursDlg)
	//}}AFX_DATA_INIT
	
	m_swDisAllowed.bWhich = FALSE;
	m_swAllowed.bWhich = TRUE;

}

CHoursDlg::~CHoursDlg()
{
}

void CHoursDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHoursDlg)
	DDX_Control(pDX, IDC_STATIC_DISALLOWEDTIMES, m_swDisAllowed);
	DDX_Control(pDX, IDC_STATIC_ALLOWEDTIMES, m_swAllowed);
	DDX_Control(pDX, IDC_HOURSCTRL1, m_ccHours);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHoursDlg, CWizBaseDlg)
	//{{AFX_MSG_MAP(CHoursDlg)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHoursDlg message handlers

BOOL CHoursDlg::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CHoursDlg::OnWizardNext()
{
	UpdateData(TRUE);
 
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

// build a SAFEARRAY to receive data from the control
	VARIANT vaResult;
	VariantInit(&vaResult);

	vaResult.vt = VT_ARRAY | VT_UI1;

	SAFEARRAYBOUND sab[1];
	sab[0].cElements = 21;
	sab[0].lLbound = 0;

	vaResult.parray = SafeArrayCreate(VT_UI1, 1, sab);

	void* vRet;
	BYTE* bRet;

// get the data from the control
	vaResult = m_ccHours.GetDateData();

	SafeArrayAccessData(vaResult.parray, &vRet);

	USHORT sCount = 0;
	bRet = (BYTE*)vRet;
	while (sCount < 21)
		{
		memcpy(&pApp->m_pHours[sCount], bRet + (sCount * sizeof(BYTE)), sizeof(BYTE));
		sCount++;
		}

	if (pApp->m_bWorkstation) return IDD_LOGONTO_DLG;
	else if (pApp->m_bNW) return IDD_NWLOGON_DIALOG;
	else return IDD_FINISH;

}

LRESULT CHoursDlg::OnWizardBack() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bExpiration) return IDD_ACCOUNT_EXP_DIALOG;
	return IDD_RESTRICTIONS_DIALOG;

}

void CHoursDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	if (bShow)
		{
		m_ccHours.SetCrPermitColor(GetSysColor(COLOR_ACTIVECAPTION));
		m_ccHours.SetCrDenyColor(GetSysColor(COLOR_CAPTIONTEXT));
		}
	
}

/////////////////////////////////////////////////////////////////////////////
// CSWnd

CSWnd::CSWnd()
{
}

CSWnd::~CSWnd()
{
}


BEGIN_MESSAGE_MAP(CSWnd, CStatic)
	//{{AFX_MSG_MAP(CSWnd)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSWnd message handlers

void CSWnd::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	if (bWhich) dc.FillRect(&dc.m_ps.rcPaint, CBrush::FromHandle(CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION)))); 
	else dc.FillRect(&dc.m_ps.rcPaint, CBrush::FromHandle(CreateSolidBrush(GetSysColor(COLOR_CAPTIONTEXT)))); 
	
	// Do not call CStatic::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\homedir.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    HomeDir.h : header file

File History:

	JonY	Apr-96	created

--*/



/////////////////////////////////////////////////////////////////////////////
// CHomeDir dialog

class CHomeDir : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CHomeDir)

// Construction
public:
	CHomeDir();
	~CHomeDir();

// Dialog Data
	//{{AFX_DATA(CHomeDir)
	enum { IDD = IDD_HOMEDIR_DIALOG };
	CComboBox	m_cbDriveLetter;
	CString	m_csHome_dir_drive;
	CString	m_csRemotePath;
	int		m_rbPathLocale;
	CString	m_csCaption;
	//}}AFX_DATA

	BOOL CreateNewDirectory(const TCHAR* m_csDirectoryName);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHomeDir)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	LRESULT OnWizardBack();
	LRESULT OnWizardNext();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHomeDir)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnLocalPathButton();
	afx_msg void OnRemotePathButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\hours1.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "hours1.h"

/////////////////////////////////////////////////////////////////////////////
// CHours

IMPLEMENT_DYNCREATE(CHours, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CHours properties

unsigned long CHours::GetCrPermitColor()
{
	unsigned long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CHours::SetCrPermitColor(unsigned long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

unsigned long CHours::GetCrDenyColor()
{
	unsigned long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CHours::SetCrDenyColor(unsigned long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

VARIANT CHours::GetDateData()
{
	VARIANT result;
	GetProperty(0x3, VT_VARIANT, (void*)&result);
	return result;
}

void CHours::SetDateData(const VARIANT& propVal)
{
	SetProperty(0x3, VT_VARIANT, &propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CHours operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\ginfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    GInfo.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CGroupInfo dialog

class CGroupInfo : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CGroupInfo)

// Construction
public:
	CGroupInfo();
	~CGroupInfo();

// Dialog Data
	//{{AFX_DATA(CGroupInfo)
	enum { IDD = IDD_GROUP_INFO };
	CUserList	m_lbSelectedGroups;
	CUserList	m_lbAvailableGroups;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupInfo)
	virtual BOOL OnInitDialog();
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnSetfocusGroupAvailableList();
	afx_msg void OnSetfocusGroupMemberList();
	afx_msg void OnSelchangeGroupMemberList();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnDblclkGroupAvailableList();
	afx_msg void OnDblclkGroupMemberList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\hours1.h ===
#ifndef __HOURS1_H__
#define __HOURS1_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CHours wrapper class

class CHours : public CWnd
{
protected:
	DECLARE_DYNCREATE(CHours)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xa44ea7ad, 0x9d58, 0x11cf, { 0xa3, 0x5f, 0x0, 0xaa, 0x0, 0xb6, 0x74, 0x3b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	unsigned long GetCrPermitColor();
	void SetCrPermitColor(unsigned long);
	unsigned long GetCrDenyColor();
	void SetCrDenyColor(unsigned long);
	VARIANT GetDateData();
	void SetDateData(const VARIANT&);

// Operations
public:
};

#endif // __HOURS1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\hours.h ===
//{{AFX_INCLUDES()
#include "hours1.h"
//}}AFX_INCLUDES
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Hours.h : header file

File History:

	JonY	Apr-96	created

--*/
//
/////////////////////////////////////////////////////////////////////////////
// CSWnd window

class CSWnd : public CStatic
{
// Construction
public:
	CSWnd();
	BOOL bWhich;
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CSWnd)
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CHoursDlg dialog

class CHoursDlg : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CHoursDlg)

// Construction
public:
	CHoursDlg();
	~CHoursDlg();

// Dialog Data
	//{{AFX_DATA(CHoursDlg)
	enum { IDD = IDD_HOURS_DLG };
	CSWnd	m_swDisAllowed;
	CSWnd	m_swAllowed;
	CHours	m_ccHours;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHoursDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHoursDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	LRESULT OnWizardNext();
	LRESULT OnWizardBack();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\limit.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Limit.h : header file

File History:

	JonY	Apr-96	created

--*/
/////////////////////////////////////////////////////////////////////////////
// CAddWorkstation dialog

class CAddWorkstation : public CDialog
{
// Construction
public:
	CAddWorkstation(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddWorkstation)
	enum { IDD = IDD_ADD_WKS_DIALOG };
	CString	m_csWorkstation;
	//}}AFX_DATA

	CListBox* pListBox;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddWorkstation)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddWorkstation)
	afx_msg void OnAdd();
	afx_msg void OnClose();
	afx_msg void OnChangeWorkstationEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CLimitLogon dialog

class CLimitLogon : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CLimitLogon)

// Construction
public:
	CLimitLogon();
	~CLimitLogon();

// Dialog Data
	//{{AFX_DATA(CLimitLogon)
	enum { IDD = IDD_LOGONTO_DLG };
	CListBox	m_lbWksList;
	int		m_nWorkstationRadio;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLimitLogon)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	LRESULT OnWizardNext();
	LRESULT OnWizardBack();
// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLimitLogon)
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnWorkstationRadio();
	afx_msg void OnWorkstationRadio2();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSetfocusList1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void Toggle(BOOL bParam);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\lscript.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    LScript.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "LScript.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLoginScript property page

IMPLEMENT_DYNCREATE(CLoginScript, CWizBaseDlg)

CLoginScript::CLoginScript() : CWizBaseDlg(CLoginScript::IDD)
{
	//{{AFX_DATA_INIT(CLoginScript)
	m_csLogonScript = _T("");
	//}}AFX_DATA_INIT
}

CLoginScript::~CLoginScript()
{
}

void CLoginScript::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLoginScript)
	DDX_Text(pDX, IDC_LOGON_SCRIPT, m_csLogonScript);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLoginScript, CWizBaseDlg)
	//{{AFX_MSG_MAP(CLoginScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLoginScript message handlers

LRESULT CLoginScript::OnWizardNext()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	UpdateData(TRUE);
	pApp->m_csLogonScript = m_csLogonScript;

	if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;

}

LRESULT CLoginScript::OnWizardBack()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\nwlim.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NWLim.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "speckle.h"
#include "NWLim.h"
#include "NWWKS.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class WKSMember
	{
	public:
	CString csWKSAddress;
	CString csWKSNode;
	};

/////////////////////////////////////////////////////////////////////////////
// CNWLimitLogon dialog
IMPLEMENT_DYNCREATE(CNWLimitLogon, CPropertyPage)
CNWLimitLogon::CNWLimitLogon() : CPropertyPage(CNWLimitLogon::IDD)
{
	//{{AFX_DATA_INIT(CNWLimitLogon)
	m_nWorkstationRadio = 0;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}


void CNWLimitLogon::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNWLimitLogon)
	DDX_Control(pDX, IDC_NWLOGON_LIST, m_lbWksList);
	DDX_Radio(pDX, IDC_WORKSTATION_RADIO, m_nWorkstationRadio);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNWLimitLogon, CPropertyPage)
	//{{AFX_MSG_MAP(CNWLimitLogon)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_BN_CLICKED(IDC_WORKSTATION_RADIO, OnWorkstationRadio)
	ON_BN_CLICKED(IDC_WORKSTATION_RADIO2, OnWorkstationRadio2)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNWLimitLogon message handlers
LRESULT CNWLimitLogon::OnWizardNext()
{
	UpdateData(TRUE);
	if ((m_nWorkstationRadio == 1) && (m_lbWksList.GetCount() == 0))
		{
		AfxMessageBox(IDS_NEEDA_WORKSTATION);
		return -1;
		}

	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	USHORT sCount = 0;
	BOOL bMatch = FALSE;
	pApp->m_csAllowedLoginFrom = L"";
	while (sCount < m_lbWksList.GetCount())
		{
		WKSMember* pMem = (WKSMember*)m_lbWksList.GetItemData(sCount);
		CString csTemp;
		if (pMem->csWKSNode == L"0000000000-1") csTemp.Format(L"%s%s", pMem->csWKSAddress, L"ffffffffffff");
		else csTemp.Format(L"%s%s", pMem->csWKSAddress, pMem->csWKSNode);
		
		pApp->m_csAllowedLoginFrom += csTemp;
		sCount++;
		}
	
	if (m_lbWksList.GetCount() > 0) pApp->m_csAllowedLoginFrom += L"00";

	return IDD_FINISH;

}

LRESULT CNWLimitLogon::OnWizardBack()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (pApp->m_bWorkstation) return IDD_LOGONTO_DLG;
	else if (pApp->m_bHours) return IDD_HOURS_DLG;
	else if (pApp->m_bExpiration) return IDD_ACCOUNT_EXP_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;

}


void CNWLimitLogon::OnAddButton() 
{
	CAddNWWKS add;
	if (add.DoModal() == 1)
		{
	// check for uniqueness
		USHORT sCount = 0;
		BOOL bMatch = FALSE;
		while (sCount < m_lbWksList.GetCount())
			{
			WKSMember* pMem = (WKSMember*)m_lbWksList.GetItemData(sCount);
			if ((pMem->csWKSAddress == add.m_csNetworkAddress) &&
				(pMem->csWKSNode == add.m_csNodeAddress)) 
				{
				bMatch = TRUE;
				break;
				}

			sCount++;
			}

		if (bMatch) return;

		WKSMember* member = new WKSMember;
		member->csWKSAddress = add.m_csNetworkAddress;
		member->csWKSNode = add.m_csNodeAddress;

		int nEntry = m_lbWksList.AddString(L" ");
		m_lbWksList.SetItemData(nEntry, (DWORD)member);

	// enable the remove button since there is something to remove
		GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
		GetDlgItem(IDC_NWLOGON_LIST)->SetFocus();
		m_lbWksList.SetCurSel(0);
		}	
	
}

void CNWLimitLogon::OnRemoveButton() 
{
	USHORT sSel = m_lbWksList.GetCurSel();

	WKSMember* member = (WKSMember*)m_lbWksList.GetItemData(sSel);
	free(member);
	m_lbWksList.DeleteString(sSel);

	if (m_lbWksList.GetCount() == 0) GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	else if (sSel > 0) m_lbWksList.SetCurSel(sSel - 1);
	else m_lbWksList.SetCurSel(0);
			   
}

void CNWLimitLogon::OnWorkstationRadio() 
{
	GetDlgItem(IDC_NWSTATIC1)->EnableWindow(FALSE);
	GetDlgItem(IDC_NWSTATIC2)->EnableWindow(FALSE);
	GetDlgItem(IDC_NWLOGON_LIST)->EnableWindow(FALSE);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	
}

void CNWLimitLogon::OnWorkstationRadio2() 
{
	GetDlgItem(IDC_NWSTATIC1)->EnableWindow(TRUE);
	GetDlgItem(IDC_NWSTATIC2)->EnableWindow(TRUE);
	GetDlgItem(IDC_NWLOGON_LIST)->EnableWindow(TRUE);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
	
}


/////////////////////////////////////////////////////////////////////////////
// CWorkstationList

CWorkstationList::CWorkstationList()
{
}

CWorkstationList::~CWorkstationList()
{
}


BEGIN_MESSAGE_MAP(CWorkstationList, CListBox)
	//{{AFX_MSG_MAP(CWorkstationList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWorkstationList message handlers

void CWorkstationList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	COLORREF crefOldText;
	COLORREF crefOldBk;
	HBRUSH hBrush;

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	switch (lpDrawItemStruct->itemAction)
		{
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
// Is the item selected?
            if (lpDrawItemStruct->itemState & ODS_SELECTED)
				{
				hBrush = CreateSolidBrush( GetSysColor(COLOR_HIGHLIGHT));
                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT) );
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT) );
				}
            else
				{
				hBrush = (HBRUSH)GetStockObject( GetSysColor(COLOR_WINDOW));
                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
				}

// fill in the background
		pDC->FillRect(&(lpDrawItemStruct->rcItem), CBrush::FromHandle(hBrush));

// display text
		TCHAR* pName = (TCHAR*)malloc(255 * sizeof(TCHAR));
		if (pName == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			exit(1);
			}

		DWORD dwAddr = GetItemData(lpDrawItemStruct->itemID);

		WKSMember* member = (WKSMember*)dwAddr;

// format the name + comment
        int nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top) / 2;
        pDC->TextOut(0,
            (nTop - 8),
            member->csWKSAddress);

		if (member->csWKSNode == L"0000000000-1") 		
			pDC->TextOut(130,
				(nTop - 8),
				L"All Nodes");

		else 		
			pDC->TextOut(130,
				(nTop - 8),
				member->csWKSNode);

		free(pName);
        break;
		}

	pDC->SetBkColor(crefOldBk );
    pDC->SetTextColor(crefOldText );
}

int CWorkstationList::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{
	// TODO: Add your code to determine the sorting order of the specified items
	// return -1 = item 1 sorts before item 2
	// return 0 = item 1 and item 2 sort the same
	// return 1 = item 1 sorts after item 2
	
	return 0;
}

void CWorkstationList::OnDestroy() 
{
	while(GetCount() > 0)
		{
		WKSMember* member = (WKSMember*)GetItemData(0);
		delete member;
		DeleteString(0);
		}
	CListBox::OnDestroy();
	
	
}


void CNWLimitLogon::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_NWLOGON_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\limit.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Limit.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/
#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Limit.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLimitLogon property page

IMPLEMENT_DYNCREATE(CLimitLogon, CWizBaseDlg)

CLimitLogon::CLimitLogon() : CWizBaseDlg(CLimitLogon::IDD)
{
	//{{AFX_DATA_INIT(CLimitLogon)
	m_nWorkstationRadio = 0;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

CLimitLogon::~CLimitLogon()
{
}

void CLimitLogon::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLimitLogon)
	DDX_Control(pDX, IDC_LIST1, m_lbWksList);
	DDX_Radio(pDX, IDC_WORKSTATION_RADIO, m_nWorkstationRadio);
	DDX_Text(pDX, IDC_STATIC2, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLimitLogon, CWizBaseDlg)
	//{{AFX_MSG_MAP(CLimitLogon)
	ON_BN_CLICKED(IDC_ADD_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_BUTTON, OnRemoveButton)
	ON_BN_CLICKED(IDC_WORKSTATION_RADIO, OnWorkstationRadio)
	ON_BN_CLICKED(IDC_WORKSTATION_RADIO2, OnWorkstationRadio2)
	ON_WM_SHOWWINDOW()
	ON_LBN_SETFOCUS(IDC_LIST1, OnSetfocusList1)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLimitLogon message handlers
LRESULT CLimitLogon::OnWizardNext()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	UpdateData(TRUE);

	if ((m_nWorkstationRadio == 1) && (m_lbWksList.GetCount() == 0))
		{
		AfxMessageBox(IDS_NEEDA_WORKSTATION);
		return -1;
		}

	if (m_nWorkstationRadio == 0) pApp->m_csAllowedMachines = L"";
	else
		{
// make workstation list and store it
		USHORT sCount;
		CString csWksList;
		for (sCount = 0; sCount < m_lbWksList.GetCount(); sCount++)
			{
			CString csWks;
			m_lbWksList.GetText(sCount, csWks);
			csWksList += csWks;
			csWksList += L",";
			}
	
// remove trailing ','
		csWksList = csWksList.Left(csWksList.GetLength() - 1);
		pApp->m_csAllowedMachines = csWksList;
		}

	if (pApp->m_bNW) return IDD_NWLOGON_DIALOG;
	else return IDD_FINISH;

}

LRESULT CLimitLogon::OnWizardBack()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bHours) return IDD_HOURS_DLG;
	else if (pApp->m_bExpiration) return IDD_ACCOUNT_EXP_DIALOG;
	return IDD_RESTRICTIONS_DIALOG;

}


void CLimitLogon::OnAddButton() 
{
	CAddWorkstation pWks;
	pWks.pListBox = &m_lbWksList;
	pWks.DoModal();

	if (m_lbWksList.GetCount() > 0) GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
	else GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);

	GetDlgItem(IDC_LIST1)->SetFocus();
	m_lbWksList.SetCurSel(0);
	
}

void CLimitLogon::OnRemoveButton() 
{
	int ui = m_lbWksList.GetCurSel();
	if (ui == LB_ERR) return;

	m_lbWksList.DeleteString(ui);
	if (ui > 0) m_lbWksList.SetCurSel(ui - 1);
	else if (m_lbWksList.GetCount() > 0) m_lbWksList.SetCurSel(0);
	else GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);

}

/////////////////////////////////////////////////////////////////////////////
// CAddWorkstation dialog


CAddWorkstation::CAddWorkstation(CWnd* pParent /*=NULL*/)
	: CDialog(CAddWorkstation::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddWorkstation)
	m_csWorkstation = _T("");
	//}}AFX_DATA_INIT
}


void CAddWorkstation::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddWorkstation)
	DDX_Text(pDX, IDC_WORKSTATION_EDIT, m_csWorkstation);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddWorkstation, CDialog)
	//{{AFX_MSG_MAP(CAddWorkstation)
	ON_BN_CLICKED(IDOK, OnAdd)
	ON_BN_CLICKED(IDCANCEL, OnClose)
	ON_EN_CHANGE(IDC_WORKSTATION_EDIT, OnChangeWorkstationEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddWorkstation message handlers

void CAddWorkstation::OnAdd() 
{

	UpdateData(TRUE);
	if (m_csWorkstation == L"") 
		{
		GetDlgItem(IDC_WORKSTATION_EDIT)->SetFocus();
		return;
		}

// 	check for validity
	if (m_csWorkstation.FindOneOf(L"/.,<>;;'[{]}=+)(*&^%$#@!~`| ") != -1)
		{
		AfxMessageBox(IDS_BAD_WS_NAME);
		GetDlgItem(IDC_WORKSTATION_EDIT)->SetFocus();
		}

//#ifdef DBCS
// We need MuliByteString count
// Fix: #12335 ADMIN:Admin wizard should check the DBCS computername correctly
// V-HIDEKK 1996.09.27
        {
	DWORD cch;

        cch = WideCharToMultiByte( CP_ACP,
                             0, 
                             m_csWorkstation.GetBuffer(m_csWorkstation.GetLength()),
                             -1,
                             NULL,
                             NULL,
                             NULL,
                             NULL );
        if ( (cch-1) > 15 )
/*
#else
	if (m_csWorkstation.GetLength() > 15)
#endif
*/
		{
		AfxMessageBox(IDS_WSNAME_TOOLONG);
		GetDlgItem(IDC_WORKSTATION_EDIT)->SetFocus();
		return;
		}
//#ifdef DBCS
// V-HIDEKK 1996.09.27
        }
//#endif

	while (m_csWorkstation.Left(1) == L"\\")
		m_csWorkstation = m_csWorkstation.Right(m_csWorkstation.GetLength() - 1);

// make sure its unique
	if (pListBox->FindString(-1, m_csWorkstation) == LB_ERR) pListBox->AddString(m_csWorkstation);
	UpdateData(FALSE);
	EndDialog(1);
	
}

void CAddWorkstation::OnClose() 
{
	EndDialog(0);
	
}

void CLimitLogon::OnWorkstationRadio() 
{
	GetDlgItem(IDC_STATIC1)->EnableWindow(FALSE);
	GetDlgItem(IDC_LIST1)->EnableWindow(FALSE);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(FALSE);
	GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	
}

void CLimitLogon::OnWorkstationRadio2() 
{
	GetDlgItem(IDC_STATIC1)->EnableWindow(TRUE);
	GetDlgItem(IDC_LIST1)->EnableWindow(TRUE);
	GetDlgItem(IDC_ADD_BUTTON)->EnableWindow(TRUE);
	if (m_lbWksList.GetCount() > 0) GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
	else GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);
	
}

void CLimitLogon::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_WORKSTATION_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}
	
}

void CLimitLogon::OnSetfocusList1() 
{
	if (m_lbWksList.GetCount() > 0) GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(TRUE);
	else GetDlgItem(IDC_REMOVE_BUTTON)->EnableWindow(FALSE);

}

void CAddWorkstation::OnChangeWorkstationEdit() 
{
	UpdateData(TRUE);

// 	check for validity
	if (m_csWorkstation.FindOneOf(L"/.,<>;;'[{]}=+)(*&^%$#@!~`| ") != -1)
		{
		AfxMessageBox(IDS_BAD_WS_NAME);
		GetDlgItem(IDC_WORKSTATION_EDIT)->SetFocus();
		}

#ifndef DBCS
// If string input longer than 15 char by ime,
// MessageBox raise up too many time. 
// We don't need this check.
// Fix: #12348 ADMIN:AddUser Wizard has problem checking length computername of DBCS
// V-HIDEKK 1996.09.27

	if (m_csWorkstation.GetLength() > 15)
		{
		AfxMessageBox(IDS_WSNAME_TOOLONG);
		GetDlgItem(IDC_WORKSTATION_EDIT)->SetFocus();
		return;
		}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\nwlim.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NWLim.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CWorkstationList window

class CWorkstationList : public CListBox
{
// Construction
public:
	CWorkstationList();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWorkstationList)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWorkstationList();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWorkstationList)
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNWLimitLogon dialog

class CNWLimitLogon : public CPropertyPage
{
DECLARE_DYNCREATE(CNWLimitLogon)
// Construction
public:
	CNWLimitLogon();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNWLimitLogon)
	enum { IDD = IDD_NWLOGON_DIALOG };
	CWorkstationList	m_lbWksList;
	int		m_nWorkstationRadio;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNWLimitLogon)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	LRESULT OnWizardNext();
	LRESULT OnWizardBack();

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNWLimitLogon)
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnWorkstationRadio();
	afx_msg void OnWorkstationRadio2();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\nwwks.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NWWKS.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "speckle.h"
#include "NWWKS.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddNWWKS dialog


CAddNWWKS::CAddNWWKS(CWnd* pParent /*=NULL*/)
	: CDialog(CAddNWWKS::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddNWWKS)
	m_csNetworkAddress = _T("");
	m_csNodeAddress = _T("");
	//}}AFX_DATA_INIT
}


void CAddNWWKS::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddNWWKS)
	DDX_Text(pDX, IDC_NETWORK_ADDRESS_EDIT, m_csNetworkAddress);
	DDX_Text(pDX, IDC_NODE_ADDRESS_EDIT, m_csNodeAddress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddNWWKS, CDialog)
	//{{AFX_MSG_MAP(CAddNWWKS)
	ON_EN_CHANGE(IDC_NETWORK_ADDRESS_EDIT, OnChangeNetworkAddressEdit)
	ON_EN_CHANGE(IDC_NODE_ADDRESS_EDIT, OnChangeNodeAddressEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddNWWKS message handlers

void CAddNWWKS::OnOK() 
{
// 8 digit address
// 12 digit node
// network is req'd. Node is not.
	UpdateData(TRUE);

	if (m_csNetworkAddress == L"")
		{
		AfxMessageBox(IDS_NEED_ADDRESS);
		GetDlgItem(IDC_NETWORK_ADDRESS_EDIT)->SetFocus();
		return;
		}

	if (m_csNetworkAddress.FindOneOf(L"GgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz~`!@#$%^&*()-_+={[}}]|\\:;\"',<.>/?") != -1)
		{
		AfxMessageBox(IDS_BAD_NWADDRESS);
		GetDlgItem(IDC_NETWORK_ADDRESS_EDIT)->SetFocus();
		return;
		}

	if (m_csNetworkAddress.GetLength() > 8)
		{
		AfxMessageBox(IDS_TOOLONG_NWADDRESS);
		GetDlgItem(IDC_NETWORK_ADDRESS_EDIT)->SetFocus();
		return;
		}
	
	if (m_csNodeAddress.FindOneOf(L"GgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz~`!@#$%^&*()-_+={[}}]|\\:;\"',<.>/?") != -1)
		{
		AfxMessageBox(IDS_BAD_NWNODE);
		GetDlgItem(IDC_NODE_ADDRESS_EDIT)->SetFocus();
		return;
		}

	if (m_csNodeAddress.GetLength() > 12)
		{
		AfxMessageBox(IDS_TOOLONG_NWNODE);
		GetDlgItem(IDC_NODE_ADDRESS_EDIT)->SetFocus();
		return;
		}

	if (m_csNodeAddress == L"")
		{
		if (AfxMessageBox(IDS_ALL_NODES, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
			m_csNodeAddress = L"-1";

		else return;
		}

// pad out the numbers to the appropriate length
	while (m_csNodeAddress.GetLength() < 12) m_csNodeAddress = L"0" + m_csNodeAddress;
	while (m_csNetworkAddress.GetLength() < 8) m_csNetworkAddress = L"0" + m_csNetworkAddress;

	EndDialog(1);

}

void CAddNWWKS::OnCancel() 
{
	EndDialog(0);
}

BOOL CAddNWWKS::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	GetDlgItem(IDC_NETWORK_ADDRESS_EDIT)->SetFocus();
	
	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddNWWKS::OnChangeNetworkAddressEdit() 
{
	UpdateData(TRUE);
	if (m_csNetworkAddress.FindOneOf(L"GgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz~`!@#$%^&*()-_+={[}}]|\\:;\"',<.>/?") != -1)
		{
		AfxMessageBox(IDS_BAD_NWADDRESS);
		}

	if (m_csNetworkAddress.GetLength() > 8)
		{
		AfxMessageBox(IDS_TOOLONG_NWADDRESS);
		}
	
}

void CAddNWWKS::OnChangeNodeAddressEdit() 
{
	UpdateData(TRUE);
	if (m_csNodeAddress.FindOneOf(L"GgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz~`!@#$%^&*()-_+={[}}]|\\:;\"',<.>/?") != -1)
		AfxMessageBox(IDS_BAD_NWNODE);

	if (m_csNodeAddress.GetLength() > 12)
		AfxMessageBox(IDS_TOOLONG_NWNODE);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\lscript.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    LScript.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CLoginScript dialog

class CLoginScript : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CLoginScript)

// Construction
public:
	CLoginScript();
	~CLoginScript();

// Dialog Data
	//{{AFX_DATA(CLoginScript)
	enum { IDD = IDD_LOGON_SCRIPT_DIALOG };
	CString	m_csLogonScript;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLoginScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	LRESULT OnWizardBack();
	LRESULT OnWizardNext();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLoginScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\nwwks.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NWWKS.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CAddNWWKS dialog

class CAddNWWKS : public CDialog
{
// Construction
public:
	CAddNWWKS(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddNWWKS)
	enum { IDD = IDD_ADD_NWWKS_DIALOG };
	CString	m_csNetworkAddress;
	CString	m_csNodeAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddNWWKS)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddNWWKS)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNetworkAddressEdit();
	afx_msg void OnChangeNodeAddressEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\optdlg.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    OptDlg.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "OptDlg.h"

#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <winreg.h>

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg property page

IMPLEMENT_DYNCREATE(COptionsDlg, CWizBaseDlg)

COptionsDlg::COptionsDlg() : CWizBaseDlg(COptionsDlg::IDD)
{
	//{{AFX_DATA_INIT(COptionsDlg)
	m_bNW = FALSE;
	m_bProfile = FALSE;
	m_bRAS = FALSE;
	m_bExchange = FALSE;
	m_bHomeDir = FALSE;
	m_bLoginScript = FALSE;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

COptionsDlg::~COptionsDlg()
{
}

void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionsDlg)
	DDX_Check(pDX, IDC_NW_CHECK, m_bNW);
	DDX_Check(pDX, IDC_PROFILE_CHECK, m_bProfile);
	DDX_Check(pDX, IDC_RAS_CHECK, m_bRAS);
	DDX_Check(pDX, IDC_EXCHANGE_CHECK, m_bExchange);
	DDX_Check(pDX, IDC_HOMEDIR_CHECK, m_bHomeDir);
	DDX_Check(pDX, IDC_LOGIN_SCRIPT_CHECK, m_bLoginScript);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CWizBaseDlg)
	//{{AFX_MSG_MAP(COptionsDlg)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg message handlers

void COptionsDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (bShow)
		{
		CString csTemp;
		csTemp.LoadString(IDS_OPTION_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);

// first find out whats installed so we know what to enable/disable
		TCHAR* pServer = (TCHAR*)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		pApp->m_csServer.ReleaseBuffer();

		SERVER_INFO_102* pInfo;
		NET_API_STATUS nApi = NetServerGetInfo(pServer,
			102,
			(LPBYTE*)&pInfo);
		
		if (nApi != ERROR_SUCCESS)
			{
			AfxMessageBox(IDS_UNKNOWN_COMPONENTS);
			GetDlgItem(IDC_NW_CHECK)->EnableWindow(FALSE);
			return;
			}
			
// FPNW
		GetDlgItem(IDC_NW_CHECK)->EnableWindow(pInfo->sv102_type & SV_TYPE_SERVER_MFPN);
		m_bNW = (pInfo->sv102_type & SV_TYPE_SERVER_MFPN) ? m_bNW : FALSE;
		UpdateData(FALSE);
					
// exchange- look for the usrmgr extension entry
		HKEY hKey;

		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
		long lRet = RegConnectRegistry(
			(LPTSTR)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength()), 
			HKEY_LOCAL_MACHINE,
			&hKey);

		if (lRet != ERROR_SUCCESS) 
			{
			GetDlgItem(IDC_EXCHANGE_CHECK)->EnableWindow(FALSE);
			m_bExchange = FALSE;
			UpdateData(FALSE);
			return;
			}
		
		DWORD cbProv = 0;
		DWORD dwRet = RegOpenKey(hKey,
			TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Network\\UMAddOns"), &hKey );

		TCHAR* lpPrimaryDomain = NULL;
		if ((dwRet = RegQueryValueEx( hKey, TEXT("Mailumx"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
			GetDlgItem(IDC_EXCHANGE_CHECK)->EnableWindow(TRUE);
		else GetDlgItem(IDC_EXCHANGE_CHECK)->EnableWindow(FALSE);

		RegCloseKey(hKey);
		}
	
}

LRESULT COptionsDlg::OnWizardNext() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	UpdateData(TRUE);
	pApp->m_bProfile = m_bProfile;
	pApp->m_bLoginScript = m_bLoginScript;
	pApp->m_bHomeDir = m_bHomeDir;
	pApp->m_bRAS = m_bRAS;
	pApp->m_bNW = m_bNW;
	pApp->m_bExchange = m_bExchange;
	
	if (m_bProfile) return IDD_PROFILE;
	else if (m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (m_bNW) return IDD_FPNW_DLG;
	else if (m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\profile.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Profile.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CProfile dialog

class CProfile : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CProfile)

// Construction
public:
	CProfile();
	~CProfile();

// Dialog Data
	//{{AFX_DATA(CProfile)
	enum { IDD = IDD_PROFILE };
	CString	m_csProfilePath;
	//}}AFX_DATA

	LRESULT OnWizardNext();
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CProfile)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CProfile)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	LRESULT OnWizardBack();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\profile.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Profile.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Profile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProfile property page

IMPLEMENT_DYNCREATE(CProfile, CWizBaseDlg)

CProfile::CProfile() : CWizBaseDlg(CProfile::IDD)
{
	//{{AFX_DATA_INIT(CProfile)
	m_csProfilePath = _T("");
	//}}AFX_DATA_INIT
}

CProfile::~CProfile()
{
}

void CProfile::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProfile)
	DDX_Text(pDX, IDC_PROFILE_PATH, m_csProfilePath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProfile, CWizBaseDlg)
	//{{AFX_MSG_MAP(CProfile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProfile message handlers
BOOL CProfile::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	UpdateData(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
	 /*
void CProfile::OnBrowseButton() 
{
	static TCHAR szFilter[] = _T("All Files (*.*)|*.*||");

	CFileDialog cf(TRUE, L"", NULL, OFN_FILEMUSTEXIST | OFN_EXPLORER | OFN_PATHMUSTEXIST, szFilter);
	if (cf.DoModal() == IDOK)
		{
		m_csProfilePath = cf.GetPathName();
		UpdateData(FALSE);
		}

	
}	 */

LRESULT CProfile::OnWizardNext()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	UpdateData(TRUE);
	pApp->m_csProfilePath = m_csProfilePath;

	if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;


}

LRESULT CProfile::OnWizardBack()
{
	return IDD_OPTIONS_DIALOG;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\pwinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PasswordInfo.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "PwInfo.h"

#include <lmaccess.h>
#include <lmerr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPasswordInfo property page

IMPLEMENT_DYNCREATE(CPasswordInfo, CWizBaseDlg)

CPasswordInfo::CPasswordInfo() : CWizBaseDlg(CPasswordInfo::IDD)
{
	//{{AFX_DATA_INIT(CPasswordInfo)
	m_csPassword1 = _T("");
	m_csPassword2 = _T("");
	m_nPWOptions = 0;
	m_bNeverExpirePW = FALSE;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

CPasswordInfo::~CPasswordInfo()
{
}

void CPasswordInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPasswordInfo)
	DDX_Text(pDX, IDC_PASSWORD1, m_csPassword1);
	DDX_Text(pDX, IDC_PASSWORD2, m_csPassword2);
	DDX_Radio(pDX, IDC_PWOPTIONS_RADIO, m_nPWOptions);
	DDX_Check(pDX, IDC_EXPIREPW_CHECK, m_bNeverExpirePW);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPasswordInfo, CWizBaseDlg)
	//{{AFX_MSG_MAP(CPasswordInfo)
	ON_WM_SHOWWINDOW()
	ON_EN_CHANGE(IDC_PASSWORD1, OnChangePassword1)
	ON_EN_CHANGE(IDC_PASSWORD2, OnChangePassword2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPasswordInfo message handlers

LRESULT CPasswordInfo::OnWizardNext()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	UpdateData(TRUE);
	SetButtonAccess(PSWIZB_NEXT | PSWIZB_BACK);

	TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
	pApp->m_csServer.ReleaseBuffer();

	if (m_csPassword1 != m_csPassword2)
		{
		CString csPW;
		csPW.Format(IDS_PW_NOMATCH, pApp->m_csUserName);
		AfxMessageBox(csPW);
		GetDlgItem(IDC_PASSWORD1)->SetFocus();
		return -1;
		}

	if (m_csPassword1.GetLength() > 14)
		{
		AfxMessageBox(IDS_PW_TOOLONG);
		GetDlgItem(IDC_PASSWORD1)->SetFocus();
		return -1;
		}

	if (m_csPassword2.GetLength() > 14)
		{
		AfxMessageBox(IDS_PW_TOOLONG);
		GetDlgItem(IDC_PASSWORD2)->SetFocus();
		return -1;
		}

	LPBYTE pBuf;
	NET_API_STATUS nAPI = NetUserModalsGet(
		pServer,
		0,
		&pBuf);

	PUSER_MODALS_INFO_0 pModals = (PUSER_MODALS_INFO_0)pBuf;

	if (nAPI != NERR_Success)
		{
		AfxMessageBox(IDS_BAD_GETMODALS);
		ExitProcess(1);
		}

	if (m_csPassword1.GetLength() < (int)pModals->usrmod0_min_passwd_len)
		{
		CString csMin; 
		csMin.Format(IDS_PW_TOOSHORT, 
			pModals->usrmod0_min_passwd_len);

		AfxMessageBox(csMin);
		GetDlgItem(IDC_PASSWORD1)->SetFocus();
		return -1;
		}

	pApp->m_csPassword1 = m_csPassword1;
	m_csPassword1 = L"";

	if (m_nPWOptions == 0 && m_bNeverExpirePW) AfxMessageBox(IDS_WONT_REQUIRE);
	

	pApp->m_bPW_Never_Expires = m_bNeverExpirePW;

	if (m_nPWOptions == 0)
		{
		pApp->m_bMust_Change_PW = TRUE;
		pApp->m_bChange_Password = TRUE;
		}
	else if (m_nPWOptions == 1) 
		{
		pApp->m_bChange_Password = TRUE;
		pApp->m_bMust_Change_PW = FALSE;
		}

	else pApp->m_bChange_Password = FALSE;

	return CPropertyPage::OnWizardNext();

}


void CPasswordInfo::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_PASSWORD_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;

		if (pApp->m_bPWReset)
			{
			m_csPassword1 = L"";
			m_csPassword2 = L"";
			m_nPWOptions = 0;
			m_bNeverExpirePW = FALSE;
			pApp->m_bPWReset = FALSE;
			}
		UpdateData(FALSE);
		}
	
}

void CPasswordInfo::OnChangePassword1() 
{
	UpdateData(TRUE);

	if (m_csPassword1.GetLength() > 14)
		{
		AfxMessageBox(IDS_PW_TOOLONG);
		GetDlgItem(IDC_PASSWORD1)->SetFocus();
		}

}

void CPasswordInfo::OnChangePassword2() 
{
	UpdateData(TRUE);

	if (m_csPassword2.GetLength() > 14)
		{
		AfxMessageBox(IDS_PW_TOOLONG);
		GetDlgItem(IDC_PASSWORD2)->SetFocus();
		}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\prsinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PersonalInfo.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Prsinfo.h"

#include <lmerr.h>
#include <lmaccess.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfo dialog
IMPLEMENT_DYNCREATE(CPersonalInfo, CWizBaseDlg)

CPersonalInfo::CPersonalInfo() : CWizBaseDlg(CPersonalInfo::IDD)
{
	//{{AFX_DATA_INIT(CPersonalInfo)
	m_csDescription = _T("");
	m_csFullName = _T("");
	m_csUserName = _T("");
	//}}AFX_DATA_INIT
}


void CPersonalInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPersonalInfo)
	DDX_Text(pDX, IDC_DESCRIPTION, m_csDescription);
	DDX_Text(pDX, IDC_FULLNAME, m_csFullName);
	DDX_Text(pDX, IDC_USERNAME, m_csUserName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPersonalInfo, CWizBaseDlg)
	//{{AFX_MSG_MAP(CPersonalInfo)
	ON_WM_SHOWWINDOW()
	ON_EN_CHANGE(IDC_USERNAME, OnChangeUsername)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfo message handlers
LRESULT CPersonalInfo::OnWizardBack()
{
	SetButtonAccess(PSWIZB_NEXT | PSWIZB_BACK);

	return CPropertyPage::OnWizardBack();
}

LRESULT CPersonalInfo::OnWizardNext()
{
	SetButtonAccess(PSWIZB_NEXT | PSWIZB_BACK);
	
// eventually this needs to be changed to I_NetNameValidate from private\net\inc\icanon.h from netlib.lib
	UpdateData(TRUE);
	if (m_csUserName == "")
		{
		AfxMessageBox(IDS_NO_USERNAME);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		return -1;
		}

	if (m_csUserName.GetLength() > 20)
		{
		AfxMessageBox(IDS_USERNAME_TOOLONG);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		return -1;
		}

	if (m_csUserName.FindOneOf(L"\"\\/[];:|=,+*?<>") != -1)
		{
		AfxMessageBox(IDS_BAD_USERNAME);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		return -1;
		}

	CWaitCursor wait;
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	TCHAR* pServer = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
	pApp->m_csServer.ReleaseBuffer();

	TCHAR* pUser = m_csUserName.GetBuffer(m_csUserName.GetLength());
	m_csUserName.ReleaseBuffer();

// is username unique?
	LPBYTE* pUserInfo = new LPBYTE[256];
	NET_API_STATUS nAPI = NetUserGetInfo(pServer,
		pUser,
		0,
		pUserInfo);

	delete (pUserInfo);
	if (nAPI == NERR_Success)
		{
		CString csDup;
		csDup.Format(IDS_DUPLICATE_NAME, m_csUserName, m_csUserName, pApp->m_csDomain);
		AfxMessageBox(csDup);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		return -1;
		}

	pApp->m_csDescription = m_csDescription;
	pApp->m_csFullName = m_csFullName;
	pApp->m_csUserName = m_csUserName;

	return CPropertyPage::OnWizardNext();

}

void CPersonalInfo::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (bShow && pApp->m_bPRSReset)
		{
		m_csDescription	= L"";
		m_csFullName = L"";
		m_csUserName = L"";
		pApp->m_bPRSReset = FALSE;
		UpdateData(FALSE);
		}
}

void CPersonalInfo::OnChangeUsername() 
{
	UpdateData(TRUE);

	if (m_csUserName.GetLength() > 20)
		{
		AfxMessageBox(IDS_USERNAME_TOOLONG);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		}

	if (m_csUserName.FindOneOf(L"\"\\/[];:|=,+*?<>") != -1)
		{
		AfxMessageBox(IDS_BAD_USERNAME);
		GetDlgItem(IDC_USERNAME)->SetFocus();
		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\optdlg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    OptDlg.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog

class COptionsDlg : public CWizBaseDlg
{
	DECLARE_DYNCREATE(COptionsDlg)

// Construction
public:
	COptionsDlg();
	~COptionsDlg();

// Dialog Data
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTIONS_DIALOG };
	BOOL	m_bNW;
	BOOL	m_bProfile;
	BOOL	m_bRAS;
	BOOL	m_bExchange;
	BOOL	m_bHomeDir;
	BOOL	m_bLoginScript;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COptionsDlg)
	public:
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(COptionsDlg)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\pwinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PwInfo.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CPasswordInfo dialog
class CPasswordInfo : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CPasswordInfo)

// Construction
public:
	CPasswordInfo();
	~CPasswordInfo();
	
	LRESULT OnWizardNext();

// Dialog Data
	//{{AFX_DATA(CPasswordInfo)
	enum { IDD = IDD_PASSWORD_INFO };
	CString	m_csPassword1;
	CString	m_csPassword2;
	int		m_nPWOptions;
	BOOL	m_bNeverExpirePW;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPasswordInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPasswordInfo)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnChangePassword1();
	afx_msg void OnChangePassword2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\rasperm.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    CRasPerm.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "RasPerm.h"
#include <rassapi.h>

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRasPerm property page

IMPLEMENT_DYNCREATE(CRasPerm, CWizBaseDlg)

CRasPerm::CRasPerm() : CWizBaseDlg(CRasPerm::IDD)
{
	//{{AFX_DATA_INIT(CRasPerm)
	m_csRasPhoneNumber = _T("");
	m_nCallBackRadio = 0;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT
}

CRasPerm::~CRasPerm()
{
}

void CRasPerm::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRasPerm)
	DDX_Text(pDX, IDC_RASPHONE_EDIT, m_csRasPhoneNumber);
	DDX_Radio(pDX, IDC_CALL_BACK_RADIO, m_nCallBackRadio);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRasPerm, CWizBaseDlg)
	//{{AFX_MSG_MAP(CRasPerm)
	ON_WM_SHOWWINDOW()
	ON_BN_CLICKED(IDC_RADIO3, OnRadio3)
	ON_BN_CLICKED(IDC_RADIO2, OnRadio2)
	ON_BN_CLICKED(IDC_CALL_BACK_RADIO, OnCallBackRadio)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRasPerm message handlers
LRESULT CRasPerm::OnWizardNext()
{
	UpdateData(TRUE);
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if ((m_nCallBackRadio == 2) && (m_csRasPhoneNumber == L""))
		{
		AfxMessageBox(IDS_NO_RAS_NUMBER);
		return -1;
		}

// check for invalid phone number
	if (m_nCallBackRadio == 2)
		{
		if (m_csRasPhoneNumber.GetLength() > RASSAPI_MAX_PHONENUMBER_SIZE)
			{
			AfxMessageBox(IDS_RAS_NUMBER_TOO_LONG);
			GetDlgItem(IDC_RASPHONE_EDIT)->SetFocus();
			return -1;
			}

		TCHAR* pNum = m_csRasPhoneNumber.GetBuffer(m_csRasPhoneNumber.GetLength());
		TCHAR pValid[] = {L"0123456789TPW()@- "};

		if (_tcsspnp(pNum, pValid) != NULL)
			{
			AfxMessageBox(IDS_BAD_RAS_NUMBER);
			GetDlgItem(IDC_RASPHONE_EDIT)->SetFocus();
			return -1;
			}
		}

	pApp->m_csRasPhoneNumber = m_csRasPhoneNumber;
	pApp->m_sCallBackType = m_nCallBackRadio;
	
	if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else return IDD_RESTRICTIONS_DIALOG;

}

LRESULT CRasPerm::OnWizardBack()
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;

}

void CRasPerm::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_RAS_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}
	
}

void CRasPerm::OnRadio3() 
{
	GetDlgItem(IDC_RASPHONE_EDIT)->EnableWindow(TRUE);
	GetDlgItem(IDC_RASPHONE_EDIT)->SetFocus();
	
}

void CRasPerm::OnRadio2() 
{
	GetDlgItem(IDC_RASPHONE_EDIT)->EnableWindow(FALSE);
	
}

void CRasPerm::OnCallBackRadio() 
{
	GetDlgItem(IDC_RASPHONE_EDIT)->EnableWindow(FALSE);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\rasperm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    RasPerm.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CRasPerm dialog

class CRasPerm : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CRasPerm)

// Construction
public:
	CRasPerm();
	~CRasPerm();

// Dialog Data
	//{{AFX_DATA(CRasPerm)
	enum { IDD = IDD_RAS_PERM_DIALOG };
	CString	m_csRasPhoneNumber;
	int		m_nCallBackRadio;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRasPerm)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	LRESULT OnWizardNext();
	LRESULT OnWizardBack();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRasPerm)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnRadio3();
	afx_msg void OnRadio2();
	afx_msg void OnCallBackRadio();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\prsinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PrsInfo.h : header file

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CPersonalInfo dialog

class CPersonalInfo : public CWizBaseDlg
{
DECLARE_DYNCREATE(CPersonalInfo)

// Construction
public:
	CPersonalInfo();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPersonalInfo)
	enum { IDD = IDD_USER_NAME };
	CString	m_csDescription;
	CString	m_csFullName;
	CString	m_csUserName;
	//}}AFX_DATA

	LRESULT OnWizardBack();
	LRESULT OnWizardNext();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonalInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPersonalInfo)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnChangeUsername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\restrct.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Restrct.cpp : implementation file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

// 
//

#include "stdafx.h"
#include "speckle.h"
#include "wizbased.h"
#include "Restrct.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRestrictions property page

IMPLEMENT_DYNCREATE(CRestrictions, CWizBaseDlg)

CRestrictions::CRestrictions() : CWizBaseDlg(CRestrictions::IDD)
{
	//{{AFX_DATA_INIT(CRestrictions)
	m_bAccountExpire = FALSE;
	m_bAccountDisabled = FALSE;
	m_bLoginTimes = FALSE;
	m_bLimitWorkstations = FALSE;
	m_nRestrictions = 0;
	m_csCaption = _T("");
	//}}AFX_DATA_INIT

	m_bEnable = FALSE;
	m_bHours = FALSE;

}

CRestrictions::~CRestrictions()
{
}

void CRestrictions::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRestrictions)
	DDX_Check(pDX, IDC_ACCOUNT_EXPIRE_CHECK, m_bAccountExpire);
	DDX_Check(pDX, IDC_DISABLED_CHECK, m_bAccountDisabled);
	DDX_Check(pDX, IDC_LOGIN_TIMES_CHECK, m_bLoginTimes);
	DDX_Check(pDX, IDC_WORKSTATIONS_CHECK, m_bLimitWorkstations);
	DDX_Radio(pDX, IDC_RESTRICTIONS_RADIO, m_nRestrictions);
	DDX_Text(pDX, IDC_STATIC1, m_csCaption);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRestrictions, CWizBaseDlg)
	//{{AFX_MSG_MAP(CRestrictions)
	ON_BN_CLICKED(IDC_RESTRICTIONS_RADIO, OnRestrictionsRadio)
	ON_BN_CLICKED(IDC_RESTRICTIONS_RADIO2, OnRestrictionsRadio2)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRestrictions message handlers

LRESULT CRestrictions::OnWizardBack() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (pApp->m_bExchange) return IDD_EXCHANGE_DIALOG;
	else if (pApp->m_bNW) return IDD_FPNW_DLG;
	else if (pApp->m_bRAS) return IDD_RAS_PERM_DIALOG;
	else if (pApp->m_bHomeDir) return IDD_HOMEDIR_DIALOG;
	else if (pApp->m_bLoginScript) return IDD_LOGON_SCRIPT_DIALOG;
	else if (pApp->m_bProfile) return IDD_PROFILE;
	else return IDD_OPTIONS_DIALOG;

}

LRESULT CRestrictions::OnWizardNext() 
{
	UpdateData(TRUE);
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	pApp->m_bEnableRestrictions = m_bEnable;
	pApp->m_bExpiration = m_bAccountExpire & m_bEnable;
	pApp->m_bDisabled = m_bAccountDisabled & m_bEnable;
	pApp->m_bHours = m_bLoginTimes & m_bEnable;
	pApp->m_bWorkstation = m_bLimitWorkstations & m_bEnable;

	if (m_bAccountExpire & m_bEnable) return IDD_ACCOUNT_EXP_DIALOG;
	else if (m_bLoginTimes & m_bEnable) return IDD_HOURS_DLG;
	else if (m_bLimitWorkstations & m_bEnable) return IDD_LOGONTO_DLG;
	else if (pApp->m_bNW & m_bEnable) return IDD_NWLOGON_DIALOG;
	else return IDD_FINISH;
	
	return CWizBaseDlg::OnWizardNext();

}

void CRestrictions::OnRestrictionsRadio() 
{
	GetDlgItem(IDC_ACCOUNT_EXPIRE_CHECK)->EnableWindow(FALSE);
	GetDlgItem(IDC_DISABLED_CHECK)->EnableWindow(FALSE);
	GetDlgItem(IDC_LOGIN_TIMES_CHECK)->EnableWindow(FALSE);
	GetDlgItem(IDC_WORKSTATIONS_CHECK)->EnableWindow(FALSE);

	m_bEnable = FALSE;
	
}

void CRestrictions::OnRestrictionsRadio2() 
{
	GetDlgItem(IDC_ACCOUNT_EXPIRE_CHECK)->EnableWindow(TRUE);
	GetDlgItem(IDC_DISABLED_CHECK)->EnableWindow(TRUE);
	GetDlgItem(IDC_LOGIN_TIMES_CHECK)->EnableWindow(m_bHours);
	GetDlgItem(IDC_WORKSTATIONS_CHECK)->EnableWindow(TRUE);

	m_bEnable = TRUE;
	
}

void CRestrictions::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWizBaseDlg::OnShowWindow(bShow, nStatus);
	
	if (bShow)
		{
		CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

		CString csTemp;
		csTemp.LoadString(IDS_RESTRICTION_CAPTION);

		CString csTemp2;
		csTemp2.Format(csTemp, pApp->m_csUserName);
		m_csCaption = csTemp2;
		UpdateData(FALSE);
		}

}

BOOL CRestrictions::OnInitDialog() 
{
	CWizBaseDlg::OnInitDialog();
	
	CString csPath;
	TCHAR pDir[256];
	GetSystemDirectory(pDir, 256);
	csPath = pDir;
	csPath += L"\\hours.ocx";

	HINSTANCE hLib = LoadLibrary((LPCTSTR)csPath);

	if (hLib < (HINSTANCE)HINSTANCE_ERROR)
		{
		m_bHours = FALSE;						 //unable to load DLL
		return TRUE;
		}

	// Find the entry point.
	FARPROC lpDllEntryPoint = NULL;
	(FARPROC&)lpDllEntryPoint = GetProcAddress(hLib, 
		"DllRegisterServer");
	if (lpDllEntryPoint != NULL)
		{
		HRESULT h = (*lpDllEntryPoint)();
		if (h == 0) m_bHours = TRUE;
		else m_bHours = FALSE;
		}
	else
		m_bHours = FALSE;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by speckle.rc
//
#define IDS_GENERIC_NO_HEAP             1
#define IDS_GENERIC_NO_PDC              2
#define IDS_GENERIC_BAD_MACHINE         3
#define IDS_NO_GROUP_NAME               4
#define IDS_GROUP_INVALID_NAME          5
#define IDS_DOMAIN_SET                  6
#define IDS_TREE_ROOT                   7
#define IDS_NET_ERROR                   8
#define IDS_NET_NO_SERVERS              9
#define IDS_ERROR                       10
#define IDS_GROUP_EXISTS                11
#define IDS_INSUFFICIENT_PERMISSION     12
#define IDS_CANT_ADD_NAMES              13
#define IDS_LOCAL_GROUP                 14
#define IDS_GLOBAL_GROUP                15
#define IDS_NO_MACHINE_NAME             16
#define IDS_NO_VALID_WORKSTATIONS       17
#define IDS_NO_NEW_USER                 18
#define IDS_BAD_USER_DATA               19
#define IDS_NO_LOCAL_GROUP              20
#define IDS_NO_GLOBAL_GROUP             21
#define IDD_SPECKLE_DIALOG              102
#define IDD_RAS_PERM_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_BASE_DIALOG                 129
#define IDB_BITMAP1                     130
#define IDD_WELCOME_DIALOG              131
#define IDD_LOCAL_REMOTE                132
#define IDD_REMOTE_NAME                 133
#define IDD_USER_NAME                   134
#define IDB_USER_BITMAP                 134
#define IDD_PASSWORD_INFO               135
#define IDB_GLOBAL_GROUP_BITMAP         136
#define IDD_GROUP_INFO                  138
#define IDB_NET_TREE                    138
#define IDD_PROFILE                     139
#define IDB_USER_BITMAP1                139
#define IDD_FINISH                      140
#define IDD_FPNW_DLG                    142
#define IDB_LOCAL_GROUP_BITMAP          143
#define IDB_WORLD                       144
#define IDD_ADD_NWWKS_DIALOG            145
#define IDD_ACCOUNT_EXP_DIALOG          146
#define IDD_OPTIONS_DIALOG              148
#define IDD_HOMEDIR_DIALOG              150
#define IDD_LOGON_SCRIPT_DIALOG         151
#define IDD_RESTRICTIONS_DIALOG         152
#define IDD_NWLOGON_DIALOG              153
#define IDD_EXCHANGE_DIALOG             154
#define IDD_ADD_WKS_DIALOG              155
#define IDB_ENDFLAG                     156
#define IDD_HOURS_DLG                   164
#define IDD_LOGONTO_DLG                 165
#define IDC_PAINT_BOX                   1000
#define IDC_RADIO_LOCAL                 1001
#define IDC_RADIO_REMOTE                1002
#define IDC_REMOTE_SERVER               1003
#define IDC_USERNAME                    1004
#define IDC_FULLNAME                    1005
#define IDC_DESCRIPTION                 1006
#define IDC_LOCATION                    1007
#define IDC_MUST_CHANGE_PASSWORD        1010
#define IDC_CANNOT_CHANGE_PASSWORD      1011
#define IDC_PASSWORD_NEVER_EXPIRES      1012
#define IDC_ACCOUNT_DISABLED            1013
#define IDC_PASSWORD1                   1015
#define IDC_PASSWORD2                   1016
#define IDC_AVAILABLE_GROUPS            1017
#define IDC_SELECTED_GROUPS             1018
#define IDC_GROUP_MEMBER_LIST           1018
#define IDC_ADD_GROUP                   1019
#define IDC_GROUP_AVAILABLE_LIST        1019
#define IDC_REMOVE_GROUP                1020
#define IDC_ADD_BUTTON                  1020
#define IDC_LOGON_SCRIPT                1021
#define IDC_REMOVE_BUTTON               1021
#define IDC_LOCAL_PATH_BUTTON           1022
#define IDC_LOCALPATH_TEXT              1023
#define IDC_REMOTE_PATH_BUTTON          1024
#define IDC_DRIVE_LETTER                1026
#define IDC_REMOTE_PATH                 1027
#define IDC_DIALIN_CHECK                1028
#define IDC_CALL_BACK_RADIO             1029
#define IDC_RADIO2                      1030
#define IDC_RADIO3                      1031
#define IDC_RASPHONE_EDIT               1032
#define IDC_EXPIRE_NW_PASSWORD          1033
#define IDC_GRACE_LOGIN_RADIO           1034
#define IDC_ALLOWED_GRACE_LOGINS_EDIT   1035
#define IDC_GRACE_LOGIN_SPIN            1036
#define IDC_REMAINING_GRACE_LOGINS_EDIT 1037
#define IDC_CONCURRENT_CONNECTIONS_RADIO 1038
#define IDC_CONCURRENT_CONNECTIONS_RADIO2 1039
#define IDC_CONCURRENT_CONNNECTIONS_EDIT 1040
#define IDC_CONNCURRENT_CONNECTIONS_SPIN 1041
#define IDC_STATIC1                     1042
#define IDC_STATIC2                     1043
#define IDC_STATIC3                     1044
#define IDC_GRACE_LOGIN_RADIO2          1045
#define IDC_NETTREE                     1048
#define IDC_NETTREE_EDIT                1049
#define IDC_NWPATH_EDIT                 1051
#define IDC_PROFILE_PATH                1052
#define IDC_NWLOGON_RADIO               1053
#define IDC_NWLOGON_LIST                1054
#define IDC_NWLOGON_RADIO2              1057
#define IDC_NWSTATIC1                   1058
#define IDC_NWSTATIC2                   1059
#define IDC_NETWORK_ADDRESS_EDIT        1060
#define IDC_AVAILABLE_TIMES             1061
#define IDC_NODE_ADDRESS_EDIT           1061
#define IDC_SU_BUTTON                   1064
#define IDC_DAY_EDIT                    1064
#define IDC_MONTH_EDIT                  1065
#define IDC_YEAR_EDIT                   1066
#define IDC_WHERE_LOGON_RADIO           1068
#define IDC_DATE_SPIN                   1068
#define IDC_LOCATION_EDIT1              1069
#define IDC_M_BUTTON                    1069
#define IDC_LOCATION_EDIT2              1070
#define IDC_TU_BUTTON                   1070
#define IDC_LOCATION_EDIT3              1071
#define IDC_W_BUTTON                    1071
#define IDC_LOCATION_EDIT4              1072
#define IDC_TH_BUTTON                   1072
#define IDC_LOCATION_EDIT5              1073
#define IDC_F_BUTTON                    1073
#define IDC_NW_CHECK                    1073
#define IDC_LOCATION_EDIT6              1074
#define IDC_SA_BUTTON                   1074
#define IDC_RAS_CHECK                   1074
#define IDC_LOCATION_EDIT7              1075
#define IDC_LOCATION_EDIT8              1076
#define IDC_STATIC4                     1078
#define IDC_PROFILE_CHECK               1078
#define IDC_STATIC5                     1079
#define IDC_STATIC6                     1080
#define IDC_STATIC7                     1081
#define IDC_STATIC8                     1082
#define IDC_WHERE_LOGON_RADIO2          1083
#define IDC_DOMAIN_LIST                 1090
#define IDC_PWOPTIONS_RADIO             1091
#define IDC_EXPIREPW_CHECK              1092
#define IDC_BROWSE_BUTTON               1093
#define IDC_LOGIN_SCRIPT_CHECK          1094
#define IDC_HOMEDIR_CHECK               1095
#define IDC_EXCHANGE_CHECK              1096
#define IDC_RESTRICTIONS_RADIO          1097
#define IDC_RESTRICTIONS_RADIO2         1098
#define IDC_ACCOUNT_EXPIRE_CHECK        1099
#define IDC_LOGIN_TIMES_CHECK           1100
#define IDC_WORKSTATIONS_CHECK          1101
#define IDC_PRIMARY_GROUP               1102
#define IDC_DISABLED_CHECK              1102
#define IDC_SET_PRIMARY_GROUP_BUTTON    1103
#define IDC_LIST1                       1103
#define IDC_CONCURRENT_CONNECTIONS_RADIO1 1106
#define IDC_CONCURRENT_CONNECTIONS_EDIT 1107
#define IDC_CONCURRENT_CONNECTIONS_SPIN 1109
#define IDC_WORKSTATION_EDIT            1110
#define IDC_RADIO1                      1113
#define IDC_WORKSTATION_RADIO           1113
#define IDC_BUTTON1                     1114
#define IDC_COMBO2                      1117
#define IDC_WORKSTATION_RADIO2          1118
#define IDC_STATIC_ALLOWEDTIMES         1119
#define IDC_STATIC_DISALLOWEDTIMES      1120
#define IDC_SERVER_LIST                 1121
#define IDC_STATIC_FRAME                1124
#define IDC_STATIC_DOMAIN               1130
#define IDC_SERVERNAME_EDIT             1131
#define IDC_HOURSCTRL1                  1132
#define IDS_BAD_VERSION                 57345
#define IDS_WELCOME_STRING              57346
#define IDS_PASSWORD_CAPTION            57347
#define IDS_FINISH_CAPTION              57348
#define IDS_OPTION_CAPTION              57349
#define IDS_FPNW_CAPTION                57350
#define IDS_GROUP_CAPTION               57351
#define IDS_RAS_CAPTION                 57352
#define IDS_WORKSTATION_CAPTION         57353
#define IDS_HOMEDIR_CAPTION             57354
#define IDS_RESTRICTION_CAPTION         57355
#define IDS_NWLOGON_CAPTION             57356
#define IDS_SUCCESS                     57357
#define IDS_NW_PW_ERROR                 57358
#define IDS_NW_GRACELOGIN_ERROR         57359
#define IDS_NW_CONCON_ERROR             57360
#define IDS_RAS_ERROR                   57361
#define IDS_NEEDA_WORKSTATION           57362
#define IDS_NEED_ADDRESS                57363
#define IDS_UNKNOWN_COMPONENTS          57364
#define IDS_BAD_WS_NAME                 57365
#define IDS_BAD_USERNAME                57366
#define IDS_DUPLICATE_NAME              57367
#define IDS_PW_NOMATCH                  57368
#define IDS_PW_TOOLONG                  57369
#define IDS_BAD_GETMODALS               57370
#define IDS_PW_TOOSHORT                 57371
#define IDS_NODC                        57372
#define IDS_NO_USERNAME                 57373
#define IDS_USERNAME_TOOLONG            57374
#define IDS_NOFP_WS                     57375
#define IDS_ALL_NODES                   57376
#define IDS_NOT_ADMIN                   57377
#define IDS_WSNAME_TOOLONG              57378
#define IDS_INVALID_DAY                 57379
#define IDS_INVALID_MONTH               57380
#define IDS_INVALID_YEAR                57381
#define IDS_BAD_NWADDRESS               57382
#define IDS_BAD_NWNODE                  57383
#define IDS_TOOLONG_NWADDRESS           57384
#define IDS_TOOLONG_NWNODE              57385
#define IDS_ALREADY_EXPIRED             57386
#define IDS_INVALID_DIRECTORY_NAME      57388
#define IDS_NO_DIR_PERMISSION           57389
#define IDS_CANT_CREATE_DIRECTORY       57390
#define IDS_INVALID_PATH                57391
#define IDS_NEW_DIR_CREATED             57392
#define IDS_SUCCESS2                    57393
#define IDS_WONT_REQUIRE                57394
#define IDS_BAD_USER_DATA2              57395
#define IDC_NO_WKSALLOWED               57396
#define IDS_NO_HOMEDIR_DRIVE_LETTER     57397
#define IDS_NO_RAS_NUMBER               57398
#define IDS_NO_EXCH_SERVER              57399
#define IDS_BAD_RAS_NUMBER              57400
#define IDS_RAS_NUMBER_TOO_LONG         57401
#define IDS_INVALID_GL_NUMBER           57402

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        158
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1133
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\rpcbak.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Thu Apr 11 13:52:52 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcbak_h__
#define __rpcbak_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __TriggerBackupRPC_INTERFACE_DEFINED__
#define __TriggerBackupRPC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: TriggerBackupRPC
 * at Thu Apr 11 13:52:52 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


#ifndef RPC_COMMON_IDL
#define RPC_COMMON_IDL
#define		szTriggerRPCProtocol		TEXT("ncacn_np")
#define		szTriggerRPCSecurity		TEXT("Security=impersonation dynamic true")
			/* size is 4 */
typedef long RPC_BOOL;

			/* size is 1 */
typedef small RPC_BYTE;

			/* size is 4 */
typedef long RPC_INT;

			/* size is 4 */
typedef long RPC_SC;

			/* size is 4 */
typedef long RPC_EC;

			/* size is 4 */
typedef long RPC_DWORD;

			/* size is 2 */
typedef wchar_t RPC_CHAR;

			/* size is 4 */
typedef /* [string] */ RPC_CHAR __RPC_FAR *RPC_SZ;

			/* size is 16 */
typedef struct  __MIDL_TriggerBackupRPC_0001
    {
    short rgwSystemTime[ 8 ];
    }	RPC_SYSTEMTIME;

			/* size is 172 */
typedef struct  __MIDL_TriggerBackupRPC_0002
    {
    RPC_BYTE rgbTzi[ 172 ];
    }	RPC_TIME_ZONE_INFORMATION;

			/* size is 28 */
typedef struct  __MIDL_TriggerBackupRPC_0003
    {
    long rgdwServiceStatus[ 7 ];
    }	RPC_SERVICE_STATUS;

#define		ecOK						0		// no error
#define		ecGeneralFailure			50001	// a failure occurred that caused proxy generation to stop
#define		ecSomeProxiesFailed			50002	// some proxies failed to get generated
#define		ecTargetNotValid			50003	// supplied target address not valid
#define		ecTargetNotUnique			50004	// supplied target address not unique
#define		ecProxyDLLNotImplemented	50005	// not implemented yet
#define		ecProxyDLLOOM				50006	// memory allocation error
#define		ecProxyDLLError				50007	// general error
#define		ecProxyDLLProtocol			50008	// protocol error
#define		ecProxyDLLSyntax			50009	// syntax error
#define		ecProxyDLLEOF				50010   // end of file
#define		ecProxyDLLSoftware			50011	// error in software
#define		ecProxyDLLConfig			50012	// configuration error
#define		ecProxyDLLContention		50013	// contention error
#define		ecProxyDLLNotFound			50014	// not found
#define		ecProxyDLLDiskSpace			50015	// out of disk space
#define		ecProxyDLLException			50016	// exception thrown
#define		ecProxyDLLDefault			50017	// unknown error
#define		ecProxyNotValid				50018	// supplied proxy not valid
#define		ecProxyNotUnique			50019	// supplied proxy not unique or unable to generate a unique proxy
#define		ecProxyDuplicate			50020	// a primary proxy of the same type was also supplied
			/* size is 16 */
typedef struct  _PROXYNODE
    {
    struct _PROXYNODE __RPC_FAR *pnodeNext;
    RPC_SZ wszProxy;
    RPC_EC ec;
    RPC_SZ wszDN;
    }	PROXYNODE;

			/* size is 4 */
typedef struct _PROXYNODE __RPC_FAR *PPROXYNODE;

			/* size is 48 */
typedef struct  _PROXYINFO
    {
    RPC_BOOL fContinueOnError;
    RPC_BOOL fIgnoreOldSecondaries;
    RPC_SZ wszDN;
    RPC_SZ wszNickName;
    RPC_SZ wszCommonName;
    RPC_SZ wszDisplayName;
    RPC_SZ wszSurName;
    RPC_SZ wszGivenName;
    RPC_SZ wszInitials;
    RPC_SZ wszTargetAddress;
    PROXYNODE __RPC_FAR *pPNVerifyProxy;
    PROXYNODE __RPC_FAR *pPNExcludeProxy;
    }	PROXYINFO;

			/* size is 4 */
typedef struct _PROXYINFO __RPC_FAR *PPROXYINFO;

			/* size is 8 */
typedef struct  _PROXYLIST
    {
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNProxy;
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNFailedProxyType;
    }	PROXYLIST;

			/* size is 4 */
typedef struct _PROXYLIST __RPC_FAR *PPROXYLIST;

			/* size is 192 */
typedef struct  __MIDL_TriggerBackupRPC_0004
    {
    RPC_SYSTEMTIME st;
    RPC_TIME_ZONE_INFORMATION tzi;
    RPC_DWORD dwReturn;
    }	RemoteSystemTimeInfo;

			/* size is 48 */
typedef struct  _RemoteServiceStatus
    {
    RPC_SC sc;
    RPC_SZ szShortName;
    RPC_SZ szDisplayName;
    RPC_SZ szVersion;
    RPC_SERVICE_STATUS ss;
    struct _RemoteServiceStatus __RPC_FAR *prssNext;
    }	RemoteServiceStatus;

#define		rmsSuspendRepair	0x0001
#define		rmsSuspendNotif		0x0002
			/* size is 24 */
typedef struct  _RemoteMaintenanceStatus
    {
    RPC_DWORD dwStatus;
    RPC_SYSTEMTIME st;
    RPC_SZ szUser;
    }	RemoteMaintenanceStatus;

			/* size is 12 */
typedef struct  _BackupListNode
    {
    struct _BackupListNode __RPC_FAR *pnodeNext;
    struct _BackupListNode __RPC_FAR *pnodeChildren;
    RPC_SZ szName;
    }	BackupListNode;

			/* size is 44 */
typedef struct  _DistributedLockOwner
    {
    RPC_CHAR rgchComputer[ 17 ];
    RPC_DWORD dwPID;
    RPC_DWORD dwTID;
    }	DistributedLockOwner;

#define	DLR_NO_WAIT		0x00000001
#define	cchMaxLockName	17
			/* size is 84 */
typedef struct  _DistributedLockRequest
    {
    RPC_CHAR rgchLockName[ 17 ];
    RPC_DWORD dwFlags;
    DistributedLockOwner dlo;
    }	DistributedLockRequest;

			/* size is 48 */
typedef struct  _DistributedLockReply
    {
    RPC_BOOL fGranted;
    DistributedLockOwner dlo;
    }	DistributedLockReply;

#endif  // #ifndef RPC_COMMON_IDL
			/* size is 4 */
RPC_SC __cdecl ScGetBackupListNode( 
    /* [in] */ handle_t h,
    /* [out][in] */ BackupListNode __RPC_FAR *__RPC_FAR *ppnode);



extern RPC_IF_HANDLE TriggerBackupRPC_ClientIfHandle;
extern RPC_IF_HANDLE TriggerBackupRPC_ServerIfHandle;
#endif /* __TriggerBackupRPC_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\restrct.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Restrct.h : header file

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////
// CRestrictions dialog

class CRestrictions : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CRestrictions)

// Construction
public:
	CRestrictions();
	~CRestrictions();

// Dialog Data
	//{{AFX_DATA(CRestrictions)
	enum { IDD = IDD_RESTRICTIONS_DIALOG };
	BOOL	m_bAccountExpire;
	BOOL	m_bAccountDisabled;
	BOOL	m_bLoginTimes;
	BOOL	m_bLimitWorkstations;
	int		m_nRestrictions;
	CString	m_csCaption;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRestrictions)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRestrictions)
	afx_msg void OnRestrictionsRadio();
	afx_msg void OnRestrictionsRadio2();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_bEnable;
	BOOL m_bHours;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Speckle.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\rpcpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Thu Apr 11 09:26:39 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __rpcpub_h__
#define __rpcpub_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __TriggerPublicRPC_INTERFACE_DEFINED__
#define __TriggerPublicRPC_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: TriggerPublicRPC
 * at Thu Apr 11 09:26:39 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [auto_handle][unique][version][uuid] */ 


#ifndef RPC_COMMON_IDL
#define RPC_COMMON_IDL
#define		szTriggerRPCProtocol		TEXT("ncacn_np")
#define		szTriggerRPCSecurity		TEXT("Security=impersonation dynamic true")
			/* size is 4 */
typedef long RPC_BOOL;

			/* size is 1 */
typedef small RPC_BYTE;

			/* size is 4 */
typedef long RPC_INT;

			/* size is 4 */
typedef long RPC_SC;

			/* size is 4 */
typedef long RPC_EC;

			/* size is 4 */
typedef long RPC_DWORD;

			/* size is 2 */
typedef wchar_t RPC_CHAR;

			/* size is 4 */
typedef /* [string] */ RPC_CHAR __RPC_FAR *RPC_SZ;

			/* size is 16 */
typedef struct  __MIDL_TriggerPublicRPC_0001
    {
    short rgwSystemTime[ 8 ];
    }	RPC_SYSTEMTIME;

			/* size is 172 */
typedef struct  __MIDL_TriggerPublicRPC_0002
    {
    RPC_BYTE rgbTzi[ 172 ];
    }	RPC_TIME_ZONE_INFORMATION;

			/* size is 28 */
typedef struct  __MIDL_TriggerPublicRPC_0003
    {
    long rgdwServiceStatus[ 7 ];
    }	RPC_SERVICE_STATUS;

#define		ecOK						0		// no error
#define		ecGeneralFailure			50001	// a failure occurred that caused proxy generation to stop
#define		ecSomeProxiesFailed			50002	// some proxies failed to get generated
#define		ecTargetNotValid			50003	// supplied target address not valid
#define		ecTargetNotUnique			50004	// supplied target address not unique
#define		ecProxyDLLNotImplemented	50005	// not implemented yet
#define		ecProxyDLLOOM				50006	// memory allocation error
#define		ecProxyDLLError				50007	// general error
#define		ecProxyDLLProtocol			50008	// protocol error
#define		ecProxyDLLSyntax			50009	// syntax error
#define		ecProxyDLLEOF				50010   // end of file
#define		ecProxyDLLSoftware			50011	// error in software
#define		ecProxyDLLConfig			50012	// configuration error
#define		ecProxyDLLContention		50013	// contention error
#define		ecProxyDLLNotFound			50014	// not found
#define		ecProxyDLLDiskSpace			50015	// out of disk space
#define		ecProxyDLLException			50016	// exception thrown
#define		ecProxyDLLDefault			50017	// unknown error
#define		ecProxyNotValid				50018	// supplied proxy not valid
#define		ecProxyNotUnique			50019	// supplied proxy not unique or unable to generate a unique proxy
#define		ecProxyDuplicate			50020	// a primary proxy of the same type was also supplied
			/* size is 16 */
typedef struct  _PROXYNODE
    {
    struct _PROXYNODE __RPC_FAR *pnodeNext;
    RPC_SZ wszProxy;
    RPC_EC ec;
    RPC_SZ wszDN;
    }	PROXYNODE;

			/* size is 4 */
typedef struct _PROXYNODE __RPC_FAR *PPROXYNODE;

			/* size is 48 */
typedef struct  _PROXYINFO
    {
    RPC_BOOL fContinueOnError;
    RPC_BOOL fIgnoreOldSecondaries;
    RPC_SZ wszDN;
    RPC_SZ wszNickName;
    RPC_SZ wszCommonName;
    RPC_SZ wszDisplayName;
    RPC_SZ wszSurName;
    RPC_SZ wszGivenName;
    RPC_SZ wszInitials;
    RPC_SZ wszTargetAddress;
    PROXYNODE __RPC_FAR *pPNVerifyProxy;
    PROXYNODE __RPC_FAR *pPNExcludeProxy;
    }	PROXYINFO;

			/* size is 4 */
typedef struct _PROXYINFO __RPC_FAR *PPROXYINFO;

			/* size is 8 */
typedef struct  _PROXYLIST
    {
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNProxy;
    PROXYNODE __RPC_FAR *__RPC_FAR *ppPNFailedProxyType;
    }	PROXYLIST;

			/* size is 4 */
typedef struct _PROXYLIST __RPC_FAR *PPROXYLIST;

			/* size is 192 */
typedef struct  __MIDL_TriggerPublicRPC_0004
    {
    RPC_SYSTEMTIME st;
    RPC_TIME_ZONE_INFORMATION tzi;
    RPC_DWORD dwReturn;
    }	RemoteSystemTimeInfo;

			/* size is 48 */
typedef struct  _RemoteServiceStatus
    {
    RPC_SC sc;
    RPC_SZ szShortName;
    RPC_SZ szDisplayName;
    RPC_SZ szVersion;
    RPC_SERVICE_STATUS ss;
    struct _RemoteServiceStatus __RPC_FAR *prssNext;
    }	RemoteServiceStatus;

#define		rmsSuspendRepair	0x0001
#define		rmsSuspendNotif		0x0002
			/* size is 24 */
typedef struct  _RemoteMaintenanceStatus
    {
    RPC_DWORD dwStatus;
    RPC_SYSTEMTIME st;
    RPC_SZ szUser;
    }	RemoteMaintenanceStatus;

			/* size is 12 */
typedef struct  _BackupListNode
    {
    struct _BackupListNode __RPC_FAR *pnodeNext;
    struct _BackupListNode __RPC_FAR *pnodeChildren;
    RPC_SZ szName;
    }	BackupListNode;

			/* size is 44 */
typedef struct  _DistributedLockOwner
    {
    RPC_CHAR rgchComputer[ 17 ];
    RPC_DWORD dwPID;
    RPC_DWORD dwTID;
    }	DistributedLockOwner;

#define	DLR_NO_WAIT		0x00000001
#define	cchMaxLockName	17
			/* size is 84 */
typedef struct  _DistributedLockRequest
    {
    RPC_CHAR rgchLockName[ 17 ];
    RPC_DWORD dwFlags;
    DistributedLockOwner dlo;
    }	DistributedLockRequest;

			/* size is 48 */
typedef struct  _DistributedLockReply
    {
    RPC_BOOL fGranted;
    DistributedLockOwner dlo;
    }	DistributedLockReply;

#endif  // #ifndef RPC_COMMON_IDL
			/* size is 4 */
RPC_SC __cdecl ScNetworkTimingTest( 
    /* [in] */ handle_t h,
    /* [in] */ long cbSend,
    /* [size_is][in] */ small __RPC_FAR rgbSend[  ],
    /* [in] */ long cbReceive,
    /* [size_is][out] */ small __RPC_FAR rgbReceive[  ]);

			/* size is 4 */
RPC_SC __cdecl ScRunRID( 
    /* [in] */ handle_t h);

			/* size is 4 */
RPC_SC __cdecl ScRunRIDEx( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fProxySpace,
    /* [in] */ RPC_BOOL fGwart);

			/* size is 4 */
RPC_SC __cdecl ScRunDRACheck( 
    /* [in] */ handle_t h,
    RPC_DWORD dw);

#define		BPTAdd			1
#define		BPTRemove		2
#define		BPTUpdate		3
			/* size is 4 */
RPC_SC __cdecl ScBulkCreateProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szHeader,
    /* [in] */ RPC_DWORD dwOptions);

			/* size is 4 */
RPC_SC __cdecl ScBulkCreateMultiProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cszHeader,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszRecipients[  ],
    /* [in] */ RPC_DWORD dwOptions);

			/* size is 4 */
RPC_SC __cdecl ScBulkUpdateMultiProxy( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cszSiteAddress,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszOldSiteAddress[  ],
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszNewSiteAddress[  ],
    /* [in] */ RPC_BOOL fSaveSiteAddress);

			/* size is 4 */
RPC_SC __cdecl ScGetBulkProxyStatus( 
    /* [in] */ handle_t h,
    /* [out] */ RPC_SYSTEMTIME __RPC_FAR *pstTimeStart,
    /* [out] */ RPC_DWORD __RPC_FAR *pdwTimeStart,
    /* [out] */ RPC_DWORD __RPC_FAR *pdwTimeCur,
    /* [out] */ RPC_INT __RPC_FAR *piRecipients,
    /* [out] */ RPC_INT __RPC_FAR *pcRecipients);

			/* size is 4 */
RPC_SC __cdecl ScBulkProxyHalt( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fWaitForShutdown);

			/* size is 4 */
RPC_EC __cdecl EcGetProxies( 
    /* [in] */ handle_t h,
    /* [in] */ PPROXYINFO pProxyInfo,
    /* [out][in] */ PPROXYLIST pProxyList);

			/* size is 4 */
RPC_SC __cdecl ScIsProxyUnique( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfUnique,
    /* [out] */ RPC_SZ __RPC_FAR *pszOwner);

			/* size is 4 */
RPC_SC __cdecl ScProxyValidate( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfValid,
    /* [out] */ RPC_SZ __RPC_FAR *pszProxyCorrected);

			/* size is 4 */
RPC_SC __cdecl ScSiteProxyValidate( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_SZ szSiteProxy,
    /* [out] */ RPC_BOOL __RPC_FAR *pfValid,
    /* [out] */ RPC_SZ __RPC_FAR *pszSiteProxyCorrected);

			/* size is 4 */
RPC_SC __cdecl ScProxyReset( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_BOOL fWaitUntilCompleted);

#define		scNoError			0
#define		scInvalidData		1
#define		scCannotLogData		2
			/* size is 4 */
RPC_SC __cdecl ScSaveTrackingData( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_INT cb,
    /* [size_is][in] */ RPC_BYTE __RPC_FAR pb[  ],
    /* [in] */ RPC_DWORD dwFlags);

#define		tevtMessageTransferIn		0
#define		tevtReportTransferIn		2
#define		tevtMessageSubmission		4
#define		tevtMessageTransferOut		7
#define		tevtReportTransferOut		8
#define		tevtMessageDelivery			9
#define		tevtReportDelivery			10
#define		tevtStartAssocByMTSUser		18
#define		tevtReleaseAssocByMTSUser	23
#define		tevtDLExpansion				26
#define		tevtRedirection				28
#define		tevtRerouting				29
#define		tevtDowngrading				31
#define		tevtReportAbsorption		33
#define		tevtReportGenerated			34
#define		tevtUnroutableReportDiscard	43
#define		tevtMessageLocalDelivery		1000
#define		tevtMessageBackboneTransferIn	1001
#define		tevtMessageBackboneTransferOut	1002
#define		tevtMessageGatewayTransferOut	1003
#define		tevtMessageGatewayTransferIn	1004
#define		tevtReportGatewayTransferIn		1005
#define		tevtReportGatewayTransferOut	1006
#define		tevtReportGatewayGenerated		1007
#define		tevtUserMin		2000
			/* size is 60 */
typedef struct  __MIDL_TriggerPublicRPC_0005
    {
    RPC_INT nEventType;
    RPC_SYSTEMTIME stEvent;
    RPC_SZ szGatewayName;
    RPC_SZ szPartner;
    RPC_SZ szMTSID;
    RPC_SZ szRemoteID;
    RPC_SZ szOriginator;
    RPC_INT nPriority;
    RPC_INT nLength;
    RPC_INT nSeconds;
    RPC_INT nCost;
    RPC_SZ szSubjectID;
    }	RPC_GATEWAY_TRACK_INFORMATION;

			/* size is 4 */
RPC_SC __cdecl ScSaveGatewayTrackingData( 
    /* [in] */ handle_t h,
    /* [in] */ RPC_GATEWAY_TRACK_INFORMATION __RPC_FAR *pgti,
    /* [in] */ RPC_INT cszRecipients,
    /* [size_is][in] */ RPC_SZ __RPC_FAR rgszRecipients[  ]);



extern RPC_IF_HANDLE TriggerPublicRPC_ClientIfHandle;
extern RPC_IF_HANDLE TriggerPublicRPC_ServerIfHandle;
#endif /* __TriggerPublicRPC_INTERFACE_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0001
 * at Thu Apr 11 09:26:39 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define		szTrackReportRecipientInfoDelivered	L("\t0")
#define		szTrackReportRecipientInfoNonDelivered	L("\t1")


extern RPC_IF_HANDLE __MIDL__intf_0001_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL__intf_0001_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\sadapi.h ===
/*
 *	sadapi.h
 *
 *	Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *	Definition of the public RPC APIs from the SAD Exchange service
 *
 */


#ifndef _SADLIB_H_
#define _SADLIB_H_

#include "rpcpub.h"

#ifdef __cplusplus
extern "C"
{
#endif


/* 
 * Return codes for all functions except SAD_EcGetProxies() and SAD_EcGetProxiesBI().
 * In addition to this list are all normal NT error codes...
 */
typedef enum _SC_RETURN_VALUES
{
	SC_OK = 0,					// no error
	SC_Error = 49001,			// general error
	SC_BPActive,				// bulk proxy generation is currently running
	SC_BPInactive,				// bulk proxy generation is not currently running
	SC_BPShutdownPending,		// a shutdown in bulk proxy generation is in progress
	SC_BPSiteAddressMismatch,	// a Site Address Mismatch between rgszOldSiteAddress
								//   and rgszNewSiteAddress lists in ScBulkUpdateMultiProxy
} SC_RETURN_VALUES;


#define cchMaxServer		(MAX_COMPUTERNAME_LENGTH + 1)

typedef	struct _RPCBINDINFO
{
	handle_t 		h;
	WCHAR			wszServer[cchMaxServer];
	RPC_IF_HANDLE	hClientIfHandle;
} RPCBINDINFO, *PRPCBINDINFO;


//	Utility entry points
RPC_SC WINAPI SAD_ScBindA(PRPCBINDINFO pBI, LPSTR szServer);
RPC_SC WINAPI SAD_ScBindW(PRPCBINDINFO pBI, LPWSTR wszServer);
void WINAPI SAD_Unbind(PRPCBINDINFO pBI);

#ifdef UNICODE
#define	SAD_ScBind		SAD_ScBindW
#else
#define	SAD_ScBind		SAD_ScBindA
#endif



// Message Tracking group
RPC_SC WINAPI SAD_ScSaveGatewayTrackingData(PRPCBINDINFO pBI,
											RPC_GATEWAY_TRACK_INFORMATION *	pgti,
											INT	cszRecipients,
											LPWSTR	rgwszRecipients[]);

// for Microsoft Internal Use ONLY
RPC_SC WINAPI SAD_ScSaveTrackingData(PRPCBINDINFO pBI, INT cb, BYTE pb[], DWORD dwFlags);


// for Gateways - cause the routing table to be recalculated
RPC_SC WINAPI SAD_ScRunRIDA(LPSTR szServer);
RPC_SC WINAPI SAD_ScRunRIDW(LPWSTR wszServer);
RPC_SC WINAPI SAD_ScRunRIDExA(LPSTR szServer, RPC_BOOL fProxySpace, RPC_BOOL fGwart);
RPC_SC WINAPI SAD_ScRunRIDExW(LPWSTR wszServer, RPC_BOOL fProxySpace, RPC_BOOL fGwart);

#ifdef UNICODE
#define	SAD_ScRunRID		SAD_ScRunRIDW
#define	SAD_ScRunRIDEx		SAD_ScRunRIDExW
#else
#define	SAD_ScRunRID		SAD_ScRunRIDA
#define	SAD_ScRunRIDEx		SAD_ScRunRIDExA
#endif



//	Proxy Entry points

RPC_EC WINAPI SAD_EcGetProxies(LPWSTR wszServer, PPROXYINFO pProxyInfo, PPROXYLIST pProxyList);
RPC_EC WINAPI SAD_EcGetProxiesBI(PRPCBINDINFO pBI, PPROXYINFO pProxyInfo, PPROXYLIST pProxyList);
void   WINAPI SAD_FreeProxyListNode(PPROXYNODE pnode);
RPC_SC WINAPI SAD_ScIsProxyUniqueA(LPSTR szServer,
		LPSTR szProxy, RPC_BOOL * pfUnique, LPSTR * pszExisting);
RPC_SC WINAPI SAD_ScIsProxyUniqueW(LPWSTR wszServer,
		LPWSTR szProxy, RPC_BOOL * pfUnique, LPWSTR * pszExisting);

// dwOptions values for SAD_ScBulkCreateProxy() and SAD_ScBulkCreateMultiProxy()
#define		BPTAdd			1
#define		BPTRemove		2
#define		BPTUpdate		3

RPC_SC WINAPI SAD_ScBulkCreateProxyA(LPSTR szServer, LPSTR szHeader, DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateProxyW(LPWSTR wszServer, LPWSTR wszHeader, DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateMultiProxyA(LPSTR szServer,
										  INT cszHeader,
										  LPSTR rgszHeader[],
										  DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkCreateMultiProxyW(LPWSTR wszServer,
										  INT cwszHeader,
										  LPWSTR rgwszHeader[],
										  DWORD dwOptions);
RPC_SC WINAPI SAD_ScBulkUpdateMultiProxy(LPWSTR wszServer,
										 INT cwszSiteAddress,
										 LPWSTR rgwszOldSiteAddress[],
										 LPWSTR rgwszNewSiteAddress[],
										 RPC_BOOL fSaveSiteAddress);


RPC_SC WINAPI SAD_ScGetBulkProxyStatusA(LPSTR szServer,
									    RPC_SYSTEMTIME * pstTimeStart,
									    DWORD * pdwTimeStart,
									    DWORD * pdwTimeCur,
									    INT * piRecipients,
									    INT * pcRecipients);
RPC_SC WINAPI SAD_ScGetBulkProxyStatusW(LPWSTR wszServer,
										RPC_SYSTEMTIME * pstTimeStart,
									    DWORD * pdwTimeStart,
									    DWORD * pdwTimeCur,
									    INT * piRecipients,
									    INT * pcRecipients);
RPC_SC WINAPI SAD_ScBulkProxyHaltA(LPSTR szServer, RPC_BOOL fWaitForShutdown);
RPC_SC WINAPI SAD_ScBulkProxyHaltW(LPWSTR wszServer, RPC_BOOL fWaitForShutdown);

#ifdef UNICODE
#define	SAD_ScIsProxyUnique			SAD_ScIsProxyUniqueW
#define SAD_ScBulkCreateProxy		SAD_ScBulkCreateProxyW
#define SAD_ScBulkCreateMultiProxy	SAD_ScBulkCreateMultiProxyW
#define	SAD_ScGetBulkProxyStatus	SAD_ScGetBulkProxyStatusW
#define	SAD_ScBulkProxyHalt			SAD_ScBulkProxyHaltW
#else
#define	SAD_ScIsProxyUnique			SAD_ScIsProxyUniqueA
#define SAD_ScBulkCreateProxy		SAD_ScBulkCreateProxyA
#define SAD_ScBulkCreateMultiProxy	SAD_ScBulkCreateMultiProxyA
#define	SAD_ScGetBulkProxyStatus	SAD_ScGetBulkProxyStatusA
#define	SAD_ScBulkProxyHalt			SAD_ScBulkProxyHaltA
#endif






//	Backup entry point	(available only in UNICODE!)

RPC_SC WINAPI	SAD_ScGetBackupListNodeW(LPWSTR wszServer, BackupListNode ** ppnode);
void WINAPI		SAD_FreeBackupListNode(BackupListNode * pnode);


// Run DRA Check calling parameters (dwCheck)
#define INTRASITE_CHECK 0
#define INTERSITE_CHECK 1

RPC_SC WINAPI	SAD_ScRunDRACheck(LPWSTR wszServer, RPC_DWORD dwCheck);



// These few lines (or equivalent) need to be supplied by the application that links
// with SADAPI.LIB.
#ifdef _SAMPLE_CODE
void __RPC_FAR * __RPC_API midl_user_allocate(size_t cb)
{
	void *	pv;

	pv = GlobalAlloc(GMEM_FIXED, cb);
	if (!pv)
		RpcRaiseException(RPC_S_OUT_OF_MEMORY);

	return pv;
}

void __RPC_API midl_user_free(void __RPC_FAR * pv)
{
	GlobalFree(pv);
}
#endif







#ifdef __cplusplus
}
#endif

#endif		// #ifndef _SADLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\speckle.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Speckle.cpp : Defines the class behaviors for the application.

File History:

	JonY    Apr-96  created

--*/

#include "stdafx.h"
#include "Speckle.h"

#include "wizbased.h"
#include "welcome.h"
#include "prsinfo.h"
#include "pwinfo.h"
#include "userlist.h"
#include "ginfo.h"
#include "Profile.h"
#include "finish.h"
#include "RasPerm.h"
#include "FPInfo.h"
#include "Limit.h"
#include "Timelist.h"
#include "hours.h"
#include "AccExp.h"
#include "optdlg.h"
#include "Restrct.h"
#include "HomeDir.h"
#include "LScript.h"
#include "Exch.h"
#include "NWLim.h"

#include <fpnwcomm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TCHAR pszTreeEvent[] =  _T("TreeThread");
/////////////////////////////////////////////////////////////////////////////
// CSpeckleApp

BEGIN_MESSAGE_MAP(CSpeckleApp, CWinApp)
	//{{AFX_MSG_MAP(CSpeckleApp)
	//}}AFX_MSG
//      ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSpeckleApp construction

CSpeckleApp::CSpeckleApp()
{
	m_bLocal = 0; // local or remote
	m_dwExpirationDate = TIMEQ_FOREVER;
	*m_pHours = NULL;

	m_sNWAllowedGraceLogins = 0x6;
	m_sNWRemainingGraceLogins = 0xff;
	m_sNWConcurrentConnections = NO_LIMIT;
	m_csNWHomeDir = (TCHAR*)DEFAULT_NWHOMEDIR;
	m_csAllowedLoginFrom = (TCHAR*)DEFAULT_NWLOGONFROM;

	m_bDisabled = FALSE;
	m_bChange_Password = FALSE;
	m_bMust_Change_PW = FALSE;
	m_bPW_Never_Expires = FALSE;

	m_bExpiration = FALSE;
	m_bHours = FALSE;
	m_bNW = FALSE;
	m_bProfile = FALSE;
	m_bRAS = FALSE;
	m_bWorkstation = FALSE;
	m_bExchange = FALSE;
	m_bHomeDir = FALSE;
	m_bLoginScript = FALSE;
	m_bDisabled = FALSE;
	m_bEnableRestrictions = FALSE;

	m_sCallBackType = 0;

	m_bPRSReset = TRUE;
	m_bPWReset = TRUE;
	m_bGReset = TRUE;
}

CSpeckleApp::~CSpeckleApp()
{
// zero out the password before we leave.
	m_csPassword1 = L"";

}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSpeckleApp object

CSpeckleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSpeckleApp initialization
BOOL CSpeckleApp::IsSecondInstance()
{
    HANDLE hSem;

       //create a semaphore object with max count of 1
    hSem = CreateSemaphore(NULL, 0, 1, L"Adduser Wizard Semaphore");
    if (hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
	CloseHandle(hSem);
		CString csAppName;
		csAppName.LoadString(AFX_IDS_APP_TITLE);
	CWnd* pWnd = CWnd::FindWindow(NULL, (LPCTSTR)csAppName);

	if (pWnd)
	   pWnd->SetForegroundWindow();
	return TRUE;
    }

    return FALSE;
}

BOOL CSpeckleApp::InitInstance()
{
// check for OS version
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(os);
	GetVersionEx(&os);

	if (os.dwMajorVersion < 4) 
		{
		AfxMessageBox(IDS_BAD_VERSION, MB_ICONSTOP);
		ExitProcess(0);
		}
	if (IsSecondInstance())
	return FALSE;

	AfxEnableControlContainer();

	// Standard initialization

#ifdef _AFXDLL
	Enable3dControls();                     // Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif

// create the dialogs
	CWelcomeDlg* pWelcome = new CWelcomeDlg;
	CPersonalInfo* pInfo = new CPersonalInfo;
	CPasswordInfo* pPassword = new CPasswordInfo;
	CGroupInfo* pGroup = new CGroupInfo;
	CProfile* pProfile = new CProfile;
	CFinish* pFinish = new CFinish;
	CRasPerm* pRasP = new CRasPerm;
	CFPInfo* pFP = new CFPInfo;
	CLimitLogon* pLim = new CLimitLogon;
	CHoursDlg* pHours = new CHoursDlg;
	CAccExp* pExp = new CAccExp;
	COptionsDlg* pOpt = new COptionsDlg;
	CRestrictions* pRestrictions = new CRestrictions;
	CHomeDir* pHomeDir = new CHomeDir;
	CLoginScript* pLScript = new CLoginScript;
	CExch* pExch = new CExch;
	CNWLimitLogon* pNWLim = new CNWLimitLogon;

// create the property sheet and set 'wizmode'
	m_cps1.SetWizardMode();

// Add the dialogs
	m_cps1.AddPage(pWelcome);
	m_cps1.AddPage(pInfo);
	m_cps1.AddPage(pPassword);
	m_cps1.AddPage(pGroup);

	m_cps1.AddPage(pOpt);
	m_cps1.AddPage(pProfile);
	m_cps1.AddPage(pLScript);
	m_cps1.AddPage(pHomeDir);
	m_cps1.AddPage(pRasP);
	m_cps1.AddPage(pFP);

	m_cps1.AddPage(pExch);

	m_cps1.AddPage(pRestrictions);
	m_cps1.AddPage(pExp);
	m_cps1.AddPage(pHours);
	m_cps1.AddPage(pLim);
	m_cps1.AddPage(pNWLim);
	m_cps1.AddPage(pFinish);
	
// start the wizard
	m_cps1.DoModal();
	
// clean up
	delete pWelcome;
	delete pInfo;
	delete pPassword;
	delete pGroup;
	delete pProfile;
	delete pFinish;
	delete pRasP;
	delete pFP;
	delete pLim;
	delete pHours;
	delete pExp;
	delete pOpt;
	delete pRestrictions;
	delete pHomeDir;
	delete pLScript;
	delete pExch;
	delete pNWLim;

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CMySheet

IMPLEMENT_DYNAMIC(CMySheet, CPropertySheet)

CMySheet::CMySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CMySheet::CMySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CMySheet::CMySheet() : CPropertySheet()
{
}

CMySheet::~CMySheet()
{
}


BEGIN_MESSAGE_MAP(CMySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMySheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMySheet message handlers

BOOL CMySheet::OnInitDialog() 
{
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
	HICON hIcon = LoadIcon(pApp->m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));
	::SetClassLong(m_hWnd, GCL_HICON, (long)hIcon);
	
	return CPropertySheet::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\speckle.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Speckle.h : main header file for the SPECKLE application

File History:

	JonY	Apr-96	created

--*/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols


/////////////////////////////////////////////////////////////////////////////
// CMySheet

class CMySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMySheet)

// Construction
public:
	CMySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMySheet();

// Attributes
public:

// Operations
public:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMySheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSpeckleApp:
// See Speckle.cpp for the implementation of this class
//

typedef struct tagTREEINFO
{
	HTREEITEM	hTreeItem;
	DWORD		dwBufSize;
	CObject*	pTree;
	BOOL		bExpand;
}
TREEINFO, *PTREEINFO;

class CSpeckleApp : public CWinApp
{
public:
	CSpeckleApp();
	~CSpeckleApp();

	CMySheet m_cps1;
	BOOL IsSecondInstance();

	short m_bLocal;

// remote server name
	BOOL m_bDomain;
	BOOL m_bServer;
	CString m_csServer;
	int m_nGroupType;
	CString m_csCurrentDomain;
	CString m_csCurrentMachine;
	CString m_csDomain;

// account information
// password info
	BOOL	m_bChange_Password;
	BOOL	m_bMust_Change_PW;
	BOOL	m_bPW_Never_Expires;
	CString	m_csPassword1;

// personal info
	CString	m_csDescription;
	CString	m_csFullName;
	CString	m_csUserName;

// profile info
	CString	m_csLogonScript;  // usri3_script_path
	CString m_csProfilePath;  // usri3_profile

// homedir info
	CString m_csHomeDir;		 //	usri3_home_dir
	CString m_csHome_dir_drive;	 //	usri3_home_dir_drive

// group list
	CStringArray m_csaSelectedLocalGroups;
	CStringArray m_csaSelectedGlobalGroups;

// permitted machine list
	CString m_csAllowedMachines;

// Account expiration date (seconds since 1/1/1970 00:00:00)
	DWORD m_dwExpirationDate;

// time of availability
	BYTE m_pHours[21];

// NetWare params
	USHORT m_sNWAllowedGraceLogins;
	USHORT m_sNWConcurrentConnections;
	USHORT m_sNWRemainingGraceLogins;
	CString m_csNWHomeDir;
	CString m_csAllowedLoginFrom;

// RAS params;
	CString m_csRasPhoneNumber;
	USHORT m_sCallBackType;	  // 0- no call back 1- caller set 2-preset

// primary group ID
	DWORD m_dwPrimaryGroupID;

// Which windows to use
	BOOL	m_bExpiration;
	BOOL	m_bHours;
	BOOL	m_bNW;
	BOOL	m_bProfile;
	BOOL	m_bRAS;
	BOOL	m_bWorkstation;
	BOOL	m_bExchange;
	BOOL	m_bHomeDir;
	BOOL	m_bLoginScript;
	BOOL	m_bDisabled;

	BOOL	m_bEnableRestrictions;

// restarting the app?
	BOOL	m_bPRSReset;
	BOOL	m_bPWReset;
	BOOL	m_bGReset;

// Exchange server
	CString m_csExchangeServer;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSpeckleApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSpeckleApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    stdafx.h : header file

	stdafx.h : include file for standard system include files,
	or project specific include files that are used frequently, but
	are changed infrequently


File History:

	JonY    Apr-96  created

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>                     // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//#include <afxdisp.h>        // MFC OLE automation classes
#include <lmaccess.h>
#include <afxtempl.h>           // MFC template classes
#include <afxmt.h>                      // MFC synchronization classes
#include <afxctl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\transbmp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    transbmp.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

/////////////////////////////////////////////////////////////////////////////

class CTransBmp : public CBitmap
{
public:
    CTransBmp();
    ~CTransBmp();
    void Draw(HDC hDC, int x, int y);
    void Draw(CDC* pDC, int x, int y);
    void DrawTrans(HDC hDC, int x, int y);
    void DrawTrans(CDC* pDC, int x, int y);
    int GetWidth();
    int GetHeight();

private:
    int m_iWidth;
    int m_iHeight;
    CBitmap* m_hbmMask;    // handle to mask bitmap

    void GetMetrics();
    void CreateMask(HDC hDC);
	void CreateMask(CDC* pDC);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\trstlist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Trstlist.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/



#include <windows.h>
#include <lm.h>
#include <ntsecapi.h> // \mstools\security\ntsecapi.h
#include <tchar.h>

class CTrustList
{
	public:
		TCHAR** m_ppszTrustList;        // array of trust elements
		DWORD m_dwTrustCount;         // number of elements in m_ppszTrustList

		CTrustList();
		~CTrustList();

		BOOL BuildTrustList(LPTSTR Target);

	private:
		BOOL IsDomainController(LPTSTR Server,
			LPBOOL bDomainController);

		BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle);

		BOOL AddTrustToList(PLSA_UNICODE_STRING UnicodeString);

		//
		// helper functions
		//

		void InitLsaString(PLSA_UNICODE_STRING LsaString,
			LPTSTR String);

		NTSTATUS OpenPolicy(LPTSTR ServerName,
			DWORD DesiredAccess,
			PLSA_HANDLE PolicyHandle);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\timelist.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    TimesList.cpp : implementation file

File History:

	JonY	Apr-96	created

--*/


#include "stdafx.h"
#include "Speckle.h"
#include "TimeList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTimesList

CTimesList::CTimesList()
{
	
}

CTimesList::~CTimesList()
{
}


BEGIN_MESSAGE_MAP(CTimesList, CListBox)
	//{{AFX_MSG_MAP(CTimesList)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTimesList message handlers

void CTimesList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);

	USHORT dwValue = (USHORT)GetItemData(lpDrawItemStruct->itemID);

	switch (lpDrawItemStruct->itemAction)
		{
        case ODA_SELECT:
			{
			if (dwValue == 1)
				{
				SetItemData(lpDrawItemStruct->itemID, 0);
				InvalidateRect(&lpDrawItemStruct->rcItem);
				}
			else
				{
				SetItemData(lpDrawItemStruct->itemID, 1);
				InvalidateRect(&lpDrawItemStruct->rcItem);
				}
			}
			break;

        case ODA_DRAWENTIRE:
			if (dwValue == 0)
				{									  
				pDC->FillRect(&(lpDrawItemStruct->rcItem), 
					CBrush::FromHandle(CreateSolidBrush(GetSysColor(COLOR_CAPTIONTEXT)))); 
				
				pDC->DrawEdge(&lpDrawItemStruct->rcItem, 
					BDR_RAISEDOUTER | BDR_SUNKENINNER,
					BF_BOTTOM | BF_BOTTOMRIGHT);
				}
			else
				{
				pDC->FillRect(&(lpDrawItemStruct->rcItem), 
					CBrush::FromHandle(CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION))));

				pDC->DrawEdge(&lpDrawItemStruct->rcItem, 
					BDR_RAISEDINNER | BDR_SUNKENOUTER,
					BF_BOTTOM | BF_BOTTOMRIGHT);
				}
		break;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\userlist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    UserList.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/

#include "transbmp.h"
/////////////////////////////////////////////////////////////////////////////
// CUserList window

class CUserList : public CListBox
{
// Construction
public:
	CUserList();

// Attributes
public:
private:
	CTransBmp* m_pBitmap[4];
	unsigned short m_sHScrollWidth;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUserList)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int VKeyToItem(UINT nKey, UINT nIndex);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CUserList();
	int AddString(LPCTSTR lpItem);
	int AddString(short nType, LPCTSTR lpItem);
	int AddString(LPCTSTR lpItem, USHORT dwBitmap);
	short GetBitmapID();
	short GetBitmapID(USHORT sSel);

	// Generated message map functions
protected:
	//{{AFX_MSG(CUserList)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\userlist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    UserList.cpp

	CListBox class for owner draw list that displays users and groups

    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "resource.h"
#include "UserList.h"

const unsigned short BITMAP_HEIGHT = 18;
const unsigned short BITMAP_WIDTH = 18;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUserList

CUserList::CUserList()
{	 
	m_pBitmap[0] = new CTransBmp;
	m_pBitmap[0]->LoadBitmap(IDB_USER_BITMAP);

	m_pBitmap[1] = new CTransBmp;
	m_pBitmap[1]->LoadBitmap(IDB_GLOBAL_GROUP_BITMAP);

	m_pBitmap[2] = new CTransBmp;
	m_pBitmap[2]->LoadBitmap(IDB_WORLD);

	m_pBitmap[3] = new CTransBmp;
	m_pBitmap[3]->LoadBitmap(IDB_LOCAL_GROUP_BITMAP);

	m_sHScrollWidth = 0;
}

CUserList::~CUserList()
{
	delete m_pBitmap[0];
	delete m_pBitmap[1];
	delete m_pBitmap[2];
	delete m_pBitmap[3];

}


BEGIN_MESSAGE_MAP(CUserList, CListBox)
	//{{AFX_MSG_MAP(CUserList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUserList message handlers
void CUserList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
// is this a valid item?
	if ((GetCount() == LB_ERR) || (lpDrawItemStruct->itemID > (UINT)GetCount())) return;

	COLORREF crefOldText;
	COLORREF crefOldBk;

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	pDC->SetBkMode(TRANSPARENT);
 
	HBRUSH hBrush;
	CTransBmp* pTempBmp = (CTransBmp*)lpDrawItemStruct->itemData;

	switch (lpDrawItemStruct->itemAction)
		{
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
// Display the text associated with the item. 
			HBITMAP hBitmapOld;

// Is the item selected?
            if (lpDrawItemStruct->itemState & ODS_SELECTED)
				{
				hBrush = CreateSolidBrush( GetSysColor(COLOR_HIGHLIGHT));
                hBitmapOld = (HBITMAP)pDC->SelectObject(pTempBmp);
                
                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT) );
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT) );
				}
            else
				{
                hBrush = (HBRUSH)GetStockObject( GetSysColor(COLOR_WINDOW));
                hBitmapOld = (HBITMAP)pDC->SelectObject(pTempBmp);

                crefOldText = pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
                crefOldBk = pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
				
				}		  

			pDC->FillRect(&(lpDrawItemStruct->rcItem), CBrush::FromHandle(hBrush));

// display text
			TCHAR* pName = (TCHAR*)malloc(255 * sizeof(TCHAR));
			if (pName == NULL)
				{
				AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
				exit(1);
				}

			GetText(lpDrawItemStruct->itemID, pName);
			TCHAR* pName2;
			pName = _tcstok(pName, _T(";"));	 // gets the name
			pName2 = _tcstok(NULL, _T(";"));	// gets the comment

// format the name + comment
            int nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top) / 2;
            pDC->TextOut(BITMAP_WIDTH + 6,
                (nTop - 8),
                pName);

			pDC->TextOut(130,
				(nTop - 8),
                pName2);

			free(pName);

// Display bitmap
			nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top - BITMAP_HEIGHT) / 2;

			pTempBmp->DrawTrans(pDC, lpDrawItemStruct->rcItem.left,	nTop); 

			pDC->SetBkColor(crefOldBk );
            pDC->SetTextColor(crefOldText );
            pDC->SelectObject(hBitmapOld);
										 
            break;
		}

}
int CUserList::AddString(LPCTSTR lpItem)
{
	int nPos = CListBox::AddString((const TCHAR*) lpItem);
	if (nPos == LB_ERR) return LB_ERR;
	SetItemData(nPos, (unsigned long)m_pBitmap[1]); 

	return nPos;
}

int CUserList::AddString(LPCTSTR lpItem, USHORT usBitmapID)
{
	int nPos = CListBox::AddString((const TCHAR*) lpItem);
	if (nPos == LB_ERR) return LB_ERR;
	SetItemData(nPos, (DWORD)m_pBitmap[usBitmapID]); 

	return nPos;
}


void CUserList::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	lpMeasureItemStruct->itemHeight = 20;	
}


int CUserList::VKeyToItem(UINT nKey, UINT nIndex) 
{
	// TODO: Add your code to handle a particular virtual key
	// return -1 = default action
	// return -2 = no further action
	// return index = perform default action for keystroke on
	//                item specified by index

	if (nKey == 46) DeleteString(GetCurSel());
	return -1;
}

int CUserList::AddString(short nType, LPCTSTR lpItem)
{
	int nPos = CListBox::AddString((const TCHAR*) lpItem);
	if (nPos == LB_ERR) return LB_ERR;
	SetItemData(nPos, (DWORD)m_pBitmap[nType]); 

	return nPos;
}

short CUserList::GetBitmapID()
{
	USHORT sSel = GetCurSel();
	if (sSel == LB_ERR) return -1;
	USHORT sCount = 0;

	while ((sCount < 4) && ((CBitmap*)GetItemData(sSel) != m_pBitmap[sCount])) sCount++;
	return sCount;

}

short CUserList::GetBitmapID(USHORT sSel)
{
	USHORT sCount = 0;

	DWORD dwData = GetItemData(sSel);
	DWORD dwBmp =  (DWORD)m_pBitmap[0];
	while ((sCount < 4) && (dwData != dwBmp)) 
		{
		sCount++;
		dwBmp = (DWORD)m_pBitmap[sCount];
		}

	return sCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\trstlist.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disptrus.c(pp)

Author:

    Scott Field (sfield) 16-Mar-96

Revision:
	JonY	16-Apr-96	Modified to .cpp

--*/

#include "stdafx.h"
#include "trstlist.h"


#define RTN_OK 0
#define RTN_ERROR 13

//
// if you have the ddk, include ntstatus.h
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#endif


#define ELEMENT_COUNT 64    // number of array elements to allocate

CTrustList::CTrustList()
{
    m_dwTrustCount = 0;
    m_ppszTrustList = (LPWSTR *)HeapAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY,
        ELEMENT_COUNT * sizeof(LPWSTR)
        );
}

CTrustList::~CTrustList()
{
    //
    // free trust list
    //
	unsigned int i;
    for(i = 0 ; i < m_dwTrustCount ; i++) {
        if(m_ppszTrustList[i] != NULL)
            HeapFree(GetProcessHeap(), 0, m_ppszTrustList[i]);
    }

    HeapFree(GetProcessHeap(), 0, m_ppszTrustList);

}

BOOL
CTrustList::BuildTrustList(
    LPTSTR Target
    )
{
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;

    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain;
    BOOL bDC;
    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    //
    // open the policy on the specified machine
    //
    Status = OpenPolicy(
                Target,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if(Status != STATUS_SUCCESS) {
        SetLastError( LsaNtStatusToWinError(Status) );
        return FALSE;
    }

    //
    // obtain the AccountDomain, which is common to all three cases
    //
    Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (LPVOID*)&AccountDomain
                );

    if(Status != STATUS_SUCCESS)
        goto cleanup;

    //
    // Note: AccountDomain->DomainSid will contain binary Sid
    //
    AddTrustToList(&AccountDomain->DomainName);

    //
    // free memory allocated for account domain
    //
    LsaFreeMemory(AccountDomain);

    //
    // find out if the target machine is a domain controller
    //
    if(!IsDomainController(Target, &bDC)) {
        ////
        goto cleanup;
    }

    if(!bDC) {
        PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
        TCHAR* szPrimaryDomainName = NULL;
        TCHAR* DomainController = NULL;

        //
        // get the primary domain
        //
        Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyPrimaryDomainInformation,
                (LPVOID*)&PrimaryDomain
                );

        if(Status != STATUS_SUCCESS)
            goto cleanup;

        //
        // if the primary domain Sid is NULL, we are a non-member, and
        // our work is done.
        //
        if(PrimaryDomain->Sid == NULL) {
            LsaFreeMemory(PrimaryDomain);
            bSuccess = TRUE;
            goto cleanup;
        }

        AddTrustToList(&PrimaryDomain->Name);

        //
        // build a copy of what we just added.  This is necessary in order
        // to lookup the domain controller for the specified domain.
        // the Domain name must be NULL terminated for NetGetDCName(),
        // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
        // terminated.  Note that in a practical implementation, we
        // could just extract the element we added, since it ends up
        // NULL terminated.
        //

        szPrimaryDomainName = (LPTSTR)HeapAlloc(
            GetProcessHeap(), 0,
            PrimaryDomain->Name.Length + sizeof(WCHAR) // existing length + NULL
            );

        if(szPrimaryDomainName != NULL) {
            //
            // copy the existing buffer to the new storage, appending a NULL
            //
            _tcsncpy(
                szPrimaryDomainName,
                PrimaryDomain->Name.Buffer,
                (PrimaryDomain->Name.Length / 2) + 1
                );
        }

        LsaFreeMemory(PrimaryDomain);

        if(szPrimaryDomainName == NULL) goto cleanup;

        //
        // get the primary domain controller computer name
        //
        nas = NetGetDCName(
            NULL,
            szPrimaryDomainName,
            (LPBYTE *)&DomainController
            );

        HeapFree(GetProcessHeap(), 0, szPrimaryDomainName);

        if(nas != NERR_Success)
            goto cleanup;

        //
        // close the policy handle, because we don't need it anymore
        // for the workstation case, as we open a handle to a DC
        // policy below
        //
        LsaClose(PolicyHandle);
        PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

        //
        // open the policy on the domain controller
        //
        Status = OpenPolicy(
                    DomainController,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &PolicyHandle
                    );

        //
        // free the domaincontroller buffer
        //
        NetApiBufferFree(DomainController);

        if(Status != STATUS_SUCCESS)
            goto cleanup;
    }
				  
    //
    // build additional trusted domain(s) list and indicate if successful
    //
    bSuccess = EnumTrustedDomains(PolicyHandle);

cleanup:

    //
    // close the policy handle
    //
    if(PolicyHandle != INVALID_HANDLE_VALUE)
        LsaClose(PolicyHandle);

    if(!bSuccess) {
        if(Status != STATUS_SUCCESS)
            SetLastError( LsaNtStatusToWinError(Status) );
        else if(nas != NERR_Success)
            SetLastError( nas );
    }

    return bSuccess;
}

BOOL
CTrustList::EnumTrustedDomains(
    LSA_HANDLE PolicyHandle
    )
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // counter for items returned
    NTSTATUS Status;

    do {
        Status = LsaEnumerateTrustedDomains(
                        PolicyHandle,   // open policy handle
                        &lsaEnumHandle, // enumeration tracker
                        (LPVOID*)&TrustInfo,     // buffer to receive data
                        32000,          // recommended buffer size
                        &ulReturned     // number of items returned
                        );
        //
        // get out if an error occurred
        //
        if( (Status != STATUS_SUCCESS) &&
            (Status != STATUS_MORE_ENTRIES) &&
            (Status != STATUS_NO_MORE_ENTRIES)
            ) {
            SetLastError( LsaNtStatusToWinError(Status) );
            return FALSE;
        }

        //
        // Display results
        // Note: Sids are in TrustInfo[ulCounter].Sid
        //
        for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
            AddTrustToList(&TrustInfo[ulCounter].Name);

        //
        // free the buffer
        //
        LsaFreeMemory(TrustInfo);

    } while (Status != STATUS_NO_MORE_ENTRIES);

    return TRUE;
}

BOOL
CTrustList::IsDomainController(
    LPTSTR Server,
    LPBOOL bDomainController
    )
{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;

    nas = NetServerGetInfo(
        Server,
        101,    // info-level
        (LPBYTE *)&si101
        );

    if(nas != NERR_Success) {
        SetLastError(nas);
        return FALSE;
    }

    if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {
        //
        // we are dealing with a DC
        //
        *bDomainController = TRUE;
    } else {
        *bDomainController = FALSE;
    }

    NetApiBufferFree(si101);

    return TRUE;
}

BOOL
CTrustList::AddTrustToList(
    PLSA_UNICODE_STRING UnicodeString
    )
{
    if(m_dwTrustCount > ELEMENT_COUNT) return FALSE;

    //
    // allocate storage for array element
    //
    m_ppszTrustList[m_dwTrustCount] = (LPWSTR)HeapAlloc(
        GetProcessHeap(), 0,
        UnicodeString->Length + sizeof(WCHAR) // existing length + NULL
        );

    if(m_ppszTrustList[m_dwTrustCount] == NULL) return FALSE;

    //
    // copy the existing buffer to the new storage, appending a NULL
    //
    lstrcpynW(
        m_ppszTrustList[m_dwTrustCount],
        UnicodeString->Buffer,
        (UnicodeString->Length / 2) + 1
        );

    m_dwTrustCount++; // increment the trust count

    return TRUE;
}

void
CTrustList::InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPTSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = _tcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
}

NTSTATUS
CTrustList::OpenPolicy(
    LPTSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if(ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);

        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\timelist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    TimesList.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CTimesList window

class CTimesList : public CListBox
{
// Construction
public:
	CTimesList();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTimesList)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTimesList();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTimesList)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\transbmp.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

 // transbmp.cpp : implementation of the CTransBmp class
//
// support for transparent CBitmap objects. Used in the CUserList class.
// Based on a class from MSDN 7/95

	File History:

	JonY	Apr-96	created

--*/

#include "stdafx.h"
#include "transbmp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Colors
#define rgbWhite RGB(255,255,255)
// Raster op codes
#define DSa     0x008800C6L
#define DSx     0x00660046L


/////////////////////////////////////////////////////////////////////////////
// CTransBmp construction/destruction

CTransBmp::CTransBmp()
{
    m_iWidth = 0;
    m_iHeight = 0;
	m_hbmMask = NULL;
}

CTransBmp::~CTransBmp()
{
	if (m_hbmMask != NULL) delete m_hbmMask;
}

void CTransBmp::GetMetrics()
{
    // Get the width and height
    BITMAP bm;
    GetObject(sizeof(bm), &bm);
    m_iWidth = bm.bmWidth;
    m_iHeight = bm.bmHeight;
}


int CTransBmp::GetWidth()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iWidth;
}

int CTransBmp::GetHeight()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iHeight;
}


void CTransBmp::CreateMask(CDC* pDC)
{
	m_hbmMask = new CBitmap;    
// Nuke any existing mask
    if (m_hbmMask) m_hbmMask->DeleteObject();

// Create memory DCs to work with
	CDC* hdcMask = new CDC;
	CDC* hdcImage = new CDC;

    hdcMask->CreateCompatibleDC(pDC);
    hdcImage->CreateCompatibleDC(pDC);

// Create a monochrome bitmap for the mask
    m_hbmMask->CreateBitmap(GetWidth(),
                               GetHeight(),
                               1,
                               1,
                               NULL);
	CBitmap* pTempBmp;
// Select the mono bitmap into its DC
    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);
// Select the image bitmap into its DC
    CBitmap* hbmOldImage = hdcImage->SelectObject(pTempBmp->FromHandle((HBITMAP)m_hObject));

// Set the transparency color to be the top-left pixel
    hdcImage->SetBkColor(hdcImage->GetPixel(0, 0));
// Make the mask
    hdcMask->BitBlt(0, 0,
             GetWidth(), GetHeight(),
             hdcImage,
             0, 0,
             SRCCOPY);
// clean up
    hdcMask->SelectObject(hbmOldMask);
    hdcImage->SelectObject(hbmOldImage);
    delete hdcMask;
    delete hdcImage;
}

// draw the transparent bitmap using the created mask
void CTransBmp::DrawTrans(CDC* pDC, int x, int y)
{
   if (m_hbmMask == NULL) CreateMask(pDC);

    int dx = GetWidth();
    int dy = GetHeight();

// Create a memory DC to do the drawing to
	CDC* hdcOffScr = new CDC;
	hdcOffScr->CreateCompatibleDC(pDC);

// Create a bitmap for the off-screen DC that is really
// color compatible with the destination DC.
	CBitmap hbmOffScr;
	hbmOffScr.CreateBitmap(dx, dy, 
						pDC->GetDeviceCaps(PLANES),
						pDC->GetDeviceCaps(BITSPIXEL),
						NULL);
                             
// Select the buffer bitmap into the off-screen DC
    HBITMAP hbmOldOffScr = (HBITMAP)hdcOffScr->SelectObject(hbmOffScr);

// Copy the image of the destination rectangle to the
// off-screen buffer DC so we can play with it
    hdcOffScr->BitBlt(0, 0, dx, dy, pDC, x, y, SRCCOPY);

// Create a memory DC for the source image
	CDC* hdcImage = new CDC;
	hdcImage->CreateCompatibleDC(pDC);

    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

    // Create a memory DC for the mask
    CDC* hdcMask = new CDC;
	hdcMask->CreateCompatibleDC(pDC);

    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);

    // XOR the image with the destination
    hdcOffScr->SetBkColor(rgbWhite);
    hdcOffScr->BitBlt(0, 0, dx, dy ,hdcImage, 0, 0, DSx);
    // AND the destination with the mask
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcMask, 0,0, DSa);
    // XOR the destination with the image again
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcImage, 0, 0, DSx);

    // Copy the resultant image back to the screen DC
    pDC->BitBlt(x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

    // Tidy up
    hdcOffScr->SelectObject(hbmOldOffScr);
    hdcImage->SelectObject(hbmOldImage);
    hdcMask->SelectObject(hbmOldMask);

	delete hdcOffScr;
	delete hdcImage;
	delete hdcMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\wizbased.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    WizBaseD.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/


/////////////////////////////////////////////////////////////////////////////
// CWizBaseDlg dialog

class CWizBaseDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CWizBaseDlg)

// Construction
public:
	CWizBaseDlg();
	CWizBaseDlg(short sIDD);
	~CWizBaseDlg();

public:
// base class paint fn for space on left side of dialog
	void SetButtonAccess(short sFlags);

// Dialog Data
	//{{AFX_DATA(CWizBaseDlg)
	enum { IDD = IDD_BASE_DIALOG };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizBaseDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizBaseDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hours.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// Hours.h : main header file for HOURS.DLL

File History:

	JonY    May-96  created

--*/



#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHoursApp : See Hours.cpp for implementation.

class CHoursApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hours.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Hours.cpp : Defines the class behaviors for the application.

File History:

	JonY    May-96  created

--*/



#include "stdafx.h"
#include "Hours.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CHoursApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xa44ea7aa, 0x9d58, 0x11cf, { 0xa3, 0x5f, 0, 0xaa, 0, 0xb6, 0x74, 0x3b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CHoursApp::InitInstance - DLL initialization

BOOL CHoursApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CHoursApp::ExitInstance - DLL termination

int CHoursApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\welcome.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    WelcomeDlg.cpp

	CPropertyPage support for User management wizard

    FILE HISTORY:
        jony     Apr-1996     created
*/

#include "stdafx.h"
#include "Speckle.h"
#include "wizbased.h"
#include "Welcome.h"
#include "trstlist.h"

#include <winreg.h>
#include <lmerr.h>
#include <lmapibuf.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWelcomeDlg property page

IMPLEMENT_DYNCREATE(CWelcomeDlg, CWizBaseDlg)

CWelcomeDlg::CWelcomeDlg() : CWizBaseDlg(CWelcomeDlg::IDD)
{
	//{{AFX_DATA_INIT(CWelcomeDlg)
	//}}AFX_DATA_INIT

	m_pFont = NULL;
}

CWelcomeDlg::~CWelcomeDlg()
{
	if (m_pFont != NULL) delete m_pFont;
}

void CWelcomeDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWelcomeDlg)
	DDX_Control(pDX, IDC_DOMAIN_LIST, m_cbDomainList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWelcomeDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CWelcomeDlg)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomeDlg message handlers
BOOL CWelcomeDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();
// read cached domain list from registry
	DWORD dwRet;
	HKEY hKey;
	DWORD cbProv = 0;
	TCHAR* lpProv = NULL;

	BOOL bFoundOne = FALSE;

	long lRet = RegConnectRegistry(
		(LPTSTR)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength()), 
		HKEY_LOCAL_MACHINE,
		&hKey);
	
    dwRet = RegOpenKey(hKey,
		TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), &hKey );

	TCHAR* lpPrimaryDomain = NULL;
	if ((dwRet = RegQueryValueEx( hKey, TEXT(/*"CachePrimaryDomain"*/"DefaultDomainName"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpPrimaryDomain = (TCHAR*)malloc(cbProv);
		if (lpPrimaryDomain == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			ExitProcess(1);
			}
		dwRet = RegQueryValueEx( hKey, TEXT(/*"CachePrimaryDomain"*/"DefaultDomainName"), NULL, NULL, (LPBYTE) lpPrimaryDomain, &cbProv );
		bFoundOne = TRUE;
		}

	m_csPrimaryDomain = lpPrimaryDomain;
	free(lpPrimaryDomain);
	RegCloseKey(hKey);

	CString csMachineName;
	DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
	GetComputerName(csMachineName.GetBufferSetLength(MAX_COMPUTERNAME_LENGTH + 1), &dwSize);

	pApp->m_csCurrentMachine = csMachineName;

// read the list of trusted domains
	CTrustList pList;
	if (!pList.BuildTrustList((LPTSTR)pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength()))) 
		{					 
/* if this fails its probably because they are running the wizard 
	from a machine account that doesn't exist on the domain level. 
	Add only the local machine and select it.*/
		m_cbDomainList.AddString(pApp->m_csCurrentMachine);
		m_cbDomainList.SelectString(-1, pApp->m_csCurrentMachine);
		}

	else
		{
		UINT i;
		for(i = 0 ; i < pList.m_dwTrustCount ; i++)
			m_cbDomainList.AddString(pList.m_ppszTrustList[i]);

// remove the current machine from the list
//	if ((i = m_cbDomainList.FindStringExact(-1, pApp->m_csCurrentMachine)) != LB_ERR)
//		m_cbDomainList.DeleteString(i);

// now select the default domain into view
		int nSel = m_cbDomainList.SelectString(-1, m_csPrimaryDomain);
		m_cbDomainList.GetWindowText(m_csDomain);
		UpdateData(FALSE);	 
		}

// welcome text
	m_pFont = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  
	_tcscpy(lf.lfFaceName, L"MS Sans Serif");  
	lf.lfWeight = 700;
	m_pFont->CreateFontIndirect(&lf);    // Create the font.

	CString cs;
	cs.LoadString(IDS_WELCOME_STRING);
	CWnd* pWnd = GetDlgItem(IDC_STATIC1);
	pWnd->SetWindowText(cs);
	pWnd->SetFont(m_pFont);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CWelcomeDlg::OnWizardNext()
{
	UpdateData(TRUE);
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

// get the DC of the selected domain
	m_cbDomainList.GetWindowText(m_csDomain);

// same as last time? no need to check again.
	if (m_csLastDomain == m_csDomain) return CPropertyPage::OnWizardNext();

	CWaitCursor wait;

	pApp->m_csDomain = m_csDomain;
	pApp->m_bDomain = FALSE;
	TCHAR* pDomain = m_csDomain.GetBuffer(m_csDomain.GetLength());
	m_csDomain.ReleaseBuffer();	

	TCHAR* pDC;
	NET_API_STATUS nApi;

// local machine?
	if (m_csDomain == pApp->m_csCurrentMachine)
		{
		pApp->m_csServer = CString(L"\\\\") + pApp->m_csCurrentMachine;
		pDC = pApp->m_csServer.GetBuffer(pApp->m_csServer.GetLength());
		}

	else
		{
		nApi = NetGetDCName(NULL, 
			pDomain, 
			(LPBYTE*)&pDC);

		if (nApi != NERR_Success)
			{
			AfxMessageBox(IDS_NODC, MB_ICONSTOP);
			return -1;
			}
		pApp->m_csServer = pDC;
		pApp->m_bDomain = TRUE;
		}

// we really shouldn't proceed until we know we are an admin on the remote machine
	BYTE sidBuffer[100];
	PSID pSID = (PSID)&sidBuffer;
	BOOL bRet;		
					 
// create a SID for the Administrators group
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	bRet = AllocateAndInitializeSid(&SIDAuth,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		&pSID);

	if (!bRet) 
		{
		DWORD dw = GetLastError();
		ASSERT(0);
		}

	TCHAR pName[256];
	DWORD dwNameLen = 256;
	TCHAR pDomainName[256];
	DWORD dwDomainNameLen = 256;
	SID_NAME_USE SNU;

	bRet = LookupAccountSid(pDC,
		pSID,
		pName,
		&dwNameLen,
		pDomainName,
		&dwDomainNameLen,
		&SNU);

// get the users name and domain from the reg for comparison
	DWORD dwRet;							   
	HKEY hKey;
	DWORD cbProv = 0;

	CString csUsername;
	CString csDomainName;
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE,
		TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), &hKey );
	
	if ((dwRet = RegQueryValueEx( hKey, TEXT("DefaultDomainName"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		dwRet = RegQueryValueEx( hKey, TEXT("DefaultDomainName"), 
			NULL, 
			NULL, 
			(LPBYTE)csDomainName.GetBufferSetLength(cbProv), 
			&cbProv );
		}

	TCHAR* lpDefaultUserName = NULL;
	if ((dwRet = RegQueryValueEx( hKey, TEXT("DefaultUserName"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		dwRet = RegQueryValueEx( hKey, TEXT("DefaultUserName"), 
			NULL, 
			NULL, 
			(LPBYTE)csUsername.GetBufferSetLength(cbProv), 
			&cbProv );
		}

	RegCloseKey(hKey);

// now enumerate the members of the admin group to see if we are a member
	BOOL bAdmin = FALSE;
	PLOCALGROUP_MEMBERS_INFO_1 pMembers;
	DWORD dwEntriesRead, dwTotalEntries;
	DWORD dwResumeHandle = 0;
	nApi = NetLocalGroupGetMembers(pDC,
		pName,
		1,
		(LPBYTE*)&pMembers,
		5000,
		&dwEntriesRead,
		&dwTotalEntries,
		&dwResumeHandle);

	if (nApi == NERR_Success)
		{
		USHORT sIndex = 0;
		while (sIndex < dwEntriesRead)	
			{
			TCHAR pName[50];
			DWORD dwNameSize = 50;
			TCHAR pDomain[50];
			DWORD dwDomainNameSize = 50;
			SID_NAME_USE pUse;
			LookupAccountSid(pDC, pMembers[sIndex].lgrmi1_sid,
				pName, &dwNameSize,
				pDomain, &dwDomainNameSize,
				&pUse);
			
			if (((pUse == SidTypeGroup) && (bParseGlobalGroup(pName, csUsername, csDomainName))) ||
				((!csUsername.CompareNoCase(pName)) && (!csDomainName.CompareNoCase(pDomain)))) 
				{
				bAdmin = TRUE;
				break;
				}

			sIndex++;
			}

		NetApiBufferFree(pMembers);

		while ((dwResumeHandle != 0) && (!bAdmin))
			{
			nApi = NetLocalGroupGetMembers(pDC,
				pName,
				1,
				(LPBYTE*)&pMembers,
				5000,
				&dwEntriesRead,
				&dwTotalEntries,
				&dwResumeHandle);

			if (nApi == NERR_Success)
				{
				USHORT sIndex = 0;
				while (sIndex < dwEntriesRead)
					{
					TCHAR pName[50];
					DWORD dwNameSize = 50;
					TCHAR pDomain[50];
					DWORD dwDomainNameSize = 50;
					SID_NAME_USE pUse;
					LookupAccountSid(pDC, pMembers[sIndex].lgrmi1_sid,
						pName, &dwNameSize,
						pDomain, &dwDomainNameSize,
						&pUse);
					
					if (((pUse == SidTypeGroup) && (bParseGlobalGroup(pName, csUsername, csDomainName))) ||
						((!csUsername.CompareNoCase(pName)) && (!csDomainName.CompareNoCase(pDomain)))) 
						{
						bAdmin = TRUE;
						break;
						}

					sIndex++;
					}
				}
			NetApiBufferFree(pMembers);
			}
		}
			  
	if (!bAdmin) // not in the administrators group - check the account ops group
		{
		BYTE sidBuffer[100];
		PSID pSID = (PSID)&sidBuffer;
		BOOL bRet;		

// create a SID for the Account Operators group
		SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
		bRet = AllocateAndInitializeSid(&SIDAuth,
			2,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ACCOUNT_OPS,
			0,
			0,
			0,
			0,
			0,
			0,
			&pSID);

		if (!bRet) 
			{
			DWORD dw = GetLastError();
			ASSERT(0);
			}

		TCHAR pName[256];
		DWORD dwNameLen = 256;
		TCHAR pDomainName[256];
		DWORD dwDomainNameLen = 256;
		SID_NAME_USE SNU;

		bRet = LookupAccountSid(pDC,
			pSID,
			pName,
			&dwNameLen,
			pDomainName,
			&dwDomainNameLen,
			&SNU);

// now enumerate the members of the group to see if we are a member
		PLOCALGROUP_MEMBERS_INFO_1 pMembers;
		DWORD dwEntriesRead, dwTotalEntries;
		DWORD dwResumeHandle = 0;
		nApi = NetLocalGroupGetMembers(pDC,
			pName,
			1,
			(LPBYTE*)&pMembers,
			5000,
			&dwEntriesRead,
			&dwTotalEntries,
			&dwResumeHandle);

		if (nApi == NERR_Success)
			{
			USHORT sIndex = 0;
			while (sIndex < dwEntriesRead)	
				{
				TCHAR pName[50];
				DWORD dwNameSize = 50;
				TCHAR pDomain[50];
				DWORD dwDomainNameSize = 50;
				SID_NAME_USE pUse;
				LookupAccountSid(pDC, pMembers[sIndex].lgrmi1_sid,
					pName, &dwNameSize,
					pDomain, &dwDomainNameSize,
					&pUse);
				
				if (((pUse == SidTypeGroup) && (bParseGlobalGroup(pName, csUsername, csDomainName))) ||
					((!csUsername.CompareNoCase(pName)) && (!csDomainName.CompareNoCase(pDomain)))) 
					{
					bAdmin = TRUE;
					break;
					}

				sIndex++;
				}

			NetApiBufferFree(pMembers);

			while ((dwResumeHandle != 0) && (!bAdmin))
				{
				nApi = NetLocalGroupGetMembers(pDC,
					pName,
					1,
					(LPBYTE*)&pMembers,
					5000,
					&dwEntriesRead,
					&dwTotalEntries,
					&dwResumeHandle);

				if (nApi == NERR_Success)
					{
					USHORT sIndex = 0;
					while (sIndex < dwEntriesRead)
						{
						TCHAR pName[50];
						DWORD dwNameSize = 50;
						TCHAR pDomain[50];
						DWORD dwDomainNameSize = 50;
						SID_NAME_USE pUse;
						LookupAccountSid(pDC, pMembers[sIndex].lgrmi1_sid,
							pName, &dwNameSize,
							pDomain, &dwDomainNameSize,
							&pUse);
						
						if (((pUse == SidTypeGroup) && (bParseGlobalGroup(pName, csUsername, csDomainName))) ||
							((!csUsername.CompareNoCase(pName)) && (!csDomainName.CompareNoCase(pDomain)))) 
							{
							bAdmin = TRUE;
							break;
							}

						sIndex++;
						}
					}
				NetApiBufferFree(pMembers);
				}
			}

		}

// not an admin? don't continue
	if (!bAdmin)
		{
		AfxMessageBox(IDS_NOT_ADMIN);
		return -1;
		}

// store the domain name for a possible rerun.
	m_csLastDomain = m_csDomain;
		
	return CPropertyPage::OnWizardNext();

}	

// this gets called to look into a global group which is included in the admin or account ops local group.
// these groups live on the DC of the domain passed in.
BOOL CWelcomeDlg::bParseGlobalGroup(LPTSTR lpGroupName, CString& lpName, CString& lpDomain)
{
	DWORD dwEntriesRead;
	DWORD dwTotalEntries;
	DWORD dwResumeHandle = 0;
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	TCHAR* pDomain = lpDomain.GetBuffer(lpDomain.GetLength());
	lpDomain.ReleaseBuffer();	

	TCHAR* pServer;
	NET_API_STATUS nApi = NetGetDCName(NULL, 
		pDomain, 
		(LPBYTE*)&pServer);

	if (nApi != NERR_Success)
		{
		AfxMessageBox(IDS_NODC, MB_ICONSTOP);
		return FALSE;
		}
	
	PGROUP_USERS_INFO_1 pMembers;
	nApi = NetGroupGetUsers(pServer,
		lpGroupName,
		1,
		(LPBYTE*)&pMembers,
		5000,
		&dwEntriesRead,
		&dwTotalEntries, 
		&dwResumeHandle);

	if (nApi != ERROR_SUCCESS) 
		{
		NetApiBufferFree(pServer);
		return FALSE;
		}

	USHORT sIndex;
	for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
		{
		if (!lpName.CompareNoCase(pMembers[sIndex].grui1_name)) 
			{
			NetApiBufferFree(pServer);
			return TRUE;
			}
		}

	while (dwResumeHandle != 0)
		{
		nApi = NetGroupGetUsers(pServer,
			lpGroupName,
			1,
			(LPBYTE*)&pMembers,
			5000,
			&dwEntriesRead,
			&dwTotalEntries, 
			&dwResumeHandle);

		if (nApi != ERROR_SUCCESS) 
			{
			NetApiBufferFree(pServer);
			return FALSE;
			}

		for (sIndex = 0; sIndex < dwEntriesRead; sIndex++)
			{
			if (!lpName.CompareNoCase(pMembers[sIndex].grui1_name)) 
				{
				NetApiBufferFree(pServer);
				return TRUE;
				}
			}
		}

	NetApiBufferFree(pServer);
	return FALSE;
}


void CWelcomeDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CPropertyPage::OnShowWindow(bShow, nStatus);
	
	CSpeckleApp* pApp = (CSpeckleApp*)AfxGetApp();

	if (bShow) pApp->m_cps1.SetWizardButtons(PSWIZB_NEXT);
	else pApp->m_cps1.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\wizbased.cpp ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991-1996              **/
/**********************************************************************/

/*
    WizBaseD.cpp

	CPropertyPage support for User management wizard

    FILE HISTORY:
        jony     Apr-1996     created
*/


#include "stdafx.h"
#include "Speckle.h"
#include "WizBaseD.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizBaseDlg property page

IMPLEMENT_DYNCREATE(CWizBaseDlg, CPropertyPage)

CWizBaseDlg::CWizBaseDlg() : CPropertyPage(CWizBaseDlg::IDD)
{
	//{{AFX_DATA_INIT(CWizBaseDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWizBaseDlg::~CWizBaseDlg()
{
}

CWizBaseDlg::CWizBaseDlg(short sIDD) : CPropertyPage(sIDD)
{

}

void CWizBaseDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWizBaseDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizBaseDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CWizBaseDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizBaseDlg message handlers
void CWizBaseDlg::SetButtonAccess(short sFlags)
{
	CPropertySheet* cp = (CPropertySheet*)GetParent();
	cp->SetWizardButtons(sFlags);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\addusrw\welcome.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    WelcomeDlg.h : header file

  CPropertyPage support for User mgmt wizard

File History:

	JonY	Apr-96	created

--*/



/////////////////////////////////////////////////////////////////////////////
// CWelcomeDlg dialog

class CWelcomeDlg : public CWizBaseDlg
{
	DECLARE_DYNCREATE(CWelcomeDlg)

// Construction
public:
	CWelcomeDlg();
	~CWelcomeDlg();

// Dialog Data
	//{{AFX_DATA(CWelcomeDlg)
	enum { IDD = IDD_WELCOME_DIALOG };
	CComboBox	m_cbDomainList;
	//}}AFX_DATA
	virtual LRESULT OnWizardNext();

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWelcomeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWelcomeDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	CString m_csPrimaryDomain;
	CString m_csDomain;
	CFont* m_pFont;
	CString m_csLastDomain;
	BOOL bParseGlobalGroup(LPTSTR lpGroupName, CString& lpName, CString& lpDomain);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hoursctl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// HoursCtl.h : Declaration of the CHoursCtrl OLE control class.

File History:

	JonY    May-96  created

--*/

/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl : See HoursCtl.cpp for implementation.

class CHoursCtrl : public COleControl 
{
	DECLARE_DYNCREATE(CHoursCtrl)

// Constructor
public:
	CHoursCtrl();

// Overrides

	// Drawing function
	virtual void OnDraw(
				CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

	// Persistence
	virtual void DoPropExchange(CPropExchange* pPX);

	// Reset control state
	virtual void OnResetState();

	virtual BOOL PreTranslateMessage(LPMSG lpmsg);

private:
	CFont* m_pFont;

	struct 
		{
		USHORT x;
		USHORT y;
		USHORT cx;
		USHORT cy;
		BOOL bVal;	  // TRUE = access allowed (default)
		BOOL bSelected;
		USHORT row;
		USHORT col;
		} m_sCell[202];  // 169 cells + 7 days + 24 hours + 1 big

	CString csDay[7];

	CPoint pointDrag;
	USHORT GetCellID(CPoint point);
	void InvalidateCell(USHORT sCellID);

public:
	short m_sCurrentCol;
	short m_sCurrentRow;
						
	short m_sCurrentLoc();
	void Click(CPoint point);

	void ToggleDay(UINT nID);
	void ToggleCol(UINT nID);
	void OnBigButton();
	BOOL bToggle;

// Implementation
protected:
	~CHoursCtrl();

	DECLARE_OLECREATE_EX(CHoursCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CHoursCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CHoursCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CHoursCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CHoursCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CHoursCtrl)
	OLE_COLOR m_crPermitColor;
	afx_msg void OnCrPermitColorChanged();
	OLE_COLOR m_crDenyColor;
	afx_msg void OnCrDenyColorChanged();
	afx_msg VARIANT GetDateData();
	afx_msg void SetDateData(const VARIANT FAR& newValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CHoursCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CHoursCtrl)
	dispidCrPermitColor = 1L,
	dispidCrDenyColor = 2L,
	dispidDateData = 3L,
	//}}AFX_DISP_ID
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hoursctl.cpp ===
// HoursCtl.cpp : Implementation of the CHoursCtrl OLE control class.

#include "stdafx.h"
#include "Hours.h"
#include "HoursCtl.h"
#include "HoursPpg.h"

#include <time.h>
#include <sys\timeb.h>

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHoursCtrl, COleControl)

//#ifdef DBCS
// For localization
// We hate hardcord resource
// V-HIDEKK 1996.09.23
USHORT CONTROL_WIDTH = 375;
USHORT CONTROL_HEIGHT = 163;
USHORT DAY_BUTTON_WIDTH = 83;
USHORT HOUR_BUTTON_HEIGHT = 20;

USHORT CELL_WIDTH = ((CONTROL_WIDTH - DAY_BUTTON_WIDTH) / 24);
USHORT CELL_HEIGHT = ((CONTROL_HEIGHT - HOUR_BUTTON_HEIGHT) / 7);
/*
#else
const USHORT CONTROL_WIDTH = 375;
const USHORT CONTROL_HEIGHT = 163;
const USHORT DAY_BUTTON_WIDTH = 83;
const USHORT HOUR_BUTTON_HEIGHT = 20;

const USHORT CELL_WIDTH = ((CONTROL_WIDTH - DAY_BUTTON_WIDTH) / 24);
const USHORT CELL_HEIGHT = ((CONTROL_HEIGHT - HOUR_BUTTON_HEIGHT) / 7);
#endif
*/
/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHoursCtrl, COleControl)
	//{{AFX_MSG_MAP(CHoursCtrl)
	ON_WM_CREATE()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map									VT_ARRAY

BEGIN_DISPATCH_MAP(CHoursCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CHoursCtrl)
	DISP_PROPERTY_NOTIFY(CHoursCtrl, "crPermitColor", m_crPermitColor, OnCrPermitColorChanged, VT_COLOR)
	DISP_PROPERTY_NOTIFY(CHoursCtrl, "crDenyColor", m_crDenyColor, OnCrDenyColorChanged, VT_COLOR)
	DISP_PROPERTY_EX(CHoursCtrl, "DateData", GetDateData, SetDateData, VT_VARIANT)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CHoursCtrl, COleControl)
	//{{AFX_EVENT_MAP(CHoursCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CHoursCtrl, 1)
	PROPPAGEID(CHoursPropPage::guid)
END_PROPPAGEIDS(CHoursCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHoursCtrl, "HOURS.HoursCtrl.1",
	0xa44ea7ad, 0x9d58, 0x11cf, 0xa3, 0x5f, 0, 0xaa, 0, 0xb6, 0x74, 0x3b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CHoursCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DHours =
		{ 0xa44ea7ab, 0x9d58, 0x11cf, { 0xa3, 0x5f, 0, 0xaa, 0, 0xb6, 0x74, 0x3b } };
const IID BASED_CODE IID_DHoursEvents =
		{ 0xa44ea7ac, 0x9d58, 0x11cf, { 0xa3, 0x5f, 0, 0xaa, 0, 0xb6, 0x74, 0x3b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwHoursOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CHoursCtrl, IDS_HOURS, _dwHoursOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::CHoursCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CHoursCtrl

BOOL CHoursCtrl::CHoursCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_HOURS,
			IDB_HOURS,
		/*	afxRegApartmentThreading,  */0,
			_dwHoursOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::CHoursCtrl - Constructor

CHoursCtrl::CHoursCtrl()
{
	InitializeIIDs(&IID_DHours, &IID_DHoursEvents);
						 
// regular font
	m_pFont = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.

//#ifdef DBCS
        // for localize
        // V-HIDEKK 1996.09.23
	CString csFontName,csFontSize;
	csFontName.LoadString(IDS_STR_FONTNAME);
	csFontSize.LoadString(IDS_STR_FONTSIZE);
        lf.lfHeight = _ttoi(csFontSize.GetBuffer(0));
	_tcscpy(lf.lfFaceName, csFontName.GetBuffer(0));
/*
#else
	lf.lfHeight = 15;                  
	_tcscpy(lf.lfFaceName, TEXT("Arial"));  
#endif
*/
	lf.lfWeight = 100;
	m_pFont->CreateFontIndirect(&lf);    // Create the font.

// create the individual 'cells' (m_sCells)
	USHORT x, y;
	x = HOUR_BUTTON_HEIGHT;
	y = DAY_BUTTON_WIDTH;

	CRect crOuter;
	USHORT sCount = 1;
	USHORT sRow = 1;
	USHORT sCol = 1;

	for (x = DAY_BUTTON_WIDTH; (x + CELL_WIDTH) < CONTROL_WIDTH; x += CELL_WIDTH)
		{
		for (y = HOUR_BUTTON_HEIGHT; (y + CELL_HEIGHT) < CONTROL_HEIGHT; y += CELL_HEIGHT)
			{
			m_sCell[sCount].x = x;
			m_sCell[sCount].y = y;
			m_sCell[sCount].cx = x + CELL_WIDTH + 1;
			m_sCell[sCount].cy = y + CELL_HEIGHT + 1;

			m_sCell[sCount].bVal = TRUE;
			m_sCell[sCount].row = sRow;
			m_sCell[sCount].col = sCol;
			m_sCell[sCount].bSelected = FALSE;
			sCount++;
			sRow++;
			}
		sRow = 1;
		sCol++;
		}

// create the buttons
	// start with the days
	y = HOUR_BUTTON_HEIGHT;
	sRow = 0;

	while (sCount < 176)
		{
		m_sCell[sCount].x = 2;
		m_sCell[sCount].y = y;
		m_sCell[sCount].cx = m_sCell[sCount].x + DAY_BUTTON_WIDTH;
		m_sCell[sCount].cy = y + CELL_HEIGHT;
		m_sCell[sCount].bVal = TRUE;
		m_sCell[sCount].row = sRow;
		m_sCell[sCount].col = 0;
		m_sCell[sCount].bSelected = FALSE;

		sCount++;
		sRow++;
//#ifdef DBCS
                // This is right!
                // V-HIDEKK 1996.09.23
		y += CELL_HEIGHT;
/*
#else
		y += HOUR_BUTTON_HEIGHT;
#endif
*/
		}

// 'select all' button
	m_sCell[sCount].x = 2;
	m_sCell[sCount].y = 2;
	m_sCell[sCount].cx = m_sCell[sCount].x + DAY_BUTTON_WIDTH;
//#ifdef DBCS
        // This is right!
        // V-HIDEKK 1996.09.23
	m_sCell[sCount].cy = m_sCell[sCount].y + HOUR_BUTTON_HEIGHT;
/*
#else
	m_sCell[sCount].cy = m_sCell[sCount].y + CELL_HEIGHT;
#endif
*/
	m_sCell[sCount].bVal = TRUE;
	m_sCell[sCount].row = 0;
	m_sCell[sCount].col = 0;
	m_sCell[sCount].bSelected = FALSE;

//#ifdef DBCS
        // This is right!
        // V-HIDEKK 1996.09.23
        x = DAY_BUTTON_WIDTH;
/*
#else
	x = 83;
#endif
*/
	sCount++;
	while (sCount < 201)
		{
		m_sCell[sCount].x = x;
		m_sCell[sCount].y = 2;
		m_sCell[sCount].cx = x + CELL_WIDTH;
//#ifdef DBCS
                // This is right!
                // V-HIDEKK 1996.09.23
		m_sCell[sCount].cy = m_sCell[sCount].y + HOUR_BUTTON_HEIGHT;
/*
#else
		m_sCell[sCount].cy = m_sCell[sCount].y + CELL_HEIGHT;
#endif
*/

		m_sCell[sCount].bVal = TRUE;
		m_sCell[sCount].row = sRow;
		m_sCell[sCount].col = 0;
		m_sCell[sCount].bSelected = FALSE;

		sCount++;
		sRow++;
		x += CELL_WIDTH;
		}

	m_sCurrentRow = 1;
	m_sCurrentCol = 1;

	bToggle = TRUE;

// set default color values
	m_crPermitColor = GetSysColor(COLOR_ACTIVECAPTION);
	m_crDenyColor = GetSysColor(COLOR_CAPTIONTEXT);

}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::~CHoursCtrl - Destructor

CHoursCtrl::~CHoursCtrl()
{
// remove button CFont*
	if (m_pFont != NULL) delete m_pFont;   	
}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::OnDraw - Drawing function

void CHoursCtrl::OnDraw(
			CDC* pDC, const CRect& rcBounds, const CRect& rcInvalid)
{
// create pen for the grid lines
 	CPen pBlackPen(PS_SOLID, 1, RGB(0,0,0));
	CPen* pOriginalPen = (CPen*)pDC->SelectObject(pBlackPen);

// create the two brushes for allowed color and denied color
	CBrush* pAllowedBrush = new CBrush;
	pAllowedBrush->CreateSolidBrush(m_crPermitColor);

	CBrush* pDeniedBrush = new CBrush;
	pDeniedBrush->CreateSolidBrush(m_crDenyColor);

	CBrush* pDragBrush = new CBrush;
	pDragBrush->CreateHatchBrush(HS_BDIAGONAL, GetSysColor(COLOR_ACTIVECAPTION));

	USHORT sCount = 1;
	CRect crOuter;

	pDC->SetBkColor(GetSysColor(COLOR_BTNFACE));
				
// draw the grid
	while (sCount < 169)
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].cx, 
			m_sCell[sCount].cy);

		CRect crInterSect = (rcInvalid & crOuter);
		if (!crInterSect.IsRectNull())
			{
			pDC->Rectangle(&crOuter);
			crOuter.DeflateRect(1, 1);

			if (m_sCell[sCount].bSelected) pDC->FillRect(&crOuter, pDragBrush); 
			else pDC->FillRect(&crOuter, (m_sCell[sCount].bVal ? pAllowedBrush : pDeniedBrush)); 

			if ((m_sCurrentRow && m_sCurrentCol) && (sCount == m_sCurrentLoc())) 	  // is this the 'selected' cell?
				{
				crOuter.DeflateRect(2, 4);
				pDC->DrawFocusRect(&crOuter); 
				}	 
			}

		sCount++;
		}	  

	delete pAllowedBrush;
	delete pDeniedBrush;
	delete pDragBrush;


// draw the surrounding buttons
	CBrush* pButtonBrush = new CBrush;
	pButtonBrush->CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

	CPen pWhitePen(PS_SOLID, 1, RGB(255, 255, 255));
	pOriginalPen = (CPen*)pDC->SelectObject(pWhitePen);

	CPen pDkGreyPen(PS_SOLID, 1, RGB(128, 128, 128));
	CPen pLtGreyPen(PS_SOLID, 1, RGB(196, 196, 196));

	CFont* pOldFont = pDC->SelectObject(m_pFont);

	while (sCount < 176) // start with the days of the week
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].cx, 
			m_sCell[sCount].cy);

		CRect crInterSect = (rcInvalid & crOuter);
		if (!crInterSect.IsRectNull())
			{
			crOuter.DeflateRect(1, 1);
			pDC->FillRect(&crOuter, pButtonBrush);
			if (m_sCell[sCount].bVal)
				{
				pDC->SelectObject(pWhitePen);
				pDC->MoveTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].y + 1);
				pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].y + 1);
				
				pDC->SelectObject(pBlackPen);
				pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].cy);
				pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy);

				pDC->SelectObject(pDkGreyPen);
				pDC->MoveTo(m_sCell[sCount].cx - 3, m_sCell[sCount].y + 2);
				pDC->LineTo(m_sCell[sCount].cx - 3, m_sCell[sCount].cy - 1);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);
				}
			else
				{
				pDC->SelectObject(pBlackPen);
				pDC->MoveTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].y + 1);
				pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].y + 1);

				pDC->SelectObject(pWhitePen);				
				pDC->MoveTo(m_sCell[sCount].cx - 2, m_sCell[sCount].cy);
				pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy);

				pDC->SelectObject(pLtGreyPen);
				pDC->MoveTo(m_sCell[sCount].cx - 3, m_sCell[sCount].y + 2);
				pDC->LineTo(m_sCell[sCount].cx - 3, m_sCell[sCount].cy - 1);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);	
				}
					  
			pDC->SetBkMode(TRANSPARENT);
			crOuter.DeflateRect(3, 2);
			if (m_sCell[sCount].bVal) 
				pDC->DrawText(csDay[sCount - 169], 
					&crOuter,
					DT_CENTER);
			else
				{
				crOuter.OffsetRect(1, 1);
				pDC->DrawText(csDay[sCount - 169], 
					&crOuter,
					DT_CENTER);
				}
			// current selection?
			if ((m_sCurrentCol == 0) && (m_sCurrentRow == sCount - 168))
				{
				CRect crSelection = CRect(m_sCell[sCount].x, 
					m_sCell[sCount].y, 
					m_sCell[sCount].cx, 
					m_sCell[sCount].cy);

				crSelection.DeflateRect(5, 5);
				pDC->DrawFocusRect(&crSelection); 
				}
			}
		sCount++;
		}

// 'select all' button
	crOuter = CRect(m_sCell[sCount].x, 
		m_sCell[sCount].y, 
		m_sCell[sCount].cx + 1, 
		m_sCell[sCount].cy + 1);

	CRect crInterSect = (rcInvalid & crOuter);
	if (!crInterSect.IsRectNull())
		{
		crOuter.DeflateRect(1, 1);

		pDC->FillRect(&crOuter, pButtonBrush);

		if (m_sCell[sCount].bVal)
			{
			pDC->SelectObject(pWhitePen);
			pDC->MoveTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);
			pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].y);
			pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].y);
			
			pDC->SelectObject(pBlackPen);
			pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].cy - 2);
			pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy - 2);

			pDC->SelectObject(pDkGreyPen);
			pDC->MoveTo(m_sCell[sCount].cx - 3, m_sCell[sCount].y + 1);
			pDC->LineTo(m_sCell[sCount].cx - 3, m_sCell[sCount].cy - 3);
			pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 3);
			}
		else
			{
			pDC->SelectObject(pBlackPen);
			pDC->MoveTo(m_sCell[sCount].x, m_sCell[sCount].cy - 1);
			pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].y);
			pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].y);
			
			pDC->SelectObject(pWhitePen);
			pDC->LineTo(m_sCell[sCount].cx - 2, m_sCell[sCount].cy - 2);
			pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy - 2);

			pDC->SelectObject(pLtGreyPen);
			pDC->MoveTo(m_sCell[sCount].cx - 3, m_sCell[sCount].y + 1);
			pDC->LineTo(m_sCell[sCount].cx - 3, m_sCell[sCount].cy - 3);
			pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 3);
			}

		// current selection?
		if ((m_sCurrentCol == 0) && (m_sCurrentRow == 0))
			{
			CRect crSelection = CRect(m_sCell[sCount].x, 
				m_sCell[sCount].y, 
				m_sCell[sCount].cx, 
				m_sCell[sCount].cy);

			crSelection.DeflateRect(5, 5);
			pDC->DrawFocusRect(&crSelection); 
			}

		}

	sCount++;
// finish with col headers
	while (sCount < 201)
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].cx, 
			m_sCell[sCount].cy);

		CRect crInterSect = (rcInvalid & crOuter);
		if (!crInterSect.IsRectNull())
			{
			crOuter.DeflateRect(1, 1);

			pDC->FillRect(&crOuter, pButtonBrush);

			if (m_sCell[sCount].bVal)
				{
				pDC->SelectObject(pWhitePen);
				pDC->MoveTo(m_sCell[sCount].x + 1, m_sCell[sCount].cy - 2);
				pDC->LineTo(m_sCell[sCount].x + 1, m_sCell[sCount].y);
				pDC->LineTo(m_sCell[sCount].cx, m_sCell[sCount].y);
				
				pDC->SelectObject(pBlackPen);
				pDC->LineTo(m_sCell[sCount].cx, m_sCell[sCount].cy - 2);
				pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy - 2);

				pDC->SelectObject(pDkGreyPen);
				pDC->MoveTo(m_sCell[sCount].cx - 1, m_sCell[sCount].y + 1);
				pDC->LineTo(m_sCell[sCount].cx - 1, m_sCell[sCount].cy - 3);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 3);
				}
			else
				{
				pDC->SelectObject(pBlackPen);
				pDC->MoveTo(m_sCell[sCount].x + 1, m_sCell[sCount].cy - 2);
				pDC->LineTo(m_sCell[sCount].x + 1, m_sCell[sCount].y);
				pDC->LineTo(m_sCell[sCount].cx, m_sCell[sCount].y);
				
				pDC->SelectObject(pWhitePen);
				pDC->LineTo(m_sCell[sCount].cx, m_sCell[sCount].cy - 2);
				pDC->LineTo(m_sCell[sCount].x - 1, m_sCell[sCount].cy - 2);

				pDC->SelectObject(pLtGreyPen);
				pDC->MoveTo(m_sCell[sCount].cx - 1, m_sCell[sCount].y + 1);
				pDC->LineTo(m_sCell[sCount].cx - 1, m_sCell[sCount].cy - 3);
				pDC->LineTo(m_sCell[sCount].x, m_sCell[sCount].cy - 3);
				}

			// current selection?
			if ((m_sCurrentCol == sCount - 176) && (m_sCurrentRow == 0))
				{
				CRect crSelection = CRect(m_sCell[sCount].x, 
					m_sCell[sCount].y, 
					m_sCell[sCount].cx, 
					m_sCell[sCount].cy);

				crSelection.DeflateRect(3, 3);
				pDC->DrawFocusRect(&crSelection); 
				}

			}
		sCount++;
		}	   
  
	delete pButtonBrush;
	pDC->SelectObject(pOldFont);

// draw the border
	pDC->SelectObject(pBlackPen);
	pDC->MoveTo(1, rcBounds.BottomRight().y - 1);
	pDC->LineTo(rcBounds.TopLeft().x + 1, rcBounds.TopLeft().y + 1);
	pDC->LineTo(rcBounds.BottomRight().x + 1, 1);

	pDC->SelectObject(pDkGreyPen);
	pDC->MoveTo(0, rcBounds.BottomRight().y);
	pDC->LineTo(rcBounds.TopLeft().x, rcBounds.TopLeft().y);
	pDC->LineTo(rcBounds.BottomRight().x, 0);

	pDC->SelectObject(pWhitePen);
	pDC->MoveTo(1, rcBounds.BottomRight().y - 1);
	pDC->LineTo(rcBounds.BottomRight().x - 1, rcBounds.BottomRight().y - 1);
	pDC->LineTo(rcBounds.BottomRight().x - 1, 0);

	pDC->SelectObject(pLtGreyPen);
	pDC->MoveTo(2, rcBounds.BottomRight().y - 2);
	pDC->LineTo(rcBounds.BottomRight().x - 2, rcBounds.BottomRight().y - 2);
	pDC->LineTo(rcBounds.BottomRight().x - 2, 2);

}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::DoPropExchange - Persistence support

void CHoursCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl::OnResetState - Reset control to default state

void CHoursCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}


/////////////////////////////////////////////////////////////////////////////
// CHoursCtrl message handlers

int CHoursCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{

//#ifdef DBCS
// for debug and localize
// We need this code. because dialog-size changed for RL (addusrw.exe)
// HardCord size mismatched
// V-HIDEKK 1996.09.23

	CString csButtonWidth;
	csButtonWidth.LoadString(IDS_STR_BUTTONWIDTH);
        DAY_BUTTON_WIDTH = (USHORT)_ttoi(csButtonWidth.GetBuffer(0));

	CONTROL_WIDTH = (USHORT)lpCreateStruct->cx;
	CONTROL_HEIGHT = (USHORT)lpCreateStruct->cy;
	HOUR_BUTTON_HEIGHT = CONTROL_HEIGHT/8 + CONTROL_HEIGHT%8 - 3;
	CELL_WIDTH = ((CONTROL_WIDTH - DAY_BUTTON_WIDTH) / 24);
	CELL_HEIGHT = ((CONTROL_HEIGHT - HOUR_BUTTON_HEIGHT) / 7);

// create the individual 'cells' (m_sCells)
	USHORT x, y;
	x = HOUR_BUTTON_HEIGHT;
	y = DAY_BUTTON_WIDTH;

	CRect crOuter;
	USHORT sCount = 1;
	USHORT sRow = 1;
	USHORT sCol = 1;

	for (x = DAY_BUTTON_WIDTH; (x + CELL_WIDTH) < CONTROL_WIDTH; x += CELL_WIDTH)
		{
		for (y = HOUR_BUTTON_HEIGHT; (y + CELL_HEIGHT) < CONTROL_HEIGHT; y += CELL_HEIGHT)
			{
			m_sCell[sCount].x = x;
			m_sCell[sCount].y = y;
			m_sCell[sCount].cx = x + CELL_WIDTH + 1;
			m_sCell[sCount].cy = y + CELL_HEIGHT + 1;

			m_sCell[sCount].bVal = TRUE;
			m_sCell[sCount].row = sRow;
			m_sCell[sCount].col = sCol;
			m_sCell[sCount].bSelected = FALSE;
			sCount++;
			sRow++;
			}
		sRow = 1;
		sCol++;
		}

// create the buttons
	// start with the days
	y = HOUR_BUTTON_HEIGHT;
	sRow = 0;

	while (sCount < 176)
		{
		m_sCell[sCount].x = 2;
		m_sCell[sCount].y = y;
		m_sCell[sCount].cx = m_sCell[sCount].x + DAY_BUTTON_WIDTH;
		m_sCell[sCount].cy = y + CELL_HEIGHT;
		m_sCell[sCount].bVal = TRUE;
		m_sCell[sCount].row = sRow;
		m_sCell[sCount].col = 0;
		m_sCell[sCount].bSelected = FALSE;

		sCount++;
		sRow++;
		y += CELL_HEIGHT;
		}

// 'select all' button
	m_sCell[sCount].x = 2;
	m_sCell[sCount].y = 2;
	m_sCell[sCount].cx = m_sCell[sCount].x + DAY_BUTTON_WIDTH;
	m_sCell[sCount].cy = m_sCell[sCount].y + HOUR_BUTTON_HEIGHT;
	m_sCell[sCount].bVal = TRUE;
	m_sCell[sCount].row = 0;
	m_sCell[sCount].col = 0;
	m_sCell[sCount].bSelected = FALSE;

        x = DAY_BUTTON_WIDTH;
	sCount++;
	while (sCount < 201)
		{
		m_sCell[sCount].x = x;
		m_sCell[sCount].y = 2;
		m_sCell[sCount].cx = x + CELL_WIDTH;
		m_sCell[sCount].cy = m_sCell[sCount].y + HOUR_BUTTON_HEIGHT;

		m_sCell[sCount].bVal = TRUE;
		m_sCell[sCount].row = sRow;
		m_sCell[sCount].col = 0;
		m_sCell[sCount].bSelected = FALSE;

		sCount++;
		sRow++;
		x += CELL_WIDTH;
		}

//#endif

	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;


// load the text for the day buttons
	csDay[0].LoadString(IDS_SUNDAY);
	csDay[1].LoadString(IDS_MONDAY);
	csDay[2].LoadString(IDS_TUESDAY);
	csDay[3].LoadString(IDS_WEDNESDAY);
	csDay[4].LoadString(IDS_THURSDAY);
	csDay[5].LoadString(IDS_FRIDAY);
	csDay[6].LoadString(IDS_SATURDAY);



	return 0;
}

// make the cursor over the control into the '+' sign
BOOL CHoursCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	::SetCursor(::LoadCursor(NULL, IDC_CROSS));
	return TRUE;
}

// trap lButton clicks to toggle single cells
void CHoursCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
//	invalidate the previous selection
	InvalidateCell(m_sCurrentLoc());

	Click(point);
	pointDrag = point;

	USHORT sCount = 1;
// clear out the old drag selection(s)
	while (sCount < 168)
		{
		if (m_sCell[sCount].bSelected)
			{
			m_sCell[sCount].bSelected = FALSE;

			InvalidateCell(sCount);
			}

		sCount++;
		}

//	COleControl::OnLButtonDown(nFlags, point);	
}


void CHoursCtrl::InvalidateCell(USHORT sCellID)
{
	CRect crCell = CRect(m_sCell[sCellID].x, 
		m_sCell[sCellID].y, 
		m_sCell[sCellID].cx, 
		m_sCell[sCellID].cy);
	InvalidateRect(crCell);
}

void CHoursCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	if (nFlags == MK_LBUTTON)
		{
		USHORT sEndCell = GetCellID(point);
		USHORT sStartCell = GetCellID(pointDrag);
//#ifdef DBCS
                // If sEndCell==0, this cell is invalid
                // It seems this like better!
                // V-HIDEKK 1996.09.23
		if (sStartCell == sEndCell || !sEndCell ) return;
/*
#else
		if (sStartCell == sEndCell) return;
#endif
*/

		CRect crSelected = CRect(min(m_sCell[sStartCell].x, m_sCell[sEndCell].x),
			min(m_sCell[sStartCell].y, m_sCell[sEndCell].y),
			max(m_sCell[sStartCell].x, m_sCell[sEndCell].x) + CELL_WIDTH,
			max(m_sCell[sStartCell].y, m_sCell[sEndCell].y) + CELL_HEIGHT);

		USHORT sCount = 0;
// clear out the old selection
		while (sCount < 169)
			{
			if (!crSelected.PtInRect(CPoint(m_sCell[sCount].x + 1, m_sCell[sCount].y + 1)))
				{
				if (m_sCell[sCount].bSelected)
					{
					m_sCell[sCount].bSelected = FALSE;

					InvalidateCell(sCount);
					}
				}
			else 
				{
				if (!m_sCell[sCount].bSelected)
					{
					m_sCell[sCount].bSelected = TRUE;
					InvalidateCell(sCount);
					}
				}

			sCount++;
			}
		}

	COleControl::OnMouseMove(nFlags, point);
}

void CHoursCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	USHORT sEndCell = GetCellID(point);
	USHORT sStartCell = GetCellID(pointDrag);
//#ifdef DBCS
        // If sEndCell==0, this cell is invalid
        // It seems this like better!
        // V-HIDEKK 1996.09.23
	if (sStartCell == sEndCell || !sEndCell ) return;
/*
#else
	if (sStartCell == sEndCell) return;
#endif
*/

	CRect crSelected = CRect(min(m_sCell[sStartCell].x, m_sCell[sEndCell].x),
		min(m_sCell[sStartCell].y, m_sCell[sEndCell].y),
		max(m_sCell[sStartCell].x, m_sCell[sEndCell].x) + CELL_WIDTH,
		max(m_sCell[sStartCell].y, m_sCell[sEndCell].y) + CELL_HEIGHT);

// first get the avg 
	short sTmp = 0;
	USHORT sCount = 0;
	while (sCount < 169)
		{
		if (crSelected.PtInRect(CPoint(m_sCell[sCount].x + 1, m_sCell[sCount].y + 1)))
			{
			if (m_sCell[sCount].bVal) sTmp++;
			else sTmp--;
			}

		sCount++;
		}

	BOOL bNewVal;
	if (sTmp >= 0) bNewVal = FALSE;
	else bNewVal = TRUE;
	sCount = 0;
// now change them all to be !the average
// first get the avg 
	while (sCount < 169)
		{
		if (crSelected.PtInRect(CPoint(m_sCell[sCount].x + 1, m_sCell[sCount].y + 1)))
			{
			m_sCell[sCount].bVal = bNewVal;
			m_sCell[sCount].bSelected = FALSE;
			InvalidateCell(sCount);
			}

		sCount++;
		}

	COleControl::OnLButtonUp(nFlags, point);
}

USHORT CHoursCtrl::GetCellID(CPoint point)
{
	USHORT sCount = 1;

// big grid?
	CRect crOuter;
	while (sCount < 169)
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].x + CELL_WIDTH + 1, 
			m_sCell[sCount].y + CELL_HEIGHT + 1);
		if (crOuter.PtInRect(point)) return sCount;

		sCount++;
		}

// day button?
	while (sCount < 176)
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].x + DAY_BUTTON_WIDTH + 1, 
			m_sCell[sCount].y + CELL_HEIGHT + 1);
		if (crOuter.PtInRect(point)) return sCount;

		sCount++;
		}

// big button?
	crOuter = CRect(m_sCell[sCount].x, 
		m_sCell[sCount].y, 
		m_sCell[sCount].x + DAY_BUTTON_WIDTH + 1, 
//#ifdef DBCS
                // It seems this is right!
                // V-HIDEKK 1996.09.23
		m_sCell[sCount].y + HOUR_BUTTON_HEIGHT + 1 );  //CELL_HEIGHT + 1);
/*
#else
		m_sCell[sCount].y + CELL_HEIGHT + 1);
#endif
*/
	if (crOuter.PtInRect(point)) return sCount;

// column button?
	while (sCount < 201)
		{
		crOuter = CRect(m_sCell[sCount].x, 
			m_sCell[sCount].y, 
			m_sCell[sCount].x + CELL_WIDTH + 1, 
//#ifdef DBCS
                        // It seems this is right!
                        // V-HIDEKK 1996.09.23
			m_sCell[sCount].y + HOUR_BUTTON_HEIGHT + 1 );  //CELL_HEIGHT + 1);
/*
#else
			m_sCell[sCount].y + CELL_HEIGHT + 1);
#endif
*/
		if (crOuter.PtInRect(point)) return sCount;

		sCount++;
		}

	return 0;
}

void CHoursCtrl::Click(CPoint point)
{
	USHORT sCount = 0;
	CRect crOuter;

	USHORT sCell = GetCellID(point);

//#ifdef DBCS
        // Fix: Invalid Area clicked, then AV occurred.
        // sCell==0 is Invalid Cell
        // V-HIDEKK 1996.09.23
        if( !sCell )
            return;

//#endif
	m_sCurrentRow = m_sCell[sCell].row;
	m_sCurrentCol = m_sCell[sCell].col;

//#ifdef DBCS
        // Fix: most right-bottom area can not selected
        // Where is sCell==168 ?
        // This is RIGHT! 
        // V-HIDEKK 1996.09.23
	if (sCell < 169) m_sCell[sCell].bVal = !m_sCell[sCell].bVal;
/*
#else
	if (sCell < 168) m_sCell[sCell].bVal = !m_sCell[sCell].bVal;
#endif
*/
	InvalidateCell(sCell);

// 	if we clicked on a button toggle its value and redraw
	if (sCell > 168)
		{
		if ((sCell > 168) && (sCell < 176)) // day button
			ToggleDay(sCell - 168);

		else if (sCell == 176) // toggle all
			OnBigButton();

		else	// column header
			ToggleCol(sCell - 177);
		}

}

// toggle the values of a row (by day)
void CHoursCtrl::ToggleDay(UINT nID)
{
	USHORT sCount;
	CRect crOuter;

	for (sCount = (USHORT)nID; sCount < 169; sCount += 7)
		{
		m_sCell[sCount].bVal = !m_sCell[nID + 168].bVal;
		InvalidateCell(sCount);
		}
	m_sCell[nID + 168].bVal = !m_sCell[nID + 168].bVal;
	m_sCurrentRow = (USHORT)nID;
	m_sCurrentCol = 0;
  
}

// toggle the values of a column
void CHoursCtrl::ToggleCol(UINT nID)
{
	USHORT sCount;
	CRect crOuter;

	m_sCurrentRow = 0;
	m_sCurrentCol = nID + 1;

	USHORT sVal = nID + 177;
	nID *= 7;

	for (sCount = 1; sCount < 8; sCount += 1)
		{
		m_sCell[sCount + nID].bVal = !m_sCell[sVal].bVal;
		InvalidateCell(sCount + nID);
		}
	m_sCell[sVal].bVal = !m_sCell[sVal].bVal;

}

// toggle the whole page
void CHoursCtrl::OnBigButton()
{
	USHORT sCount;
	CRect crOuter;

	m_sCurrentRow = 0;
	m_sCurrentCol = 0;
	
	for (sCount = 1; sCount < 169; sCount ++)
		{
		m_sCell[sCount].bVal = !m_sCell[176].bVal;
		InvalidateCell(sCount);
		}

	m_sCell[176].bVal = !m_sCell[176].bVal;

}

BOOL CHoursCtrl::PreTranslateMessage(LPMSG lpmsg)
{
    BOOL bHandleNow = FALSE;
	CRect crOld, crNew;

    switch (lpmsg->message)
    {
    case WM_KEYDOWN:
        switch (lpmsg->wParam)
        {
			case VK_SPACE: // toggle the cell under the dot
				{
				short sOldCell = m_sCurrentLoc();
//#ifdef DBCS
                                // FIX: most left hours button can not selected.
                                // It seems rectangle mismatched.
                                // V-HIDEKK 1996.09.23
				Click(CPoint(m_sCell[sOldCell].x + 5, m_sCell[sOldCell].y + 5));
/*
#else
				Click(CPoint(m_sCell[sOldCell].x + 1, m_sCell[sOldCell].y + 1));
#endif
*/
				bHandleNow = TRUE;
				break;
				} 

			case VK_UP:
				{		 
				// first store the old cell pos so we can erase it 
				short sOldCell = m_sCurrentLoc();

				// move the carat to the new cell
				m_sCurrentRow--;
				if (m_sCurrentRow < 0) m_sCurrentRow = 7;

				// now draw the new cell
				short sNewCell = m_sCurrentLoc();
				InvalidateCell(sOldCell);
				InvalidateCell(sNewCell);
				bHandleNow = TRUE;
				break;
				}

			case VK_DOWN:
				{
				short sOldCell = m_sCurrentLoc();

				m_sCurrentRow++;
				if (m_sCurrentRow > 7) m_sCurrentRow = 0;

				short sNewCell = m_sCurrentLoc();
				InvalidateCell(sOldCell);
				InvalidateCell(sNewCell);
				bHandleNow = TRUE;
				break;
				}
			   
			case VK_LEFT:
				{			
				short sOldCell = m_sCurrentLoc();
				m_sCurrentCol--;
				if (m_sCurrentCol < 0) m_sCurrentCol = 24;

				short sNewCell = m_sCurrentLoc();
				InvalidateCell(sOldCell);
				InvalidateCell(sNewCell);
				bHandleNow = TRUE;
				break;
				}

			case VK_RIGHT:
				{
				short sOldCell = m_sCurrentLoc();						  
				m_sCurrentCol++;
				if (m_sCurrentCol > 24) m_sCurrentCol = 0;

				short sNewCell = m_sCurrentLoc();
				InvalidateCell(sOldCell);
				InvalidateCell(sNewCell);
				bHandleNow = TRUE;
				break;
				}
			}
		}

    return bHandleNow;
}


short CHoursCtrl::m_sCurrentLoc()
{	
	if (!m_sCurrentCol && !m_sCurrentRow) // select all button
		return 176;

	else if (!m_sCurrentCol)
		return m_sCurrentRow + 168;
	
	else if (!m_sCurrentRow)
		return m_sCurrentCol + 176;

	return ((max(m_sCurrentCol - 1, 0) * 7) + m_sCurrentRow);
}

// these are triggered when the client app changes one of the exported properties
void CHoursCtrl::OnCrPermitColorChanged() 
{
	Invalidate();

	SetModifiedFlag();
}

void CHoursCtrl::OnCrDenyColorChanged() 
{
	Invalidate();

	SetModifiedFlag();
}

VARIANT CHoursCtrl::GetDateData() 
{
	VARIANT vaResult;
	VariantInit(&vaResult);

	vaResult.vt = VT_ARRAY | VT_UI1;

	SAFEARRAYBOUND sab[1];
	sab[0].cElements = 21;
	sab[0].lLbound = 0;

	vaResult.parray = SafeArrayCreate(VT_UI1, 1, sab);

 // load constant offsets into an array
	DWORD dwOffset[8];
	USHORT sCount;
	short sVal = 1;
	for (sCount = 0; sCount < 8; sCount++)
		{
		dwOffset[sCount] = sVal;
		sVal = sVal << 1;
		}

// find the diff between current time and GMT (UTC)
	struct _timeb tstruct;
	_tzset();
	_ftime( &tstruct );

// time difference in "seconds moving westward"	- this is the amount of hours to add to the
// listbox values to get GMT
	short sHourDiff = tstruct.timezone / 60;

	sCount = 0;
	short sOffset = 0;

// adjust for GMT
	if (sHourDiff != 0)
		{
		sOffset += (sHourDiff % 8);
		sCount = (int)(sHourDiff / 8);
		} 

	USHORT sCount2 = 1;	// address 0 is used elsewhere
	USHORT sBase;
	BYTE bRet[21];
	ZeroMemory(bRet, 21);
	
	for (sBase = 1; sBase < 8; sBase++)
		{
		sCount2 = sBase;
		while (sCount2 < 169)
			{
			if (m_sCell[sCount2].bVal)  // 1 = marked
				bRet[sCount] |= dwOffset[sOffset];

			sOffset++;
			if (sOffset > 7)
				{
				sOffset = 0;
				sCount++;
				if (sCount > 20) sCount = 0;
				}
			sCount2+=7;
			}
		}


	long index[1];
	for (index[0] = 0; index[0] < 21; index[0]++)
		SafeArrayPutElement(vaResult.parray, &index[0], &bRet[index[0]]);

	return vaResult;
}

void CHoursCtrl::SetDateData(const VARIANT FAR& newValue) 
{
	// TODO: Add your property handler here

	SetModifiedFlag();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// stdafx.cpp : source file that includes just the standard includes

File History:

	JonY    May-96  created

--*/

//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hoursppg.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// HoursPpg.cpp : Implementation of the CHoursPropPage property page class.

File History:

	JonY    May-96  created

--*/

#include "stdafx.h"
#include "Hours.h"
#include "HoursPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CHoursPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CHoursPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CHoursPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CHoursPropPage, "HOURS.HoursPropPage.1",
	0xa44ea7ae, 0x9d58, 0x11cf, 0xa3, 0x5f, 0, 0xaa, 0, 0xb6, 0x74, 0x3b)


/////////////////////////////////////////////////////////////////////////////
// CHoursPropPage::CHoursPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CHoursPropPage

BOOL CHoursPropPage::CHoursPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_HOURS_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CHoursPropPage::CHoursPropPage - Constructor

CHoursPropPage::CHoursPropPage() :
	COlePropertyPage(IDD, IDS_HOURS_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CHoursPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CHoursPropPage::DoDataExchange - Moves data between page and properties

void CHoursPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CHoursPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CHoursPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// stdafx.h : include file for standard system include files,

File History:

	JonY    May-96  created

--*/

//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>
#include <afxctl.h>         // MFC support for OLE Controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Hours.rc
//
#define IDS_HOURS                       1
#define IDB_HOURS                       1
#define IDS_HOURS_PPG                   2
#define IDS_HOURS_PPG_CAPTION           100
#define IDD_PROPPAGE_HOURS              100
#define IDS_SUNDAY                      101
#define IDS_MONDAY                      102
#define IDS_TUESDAY                     103
#define IDS_WEDNESDAY                   104
#define IDS_THURSDAY                    105
#define IDS_FRIDAY                      106
#define IDS_SATURDAY                    107

// ADD For localize by V-HIDEKK 96/06/17 JAPAN
#define IDS_STR_FONTNAME                108
#define IDS_STR_FONTSIZE                109
#define IDS_STR_BUTTONWIDTH             110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\finpic.cpp ===
// FinPic.cpp : implementation file
//

#include "stdafx.h"
#include "lcwiz.h"
#include "FinPic.h"
#include "transbmp.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture

CFinalPicture::CFinalPicture()
{
}

CFinalPicture::~CFinalPicture()
{
}


BEGIN_MESSAGE_MAP(CFinalPicture, CStatic)
	//{{AFX_MSG_MAP(CFinalPicture)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture message handlers

void CFinalPicture::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	CTransBmp transbmp;

	transbmp.LoadBitmap(IDB_END_FLAG);
	transbmp.DrawTrans(&dc, 0, 0);

	// Do not call CStatic::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\hoursctl\hoursppg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

// HoursPpg.h : Declaration of the CHoursPropPage property page class.

File History:

	JonY    May-96  created

--*/

////////////////////////////////////////////////////////////////////////////
// CHoursPropPage : See HoursPpg.cpp.cpp for implementation.

class CHoursPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CHoursPropPage)
	DECLARE_OLECREATE_EX(CHoursPropPage)

// Constructor
public:
	CHoursPropPage();

// Dialog Data
	//{{AFX_DATA(CHoursPropPage)
	enum { IDD = IDD_PROPPAGE_HOURS };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CHoursPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\finpic.h ===
// FinPic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFinalPicture window

class CFinalPicture : public CStatic
{
// Construction
public:
	CFinalPicture();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFinalPicture)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFinalPicture();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFinalPicture)
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwiz.h ===
// LCWiz.h : main header file for the LCWIZ application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __LCWIZ_H__
#define __LCWIZ_H__

#include <winreg.h>
#include "resource.h"		// main symbols

typedef struct tagTREEINFO
{
	HTREEITEM	hTreeItem;
	DWORD		dwBufSize;
	CObject*	pTree;
	BOOL		bExpand;
}
TREEINFO, *PTREEINFO;

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp:
// See LCWiz.cpp for the implementation of this class
//

class CLicCompWizApp : public CWinApp
{
public:
	void OnWizard();
	CLicCompWizApp();
	~CLicCompWizApp();
	void NotifyLicenseThread(BOOL bExit);
	void ExitThreads();

// Data members
public:
	CString m_strEnterprise;
	CWinThread* m_pLicenseThread;
	BOOL m_bExitLicenseThread;
	CEvent m_event;
	CString m_strDomain, m_strEnterpriseServer, m_strUser;
	int m_nRemote;

protected:
	HANDLE m_hMutex;

// Attributes
public:
	inline int& IsRemote() {return m_nRemote;}

protected:
	BOOL GetRegString(CString& strIn, UINT nSubKey, UINT nValue, HKEY hHive = HKEY_LOCAL_MACHINE);

// Constants
	enum
	{
		BUFFER_SIZE = 256
	};

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CLicCompWizApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif __LCWIZ_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwiz.cpp ===
// LCWiz.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "LCWiz.h"
#include "LCWizSht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp

BEGIN_MESSAGE_MAP(CLicCompWizApp, CWinApp)
	//{{AFX_MSG_MAP(CLicCompWizApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	//ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global variables

TCHAR pszMutex[] = _T("LicenseMutex");
TCHAR pszLicenseEvent[] = _T("LicenseThread");
TCHAR pszTreeEvent[] =  _T("TreeThread");

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp construction

CLicCompWizApp::CLicCompWizApp()
: m_pLicenseThread(NULL), m_bExitLicenseThread(FALSE), 
  m_event(TRUE, TRUE, pszLicenseEvent), m_nRemote(0)
{
	m_strEnterprise.Empty();
	m_strDomain.Empty();
	m_strEnterpriseServer.Empty();
	m_strUser.Empty();

	// Create a mutex object for use when checking for
	// multiple instances.
	m_hMutex = ::CreateMutex(NULL, TRUE, pszMutex);

	// Place all significant initialization in InitInstance
}

CLicCompWizApp::~CLicCompWizApp()
{
	::ReleaseMutex(m_hMutex);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLicCompWizApp object

CLicCompWizApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizApp initialization

BOOL CLicCompWizApp::InitInstance()
{
	// Make sure we're running on the correct OS version.
	OSVERSIONINFO  os;

	os.dwOSVersionInfoSize = sizeof(os);
	::GetVersionEx(&os);

	if (os.dwMajorVersion < 4 || os.dwPlatformId != VER_PLATFORM_WIN32_NT)
	{
		AfxMessageBox(IDS_BAD_VERSION, MB_OK | MB_ICONSTOP);
		return FALSE;
	}

	// If there's an instance already running, bring it to the 
	// top and exit.
	if (::WaitForSingleObject(m_hMutex, 0) != WAIT_OBJECT_0)
	{
		CString strWindow;

		strWindow.LoadString(AFX_IDS_APP_TITLE);
		HWND hwnd = ::FindWindow(NULL, (LPCTSTR)strWindow);

		if (hwnd != NULL)
			::SetForegroundWindow(hwnd);
		else
		{
			TRACE(_T("%lu: FindWindow\n"), ::GetLastError());
		}

		return FALSE;
	}

#ifdef OLE_AUTO
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}
#endif // OLE_AUTO

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

#ifdef OLE_AUTO
	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	COleObjectFactory::UpdateRegistryAll();

#endif // OLE_AUTO

	PLLS_CONNECT_INFO_0 pllsci;

	// Get the default domain and license server.
	NTSTATUS status = ::LlsEnterpriseServerFind(NULL, 0, (LPBYTE*)&pllsci);

	if (NT_SUCCESS(status))
	{
		m_strDomain = pllsci->Domain;
		m_strEnterpriseServer = pllsci->EnterpriseServer;

		// Free embedded pointers.
		//::LlsFreeMemory(pllsci->Domain);
		//::LlsFreeMemory(pllsci->EnterpriseServer);
		::LlsFreeMemory(pllsci);
	}
	else
	{
		// There is no license server if this is a workstation
		// so get the local computer name instead.
	
		DWORD dwBufSize = BUFFER_SIZE;
		LPTSTR pszTemp = m_strEnterpriseServer.GetBuffer(dwBufSize);
		::GetComputerName(pszTemp, &dwBufSize);
		m_strDomain.ReleaseBuffer();

		// Get the default domain name from the registry.
		GetRegString(m_strDomain, IDS_SUBKEY, IDS_REG_VALUE);
	}
	
	CString strDomain, strUser;

	// Get the user's name and domain.
	GetRegString(strDomain, IDS_SUBKEY, IDS_REG_VALUE_DOMAIN);
	GetRegString(strUser, IDS_SUBKEY, IDS_REG_VALUE_USER);

	m_strUser.Format(IDS_DOMAIN_USER, strDomain, strUser);

	// Launch the wizard.
	OnWizard();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

void CLicCompWizApp::OnWizard()
{
	// The property sheet attached to your project
	// via this function is not hooked up to any message
	// handler.  In order to actually use the property sheet,
	// you will need to associate this function with a control
	// in your project such as a menu item or tool bar button.

	CLicCompWizSheet propSheet;
	m_pMainWnd = &propSheet;

	propSheet.DoModal();

	// This is where you would retrieve information from the property
	// sheet if propSheet.DoModal() returned IDOK.  We aren't doing
	// anything for simplicity.
}

BOOL CLicCompWizApp::GetRegString(CString& strIn, UINT nSubKey, UINT nValue, HKEY hHive /* = HKEY_LOCAL_MACHINE */)
{
	BOOL bReturn = FALSE;
	HKEY hKey;
	LPTSTR pszTemp;
	DWORD dwBufSize = BUFFER_SIZE;
	CString strSubkey;
	strSubkey.LoadString(nSubKey);

	if (::RegOpenKeyEx(hHive, (LPCTSTR)strSubkey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType = REG_SZ;
		CString strValue;
		strValue.LoadString(nValue);

		pszTemp = strIn.GetBuffer(dwBufSize);
		::RegQueryValueEx(hKey, (LPCTSTR)strValue, NULL, &dwType, (LPBYTE)pszTemp, &dwBufSize);
		::RegCloseKey(hKey);
		strIn.ReleaseBuffer();

		bReturn = TRUE;
	}

	return bReturn;
}

int CLicCompWizApp::ExitInstance() 
{
	ExitThreads();
		
	return CWinApp::ExitInstance();
}

void CLicCompWizApp::NotifyLicenseThread(BOOL bExit)
{
	CCriticalSection cs;

	if (cs.Lock())
	{
		m_bExitLicenseThread = bExit;
		cs.Unlock();
	}
}

void CLicCompWizApp::ExitThreads()
{
	// Make sure the license thread knows it's supposed to quit.
	if (m_pLicenseThread != NULL)
		NotifyLicenseThread(TRUE);

	// Create a lock object for the event object.
	CSingleLock lock(&m_event);

	// Lock the lock object and make the main thread wait for the
	// threads to signal their event objects.
	lock.Lock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwizsht.cpp ===
// LCWizSht.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "LCWizSht.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet

IMPLEMENT_DYNAMIC(CLicCompWizSheet, CPropertySheet)

CLicCompWizSheet::CLicCompWizSheet(CWnd* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the 
	// active one is to call SetActivePage().

	AddPage(&m_Page1);
	AddPage(&m_Page3);
	AddPage(&m_Page4);

	SetWizardMode();
}

CLicCompWizSheet::~CLicCompWizSheet()
{
}


BEGIN_MESSAGE_MAP(CLicCompWizSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CLicCompWizSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet message handlers


BOOL CLicCompWizSheet::OnInitDialog() 
{
	if ((m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME)) != NULL)
	{
		::SetClassLongPtr(m_hWnd, GCLP_HICON, (LONG_PTR)m_hIcon);
		::SetClassLongPtr(m_hWnd, GCLP_HICONSM, (LONG_PTR)m_hIcon);
	}

	return CPropertySheet::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwizpgs.cpp ===
// LCWizPgs.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "LCWizPgs.h"
#include "LCWiz.h"
#include "LCWizSht.h"
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLicCompWizPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CLicCompWizPage3, CPropertyPage)
IMPLEMENT_DYNCREATE(CLicCompWizPage4, CPropertyPage)


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 property page

CLicCompWizPage1::CLicCompWizPage1() : CPropertyPage(CLicCompWizPage1::IDD)
{
	//{{AFX_DATA_INIT(CLicCompWizPage1)
	m_nRadio = 0;
	m_strText = _T("");
	//}}AFX_DATA_INIT
}

CLicCompWizPage1::~CLicCompWizPage1()
{
}

void CLicCompWizPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage1)
	DDX_Control(pDX, IDC_WELCOME, m_wndWelcome);
	DDX_Radio(pDX, IDC_RADIO_LOCAL_COMPUTER, m_nRadio);
	DDX_Text(pDX, IDC_TEXT, m_strText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 property page

BOOL CLicCompWizPage1::OnSetActive() 
{
	((CLicCompWizSheet*)GetParent())->SetWizardButtons(PSWIZB_NEXT);
	
	return CPropertyPage::OnSetActive();
}

BOOL CLicCompWizPage1::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	m_strText.LoadString(IDS_TEXT_PAGE1);
	
	// Get the font for the welcome static control and make the font bold.
	CFont* pFont = m_wndWelcome.GetFont();

	// Get the default GUI font if GetFont() fails.
	if (pFont == NULL)
		pFont = CFont::FromHandle((HFONT)::GetStockObject(DEFAULT_GUI_FONT));

	LOGFONT lf;

	if (pFont != NULL && pFont->GetLogFont(&lf))
	{
		// Add to the font weight to make it bold.
		lf.lfWeight += BOLD_WEIGHT;

		if (m_fontBold.CreateFontIndirect(&lf))
		{
			// Set the font for the static control.
			m_wndWelcome.SetFont(&m_fontBold);
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CLicCompWizPage1::OnWizardNext() 
{
	UpdateData();

	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	pApp->IsRemote() = m_nRadio;

	pApp->m_strEnterprise.Empty();

	if (m_nRadio == 0)
	{
		if (::IsWindow(pSheet->m_Page3.m_hWnd))
		{
			pSheet->m_Page3.GetEnterpriseEdit().SetWindowText(_T(""));
		}

		return IDD_PROPPAGE4;
	}
	else
		return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 property page

CLicCompWizPage3::CLicCompWizPage3()
: CPropertyPage(CLicCompWizPage3::IDD), m_bExpandedOnce(FALSE)
{
	//{{AFX_DATA_INIT(CLicCompWizPage3)
	//}}AFX_DATA_INIT
}

CLicCompWizPage3::~CLicCompWizPage3()
{
}

void CLicCompWizPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage3)
	DDX_Control(pDX, IDC_TEXT_SELECT_DOMAIN, m_wndTextSelectDomain);
	DDX_Control(pDX, IDC_TEXT_DOMAIN, m_wndTextDomain);
	DDX_Control(pDX, IDC_EDIT_ENTERPRISE, m_wndEnterprise);
	DDX_Control(pDX, IDC_TREE_NETWORK, m_wndTreeNetwork);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage3)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE_NETWORK, OnSelChangedTree)
	ON_EN_CHANGE(IDC_EDIT_ENTERPRISE, OnChangeEditEnterprise)
	ON_NOTIFY(NM_OUTOFMEMORY, IDC_TREE_NETWORK, OnNetworkTreeOutOfMemory)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 message handlers

BOOL CLicCompWizPage3::OnSetActive() 
{
	BOOL bReturn = CPropertyPage::OnSetActive();

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Do the default domain expansion only once.
	if (!m_bExpandedOnce)
	{
		m_bExpandedOnce = TRUE;
		m_wndTreeNetwork.PopulateTree();
	}

	pSheet->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	return bReturn;
}

void CLicCompWizPage3::OnSelChangedTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	ASSERT(pNMTreeView->itemNew.mask & TVIF_PARAM);

	// Copy the remote name for the selected item into the edit control.
	if (pNMTreeView->itemNew.mask & TVIF_PARAM)
	{
		CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

		int nImage, nSelectedImage;

		nImage = nSelectedImage = 0;

		m_wndTreeNetwork.GetItemImage(m_wndTreeNetwork.GetSelectedItem(), nImage, nSelectedImage);

		// Set the enterprise name in the App object.
		if (nImage == CNetTreeCtrl::IMG_ROOT)
			pApp->m_strEnterprise.Empty();
		else
			pApp->m_strEnterprise = ((LPNETRESOURCE)pNMTreeView->itemNew.lParam)->lpRemoteName;

		// Set the text in the edit control.
		m_wndEnterprise.SetWindowText(pApp->m_strEnterprise);

		// Select the text in the edit control.
		m_wndEnterprise.SetSel(0, -1);
	}

	*pResult = 0;
}

void CLicCompWizPage3::OnChangeEditEnterprise() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	m_wndEnterprise.GetWindowText(pApp->m_strEnterprise);
}

void CLicCompWizPage3::OnNetworkTreeOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_wndTreeNetwork.NotifyThread(TRUE);

	AfxMessageBox(IDS_MEM_ERROR, MB_OK | MB_ICONSTOP);

	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 functions


/////////////////////////////////////////////////////////////////////////////
// Global variables

extern TCHAR pszLicenseEvent[];

/////////////////////////////////////////////////////////////////////////////
// Static member functions

UINT CLicCompWizPage4::GetLicenseInfo(LPVOID pParam)
{
	// Create an event object to match that in the application object.
	CEvent event(TRUE, TRUE, pszLicenseEvent);
	
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CLicCompWizPage4* pPage = (CLicCompWizPage4*)pParam;
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)pPage->GetParent();
	CWaitCursor wc;
	NTSTATUS status = STATUS_ACCESS_DENIED;

	try
	{
		CString strText;
		
		// Unsignal the event object.
		event.ResetEvent();

		// Reset the exit flag.
		pApp->NotifyLicenseThread(FALSE);

		// Disable the Back and Next buttons while the thread is running.
		pSheet->SetWizardButtons(0);

		LPBYTE lpbBuf = NULL;
		LLS_HANDLE hLls = NULL;
		DWORD dwTotalEntries, dwResumeHandle;

		dwTotalEntries = dwResumeHandle = 0;

		// Save the machine or domain name that the user typed.
		CString strFocus = pApp->m_strEnterprise;

		// Display a message indicating what the wizard is doing.
		strText.LoadString(IDS_WORKING);
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);
		strText.Empty();  // Avoids a memory leak.

		// Connect to the license server.
		status = ::LlsConnectEnterprise(const_cast<LPTSTR>((LPCTSTR)pApp->m_strEnterprise),
												 &hLls, 0, &lpbBuf);

		if (NT_ERROR(status))
			goto ErrorMessage;

		// It's OK for the user to click the Back button now, so enable it.
		pSheet->SetWizardButtons(PSWIZB_BACK);

		if (lpbBuf != NULL)
		{
			PLLS_CONNECT_INFO_0 pllsci = (PLLS_CONNECT_INFO_0)lpbBuf;

			// Reset the domain and enterprise server names.
			pApp->m_strDomain = pllsci->Domain;
			pApp->m_strEnterpriseServer = pllsci->EnterpriseServer;

			// Free embedded pointers
			//::LlsFreeMemory(pllsci->Domain);
			//::LlsFreeMemory(pllsci->EnterpriseServer);

			// Free memory allocated by the LLS API.
			status = ::LlsFreeMemory(lpbBuf);
			lpbBuf = NULL;
		}

		if (NT_SUCCESS(status))
		{
			// Display a message indicating what the wizard is doing.
			strText.LoadString(IDS_ENUM_PRODUCTS);
			pPage->m_wndUnlicensedProducts.SetWindowText(strText);
			strText.Empty();  // Avoids a memory leak.

			USHORT nProductCount = 0;
			DWORD dwEntriesRead, dwTotalEntriesRead;

			dwEntriesRead = dwTotalEntriesRead = 0;

			// Build a list of all the products.
			do
			{	
				// Check the exit thread flag.  The user may have clicked the Back button.
				if (pApp->m_bExitLicenseThread)
					goto ExitThread;

				status = ::LlsProductEnum(hLls, 1, &lpbBuf, CLicCompWizPage4::LLS_PREFERRED_LENGTH,
										  &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);

				if (!NT_SUCCESS(status))
					goto ErrorMessage;

				dwTotalEntriesRead += dwEntriesRead;

				PLLS_PRODUCT_INFO_1 pllspi = (PLLS_PRODUCT_INFO_1)lpbBuf;

				while (dwEntriesRead--)
				{
					// Check the exit thread flag.  The user may have clicked the Back button.
					if (pApp->m_bExitLicenseThread)
						goto ExitThread;

					if ((LONG)pllspi->InUse > (LONG)pllspi->Purchased)
					{
						pPage->FillListCtrl(pllspi->Product, (WORD)pllspi->InUse, (WORD)pllspi->Purchased);

						// Increment the unlicensed products counter.
						nProductCount++;
					}

					// Free embedded pointer.
					::LlsFreeMemory(pllspi->Product);

					pllspi++;
				}

				// Free memory allocated by the LLS API.
				status = ::LlsFreeMemory(lpbBuf);
				lpbBuf = NULL;

				ASSERT(NT_SUCCESS(status));
			}
			while (dwTotalEntries);

			// Close the LLS handle.
			status = ::LlsClose(hLls);

			// Check the exit thread flag.  The user may have clicked the Back button.
			if (pApp->m_bExitLicenseThread)
				goto ExitThread;

			ASSERT(NT_SUCCESS(status));

			// Show the user how many unlicensed products were found.
			if (nProductCount)
			{
				strText.Format(IDS_UNLICENSED_PRODUCTS, pApp->m_strEnterpriseServer);
				pPage->m_wndUnlicensedProducts.SetWindowText(strText);

				// Make the static text box the appropriate size.
				pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
															pPage->m_sizeSmallText.cx, 
															pPage->m_sizeSmallText.cy, 
														    SWP_NOMOVE | SWP_NOZORDER);

				// Make sure the list control is visible.
				pPage->m_wndProductList.ShowWindow(SW_SHOW);

				// Make sure the print button is visible.
				pPage->m_wndPrint.ShowWindow(SW_SHOW);
			}
			else
			{
				// Make the static text box the appropriate size.
				pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
															pPage->m_sizeLargeText.cx, 
															pPage->m_sizeLargeText.cy, 
														    SWP_NOMOVE | SWP_NOZORDER);

				// Display a message if no unlicensed products were found.
				strText.LoadString(IDS_NO_UNLICENSED_PRODUCTS);
				pPage->m_wndUnlicensedProducts.SetWindowText(strText);
			}

			// Enable the Back button.
			pSheet->SetWizardButtons(PSWIZB_BACK);

			CString strFinished;
			CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);

			// Change the text on the cancel button to "Done."
			strFinished.LoadString(IDS_DONE);
			pCancel->SetWindowText(strFinished);

			// Signal the event object.
			event.SetEvent();

			// Reset the pointer to the license thread.
			pApp->m_pLicenseThread = NULL;

			// Restore the normal cursor.
			pPage->PostMessage(WM_SETCURSOR);
		}

		return 0;

	ErrorMessage:
		// Check the exit thread flag.  The user may have clicked the Back button.
		if (pApp->m_bExitLicenseThread)
			goto ExitThread;

		// Make the static text box the appropriate size.
		pPage->m_wndUnlicensedProducts.SetWindowPos(&CWnd::wndTop, 0, 0, 
													pPage->m_sizeLargeText.cx, 
													pPage->m_sizeLargeText.cy, 
													SWP_NOMOVE | SWP_NOZORDER);

		// Create an error message based on the return value from LlsConnectEnterprise().
		switch (status)
		{
			case STATUS_NO_SUCH_DOMAIN:
				if (pApp->IsRemote())
					strText.Format(IDS_BAD_DOMAIN_NAME, strFocus);
				else
					strText.LoadString(IDS_UNAVAILABLE);
				break;

			case STATUS_ACCESS_DENIED:
				if (pApp->IsRemote())
					strText.Format(IDS_ACCESS_DENIED, strFocus);
				else
					strText.LoadString(IDS_LOCAL_ACCESS_DENIED);
				break;

			case RPC_NT_SERVER_UNAVAILABLE:
				strText.Format(IDS_SERVER_UNAVAILABLE);
				break;

			default:
				if (pApp->IsRemote())
					strText.Format(IDS_NO_LICENSE_INFO_REMOTE, strFocus);
				else
					strText.LoadString(IDS_NO_LICENSE_INFO_LOCAL);
		}

		// Display an error message if LlsProductEnum() fails.
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);

		// Enable the Back button.
		pSheet->SetWizardButtons(PSWIZB_BACK);

		// Signal the event object.
		event.SetEvent();

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		// Restore the normal cursor.
		pPage->PostMessage(WM_SETCURSOR);

		return 1;

	ExitThread:
		// Signal the event object.
		event.SetEvent();

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		return 2;
	}
	catch(...)
	{
		// Signal the event object.
		event.SetEvent();

		CString strText;

		// Display an error message.
		strText.LoadString(IDS_GENERIC_ERROR);
		pPage->m_wndUnlicensedProducts.SetWindowText(strText);

		// Reset the pointer to the license thread.
		pApp->m_pLicenseThread = NULL;

		// Restore the normal cursor.
		pPage->PostMessage(WM_SETCURSOR);

		return 3;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage4 property page

CLicCompWizPage4::CLicCompWizPage4()
: CPropertyPage(CLicCompWizPage4::IDD), m_ptPrint(0, 0), m_nHorzMargin(0), 
m_nVertMargin(0),m_ptOrg(0, 0), m_ptExt(0, 0), m_sizeSmallText(0, 0), 
m_sizeLargeText(0, 0)
{
	//{{AFX_DATA_INIT(CLicCompWizPage4)
	//}}AFX_DATA_INIT
	
	m_strCancel.Empty();
	m_pTabs = new INT[PRINT_COLUMNS];
}

CLicCompWizPage4::~CLicCompWizPage4()
{
	if (m_pTabs != NULL)
		delete[] m_pTabs;
}

void CLicCompWizPage4::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicCompWizPage4)
	DDX_Control(pDX, IDC_FLAG_BMP, m_wndPicture);
	DDX_Control(pDX, IDC_BUT_PRINT, m_wndPrint);
	DDX_Control(pDX, IDC_TEXT_UNCOMP_PRODUCTS, m_wndUnlicensedProducts);
	DDX_Control(pDX, IDC_LIST_PRODUCTS, m_wndProductList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicCompWizPage4, CPropertyPage)
	//{{AFX_MSG_MAP(CLicCompWizPage4)
	ON_BN_CLICKED(IDC_BUT_PRINT, OnPrintButton)
	ON_NOTIFY(NM_OUTOFMEMORY, IDC_LIST_PRODUCTS, OnListProductsOutOfMemory)
	ON_WM_DESTROY()
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CLicCompWizPage4::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;

	try
	{
		// Handle dialog messages
		while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
		  if(!IsDialogMessage(&msg))
		  {
			TranslateMessage(&msg);
			DispatchMessage(&msg);  
		  }
		}
	}
	catch(...)
	{
		TRACE(_T("Exception in CLicCompWizPage4::PumpMessages()\n"));
	}

}

BOOL CLicCompWizPage4::FillListCtrl(LPTSTR pszProduct, WORD wInUse, WORD wPurchased)
{
	TCHAR pszLicenses[BUFFER_SIZE];

	::wsprintf(pszLicenses, _T("%u"), wInUse - wPurchased);

	USHORT nIndex;
	LV_ITEM lvi;

	lvi.mask = LVIF_TEXT | LVIF_PARAM;
	lvi.iItem = 0;
	lvi.iSubItem = 0;
	lvi.lParam = MAKELONG(wInUse, wPurchased);
	lvi.pszText = pszProduct;

	if ((nIndex = (USHORT)m_wndProductList.InsertItem(&lvi)) != (USHORT)-1)
	{
		m_wndProductList.SetItemText(nIndex, 1, pszLicenses);
	}

	return TRUE;
}

BOOL CLicCompWizPage4::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// Set the header text for the list control.
	CRect rcList;

	m_wndProductList.GetWindowRect(&rcList);

	CString strColumnTitle;
	LV_COLUMN lvc;

	lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvc.fmt = LVCFMT_LEFT;

	USHORT nColumns = COLUMNS;
	UINT uStringID[COLUMNS] = {IDS_PRODUCTS_LIST, IDS_LICENSES_LIST};

	for (USHORT i = 0; i < nColumns; i++)
	{
		strColumnTitle.LoadString(uStringID[i]);
		lvc.pszText = strColumnTitle.GetBuffer(strColumnTitle.GetLength());
		lvc.cx = rcList.Width() / COLUMNS;

		m_wndProductList.InsertColumn(i, &lvc);

		strColumnTitle.ReleaseBuffer();
	}

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Store the text on the cancel button.
	CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);
	pCancel->GetWindowText(m_strCancel);

	CRect rcText;

	// Create the large and small extents for the static text control.
	m_wndUnlicensedProducts.GetWindowRect(&rcText);

	m_sizeSmallText.cx = rcText.right - rcText.left;
	m_sizeSmallText.cy = rcText.bottom - rcText.top;

	// Make the large extents match those for the list control.
	m_sizeLargeText.cx = rcList.right - rcList.left;
	m_sizeLargeText.cy = rcList.bottom - rcList.top;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLicCompWizPage4::OnListProductsOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AfxMessageBox(IDS_MEM_ERROR, MB_OK | MB_ICONSTOP);
	
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Let the license thread know it's supposed to quit.
	pApp->NotifyLicenseThread(TRUE);

	*pResult = 0;
}

void CLicCompWizPage4::OnPrintButton() 
{
	CDC dc;
	CPrintDialog dlg(FALSE, 
					 PD_ALLPAGES | PD_USEDEVMODECOPIESANDCOLLATE | 
					 PD_NOPAGENUMS | PD_HIDEPRINTTOFILE | 
					 PD_NOSELECTION, 
					 this);

	if (dlg.DoModal() == IDOK)
	{
		CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
		m_wndPrint.RedrawWindow();

		DOCINFO di;
		CString strDocName;

		strDocName.Format(IDS_DOC_NAME, pApp->m_strEnterpriseServer);

		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = strDocName.GetBuffer(BUFFER_SIZE);
		di.lpszOutput = NULL;

		if (dc.Attach(dlg.GetPrinterDC()))
		{
			PrepareForPrinting(dc);
			dc.StartDoc(&di);
			PrintReport(dc);
			dc.EndDoc();
			dc.DeleteDC();
			::GlobalFree(dlg.m_pd.hDevNames);
			::GlobalFree(dlg.m_pd.hDevMode);
		}
	}
}

BOOL CLicCompWizPage4::PrepareForPrinting(CDC& dc)
{
	// Create various fonts...
	CString strFont;

	// Create a heading font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontHeading.CreatePointFont(FONT_SIZE_HEADING, strFont, &dc);

	// Create a bold, underlined header font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontHeader.CreatePointFont(FONT_SIZE, strFont, &dc);

	LOGFONT lf;
	m_fontHeader.GetLogFont(&lf);
	m_fontHeader.DeleteObject();
	lf.lfUnderline = TRUE;
	m_fontHeader.CreateFontIndirect(&lf);

	// Create a footer font.
	strFont.LoadString(IDS_FONT_BOLD);
	m_fontFooter.CreatePointFont(FONT_SIZE_FOOTER, strFont, &dc);

	// Create a default font.
	strFont.LoadString(IDS_FONT);
	m_fontNormal.CreatePointFont(FONT_SIZE, strFont, &dc);

	// Get the text metrics for each font.
	CFont* pOldFont = dc.SelectObject(&m_fontHeading);
	dc.GetTextMetrics(&m_tmHeading);

	dc.SelectObject(&m_fontHeader);
	dc.GetTextMetrics(&m_tmHeader);

	dc.SelectObject(&m_fontFooter);
	dc.GetTextMetrics(&m_tmFooter);

	dc.SelectObject(&m_fontNormal);
	dc.GetTextMetrics(&m_tmNormal);

	// Select the original font back in to the device context.
	dc.SelectObject(pOldFont);

	// Set the horizontal and vertical margins.
	m_nHorzMargin = (LONG)(dc.GetDeviceCaps(LOGPIXELSX) * HORZ_MARGIN);
	m_nVertMargin = (LONG)(dc.GetDeviceCaps(LOGPIXELSY) * VERT_MARGIN);

	// Get the printable page offsets for the origin.
	m_ptOrg.x = dc.GetDeviceCaps(PHYSICALOFFSETX);
	m_ptOrg.y = dc.GetDeviceCaps(PHYSICALOFFSETY);

	dc.SetWindowOrg(m_ptOrg);

	m_ptOrg.x += m_nHorzMargin;
	m_ptOrg.y += m_nVertMargin;

	// Get the printable page offsets for the page extents.
	m_ptExt.x = dc.GetDeviceCaps(PHYSICALWIDTH) -  m_ptOrg.x;
	m_ptExt.y = dc.GetDeviceCaps(PHYSICALHEIGHT) - m_ptOrg.y;

	dc.SetViewportOrg(m_ptOrg);

	CalculateTabs(dc);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintReport(CDC& dc)
{
	// Set the starting point for printing.
	m_ptPrint.x = m_ptPrint.y = 0;

	// Prepare to print a heading.
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	CString strHeading;

	CFont* pOldFont = dc.SelectObject(&m_fontHeading);
	strHeading.Format(IDS_DOC_NAME, pApp->m_strEnterpriseServer);

	dc.StartPage();

	CRect rc(m_ptPrint.x, m_ptPrint.y, m_ptExt.x - m_ptOrg.x, m_tmHeading.tmHeight);

	// Calculate the size of the rectangle needed to draw the text.
	m_ptPrint.y += dc.DrawText(strHeading, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	// Normalize the rectangle.
	rc.NormalizeRect();
	
	// Add a blank line below the heading.
	m_ptPrint.y += m_tmHeading.tmHeight;

	// Move the right side of the rectangle out to the right margin so text is properly centered.
	rc.right = m_ptExt.x - m_ptOrg.x;

	// Draw the text in the rectangle.
	dc.DrawText(strHeading, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	dc.SelectObject(pOldFont);

	PrintPages(dc, 100);

	// Delete the fonts.
	m_fontNormal.DeleteObject();
	m_fontHeader.DeleteObject();
	m_fontFooter.DeleteObject();
	m_fontHeading.DeleteObject();

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPageHeader(CDC& dc)
{
	CFont* pOldFont = dc.SelectObject(&m_fontHeader);

	dc.StartPage();

	CString strHeader, strProducts, strLicenses, strPurchased, strUsed;
	strProducts.LoadString(IDS_PRODUCTS);
	strLicenses.LoadString(IDS_LICENSES);
	strPurchased.LoadString(IDS_PURCHASED);
	strUsed.LoadString(IDS_USED);
	strHeader.Format(_T("%s\t%s\t%s\t%s"), strProducts, strLicenses,
										   strPurchased, strUsed);

	dc.TabbedTextOut(m_ptPrint.x, m_ptPrint.y, strHeader, PRINT_COLUMNS, m_pTabs, 0);

	m_ptPrint.y += ((m_tmHeader.tmHeight + m_tmHeader.tmExternalLeading) * 2);

	dc.SelectObject(pOldFont);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPageFooter(CDC& dc, USHORT nPage)
{
	CFont* pOldFont = dc.SelectObject(&m_fontFooter);

	CString strFooter;
	CTime time(CTime::GetCurrentTime());

	strFooter.Format(IDS_PAGE_DATE, nPage, time.Format(IDS_FMT_DATE));

	CRect rc(m_ptPrint.x, m_ptExt.y - m_nVertMargin, m_ptOrg.x, m_tmFooter.tmHeight);

	// Calculate the size of the rectangle needed to draw the text.
	m_ptPrint.y += dc.DrawText(strFooter, &rc, DT_CALCRECT | DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	// Move the right side of the rectangle out to the right margin so text is properly centered.
	rc.right = m_ptExt.x - m_ptOrg.x;

	// Draw the text in the rectangle.
	dc.DrawText(strFooter, &rc, DT_EXTERNALLEADING | DT_CENTER | DT_WORDBREAK | DT_NOCLIP);

	dc.EndPage();

	dc.SelectObject(pOldFont);

	return TRUE;
}

BOOL CLicCompWizPage4::PrintPages(CDC& dc, UINT nStart)
{
	CFont* pOldFont = dc.SelectObject(&m_fontNormal);

	UINT nPage = 1;
	UINT nItems = m_wndProductList.GetItemCount();

	// Print the initial header.
	PrintPageHeader(dc);

	DWORD dwParam = 0;
	CString strTextOut;

	for (UINT i = 0; i < nItems; i++)
	{
		dwParam = (DWORD)m_wndProductList.GetItemData(i);

		CString strProduct = m_wndProductList.GetItemText(i, 0);

		CSize sizeProduct = dc.GetTextExtent(strProduct);

		if (sizeProduct.cx > m_pTabs[0] - (m_tmNormal.tmAveCharWidth * TAB_WIDTH))
			TruncateText(dc, strProduct);

		// Format the output text.
		strTextOut.Format(_T("%s\t%s\t%u\t%u"), strProduct,
												m_wndProductList.GetItemText(i, 1),
												HIWORD(dwParam), LOWORD(dwParam));

		dc.TabbedTextOut(m_ptPrint.x, m_ptPrint.y, strTextOut, PRINT_COLUMNS, m_pTabs, 0);

		// Calculate the vertical position for the next line of text.
		m_ptPrint.y += m_tmNormal.tmHeight + m_tmNormal.tmExternalLeading;

		if ((m_ptPrint.y + m_ptOrg.y) >= m_ptExt.y)
		{
			PrintPageFooter(dc, nPage++);

			// Reset the printing position.
			m_ptPrint.y = 0;

			PrintPageHeader(dc);
		}
	}

	// Print the final footer.
	PrintPageFooter(dc, (USHORT)nPage);

	dc.SelectObject(pOldFont);

	return TRUE;
}

void CLicCompWizPage4::TruncateText(CDC& dc, CString& strInput)
{
	CString strText, strEllipsis;

	USHORT nLen, nChars = 0;
	UINT nMaxWidth = m_pTabs[0] - (m_tmNormal.tmAveCharWidth * TAB_WIDTH);
	nLen = (USHORT)strInput.GetLength();

	strEllipsis.LoadString(IDS_ELLIPSIS);

	CSize sizeText = dc.GetTextExtent(strInput);

	// Keep lopping off characters until the string is short enough.
	while ((UINT)sizeText.cx > nMaxWidth)
	{
		strText = strInput.Left(nLen - nChars++);
		sizeText = dc.GetTextExtent(strText);
	}

	// Remove the last characters and replace them with an ellipsis.
	ASSERT(strText.GetLength() > strEllipsis.GetLength());
	strInput = strText.Left(strText.GetLength() - strEllipsis.GetLength()) + strEllipsis;
}

BOOL CLicCompWizPage4::CalculateTabs(CDC& dc)
{
	INT nTotalExt = 0;
	INT nTabSize = TAB_WIDTH * m_tmHeader.tmAveCharWidth;

	UINT uStrIds[] = {IDS_LICENSES, IDS_PURCHASED, IDS_USED};

	m_pTabs[0] = 0;

	for (USHORT i = 1; i < PRINT_COLUMNS; i++)
	{
		CString strText;

		strText.LoadString(uStrIds[i - 1]);
		// Get the text extent for each string.
		m_pTabs[i] = dc.GetTextExtent(strText).cx;
		// Keep a running total of the extents.
		nTotalExt += m_pTabs[i];
	}

	// Add tab space between columns.
	nTotalExt += nTabSize * (PRINT_COLUMNS - 2);

	// The second column will begin at the difference between the right
	// margin and the total extent.
	m_pTabs[0] = m_ptExt.x - m_ptOrg.x - nTotalExt;

	// Now set the actual tab positions in the array.
	for (i = 1; i < PRINT_COLUMNS; i++)
	{
		m_pTabs[i] += m_pTabs[i - 1] + nTabSize;
	}

	return TRUE;
}

LRESULT CLicCompWizPage4::OnWizardBack() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Let the license thread know it's time to quit.
	pApp->NotifyLicenseThread(TRUE);

	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	// Set the cancel button text back to "Cancel."
	CButton* pCancel = (CButton*)pSheet->GetDlgItem(IDCANCEL);
	pCancel->SetWindowText(m_strCancel);

	if (pSheet->m_Page1.m_nRadio == 0)
		return IDD_PROPPAGE1;
	else
		return CPropertyPage::OnWizardBack();
}

void CLicCompWizPage4::OnDestroy() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	pApp->NotifyLicenseThread(TRUE);
	PumpMessages();

	CPropertyPage::OnDestroy();
}

BOOL CLicCompWizPage4::OnSetActive() 
{
	CLicCompWizSheet* pSheet = (CLicCompWizSheet*)GetParent();

	pSheet->SetWizardButtons(PSWIZB_BACK);

	// Hide the list control and clear it.
	m_wndProductList.ShowWindow(SW_HIDE);
	m_wndProductList.DeleteAllItems();

	// Hide the print button.
	m_wndPrint.ShowWindow(SW_HIDE);

	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	// Make sure the last thread has terminated before starting a new one.
	if (pApp->m_pLicenseThread != NULL)
	{
		pApp->NotifyLicenseThread(TRUE);

		CEvent event(TRUE, TRUE, pszLicenseEvent);
		CSingleLock lock(&event);

		lock.Lock();
	}

	// Keep a pointer to the thread so we can find out if it's still running.
	pApp->m_pLicenseThread = AfxBeginThread((AFX_THREADPROC)GetLicenseInfo, (LPVOID)this);

	return CPropertyPage::OnSetActive();
}

LRESULT CLicCompWizPage3::OnWizardNext() 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	m_wndEnterprise.GetWindowText(pApp->m_strEnterprise);

	// Trim off any white space in the enterprise name.
	pApp->m_strEnterprise.TrimLeft();
	pApp->m_strEnterprise.TrimRight();

	if (pApp->m_strEnterprise.IsEmpty() ||
		pApp->m_strEnterprise.Find(_T("\\\\")) != -1)
	{
		AfxMessageBox(IDS_SPECIFY_DOMAIN, MB_OK | MB_ICONEXCLAMATION);
		return IDD;
	}
	
	return CPropertyPage::OnWizardNext();
}

BOOL CLicCompWizPage4::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	if (pApp->m_pLicenseThread == NULL)	
	{
		return CPropertyPage::OnSetCursor(pWnd, nHitTest, message);
	}
	else
	{
		// Restore the wait cursor if the thread is running.
		RestoreWaitCursor();

		return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwizsht.h ===
// LCWizSht.h : header file
//
// This class defines custom modal property sheet 
// CLicCompWizSheet.
 
#ifndef __LCWIZSHT_H__
#define __LCWIZSHT_H__

#include "LCWizPgs.h"

/////////////////////////////////////////////////////////////////////////////
// CLicCompWizSheet

class CLicCompWizSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CLicCompWizSheet)

// Construction
public:
	CLicCompWizSheet(CWnd* pParentWnd = NULL);

// Data members
public:
	CLicCompWizPage1 m_Page1;
	CLicCompWizPage3 m_Page3;
	CLicCompWizPage4 m_Page4;
	HICON m_hIcon;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLicCompWizSheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CLicCompWizSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __LCWIZSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    llsapi.h

Abstract:

    License logging server's RPC API's.

Author:

    Arthur Hanson (arth) 21-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;


typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;


typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;


typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;



#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#define LlsConnect LlsConnectW
#else
#define LlsConnect LlsConnectA
#endif

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );


NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif
//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif


NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif


#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")

#define REG_VALUE_NAME   TEXT("DisplayName")
#define REG_VALUE_MODE   TEXT("Mode")
#define REG_VALUE_FLIP   TEXT("FlipAllow")
#define REG_VALUE_LIMIT  TEXT("ConcurrentLimit")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\lcwizpgs.h ===
// LCWizPgs.h : header file
//

#ifndef __LCWIZPGS_H__
#define __LCWIZPGS_H__

#include "NetTree.h"
#include "FinPic.h"

#define HORZ_MARGIN 1		// Inches
#define VERT_MARGIN 1.25	// Inches


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage1 dialog

class CLicCompWizPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage1)

// Construction
public:
	CLicCompWizPage1();
	~CLicCompWizPage1();

// Dialog Data

	CFont m_fontBold;

	//{{AFX_DATA(CLicCompWizPage1)
	enum { IDD = IDD_PROPPAGE1 };
	CStatic	m_wndWelcome;
	int		m_nRadio;
	CString	m_strText;
	//}}AFX_DATA

// Constants
	enum
	{
		BOLD_WEIGHT = 300
	};


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage1)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage1)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage3 dialog

class CLicCompWizPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage3)

// Construction
public:
	CLicCompWizPage3();
	~CLicCompWizPage3();

// Dialog Data
protected:
	BOOL m_bExpandedOnce;

	//{{AFX_DATA(CLicCompWizPage3)
	enum { IDD = IDD_PROPPAGE3 };
	CStatic	m_wndTextSelectDomain;
	CStatic	m_wndTextDomain;
	CEdit	m_wndEnterprise;
	CNetTreeCtrl	m_wndTreeNetwork;
	//}}AFX_DATA

	// Constants
	enum
	{
		BUFFER_SIZE = 0x100
	};


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	inline CEdit& GetEnterpriseEdit() {return m_wndEnterprise;}

protected:

	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage3)
	afx_msg void OnSelChangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeEditEnterprise();
	afx_msg void OnNetworkTreeOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CLicCompWizPage4 dialog

class CLicCompWizPage4 : public CPropertyPage
{
	DECLARE_DYNCREATE(CLicCompWizPage4)

// Construction
public:
	CLicCompWizPage4();
	~CLicCompWizPage4();

// Dialog Data
protected:
	CFont m_fontNormal, m_fontHeader, m_fontFooter, m_fontHeading;
	TEXTMETRIC m_tmNormal, m_tmHeader, m_tmFooter, m_tmHeading;
	CPoint m_ptPrint, m_ptOrg, m_ptExt;
	LONG m_nHorzMargin, m_nVertMargin;
	LPINT m_pTabs;
	CString m_strCancel;
	CSize m_sizeSmallText, m_sizeLargeText;

	//{{AFX_DATA(CLicCompWizPage4)
	enum { IDD = IDD_PROPPAGE4 };
	CFinalPicture	m_wndPicture;
	CButton	m_wndPrint;
	CStatic	m_wndUnlicensedProducts;
	CListCtrl	m_wndProductList;
	//}}AFX_DATA

	// Constants
	enum
	{
		LLS_PREFERRED_LENGTH = 500,

		COLUMNS = 2,
		PRINT_COLUMNS = 4,
		TAB_WIDTH = 3,

		BUFFER_SIZE =  0x100,

		FONT_SIZE = 100,
		FONT_SIZE_HEADING = 140,
		FONT_SIZE_FOOTER = 80,
	};

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLicCompWizPage4)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL FillListCtrl(LPTSTR pszProduct, WORD wInUse, WORD wPurchased);
	static UINT GetLicenseInfo(LPVOID pParam);

protected:
	BOOL PrintReport(CDC& dc);
	BOOL PrintPages(CDC& dc, UINT nStart);
	BOOL PrepareForPrinting(CDC& dc);
	BOOL PrintPageHeader(CDC& dc);
	BOOL PrintPageFooter(CDC& dc, USHORT nPage);
	BOOL CalculateTabs(CDC& dc);
	void TruncateText(CDC& dc, CString& strText);
	void PumpMessages();

	// Generated message map functions
	//{{AFX_MSG(CLicCompWizPage4)
	virtual BOOL OnInitDialog();
	afx_msg void OnPrintButton();
	afx_msg void OnListProductsOutOfMemory(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif // __LCWIZPGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	LCWiz.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef ASSERT
#  undef ASSERT
#endif
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxtempl.h>		// MFC template classes
#include <afxmt.h>			// MFC synchronization classes
#include <winnetwk.h>
#include <llsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LCWiz.rc
//
#define IDP_OLE_INIT_FAILED             100
#define IDD_LCWIZ_DIALOG                102
#define IDS_PROPSHT_CAPTION             103
#define IDS_TEXT_PAGE1                  104
#define IDS_TEXT_PAGE2                  105
#define IDS_NET_ERROR                   106
#define IDS_NET_NO_SERVERS              107
#define IDS_PRODUCTS                    108
#define IDS_LICENSES                    109
#define IDS_FONT                        110
#define IDS_FONT_BOLD                   111
#define IDS_UNLICENSED_PRODUCTS         112
#define IDS_FMT_DATE                    113
#define IDS_NO_LICENSE_INFO             114
#define IDS_NO_LICENSE_INFO_LOCAL       114
#define IDS_DONE                        115
#define IDS_ERROR                       116
#define IDS_TREE_ROOT                   117
#define IDS_WORKING                     118
#define IDS_DOC_NAME                    119
#define IDS_PAGE_DATE                   120
#define IDS_PURCHASED                   121
#define IDS_USED                        122
#define IDS_PRODUCTS_LIST               123
#define IDS_LICENSES_LIST               124
#define IDS_ENUM_PRODUCTS               125
#define IDS_WELCOME                     126
#define IDS_MEM_ERROR                   127
#define IDR_MAINFRAME                   128
#define IDS_NO_UNLICENSED_PRODUCTS      128
#define IDD_PROPPAGE1                   129
#define IDS_ELLIPSIS                    129
#define IDD_PROPPAGE2                   130
#define IDS_SUBKEY                      130
#define IDD_PROPPAGE3                   131
#define IDS_REG_VALUE                   131
#define IDD_PROPPAGE4                   132
#define IDS_BAD_DOMAIN_NAME             132
#define IDS_SERVER_UNAVAILABLE          133
#define IDB_NET_TREE                    134
#define IDS_NO_LICENSE_INFO_REMOTE      134
#define IDB_PAGE_ART                    135
#define IDS_ACCESS_DENIED               135
#define IDS_GENERIC_ERROR               136
#define IDS_REG_VALUE_USER              137
#define IDS_REG_VALUE_DOMAIN            138
#define IDS_DOMAIN_USER                 139
#define IDB_END_FLAG                    140
#define IDS_ADMIN                       140
#define IDS_LOCAL_ACCESS_DENIED         141
#define IDS_UNAVAILABLE                 142
#define IDS_SERVER_UNAVAILABLE_LOCAL    143
#define IDS_SPECIFY_DOMAIN              144
#define IDS_BAD_VERSION                 145
#define IDC_PAINT_BOX                   1000
#define IDC_TEXT                        1003
#define IDC_TREE_NETWORK                1007
#define IDC_CHECK_LOCAL_COMPUTER        1008
#define IDC_EDIT_ENTERPRISE             1018
#define IDC_LIST_PRODUCTS               1019
#define IDC_TEXT_COMP_PRODUCTS          1023
#define IDC_TEXT_UNCOMP_PRODUCTS        1024
#define IDC_BUT_PRINT                   1025
#define IDC_RADIO_LOCAL_COMPUTER        1026
#define IDC_RADIO_DOMAIN                1027
#define IDC_TEXT_DOMAIN                 1028
#define IDC_TEXT_SELECT_DOMAIN          1029
#define IDC_WELCOME                     1031
#define IDC_FLAG_BMP                    1033

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        141
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\nettree.cpp ===
// NetTree.cpp : implementation file
//

#include "stdafx.h"
#include "NetTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global variables

extern TCHAR pszTreeEvent[];


/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl

CNetTreeCtrl::CNetTreeCtrl()
: m_pThread(NULL), m_bExitThread(FALSE), m_event(TRUE, TRUE, pszTreeEvent)
{
	// Get a handle to the process heap
	m_hHeap = ::GetProcessHeap();

	ASSERT(m_hHeap != NULL);
}

CNetTreeCtrl::~CNetTreeCtrl()
{
	// Make sure the thread knows it's time to terminate.
	NotifyThread(TRUE);

	// Create an event object to match the tree thread event object.
	CEvent event(TRUE, TRUE, pszTreeEvent);
	
	// Create a lock object for the event object.
	CSingleLock lock(&event);

	// Lock the lock object and make the main thread wait for the
	// threads to signal their event objects.
	lock.Lock();

	// Free all of the pointers to LPTSTRs in the list
	POSITION pos = m_ptrlistStrings.GetHeadPosition();

	while (pos != NULL)
	{
		// Memory deallocation fails if there's a null char
		// at the end of the string.
		LPTSTR psz = m_ptrlistStrings.GetNext(pos);
		*(::_tcslen(psz) + psz) = (TCHAR)0xFD;
		delete[] psz;
	}

	// Free all of the pointers to NETRESOURCE structs in the list
	pos = m_ptrlistContainers.GetHeadPosition();

	while (pos != NULL)
	{
		delete m_ptrlistContainers.GetNext(pos);
	}
}


BEGIN_MESSAGE_MAP(CNetTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CNetTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
	ON_WM_SETCURSOR()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Static member functions

UINT CNetTreeCtrl::FillTree(LPVOID pParam)
{
	CEvent event(TRUE, TRUE, pszTreeEvent);
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();
	PTREEINFO pti = (PTREEINFO)pParam;
	CNetTreeCtrl* pTree = (CNetTreeCtrl*)pti->pTree;
	BOOL bResult = FALSE;
	DWORD dwEntries = 0xFFFFFFFF;
	LPVOID lpvBuffer = NULL;
	HANDLE hEnum = NULL;

	// Because this function may call itself, keep a usage count
	// so that pti is freed only when the first instance returns.
	static USHORT uUsage = 0;

	// Keep a handle to the heap in case the CNetTreeCtrl object
	// goes away before the thread ends.
	HANDLE hHeap = pTree->m_hHeap;
	DWORD dwResult;
	LPNETRESOURCE pnrRoot;
	HTREEITEM hTreeItem, hTreeExpand;

	hTreeItem = hTreeExpand = NULL;

	try
	{
		// Unsignal the event object.
		event.ResetEvent();

		// Show the wait cursor
		pTree->BeginWaitCursor();

		// Exit if the handle to the heap is invalid.
		if (hHeap == NULL)
			goto ExitFunction;

		if (pti->hTreeItem == TVI_ROOT)
		{
			pnrRoot = NULL;
			if (pTree->m_imagelist.Create(IDB_NET_TREE, 16, 3, CNetTreeCtrl::IMG_MASK))
			{
				pTree->SetImageList(&(pTree->m_imagelist), TVSIL_NORMAL);
				pTree->m_imagelist.SetBkColor(CLR_NONE);
			}
		}
		else
			pnrRoot = (LPNETRESOURCE)pTree->GetItemData(pti->hTreeItem);

		// Get an enumeration handle.
		if ((dwResult = ::WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY, 
								  RESOURCEUSAGE_CONTAINER, pnrRoot, &hEnum)) != NO_ERROR)
		{
			// Exit if WNetOpenEnum fails.
			dwResult = ::GetLastError();
			goto ExitFunction;
		}

		// Allocate a buffer for enumeration.
		if ((lpvBuffer = ::HeapAlloc(hHeap, HEAP_ZERO_MEMORY, pti->dwBufSize)) == NULL)
			// Exit if memory allocation failed
			goto ExitFunction;

		// Retrieve a block of network entries.
		while ((dwResult = ::WNetEnumResource(hEnum, &dwEntries, lpvBuffer, &(pti->dwBufSize))) != ERROR_NO_MORE_ITEMS)
		{
			// See if it's time to exit.
			if (pTree->m_bExitThread)
			{
				pTree->NotifyThread(FALSE);
				bResult = TRUE;
				goto ExitFunction;
			}

			// Exit if WNetEnumResource failed.
			if (dwResult != NO_ERROR)
			{
				dwResult = ::GetLastError();
				goto ExitFunction;
			}

			LPNETRESOURCE pnrLeaf = (LPNETRESOURCE)lpvBuffer;
			TV_INSERTSTRUCT tviLeaf;

			// Fill in the TV_INSERTSTRUCT members.
			tviLeaf.hParent = pti->hTreeItem;
			tviLeaf.hInsertAfter = TVI_SORT;
			tviLeaf.item.hItem = NULL;
			tviLeaf.item.state = 0;
			tviLeaf.item.stateMask = 0;
			tviLeaf.item.cchTextMax = 0;
			tviLeaf.item.iSelectedImage = 0;

			// Set the correct image for the leaf.
			switch (pnrLeaf->dwDisplayType)
			{
				case RESOURCEDISPLAYTYPE_DOMAIN:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_DOMAIN;
					break;
					
				case RESOURCEDISPLAYTYPE_SERVER:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_SERVER;
					break;

				default:
					tviLeaf.item.iImage = tviLeaf.item.iSelectedImage = CNetTreeCtrl::IMG_ROOT;
			}

			// Fool the tree into thinking that this leaf has children
			// since we don't know initially.
#if 0
			if (pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
#else
			if (pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_DOMAIN ||
				pnrLeaf->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
#endif
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 0;
			}
			else
			{
				tviLeaf.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				tviLeaf.item.cChildren = 1;
			}

			// Add leaves to the branch.
			for (DWORD i = 0; i < dwEntries; i++)
			{
				// See if it's time to exit.
				if (pTree->m_bExitThread)
				{
					pTree->NotifyThread(FALSE);
					bResult = TRUE;
					goto ExitFunction;
				}

				// Create a permanent NETRESOURCE struct for later use.
				LPNETRESOURCE pnrTemp = new NETRESOURCE;
				pTree->m_ptrlistContainers.AddTail(pnrTemp);

				::CopyMemory(pnrTemp, pnrLeaf, sizeof(NETRESOURCE));

				// Initialize members.
				pnrTemp->lpLocalName = NULL; 
				pnrTemp->lpRemoteName = NULL; 
				pnrTemp->lpComment = NULL; 
				pnrTemp->lpProvider = NULL; 

				if (pnrLeaf->lpRemoteName != NULL)
				{
					pnrTemp->lpRemoteName = new TCHAR[::_tcslen(pnrLeaf->lpRemoteName) + 1];
					::_tcscpy(pnrTemp->lpRemoteName, pnrLeaf->lpRemoteName);
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpRemoteName);
				}

				if (pnrLeaf->lpProvider != NULL)
				{
					pnrTemp->lpProvider = new TCHAR[::_tcslen(pnrLeaf->lpProvider) + 1];
					::_tcscpy(pnrTemp->lpProvider, pnrLeaf->lpProvider);
					pTree->m_ptrlistStrings.AddTail(pnrTemp->lpProvider);
				}

				// Increment the buffer pointer.
				pnrLeaf++;

				// Use "Enterprise" as the item text if this is the root.
				if (pti->hTreeItem == TVI_ROOT)
				{
					CString strRoot;

					strRoot.LoadString(IDS_TREE_ROOT);
					tviLeaf.item.pszText = new TCHAR[strRoot.GetLength() + 1];
					::_tcscpy(tviLeaf.item.pszText, (LPCTSTR)strRoot);
				}
				else if (pnrTemp->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
				{
					// Skip the initial backslashes before adding the server
					// name to the tree.
					tviLeaf.item.pszText = pnrTemp->lpRemoteName + 2;
				}
				else
					tviLeaf.item.pszText = pnrTemp->lpRemoteName;

				tviLeaf.item.lParam = (LPARAM)(LPVOID)pnrTemp;

				// Make sure the pointer to the tree control is still valid.
				if (::IsWindow(pTree->m_hWnd))
				{
					hTreeItem = pTree->InsertItem(&tviLeaf);
				}
				else	// Otherwise, exit the thread.
				{
					bResult = TRUE;
					goto ExitFunction;
				}

				// Delete the string allocated for the root node text.
				if (pti->hTreeItem == TVI_ROOT)
					delete tviLeaf.item.pszText;

				// See if the lpRemoteName member is equal to the default domain
				// name.
#if 0
				if (!_tcscmp(pnrTemp->lpRemoteName, pApp->m_strDomain) ||
#else
				if (
#endif
					pti->hTreeItem == TVI_ROOT)
				{
					// Store the handle.
					hTreeExpand = hTreeItem;
				}

				// Select the name of the license server in the tree.
#if 0
				if (!_tcsicmp(pnrTemp->lpRemoteName, pApp->m_strEnterpriseServer))
#else
				if (!_tcsicmp(pnrTemp->lpRemoteName, pApp->m_strDomain))
#endif
				{
					pTree->SelectItem(hTreeItem);
					pTree->EnsureVisible(hTreeItem);
					pTree->SetFocus();
				}
			}

			// Everything went all right.
			bResult = TRUE;
		}

		// Expand the branch but only if it isn't the root.
		// The root item thinks it has children, but really doesn't the first time through.
		if (pti->hTreeItem != TVI_ROOT && pTree->ItemHasChildren(pti->hTreeItem))
		{
			// Indicate that the branch has been expanded once.
			pTree->SetItemState(pti->hTreeItem, TVIS_EXPANDEDONCE, TVIS_EXPANDEDONCE);
			pTree->Expand(pti->hTreeItem, TVE_EXPAND);
		}

		// Fill the branch for the current domain if the bExpand member is TRUE.
		if (hTreeExpand != NULL && pti->bExpand)
		{
			TREEINFO ti;

			ti.hTreeItem = hTreeExpand;
			ti.dwBufSize = pti->dwBufSize;
			ti.pTree = pti->pTree;
			ti.bExpand = TRUE;

			// Increment the usage count.
			uUsage++;

			FillTree((LPVOID)&ti);

			// Decrement the usage count.
			uUsage--;
		}
		
	ExitFunction:
		// Display a message if an error occurred.
		if (!bResult)
			pTree->ErrorHandler(dwResult);

		// Close the enumeration handle.
		if (hEnum != NULL)
			if (!(bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer only if the usage count is zero.
		if (uUsage == 0)
			delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Make sure the tree control still exists before posting a message.
		if (::IsWindow(pTree->m_hWnd))
			pTree->PostMessage(WM_SETCURSOR);

		// Signal the event object.
		if (uUsage == 0)
			event.SetEvent();

		return (UINT)!bResult;
	}
	catch(...)
	{
		// Close the enumeration handle.
		if (hEnum != NULL)
			if (!(bResult = (::WNetCloseEnum(hEnum) == NO_ERROR)))
				dwResult = ::GetLastError();

		// Free memory allocated on the heap.
		if (lpvBuffer != NULL)
			::HeapFree(hHeap, 0, lpvBuffer);

		// Free the TREEINFO pointer
		delete pti;

		// Reset the thread pointer.
		pTree->m_pThread = NULL;

		// Turn off the wait cursor
		pTree->EndWaitCursor();

		// Signal the event object.
		event.SetEvent();

		return (UINT)2;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl member functions

BOOL CNetTreeCtrl::PopulateTree(BOOL bExpand /* = TRUE */, const HTREEITEM hParentBranch /* = TVI_ROOT */, 
								DWORD dwBufSize /* = BUFFER_SIZE */)
{
	PTREEINFO pti = new TREEINFO;

	pti->hTreeItem = hParentBranch;
	pti->dwBufSize = dwBufSize;
	pti->pTree = this;
	pti->bExpand = bExpand;

	// Don't begin a new thread until the last one has ended.
	if (m_pThread != NULL)
	{
		NotifyThread(TRUE);

		CEvent event(TRUE, TRUE, pszTreeEvent);
		CSingleLock lock(&event);

		// Wait.
		lock.Lock();
	}

	m_pThread = AfxBeginThread((AFX_THREADPROC)FillTree, (LPVOID)pti);

	return TRUE;
}

void CNetTreeCtrl::ErrorHandler(const DWORD dwCode)
{
	CString strError;
	BOOL bNetError = FALSE;

#ifdef _DEBUG
	switch (dwCode)
	{
		case ERROR_MORE_DATA:
			strError = "ERROR_MORE_DATA";
			break;

		case ERROR_INVALID_HANDLE:
			strError = "ERROR_INVALID_HANDLE";
			break;

		case ERROR_NOT_CONTAINER:
			strError = "ERROR_NOT_CONTAINER";
			break;

		case ERROR_INVALID_PARAMETER:
			strError = "ERROR_INVALID_PARAMETER";
			break;

		case ERROR_NO_NETWORK:
			strError = "ERROR_NO_NETWORK";
			break;

		case ERROR_EXTENDED_ERROR:
			strError = "ERROR_EXTENDED_ERROR";
			break;

		default:
		{
#endif // _DEBUG
			DWORD dwErrCode;
			CString strErrDesc, strProvider;
			LPTSTR pszErrDesc = strErrDesc.GetBuffer(MAX_STRING);
			LPTSTR pszProvider = strProvider.GetBuffer(MAX_STRING);

			if (::WNetGetLastError(&dwErrCode, pszErrDesc, MAX_STRING,
								   pszProvider, MAX_STRING) == NO_ERROR)
			{
				strErrDesc.ReleaseBuffer();
				strProvider.ReleaseBuffer();

				CString strErrMsg;

				// Don't display the WNetGetLastError message if dwErrCode == 0.
				if (dwErrCode)
				{	
					// Trim of any leading or trailing white space.
					strProvider.TrimRight();
					strProvider.TrimLeft();
					strErrDesc.TrimRight();
					strErrDesc.TrimLeft();
					strErrMsg.Format(IDS_NET_ERROR, strProvider, strErrDesc);
				}
				else
					strErrMsg.LoadString(IDS_NET_NO_SERVERS);
				
				MessageBox(strErrMsg, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);

				bNetError = TRUE;
			}
			else
				strError.LoadString(IDS_ERROR);
#ifdef _DEBUG
		}
	}
#endif // _DEBUG

	if (!bNetError)
		AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl functions

void CNetTreeCtrl::NotifyThread(BOOL bExit)
{
	CCriticalSection cs;

	if (cs.Lock())
	{
		m_bExitThread = bExit;
		cs.Unlock();
	}
}

void CNetTreeCtrl::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;

	try
	{
		// Handle dialog messages
		while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
		  if(!IsDialogMessage(&msg))
		  {
			TranslateMessage(&msg);
			DispatchMessage(&msg);  
		  }
		}
	}
	catch(...)
	{
		TRACE(_T("Exception in CNetTreeCtrl::PumpMessages()\n"));
	}

}

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl message handlers

void CNetTreeCtrl::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	// Exit and stop expansion if the thread is running.
	if (m_pThread != NULL)
	{
		*pResult = TRUE;
		return;
	}

	// Exit if this branch has been expanded once.
	if (!(pNMTreeView->itemNew.state & TVIS_EXPANDEDONCE))
	{
		// Add new leaves to the branch.
		if (pNMTreeView->itemNew.mask & TVIF_HANDLE)
		{
			PopulateTree(FALSE, pNMTreeView->itemNew.hItem);
			pNMTreeView->itemNew.mask |= TVIS_EXPANDEDONCE;
		}
	}
	
	*pResult = FALSE;
}

BOOL CNetTreeCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	CLicCompWizApp* pApp = (CLicCompWizApp*)AfxGetApp();

	if (m_pThread == NULL && pApp->m_pLicenseThread == NULL)	
	{
		return CTreeCtrl::OnSetCursor(pWnd, nHitTest, message);
	}
	else
	{
		// Restore the wait cursor if the thread is running.
		RestoreWaitCursor();

		return TRUE;
	}
}

void CNetTreeCtrl::OnDestroy() 
{
	NotifyThread(TRUE);
	PumpMessages();

	CTreeCtrl::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\transbmp.cpp ===
// transbmp.cpp : implementation of the CTransBmp class
//
// support for transparent CBitmap objects. Used in the CUserList class.
// Based on a class from MSDN 7/95
#include "stdafx.h"
#include "transbmp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Colors
#define rgbWhite RGB(255,255,255)
// Raster op codes
#define DSa     0x008800C6L
#define DSx     0x00660046L


/////////////////////////////////////////////////////////////////////////////
// CTransBmp construction/destruction

CTransBmp::CTransBmp()
{
    m_iWidth = 0;
    m_iHeight = 0;
	m_hbmMask = NULL;
}

CTransBmp::~CTransBmp()
{
	if (m_hbmMask != NULL) delete m_hbmMask;
}

void CTransBmp::GetMetrics()
{
    // Get the width and height
    BITMAP bm;
    GetObject(sizeof(bm), &bm);
    m_iWidth = bm.bmWidth;
    m_iHeight = bm.bmHeight;
}


int CTransBmp::GetWidth()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iWidth;
}

int CTransBmp::GetHeight()
{
    if ((m_iWidth == 0) || (m_iHeight == 0)){
        GetMetrics();
    }
    return m_iHeight;
}


void CTransBmp::CreateMask(CDC* pDC)
{
	m_hbmMask = new CBitmap;    
// Nuke any existing mask
    if (m_hbmMask) m_hbmMask->DeleteObject();

// Create memory DCs to work with
	CDC* hdcMask = new CDC;
	CDC* hdcImage = new CDC;

    hdcMask->CreateCompatibleDC(pDC);
    hdcImage->CreateCompatibleDC(pDC);

// Create a monochrome bitmap for the mask
    m_hbmMask->CreateBitmap(GetWidth(),
                               GetHeight(),
                               1,
                               1,
                               NULL);
// Select the mono bitmap into its DC
    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);
// Select the image bitmap into its DC
    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

// Set the transparency color to be the top-left pixel
    hdcImage->SetBkColor(hdcImage->GetPixel(0, 0));
// Make the mask
    hdcMask->BitBlt(0, 0,
             GetWidth(), GetHeight(),
             hdcImage,
             0, 0,
             SRCCOPY);
// clean up
    hdcMask->SelectObject(hbmOldMask);
    hdcImage->SelectObject(hbmOldImage);
    delete hdcMask;
    delete hdcImage;
}

// draw the transparent bitmap using the created mask
void CTransBmp::DrawTrans(CDC* pDC, int x, int y)
{
    if (m_hbmMask == NULL) CreateMask(pDC);

    int dx = GetWidth();
    int dy = GetHeight();

// Create a memory DC to do the drawing to
	CDC* hdcOffScr = new CDC;
	hdcOffScr->CreateCompatibleDC(pDC);

// Create a bitmap for the off-screen DC that is really
// color compatible with the destination DC.
	CBitmap hbmOffScr;
	hbmOffScr.CreateBitmap(dx, dy, 
						pDC->GetDeviceCaps(PLANES),
						pDC->GetDeviceCaps(BITSPIXEL),
						NULL);
                             
// Select the buffer bitmap into the off-screen DC
    HBITMAP hbmOldOffScr = (HBITMAP)hdcOffScr->SelectObject(hbmOffScr);

// Copy the image of the destination rectangle to the
// off-screen buffer DC so we can play with it
    hdcOffScr->BitBlt(0, 0, dx, dy, pDC, x, y, SRCCOPY);

// Create a memory DC for the source image
	CDC* hdcImage = new CDC;
	hdcImage->CreateCompatibleDC(pDC);

    CBitmap* hbmOldImage = hdcImage->SelectObject(CBitmap::FromHandle((HBITMAP)m_hObject));

    // Create a memory DC for the mask
    CDC* hdcMask = new CDC;
	hdcMask->CreateCompatibleDC(pDC);

    CBitmap* hbmOldMask = hdcMask->SelectObject(m_hbmMask);

    // XOR the image with the destination
    hdcOffScr->SetBkColor(rgbWhite);
    hdcOffScr->BitBlt(0, 0, dx, dy ,hdcImage, 0, 0, DSx);
    // AND the destination with the mask
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcMask, 0,0, DSa);
    // XOR the destination with the image again
    hdcOffScr->BitBlt(0, 0, dx, dy, hdcImage, 0, 0, DSx);

    // Copy the resultant image back to the screen DC
    pDC->BitBlt(x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

    // Tidy up
    hdcOffScr->SelectObject(hbmOldOffScr);
    hdcImage->SelectObject(hbmOldImage);
    hdcMask->SelectObject(hbmOldMask);

	delete hdcOffScr;
	delete hdcImage;
	delete hdcMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\nettree.h ===
// NetTree.h : header file
//

#include "lcwiz.h"

/////////////////////////////////////////////////////////////////////////////
// CNetTreeCtrl window

class CNetTreeCtrl : public CTreeCtrl
{
// Construction
public:
	CNetTreeCtrl();
	virtual ~CNetTreeCtrl();

// Data members
public:
	enum 
	{
		ROOT_LEVEL = 0x0,
		DOMAIN_LEVEL = 0x1,
		SERVER_LEVEL = 0x2,

		BUFFER_SIZE = 0x4000,
		MAX_STRING = 0x100,

		IMG_ROOT = 0,
		IMG_DOMAIN = 1,
		IMG_SERVER = 2,

		IMG_SIZE = 16,
		IMG_GROW = 3,
		IMG_MASK = RGB(0xFF, 0xFF, 0xFF)
	};

public:
	HANDLE m_hHeap;
	CImageList m_imagelist;
	CTypedPtrList<CPtrList, LPNETRESOURCE> m_ptrlistContainers;
	CTypedPtrList<CPtrList, LPTSTR> m_ptrlistStrings;
	CWinThread* m_pThread;
	CEvent m_event;
	BOOL m_bExitThread;

// Attributes
public:

// Operations
public:
	BOOL PopulateTree(BOOL bExpand= TRUE, const HTREEITEM hParentBranch = TVI_ROOT, DWORD dwBufSize = BUFFER_SIZE);
	void ErrorHandler(const DWORD dwCode);
	void NotifyThread(BOOL bExit);
	static UINT FillTree(LPVOID pParam);

protected:
	void CNetTreeCtrl::PumpMessages();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CNetTreeCtrl)
	afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\liccomp\transbmp.h ===
// transbmp.h : interface of the CTransBitmap class
//
/////////////////////////////////////////////////////////////////////////////

class CTransBmp : public CBitmap
{
public:
    CTransBmp();
    ~CTransBmp();
    void Draw(HDC hDC, int x, int y);
    void Draw(CDC* pDC, int x, int y);
    void DrawTrans(HDC hDC, int x, int y);
    void DrawTrans(CDC* pDC, int x, int y);
    int GetWidth();
    int GetHeight();

private:
    int m_iWidth;
    int m_iHeight;
    CBitmap* m_hbmMask;    // handle to mask bitmap

    void GetMetrics();
    void CreateMask(HDC hDC);
	void CreateMask(CDC* pDC);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\fpnw.h ===
#ifndef _FPNW_H_
#define _FPNW_H_

BOOL
FPNWShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
);

DWORD
FPNWCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD,
    IN HINSTANCE              hLib
);

#endif // _FPNW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\aclpage.h ===
#ifndef __ACLPAGE_H__
#define __ACLPAGE_H__

#include "aclui.h"

#define DONT_WANT_SHELLDEBUG
#include "shlobj.h"     // LPITEMIDLIST
#include "shlobjp.h"

#define SHARE_PERM_FULL_CONTROL       FILE_ALL_ACCESS
#define SHARE_PERM_READ_ONLY          (FILE_GENERIC_READ | FILE_EXECUTE)
#define ACCOUNT_EVERYONE              _T("everyone")
#define ACCOUNT_ADMINISTRATORS        _T("administrators")
#define ACCOUNT_SYSTEM                _T("system")
#define ACCOUNT_INTERACTIVE           _T("interactive")

/////////////////////////////////////////////////////////////////////////////
// CPermEntry

class CPermEntry
{
public:
  CPermEntry();
  ~CPermEntry();
  HRESULT Initialize(
      IN LPCTSTR  lpszSystem,
      IN LPCTSTR  lpszAccount,
      IN DWORD    dwAccessMask
  );
  UINT GetLengthSid();
  HRESULT AddAccessAllowedAce(OUT PACL pACL);

protected:
  CString m_cstrSystem;
  CString m_cstrAccount;
  DWORD   m_dwAccessMask;
  PSID    m_pSid;
  BOOL    m_bWellKnownSid;
};

HRESULT
BuildSecurityDescriptor(
    IN  CPermEntry            *pPermEntry, // an array of CPermEntry
    IN  UINT                  cEntries,    // number of entries in the array
    OUT PSECURITY_DESCRIPTOR  *ppSelfRelativeSD // return a security descriptor in self-relative form
);

HRESULT
GetAccountSID(
    IN  LPCTSTR lpszSystem,    // system where the account belongs to 
    IN  LPCTSTR lpszAccount,   // account
    OUT PSID    *ppSid,        // return SID of the account
    OUT BOOL    *pbWellKnownSID // return a BOOL, caller needs to call FreeSid() on a well-known SID
);

/////////////////////////////////////////////////////////////////////////////
// CShareSecurityInformation

class CShareSecurityInformation : public ISecurityInformation
{
private:
  ULONG   m_cRef; 
	CString m_cstrComputerName;
	CString m_cstrShareName;
  CString m_cstrPageTitle;
  PSECURITY_DESCRIPTOR m_pDefaultDescriptor;
  BOOL    m_bDefaultSD;

public:
  CShareSecurityInformation(PSECURITY_DESCRIPTOR pSelfRelativeSD);
  ~CShareSecurityInformation();

  void Initialize(
      IN LPCTSTR lpszComputerName,
      IN LPCTSTR lpszShareName,
      IN LPCTSTR lpszPageTitle
  );

  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
  STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                          PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                          BOOL fDefault );
  STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                          PSECURITY_DESCRIPTOR pSecurityDescriptor );
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  );

protected:
  HRESULT GetDefaultSD(
      OUT PSECURITY_DESCRIPTOR  *ppsd
  );

  HRESULT MakeSelfRelativeCopy(
      IN  PSECURITY_DESCRIPTOR  psdOriginal,
      OUT PSECURITY_DESCRIPTOR  *ppsdNew
  );
};

/////////////////////////////////////////////////////////////////////////////
// CFileSecurityDataObject

class CFileSecurityDataObject: public IDataObject
{
protected:
  UINT m_cRef;
  CString m_cstrComputerName;
  CString m_cstrFolder;
  CString m_cstrPath;
  CLIPFORMAT m_cfIDList;

public:
  CFileSecurityDataObject();
  ~CFileSecurityDataObject();
  void Initialize(
      IN LPCTSTR lpszComputerName,
      IN LPCTSTR lpszFolder
  );

  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(REFIID, LPVOID *);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // *** IDataObject methods ***
  STDMETHOD(GetData)(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
  inline STDMETHOD(GetDataHere)(LPFORMATETC pFE, LPSTGMEDIUM pSTM) {return E_NOTIMPL;}
  inline STDMETHOD(QueryGetData)(LPFORMATETC pFE) {return E_NOTIMPL;}
  inline STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pFEIn, LPFORMATETC pFEOut) {return E_NOTIMPL;}
  inline STDMETHOD(SetData)(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease) {return E_NOTIMPL;}
  inline STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnum) {return E_NOTIMPL;}
  inline STDMETHOD(DAdvise)(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink, LPDWORD pdwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(DUnadvise)(DWORD dwConnection) {return E_NOTIMPL;}
  inline STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnum) {return E_NOTIMPL;}

  HRESULT GetFolderPIDList(OUT LPITEMIDLIST *ppidl);
};

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
);

#endif // __ACLPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\aclpage.cpp ===
// AclPage.cpp : Implementation of ISecurityInformation and IDataObject

#include "stdafx.h"
#include "shrwiz.h"
#include "AclPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////
// class CPermEntry

CPermEntry::CPermEntry()
: m_dwAccessMask(0),
  m_pSid(NULL),
  m_bWellKnownSid(FALSE)
{
}

CPermEntry::~CPermEntry()
{
  if (m_pSid)
    if (m_bWellKnownSid)
      FreeSid(m_pSid);
    else
      LocalFree((HLOCAL)m_pSid);
}

HRESULT
CPermEntry::Initialize(
    IN LPCTSTR  lpszSystem,
    IN LPCTSTR  lpszAccount,
    IN DWORD    dwAccessMask
)
{
  m_cstrSystem = lpszSystem;
  m_cstrAccount = lpszAccount;
  m_dwAccessMask = dwAccessMask;
  
  return GetAccountSID(m_cstrSystem, m_cstrAccount, &m_pSid, &m_bWellKnownSid);
}

UINT
CPermEntry::GetLengthSid()
{
  return (m_pSid ? ::GetLengthSid(m_pSid) : 0);
}

HRESULT
CPermEntry::AddAccessAllowedAce(OUT PACL pACL)
{
  if ( !::AddAccessAllowedAce(pACL, ACL_REVISION, m_dwAccessMask, m_pSid) )
    return HRESULT_FROM_WIN32(GetLastError());
  return S_OK;
}

// NOTE: caller needs to call LocalFree() on the returned SD
HRESULT
BuildSecurityDescriptor(
    IN  CPermEntry            *pPermEntry, // an array of CPermEntry
    IN  UINT                  cEntries,    // number of entries in the array
    OUT PSECURITY_DESCRIPTOR  *ppSelfRelativeSD // return a security descriptor in self-relative form
)
{
  if (!pPermEntry || !cEntries || !ppSelfRelativeSD)
    return E_INVALIDARG;

  ASSERT(!*ppSelfRelativeSD); // prevent memory leak
  *ppSelfRelativeSD = NULL;

  HRESULT               hr = S_OK;
  PSECURITY_DESCRIPTOR  pAbsoluteSD = NULL;
  PACL 			            pACL = NULL;
  
  do { // false loop

    UINT        i = 0;
    CPermEntry *pEntry = NULL;
    DWORD       cbACL = sizeof(ACL);

    // Initialize a new ACL
    for (pEntry=pPermEntry, i=0; i<cEntries; pEntry++, i++)
      cbACL += sizeof(ACCESS_ALLOWED_ACE) + pEntry->GetLengthSid() - sizeof(DWORD);

    if ( !(pACL = (PACL)LocalAlloc(LPTR, cbACL)) ||
         !InitializeAcl(pACL, cbACL, ACL_REVISION))
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }

    // Add Ace
    for (pEntry=pPermEntry, i=0; SUCCEEDED(hr) && i<cEntries; pEntry++, i++)
      hr = pEntry->AddAccessAllowedAce(pACL);
    if (FAILED(hr))
      break;

    // Note: this is a new object, set Dacl only.
    // Initialize a new security descriptor in absolute form and add the new ACL to it
    if ( !(pAbsoluteSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH)) ||
         !InitializeSecurityDescriptor(pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION) ||
         !SetSecurityDescriptorDacl(pAbsoluteSD, TRUE, pACL, FALSE) )
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }

    // transform into a self-relative form
    DWORD dwSDSize = 0;
    MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize);
    if ( !(*ppSelfRelativeSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDSize)) ||
         !MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize) )
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      break;
    }
  } while (0);

  if (FAILED(hr))
  {
    if (*ppSelfRelativeSD)
    {
      LocalFree((HLOCAL)*ppSelfRelativeSD);
      *ppSelfRelativeSD = NULL;
    }
  }

  if (pACL)
    LocalFree((HLOCAL)pACL);
  if (pAbsoluteSD)
    LocalFree((HLOCAL)pAbsoluteSD);

  return hr;
}

#define MAX_DOMAIN_NAME_LENGTH    1024

// NOTE: caller needs to call FreeSid()/LocalFree() on the returned SID
// NOTE: this function only handles limited well-known SIDs.
HRESULT
GetAccountSID(
    IN  LPCTSTR lpszSystem,    // system where the account belongs to 
    IN  LPCTSTR lpszAccount,   // account
    OUT PSID    *ppSid,        // return SID of the account
    OUT BOOL    *pbWellKnownSID // return a BOOL, caller needs to call FreeSid() on a well-known SID
)
{
  if (!lpszAccount || !*lpszAccount || !ppSid || !pbWellKnownSID)
    return E_INVALIDARG;

  ASSERT(!*ppSid); // prevent memory leak
  *ppSid = NULL;

  SID_IDENTIFIER_AUTHORITY  SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
  SID_IDENTIFIER_AUTHORITY  SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
  PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority = NULL;
  DWORD dwRet = ERROR_SUCCESS;
  BYTE  Count = 0;
  DWORD dwRID[8];
  ZeroMemory(dwRID, sizeof(dwRID));

  *pbWellKnownSID = TRUE;

  CString cstrAccount = lpszAccount;
  cstrAccount.MakeLower();
  if ( ACCOUNT_ADMINISTRATORS == cstrAccount ) {
    // Administrators group
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 2;
    dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
    dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
  } else if ( ACCOUNT_EVERYONE == cstrAccount ) {
    // Everyone
    pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
    Count = 1;
    dwRID[0] = SECURITY_WORLD_RID;
  } else if ( ACCOUNT_SYSTEM == cstrAccount ) {
    // SYSTEM
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 1;
    dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
  } else if ( ACCOUNT_INTERACTIVE == cstrAccount ) {
    // INTERACTIVE
    pSidIdentifierAuthority = &SidIdentifierNTAuthority;
    Count = 1;
    dwRID[0] = SECURITY_INTERACTIVE_RID;
  } else {
    *pbWellKnownSID = FALSE;
  }

  if (*pbWellKnownSID) {
    if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, Count, 
		                        dwRID[0], dwRID[1], dwRID[2], dwRID[3], 
		                        dwRID[4], dwRID[5], dwRID[6], dwRID[7], ppSid) )
    {
      dwRet = GetLastError();
    }
  } else {
    // get regular account sid
    DWORD        dwSidSize = 0;
    TCHAR        refDomain[MAX_DOMAIN_NAME_LENGTH];
    DWORD        refDomainSize = MAX_DOMAIN_NAME_LENGTH;
    SID_NAME_USE snu;

    LookupAccountName (lpszSystem, lpszAccount, *ppSid, &dwSidSize,
                       refDomain, &refDomainSize, &snu);
    dwRet = GetLastError();

    if (ERROR_INSUFFICIENT_BUFFER == dwRet)
    {
      dwRet = ERROR_SUCCESS;
      if ( !(*ppSid = (PSID)LocalAlloc(LPTR, dwSidSize)) )
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
      else
      {
        refDomainSize = MAX_DOMAIN_NAME_LENGTH;
        if (!LookupAccountName (lpszSystem, lpszAccount, *ppSid, &dwSidSize,
                                refDomain, &refDomainSize, &snu))
          dwRet = GetLastError();
      }
    }
  }

  if (ERROR_SUCCESS != dwRet)
  {
    if (*ppSid)
    {
      if (*pbWellKnownSID)
        FreeSid(*ppSid);
      else
        LocalFree((HLOCAL)*ppSid);
      *ppSid = NULL;
    }
  }

  return HRESULT_FROM_WIN32(dwRet);
}

///////////////////////////////////////////////////////
// class CShareSecurityInformation

CShareSecurityInformation::CShareSecurityInformation(PSECURITY_DESCRIPTOR pSelfRelativeSD)
: m_cRef(1), m_pDefaultDescriptor(pSelfRelativeSD)
{
  m_bDefaultSD = !pSelfRelativeSD;
}

CShareSecurityInformation::~CShareSecurityInformation()
{
  TRACE(_T("CShareSecurityInformation::~CShareSecurityInformation m_cRef=%d\n"), m_cRef);
  if (m_bDefaultSD && m_pDefaultDescriptor)
    LocalFree((HLOCAL)m_pDefaultDescriptor);
}

void 
CShareSecurityInformation::Initialize(
    IN LPCTSTR lpszComputerName,
    IN LPCTSTR lpszShareName,
    IN LPCTSTR lpszPageTitle
)
{
  m_cstrComputerName = lpszComputerName;
  m_cstrShareName = lpszShareName;
	m_cstrPageTitle = lpszPageTitle;
}

////////////////////////////////
// IUnknown methods
////////////////////////////////
STDMETHODIMP
CShareSecurityInformation::QueryInterface(REFIID riid, LPVOID *ppv)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
  {
    *ppv = this;
    m_cRef++;
    return S_OK;
  } else
  {
    *ppv = NULL;
    return E_NOINTERFACE;
  }
}

STDMETHODIMP_(ULONG)
CShareSecurityInformation::AddRef()
{
  return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CShareSecurityInformation::Release()
{
  if (--m_cRef == 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

////////////////////////////////
// ISecurityInformation methods
////////////////////////////////
STDMETHODIMP
CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo
)
{
  ASSERT(pObjectInfo);
  ASSERT(!IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

  pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_PAGE_TITLE | SI_RESET;
  pObjectInfo->hInstance = AfxGetResourceHandle();
  pObjectInfo->pszServerName = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrComputerName));
  pObjectInfo->pszObjectName = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrShareName));
  pObjectInfo->pszPageTitle = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrPageTitle));

  return S_OK;
}

STDMETHODIMP
CShareSecurityInformation::GetSecurity (
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    BOOL fDefault
)
{
  ASSERT(DACL_SECURITY_INFORMATION == RequestedInformation);
  ASSERT(ppSecurityDescriptor);
  TRACE(_T("GetSecurity RequestedInformation=%d fDefault=%d\n"), RequestedInformation, fDefault);

  *ppSecurityDescriptor = NULL;

  if (NULL == m_pDefaultDescriptor)
  {
    HRESULT hr = GetDefaultSD(&m_pDefaultDescriptor);
    if (FAILED(hr))
      return hr;
  }

  // We have to pass back a LocalAlloc'ed copy of the SD
  return MakeSelfRelativeCopy(m_pDefaultDescriptor, ppSecurityDescriptor);
}

STDMETHODIMP
CShareSecurityInformation::SetSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
)
{
  ASSERT(DACL_SECURITY_INFORMATION == SecurityInformation);
  TRACE(_T("SetSecurity SecurityInformation=%d\n"), SecurityInformation);

  PSECURITY_DESCRIPTOR pNewSD = NULL;
  HRESULT hr = MakeSelfRelativeCopy(pSecurityDescriptor, &pNewSD);
  if (SUCCEEDED(hr))
    ((CShrwizApp *)AfxGetApp())->SetSecurity(pNewSD);
  return hr;
}

SI_ACCESS siShareAccesses[] =
{
  { &GUID_NULL, 
    FILE_ALL_ACCESS, 
    MAKEINTRESOURCE(IDS_SHAREPERM_ALL), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_CHANGE), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_READ), 
    SI_ACCESS_GENERAL }
};

#define iShareDefAccess       2   // index of value in array siShareAccesses
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)          (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP
CShareSecurityInformation::GetAccessRights(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
)
{
  ASSERT(ppAccess);
  ASSERT(pcAccesses);
  ASSERT(piDefaultAccess);

  *ppAccess = siShareAccesses;
  *pcAccesses = ARRAYSIZE(siShareAccesses);
  *piDefaultAccess = iShareDefAccess;

  return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
  FILE_GENERIC_READ,
  FILE_GENERIC_WRITE,
  FILE_GENERIC_EXECUTE,
  FILE_ALL_ACCESS
};

STDMETHODIMP
CShareSecurityInformation::MapGeneric(
    const GUID  *pguidObjectType,
    UCHAR       *pAceFlags,
    ACCESS_MASK *pMask
)
{
  ASSERT(pMask);

  MapGenericMask(pMask, &ShareMap);

  return S_OK;
}

STDMETHODIMP 
CShareSecurityInformation::GetInheritTypes (
    PSI_INHERIT_TYPE  *ppInheritTypes,
    ULONG             *pcInheritTypes
)
{
  return E_NOTIMPL;
}

STDMETHODIMP 
CShareSecurityInformation::PropertySheetPageCallback(
    HWND          hwnd, 
    UINT          uMsg, 
    SI_PAGE_TYPE  uPage
)
{
  return S_OK;
}

HRESULT 
CShareSecurityInformation::GetDefaultSD(
    OUT PSECURITY_DESCRIPTOR  *ppsd
)
{
  CPermEntry permEntry;
  HRESULT hr = permEntry.Initialize(NULL, ACCOUNT_EVERYONE, SHARE_PERM_FULL_CONTROL);
  if (SUCCEEDED(hr))
    hr = BuildSecurityDescriptor(&permEntry, 1, ppsd);
  return hr;
}

HRESULT 
CShareSecurityInformation::MakeSelfRelativeCopy(
    IN  PSECURITY_DESCRIPTOR  psdOriginal,
    OUT PSECURITY_DESCRIPTOR  *ppsdNew
)
{
  ASSERT(psdOriginal);
  ASSERT(ppsdNew);

  *ppsdNew = NULL;

  DWORD dwErr = 0;
  PSECURITY_DESCRIPTOR psdSelfRelative = NULL;

  do { // false loop

    DWORD cbSD = ::GetSecurityDescriptorLength(psdOriginal);
    if ( !(psdSelfRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, cbSD)) )
    {
      dwErr = ::GetLastError();
      break;
    }

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL sdc = 0;
    DWORD dwRevision = 0;
    if ( !::GetSecurityDescriptorControl(psdOriginal, &sdc, &dwRevision) )
    {
      dwErr = ::GetLastError();
      break;
    }

    if (sdc & SE_SELF_RELATIVE)
    {
      ::memcpy(psdSelfRelative, psdOriginal, cbSD);
    } else if ( !::MakeSelfRelativeSD(psdOriginal, psdSelfRelative, &cbSD) )
    {
      dwErr = ::GetLastError();
      break;
    }

    *ppsdNew = psdSelfRelative;

  } while (FALSE);

  if (dwErr && psdSelfRelative)
    LocalFree((HLOCAL)psdSelfRelative);
 
  return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}

///////////////////////////////////////////////////////
// class CFileSecurityDataObject

CFileSecurityDataObject::CFileSecurityDataObject()
: m_cRef(1)
{
}

CFileSecurityDataObject::~CFileSecurityDataObject()
{
  TRACE(_T("CFileSecurityDataObject::~CFileSecurityDataObject m_cRef=%d\n"), m_cRef);
}

void
CFileSecurityDataObject::Initialize(
    IN LPCTSTR lpszComputerName,
    IN LPCTSTR lpszFolder
)
{
  m_cstrComputerName = lpszComputerName;
  m_cstrFolder = lpszFolder;

  GetFullPath(lpszComputerName, lpszFolder, m_cstrPath);

  m_cfIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
}

////////////////////////////////
// IUnknown methods
////////////////////////////////
STDMETHODIMP
CFileSecurityDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject))
  {
    *ppv = this;
    m_cRef++;
    return S_OK;
  } else
  {
    *ppv = NULL;
    return E_NOINTERFACE;
  }
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::AddRef()
{
  return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CFileSecurityDataObject::Release()
{
  if (--m_cRef == 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

STDMETHODIMP
CFileSecurityDataObject::GetData(
    FORMATETC __RPC_FAR * pFormatEtcIn,
    STGMEDIUM __RPC_FAR * pMedium
)
{
  ASSERT(pFormatEtcIn);
  ASSERT(pMedium);

  if (m_cfIDList != pFormatEtcIn->cfFormat)
    return DV_E_FORMATETC;

  LPITEMIDLIST      pidl = NULL;
  LPITEMIDLIST      pidlR = NULL;
  HRESULT           hr = GetFolderPIDList(&pidl);
  if (SUCCEEDED(hr))
  {
    pidlR = ILClone(ILFindLastID(pidl));  // relative IDList
    ILRemoveLastID(pidl);                 // folder IDList

    int  cidl = 1;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbFolder = ILGetSize(pidl);
    UINT cbRelative = ILGetSize(pidlR);
    UINT cbTotal = offset + cbFolder + cbRelative;

    HGLOBAL hGlobal = ::GlobalAlloc (GPTR, cbTotal);
    if ( hGlobal )
    {
      LPIDA pida = (LPIDA)hGlobal;

      pida->cidl = cidl;
      pida->aoffset[0] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidl, cbFolder);

      offset += cbFolder;
      pida->aoffset[1] = offset;
      MoveMemory(((LPBYTE)hGlobal+offset), pidlR, cbRelative);

      pMedium->hGlobal = hGlobal;
    } else
    {
      hr = E_OUTOFMEMORY;
    }

    if (pidl)
      ILFree(pidl);
    if (pidlR)
      ILFree(pidlR);
  }

  return hr;
}

HRESULT
CFileSecurityDataObject::GetFolderPIDList(
    OUT LPITEMIDLIST *ppidl
)
{
  ASSERT(!m_cstrPath.IsEmpty());
  ASSERT(ppidl);
  ASSERT(!*ppidl);  // prevent memory leak

  *ppidl = ILCreateFromPath(m_cstrPath);

  return ((*ppidl) ? S_OK : E_FAIL);
}

///////////////////////////////////////////////
// File security

// Security Shell extension CLSID - {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_ShellExtSecurity =
 {0x1F2E5C40, 0x9550, 0x11CE, {0x99, 0xD2, 0x0, 0xAA, 0x0, 0x6E, 0x08, 0x6C}};

BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM lParam)
{
  // pass out the created page handle
  *((HPROPSHEETPAGE *)lParam) = hPage;

  return TRUE;
}

HRESULT
CreateFileSecurityPropPage(
    HPROPSHEETPAGE *phOutPage,
    LPDATAOBJECT pDataObject
)
{
  ASSERT(phOutPage);
  ASSERT(pDataObject);

  IShellExtInit *piShellExtInit = NULL;
  HRESULT hr = CoCreateInstance(CLSID_ShellExtSecurity,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IShellExtInit,
                        (void **)&piShellExtInit);
  if (SUCCEEDED(hr))
  {
    hr = piShellExtInit->Initialize(NULL, pDataObject, 0);
    if (SUCCEEDED(hr))
    {
      IShellPropSheetExt *piSPSE = NULL;
      hr = piShellExtInit->QueryInterface(IID_IShellPropSheetExt, (void **)&piSPSE);
      if (SUCCEEDED(hr))
      {
        hr = piSPSE->AddPages(AddPageProc, (LPARAM)phOutPage);
        piSPSE->Release();
      }
    }
    piShellExtInit->Release();
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shrwiz.rc
//
#define IDS_WIZARD_TITLE                1
#define IDS_CANNOT_GET_LOCAL_COMPUTER   2
#define IDS_CANNOT_CONTACT_COMPUTER     3
#define IDS_APP_USAGE                   4
#define IDS_TEXT_REQUIRED               5
#define IDS_INVALID_FOLDER              6
#define IDS_DUPLICATE_SHARENAME         7
#define IDS_FAILED_TO_VALIDATE_FOLDER   8
#define IDS_CLIENT_REQUIRED             9
#define IDS_BROWSE_FOLDER               10
#define IDS_CANNOT_BROWSE_FOLDER        11
#define IDS_FAILED_TO_GET_SD            12
#define IDS_INVALID_SHARENAME           13
#define IDS_LINE_RETURN                 14
#define IDS_SMB_CLIENTS                 15
#define IDS_FPNW_CLIENTS                16
#define IDS_SFM_CLIENTS                 17
#define IDS_SUCCEEDED_IN_CREATING_SHARE 18
#define IDS_FAILED_TO_CREATE_SHARE      19
#define IDS_PATH_NOT_FOLDER             20
#define IDS_CREATE_NEW_DIR              21
#define IDS_FAILED_TO_CREATE_NEW_DIR    22
#define IDS_OPERATION_SUCCEEDED_MORE_SHARES 23
#define IDS_SHAREPERM_ALL               24
#define IDS_SHAREPERM_CHANGE            25
#define IDS_SHAREPERM_READ              26
#define IDS_SHARE_PERMISSIONS           27
#define IDS_FAILED_TO_CREATE_ACLUI      28
#define IDS_CUSTOM_PERM                 29
#define IDS_CMDLINE_PARAMS              30
#define IDS_FOLDER_LABEL                31
#define IDS_SHARENAME_LABEL             32
#define IDS_MACSHARENAME_LABEL          33
#define IDS_INVALID_DRIVE               34
#define IDS_FAILED_TO_GETINFO_FOLDER    35
#define IDD_SHRWIZ_DIALOG               102
#define IDD_SHRWIZ_FOLDER               103
#define IDD_SHRWIZ_PERM                 104
#define IDR_MAINFRAME                   128
#define IDD_NO_SHARE_PERMISSIONS        129
#define IDB_BANNER                      132
#define IDC_COMPUTER                    1000
#define IDC_FOLDER                      1001
#define IDC_SHARENAME                   1002
#define IDC_SHAREDESCRIPTION            1003
#define IDC_CHECK_MS                    1004
#define IDC_CHECK_NETWARE               1005
#define IDC_CHECK_MAC                   1006
#define IDC_SHARENAME_MAC               1007
#define IDC_MACSHARENAME                1007
#define IDC_BROWSEFOLDER                1008
#define IDC_RADIO_PERM1                 1009
#define IDC_RADIO_PERM2                 1010
#define IDC_RADIO_PERM3                 1011
#define IDC_RADIO_PERM4                 1012
#define IDC_PERM_CUSTOM                 1013
#define IDC_MACSHARENAME_STATIC         1014
#define IDC_CLIENTS_GROUP               1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\fpnw.cpp ===
// fpnw.cpp : Implementation of shares for Novell NetWare

#include "stdafx.h"
#include <fpnwapi.h>

#define FUNCNAME_FPNWVOLUMEGETINFO  "FpnwVolumeGetInfo"
#define FUNCNAME_FPNWVOLUMEADD      "FpnwVolumeAdd"
#define FUNCNAME_FPNWAPIBUFFERFREE  "FpnwApiBufferFree"

typedef DWORD (CALLBACK *PFPNWVOLUMEGETINFO) (LPWSTR, LPWSTR, DWORD, LPBYTE*);
typedef DWORD (CALLBACK *PFPNWVOLUMEADD)(LPWSTR, DWORD, LPBYTE);
typedef DWORD (CALLBACK *PFPNWAPIBUFFERFREE)(LPVOID);

BOOL
FPNWShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
)
{
  BOOL                  bReturn = FALSE;
  DWORD                 dwRet = NERR_Success;
  PFPNWVOLUMEGETINFO     pFPNWVolumeGetInfo = NULL;
  PFPNWAPIBUFFERFREE     pFPNWApiBufferFree = NULL;

  if ((pFPNWVolumeGetInfo = (PFPNWVOLUMEGETINFO)GetProcAddress(hLib, FUNCNAME_FPNWVOLUMEGETINFO)) &&
      (pFPNWApiBufferFree = (PFPNWAPIBUFFERFREE)GetProcAddress(hLib, FUNCNAME_FPNWAPIBUFFERFREE)) )
  {
    FPNWVOLUMEINFO *pInfo = NULL;
    dwRet = (*pFPNWVolumeGetInfo)(
        const_cast<LPTSTR>(lpszServerName), 
        const_cast<LPTSTR>(lpszShareName),
        1,
        (LPBYTE*)&pInfo);  

    if (NERR_Success == dwRet)
    {
      bReturn = TRUE;
      (*pFPNWApiBufferFree)(pInfo);
    }
  }

  return bReturn;
}

DWORD
FPNWCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD,
    IN HINSTANCE              hLib
)
{
  DWORD         dwRet = NERR_Success;
  PFPNWVOLUMEADD pFPNWVolumeAdd = NULL;

  if (!(pFPNWVolumeAdd = (PFPNWVOLUMEADD)GetProcAddress(hLib, FUNCNAME_FPNWVOLUMEADD)))
  {
    dwRet = GetLastError();
  } else
  {
    FPNWVOLUMEINFO_2 VolumeInfo2;

    ZeroMemory(&VolumeInfo2, sizeof(VolumeInfo2));
    VolumeInfo2.lpVolumeName = const_cast<LPTSTR>(lpszShareName);
    VolumeInfo2.dwType = FPNWVOL_TYPE_DISKTREE;
    VolumeInfo2.dwMaxUses = -1; // unlimited
    VolumeInfo2.lpPath = const_cast<LPTSTR>(lpszSharePath);
    VolumeInfo2.FileSecurityDescriptor = pSD;

    dwRet = (*pFPNWVolumeAdd)(const_cast<LPTSTR>(lpszServer), 2, (LPBYTE)&VolumeInfo2);
  }

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\sfm.cpp ===
// sfm.cpp : Implementation of shares for Apple Macintosh

#include "stdafx.h"
#include <macfile.h>

#define FUNCNAME_AFPADMINCONNECT        "AfpAdminConnect"
#define FUNCNAME_AFPADMINDISCONNECT     "AfpAdminDisconnect"
#define FUNCNAME_AFPADMINVOLUMEGETINFO  "AfpAdminVolumeGetInfo"
#define FUNCNAME_AFPADMINVOLUMEADD      "AfpAdminVolumeAdd"
#define FUNCNAME_AFPADMINBUFFERFREE     "AfpAdminBufferFree"

typedef DWORD (CALLBACK *PAFPADMINCONNECT)(LPTSTR, PAFP_SERVER_HANDLE);
typedef VOID  (CALLBACK *PAFPADMINDISCONNECT)(AFP_SERVER_HANDLE);
typedef DWORD (CALLBACK *PAFPADMINVOLUMEGETINFO)(AFP_SERVER_HANDLE, LPWSTR, LPBYTE*);
typedef DWORD (CALLBACK *PAFPADMINVOLUMEADD)(AFP_SERVER_HANDLE, LPBYTE);
typedef DWORD (CALLBACK *PAFPADMINBUFFERFREE)(LPVOID);

BOOL
SFMShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
)
{
  BOOL                  bReturn = FALSE;
  DWORD                 dwRet = NERR_Success;
  PAFPADMINCONNECT       pAfpAdminConnect = NULL;
  PAFPADMINVOLUMEGETINFO pAfpAdminVolumeGetInfo = NULL;
  PAFPADMINBUFFERFREE    pAfpAdminBufferFree = NULL;
  PAFPADMINDISCONNECT    pAfpAdminDisconnect = NULL;

  if ( (pAfpAdminConnect = (PAFPADMINCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINCONNECT)) &&
       (pAfpAdminVolumeGetInfo = (PAFPADMINVOLUMEGETINFO)GetProcAddress(hLib, FUNCNAME_AFPADMINVOLUMEGETINFO)) &&
       (pAfpAdminBufferFree = (PAFPADMINBUFFERFREE)GetProcAddress(hLib, FUNCNAME_AFPADMINBUFFERFREE)) &&
       (pAfpAdminDisconnect = (PAFPADMINDISCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINDISCONNECT)) )
  {
    AFP_SERVER_HANDLE hAfpServerHandle = NULL;
    dwRet = (*pAfpAdminConnect)(
                const_cast<LPTSTR>(lpszServerName), 
                &hAfpServerHandle);
    if (NERR_Success == dwRet)
    {
      PAFP_VOLUME_INFO pInfo = NULL;
      dwRet = (*pAfpAdminVolumeGetInfo)(
                    hAfpServerHandle, 
                    const_cast<LPTSTR>(lpszShareName), 
                    (LPBYTE*)&pInfo);

      if (NERR_Success == dwRet)
      {
        bReturn = TRUE;
        (*pAfpAdminBufferFree)(pInfo);
      }

      (*pAfpAdminDisconnect)(hAfpServerHandle);
    }
  }

  return bReturn;
}

DWORD
SFMCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN HINSTANCE              hLib
)
{
  DWORD                dwRet = NERR_Success;
  PAFPADMINCONNECT     pAfpAdminConnect = NULL;
  PAFPADMINDISCONNECT  pAfpAdminDisconnect = NULL;
  PAFPADMINVOLUMEADD   pAfpAdminVolumeAdd = NULL;

  if (!(pAfpAdminConnect = (PAFPADMINCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINCONNECT)) ||
      !(pAfpAdminDisconnect = (PAFPADMINDISCONNECT)GetProcAddress(hLib, FUNCNAME_AFPADMINDISCONNECT)) ||
      !(pAfpAdminVolumeAdd = (PAFPADMINVOLUMEADD)GetProcAddress(hLib, FUNCNAME_AFPADMINVOLUMEADD)))
  {
    dwRet = GetLastError();
  } else
  {
    AFP_SERVER_HANDLE   hAfpServerHandle = NULL;
    dwRet = (*pAfpAdminConnect)(
                const_cast<LPTSTR>(lpszServer), 
                &hAfpServerHandle);
    if (NERR_Success == dwRet)
    {
      AFP_VOLUME_INFO   AfpVolumeInfo;
      ZeroMemory(&AfpVolumeInfo, sizeof(AfpVolumeInfo));
      AfpVolumeInfo.afpvol_name = const_cast<LPTSTR>(lpszShareName);
      AfpVolumeInfo.afpvol_max_uses = AFP_VOLUME_UNLIMITED_USES;
      AfpVolumeInfo.afpvol_props_mask = AFP_VOLUME_GUESTACCESS;
      AfpVolumeInfo.afpvol_path = const_cast<LPTSTR>(lpszSharePath);

      dwRet = (*pAfpAdminVolumeAdd)(hAfpServerHandle, (LPBYTE)&AfpVolumeInfo);

      (*pAfpAdminDisconnect)(hAfpServerHandle);
    }
  }

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\sfm.h ===
#ifndef _SFM_H_
#define _SFM_H_

BOOL
SFMShareNameExists(
    IN LPCTSTR    lpszServerName,
    IN LPCTSTR    lpszShareName,
    IN HINSTANCE  hLib
);

DWORD
SFMCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszSharePath,
    IN HINSTANCE              hLib
);

#endif // _SFM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\smb.h ===
#ifndef _SMB_H_
#define _SMB_H_

BOOL
SMBShareNameExists(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszShareName
);

DWORD
SMBCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszShareComment,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD
);

#endif // _SMB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\shrwiz.cpp ===
// shrwiz.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "shrwiz.h"
#include "wizDir.h"
#include "wizPerm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp

BEGIN_MESSAGE_MAP(CShrwizApp, CWinApp)
	//{{AFX_MSG_MAP(CShrwizApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
//	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp construction

CShrwizApp::CShrwizApp()
{
  m_bNextButtonClicked = TRUE;

  // filled in by initialization routine in shrwiz.cpp
  m_cstrTargetComputer.Empty();
  m_bIsLocal = FALSE;
  m_bServerFPNW = FALSE;
  m_bServerSFM = FALSE;
  m_hLibFPNW = NULL;
  m_hLibSFM = NULL;
  m_pWizard = NULL;

  // filled in by the folder page
  m_cstrFolder.Empty();
  m_cstrShareName.Empty();
  m_cstrShareDescription.Empty();
  m_cstrMACShareName.Empty();
  m_bSMB = FALSE;
  m_bFPNW = FALSE;
  m_bSFM = FALSE;

  // filled in by the permission page
  m_pSD = NULL;
}

CShrwizApp::~CShrwizApp()
{
  TRACE(_T("CShrwizApp::~CShrwizApp\n"));

  if (m_hLibFPNW)
    FreeLibrary(m_hLibFPNW);

  if (m_hLibSFM)
    FreeLibrary(m_hLibSFM);

  if (m_pSD)
    LocalFree((HLOCAL)m_pSD);

  delete m_pWizard;
}

void
CShrwizApp::Reset()
{
  m_bNextButtonClicked = TRUE;

  // filled in by the folder page
  m_cstrFolder.Empty();
  m_cstrShareName.Empty();
  m_cstrShareDescription.Empty();
  m_cstrMACShareName.Empty();
  m_bSMB = FALSE;
  m_bFPNW = FALSE;
  m_bSFM = FALSE;

  // filled in by the permission page
  if (m_pSD)
  {
    LocalFree((HLOCAL)m_pSD);
    m_pSD = NULL;
  }

  m_pWizard->PostMessage(PSM_SETCURSEL, 0);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CShrwizApp object

CShrwizApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp initialization

BOOL CShrwizApp::InitInstance()
{
  InitCommonControls();         // use XP theme-aware common controls

	Enable3dControls();			// Call this when using MFC in a shared DLL

  if (!GetTargetComputer())
    return FALSE;

  m_pMainWnd = NULL;

  m_pWizard = new CPropertySheet(IDS_WIZARD_TITLE, NULL, 0);

  CWizFolder folderPage;
  CWizPerm   permPage;

  m_pWizard->AddPage(&folderPage);
  m_pWizard->AddPage(&permPage);
  m_pWizard->SetWizardMode();
  (m_pWizard->m_psh).dwFlags |= PSH_WIZARD_LITE;
  m_pWizard->DoModal();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

BOOL
CShrwizApp::GetTargetComputer()
{
  BOOL bReturn = FALSE;

  m_cstrTargetComputer.Empty();
  m_bIsLocal = FALSE;

  do { // false loop

    CString cstrCmdLine = m_lpCmdLine;
    cstrCmdLine.TrimLeft();
    cstrCmdLine.TrimRight();
    if (cstrCmdLine.IsEmpty() || cstrCmdLine == _T("/s"))
    { // local computer
      TCHAR szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
      DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      if (GetComputerName(szBuffer, &dwSize))
      {
        m_cstrTargetComputer = szBuffer;
        m_bIsLocal = TRUE;
      } else
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, GetLastError(), IDS_CANNOT_GET_LOCAL_COMPUTER);
        break;
      }
    } else if (_T("/s") == cstrCmdLine.Left(2))
    {
      if (_istspace(cstrCmdLine.GetAt(2)))
      {
        cstrCmdLine = cstrCmdLine.Mid(3);
        cstrCmdLine.TrimLeft();
        if ( _T("\\\\") == cstrCmdLine.Left(2) )
          m_cstrTargetComputer = cstrCmdLine.Mid(2);
        else
          m_cstrTargetComputer = cstrCmdLine;
      }
    }

    if (m_cstrTargetComputer.IsEmpty())
    {
      CString cstrAppName = AfxGetAppName();
      CString cstrUsage;
      cstrUsage.FormatMessage(IDS_CMDLINE_PARAMS, cstrAppName);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_APP_USAGE, cstrUsage);
      break;
    } else
    {
      SERVER_INFO_102 *pInfo = NULL;
      DWORD dwRet = ::NetServerGetInfo(
        const_cast<LPTSTR>(static_cast<LPCTSTR>(m_cstrTargetComputer)), 102, (LPBYTE*)&pInfo);
      if (NERR_Success == dwRet)
      {
        m_bServerFPNW = (pInfo->sv102_type & SV_TYPE_SERVER_MFPN) && 
                        (m_hLibFPNW = LoadLibrary(_T("fpnwclnt.dll")));

        m_bServerSFM = (pInfo->sv102_type & SV_TYPE_AFP) &&
                        (m_hLibSFM = LoadLibrary(_T("sfmapi.dll")));
      
        NetApiBufferFree(pInfo);

        if (!m_bIsLocal)
          m_bIsLocal = IsLocalComputer(m_cstrTargetComputer);

        bReturn = TRUE;
      } else
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, dwRet, IDS_CANNOT_CONTACT_COMPUTER, m_cstrTargetComputer);
        break;
      }
    }
  } while (0);

  if (!bReturn)
    m_cstrTargetComputer.Empty();

  return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\shrwiz.h ===
// shrwiz.h : main header file for the SHRWIZ application
//

#if !defined(AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

// this is the user-defined message
#define WM_SETPAGEFOCUS WM_APP+2

/////////////////////////////////////////////////////////////////////////////
// CShrwizApp:
// See shrwiz.cpp for the implementation of this class
//

class CShrwizApp : public CWinApp
{
public:
	CShrwizApp();
	~CShrwizApp();
  void Reset();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShrwizApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
  BOOL GetTargetComputer();
  inline void SetSecurity(IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
  {
    if (m_pSD)
      LocalFree((HLOCAL)m_pSD);
    m_pSD = pSecurityDescriptor;
  }

  CPropertySheet *m_pWizard;
  BOOL m_bNextButtonClicked;

  // filled in by initialization routine in shrwiz.cpp
  CString   m_cstrTargetComputer;
  BOOL      m_bIsLocal;
  BOOL      m_bServerFPNW;
  BOOL      m_bServerSFM;
  HINSTANCE m_hLibFPNW; // fpnwclnt.dll
  HINSTANCE m_hLibSFM;  // sfmapi.dll

  // filled in by the folder page
  CString m_cstrFolder;
  CString m_cstrShareName;
  CString m_cstrShareDescription;
  CString m_cstrMACShareName;
  BOOL    m_bSMB;
  BOOL    m_bFPNW;
  BOOL    m_bSFM;

  // filled in by the permission page
  PSECURITY_DESCRIPTOR m_pSD;

	//{{AFX_MSG(CShrwizApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHRWIZ_H__292A4F37_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\smb.cpp ===
// smb.cpp : Implementation of shares for Microsoft Windows

#include "stdafx.h"
#include <lm.h>

BOOL
SMBShareNameExists(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszShareName
)
{
  BOOL                  bReturn = FALSE;
  DWORD                 dwRet = NERR_Success;
  SHARE_INFO_0          *pInfo = NULL;

  dwRet = NetShareGetInfo(
            const_cast<LPTSTR>(lpszServerName),
            const_cast<LPTSTR>(lpszShareName),
            0,
            (LPBYTE*)&pInfo);

  if (NERR_Success == dwRet)
  {
    bReturn = TRUE;
    NetApiBufferFree(pInfo);
  }

  return bReturn;
}

DWORD
SMBCreateShare(
    IN LPCTSTR                lpszServer,
    IN LPCTSTR                lpszShareName,
    IN LPCTSTR                lpszShareComment,
    IN LPCTSTR                lpszSharePath,
    IN PSECURITY_DESCRIPTOR   pSD
)
{
  SHARE_INFO_502 sInfo;

  ZeroMemory(&sInfo, sizeof(sInfo));
  sInfo.shi502_netname = const_cast<LPTSTR>(lpszShareName);
  sInfo.shi502_type = STYPE_DISKTREE;
  sInfo.shi502_remark = const_cast<LPTSTR>(lpszShareComment);
  sInfo.shi502_max_uses = -1;
  sInfo.shi502_path = const_cast<LPTSTR>(lpszSharePath);
  sInfo.shi502_security_descriptor = pSD;
        
  DWORD dwParamErr = 0;
  return NetShareAdd(const_cast<PTSTR>(lpszServer), 502, (LPBYTE)&sInfo, &dwParamErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "lm.h"
#include "resource.h"		// main symbols
#include "utils.h"

#include "smb.h"
#include "fpnw.h"
#include "sfm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__292A4F3B_C1EC_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

void
GetDisplayMessage(
  OUT CString&  cstrMsg,
	IN  DWORD     dwErr,
	IN  UINT      iStringId,
	...);

int
DisplayMessageBox(
	IN HWND   hwndParent,
	IN UINT   uType,
	IN DWORD  dwErr,
	IN UINT   iStringId,
	...);

BOOL IsLocalComputer(IN LPCTSTR lpszComputer);

void GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
);

HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
);

HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\utils.cpp ===
// utils.cpp : Implementation of helper functions

#include "stdafx.h"
#include <dns.h>
#include <macfile.h>

HRESULT 
GetErrorMessageFromModule(
  IN  DWORD       dwError,
  IN  LPCTSTR     lpszDll,
  OUT LPTSTR      *ppBuffer
)
{
  if (0 == dwError || !lpszDll || !*lpszDll || !ppBuffer)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;

  HINSTANCE  hMsgLib = LoadLibrary(lpszDll);
  if (!hMsgLib)
    hr = HRESULT_FROM_WIN32(GetLastError());
  else
  {
    DWORD dwRet = ::FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        hMsgLib, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)ppBuffer, 0, NULL);

    if (0 == dwRet)
      hr = HRESULT_FROM_WIN32(GetLastError());

    FreeLibrary(hMsgLib);
  }

  return hr;
}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
)
{
  if (0 == i_dwError)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    {
      hr = GetErrorMessageFromModule((i_dwError & 0x0000ffff), _T("netmsg.dll"), &lpBuffer);
      if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr)
      {
        int iError = i_dwError;  // convert to a signed integer
        if (iError >= AFPERR_MIN && iError < AFPERR_BASE)
        { 
          // use a positive number to search sfmmsg.dll
          hr = GetErrorMessageFromModule(-iError, _T("sfmmsg.dll"), &lpBuffer);
        }
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    cstrErrorMsg = lpBuffer;
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll/sfmmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    cstrErrorMsg.Format(_T("0x%x"), i_dwError);
  }

  return S_OK;
}

void
GetDisplayMessageHelper(
  OUT CString&  cstrMsg,
  IN  DWORD     dwErr,      // error code
  IN  UINT      iStringId,  // string resource Id
  IN  va_list   *parglist)  // Optional arguments
{
  HRESULT hr = S_OK;
  CString cstrErrorMsg;

  if (dwErr)
    hr = GetErrorMessage(dwErr, cstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      if (dwErr)
      {
        cstrMsg = cstrErrorMsg;
      } else
      {
        cstrMsg = va_arg(*parglist, LPCTSTR);
      }
    }
    else
    {
      CString cstrString;
      cstrString.LoadString(iStringId);

      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        cstrString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        parglist);
      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        cstrMsg = lpBuffer;
        if (dwErr)
          cstrMsg += cstrErrorMsg;
  
        LocalFree(lpBuffer);
      }
    }
  }

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    cstrMsg.Format(_T("0x%x"), hr);
  }
}

void
GetDisplayMessage(
  OUT CString&  cstrMsg,
  IN  DWORD     dwErr,      // error code
  IN  UINT      iStringId,  // string resource Id
  ...)                  // Optional arguments
{
  va_list arglist;
  va_start(arglist, iStringId);
  GetDisplayMessageHelper(cstrMsg, dwErr, iStringId, &arglist);
  va_end(arglist);
}

int
DisplayMessageBox(
  IN HWND   hwndParent,
  IN UINT   uType,      // style of message box
  IN DWORD  dwErr,      // error code
  IN UINT   iStringId,  // string resource Id
  ...)                  // Optional arguments
{
  CString cstrCaption;
  CString cstrMsg;

  cstrCaption.LoadString(IDS_WIZARD_TITLE);

  va_list arglist;
  va_start(arglist, iStringId);
  GetDisplayMessageHelper(cstrMsg, dwErr, iStringId, &arglist);
  va_end(arglist);

  return ::MessageBox(hwndParent, cstrMsg, cstrCaption, uType);
}

// NOTE: this function only handles limited cases, e.g., no ip address
BOOL IsLocalComputer(IN LPCTSTR lpszComputer)
{
  if (!lpszComputer || !*lpszComputer)
    return TRUE;

  if ( _tcslen(lpszComputer) > 2 && *lpszComputer == _T('\\') && *(lpszComputer + 1) == _T('\\') )
    lpszComputer += 2;

  BOOL    bReturn = FALSE;
  DWORD   dwErr = 0;
  TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
  DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

 // 1st: compare against local Netbios computer name
  if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
  {
    dwErr = GetLastError();
  } else
  {
    bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
    if (!bReturn)
    { // 2nd: compare against local Dns computer name 
      dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
      if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
      else
        dwErr = GetLastError();
    }
  }

  if (dwErr)
    TRACE(_T("IsLocalComputer dwErr = %x\n"), dwErr);

  return bReturn;
}

void GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
)
{
  ASSERT(lpszDir && *lpszDir);

  if (IsLocalComputer(lpszServer))
  {
    cstrPath = lpszDir;
  } else
  {
    if (*lpszServer != _T('\\') || *(lpszServer + 1) != _T('\\'))
    {
      cstrPath = _T("\\\\");
      cstrPath += lpszServer;
    } else
    {
      cstrPath = lpszServer;
    }
    cstrPath += _T("\\");
    cstrPath += lpszDir;
    int i = cstrPath.Find(_T(':'));
    ASSERT(-1 != i);
    cstrPath.SetAt(i, _T('$'));
  }
}

// Purpose: verify if the specified drive belongs to a list of disk drives on the server
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
)
{
  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetServerDiskEnum(
                                const_cast<LPTSTR>(lpszServer),
                                0,
                                &pBuffer,        
                                -1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    LPTSTR pDrive = (LPTSTR)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if (_totupper(*pDrive) == _totupper(*lpszDrive))
      {
        hr = S_OK;
        break;
      }
      pDrive += 3;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}

// Purpose: is there a related admin $ share
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDrive
)
{
  ASSERT(!IsLocalComputer(lpszServer));

  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetShareEnum( 
                                const_cast<LPTSTR>(lpszServer),
                                1,
                                &pBuffer,        
                                -1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    PSHARE_INFO_1 pShareInfo = (PSHARE_INFO_1)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if ( (pShareInfo->shi1_type & STYPE_SPECIAL) &&
           _tcslen(pShareInfo->shi1_netname) == 2 &&
           *(pShareInfo->shi1_netname + 1) == _T('$') &&
           _totupper(*(pShareInfo->shi1_netname)) == _totupper(*lpszDrive) )
      {
        hr = S_OK;
        break;
      }
      pShareInfo++;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\wizdir.cpp ===
// WizDir.cpp : implementation file
//

#include "stdafx.h"
#include "shrwiz.h"
#include "WizDir.h"
#include <shlobj.h>
#include "icanon.h"
#include <macfile.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void OpenBrowseDialog(IN HWND hwndParent, IN LPCTSTR lpszComputer, OUT LPTSTR lpszDir);

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
);

BOOL
VerifyDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
);

/////////////////////////////////////////////////////////////////////////////
// CWizFolder property page

IMPLEMENT_DYNCREATE(CWizFolder, CPropertyPage)

CWizFolder::CWizFolder() : CPropertyPage(CWizFolder::IDD)
{
    //{{AFX_DATA_INIT(CWizFolder)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CWizFolder::~CWizFolder()
{
}

void CWizFolder::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWizFolder)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizFolder, CPropertyPage)
    //{{AFX_MSG_MAP(CWizFolder)
    ON_BN_CLICKED(IDC_BROWSEFOLDER, OnBrowsefolder)
    ON_BN_CLICKED(IDC_CHECK_MAC, OnCheckMac)
    ON_BN_CLICKED(IDC_CHECK_MS, OnCheckMs)
    ON_BN_CLICKED(IDC_CHECK_NETWARE, OnCheckNetware)
    ON_EN_CHANGE(IDC_SHARENAME, OnChangeSharename)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETPAGEFOCUS, OnSetPageFocus)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizFolder message handlers

#define SHARE_NAME_LIMIT          NNLEN
#define SFM_SHARE_NAME_LIMIT      AFP_VOLNAME_LEN
#define SHARE_DESCRIPTION_LIMIT   MAXCOMMENTSZ

BOOL CWizFolder::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    GetDlgItem(IDC_FOLDER)->SendMessage(EM_LIMITTEXT, _MAX_DIR - 1, 0);
    GetDlgItem(IDC_SHARENAME)->SendMessage(EM_LIMITTEXT, SHARE_NAME_LIMIT, 0);
    GetDlgItem(IDC_MACSHARENAME)->SendMessage(EM_LIMITTEXT, SFM_SHARE_NAME_LIMIT, 0);
    GetDlgItem(IDC_SHAREDESCRIPTION)->SendMessage(EM_LIMITTEXT, SHARE_DESCRIPTION_LIMIT, 0);
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CWizFolder::OnWizardNext() 
{
  CWaitCursor wait;
  Reset(); // init all related place holders

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_bSMB = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck());
  pApp->m_bFPNW = (1 == ((CButton *)GetDlgItem(IDC_CHECK_NETWARE))->GetCheck());
  pApp->m_bSFM = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());

  if (!pApp->m_bSMB && !pApp->m_bFPNW && !pApp->m_bSFM)
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_CLIENT_REQUIRED);
    GetDlgItem(IDC_CHECK_MS)->SetFocus();
    return -1;
  }

  CString cstrFolder;
  GetDlgItemText(IDC_FOLDER, cstrFolder);
  cstrFolder.TrimLeft();
  cstrFolder.TrimRight();
  if (cstrFolder.IsEmpty())
  {
    CString cstrField;
    cstrField.LoadString(IDS_FOLDER_LABEL);
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  }

  // Removing the ending backslash, otherwise, GetFileAttribute/NetShareAdd will fail.
  if (!IsValidLocalAbsolutePath(cstrFolder))
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_FOLDER);
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  } else
  {
    int iLen = cstrFolder.GetLength();
    if (cstrFolder[iLen - 1] == _T('\\') &&
        cstrFolder[iLen - 2] != _T(':'))
      cstrFolder.SetAt(iLen - 1, _T('\0'));
  }

  if (!VerifyDirectory(pApp->m_cstrTargetComputer, cstrFolder))
  {
    GetDlgItem(IDC_FOLDER)->SetFocus();
    return -1;
  }

  pApp->m_cstrFolder = cstrFolder;

  DWORD dwStatus = 0;
  if (pApp->m_bSMB || pApp->m_bFPNW)
  {
    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);
    cstrShareName.TrimLeft();
    cstrShareName.TrimRight();
    if (cstrShareName.IsEmpty())
    {
      CString cstrField;
      cstrField.LoadString(IDS_SHARENAME_LABEL);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    dwStatus = I_NetNameValidate(
                  const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer)),
                  const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrShareName)),
                  NAMETYPE_SHARE,
                  0);
    if (dwStatus)
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_SHARENAME, cstrShareName);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    if (pApp->m_bSMB && ShareNameExists(cstrShareName, CLIENT_TYPE_SMB) ||
        pApp->m_bFPNW && ShareNameExists(cstrShareName, CLIENT_TYPE_FPNW))
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_DUPLICATE_SHARENAME, cstrShareName);
      GetDlgItem(IDC_SHARENAME)->SetFocus();
      return -1;
    }

    pApp->m_cstrShareName = cstrShareName;
  }

  if (pApp->m_bSMB)
  {
    CString cstrShareDescription;
    GetDlgItemText(IDC_SHAREDESCRIPTION, cstrShareDescription);
    cstrShareDescription.TrimLeft();
    cstrShareDescription.TrimRight();
    pApp->m_cstrShareDescription = cstrShareDescription;
  }

  if (pApp->m_bSFM)
  {
    CString cstrMACShareName;
    GetDlgItemText(IDC_MACSHARENAME, cstrMACShareName);
    cstrMACShareName.TrimLeft();
    cstrMACShareName.TrimRight();
    if (cstrMACShareName.IsEmpty())
    {
      CString cstrField;
      cstrField.LoadString(IDS_MACSHARENAME_LABEL);
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_TEXT_REQUIRED, cstrField);
      GetDlgItem(IDC_MACSHARENAME)->SetFocus();
      return -1;
    } else
    {
      dwStatus = I_NetNameValidate(
                    const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer)),
                    const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrMACShareName)),
                    NAMETYPE_SHARE,
                    0);
      if (dwStatus)
      {
        DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_INVALID_SHARENAME, cstrMACShareName);
        GetDlgItem(IDC_MACSHARENAME)->SetFocus();
        return -1;
      }
    }

    if (ShareNameExists(cstrMACShareName, CLIENT_TYPE_SFM))
    {
      DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONERROR, 0, IDS_DUPLICATE_SHARENAME, cstrMACShareName);
      GetDlgItem(IDC_MACSHARENAME)->SetFocus();
      return -1;
    }

    pApp->m_cstrMACShareName = cstrMACShareName;
  }

  pApp->m_bNextButtonClicked = TRUE;

    return CPropertyPage::OnWizardNext();
}

void CWizFolder::OnBrowsefolder() 
{
  CShrwizApp  *pApp = (CShrwizApp *)AfxGetApp();
  LPTSTR      lpszComputer = const_cast<LPTSTR>(static_cast<LPCTSTR>(pApp->m_cstrTargetComputer));
  CString     cstrPath;
  TCHAR       szDir[MAX_PATH * 2] = _T(""); // double the size in case the remote path is itself close to MAX_PATH
  
  OpenBrowseDialog(m_hWnd, lpszComputer, szDir);
  if (szDir[0])
  {
    if (pApp->m_bIsLocal)
      cstrPath = szDir;
    else
    { // szDir is in the form of \\server\share or \\server\share\path....
      LPTSTR pShare = _tcschr(szDir + 2, _T('\\'));
      pShare++;
      LPTSTR pLeftOver = _tcschr(pShare, _T('\\'));
      if (pLeftOver && *pLeftOver)
        *pLeftOver++ = _T('\0');

      SHARE_INFO_2 *psi = NULL;
      if (NERR_Success == NetShareGetInfo(lpszComputer, pShare, 2, (LPBYTE *)&psi))
      {
        cstrPath = psi->shi2_path;
        if (pLeftOver && *pLeftOver)
        {
          if (_T('\\') != cstrPath.Right(1))
            cstrPath += _T('\\');
          cstrPath += pLeftOver;
        }
        NetApiBufferFree(psi);
      }
    }
  }

  if (!cstrPath.IsEmpty())
    SetDlgItemText(IDC_FOLDER, cstrPath);
}

void CWizFolder::OnCheckClient()
{
  BOOL bSMB = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck());
  BOOL bFPNW = (1 == ((CButton *)GetDlgItem(IDC_CHECK_NETWARE))->GetCheck());
  BOOL bSFM = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());

  GetDlgItem(IDC_SHARENAME)->EnableWindow(bSMB || bFPNW);
  if (!bSMB && !bFPNW)
    SetDlgItemText(IDC_SHARENAME, _T(""));

  GetDlgItem(IDC_SHAREDESCRIPTION)->EnableWindow(bSMB);
  if (!bSMB)
    SetDlgItemText(IDC_SHAREDESCRIPTION, _T(""));

  GetDlgItem(IDC_MACSHARENAME)->EnableWindow(bSFM);
  if (!bSFM)
    SetDlgItemText(IDC_MACSHARENAME, _T(""));
}

void CWizFolder::OnCheckMac() 
{
  OnCheckClient();

  if (1 == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck())
  {
    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);
    SetDlgItemText(IDC_MACSHARENAME, cstrShareName.Left(SFM_SHARE_NAME_LIMIT));
  }
}

void CWizFolder::OnCheckMs() 
{
  OnCheckClient();
}

void CWizFolder::OnCheckNetware() 
{
  OnCheckClient();
}

void CWizFolder::OnChangeSharename() 
{
  BOOL bSMB = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MS))->GetCheck());
  BOOL bFPNW = (1 == ((CButton *)GetDlgItem(IDC_CHECK_NETWARE))->GetCheck());
  BOOL bSFM = (1 == ((CButton *)GetDlgItem(IDC_CHECK_MAC))->GetCheck());
  if ((bSMB || bFPNW) && bSFM)
  {
    CString cstrShareName;
    GetDlgItemText(IDC_SHARENAME, cstrShareName);
    SetDlgItemText(IDC_MACSHARENAME,  cstrShareName.Left(SFM_SHARE_NAME_LIMIT));
  }
}

BOOL CWizFolder::OnSetActive() 
{
    ((CPropertySheet *)GetParent())->SetWizardButtons(PSWIZB_NEXT);

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  if (pApp->m_bNextButtonClicked)
  {
    SetDlgItemText(IDC_COMPUTER, pApp->m_cstrTargetComputer);
    SetDlgItemText(IDC_FOLDER, pApp->m_cstrFolder);
    SetDlgItemText(IDC_SHARENAME, pApp->m_cstrShareName);
    SetDlgItemText(IDC_SHAREDESCRIPTION, pApp->m_cstrShareDescription);
    SetDlgItemText(IDC_SHARENAME_MAC, pApp->m_cstrMACShareName);
    CheckDlgButton(IDC_CHECK_MS, 1);
    CheckDlgButton(IDC_CHECK_NETWARE, 0);
    CheckDlgButton(IDC_CHECK_MAC, 0);
    OnCheckMs();
    GetDlgItem(IDC_CHECK_NETWARE)->EnableWindow(pApp->m_bServerFPNW);
    GetDlgItem(IDC_CHECK_MAC)->EnableWindow(pApp->m_bServerSFM);
    GetDlgItem(IDC_MACSHARENAME_STATIC)->ShowWindow(pApp->m_bServerSFM ? SW_SHOW : SW_HIDE);
    GetDlgItem(IDC_SHARENAME_MAC)->ShowWindow(pApp->m_bServerSFM ? SW_SHOW : SW_HIDE);
    if (!(pApp->m_bServerFPNW) && !(pApp->m_bServerSFM))
    {
      // hide the whole group if only SMB
      GetDlgItem(IDC_CLIENTS_GROUP)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_CHECK_MS)->EnableWindow(FALSE);
      GetDlgItem(IDC_CHECK_MS)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_CHECK_NETWARE)->ShowWindow(SW_HIDE);
      GetDlgItem(IDC_CHECK_MAC)->ShowWindow(SW_HIDE);
    } else
    {
      GetDlgItem(IDC_CLIENTS_GROUP)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_CHECK_MS)->EnableWindow(TRUE);
      GetDlgItem(IDC_CHECK_MS)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_CHECK_NETWARE)->ShowWindow(SW_SHOW);
      GetDlgItem(IDC_CHECK_MAC)->ShowWindow(SW_SHOW);
    }
  } else
  {
    CheckDlgButton(IDC_CHECK_MS, pApp->m_bSMB);
    CheckDlgButton(IDC_CHECK_NETWARE, pApp->m_bFPNW);
    CheckDlgButton(IDC_CHECK_MAC, pApp->m_bSFM);
    OnCheckClient();
  }

  BOOL fRet = CPropertyPage::OnSetActive();

  PostMessage(WM_SETPAGEFOCUS, 0, 0L);

  return fRet;
}

//
// Q148388 How to Change Default Control Focus on CPropertyPage
//
LRESULT CWizFolder::OnSetPageFocus(WPARAM wParam, LPARAM lParam)
{
  GetDlgItem(IDC_FOLDER)->SetFocus();
  return 0;
} 

BOOL CWizFolder::ShareNameExists(IN LPCTSTR lpszShareName, IN CLIENT_TYPE iType)
{
  BOOL        bReturn = FALSE;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  switch (iType)
  {
  case CLIENT_TYPE_SMB:
    {
      bReturn = SMBShareNameExists(pApp->m_cstrTargetComputer, lpszShareName);
      break;
    }
  case CLIENT_TYPE_FPNW:
    {
      ASSERT(pApp->m_hLibFPNW);
      bReturn = FPNWShareNameExists(pApp->m_cstrTargetComputer, lpszShareName, pApp->m_hLibFPNW);
      break;
    }
  case CLIENT_TYPE_SFM:
    {
      ASSERT(pApp->m_hLibSFM);
      bReturn = SFMShareNameExists(pApp->m_cstrTargetComputer, lpszShareName, pApp->m_hLibSFM);
      break;
    }
  default:
    break;
  }

  return bReturn;
}

void CWizFolder::Reset()
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  pApp->m_cstrFolder.Empty();
  pApp->m_cstrShareName.Empty();
  pApp->m_cstrShareDescription.Empty();
  pApp->m_cstrMACShareName.Empty();
  pApp->m_bSMB = FALSE;
  pApp->m_bFPNW = FALSE;
  pApp->m_bSFM = FALSE;
}

////////////////////////////////////////////////////////////
// OpenBrowseDialog
//

//
// 7/11/2001 LinanT bug#426953
// Since connection made by Terminal Service may bring some client side resources 
// (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
// the OK button when browsing to a non-local folder. We don't have this problem
// when browsing a remote machine.
//
typedef struct _LOCAL_DISKS
{
    LPTSTR pszDisks;
    DWORD  dwNumOfDisks;
} LOCAL_DISKS;

#define DISK_ENTRY_LENGTH   3  // Drive letter, colon, NULL
#define DISK_NAME_LENGTH    2  // Drive letter, colon

BOOL InDiskList(IN LPCTSTR pszDir, IN LOCAL_DISKS *pDisks)
{
    if (!pszDir || !pDisks)
        return FALSE;

    DWORD i = 0;
    PTSTR pszDisk = pDisks->pszDisks;
    for (; pszDisk && i < pDisks->dwNumOfDisks; i++)
    {
        if (!_tcsnicmp(pszDisk, pszDir, DISK_NAME_LENGTH))
            return TRUE;

        pszDisk += DISK_ENTRY_LENGTH;
    }

    return FALSE;
}

int CALLBACK
BrowseCallbackProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPARAM lp,
    IN LPARAM pData
)
{
  switch(uMsg) {
  case BFFM_SELCHANGED:
    { 
      // enable the OK button if the selected path is local to that computer.
      BOOL bEnableOK = FALSE;
      TCHAR szDir[MAX_PATH];
      if (SHGetPathFromIDList((LPITEMIDLIST) lp ,szDir))
      {
          if (pData)
          {
              // we're looking at a local computer, verify if szDir is on a local disk
              bEnableOK = InDiskList(szDir, (LOCAL_DISKS *)pData);
          } else
          {
              // no such problem when browsing at a remote computer, always enable OK button.
              bEnableOK = TRUE;
          }
      }
      SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bEnableOK);
      break;
    }
  default:
    break;
  }

  return 0;
}

void OpenBrowseDialog(IN HWND hwndParent, IN LPCTSTR lpszComputer, OUT LPTSTR lpszDir)
{
  ASSERT(lpszComputer && *lpszComputer);

  HRESULT hr = S_OK;

  LOCAL_DISKS localDisks = {0};

  CString cstrComputer;
  if (*lpszComputer != _T('\\') || *(lpszComputer + 1) != _T('\\'))
  {
    cstrComputer = _T("\\\\");
    cstrComputer += lpszComputer;
  } else
  {
    cstrComputer = lpszComputer;
  }

  hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (SUCCEEDED(hr))
  {
    LPMALLOC pMalloc;
    hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
      LPSHELLFOLDER pDesktopFolder;
      hr = SHGetDesktopFolder(&pDesktopFolder);
      if (SUCCEEDED(hr))
      {
        LPITEMIDLIST  pidlRoot;
        if (IsLocalComputer(lpszComputer))
        {
          hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlRoot);
          if (SUCCEEDED(hr))
          {
                //
                // 7/11/2001 LinanT bug#426953
                // Since connection made by Terminal Service may bring some client side resources 
                // (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
                // the OK button when browsing to a non-local folder. We don't have this problem
                // when browsing a remote machine.
                //
               //
               // Get an array of local disk names, this information is later used
               // in the browse dialog to disable OK button if non-local path is selected.
               //
               DWORD dwTotalEntries = 0;
               DWORD nStatus = NetServerDiskEnum(
                                                NULL,   // local computer
                                               0,       // level must be zero
                                               (LPBYTE *)&(localDisks.pszDisks),
                                               -1,      // dwPrefMaxLen,
                                               &(localDisks.dwNumOfDisks),
                                               &dwTotalEntries,
                                               NULL);
               if (NERR_Success != nStatus)
               {
                   hr = HRESULT_FROM_WIN32(nStatus);
               }
          }
        } else
        {
          ULONG chEaten = 0;
          hr = pDesktopFolder->ParseDisplayName(NULL, NULL,
                                const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrComputer)),
                                &chEaten, &pidlRoot, NULL);
        }
        if (SUCCEEDED(hr))
        {
          CString cstrLabel;
          cstrLabel.LoadString(IDS_BROWSE_FOLDER);

          BROWSEINFO bi;
          ZeroMemory(&bi,sizeof(bi));
          bi.hwndOwner = hwndParent;
          bi.pszDisplayName = 0;
          bi.lpszTitle = cstrLabel;
          bi.pidlRoot = pidlRoot;
          bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_SHAREABLE | BIF_USENEWUI;
          bi.lpfn = BrowseCallbackProc;
          if (localDisks.pszDisks)
            bi.lParam = (LPARAM)&localDisks; // pass the structure to the browse dialog

          LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
          if (pidl) {
            SHGetPathFromIDList(pidl, lpszDir);
            pMalloc->Free(pidl);
          }
          pMalloc->Free(pidlRoot);
        }
        pDesktopFolder->Release();
      }
      pMalloc->Release();
    }

    CoUninitialize();
  }

  if (localDisks.pszDisks)
    NetApiBufferFree(localDisks.pszDisks);

  if (FAILED(hr))
    DisplayMessageBox(::GetActiveWindow(), MB_OK|MB_ICONWARNING, hr, IDS_CANNOT_BROWSE_FOLDER, lpszComputer);
}

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
)
{
  DWORD dwPathType = 0;
  DWORD dwStatus = I_NetPathType(
                  NULL,
                  const_cast<LPTSTR>(lpszPath),
                  &dwPathType,
                  0);
  if (dwStatus)
    return FALSE;

  if (dwPathType ^ ITYPE_PATH_ABSD)
    return FALSE;

  return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnExistingFolder
//
//  Synopsis:   Check if pszPath is pointing at an existing folder.
//
//    S_OK:     The specified path points to an existing folder.
//    S_FALSE:  The specified path doesn't point to an existing folder.
//    hr:       Failed to get info on the specified path, or
//              the path exists but doesn't point to a folder.
//              The function reports error msg for both failures if desired.
//----------------------------------------------------------------------------
HRESULT
IsAnExistingFolder(
    IN HWND     hwnd,
    IN LPCTSTR  pszPath,
    IN BOOL     bDisplayErrorMsg
)
{
  if (!hwnd)
    hwnd = GetActiveWindow();

  HRESULT   hr = S_OK;
  DWORD     dwRet = GetFileAttributes(pszPath);

  if (-1 == dwRet)
  {
    DWORD dwErr = GetLastError();
    if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
    {
      // the specified path doesn't exist
      hr = S_FALSE;
    }
    else
    {
      hr = HRESULT_FROM_WIN32(dwErr);

      if (ERROR_NOT_READY == dwErr)
      {
        // fix for bug#358033/408803: ignore errors from GetFileAttributes in order to 
        // allow the root of movable drives to be shared without media inserted in.  
        int len = _tcslen(pszPath);
        if (len > 3 && 
            pszPath[len - 1] == _T('\\') &&
            pszPath[len - 2] == _T(':'))
        {
          // pszPath is pointing at the root of the drive, ignore the error
          hr = S_OK;
        }
      }

      if ( FAILED(hr) && bDisplayErrorMsg )
        DisplayMessageBox(hwnd, MB_OK, dwErr, IDS_FAILED_TO_GETINFO_FOLDER, pszPath);
    }
  } else if ( 0 == (dwRet & FILE_ATTRIBUTE_DIRECTORY) )
  {
    // the specified path is not pointing to a folder
    if (bDisplayErrorMsg)
      DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, 0, IDS_PATH_NOT_FOLDER, pszPath);
    hr = E_FAIL;
  }

  return hr;
}

// create the directories layer by layer
HRESULT
CreateLayeredDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
)
{
  ASSERT(IsValidLocalAbsolutePath(lpszDir));

  BOOL    bLocal = IsLocalComputer(lpszServer);

  CString cstrFullPath;
  GetFullPath(lpszServer, lpszDir, cstrFullPath);

  // add prefix to skip the CreateDirectory limit of 248 chars
  CString cstrFullPathNoParsing = (bLocal ? _T("\\\\?\\") : _T("\\\\?\\UNC"));
  cstrFullPathNoParsing += (bLocal ? cstrFullPath : cstrFullPath.Right(cstrFullPath.GetLength() - 1));

  HRESULT hr = IsAnExistingFolder(NULL, cstrFullPathNoParsing, FALSE);
  ASSERT(S_FALSE == hr);

  LPTSTR  pch = _tcschr(cstrFullPathNoParsing, (bLocal ? _T(':') : _T('$')));
  ASSERT(pch);

  // pszPath holds "\\?\C:\a\b\c\d" or "\\?\UNC\server\share\a\b\c\d"
  // pszLeft holds "a\b\c\d"
  LPTSTR  pszPath = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrFullPathNoParsing));
  LPTSTR  pszLeft = pch + 2;
  LPTSTR  pszRight = NULL;

  ASSERT(pszLeft && *pszLeft);

  //
  // this loop will find out the 1st non-existing sub-dir to create, and
  // the rest of non-existing sub-dirs
  //
  while (pch = _tcsrchr(pszLeft, _T('\\')))  // backwards search for _T('\\')
  {
    *pch = _T('\0');
    hr = IsAnExistingFolder(NULL, pszPath, TRUE);
    if (FAILED(hr))
      return S_FALSE;  // errormsg has already been reported by IsAnExistingFolder().

    if (S_OK == hr)
    {
      //
      // pszPath is pointing to the parent dir of the 1st non-existing sub-dir.
      // Once we restore the _T('\\'), pszPath will point at the 1st non-existing subdir.
      //
      *pch = _T('\\');
      break;
    } else
    {
      //
      // pszPath is pointing to a non-existing folder, continue with the loop.
      //
      if (pszRight)
        *(pszRight - 1) = _T('\\');
      pszRight = pch + 1;
    }
  }

  // We're ready to create directories:
  // pszPath points to the 1st non-existing dir, e.g., "C:\a\b" or "\\server\share\a\b"
  // pszRight points to the rest of non-existing sub dirs, e.g., "c\d"
  // 
  do 
  {
    if (!CreateDirectory(pszPath, NULL))
      return HRESULT_FROM_WIN32(GetLastError());

    if (!pszRight || !*pszRight)
      break;

    *(pszRight - 1) = _T('\\');
    if (pch = _tcschr(pszRight, _T('\\')))  // forward search for _T('\\')
    {
      *pch = _T('\0');
      pszRight = pch + 1;
    } else
    {
      pszRight = NULL;
    }
  } while (1);

  return S_OK;
}

BOOL
VerifyDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszDir
)
{
  ASSERT(lpszDir && *lpszDir);
  ASSERT(IsValidLocalAbsolutePath(lpszDir));

  HWND hwnd = ::GetActiveWindow();

  BOOL    bLocal = IsLocalComputer(lpszServer);
  HRESULT hr = VerifyDriveLetter(lpszServer, lpszDir);
  if (FAILED(hr))
  { /*
    // fix for bug#351212: ignore error and leave permission checkings to NetShareAdd apis
    DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszDir);
    return FALSE;
    */
    hr = S_OK;
  } else if (S_OK != hr)
  {
    DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, 0, IDS_INVALID_DRIVE, lpszDir);
    return FALSE;
  }

  if (!bLocal)
  {
    hr = IsAdminShare(lpszServer, lpszDir);
    if (FAILED(hr))
    {
      DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszDir);
      return FALSE;
    } else if (S_OK != hr)
    {
      // there is no matching $ shares, hence, no need to call GetFileAttribute, CreateDirectory,
      // assume lpszDir points to an existing directory
      return TRUE;
    }
  }

  CString cstrPath;
  GetFullPath(lpszServer, lpszDir, cstrPath);

  // add prefix to skip the GetFileAttribute limit when the path is on a remote server
  CString cstrPathNoParsing = (bLocal ? _T("\\\\?\\") : _T("\\\\?\\UNC"));
  cstrPathNoParsing += (bLocal ? cstrPath : cstrPath.Right(cstrPath.GetLength() - 1));

  hr = IsAnExistingFolder(hwnd, cstrPathNoParsing, TRUE); // error has already been reported.
  if (FAILED(hr) || S_OK == hr)
    return (S_OK == hr);

  if ( IDYES != DisplayMessageBox(hwnd, MB_YESNO|MB_ICONQUESTION, 0, IDS_CREATE_NEW_DIR, cstrPath) )
    return FALSE;

  // create the directories layer by layer
  hr = CreateLayeredDirectory(lpszServer, lpszDir);
  if (FAILED(hr))
    DisplayMessageBox(hwnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_CREATE_NEW_DIR, cstrPath);

  return (S_OK == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\mustard.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Mustard.h : main header file for the MUSTARD application

File History:

	JonY	Jan-96	created

--*/


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMustardApp:
// See Mustard.cpp for the implementation of this class
//

class CMustardApp : public CWinApp
{
public:
	CMustardApp();
	BOOL IsSecondInstance();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMustardApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMustardApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\listdata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Listdata.h : class implementation of list member data

File History:

	JonY	Jan-96	created

--*/


// 

class CItemData : public CObject
{
	public:
	HICON hIcon;
	HICON hSelIcon;
	CString csName;
	CString csDesc;
	CString csAppStart1;
	CString csAppStart2;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\wizperm.h ===
#if !defined(AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizPerm.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizPerm dialog

class CWizPerm : public CPropertyPage
{
	DECLARE_DYNCREATE(CWizPerm)

// Construction
public:
	CWizPerm();
	~CWizPerm();

// Dialog Data
	//{{AFX_DATA(CWizPerm)
	enum { IDD = IDD_SHRWIZ_PERM };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizPerm)
	public:
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizPerm)
	afx_msg void OnRadioPerm1();
	afx_msg void OnRadioPerm2();
	afx_msg void OnRadioPerm3();
	afx_msg void OnRadioPerm4();
	afx_msg void OnPermCustom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

  void Reset();
  int  CreateShare();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZPERM_H__6E49F4C0_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mustard.rc
//
#define IDS_GENERIC_NO_HEAP             1
#define IDS_GENERIC_NO_PRINTLIB         2
#define IDS_GENERIC_NO_PRINTER_CREATED  3
#define IDS_PRINT_NAME                  4
#define IDS_PRINT_DESC                  5
#define IDS_MODEM_NAME                  6
#define IDS_MODEM_DESC                  7
#define IDS_ARS_NAME                    8
#define IDS_ARS_DESC                    9
#define IDS_WKSSETUP_NAME               10
#define IDS_WKSSETUP_DESC               11
#define IDS_GROUP_NAME                  12
#define IDS_GROUP_DESC                  13
#define IDS_USER_NAME                   14
#define IDS_USER_DESC                   15
#define IDS_SHRPUB_NAME                 16
#define IDS_SHRPUB_DESC                 17
#define IDS_FDS_NAME                    18
#define IDS_FDS_DESC                    19
#define IDS_NO_START                    20
#define IDS_BAD_VERSION                 21
#define IDS_ADD_PRINTER                 22
#define IDS_FONT_NAME                   23
#define IDS_FONT_SIZE                   24
#define IDS_BIGFONT_SIZE                25
#define IDD_MUSTARD_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDB_BITMAP1                     130
#define IDR_ACCELERATOR1                131
#define IDR_ACCELERATOR2                132
#define IDC_WIZ_LIST                    1000
#define IDC_STATIC1                     1002
#define IDC_STATIC2                     1003
#define IDC_QUIT_BUTTON                 1004
#define IDC_STARTUP                     1005
#define IDC_WIZ_LIST2                   1006
#define ID_ACCEL_PRINT                  32771
#define ID_ACCEL_MODEM                  32772
#define ID_ACCEL_NETWORK                32773
#define ID_ACCEL_GROUP                  32774
#define ID_ACCEL_USER                   32775
#define ID_ACCEL_SHARE                  32776
#define ID_ACCEL_PROGRAMS               32777
#define ID_ACCEL_LICENSE                32779
#define IDS_CAPTION                     57345
#define IDS_APPWIZ                      57346
#define IDS_MODEM                       57347

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\wizdir.h ===
#if !defined(AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
#define AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizDir.h : header file
//

typedef enum _CLIENT_TYPE {
    CLIENT_TYPE_SMB=0, 
    CLIENT_TYPE_FPNW, 
    CLIENT_TYPE_SFM
} CLIENT_TYPE;

/////////////////////////////////////////////////////////////////////////////
// CWizFolder dialog

class CWizFolder : public CPropertyPage
{
	DECLARE_DYNCREATE(CWizFolder)

// Construction
public:
	CWizFolder();
	~CWizFolder();

// Dialog Data
	//{{AFX_DATA(CWizFolder)
	enum { IDD = IDD_SHRWIZ_FOLDER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizFolder)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizFolder)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowsefolder();
	afx_msg void OnCheckMac();
	afx_msg void OnCheckMs();
	afx_msg void OnCheckNetware();
	afx_msg void OnChangeSharename();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

  LRESULT OnSetPageFocus(WPARAM wParam, LPARAM lParam);
  void OnCheckClient();
  void Reset();
  BOOL ShareNameExists(IN LPCTSTR lpszShareName, IN CLIENT_TYPE iType);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZDIR_H__5F8E4B7A_C1ED_11D2_8E4A_0000F87A3388__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\shrwiz\wizperm.cpp ===
// WizPerm.cpp : implementation file
//

#include "stdafx.h"
#include "shrwiz.h"
#include "WizPerm.h"
#include "aclpage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizPerm property page

IMPLEMENT_DYNCREATE(CWizPerm, CPropertyPage)

CWizPerm::CWizPerm() : CPropertyPage(CWizPerm::IDD)
{
	//{{AFX_DATA_INIT(CWizPerm)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWizPerm::~CWizPerm()
{
}

void CWizPerm::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWizPerm)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizPerm, CPropertyPage)
	//{{AFX_MSG_MAP(CWizPerm)
	ON_BN_CLICKED(IDC_RADIO_PERM1, OnRadioPerm1)
	ON_BN_CLICKED(IDC_RADIO_PERM2, OnRadioPerm2)
	ON_BN_CLICKED(IDC_RADIO_PERM3, OnRadioPerm3)
	ON_BN_CLICKED(IDC_RADIO_PERM4, OnRadioPerm4)
	ON_BN_CLICKED(IDC_PERM_CUSTOM, OnPermCustom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizPerm message handlers
void CWizPerm::OnRadioPerm1() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
  GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(TRUE);
}

void CWizPerm::OnRadioPerm2() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
  GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(TRUE);
}

void CWizPerm::OnRadioPerm3() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(FALSE);
  GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(TRUE);
}

void CWizPerm::OnRadioPerm4() 
{
  Reset();
  GetDlgItem(IDC_PERM_CUSTOM)->EnableWindow(TRUE);
  GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(FALSE);
}

void CWizPerm::OnPermCustom() 
{
  CWaitCursor wait;
  HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (FAILED(hr))
  {
    TRACE(_T("CoInitializeEx failed hr=%x"), hr);
    return;
  }

  CShrwizApp                *pApp = (CShrwizApp *)AfxGetApp();
  CShareSecurityInformation *pssInfo = NULL;
  HPROPSHEETPAGE            phPages[2];
  int                       cPages = 1;

  CString cstrSheetTitle, cstrSharePageTitle;
  cstrSheetTitle.LoadString(IDS_CUSTOM_PERM);
  cstrSharePageTitle.LoadString(IDS_SHARE_PERMISSIONS);

  // create "Share Permissions" property page
  BOOL bSFMOnly = (!pApp->m_bSMB && !pApp->m_bFPNW && pApp->m_bSFM);
  if (bSFMOnly)
  {
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = AfxGetResourceHandle();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NO_SHARE_PERMISSIONS);
    psp.pszTitle = cstrSharePageTitle;

    phPages[0] = CreatePropertySheetPage(&psp);
    if ( !(phPages[0]) )
    {
      hr = GetLastError();
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
    }
  } else
  {
    pssInfo = new CShareSecurityInformation(pApp->m_pSD);
    if (!pssInfo)
    {
      hr = E_OUTOFMEMORY;
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
    } else
    {
      pssInfo->Initialize(pApp->m_cstrTargetComputer, pApp->m_cstrShareName, cstrSharePageTitle);
      phPages[0] = CreateSecurityPage(pssInfo);
      if ( !(phPages[0]) )
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
      }
    }
  }
  
  if (SUCCEEDED(hr))
  {
    // create "File Security" property page
    CFileSecurityDataObject *pfsDataObject = new CFileSecurityDataObject;
    if (!pfsDataObject)
    {
      hr = E_OUTOFMEMORY;
      DisplayMessageBox(m_hWnd, MB_OK|MB_ICONWARNING, hr, IDS_FAILED_TO_CREATE_ACLUI);
      // destroy pages that have not been passed to the PropertySheet function
      DestroyPropertySheetPage(phPages[0]);
    } else
    {
      pfsDataObject->Initialize(pApp->m_cstrTargetComputer, pApp->m_cstrFolder);
      hr = CreateFileSecurityPropPage(&(phPages[1]), pfsDataObject);
      if (SUCCEEDED(hr))
        cPages = 2;

      PROPSHEETHEADER psh;
      ZeroMemory(&psh, sizeof(psh));
      psh.dwSize = sizeof(psh);
      psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
      psh.hwndParent = m_hWnd;
      psh.hInstance = AfxGetResourceHandle();
      psh.pszCaption = cstrSheetTitle;
      psh.nPages = cPages;
      psh.phpage = phPages;

      // create the property sheet
      PropertySheet(&psh);

      // acl pages have been successfully added, enable the Finish button
      GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(TRUE);

      pfsDataObject->Release();
    }
  }

  if (!bSFMOnly)
  {
    if (pssInfo)
      pssInfo->Release();
  }

  CoUninitialize();
}

LRESULT CWizPerm::OnWizardBack() 
{
  Reset();

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  pApp->m_bNextButtonClicked = FALSE;
	
	return CPropertyPage::OnWizardBack();
}

BOOL CWizPerm::OnWizardFinish() 
{
  CWaitCursor wait;
  HRESULT     hr = S_OK;
  BOOL        bCustom = FALSE;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  pApp->m_bNextButtonClicked = TRUE;
	
  switch (GetCheckedRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4))
  {
  case IDC_RADIO_PERM1:
    {
      CPermEntry permEntry;
      hr = permEntry.Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_FULL_CONTROL);
      if (SUCCEEDED(hr))
        hr = BuildSecurityDescriptor(&permEntry, 1, &(pApp->m_pSD));
    }
    break;
  case IDC_RADIO_PERM2:
    {
      CPermEntry permEntry[2];
      hr = permEntry[0].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_EVERYONE, SHARE_PERM_READ_ONLY);
      if (SUCCEEDED(hr))
      {
        hr = permEntry[1].Initialize(pApp->m_cstrTargetComputer, ACCOUNT_ADMINISTRATORS, SHARE_PERM_FULL_CONTROL);
        if (SUCCEEDED(hr))
          hr = BuildSecurityDescriptor(permEntry, 2, &(pApp->m_pSD));
      }
    }
    break;
  case IDC_RADIO_PERM3:
    {
      CPermEntry permEntry;
      hr = permEntry.Initialize(pApp->m_cstrTargetComputer, ACCOUNT_ADMINISTRATORS, SHARE_PERM_FULL_CONTROL);
      if (SUCCEEDED(hr))
        hr = BuildSecurityDescriptor(&permEntry, 1, &(pApp->m_pSD));
    }
    break;
  case IDC_RADIO_PERM4:
    bCustom = TRUE;
    break;
  default:
    ASSERT(FALSE);
    return FALSE; // prevent the property sheet from being destroyed
  }

  if (!bCustom && FAILED(hr))
  {
    DisplayMessageBox(m_hWnd, MB_OK|MB_ICONERROR, hr, IDS_FAILED_TO_GET_SD);
    return FALSE; // prevent the property sheet from being destroyed
  }

  switch (CreateShare())
  {
  case IDNO:        // succeeded, no more shares
    break;
  case IDYES:       // succeeded, need to create more shares
    pApp->Reset();  // jump back to the first page, and fall through
  default:          // error happened
    return FALSE;   // prevent the property sheet from being destroyed
  }

	return CPropertyPage::OnWizardFinish();
}

BOOL CWizPerm::OnSetActive() 
{
	((CPropertySheet *)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);

  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  if (pApp->m_bNextButtonClicked)
  {
    BOOL bSFMOnly = (!pApp->m_bSMB && !pApp->m_bFPNW && pApp->m_bSFM);
    if (bSFMOnly)
    {
      GetDlgItem(IDC_RADIO_PERM1)->EnableWindow(FALSE);
      GetDlgItem(IDC_RADIO_PERM2)->EnableWindow(FALSE);
      GetDlgItem(IDC_RADIO_PERM3)->EnableWindow(FALSE);
      CheckRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4, IDC_RADIO_PERM4);
      OnRadioPerm4();
      // enable the Finish button initially if only MAC is selected
      GetParent()->GetDlgItem(ID_WIZFINISH)->EnableWindow(TRUE);
    } else
    {
      GetDlgItem(IDC_RADIO_PERM1)->EnableWindow(TRUE);
      GetDlgItem(IDC_RADIO_PERM2)->EnableWindow(TRUE);
      GetDlgItem(IDC_RADIO_PERM3)->EnableWindow(TRUE);
      CheckRadioButton(IDC_RADIO_PERM1, IDC_RADIO_PERM4, IDC_RADIO_PERM1);
      OnRadioPerm1();
    }
  }
	
	return CPropertyPage::OnSetActive();
}

void CWizPerm::Reset() 
{
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();

  if (pApp->m_pSD)
  {
    LocalFree((HLOCAL)(pApp->m_pSD));
    pApp->m_pSD = NULL;
  }
}

int
CWizPerm::CreateShare()
{
  DWORD dwRet = NERR_Success;
  CShrwizApp *pApp = (CShrwizApp *)AfxGetApp();
  UINT    iSuccess = 0;
  CString cstrSuccessMsg;
  CString cstrFailureMsg;
  CString cstrLineReturn;
  cstrLineReturn.LoadString(IDS_LINE_RETURN);

  do {
    CString cstrMsg;
    cstrSuccessMsg.LoadString(IDS_SUCCEEDED_IN_CREATING_SHARE);

    if (pApp->m_bSMB)
    {
      CString cstrSMB;
      cstrSMB.LoadString(IDS_SMB_CLIENTS);

      dwRet = SMBCreateShare(
                  pApp->m_cstrTargetComputer,
                  pApp->m_cstrShareName,
                  pApp->m_cstrShareDescription,
                  pApp->m_cstrFolder,
                  pApp->m_pSD
                  );
      if (NERR_Success != dwRet)
      {
        GetDisplayMessage(cstrMsg, dwRet, IDS_FAILED_TO_CREATE_SHARE, cstrSMB);
        cstrFailureMsg += cstrMsg;
        cstrFailureMsg += cstrLineReturn;
      } else 
      {
        iSuccess++;
        cstrSuccessMsg += cstrSMB;
        cstrSuccessMsg += cstrLineReturn;
        pApp->m_bSMB = FALSE;

        if (pApp->m_bIsLocal) // refresh shell
          SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH | SHCNF_FLUSH, pApp->m_cstrFolder, 0);
      }
    }

    if (pApp->m_bFPNW)
    {
      CString cstrFPNW;
      cstrFPNW.LoadString(IDS_FPNW_CLIENTS);

      dwRet = FPNWCreateShare(
                  pApp->m_cstrTargetComputer,
                  pApp->m_cstrShareName,
                  pApp->m_cstrFolder,
                  pApp->m_pSD,
                  pApp->m_hLibFPNW
                  );
      if (NERR_Success != dwRet)
      {
        GetDisplayMessage(cstrMsg, dwRet, IDS_FAILED_TO_CREATE_SHARE, cstrFPNW);
        cstrFailureMsg += cstrMsg;
        cstrFailureMsg += cstrLineReturn;
      } else 
      {
        iSuccess++;
        cstrSuccessMsg += cstrFPNW;
        cstrSuccessMsg += cstrLineReturn;
        pApp->m_bFPNW = FALSE;
      }
    }

    if (pApp->m_bSFM)
    {
      CString cstrSFM;
      cstrSFM.LoadString(IDS_SFM_CLIENTS);

      dwRet = SFMCreateShare(
                  pApp->m_cstrTargetComputer,
                  pApp->m_cstrMACShareName,
                  pApp->m_cstrFolder,
                  pApp->m_hLibSFM
                  );
      if (NERR_Success != dwRet)
      {
        GetDisplayMessage(cstrMsg, dwRet, IDS_FAILED_TO_CREATE_SHARE, cstrSFM);
        cstrFailureMsg += cstrMsg;
        cstrFailureMsg += cstrLineReturn;
      } else
      {
        iSuccess++;
        cstrSuccessMsg += cstrSFM;
        cstrSuccessMsg += cstrLineReturn;
        pApp->m_bSFM = FALSE;
      }
    }
  } while (0);

  cstrSuccessMsg += cstrLineReturn;
  if (cstrFailureMsg.IsEmpty())
  {
    CString cstrMoreShares;
    cstrMoreShares.LoadString(IDS_OPERATION_SUCCEEDED_MORE_SHARES);
    return DisplayMessageBox(m_hWnd, MB_YESNO|MB_ICONINFORMATION, 0, 0, 
                  cstrSuccessMsg + cstrMoreShares);
  } else
  {
    DisplayMessageBox(m_hWnd, MB_OK|MB_ICONERROR, 0, 0, 
            (iSuccess ? (cstrSuccessMsg + cstrFailureMsg) : cstrFailureMsg));
    return IDRETRY;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\mustard.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Mustard.cpp : implementation file

File History:

	JonY	Jan-96	created

--*/

#include "stdafx.h"
#include "Mustard.h"
#include "wizlist.h"
#include "Startd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMustardApp

BEGIN_MESSAGE_MAP(CMustardApp, CWinApp)
	//{{AFX_MSG_MAP(CMustardApp)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMustardApp construction

BOOL CMustardApp::IsSecondInstance()
{
    HANDLE hSem;

       //create a semaphore object with max count of 1
    hSem = CreateSemaphore(NULL, 0, 1, L"Wizmgr Semaphore");
    if (hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hSem);
		CString csAppName;
		csAppName.LoadString(AFX_IDS_APP_TITLE);
        CWnd* pWnd = CWnd::FindWindow(NULL, (LPCTSTR)csAppName);
        if (pWnd)
			{
			pWnd->ShowWindow(SW_RESTORE);
			}

        return TRUE;
    }

    return FALSE;
}

CMustardApp::CMustardApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMustardApp object

CMustardApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMustardApp initialization

BOOL CMustardApp::InitInstance()
{
	if (IsSecondInstance())
        return FALSE;

// check for OS version
	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(os);
	GetVersionEx(&os);

	if (os.dwMajorVersion < 4) 
		{
		AfxMessageBox(IDS_BAD_VERSION, MB_ICONSTOP);
		ExitProcess(0);
		}
	// Standard initialization

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CStartD dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
	}
	else if (nResponse == IDCANCEL)
	{
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stdafx.cpp : implementation file

File History:

	JonY	Jan-96	created

--*/

// stdafx.cpp : source file that includes just the standard includes
//	Mustard.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stdafx.h : header file

File History:

	JonY	Jan-96	created

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\wizlist.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	WizList.h : header file

File History:

	JonY	Jan-96	created

--*/


#include <winnetwk.h>
#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CWizList window

class CWizList : public CListBox
{
// Construction
public:
	CWizList();

// Attributes
public:
   CWizList* m_pOtherGuy;
   void PumpMessages();

// Operations
public:
private:
	BOOL LaunchPrinterWizard();
	HRESULT GetAddPrinterObject(LPSHELLFOLDER pshf, LPITEMIDLIST* ppidl);

	CFont* m_pFont;
	CFont* m_pFontBold;

	BOOL m_bSignalled;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizList)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWizList();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWizList)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	HMODULE	m_hPrinterLib;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\startd.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StartD.cpp : implementation file

File History:

	JonY	Jan-96	created

--*/


#include "stdafx.h"
#include "Mustard.h"
#include "wizlist.h"
#include "StartD.h"
#include "Listdata.h"

#include <winreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPITEMIDLIST CreatePIDL(UINT cbSize);
LPITEMIDLIST ConcatPIDLs(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
LPITEMIDLIST Next(LPCITEMIDLIST pidl);
UINT GetSize(LPCITEMIDLIST pidl);

/////////////////////////////////////////////////////////////////////////////
// CStartD dialog


CStartD::CStartD(CWnd* pParent /*=NULL*/)
	: CDialog(CStartD::IDD, pParent), m_bActive(TRUE),
	m_hAccelTable(NULL)
{
	//{{AFX_DATA_INIT(CStartD)
	m_bStartup = TRUE;
	//}}AFX_DATA_INIT
	m_pFont1 = NULL;
	m_pFont2 = NULL;

	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

// Load the accelerator tables.
	m_hAccelTable = LoadAccelerators(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_ACCELERATOR1));
}

CStartD::~CStartD()
{
	if (m_pFont1 != NULL) delete m_pFont1;
//	if (m_pFont2 != NULL) delete m_pFont2;

}
void CStartD::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStartD)
	DDX_Control(pDX, IDC_WIZ_LIST2, m_lbWizList2);
	DDX_Control(pDX, IDC_WIZ_LIST, m_lbWizList);
	DDX_Check(pDX, IDC_STARTUP, m_bStartup);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStartD, CDialog)
	//{{AFX_MSG_MAP(CStartD)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_QUIT_BUTTON, OnQuitButton)
	ON_WM_ACTIVATEAPP()
	ON_WM_QUERYDRAGICON()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_ACCEL_GROUP, OnAccelGroup)
	ON_COMMAND(ID_ACCEL_MODEM, OnAccelModem)
	ON_COMMAND(ID_ACCEL_NETWORK, OnAccelNetwork)
	ON_COMMAND(ID_ACCEL_PRINT, OnAccelPrint)
	ON_COMMAND(ID_ACCEL_SHARE, OnAccelShare)
	ON_COMMAND(ID_ACCEL_USER, OnAccelUser)
	ON_COMMAND(ID_ACCEL_PROGRAMS, OnAccelPrograms)
	ON_COMMAND(ID_ACCEL_LICENSE, OnAccelLicense)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStartD message handlers
BOOL CStartD::OnInitDialog() 
{
	CDialog::OnInitDialog();

// tell the two sides about each other
	m_lbWizList2.m_pOtherGuy = &m_lbWizList;
	m_lbWizList.m_pOtherGuy = &m_lbWizList2;

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

// font information for the headings
	m_pFont1 = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.

        CString fontname;
	fontname.LoadString(IDS_FONT_NAME);
	_tcscpy(lf.lfFaceName, fontname);  

        CString fontheight;
        fontheight.LoadString(IDS_BIGFONT_SIZE);
	lf.lfHeight = (LONG)_tcstoul(fontheight, NULL, 10);

	lf.lfWeight = 700;
	m_pFont1->CreateFontIndirect(&lf);    // Create the font.

	CString cs;
	cs.LoadString(IDS_CAPTION);
	CWnd* pWnd = GetDlgItem(IDC_STATIC1);
	pWnd->SetWindowText(cs);
	pWnd->SetFont(m_pFont1);

	CMustardApp* pApp = (CMustardApp*)AfxGetApp();

// get install dir
	TCHAR pSysDir[256];
	UINT nLen = GetWindowsDirectory(pSysDir, 256);
	if (*(pSysDir + nLen) != '\\') _tcscat(pSysDir, L"\\");
	_tcscat(pSysDir, L"SYSTEM32\\");

// Add User
	CItemData* pData = new CItemData;
	pData->csName.LoadString(IDS_USER_NAME);//	= L"Add User";
	pData->csDesc.LoadString(IDS_USER_DESC);//	= L"Add User";

	pData->csAppStart1 = pSysDir + CString(L"addusrw.exe");
	pData->csAppStart2 = L"";

	GetIconIndices(pData->csAppStart1, &pData->hIcon, &pData->hSelIcon);
	
	m_lbWizList.InsertString(0, _T(""));	
	m_lbWizList.SetItemData(0, (LONG_PTR)pData);

// Group Creation
	pData = new CItemData;
	pData->csName.LoadString(IDS_GROUP_NAME);//	= L"Group Creation";
	pData->csDesc.LoadString(IDS_GROUP_DESC);//	= L"Group Creation";

	pData->csAppStart1 = pSysDir + CString(L"addgrpw.exe");
	pData->csAppStart2 = L"";

	GetIconIndices(pData->csAppStart1, &pData->hIcon, &pData->hSelIcon);

	m_lbWizList.InsertString(1, _T(""));	
	m_lbWizList.SetItemData(1, (LONG_PTR)pData);

// Share Publishing / folder security
	pData = new CItemData;
	pData->csName.LoadString(IDS_SHRPUB_NAME);//	= L"Share Publishing";
	pData->csDesc.LoadString(IDS_SHRPUB_DESC);//	= L"Share Publishing ";

	pData->csAppStart1 = pSysDir + CString(L"shrpubw.exe");
	pData->csAppStart2 = L"";

	GetIconIndices(pData->csAppStart1, &pData->hIcon, &pData->hSelIcon);
	
	m_lbWizList.InsertString(2, _T(""));	
	m_lbWizList.SetItemData(2, (LONG_PTR)pData);

// printer
	pData = new CItemData;
	pData->csName.LoadString(IDS_PRINT_NAME);//	= L"Add Printer";
	pData->csDesc.LoadString(IDS_PRINT_DESC);//	= L"Print manager";

	pData->csAppStart1 = L"";
	pData->csAppStart2 = L"";

	GetCPLIcon(IDS_ADD_PRINTER, &pData->hIcon, &pData->hSelIcon, TRUE);

	m_lbWizList.InsertString(3, _T(""));	
	m_lbWizList.SetItemData(3, (LONG_PTR)pData);

// Add/remove software
	pData = new CItemData;
	pData->csName.LoadString(IDS_ARS_NAME);//	= L"Add/Remove software";
	pData->csDesc.LoadString(IDS_ARS_DESC);//	= L"Add/Remove software";

	pData->csAppStart1 = L"control.exe";
	pData->csAppStart2 = L"appwiz.cpl";

	GetCPLIcon(IDS_APPWIZ, &pData->hIcon, &pData->hSelIcon);
	
	m_lbWizList2.InsertString(0, _T(""));	
	m_lbWizList2.SetItemData(0, (LONG_PTR)pData);

// modem
	pData = new CItemData;
	pData->csName.LoadString(IDS_MODEM_NAME);//	= L"Add Modem";
	pData->csDesc.LoadString(IDS_MODEM_DESC);//	= L"Modems, ports, etc";

	pData->csAppStart1 = L"control.exe";
	pData->csAppStart2 = L"modem.cpl";

	GetCPLIcon(IDS_MODEM, &pData->hIcon, &pData->hSelIcon);

	m_lbWizList2.InsertString(1, _T(""));	
	m_lbWizList2.SetItemData(1, (LONG_PTR)pData);

// Workstation installation
	pData = new CItemData;
	pData->csName.LoadString(IDS_WKSSETUP_NAME);//	= L"Workstation Installation";
	pData->csDesc.LoadString(IDS_WKSSETUP_DESC);//	= L"Workstation Installation";

	pData->csAppStart1 = pSysDir + CString(L"ncadmin.exe");
	pData->csAppStart2 = L"";

	GetIconIndices(pData->csAppStart1, &pData->hIcon, &pData->hSelIcon);

	m_lbWizList2.InsertString(2, _T(""));	
	m_lbWizList2.SetItemData(2, (LONG_PTR)pData);
						   
// license compliancy
	pData = new CItemData;
	pData->csName.LoadString(IDS_FDS_NAME);
	pData->csDesc.LoadString(IDS_FDS_DESC);

	pData->csAppStart1 = pSysDir + CString(L"lcwiz.exe");
	pData->csAppStart2 = L"";

	GetIconIndices(pData->csAppStart1, &pData->hIcon, &pData->hSelIcon);

	m_lbWizList2.InsertString(3, _T(""));	
	m_lbWizList2.SetItemData(3, (LONG_PTR)pData);


// check the registry to see if we are loaded automatically at startup
	DWORD dwRet;
	HKEY hKey;
	DWORD cbProv = 0;
	TCHAR* lpProv = NULL;

    dwRet = RegOpenKey(HKEY_CURRENT_USER,
		TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows"), &hKey );

	TCHAR* lpStartup = NULL;
	if ((dwRet = RegQueryValueEx( hKey, TEXT("run"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpStartup = (TCHAR*)malloc(cbProv);
		if (lpStartup == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			ExitProcess(1);
			}
		dwRet = RegQueryValueEx( hKey, TEXT("run"), NULL, NULL, (LPBYTE) lpStartup, &cbProv );
// see if we are included
		if (_tcsstr(lpStartup, L"wizmgr.exe") != NULL)
			m_bStartup = TRUE;
		else m_bStartup = FALSE;
		UpdateData(FALSE);
		}

	free(lpStartup);
	RegCloseKey(hKey);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CStartD::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	if (IsIconic())
		{

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
		}

	else
		{
		CPen pBlackPen(PS_SOLID, 1, RGB(0,0,0));
		CPen* pOriginalPen = (CPen*)dc.SelectObject(pBlackPen);
		dc.MoveTo(596, 77);
		dc.LineTo(2, 77);
		dc.LineTo(2, 362);

		CPen pLtGreyPen(PS_SOLID, 1, RGB(192, 192, 192));
		dc.SelectObject(pLtGreyPen);
		dc.LineTo(596, 362);
		dc.LineTo(596, 77);

		CPen pDkGreyPen(PS_SOLID, 1, RGB(128, 128, 128));
		dc.SelectObject(pDkGreyPen);
		dc.MoveTo(597, 76);
		dc.LineTo(1, 76);
		dc.LineTo(1, 363);

		CPen pWhitePen(PS_SOLID, 1, RGB(255, 255, 255));
		dc.SelectObject(pWhitePen);
		dc.MoveTo(2, 363);
		dc.LineTo(598, 363);
		dc.LineTo(598, 76);
		}
// Do not call CDialog::OnPaint() for painting messages
}

HCURSOR CStartD::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CStartD::OnQuitButton() 
{
	CItemData* pData;
	ULONG_PTR lData;

	USHORT us = 0;
	while((lData = m_lbWizList.GetItemData(us)) != LB_ERR)
		{
		pData = (CItemData*)lData;
		delete pData;
		m_lbWizList.DeleteString(us);
		}

	while((lData = m_lbWizList2.GetItemData(us)) != LB_ERR)
		{
		pData = (CItemData*)lData;
		delete pData;
		m_lbWizList2.DeleteString(us);
		}
		 
// set the reg value for startup
	UpdateData(TRUE);

	DWORD dwRet;
	HKEY hKey;
	DWORD cbProv = 0;
	TCHAR* lpProv = NULL;

    dwRet = RegOpenKey(HKEY_CURRENT_USER,
		TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows"), &hKey );

	TCHAR* lpStartup = NULL;
	if ((dwRet = RegQueryValueEx( hKey, TEXT("run"), NULL, NULL, NULL, &cbProv )) == ERROR_SUCCESS)
		{
		lpStartup = (TCHAR*)malloc(cbProv);
		if (lpStartup == NULL)
			{
			AfxMessageBox(IDS_GENERIC_NO_HEAP, MB_ICONEXCLAMATION);
			ExitProcess(1);
			}
		dwRet = RegQueryValueEx( hKey, TEXT("run"), NULL, NULL, (LPBYTE) lpStartup, &cbProv );

// see if we are included
		TCHAR* pPos;
		if ((pPos = _tcsstr(lpStartup, L"wizmgr.exe")) != NULL) // included
			{
			if (!m_bStartup)	// don't want to be
				{
				UINT nPos = (UINT)(pPos - lpStartup);
				CString csCurrentValue = lpStartup;
				CString csNewVal = csCurrentValue.Left(nPos);
				csNewVal += csCurrentValue.Right(csCurrentValue.GetLength() - nPos - _tcslen(L"wizmgr.exe"));
				
				RegSetValueEx(hKey,
					TEXT("run"),
					0,
					REG_SZ,
					(BYTE *)csNewVal.GetBuffer(csNewVal.GetLength()),
					csNewVal.GetLength() * sizeof(TCHAR));
				}
			}
		else 		// not included
			{
			if (m_bStartup)		// want to be
				{
				CString csNewVal = lpStartup;
				csNewVal += L" wizmgr.exe";
				
				RegSetValueEx(hKey,
					TEXT("run"),
					0,
					REG_SZ,
					(BYTE *)csNewVal.GetBuffer(csNewVal.GetLength()),
					csNewVal.GetLength() * sizeof(TCHAR));
				}
			}

		UpdateData(FALSE);
		}

	free(lpStartup);
	RegCloseKey(hKey);

	EndDialog(1);
}

void CStartD::OnActivateApp(BOOL bActive, HTASK hTask) 
{
	CDialog::OnActivateApp(bActive, hTask);
	
	m_bActive = bActive;

	// Remove the selections from the list boxes if
	// the application is being deactivated.
	if (!m_bActive)
	{
		m_lbWizList.SetCurSel(-1);
		m_lbWizList2.SetCurSel(-1);
	}
}

void CStartD::OnMouseMove(UINT nFlags, CPoint point) 
{
	if (m_bActive)
	{
		// Remove the selection from the list boxes if 
		// the mouse has moved outside of them.
		m_lbWizList.SetCurSel(-1);
		m_lbWizList2.SetCurSel(-1);
	}

	CDialog::OnMouseMove(nFlags, point);
}

BOOL CStartD::PreTranslateMessage(MSG* pMsg) 
{
	if (m_hAccelTable != NULL)
	{
		if (!TranslateAccelerator(GetSafeHwnd(), m_hAccelTable, pMsg) )
			return CDialog::PreTranslateMessage(pMsg);
		else
			return TRUE;
	}

	return CDialog::PreTranslateMessage(pMsg);
}

void CStartD::HandleAccelerator1(USHORT nIndex)
{
	// Change the selection in the listbox and 
	// make it think it's been clicked.
	// Remove the selection from the other listbox, too.
	m_lbWizList.SetCurSel(nIndex);
	m_lbWizList2.SetCurSel(-1);
	m_lbWizList.PostMessage(WM_LBUTTONDOWN);
}

void CStartD::HandleAccelerator2(USHORT nIndex)
{
	m_lbWizList2.SetCurSel(nIndex);
	m_lbWizList.SetCurSel(-1);
	m_lbWizList2.PostMessage(WM_LBUTTONDOWN);
}

void CStartD::OnAccelUser() 
{
	HandleAccelerator1(ACCEL_USER);
}

void CStartD::OnAccelGroup() 
{
	HandleAccelerator1(ACCEL_GROUP);
}

void CStartD::OnAccelShare() 
{
	HandleAccelerator1(ACCEL_SHARE);
}

void CStartD::OnAccelPrint() 
{
	HandleAccelerator1(ACCEL_PRINT);
}

void CStartD::OnAccelPrograms() 
{
	HandleAccelerator2(ACCEL_PROGRAMS);
}

void CStartD::OnAccelModem() 
{
	HandleAccelerator2(ACCEL_MODEM);
}

void CStartD::OnAccelNetwork() 
{
	HandleAccelerator2(ACCEL_NETWORK);
}

void CStartD::OnAccelLicense() 
{
	HandleAccelerator2(ACCEL_LICENSE);
}

void CStartD::GetIconIndices(LPCTSTR pszPathName, HICON* hiNormal, HICON* hiSelected)
{
	SHFILEINFO sfi;

	// Get the index for the normal icon.
	SHGetFileInfo(pszPathName, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON);
	*hiNormal = sfi.hIcon;

	// Get the index for the selected icon.
	SHGetFileInfo(pszPathName, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_SELECTED);
	*hiSelected = sfi.hIcon;
}

void CStartD::GetCPLIcon(UINT pszCplItem, HICON* hiNormal, HICON* hiSelected, BOOL bPrinters)
{
	LPSHELLFOLDER pshf, pshfCPLItem;
	LPITEMIDLIST pidlCPLFolder, pidlCPLObj;
	LPMALLOC pMalloc;
	HRESULT hr;

	// Get a pointer to the shell's IMalloc interface.
	hr = SHGetMalloc(&pMalloc);
		
	if (SUCCEEDED(hr) && pMalloc) // JonN 01/26/00: PREFIX bug 445827
		{
		// Get a pointer to the shell's IShellFolder interface.
		hr = SHGetDesktopFolder(&pshf);

		if (SUCCEEDED(hr))
			{
			// Get a PIDL for the specified folder.
			if (!bPrinters)
				hr = SHGetSpecialFolderLocation(GetSafeHwnd(), CSIDL_CONTROLS, &pidlCPLFolder);
			else 
				hr = SHGetSpecialFolderLocation(GetSafeHwnd(), CSIDL_PRINTERS, &pidlCPLFolder);

			if (SUCCEEDED(hr))
				{
				hr = pshf->BindToObject(pidlCPLFolder, NULL, IID_IShellFolder, (LPVOID*)&pshfCPLItem);
				
				if (SUCCEEDED(hr))
					GetCPLObject(pszCplItem, pshfCPLItem, &pidlCPLObj, hiNormal, hiSelected, pidlCPLFolder);

				}
			pMalloc->Free(pidlCPLFolder);
			}
		pMalloc->Release();
		}
}		

HRESULT CStartD::GetCPLObject(UINT pszCplItem, LPSHELLFOLDER pshf, LPITEMIDLIST* ppidl, HICON* hiNormal, HICON* hiSelected, LPITEMIDLIST pParentPIDL)
{
	HRESULT hr;
	LPENUMIDLIST pEnum;
	LPMALLOC pMalloc;

	// Get a pointer to the shell's IMalloc interface.
	hr = SHGetMalloc(&pMalloc);

	if (SUCCEEDED(hr))
	{
		// Get a pointer to the folder's IEnumIDList interface.
		hr = pshf->EnumObjects(GetSafeHwnd(), SHCONTF_NONFOLDERS, &pEnum);

		if (SUCCEEDED(hr))
		{
			STRRET str;
			CString strCPLObj, strEnumObj;

			// Load the display name for the control panel object.
			strCPLObj.LoadString(pszCplItem);

			// Enumerate the objects in the control panel folder.
			while (pEnum->Next(1, ppidl, NULL) == NOERROR)
			{
				// Get the display name for the object.
				hr = pshf->GetDisplayNameOf((LPCITEMIDLIST)*ppidl, SHGDN_INFOLDER, &str);

				if (SUCCEEDED(hr))
				{
					// Copy the display name to the strEnumObj string.
					switch (str.uType)
					{
						case STRRET_CSTR:
							strEnumObj = str.cStr;
							break;

						case STRRET_OFFSET:
							char pStr[255];
							strcpy(pStr, (LPCSTR)(((UINT_PTR)*ppidl) + str.uOffset));
							TCHAR wStr[255];
							mbstowcs(wStr, pStr, 255);
							strEnumObj = wStr;
							break;

						case STRRET_WSTR:
							strEnumObj = str.pOleStr;
							break;

						case 0x04:
							strEnumObj = (LPCTSTR)(((UINT_PTR)*ppidl) + str.uOffset);
							break;

						case 0x05:
							{
							TCHAR pStr[255];
							memcpy(pStr, str.cStr, 255);
							strEnumObj = pStr;
							break;
							}
					
						default:
							strEnumObj.Empty();
					}

					// If we found the correct object, exit the loop.
					if (strCPLObj == strEnumObj)
						{
						LPITEMIDLIST pBigPIDL = ConcatPIDLs(pParentPIDL, *ppidl);
						SHFILEINFO sfi;
						// Get the index for the normal icon.
						SHGetFileInfo((LPCTSTR)pBigPIDL, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_PIDL);
						*hiNormal = sfi.hIcon;

						// Get the index for the selected icon.
						SHGetFileInfo((LPCTSTR)pBigPIDL, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON | SHGFI_SELECTED | SHGFI_PIDL);
						*hiSelected = sfi.hIcon;

						}
						
					
					// Free the PIDL returned by IEnumIDList::Next().
					pMalloc->Free(*ppidl);

					if (FAILED(hr))
					{
						TRACE(_T("IMalloc::Free failed.\n"));
						break;
					}
				}
				else
				{
					TRACE(_T("IShellFolder::GetDisplayNameOf failed.\n"));
				}
			}

			// Release the IEnumIDList pointer.
			pEnum->Release();
		}
		else
		{
			TRACE(_T("IShellFolder::EnumObjects failed.\n"));
		}

		// Release the IMalloc pointer.
		pMalloc->Release();
	}

	return hr;
}

/****************************************************************************
*
*    FUNCTION: Create(UINT cbSize)
*
*    PURPOSE:  Allocates a PIDL 
*
****************************************************************************/
LPITEMIDLIST CreatePIDL(UINT cbSize)
{
    LPMALLOC lpMalloc;
    HRESULT  hr;
    LPITEMIDLIST pidl=NULL;

    hr=SHGetMalloc(&lpMalloc);

    if (FAILED(hr))
       return 0;

    pidl=(LPITEMIDLIST)lpMalloc->Alloc(cbSize);

    if (pidl)
        memset(pidl, 0, cbSize);      // zero-init for external task   alloc

    if (lpMalloc) lpMalloc->Release();

    return pidl;
}

/****************************************************************************
*
*    FUNCTION: ConcatPidls(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
*
*    PURPOSE:  Concatenates two PIDLs 
*
****************************************************************************/
LPITEMIDLIST ConcatPIDLs(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST pidlNew;
    UINT cb1;
    UINT cb2;

    if (pidl1)  //May be NULL
       cb1 = GetSize(pidl1) - sizeof(pidl1->mkid.cb);
    else
       cb1 = 0;

    cb2 = GetSize(pidl2);

    pidlNew = CreatePIDL(cb1 + cb2);
    if (pidlNew)
    {
        if (pidl1)
           memcpy(pidlNew, pidl1, cb1);
        memcpy(((LPSTR)pidlNew) + cb1, pidl2, cb2);
    }
    return pidlNew;
}
	 
/****************************************************************************
*
*    FUNCTION: Next(LPCITEMIDLIST pidl)
*
*    PURPOSE:  Gets the next PIDL in the list 
*
****************************************************************************/
LPITEMIDLIST Next(LPCITEMIDLIST pidl)
{
   LPSTR lpMem=(LPSTR)pidl;

   lpMem+=pidl->mkid.cb;

   return (LPITEMIDLIST)lpMem;
}

/****************************************************************************
*
*    FUNCTION: GetSize(LPCITEMIDLIST pidl)
*
*    PURPOSE:  Gets the size of the PIDL 
*
****************************************************************************/
UINT GetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = Next(pidl);
        }
    }

    return cbTotal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\cwmiextcf.cpp ===
//***************************************************************************
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  File:  cwmiextcf.cpp
//
//  Description :
//              ADs "Wbem Provider" class factory
//
//  Part of :   Wbem ADs Requester oledsreq.dll
//
//  History:    
//      corinaf         10/15/95        Created
//
//***************************************************************************

#include "precomp.h"
extern ULONG g_ulObjCount;


CWMIExtensionCF::CWMIExtensionCF()
{
    m_cRef=0L;
    g_ulObjCount++;
}

CWMIExtensionCF::~CWMIExtensionCF()
{
    g_ulObjCount--;
}


//IUnknown methods
STDMETHODIMP CWMIExtensionCF::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CWMIExtensionCF::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CWMIExtensionCF::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWMIExtensionCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    10/20/98   corinaf   
//----------------------------------------------------------------------------
STDMETHODIMP
CWMIExtensionCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
    HRESULT     hr;
    IUnknown *pExtension = NULL;

    //Create the extension and get the IUnknown pointer to it
    hr = CWMIExtension::CreateExtension(pUnkOuter, (void **)&pExtension);

    if FAILED(hr)
        return hr;

    if (pExtension)
    {
        hr = pExtension->QueryInterface(riid, ppv);
        pExtension->Release();
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CWbemProviderCF::LockServer
//
//  Synopsis:
//
//  Arguments:  [fLock]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    10/20/98  corinaf   
//----------------------------------------------------------------------------
STDMETHODIMP CWMIExtensionCF::LockServer(BOOL fLock)
{
    if (fLock)
        m_cRef++;
    else
        m_cRef--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\startd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StartD.h : header file

File History:

	JonY	Jan-96	created

--*/


// StartD.h : header file
//
/////////////////////////////////////////////////////////////////////////////
// CStartD dialog

class CStartD : public CDialog
{
// Construction
public:
	CStartD(CWnd* pParent = NULL);   // standard constructor
	~CStartD();
	inline BOOL IsActive() {return m_bActive;}

// Dialog Data
	//{{AFX_DATA(CStartD)
	enum { IDD = IDD_MUSTARD_DIALOG };
	CWizList	m_lbWizList2;
	CWizList	m_lbWizList;
	BOOL	m_bStartup;
	//}}AFX_DATA

//	CStatPic m_statPic;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStartD)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
	BOOL  m_bActive;
	HACCEL m_hAccelTable;

	enum
	{
		ACCEL_USER = 0,
		ACCEL_GROUP,
		ACCEL_SHARE,
		ACCEL_PRINT,
		ACCEL_PROGRAMS = 0,
		ACCEL_MODEM,
		ACCEL_NETWORK,
		ACCEL_LICENSE
	};

	void HandleAccelerator1(USHORT nIndex);
	void HandleAccelerator2(USHORT nIndex);

	// Generated message map functions
	//{{AFX_MSG(CStartD)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg void OnQuitButton();
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG
	afx_msg void OnAccelGroup();
	afx_msg void OnAccelModem();
	afx_msg void OnAccelNetwork();
	afx_msg void OnAccelPrint();
	afx_msg void OnAccelShare();
	afx_msg void OnAccelUser();
	afx_msg void OnAccelPrograms();
	afx_msg void OnAccelLicense();

	DECLARE_MESSAGE_MAP()

private:
	CFont* m_pFont1;
	CFont* m_pFont2;
	void GetIconIndices(LPCTSTR pszPathName, HICON* hiNormal, HICON* hiSelected);
	void GetCPLIcon(UINT pszCplItem, HICON* hiNormal, HICON* hiSelected, BOOL bPrinters = FALSE);
	HRESULT GetCPLObject(UINT pszCplItem, LPSHELLFOLDER pshf, LPITEMIDLIST* ppidl, HICON* hiNormal, HICON* hiSelected, LPITEMIDLIST pParentPIDL);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\cwmiextcf.h ===
//***************************************************************************
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  File:       cwmiextcf.h
//
//	Description :
//				Defines the class factory class for the WMI 3rd party extension to ADS
//
//	Part of :	WMI ADs 3rd party extension
//
//  History:	
//		corinaf			10/20/98		Created
//
//***************************************************************************


#ifndef _CWMIEXTCF_H_
#define _CWMIEXTCF_H_


//***************************************************************************
//
//  Class :	CWMIExtensionCF
//
//  Description :
//			class factory for CWbemProvider objects
//
//  Public Methods :
//			IUnknown Methods
//			IClassFactory Methods
//			Constructor, Destructor
//			
//	Public Data Members :
//
//***************************************************************************

class CWMIExtensionCF : public IClassFactory
{
protected:
	DWORD			m_cRef;
public:
	CWMIExtensionCF();
	~CWMIExtensionCF();

	DECLARE_IUnknown_METHODS

	//IClassFactory members
	STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, LPVOID * ppv);
	STDMETHODIMP LockServer(BOOL fLock);
};

#endif //_CWMIEXTCF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wizards\wizmgr\wizlist.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	WizList.cpp : implementation file

File History:

	JonY	Jan-96	created

--*/

#include "stdafx.h"
#include "Mustard.h"
#include "WizList.h"
#include "Listdata.h"
#include "startd.h"
#include <winnetwk.h>
#include <shlobj.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const USHORT	BITMAP_WIDTH = 32;
const USHORT	BITMAP_HEIGHT = 32;
const USHORT	MAX_PRINTER_NAME = 256 + 2;
const USHORT	CELL_HEIGHT = 71;
const USHORT	CELL_WIDTH = 300;

typedef BOOL (*BPRINTERSETUP)(HWND, UINT, UINT, LPTSTR, UINT*, LPCTSTR);


/////////////////////////////////////////////////////////////////////////////
// CWizList

CWizList::CWizList()
{
        CString fontname;
	fontname.LoadString(IDS_FONT_NAME);
        CString fontheight;
        fontheight.LoadString(IDS_FONT_SIZE);

// regular font
	m_pFont = new CFont;
	LOGFONT lf;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = (LONG)_tcstoul(fontheight, NULL, 10);
	_tcscpy(lf.lfFaceName, fontname);
	lf.lfWeight = 100;
	m_pFont->CreateFontIndirect(&lf);    // Create the font.

// bold font
	m_pFontBold = new CFont;

	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = (LONG)_tcstoul(fontheight, NULL, 10);
	_tcscpy(lf.lfFaceName, fontname);
	lf.lfWeight = 700;
	m_pFontBold->CreateFontIndirect(&lf);    // Create the font.

	m_hPrinterLib = NULL;

}

CWizList::~CWizList()
{
	if (m_pFont != NULL) delete m_pFont;
	if (m_pFontBold != NULL) delete m_pFontBold;
	if (m_hPrinterLib != NULL) FreeLibrary(m_hPrinterLib);

}


BEGIN_MESSAGE_MAP(CWizList, CListBox)
	//{{AFX_MSG_MAP(CWizList)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_CONTROL_REFLECT(LBN_SETFOCUS, OnSetfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizList message handlers

void CWizList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	COLORREF crefOldText;

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	pDC->SetBkMode(OPAQUE);

// save the current font for later
	CFont* pOldFont = (CFont*)pDC->SelectObject(m_pFont);

	CItemData* pData = (CItemData*)GetItemData(lpDrawItemStruct->itemID);
	LPCTSTR pName2 = (const TCHAR*)pData->csDesc;
	LPCTSTR pName = (const TCHAR*)pData->csName;

	HICON hIcon = pData->hIcon;
	HICON hSelIcon = pData->hSelIcon;

	int nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top) / 2;
	switch (lpDrawItemStruct->itemAction)
		{
        case ODA_SELECT:
        case ODA_DRAWENTIRE:

// paint the left side - then draw text
 			CRect crRight(50, lpDrawItemStruct->rcItem.top,
				lpDrawItemStruct->rcItem.right,
				lpDrawItemStruct->rcItem.bottom);

			CBrush* pBrush = new CBrush;
			pBrush->CreateSolidBrush(GetSysColor(COLOR_WINDOW));

			pDC->FillRect(crRight, pBrush);

// paint the right - then draw text
            pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));

			crRight = CRect(lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top,
				50,
				lpDrawItemStruct->rcItem.bottom);
			pDC->FillRect(crRight, pBrush);

			crRight = CRect(lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 3,
				140,
				lpDrawItemStruct->rcItem.bottom);

// Is the item selected?
            if (lpDrawItemStruct->itemState & ODS_SELECTED)
				{
// Display bitmap
				nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top - BITMAP_HEIGHT) / 2;
				pDC->DrawIcon(lpDrawItemStruct->rcItem.left + 9, nTop - 9, hSelIcon);

// paint the right - then draw text
	            crefOldText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
				pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
				}
            else
				{
// Display bitmap
				nTop = (lpDrawItemStruct->rcItem.bottom + lpDrawItemStruct->rcItem.top - BITMAP_HEIGHT) / 2;
				pDC->DrawIcon(lpDrawItemStruct->rcItem.left + 9, nTop - 9, hIcon);

	            crefOldText = pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
				pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
				}

// draw the top (bold) text
			pDC->SelectObject(m_pFontBold);
			CRect crTop = CRect(60, lpDrawItemStruct->rcItem.top + 8,
				lpDrawItemStruct->rcItem.right - 10,	lpDrawItemStruct->rcItem.bottom);

			pDC->DrawText(pName, _tcslen(pName),
				crTop,
				DT_WORDBREAK);

// draw the lower text
			pDC->SelectObject(m_pFont);

			CRect crBottom = CRect(60, lpDrawItemStruct->rcItem.top + 28,
				lpDrawItemStruct->rcItem.right - 10, lpDrawItemStruct->rcItem.bottom);

			pDC->DrawText(pName2, _tcslen(pName2),
				crBottom,
				DT_WORDBREAK);
						
			pDC->SelectObject(pOldFont);
					
            pDC->SetTextColor(crefOldText );

			delete pBrush;
            break;
		}
// Restore the original font
	pDC->SelectObject(pOldFont);

}

void CWizList::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	lpMeasureItemStruct->itemHeight = CELL_HEIGHT;	
	lpMeasureItemStruct->itemWidth = CELL_WIDTH;
}

void CWizList::OnMouseMove(UINT nFlags, CPoint point)
{
	if (((CStartD*)GetParent())->IsActive())
	{
		USHORT y = (USHORT)(point.y / CELL_HEIGHT);
		USHORT usCurSel = (USHORT)GetCurSel();

		if (usCurSel != y) SetCurSel(y);

	// tell the other guy not to show any selection
		m_pOtherGuy->SetCurSel(-1);
	}

	CListBox::OnMouseMove(nFlags, point);
}

void CWizList::OnLButtonDown(UINT nFlags, CPoint point)
{
	USHORT usCurSel = (USHORT)GetCurSel();

	// Exit if there's no selection.
	if (usCurSel == (USHORT)-1)
		return;

	CItemData* pData = (CItemData*)GetItemData(usCurSel);

// is this the printer wiz?
	if (pData->csAppStart1 == "")
		{
		try
			{
			LaunchPrinterWizard();
			}
		catch (...)
			{
			TRACE(_T("An exception occurred while attempting to start the Add Printer Wizard.\n"));
			}
		}
	else
		{
// otherwise
		CString csCmdLine = pData->csAppStart1 + " ";
		csCmdLine += pData->csAppStart2;
		TCHAR* pCmdLine = csCmdLine.GetBuffer(csCmdLine.GetLength());

		STARTUPINFO sInfo;
		ZeroMemory(&sInfo, sizeof(sInfo));
		sInfo.cb = sizeof(sInfo);

		PROCESS_INFORMATION pInfo;

		BOOL bProc = CreateProcess(NULL,
			pCmdLine,
			NULL, NULL,
			TRUE,
			NORMAL_PRIORITY_CLASS,
			NULL, NULL,
			&sInfo,
			&pInfo);

		if (!bProc) AfxMessageBox(IDS_NO_START);
		csCmdLine.ReleaseBuffer();

		}

//	CListBox::OnLButtonDown(nFlags, point);
}

void CWizList::PumpMessages()
{
	MSG msg;
// check outstanding messages
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
		if (!IsDialogMessage(&msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}
}

BOOL CWizList::LaunchPrinterWizard()
{
	CWaitCursor wc;
	BOOL bReturn = TRUE;
	HRESULT hr;
	LPSHELLFOLDER pshf, pshfPrinters;
	LPITEMIDLIST pidlPrintFolder, pidlPrintObj;
	LPMALLOC pMalloc;

	// Get a pointer to the shell's IMalloc interface.
	hr = SHGetMalloc(&pMalloc);

	if (SUCCEEDED(hr))
	{
		// Get a pointer to the shell's IShellFolder interface.
		hr = SHGetDesktopFolder(&pshf);

		if (SUCCEEDED(hr))
		{
			// Get a PIDL for the Printers folder.
			hr = SHGetSpecialFolderLocation(GetSafeHwnd(), CSIDL_PRINTERS, &pidlPrintFolder);

			if (SUCCEEDED(hr))
			{
				// Get a pointer to the IShellFolder interface for the Printer folder.
				hr = pshf->BindToObject(pidlPrintFolder, NULL, IID_IShellFolder, (LPVOID*)&pshfPrinters);

				if (SUCCEEDED(hr))
				{
					// Get a PIDL for the Add Printer object in the Printers folder.
					hr = GetAddPrinterObject(pshfPrinters, &pidlPrintObj);

					if (SUCCEEDED(hr))
					{
						LPCONTEXTMENU pcm;

						// Get a pointer to the Printer folder's IContextMenu interface.
						hr = pshfPrinters->GetUIObjectOf(GetSafeHwnd(), 1, (LPCITEMIDLIST*)&pidlPrintObj, IID_IContextMenu, NULL, (LPVOID*)&pcm);

						if (SUCCEEDED(hr))
						{
							// Create a popup menu to hold the items in the context menu.
							HMENU hMenu = CreatePopupMenu();

							if (hMenu != NULL)
							{
								// Fill the menu.
								hr = pcm->QueryContextMenu(hMenu, 0, 1, 0x7FFF, CMF_EXPLORE);

								if (SUCCEEDED(hr))
								{
									CString strCmd(CMDSTR_NEWFOLDER);
									CHAR szCmd[MAX_PATH + 1];
									int i, nCmd, nItems = ::GetMenuItemCount(hMenu);

									for (i = 0; i < nItems; i++)
									{
										// Search through the menu to find the language-independent
										// identifier for the Add Printer object's Open command.
										nCmd = GetMenuItemID(hMenu, i);
										hr = pcm->GetCommandString(i, GCS_VERB, NULL, szCmd, MAX_PATH);

										TCHAR wStr[255];
										memcpy(wStr, szCmd, 255);
										if (SUCCEEDED(hr) && strCmd == wStr)
										{
											
											CMINVOKECOMMANDINFO cmi;

											cmi.cbSize = sizeof(CMINVOKECOMMANDINFO);
											cmi.fMask = 0;
											cmi.hwnd = GetSafeHwnd();
											cmi.lpVerb = (LPSTR)MAKEINTRESOURCE(nCmd - 1);
											cmi.lpParameters = NULL;
											cmi.lpDirectory = NULL;
											cmi.nShow = SW_SHOW;
											cmi.dwHotKey = 0;
											cmi.hIcon = NULL;

											// Invoke the Open command.
											hr = pcm->InvokeCommand(&cmi);

											// Exit the loop.
											break;

											if (FAILED(hr))
											{
												TRACE(_T("IContextMenu::InvokeCommand failed.\n"));
												bReturn = FALSE;
											}
										}
										else
										{
											TRACE(_T("IContextMenu::GetCommandString failed.\n"));
											bReturn = FALSE;
										}
									}

									pcm->Release();
								}
								else
								{
									TRACE(_T("IShellFolder::GetUIObjectOf failed.\n"));
									bReturn = FALSE;
								}

								// Destroy the temporary menu.
								if (!DestroyMenu(hMenu))
									TRACE(_T("DestroyMenu failed.\n"));
							}
							else
							{
								TRACE(_T("CreatePopupMenu failed.\n"));
								bReturn = FALSE;
							}
						}

						// Release the IShellFolder interface for the Printers folder.
						pshfPrinters->Release();
					}

					// Free the PIDL for the Add Printer object.
					pMalloc->Free(pidlPrintObj);
				}
				else
				{
					TRACE(_T("IShellFolder::BindToObject failed.\n"));
					bReturn = FALSE;
				}

				// Free the PIDL for the Printers folder.
				pMalloc->Free(pidlPrintFolder);
			}
			else
			{
				TRACE(_T("SHGetSpecialFolderLocation failed.\n"));
				bReturn = FALSE;
			}

			// Release the pointer to the shell's IShellFolder interface.
			pshf->Release();
		}
		else
		{
			TRACE(_T("SHGetDesktopFolder failed.\n"));
			bReturn = FALSE;
		}

		// Release the pointer to the shell's IMalloc interface.
		pMalloc->Release();
	}
	else
	{
		TRACE(_T("SHGetMalloc failed.\n"));
		bReturn = FALSE;
	}

	return bReturn;
}

HRESULT CWizList::GetAddPrinterObject(LPSHELLFOLDER pshf, LPITEMIDLIST* ppidl)
{
	HRESULT hr;
	LPENUMIDLIST pEnum;
	LPMALLOC pMalloc;

	// Get a pointer to the shell's IMalloc interface.
	hr = SHGetMalloc(&pMalloc);

	if (SUCCEEDED(hr))
	{
		// Get a pointer to the folder's IEnumIDList interface.
		hr = pshf->EnumObjects(GetSafeHwnd(), SHCONTF_NONFOLDERS, &pEnum);

		if (SUCCEEDED(hr))
		{
			STRRET str;
			CString strPrintObj, strEnumObj;

			// Load the display name for the Add Printer object.
			strPrintObj.LoadString(IDS_ADD_PRINTER);

			// Enumerate the objects in the Printers folder.
			while (pEnum->Next(1, ppidl, NULL) == NOERROR)
			{
				// Get the display name for the object.
				hr = pshf->GetDisplayNameOf((LPCITEMIDLIST)*ppidl, SHGDN_INFOLDER, &str);

				if (SUCCEEDED(hr))
				{
					// Copy the display name to the strEnumObj string.
					switch (str.uType)
					{
						case STRRET_CSTR:
							strEnumObj = str.cStr;
							break;

						case STRRET_OFFSET:
							char pStr[255];
							strcpy(pStr, (LPCSTR)(((UINT_PTR)*ppidl) + str.uOffset));
							TCHAR wStr[255];
							mbstowcs(wStr, pStr, 255);
							strEnumObj = wStr;
							break;

						case STRRET_WSTR:
							strEnumObj = str.pOleStr;
							break;

						case 0x04: //STRRET_OFFSETW
							strEnumObj = (LPCTSTR)(((UINT_PTR)*ppidl) + str.uOffset);
							break;

						case 0x05:
							{
							TCHAR pStr[255];
							memcpy(pStr, str.cStr, 255);
							strEnumObj = pStr;
							break;
							}

						default:
							strEnumObj.Empty();
					}

					// If we found the correct object, exit the loop.
					if (strPrintObj == strEnumObj)
						break;
					
					// Free the PIDL returned by IEnumIDList::Next().
					pMalloc->Free(*ppidl);

					if (FAILED(hr))
					{
						TRACE(_T("IMalloc::Free failed.\n"));
						break;
					}
				}
				else
				{
					TRACE(_T("IShellFolder::GetDisplayNameOf failed.\n"));
				}
			}

			// Release the IEnumIDList pointer.
			pEnum->Release();
		}
		else
		{
			TRACE(_T("IShellFolder::EnumObjects failed.\n"));
		}

		// Release the IMalloc pointer.
		pMalloc->Release();
	}

	return hr;
}

void CWizList::OnSetfocus()
{
// tell the other guy not to show any selection
	m_pOtherGuy->SetCurSel(-1);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\cwmiextension.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// CWMIExtension.h: Definition of the CWMIExtension class and the CInner inner class
//					The inner class is used for implementation of the controlling
//					IUnknown only, needed for an aggregated object.
//
//////////////////////////////////////////////////////////////////////

#ifndef _CWMIEXTENSION_H_
#define _CWMIEXTENSION_H_

class CInner;

/////////////////////////////////////////////////////////////////////////////
// CWMIExtension

class CWMIExtension : public IWMIExtension, public IADsExtension
{
public:

	DECLARE_IUnknown_METHODS

	DECLARE_IDispatch_METHODS

	DECLARE_IWMIExtension_METHODS

	DECLARE_IADsExtension_METHODS

	CWMIExtension::CWMIExtension();
	CWMIExtension::~CWMIExtension();

    static
    HRESULT
	CWMIExtension::CreateExtension(IUnknown *pUnkOuter, void **ppv);

protected :
	ULONG m_cRef;

	IUnknown *m_pUnkOuter;
	IDispatch *m_pDispOuter;
	ITypeInfo *m_pTypeInfo;
	CInner *m_pInner;

	ISWbemLocator *m_pSWMILocator;
	BSTR m_bstrADsName;
	ISWbemServices *m_pSWMIServices;
	ISWbemObject *m_pSWMIObject;

};


/////////////////////////////////////////////////////////////////////////////
// CInner

class CInner : public IUnknown
{
public :
	DECLARE_IUnknown_METHODS

	CInner::CInner(CWMIExtension *pOwner);
	CInner::~CInner();

protected :
	ULONG m_cRef;
	CWMIExtension *m_pOwner;
};


#endif // _CWMIEXTENSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\cwmiextension.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// CWMIExtension.cpp : Implementation of the CWMIExtension class

#include "precomp.h"
extern ULONG g_ulObjCount;
//#include "wmiextension_i.c"

/////////////////////////////////////////////////////////////////////////////
//

/* Constructor */
CWMIExtension::CWMIExtension()
{
    HRESULT hr;
    ITypeLib *pITypeLib;

    m_cRef = 0;
    m_pUnkOuter = NULL;
    m_pDispOuter = NULL;
    m_pInner = NULL;
    m_pSWMILocator = NULL;
    m_bstrADsName = NULL;
    m_pSWMIServices = NULL;
    m_pSWMIObject = NULL;
    m_pTypeInfo = NULL;

    //Create inner object for controlling IUnknown implementation
    m_pInner = new CInner(this);

    if (m_pInner == NULL)
        return;


    hr = LoadRegTypeLib(LIBID_WMIEXTENSIONLib, 1,0,
                        PRIMARYLANGID(GetSystemDefaultLCID()), &pITypeLib);
    if FAILED(hr)
        return;

    hr = pITypeLib->GetTypeInfoOfGuid(IID_IWMIExtension, &m_pTypeInfo);
    pITypeLib->Release();

    g_ulObjCount++; //global count for objects living in this DLL

};


CWMIExtension::~CWMIExtension()
{
    if (m_pUnkOuter)
        m_pUnkOuter = NULL;

    if (m_pDispOuter)
        m_pDispOuter = NULL;

    if (m_pInner)
    {
        delete m_pInner;
        m_pInner = NULL;
    };

    if (m_bstrADsName)
        SysFreeString(m_bstrADsName);

    if (m_pSWMIObject)
    {
        m_pSWMIObject->Release();
        m_pSWMIObject = NULL;
    };

    if (m_pSWMIServices)
    {
        m_pSWMIServices->Release();
        m_pSWMIServices = NULL;
    };

    if (m_pSWMILocator)
    {
        m_pSWMILocator->Release();
        m_pSWMILocator = NULL;
    };

    if (m_pTypeInfo)
    {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    };

    g_ulObjCount--; //global count for objects living in this DLL
};


HRESULT 
CWMIExtension::CreateExtension(IUnknown *pUnkOuter, void **ppv)
{
    CWMIExtension FAR* pObj = NULL;
    HRESULT hr;
    IADs *pADs = NULL;
    BSTR bstrTempADSName = NULL;

    pObj = new CWMIExtension();
    if (pObj == NULL)
        return E_OUTOFMEMORY;

    //No addref needed for outer unknown
    pObj->m_pUnkOuter = pUnkOuter;

/*
//Due to the fact that ADSI instantiate us for every object, regardless of whether we're actually being used or not,
//I am moving the code to obtain a locator pointer to the actual functions that need to use it...
    //Obtain a WMI Locator and store in member variable
    hr = CoCreateInstance(CLSID_SWbemLocator, NULL, CLSCTX_INPROC_SERVER, 
                              IID_ISWbemLocator, (void **)&pObj->m_pSWMILocator);
    if FAILED(hr)
    {
        delete pObj;
        return hr;
    }
*/

/*
//Due to a bug in the locator security object, we cannot set the security settings here,
//but rather need to move this to the services pointer.

    //Setup the impersonation and authentication levels for this locator
    ISWbemSecurity *pSecurity = NULL;
    hr = pObj->m_pSWMILocator->get_Security_(&pSecurity);
    if FAILED(hr)
    {
        delete pObj;
        return hr;
    }

    hr = pSecurity->put_ImpersonationLevel(wbemImpersonationLevelImpersonate);
    hr = pSecurity->put_AuthenticationLevel(wbemAuthenticationLevelConnect);
    hr = pSecurity->Release();
    if FAILED(hr)
    {
        delete pObj;
        return hr;
    }
*/
    
    //Obtain the name of this object from ADSI and store in member :

/* Moved to get_WMIObjectPath since here it doesn't work...
    //Get a pointer to the IADs interface of the outer object
    hr = pObj->m_pUnkOuter->QueryInterface(IID_IADs, (void **) &pADs );
    if FAILED(hr)
        return hr;

    //Get the name of the outer object
//  hr = pADs->get_Name(&bstrTempADSName);
    VARIANT var;
    VariantInit(&var);
    hr = pADs->Get(L"cn", &var);
    pObj->m_bstrADsName = SysAllocString(var.bstrVal);
    VariantClear(&var);
    pADs->Release();
*/

    //Since ADSI is adding a "CN=" prefix to the actual machine name, we need to remove it
//  pObj->m_bstrADsName = SysAllocString(wcschr(bstrTempADSName, L'=')+1);
//  pObj->m_bstrADsName = SysAllocString(bstrTempADSName);
//  SysFreeString(bstrTempADSName);
    
//  if FAILED(hr)
//      return hr;

    //Return the controlling unknown implementation pointer, and addref as required
    hr = pObj->m_pInner->QueryInterface(IID_IUnknown, ppv);

    return hr;
};




/* IUnknown Methods */
STDMETHODIMP CWMIExtension::QueryInterface(REFIID riid, LPVOID FAR *ppv) 
{ 
    return m_pUnkOuter->QueryInterface(riid, ppv); 
};
 
STDMETHODIMP_(ULONG)
CWMIExtension::AddRef(void) 
{ 
    ++m_cRef; 
    return m_pUnkOuter->AddRef(); 
};
 
STDMETHODIMP_(ULONG)
CWMIExtension::Release(void) 
{ 
    --m_cRef; 
    return m_pUnkOuter->Release(); 
} 


/* IDispatch methods */
//IDispatch implementation delegates to the aggregator in this case
STDMETHODIMP CWMIExtension::GetTypeInfoCount(unsigned int FAR* pctinfo)
{                                                                                                           
        IDispatch *pDisp;
        HRESULT hr;
        hr = m_pUnkOuter->QueryInterface(IID_IDispatch, (void **) &pDisp);
        if FAILED(hr)
            return hr;
        hr = pDisp->GetTypeInfoCount(pctinfo);
        pDisp->Release();
        return hr;
}                                                                     
                                                                      
STDMETHODIMP CWMIExtension::GetTypeInfo(unsigned int itinfo, LCID lcid, 
                                        ITypeInfo FAR* FAR* pptinfo)                                  
{                                                                     
        IDispatch *pDisp;
        HRESULT hr;
        hr = m_pUnkOuter->QueryInterface(IID_IDispatch, (void **) &pDisp);
        if FAILED(hr)
            return hr;
        hr = pDisp->GetTypeInfo(itinfo, lcid, pptinfo);
        pDisp->Release();
        return hr;

}                                                                     

STDMETHODIMP CWMIExtension::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 
                                          unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         
{                                                                     
        IDispatch *pDisp;
        HRESULT hr;
        hr = m_pUnkOuter->QueryInterface(IID_IDispatch, (void **) &pDisp);
        if FAILED(hr)
            return hr;
        hr = pDisp->GetIDsOfNames(iid, rgszNames, cNames, lcid, rgdispid);
        pDisp->Release();
        return hr;
}                                                                     
                                                                      
STDMETHODIMP CWMIExtension::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               
                                   unsigned short wFlags, DISPPARAMS FAR* pdispparams,           
                                   VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           
                                   unsigned int FAR* puArgErr)                                   
{                                                                     
        IDispatch *pDisp;
        HRESULT hr;
        hr = m_pUnkOuter->QueryInterface(IID_IDispatch, (void **) &pDisp);
        if FAILED(hr)
            return hr;
        hr = pDisp->Invoke(dispidMember,                      
                            iid,                               
                            lcid,                              
                            wFlags,                            
                            pdispparams,                       
                            pvarResult,                        
                            pexcepinfo,                        
                            puArgErr                           
                          );
        pDisp->Release();
        return hr;

}


/* IAdsExtension methods */
STDMETHODIMP CWMIExtension::Operate(ULONG dwCode, VARIANT varData1, 
                                    VARIANT varData2, VARIANT varData3)
{
    HRESULT hr = S_OK;

    switch (dwCode) 
    {

        case ADS_EXT_INITCREDENTIALS:
              // For debugging purpose you can prompt a dialog box
              // MessageBox(NULL, "INITCRED", "ADsExt", MB_OK);
              break;

        default:
              hr = E_FAIL;
              break;

    }        

    return hr;
    
}


STDMETHODIMP CWMIExtension::PrivateGetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, 
                                  unsigned int cNames, LCID lcid, DISPID  * rgdispid)
{
    
  if (rgdispid == NULL)
  {
        return E_POINTER;
  }

    return  DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}



STDMETHODIMP CWMIExtension::PrivateInvoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
                                          DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                                          EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
         return DispInvoke( (IWMIExtension*)this, 
            m_pTypeInfo,
            dispidMember, 
            wFlags, 
            pdispparams, 
            pvarResult, 
            pexcepinfo, 
            puArgErr );
}




/* IWMIExtension methods */
STDMETHODIMP CWMIExtension::get_WMIObjectPath(BSTR FAR *strWMIObjectPath)
{
    WCHAR wcSWMIName[1024];
    HRESULT hr;

    //Validate parameter
    if (strWMIObjectPath == NULL)
        return wbemErrInvalidParameter; //scripting enum

// Moved from CreateExtension() since it doesn't work there...
    if (!m_bstrADsName)
    {
        IADs *pADs = NULL;
        BSTR bstrTempADSName = NULL;
        hr = m_pUnkOuter->QueryInterface(IID_IADs, (void **) &pADs );
        if FAILED(hr)
            return hr;

        //Get the name of the outer object
        hr = pADs->get_Name(&bstrTempADSName);
        if FAILED(hr)
        {
            pADs->Release();
            return hr;
        }
    
        //Since ADSI is adding a "CN=" prefix to the actual machine name, we need to remove it
        m_bstrADsName = SysAllocString(wcschr(bstrTempADSName, L'=')+1);
        SysFreeString(bstrTempADSName);
        pADs->Release();
    }
    

    //Construct the path for matching (S)WMI object
    wcscpy(wcSWMIName, L"WINMGMTS:{impersonationLevel=impersonate}!//");
    wcscat(wcSWMIName, m_bstrADsName);
    wcscat(wcSWMIName, L"/root/cimv2:Win32_ComputerSystem.Name=\"");
    wcscat(wcSWMIName, m_bstrADsName);
    wcscat(wcSWMIName, L"\"");

    //Allocate out parameter and copy result to it
    *strWMIObjectPath = SysAllocString(wcSWMIName);

    return NOERROR;

}; //get_WMIObjectPath



STDMETHODIMP CWMIExtension::GetWMIObject(ISWbemObject FAR* FAR* objWMIObject)
{
    HRESULT hr;
    BSTR    bstrObjPath;

    //Validate parameter
    if (objWMIObject == NULL)
        return wbemErrInvalidParameter;

// Moved from CreateExtension() since it doesn't work there...
    //Obtain the name of this object from ADSI and store in member, if not already there
    if (!m_bstrADsName)
    {
        IADs *pADs = NULL;
        BSTR bstrTempADSName = NULL;
        hr = m_pUnkOuter->QueryInterface(IID_IADs, (void **) &pADs );
        if FAILED(hr)
            return hr;

        //Get the name of the outer object
        hr = pADs->get_Name(&bstrTempADSName);
        if FAILED(hr)
        {
            pADs->Release();
            return hr;
        }
    
        //Since ADSI is adding a "CN=" prefix to the actual machine name, we need to remove it
        m_bstrADsName = SysAllocString(wcschr(bstrTempADSName, L'=')+1);
        SysFreeString(bstrTempADSName);
        pADs->Release();
    }
    
    //Obtain a WMI Locator and store in member variable, if not already there
    if (!m_pSWMILocator)
    {
        hr = CoCreateInstance(CLSID_SWbemLocator, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_ISWbemLocator, (void **)&m_pSWMILocator);
        if FAILED(hr)
            return hr;
    }


    //Get the respective SWMI services pointer if we don't have it already, and cache in member
    if (!m_pSWMIServices)
    {
        BSTR bstrNamespace = SysAllocString(L"root\\cimv2");
        hr = m_pSWMILocator->ConnectServer(m_bstrADsName, bstrNamespace, NULL, NULL, 0, NULL, 0, NULL, &m_pSWMIServices);
        SysFreeString(bstrNamespace);

        if FAILED(hr)
            return hr;

        //Setup the impersonation and authentication levels for this services pointer
        ISWbemSecurity *pSecurity = NULL;
        hr = m_pSWMIServices->get_Security_(&pSecurity);
        if FAILED(hr)
            return hr;

        hr = pSecurity->put_ImpersonationLevel(wbemImpersonationLevelImpersonate);
        hr = pSecurity->put_AuthenticationLevel(wbemAuthenticationLevelConnect);
        hr = pSecurity->Release();
        if FAILED(hr)
            return hr;

    };


    //Get the SWMI object using this services pointer, if we don't have it already, and cache in member
    if (!m_pSWMIObject)
    {
        WCHAR wcObjPath[256];

        //Construct the path of the object
        wcscpy(wcObjPath, L"Win32_ComputerSystem.Name=\"");
        wcscat(wcObjPath, m_bstrADsName);
        wcscat(wcObjPath, L"\"");

        bstrObjPath = SysAllocString(wcObjPath);
        hr = m_pSWMIServices->Get(bstrObjPath, 0, NULL, &m_pSWMIObject);
        SysFreeString(bstrObjPath);

        if FAILED(hr)
            return hr;
    };

    //AddRef the object pointer before we hand it out...
    m_pSWMIObject->AddRef();
    *objWMIObject = m_pSWMIObject;
        
    return NOERROR;

}; //GetWMIObject


STDMETHODIMP CWMIExtension::GetWMIServices(ISWbemServices FAR* FAR* objWMIServices)
{
    HRESULT hr;

    //Validate parameter
    if (objWMIServices == NULL)
        return wbemErrInvalidParameter;

// Moved from CreateExtension() since it doesn't work there...
    //Obtain the name of this object from ADSI and store in member, if not already there
    if (!m_bstrADsName)
    {
        IADs *pADs = NULL;
        BSTR bstrTempADSName = NULL;
        hr = m_pUnkOuter->QueryInterface(IID_IADs, (void **) &pADs );
        if FAILED(hr)
            return hr;

        //Get the name of the outer object
        hr = pADs->get_Name(&bstrTempADSName);
        if FAILED(hr)
        {
            pADs->Release();
            return hr;
        }
    
        //Since ADSI is adding a "CN=" prefix to the actual machine name, we need to remove it
        m_bstrADsName = SysAllocString(wcschr(bstrTempADSName, L'=')+1);
        SysFreeString(bstrTempADSName);
        pADs->Release();
    }
    
    //Obtain a WMI Locator and store in member variable, if not already there
    if (!m_pSWMILocator)
    {
        hr = CoCreateInstance(CLSID_SWbemLocator, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_ISWbemLocator, (void **)&m_pSWMILocator);
        if FAILED(hr)
            return hr;
    }

    //Get the respective SWMI services pointer if we don't have it already, and cache in member
    if (!m_pSWMIServices)
    {
        BSTR bstrNamespace = SysAllocString(L"root\\cimv2");
        hr = m_pSWMILocator->ConnectServer(m_bstrADsName, bstrNamespace, NULL, NULL, 0, NULL, 0, NULL, &m_pSWMIServices);
        SysFreeString(bstrNamespace);

        if FAILED(hr)
            return hr;

        //Setup the impersonation and authentication levels for this services pointer
        ISWbemSecurity *pSecurity = NULL;
        hr = m_pSWMIServices->get_Security_(&pSecurity);
        if FAILED(hr)
            return hr;

        hr = pSecurity->put_ImpersonationLevel(wbemImpersonationLevelImpersonate);
        hr = pSecurity->put_AuthenticationLevel(wbemAuthenticationLevelConnect);
        hr = pSecurity->Release();
        if FAILED(hr)
            return hr;

    };


    //AddRef the services pointer before we hand it out
    m_pSWMIServices->AddRef();
    *objWMIServices = m_pSWMIServices;

    return NOERROR;

}; //GetWMIServices


/* Implementation of CInner class which implements the controlling IUnknown for the object */
//Constructor
CInner::CInner(CWMIExtension *pOwner)
{
    m_cRef = 0;
    m_pOwner = pOwner;
};

//Destructor
CInner::~CInner()
{
};


STDMETHODIMP CInner::QueryInterface(REFIID riid, LPVOID FAR *ppv) 
{ 
    if (riid == IID_IUnknown)
        *ppv=(IUnknown *)this;
    else if (riid == IID_IDispatch)
        *ppv=(IDispatch *)m_pOwner;
    else if (riid == IID_IWMIExtension)
        *ppv=(IWMIExtension *)m_pOwner;
    else if (riid == IID_IADsExtension)
        *ppv=(IADsExtension *)m_pOwner;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return NOERROR;
};

 
STDMETHODIMP_(ULONG)
CInner::AddRef(void) 
{ 
    return ++m_cRef; 
};
 

STDMETHODIMP_(ULONG)
CInner::Release(void) 
{ 
    if (--m_cRef != 0)
        return m_cRef;

    delete m_pOwner;
    return 0;
};


// eof CWMIExtension.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\precomp.h ===
//***************************************************************************
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  File:       wmiextinc.h
//
//  Description :
//              Master include file for the project - includes all other include
//              files in it.
//
//  Part of :   Wbem ADs 3rd party extension
//
//  History:    
//      corinaf         10/19/98        Created
//
//
//  Note : Some of these headers are order dependent. Don't change order unless
//         you know what you are doing.
//
//***************************************************************************

#include <ole2.h>
#include <windows.h>
#include "activeds.h"
#include "wbemdisp.h" //WMI scripting Interfaces
#include "intf.h"
#include "wbemads.h"
#include "CWMIExtCF.h"
#include "CWMIExtension.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\bcd.cpp ===
/***************************************************************************/
/* BCD.C                                                                   */
/* Copyright (C) 1996 SYWARE Inc., All rights reserved                     */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);


#include "drdbdr.h"
/***************************************************************************/
void INTFUNC BCDMultiplyByTen(LPUSTR      lpszValue)
/* Multiply a value by ten */
{
    SWORD decimal;

    /* Look for the decimal point */
    for (decimal = 0; decimal < s_lstrlen(lpszValue); decimal++) {
        if (lpszValue[decimal] == '.') {

            /* Found it.  Move the next digit to the left */
            lpszValue[decimal] = lpszValue[decimal+1];

            /* Was the decimal point at the end of the value? */
            if (lpszValue[decimal] != '\0') {

                /* No.  Set the next character to the decimal point */
                lpszValue[decimal+1] = '.';

                /* If no digits to the right of decimal point, remove it */
                if (lpszValue[decimal+2] == '\0')
                    lpszValue[decimal+1] = '\0';

            }
            else {
                /* Yes.  Add in another zero */
                lpszValue[decimal] = '0';
            }

            /* If we just moved a zero to the left of the decimal point */
            /* for a number with only a fractional part, remove the */
            /* leading zero */
            if (*lpszValue == '0')
                s_lstrcpy(lpszValue, lpszValue + 1);

            return;
        }
    }

    /* Didn't find a decimal point.  Just add a zero to the end */
    if (s_lstrlen(lpszValue) != 0)
        s_lstrcat(lpszValue, "0");
    return;
}
/***************************************************************************/
void INTFUNC BCDDivideByTen(LPUSTR      lpszValue)
/* Divide a value by ten */
{
    SWORD decimal;

    /* Look for the decimal point */
    for (decimal = 0; decimal < s_lstrlen(lpszValue); decimal++) {
        if (lpszValue[decimal] == '.') {

            /* Found it.  Is this the first character? */
            if (decimal != 0) {

                /* No. Move the previous digit into this spot */
                lpszValue[decimal] = lpszValue[decimal-1];

                /* Put in the new decimal point */
                lpszValue[decimal-1] = '.';

            }
            else {

                /* Yes.  move the number to the right */
                _fmemmove(lpszValue+1, lpszValue, s_lstrlen(lpszValue)+1);

                /* Add in another zero */
                lpszValue[1] = '0';
            }
            return;
        }
    }

    /* Didn't find a decimal point.  Move right most digit over and */
    /* add one in */
    if (decimal > 0) {
        lpszValue[decimal+1] = '\0';
        lpszValue[decimal] = lpszValue[decimal-1];
        lpszValue[decimal-1] = '.';
    }
    return;
}
/***************************************************************************/
SWORD INTFUNC BCDCompareValues(LPUSTR      lpszLeft,
                               LPUSTR      lpszRight)
/* Compares the two BCD values.  The values are assumed to be positive */
/* If 'lpszLeft' is greater than 'lpszRight', a positive value is retuned. */
/* If 'lpszLeft' is less than 'lpszRight', a negative value is retuned. */
/* If 'lpszLeft' is equal to 'lpszRight', 0 is retuned. */
{
    SWORD idxDecimalLeft;
    SWORD idxDecimalRight;
    UCHAR cLeft;
    UCHAR cRight;
    LPUSTR ptrLeft;
    LPUSTR ptrRight;
    int fComp;

    /* Find decimal point (if any) */
    for (idxDecimalLeft = 0;
         idxDecimalLeft < s_lstrlen(lpszLeft);
         idxDecimalLeft++) {
        if (lpszLeft[idxDecimalLeft] == '.')
            break;
    }
    for (idxDecimalRight = 0;
         idxDecimalRight < s_lstrlen(lpszRight);
         idxDecimalRight++) {
        if (lpszRight[idxDecimalRight] == '.')
            break;
    }

    /* If unequal number of integer digits, return answer */
    if (idxDecimalLeft > idxDecimalRight)
        return 1;
    else if (idxDecimalLeft < idxDecimalRight)
        return -1;

    /* Compare integer part of the values and if they are not equal, */
    /* return answer */
    cLeft = lpszLeft[idxDecimalLeft];
    cRight = lpszRight[idxDecimalRight];
    lpszLeft[idxDecimalLeft] = '\0';
    if (lpszRight[idxDecimalRight] != '\0')
            lpszRight[idxDecimalRight] = '\0';
    fComp = s_lstrcmp(lpszLeft, lpszRight);
    lpszLeft[idxDecimalLeft] = cLeft;
    if (lpszRight[idxDecimalRight] != cRight)
            lpszRight[idxDecimalRight] = cRight;
    if (fComp > 0)
        return 1;
    else if (fComp < 0)
        return -1;

    /* The integer parts are equal.  Compare the fractional parts */
    ptrLeft = lpszLeft + idxDecimalLeft;
    if (*ptrLeft == '.')
        ptrLeft++;
    ptrRight = lpszRight + idxDecimalRight;
    if (*ptrRight == '.')
        ptrRight++;
    while (TRUE) {
        if (*ptrLeft == '\0') {
            while (*ptrRight == '0')
                ptrRight++;
            if (*ptrRight == '\0')
                break;
            return -1;
        }
        if (*ptrRight == '\0') {
            while (*ptrLeft == '0')
                ptrLeft++;
            if (*ptrLeft == '\0')
                break;
            return 1;
        }
        if (*ptrLeft > *ptrRight)
            return 1;
        else if (*ptrLeft < *ptrRight)
            return -1;
        ptrLeft++;
        ptrRight++;
    }
    return 0;
}
/***************************************************************************/
void INTFUNC BCDAdd(LPUSTR      lpszResult,
                     LPUSTR      lpszLeft,
                     LPUSTR      lpszRight)
{
    LPUSTR lpszCurrent;
    LPUSTR lpszCurrentLeft;
    LPUSTR lpszCurrentRight;
    SWORD idxDecimalLeft;
    SWORD idxDecimalRight;
    UCHAR digit;
    LPUSTR lpszCarryDigit;

    /* Point at values */
    lpszCurrent = lpszResult;
    lpszCurrentLeft = lpszLeft;
    lpszCurrentRight = lpszRight;

    /* Put leading zero in */
    *lpszCurrent = '0';
    lpszCurrent++;

    /* Find decimal point (if any) */
    for (idxDecimalLeft = 0;
         idxDecimalLeft < s_lstrlen(lpszLeft);
         idxDecimalLeft++) {
        if (lpszLeft[idxDecimalLeft] == '.')
            break;
    }
    for (idxDecimalRight = 0;
         idxDecimalRight < s_lstrlen(lpszRight);
         idxDecimalRight++) {
        if (lpszRight[idxDecimalRight] == '.')
            break;
    }

    /* Put in excess characters */
    while (idxDecimalLeft > idxDecimalRight) {
        *lpszCurrent = *lpszCurrentLeft;
        lpszCurrent++;
        lpszCurrentLeft++;
        idxDecimalLeft--;
    }
    while (idxDecimalRight > idxDecimalLeft) {
        *lpszCurrent = *lpszCurrentRight;
        lpszCurrent++;
        lpszCurrentRight++;
        idxDecimalRight--;
    }

    /* Add integer part */
    while (idxDecimalLeft > 0) {

        /* Get left digit */
        digit = (*lpszCurrentLeft) & 0x0F;
        lpszCurrentLeft++;
        idxDecimalLeft--;

        /* Add right digit to it */
        digit += ((*lpszCurrentRight) & 0x0F);
        lpszCurrentRight++;
        idxDecimalRight--;

        /* Is there a carry? */
        if (digit >= 10) {

            /* Yes.  Propagate it to the higher digits */
            lpszCarryDigit = lpszCurrent - 1;
            while (TRUE) {
                if (*lpszCarryDigit != '9') {
                    *lpszCarryDigit = *lpszCarryDigit + 1;
                    break;
                }
                *lpszCarryDigit = '0';
                lpszCarryDigit--;
            }

            /* Adjust digit */
            digit -= (10);
        }

        /* Save digit */
        *lpszCurrent = '0' + digit;
        lpszCurrent++;
    }

    /* Is there a fractional part? */
    if ((*lpszCurrentLeft != '\0') || (*lpszCurrentRight != '\0')) {

        /* Yes. Put in a decimal point */
        *lpszCurrent = '.';
        lpszCurrent++;

        /* Skip over the decimal points */
        if (*lpszCurrentRight == '.')
            lpszCurrentRight++;
        if (*lpszCurrentLeft == '.')
            lpszCurrentLeft++;

        /* Add the values */
        while ((*lpszCurrentLeft != '\0') || (*lpszCurrentRight != '\0')) {

            /* Get left digit */
            if (*lpszCurrentLeft != '\0') {
                digit = (*lpszCurrentLeft) & 0x0F;
                lpszCurrentLeft++;
            }
            else
                digit = 0;

            /* Add right digit to it */
            if (*lpszCurrentRight != '\0') {
                digit += ((*lpszCurrentRight) & 0x0F);
                lpszCurrentRight++;
            }

            /* Is there a carry? */
            if (digit >= 10) {

                /* Yes.  Propagate it to the higher digits */
                lpszCarryDigit = lpszCurrent - 1;
                while (TRUE) {
                    if (*lpszCarryDigit == '.')
                        lpszCarryDigit--;
                    if (*lpszCarryDigit != '9') {
                        *lpszCarryDigit = *lpszCarryDigit + 1;
                        break;
                    }
                    *lpszCarryDigit = '0';
                    lpszCarryDigit--;
                }

                /* Adjust digit */
                digit -= (10);
            }

            /* Save digit */
            *lpszCurrent = '0' + digit;
            lpszCurrent++;
        }
    }

    /* Put in terminating null */
    *lpszCurrent = '\0';

    /* Did anything carry into the first digit? */
    if (*lpszResult == '0') {

        /* No.  Shift value to the left */
        s_lstrcpy(lpszResult, lpszResult+1);
    }
}
/***************************************************************************/
void INTFUNC BCDSubtract(LPUSTR      lpszResult,
                         LPUSTR      lpszLeft,
                         LPUSTR      lpszRight)
{
    LPUSTR lpszCurrent;
    LPUSTR lpszCurrentLeft;
    LPUSTR lpszCurrentRight;
    SWORD idxDecimalLeft;
    SWORD idxDecimalRight;
    UCHAR digit;
    LPUSTR lpszBorrowDigit;

    /* If the result is negative, subtract the other way */
    if (BCDCompareValues(lpszLeft, lpszRight) < 0) {
        *lpszResult = '-';
        BCDSubtract(lpszResult+1, lpszRight, lpszLeft);
        return;
    }

    /* Point at values */
    lpszCurrent = lpszResult;
    lpszCurrentLeft = lpszLeft;
    lpszCurrentRight = lpszRight;

    /* Find decimal point (if any) */
    for (idxDecimalLeft = 0;
         idxDecimalLeft < s_lstrlen(lpszLeft);
         idxDecimalLeft++) {
        if (lpszLeft[idxDecimalLeft] == '.')
            break;
    }
    for (idxDecimalRight = 0;
         idxDecimalRight < s_lstrlen(lpszRight);
         idxDecimalRight++) {
        if (lpszRight[idxDecimalRight] == '.')
            break;
    }

    /* Put in excess characters */
    while (idxDecimalLeft > idxDecimalRight) {
        *lpszCurrent = *lpszCurrentLeft;
        lpszCurrent++;
        lpszCurrentLeft++;
        idxDecimalLeft--;
    }

    /* Subtract integer part */
    while (idxDecimalLeft > 0) {

        /* Get left digit */
        digit = (*lpszCurrentLeft) & 0x0F;
        lpszCurrentLeft++;
        idxDecimalLeft--;

        /* Add ten to it (to keep it positive) */
        digit += (10);

        /* Subtract right digit from it */
        digit -= ((*lpszCurrentRight) & 0x0F);
        lpszCurrentRight++;
        idxDecimalRight--;

        /* Is there a borrow? */
        if (digit < 10) {

            /* Yes.  Propagate it to the higher digits */
            lpszBorrowDigit = lpszCurrent - 1;
            while (TRUE) {
                if (*lpszBorrowDigit != '0') {
                    *lpszBorrowDigit = *lpszBorrowDigit - 1;
                    break;
                }
                *lpszBorrowDigit = '9';
                lpszBorrowDigit--;
            }
        }
        else {

            /* No.  Adjust digit */
            digit -= (10);
        }

        /* Save digit */
        *lpszCurrent = '0' + digit;
        lpszCurrent++;
    }

    /* Is there a fractional part? */
    if ((*lpszCurrentLeft != '\0') || (*lpszCurrentRight != '\0')) {

        /* Yes. Put in a decimal point */
        *lpszCurrent = '.';
        lpszCurrent++;

        /* Skip over the decimal points */
        if (*lpszCurrentRight == '.')
            lpszCurrentRight++;
        if (*lpszCurrentLeft == '.')
            lpszCurrentLeft++;

        /* Subtract the values */
        while ((*lpszCurrentLeft != '\0') || (*lpszCurrentRight != '\0')) {

            /* Get left digit */
            if (*lpszCurrentLeft != '\0') {
                digit = (*lpszCurrentLeft) & 0x0F;
                lpszCurrentLeft++;
            }
            else
                digit = 0;

            /* Add ten to it (to keep it positive) */
            digit += (10);

            /* Subtract right digit from it */
            if (*lpszCurrentRight != '\0') {
                digit -= ((*lpszCurrentRight) & 0x0F);
                lpszCurrentRight++;
            }

            /* Is there a borrow? */
            if (digit < 10) {

                /* Yes.  Propagate it to the higher digits */
                lpszBorrowDigit = lpszCurrent - 1;
                while (TRUE) {
                    if (*lpszBorrowDigit == '.')
                        lpszBorrowDigit--;
                    if (*lpszBorrowDigit != '0') {
                        *lpszBorrowDigit = *lpszBorrowDigit - 1;
                        break;
                    }
                    *lpszBorrowDigit = '9';
                    lpszBorrowDigit--;
                }
            }
            else {

                /* No.  Adjust digit */
                digit -= (10);
            }

            /* Save digit */
            *lpszCurrent = '0' + digit;
            lpszCurrent++;
        }
    }

    /* Put in terminating null */
    *lpszCurrent = '\0';

    /* Remove leading zeros */
    while (*lpszResult == '0')
        s_lstrcpy(lpszResult, lpszResult+1);
}
/***************************************************************************/
void INTFUNC BCDTimes(LPUSTR      lpszResult,
                       LPUSTR      lpszLeft,
                       LPUSTR      lpszRight,
                       LPUSTR      lpWorkBuffer)
{
    SWORD idxDecimalLeft;
    SWORD idxDecimalRight;
    SWORD cDecimalDigits;
    LPUSTR lpszCurrent;
    UCHAR digit;
    UCHAR idx;

    /* Find decimal point (if any) */
    for (idxDecimalLeft = 0;
         idxDecimalLeft < s_lstrlen(lpszLeft);
         idxDecimalLeft++) {
        if (lpszLeft[idxDecimalLeft] == '.')
            break;
    }
    for (idxDecimalRight = 0;
         idxDecimalRight < s_lstrlen(lpszRight);
         idxDecimalRight++) {
        if (lpszRight[idxDecimalRight] == '.')
            break;
    }

    /* Remove decimal points from the values and figure out how many */
    /* decimal digits in the result */
    if (*(lpszLeft + idxDecimalLeft) == '.') {
        _fmemmove(lpszLeft + idxDecimalLeft, lpszLeft + idxDecimalLeft + 1,
                  s_lstrlen(lpszLeft + idxDecimalLeft));
        cDecimalDigits = s_lstrlen(lpszLeft) - idxDecimalLeft;
    }
    else {
        cDecimalDigits = 0;
        idxDecimalLeft = -1;
    }

    if (*(lpszRight + idxDecimalRight) == '.') {
        _fmemmove(lpszRight + idxDecimalRight, lpszRight + idxDecimalRight + 1,
                  s_lstrlen(lpszRight + idxDecimalRight));
        cDecimalDigits += (s_lstrlen(lpszRight) - idxDecimalRight);
    }
    else
        idxDecimalRight = -1;

    /* Put a zero in the workbuffer */
    s_lstrcpy(lpWorkBuffer, lpszRight);
    for (lpszCurrent = lpWorkBuffer; *lpszCurrent; lpszCurrent++)
        *lpszCurrent = '0';

    /* For each left digit... */
    lpszCurrent = lpszLeft;
    while (*lpszCurrent != '\0') {

        /* Add the right value into the result that many times */
        digit = *lpszCurrent & 0x0F;
        for (idx = 0; idx < digit; idx++) {
            BCDAdd(lpszResult, lpszRight, lpWorkBuffer);
            s_lstrcpy(lpWorkBuffer, lpszResult);
        }

        /* Look at next digit */
        lpszCurrent++;
        if (*lpszCurrent == '\0')
            break;

        /* Multiply the result by ten */
        s_lstrcat(lpWorkBuffer, "0");
    }
    s_lstrcpy(lpszResult, lpWorkBuffer);

    /* Put the decimal point back into the values */
    if (idxDecimalLeft != -1) {
        
        _fmemmove(lpszLeft + idxDecimalLeft + 1, lpszLeft + idxDecimalLeft,
                 s_lstrlen(lpszLeft + idxDecimalLeft) + 1);
        lpszLeft[idxDecimalLeft] = '.';
    }
    if (idxDecimalRight != -1) {
        _fmemmove(lpszRight + idxDecimalRight + 1, lpszRight + idxDecimalRight,
                 s_lstrlen(lpszRight + idxDecimalRight) + 1);
        lpszRight[idxDecimalRight] = '.';
    }
    if (cDecimalDigits != 0) {
        while (s_lstrlen(lpszResult) < cDecimalDigits) {
            _fmemmove(lpszResult + 1, lpszResult, s_lstrlen(lpszResult)+1);
            lpszResult[0] = '0';
        }
        _fmemmove(lpszResult + s_lstrlen(lpszResult) - cDecimalDigits + 1,
                lpszResult + s_lstrlen(lpszResult) - cDecimalDigits,
                s_lstrlen(lpszResult + s_lstrlen(lpszResult) - cDecimalDigits)+1);
        lpszResult[s_lstrlen(lpszResult) - cDecimalDigits - 1] = '.';
    }

    return;
}
/***************************************************************************/
SWORD INTFUNC BCDDivide(LPUSTR      lpszResult,
                        SWORD      scale,
                        LPUSTR      lpszLeft,
                        LPUSTR      lpszRight,
                        LPUSTR      lpWorkBuffer1,
                        LPUSTR      lpWorkBuffer2,
                        LPUSTR      lpWorkBuffer3)
{
    SWORD decimalPosition;
    LPUSTR lpszCurrent;
    SWORD i;

    /* If right side is zero, return an error */
    for (lpszCurrent = lpszRight; *lpszCurrent; lpszCurrent++){
        if ((*lpszCurrent != '0') && (*lpszCurrent != '.'))
            break;
    }
    if (*lpszCurrent == '\0')
        return ERR_ZERODIVIDE;

    /* Copy the dividend */
    if (BCDCompareValues(lpszLeft, (LPUSTR)"") != 0)
        s_lstrcpy(lpWorkBuffer1, lpszLeft);
    else
        s_lstrcpy(lpWorkBuffer1, "");

    /* 'decimalPosition' specifies how places the decimal point has to be */
    /* moved.  Positive values mean move to the right, negative values */
    /* mean move to the left */
    decimalPosition = 0;

    /* While the dividend is greater than the divisor, divide it by ten. */
    while (BCDCompareValues(lpWorkBuffer1, lpszRight) > 0) {
        BCDDivideByTen(lpWorkBuffer1);
        decimalPosition++;
    }

    /* While the dividend is less than the divisor, multiply it by ten. */
    if (s_lstrlen(lpWorkBuffer1) > 0) {
        while (BCDCompareValues(lpWorkBuffer1, lpszRight) < 0) {
            BCDMultiplyByTen(lpWorkBuffer1);
            decimalPosition--;
        }
    }

    /* Point at place to put result */
    lpszCurrent = lpszResult;

    /* If the scale is greater than zero, put in the decimal point */
    if (scale > 0) {
        *lpszCurrent = '.';
        lpszCurrent++;
    }
    decimalPosition++;

    /* For as many digits as are needed... */
    s_lstrcpy(lpWorkBuffer2, lpszRight);
    for (i = 0; i < scale + decimalPosition; i++) {

        /* Intialize the digit to zero */
        *lpszCurrent = '0';

        /* Count how many times divisor can be subtracted from dividend */
        while (BCDCompareValues(lpWorkBuffer1, lpWorkBuffer2) >= 0) {

            s_lstrcpy(lpWorkBuffer3, lpWorkBuffer1);
            BCDSubtract(lpWorkBuffer1, lpWorkBuffer3, lpWorkBuffer2);
            (*lpszCurrent)++;
        }

        /* Calculate the next digit of the result */
        lpszCurrent++;
        BCDDivideByTen(lpWorkBuffer2);
    }
    *lpszCurrent = '\0';

    /* If there is a positive scale, move the decimal point as need be */
    if (scale > 0) {
        while (decimalPosition > 0) {
            BCDMultiplyByTen(lpszResult);
            decimalPosition--;
        }

        while (decimalPosition < 0) {
            BCDDivideByTen(lpszResult);
            decimalPosition++;
        }
    }

    /* Remove leading zeros */
    while (*lpszResult == '0')
        s_lstrcpy(lpszResult, lpszResult+1);

    return ERR_SUCCESS;
}
/***************************************************************************/
void INTFUNC BCDFixNegZero(LPUSTR  szValue,
                           SDWORD cbValueMax)

/* Change "-0.000" to "0.000" if need be */
{
    LPUSTR toPtr;
    SWORD idx;
    BOOL  fZero;

    /* Is this a negative number? */
    if ((cbValueMax > 0) && (*szValue == '-')) {

        /* Yes.  Figure out if it is zero */
        fZero = TRUE;
        toPtr = szValue + 1;
        for (idx = 0; idx < cbValueMax-1; idx++) {
            if (*toPtr == '\0')
                break;
            if ((*toPtr != '.') && (*toPtr != '0')) {
                fZero = FALSE;
                break;
            }
            toPtr++;
        }

        /* If it is zero, remove leading minus sign */
        if (fZero) {
            toPtr = szValue;
            for (idx = 1; idx < cbValueMax-1; idx++) {
                *toPtr = *(toPtr + 1); 
                if (*toPtr == '\0')
                    break;
                toPtr++;
            }
            *toPtr = '\0';
        }
    }
}
/***************************************************************************/
/***************************************************************************/
SWORD INTFUNC BCDNormalize(LPUSTR  szValueFrom,
                             SDWORD cbValueFrom,
                             LPUSTR szValueTo,
                             SDWORD cbValueToMax,
                             SDWORD  precision,
                             SWORD  scale)
{
    LPUSTR toPtr;
    SDWORD toSize;
    SDWORD idxDecimalPoint;
    SWORD idx;
    BOOL  fNegative;
    BOOL  fTruncated;
    SDWORD right;
    SDWORD left;

    /* Point to destination */
    toPtr = szValueTo;
    toSize = cbValueToMax;

    /* Trim off leading spaces */
    while ((cbValueFrom > 0) && (*szValueFrom == ' ')) {
        szValueFrom++;
        cbValueFrom--;
    }

    /* See if value is positive or negative */
    if (*szValueFrom != '-')
        fNegative = FALSE;
    else {
        fNegative = TRUE;
        szValueFrom++;
        cbValueFrom--;
    }

    /* Trim off leading zeros */
    while ((cbValueFrom > 0) && (*szValueFrom == '0')) {
        szValueFrom++;
        cbValueFrom--;
    }

    /* Trim off trailing spaces */
    while ((cbValueFrom > 0) && (szValueFrom[cbValueFrom - 1] == ' '))
        cbValueFrom--;

    /* Is there a decimal point? */
    for (idx = 0; idx < cbValueFrom; idx++) {
        if (szValueFrom[idx] == '.') {

            /* Yes. Trim off trailing zeros */
            while ((cbValueFrom > 0) && (szValueFrom[cbValueFrom - 1] == '0'))
                cbValueFrom--;
            break;
        }
    }

    /* Find location of decimal point (if any) */
    idxDecimalPoint = -1;
    for (idx = 0; idx < cbValueFrom; idx++) {
        if (szValueFrom[idx] == '.') {
            idxDecimalPoint = idx;
            break;
        }
    }

    /* If scale is zero, remove decimal point and digits */
    fTruncated = FALSE;
    if ((idxDecimalPoint != -1) && (scale == 0)) {
        if (idxDecimalPoint < (cbValueFrom - 1))
            fTruncated = TRUE;
        cbValueFrom = idxDecimalPoint;
        idxDecimalPoint = -1;
    }

    /* Figure out how many digits to the right of the decimal point */
    if (idxDecimalPoint == -1)
        right = 0;
    else
        right = cbValueFrom - idxDecimalPoint - 1;

    /* If too many digits to the right of the decimal point, remove them */
    while (right > scale) {
        cbValueFrom--;
        right--;
        fTruncated = TRUE;
    }
    
    /* Figure out how many digits to the left of the decimal point */
    if (idxDecimalPoint == -1)
        left = cbValueFrom;
    else
        left = cbValueFrom - right - 1;
    
    /* If too many digits to the left of the decimal point, error */
    if (left > (precision - scale))
        return ERR_OUTOFRANGE;

    /* Copy the value to the output buffer.  If negative put in the sign */
    if (fNegative) {
        if (toSize > 0) {
            *toPtr = '-';
            toPtr++;
            toSize--;
        }
        else
            return ERR_OUTOFRANGE;
    }
    
    /* Put the digits to the left of the decimal in */
    while (left > 0) {
        if (toSize > 0) {
            *toPtr = *szValueFrom;
            szValueFrom++;
            toPtr++;
            toSize--;
        }
        else
            return ERR_OUTOFRANGE;
        left--;
    }

    /* Decimal part needed? */
    if (scale > 0) {
   
        /* Put in the decimal point */
        if (toSize > 0) {
            *toPtr = '.';
            toPtr++;
            toSize--;
        }
        else
            fTruncated = TRUE;

        /* Put in the decimal digits */
        if (idxDecimalPoint != -1)
            szValueFrom++;
        while (scale > 0) {
            if (toSize > 0) {
                if (right > 0) {
                    *toPtr = *szValueFrom;
                    szValueFrom++;
                    right--;
                }
                else {
                    *toPtr = '0';
                }
                toPtr++;
                toSize--;
            }
            else
                fTruncated = TRUE;
            scale--;
        }
    }

    /* Put in null terminator */
    if (toSize > 0) {
        *toPtr = '\0';
        toPtr++;
        toSize--;
    }
    else
        fTruncated = TRUE;

    BCDFixNegZero(szValueTo, cbValueToMax);

    if (fTruncated)
        return ERR_DATATRUNCATED;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC BCDCompare(LPSQLNODE lpSqlNode, LPSQLNODE lpSqlNodeLeft,
                        UWORD Operator, LPSQLNODE lpSqlNodeRight)

/* Compares two BCD values as follows:                                     */
/*       lpSqlNode->value.Double = lpSqlNodeLeft Operator lpSqlNodeRight   */

{
    SWORD fComp;

    /* Check parameters */
    if ((lpSqlNode->sqlDataType != TYPE_INTEGER) ||
        (lpSqlNodeLeft->sqlDataType != TYPE_NUMERIC) ||
        ((Operator != OP_NEG)&&(lpSqlNodeRight->sqlDataType != TYPE_NUMERIC)))
        return ERR_INTERNAL;

    /* Compare the values */
    if ((lpSqlNodeLeft->value.String[0] != '-') &&
        (lpSqlNodeRight->value.String[0] != '-')) {
        fComp = BCDCompareValues(lpSqlNodeLeft->value.String,
                               lpSqlNodeRight->value.String);
    }
    else if ((lpSqlNodeLeft->value.String[0] != '-') &&
             (lpSqlNodeRight->value.String[0] == '-')) 
        fComp = 1;
    else if ((lpSqlNodeLeft->value.String[0] == '-') &&
             (lpSqlNodeRight->value.String[0] != '-'))
        fComp = -1;
    else {
        fComp = BCDCompareValues(lpSqlNodeRight->value.String+1,
                               lpSqlNodeLeft->value.String+1);
    }

    /* Figure out the answer */
    switch (Operator) {
    case OP_EQ:
        if (fComp == 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_NE:
        if (fComp != 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_LE:
        if (fComp <= 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_LT:
        if (fComp < 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_GE:
        if (fComp >= 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_GT:
        if (fComp > 0)
            lpSqlNode->value.Double = TRUE;
        else
            lpSqlNode->value.Double = FALSE;
        break;
    case OP_LIKE:
    case OP_NOTLIKE:
    default:
        return ERR_INTERNAL;
    }

    return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC BCDAlgebra(LPSQLNODE lpSqlNode, LPSQLNODE lpSqlNodeLeft,
                        UWORD Operator, LPSQLNODE lpSqlNodeRight,
                        LPUSTR lpWorkBuffer1, LPUSTR lpWorkBuffer2,
                        LPUSTR lpWorkBuffer3)

/* Perfoms algebraic operation in two numerical values as follows:         */
/*       lpSqlNode lpSqlNodeLeft Operator lpSqlNodeRight                   */

{
    RETCODE err;

    /* Check parameters */
    if ((Operator != OP_NEG) && (lpSqlNodeRight == NULL))
        return ERR_INTERNAL;
    if ((lpSqlNode->sqlDataType != TYPE_NUMERIC) ||
        (lpSqlNodeLeft->sqlDataType != TYPE_NUMERIC) ||
        ((Operator != OP_NEG)&&(lpSqlNodeRight->sqlDataType != TYPE_NUMERIC)))
        return ERR_INTERNAL;

    /* Do the operation */
    switch (Operator) {

    case OP_NEG:
        if (lpSqlNodeLeft->value.String[0] == '-')
            s_lstrcpy(lpSqlNode->value.String, lpSqlNodeLeft->value.String+1);
        else {
            lpSqlNode->value.String[0] = '-';
            s_lstrcpy(lpSqlNode->value.String+1, lpSqlNodeLeft->value.String);
        }
        break;
    
    case OP_PLUS:
        if ((lpSqlNodeLeft->value.String[0] != '-') &&
            (lpSqlNodeRight->value.String[0] != '-')) {
            BCDAdd(lpSqlNode->value.String,
                   lpSqlNodeLeft->value.String,
                   lpSqlNodeRight->value.String);
        }
        else if ((lpSqlNodeLeft->value.String[0] != '-') &&
                 (lpSqlNodeRight->value.String[0] == '-')) {
            BCDSubtract(lpSqlNode->value.String,
                        lpSqlNodeLeft->value.String,
                        lpSqlNodeRight->value.String+1);
        }
        else if ((lpSqlNodeLeft->value.String[0] == '-') &&
                 (lpSqlNodeRight->value.String[0] != '-')) {
            BCDSubtract(lpSqlNode->value.String,
                        lpSqlNodeRight->value.String,
                        lpSqlNodeLeft->value.String+1);
        }
        else {
            lpSqlNode->value.String[0] = '-';
            BCDAdd(lpSqlNode->value.String+1,
                   lpSqlNodeLeft->value.String+1,
                   lpSqlNodeRight->value.String+1);
        }
        break;

    case OP_MINUS:
        if ((lpSqlNodeLeft->value.String[0] != '-') &&
            (lpSqlNodeRight->value.String[0] != '-')) {
            BCDSubtract(lpSqlNode->value.String,
                        lpSqlNodeLeft->value.String,
                        lpSqlNodeRight->value.String);
        }
        else if ((lpSqlNodeLeft->value.String[0] != '-') &&
                 (lpSqlNodeRight->value.String[0] == '-')) {
            BCDAdd(lpSqlNode->value.String,
                   lpSqlNodeLeft->value.String,
                   lpSqlNodeRight->value.String+1);
        }
        else if ((lpSqlNodeLeft->value.String[0] == '-') &&
                 (lpSqlNodeRight->value.String[0] != '-')) {
            lpSqlNode->value.String[0] = '-';
            BCDAdd(lpSqlNode->value.String+1,
                   lpSqlNodeLeft->value.String+1,
                   lpSqlNodeRight->value.String);
        }
        else {
            BCDSubtract(lpSqlNode->value.String,
                        lpSqlNodeRight->value.String+1,
                        lpSqlNodeLeft->value.String+1);
        }
        break;

    case OP_TIMES:
        if ((lpSqlNodeLeft->value.String[0] != '-') &&
            (lpSqlNodeRight->value.String[0] != '-')) {
            BCDTimes(lpSqlNode->value.String,
                            lpSqlNodeLeft->value.String,
                            lpSqlNodeRight->value.String,
                            lpWorkBuffer1);
        }
        else if ((lpSqlNodeLeft->value.String[0] != '-') &&
                 (lpSqlNodeRight->value.String[0] == '-')) {
            lpSqlNode->value.String[0] = '-';
            BCDTimes(lpSqlNode->value.String+1,
                            lpSqlNodeLeft->value.String,
                            lpSqlNodeRight->value.String+1,
                            lpWorkBuffer1);
        }
        else if ((lpSqlNodeLeft->value.String[0] == '-') &&
                 (lpSqlNodeRight->value.String[0] != '-')) {
            lpSqlNode->value.String[0] = '-';
            BCDTimes(lpSqlNode->value.String+1,
                            lpSqlNodeLeft->value.String+1,
                            lpSqlNodeRight->value.String,
                            lpWorkBuffer1);
        }
        else {
            BCDTimes(lpSqlNode->value.String,
                            lpSqlNodeLeft->value.String+1,
                            lpSqlNodeRight->value.String+1,
                            lpWorkBuffer1);
        }
        break;

    case OP_DIVIDEDBY:
        if ((lpSqlNodeLeft->value.String[0] != '-') &&
            (lpSqlNodeRight->value.String[0] != '-')) {
            err = BCDDivide(lpSqlNode->value.String,
                             lpSqlNode->sqlScale,
                             lpSqlNodeLeft->value.String,
                             lpSqlNodeRight->value.String,
                             lpWorkBuffer1, lpWorkBuffer2, lpWorkBuffer3);
        }
        else if ((lpSqlNodeLeft->value.String[0] != '-') &&
                 (lpSqlNodeRight->value.String[0] == '-')) {
            lpSqlNode->value.String[0] = '-';
            err = BCDDivide(lpSqlNode->value.String+1,
                             lpSqlNode->sqlScale,
                             lpSqlNodeLeft->value.String,
                             lpSqlNodeRight->value.String+1,
                             lpWorkBuffer1, lpWorkBuffer2, lpWorkBuffer3);
        }
        else if ((lpSqlNodeLeft->value.String[0] == '-') &&
                 (lpSqlNodeRight->value.String[0] != '-')) {
            lpSqlNode->value.String[0] = '-';
            err = BCDDivide(lpSqlNode->value.String+1,
                             lpSqlNode->sqlScale,
                             lpSqlNodeLeft->value.String+1,
                             lpSqlNodeRight->value.String,
                             lpWorkBuffer1, lpWorkBuffer2, lpWorkBuffer3);
        }
        else {
            err = BCDDivide(lpSqlNode->value.String,
                             lpSqlNode->sqlScale,
                             lpSqlNodeLeft->value.String+1,
                             lpSqlNodeRight->value.String+1,
                             lpWorkBuffer1, lpWorkBuffer2, lpWorkBuffer3);
        }
        if (err != ERR_SUCCESS)
            return err;
        break;

    default:
        return ERR_INTERNAL;
    }

    BCDFixNegZero(lpSqlNode->value.String,s_lstrlen(lpSqlNode->value.String)+1);

    return ERR_SUCCESS;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\intf.h ===
//***************************************************************************
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  File:       intf.h
//
//	Description :
//				Defines macros for interface declarations
//
//	Part of :	Wbem ADSI 3rd Party extension WMIExtension.dll
//
//  History:	
//		corinaf			10/7/98		Created
//
//  Note : If any interface definitions change, this file needs to be updated.
//
//***************************************************************************


#define DECLARE_IUnknown_METHODS \
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ; \
		STDMETHOD_(ULONG, AddRef)(THIS_); \
		STDMETHOD_(ULONG, Release)(THIS_);

#define DECLARE_IDispatch_METHODS \
        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) ; \
        \
        STDMETHOD(GetTypeInfo)(\
        THIS_ \
        UINT itinfo,\
        LCID lcid,\
        ITypeInfo FAR* FAR* pptinfo) ;\
        \
        STDMETHOD(GetIDsOfNames)( \
        THIS_ \
        REFIID riid,\
        OLECHAR FAR* FAR* rgszNames,\
        UINT cNames,\
        LCID lcid, \
        DISPID FAR* rgdispid) ;\
        \
        STDMETHOD(Invoke)(\
        THIS_\
        DISPID dispidMember,\
        REFIID riid,\
        LCID lcid,\
        WORD wFlags,\
        DISPPARAMS FAR* pdispparams,\
        VARIANT FAR* pvarResult,\
        EXCEPINFO FAR* pexcepinfo,\
        UINT FAR* puArgErr) ;

#define DECLARE_IWMIExtension_METHODS \
        STDMETHOD(get_WMIObjectPath)(THIS_ BSTR FAR *strWMIObjectPath) ; \
        STDMETHOD(GetWMIObject)(THIS_ ISWbemObject FAR* FAR* objWMIObject) ; \
        STDMETHOD(GetWMIServices)(THIS_ ISWbemServices FAR* FAR* objWMIServices) ;
        

#define DECLARE_IADsExtension_METHODS \
		STDMETHOD(Operate)(THIS_ ULONG dwCode, VARIANT varData1, VARIANT varData2, VARIANT varData3); \
		STDMETHOD(PrivateGetIDsOfNames)(THIS_ REFIID riid, OLECHAR ** rgszNames, unsigned int cNames, LCID lcid, DISPID  * rgdispid); \
		STDMETHOD(PrivateInvoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\adsi\libmain.cpp ===
//***************************************************************************
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  File:       libmain.cpp
//
//  Description :
//              The main entry point to the dll
//
//  Part of :   Wbem ADS 3rd party extension
//
//  History:    
//      corinaf         10/9/98         Created
//
//***************************************************************************
#include "precomp.h"

//#define INITGUID

HINSTANCE g_hInst = NULL;
ULONG  g_ulObjCount = 0;  // Number of objects alive in the dll

BOOL g_bLogging = TRUE;


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//              Called by OLE's CoGetClassObject (from CoCreateInstance)
//
//----------------------------------------------------------------
extern "C"
STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    IClassFactory *pCF;

    *ppv = NULL;

    if (clsid == CLSID_WMIExtension)
    {
        pCF = new CWMIExtensionCF();
        if (!pCF)
            return E_OUTOFMEMORY;
    }
    else
        return E_FAIL;

    hr = pCF->QueryInterface(iid, ppv);
	//If QI failed delete the CF object
	if (FAILED(hr))
		delete pCF;

	//    pCF->Release(); Don't release because CWMIExtensionCF() sets the ref count to 0 not 1.
    
    return hr;
}


//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------
extern "C"
STDAPI
DllCanUnloadNow(void)
{
    return (g_ulObjCount > 0 ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
extern "C"
BOOL WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls((HINSTANCE)hDll);
        g_hInst = (HINSTANCE)hDll;
        break;
    case DLL_PROCESS_DETACH:
        break;
    default:
        break;
    }

    return TRUE;

//    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}



#define WCHAR_LEN_IN_BYTES(str)  wcslen(str)*sizeof(WCHAR)+sizeof(WCHAR)

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HKEY hKey1=NULL, hKey2=NULL, hKey3=NULL, hKey4=NULL;
    DWORD dwDisposition;
    WCHAR wcClsid[128], wcIid[128], wcTypelibid[128];
    WCHAR wcKey[128];   
    WCHAR wcModule[128];
    WCHAR wcText[] = L"WMI ADSI Extension";
    WCHAR wcTypeLibText[] = L"WMI ADSI Extension Type Library";
    WCHAR wcModel[] = L"Apartment";

    // Create strings for the CLSID & IID
    StringFromGUID2(CLSID_WMIExtension, wcClsid, 128);
    StringFromGUID2(IID_IWMIExtension, wcIid, 128);
    StringFromGUID2(LIBID_WMIEXTENSIONLib, wcTypelibid, 128);

    GetModuleFileName(g_hInst, wcModule,  128);


    //Create entry under CLSID
    //==========================

    wcscpy(wcKey, L"CLSID\\");
    wcscat(wcKey, wcClsid);
    RegCreateKeyEx(HKEY_CLASSES_ROOT, wcKey, 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey1, &dwDisposition);
    if (!hKey1) return E_FAIL;
	RegSetValueEx(hKey1, NULL, 0, REG_SZ, (LPBYTE)wcText, WCHAR_LEN_IN_BYTES(wcText));
 
    RegCreateKeyEx(hKey1,L"InprocServer32",
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey2, &dwDisposition);
    if (!hKey2) { RegCloseKey(hKey1); return E_FAIL; }
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcModule, WCHAR_LEN_IN_BYTES(wcModule));
    RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (LPBYTE)wcModel, WCHAR_LEN_IN_BYTES(wcModel));
    RegCloseKey(hKey2); hKey2=NULL;

    //RegCreateKey(hKey1, L"ProgID", &hKey2);
    //RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)WBEM_NAMESPACE_NAME, WCHAR_LEN_IN_BYTES(WBEM_NAMESPACE_NAME));
    //RegCloseKey(hKey2);

    RegCreateKeyEx(hKey1, L"TypeLib", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey2, &dwDisposition);
    if (!hKey2) { RegCloseKey(hKey1); return E_FAIL; }
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcTypelibid, WCHAR_LEN_IN_BYTES(wcTypelibid));
    RegCloseKey(hKey2); hKey2=NULL;

    RegCreateKeyEx(hKey1, L"Version", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey2, &dwDisposition);
    if (!hKey2) { RegCloseKey(hKey1); return E_FAIL; }
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)L"1.0", WCHAR_LEN_IN_BYTES(L"1.0"));
    RegCloseKey(hKey2); hKey2=NULL;

    RegCloseKey(hKey1); hKey1=NULL;


    //Create entries under Typelib for the type library
    //=================================================

    wcscpy(wcKey, L"Typelib\\");
    wcscat(wcKey, wcTypelibid);

    RegCreateKeyEx(HKEY_CLASSES_ROOT, wcKey, 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey1, &dwDisposition);
	if (!hKey1) return E_FAIL;
    RegCreateKeyEx(hKey1, L"1.0", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey2, &dwDisposition);
    if (!hKey2) { RegCloseKey(hKey1); return E_FAIL; }
	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (LPBYTE)wcTypeLibText, WCHAR_LEN_IN_BYTES(wcTypeLibText));
    RegCreateKeyEx(hKey2, L"0", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                   &hKey3, &dwDisposition);
    if (!hKey3) { RegCloseKey(hKey2); RegCloseKey(hKey1); return E_FAIL; }
    RegCreateKeyEx(hKey3, L"win32", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                   &hKey4, &dwDisposition);
    if (!hKey4) { RegCloseKey(hKey3); RegCloseKey(hKey2); RegCloseKey(hKey1); return E_FAIL; }

    //Create path to typelib - take module path and change file extension
    WCHAR *ext = wcsrchr(wcModule, L'.');
    wcscpy(ext, L".tlb");
    RegSetValueEx(hKey4, NULL, 0, REG_SZ, (LPBYTE)wcModule, WCHAR_LEN_IN_BYTES(wcModule));
    RegCloseKey(hKey4); hKey4=NULL;
    RegCloseKey(hKey3); hKey3=NULL;

    RegCreateKeyEx(hKey2, L"FLAGS", 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey3, &dwDisposition);
    if (!hKey3) { RegCloseKey(hKey2); RegCloseKey(hKey1); return E_FAIL; }
    RegSetValueEx(hKey3, NULL, 0, REG_SZ, (LPBYTE)L"0", WCHAR_LEN_IN_BYTES(L"0"));
    RegCloseKey(hKey3); hKey3=NULL;

    RegCreateKeyEx(hKey2, L"HELPDIR", 
                 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                 &hKey3, &dwDisposition);
    if (!hKey3) { RegCloseKey(hKey2); RegCloseKey(hKey1); return E_FAIL; }
    RegSetValueEx(hKey3, NULL, 0, REG_SZ, (LPBYTE)L"", WCHAR_LEN_IN_BYTES(L""));
    RegCloseKey(hKey3); hKey3=NULL;

    RegCloseKey(hKey2); hKey2=NULL;
    RegCloseKey(hKey1); hKey1=NULL;


    //Make ADSI extension registration
    //=================================

    wcscpy(wcKey, L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\");
    wcscat (wcKey, L"Computer\\"); //for Computer class extension
    wcscat(wcKey, wcClsid);
    RegCreateKeyEx(HKEY_LOCAL_MACHINE, wcKey, 
                   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                   &hKey1, &dwDisposition);
	if (!hKey1) return E_FAIL;
    RegSetValueEx(hKey1, L"Interfaces", 0, REG_MULTI_SZ, (LPBYTE)wcIid, WCHAR_LEN_IN_BYTES(wcIid));
    RegCloseKey(hKey1); hKey1=NULL;

    return NOERROR;

}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    HKEY hKey1, hKey2, hKey3;
    WCHAR wcClsid[128], wcIid[128], wcTypelibid[128];
    WCHAR wcKey[128];   
    WCHAR wcText[] = L"WMI ADSI Extension";
    WCHAR wcTypeLibText[] = L"WMI ADSI Extension Type Library";
    WCHAR wcModel[] = L"Apartment";

    // Create strings for the CLSID & IID
    StringFromGUID2(CLSID_WMIExtension, wcClsid, 128);
    StringFromGUID2(IID_IWMIExtension, wcIid, 128);
    StringFromGUID2(LIBID_WMIEXTENSIONLib, wcTypelibid, 128);


    //Delete entry under \software\microsoft\ads for the extension
    //============================================================

    wcscpy(wcKey, L"SOFTWARE\\Microsoft\\ADs\\Providers\\LDAP\\Extensions\\");
    wcscat (wcKey, L"Computer\\"); //for Computer class extension
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wcKey, 0, KEY_ALL_ACCESS, &hKey1);
    if (hr == NOERROR)
    {
        RegDeleteKey(hKey1, wcClsid);
        RegCloseKey(hKey1);
    }

    
    //Delete entries under CLSID
    //==========================

    wcscpy(wcKey, L"CLSID\\");
    wcscat(wcKey, wcClsid);

    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, wcKey, 0, KEY_ALL_ACCESS, &hKey1);
    if(hr == NOERROR)
    {
        RegDeleteKey(hKey1, L"InProcServer32");
        RegDeleteKey(hKey1, L"TypeLib");
        RegDeleteKey(hKey1, L"Version");
        RegCloseKey(hKey1);
    }

    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", 0, KEY_ALL_ACCESS, &hKey1);
    if(hr == NOERROR)
    {
        RegDeleteKey(hKey1,wcClsid);
        RegCloseKey(hKey1);
    }


    //Delete entries under Typelib for the type library
    //=================================================

    wcscpy(wcKey, L"Typelib\\");
    wcscat(wcKey, wcTypelibid);

    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, wcKey, 0, KEY_ALL_ACCESS, &hKey1);
    if (hr == NOERROR)
    {
        hr = RegOpenKeyEx(hKey1, L"1.0", 0, KEY_ALL_ACCESS, &hKey2);
        if (hr == NOERROR)
        {
            hr = RegOpenKeyEx(hKey2, L"0", 0, KEY_ALL_ACCESS, &hKey3);
            if (hr == NOERROR)
            {
                RegDeleteKey(hKey3, L"win32");
                RegCloseKey(hKey3);
            }
            RegDeleteKey(hKey2, L"0");
            RegDeleteKey(hKey2, L"FLAGS");
            RegDeleteKey(hKey2, L"HELPDIR");
            RegCloseKey(hKey2);
        }
        RegDeleteKey(hKey1, L"1.0");
        RegCloseKey(hKey1);
    }

    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, L"Typelib", 0, KEY_ALL_ACCESS, &hKey1);
    if (hr == NOERROR)
    {
        RegDeleteKey(hKey1, wcTypelibid);
        RegCloseKey(hKey1);
    }

    return NOERROR;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\bcd.h ===
/***************************************************************************/
/* BCD.H                                                                   */
/* Copyright (C) 1996 SYWARE Inc., All rights reserved                     */
/***************************************************************************/

SWORD INTFUNC BCDNormalize(LPUSTR, SDWORD, LPUSTR, SDWORD, SDWORD, SWORD);
RETCODE INTFUNC BCDCompare(LPSQLNODE, LPSQLNODE, UWORD, LPSQLNODE);
RETCODE INTFUNC BCDAlgebra(LPSQLNODE, LPSQLNODE, UWORD, LPSQLNODE,
                           LPUSTR, LPUSTR, LPUSTR);

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\browse.h ===
// BrowseDialog.h : header file
//


//Icon indexes
#define HMM_ICON_SERVER		0
#define HMM_ICON_GLOBE		1
#define HMM_ICON_OTHER		2
#define HMM_ICON_NETWORK	3

//Constant Strings
#define HMM_STR_MWN				"Microsoft Windows Network"
#define HMM_STR_MN				"Microsoft Network"
#define HMM_STR_ENTIRE_NWORK	"Entire Network"
#define	HMM_LEN_ENTIRE_NWORK	14

class CNetResourceList
{
public:
	DWORD dwScope;
	DWORD dwType;
	DWORD dwDisplayType;
	DWORD dwUsage;
	char* lpLocalName;
	char* lpRemoteName;
	char* lpComment;
	char* lpProvider;

	BOOL  fIsNULL;
	BOOL  fUseGlobe;

	CNetResourceList* pNext;

	CNetResourceList(NETRESOURCE & nr, BOOL fNull = FALSE);
	~CNetResourceList();

};

/////////////////////////////////////////////////////////////////////////////
// CBrowseDialog dialog

class CBrowseDialog : public CDialog
{
// Construction
public:
	CBrowseDialog(CWnd* pParent = NULL);   // standard constructor

	~CBrowseDialog(); //destructor

	void EnumerateServers(LPNETRESOURCE lpnr, BOOL fUseGlobe = FALSE);
	void CleanUpListCtrl();

	char* GetServerName()	{return lpServerName;}

	void Clone(NETRESOURCE &nrClone, DWORD nrScope, DWORD nrType, DWORD nrDisplayType, DWORD nrUsage,
							LPSTR lpLocalName, LPSTR lpRemoteName, LPSTR lpComment, LPSTR lpProvider);
	
	int GetSelectedIndex(DWORD &dwDisplayType);
	void OnDblclkList2(int index);

// Dialog Data
	//{{AFX_DATA(CBrowseDialog)
	enum { IDD = IDD_DIALOG_BROWSE };
	CButton	m_cancelButton;
	CButton	m_okButton;
	CListCtrl	m_list;
	//}}AFX_DATA
	CImageList m_imageList;
	HICON hIcon;
	int count;
	NETRESOURCE dummy;

	CNetResourceList* pPrevList;

	CNetResourceList* pCurrentSelectionList;
	CNetResourceList* pCurrentItem;

	CBitmapButton m_backBitmapButton;
	CBitmapButton m_listBitmapButton;
	CBitmapButton m_detailBitmapButton;

	LONG oldStyle; //original list control style

	char lpServerName [MAX_SERVER_NAME_LENGTH + 1];

	int iSelectedItem;//index of item selected in listbox
	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();
	virtual void OnNcDestroy ();
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL fIsWin95; //flag to indicate if workstation is Windows 95

	// Generated message map functions
	//{{AFX_MSG(CBrowseDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkList1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBackbutton();
	afx_msg void OnListbutton();
	afx_msg void OnDetailbutton();
	afx_msg void OnItemchangedList3(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnNeedText(UINT id, NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//	afx_msg void OnSetfocusList2(NMHDR* pNMHDR, LRESULT* pResult);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\browse.cpp ===
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "afxtempl.h"

#include "resource.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);



#include  "drdbdr.h"

#include "winnetwk.h"
#define NET_API_STATUS DWORD
#define NET_API_FUNCTION __stdcall
#include "lmwksta.h"

#include "Browse.h"

#include "dlgcback.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CNetResourceList :: CNetResourceList(NETRESOURCE & nr, BOOL fNULL)
{
	//Initialize
	fUseGlobe = FALSE;
	fIsNULL = fNULL;
	pNext = NULL;
	

	lpLocalName = NULL;
	lpRemoteName = NULL;
	lpComment = NULL;
	lpProvider = NULL;

	//If it is not NULL

	if (!fIsNULL)
	{
		dwScope = nr.dwScope;
		dwType = nr.dwType;
		dwDisplayType = nr.dwDisplayType;
		dwUsage = nr.dwUsage;

		if (nr.lpLocalName)
		{
			lpLocalName = new char [strlen(nr.lpLocalName) + 1];
			lpLocalName[0] = 0;
			strcpy(lpLocalName, nr.lpLocalName);
		}
		
		if (nr.lpRemoteName)
		{
			lpRemoteName = new char [strlen(nr.lpRemoteName) + 1];
			lpRemoteName[0] = 0;
			strcpy(lpRemoteName, nr.lpRemoteName);
		}
		
		if (nr.lpComment)
		{
			lpComment = new char [strlen(nr.lpComment) + 1];
			lpComment[0] = 0;
			strcpy(lpComment, nr.lpComment);
		}
		
		if (nr.lpProvider)
		{
			lpProvider = new char [strlen(nr.lpProvider) + 1];
			lpProvider[0] = 0;
			strcpy(lpProvider, nr.lpProvider);
		}
	}
}



CNetResourceList :: ~CNetResourceList()
{
	//Tidy Up
//      if (pNext)
//              delete pNext;

	if (!fIsNULL)
	{
		delete lpLocalName;
		delete lpRemoteName;
		delete lpComment;
		delete lpProvider;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBrowseDialog dialog


CBrowseDialog::CBrowseDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CBrowseDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBrowseDialog)
	//}}AFX_DATA_INIT
}

CBrowseDialog :: ~CBrowseDialog()
{
	//Tidy Up
//	delete pPrevList;
//	delete pCurrentSelectionList;

	if (pPrevList)
	{
		CNetResourceList* theNext = NULL; 
		do
		{
			theNext = pPrevList->pNext;
			delete pPrevList;
			pPrevList = theNext;
		} while (pPrevList);
	}

	if (pCurrentSelectionList)
	{
		CNetResourceList* theNext = NULL; 
		do
		{
			theNext = pCurrentSelectionList->pNext;
			delete pCurrentSelectionList;
			pCurrentSelectionList = theNext;
		} while (pCurrentSelectionList);
	}
}

void CBrowseDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBrowseDialog)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBrowseDialog, CDialog)
	//{{AFX_MSG_MAP(CBrowseDialog)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST1, OnDblclkList1)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST1, OnItemchangedList3)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST1, OnKeyDown)
	ON_BN_CLICKED(IDC_BACKBUTTON, OnBackbutton)
	ON_BN_CLICKED(IDC_LISTBUTTON, OnListbutton)
	ON_BN_CLICKED(IDC_DETAILBUTTON, OnDetailbutton)
	ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnNeedText)
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowseDialog message handlers

//This is used to mimick the stucture in NETAPI32.LIB
typedef struct _WkstaInfo100
{
	DWORD wki100_platform_id;
	LPSTR wki100_computername;
	LPSTR wki100_langroup;
	DWORD wki100_ver_major;
	DWORD wki100_ver_minor;
} WkstaInfo100, *PWkstaInfo100, *LPWkstaInfo100;

typedef NET_API_STATUS  (CALLBACK *ULPRET)(LPSTR servername, 
										 DWORD level, 
										 LPBYTE* bufptr);

BOOL CBrowseDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// subclass the window to circumvent a bug (?) in mfc
	WNDPROC oldWindowProc =  (WNDPROC):: SetWindowLong (m_hWnd, GWL_WNDPROC, (DWORD) MySubClassProc);
	CWindowInfo *pwindowInfo = new CWindowInfo (m_hWnd, oldWindowProc);
	windowMap.SetAt ((SHORT)((DWORD)m_hWnd & 0xffff), pwindowInfo);

	// hook up controls
	m_cancelButton.Attach (::GetDlgItem (m_hWnd, IDCANCEL));
	m_okButton.Attach (::GetDlgItem (m_hWnd, IDOK));
	m_list.Attach(::GetDlgItem (m_hWnd, IDC_LIST1));
	
	// TODO: Add extra initialization here
	pPrevList = NULL;
	pCurrentSelectionList = NULL;
	pCurrentItem = NULL;
	lpServerName[0] = 0;
	iSelectedItem = 0;


	//Setup image list with icons
	m_imageList.Create (16, 16, TRUE, 25, 0);

	//The first icon (HMM_ICON_SERVER) is used to represent SERVERS
	hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON1));
	m_imageList.Add (hIcon);

	//The second icon (HMM_ICON_GLOBE) is used to represent the entire network
	hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON2));
	m_imageList.Add (hIcon);

	//The third icon (HMM_ICON_OTHER) is used to represent any other network resource
	hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON3));
	m_imageList.Add (hIcon);

	//The forth icon (HMM_ICON_NETWORK) is used to represent a link to the entire network
	hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON4));
	m_imageList.Add (hIcon);

	//Setup Bitmap pushbuttons
	m_backBitmapButton.AutoLoad(IDC_BACKBUTTON, this);
	m_listBitmapButton.AutoLoad(IDC_LISTBUTTON, this);
	m_listBitmapButton.EnableWindow(FALSE);
	m_detailBitmapButton.AutoLoad(IDC_DETAILBUTTON, this);

	//Enable tool tips for this dialog
	EnableToolTips(TRUE);

	//Setup column for report view
	LV_COLUMN lvCol;
	lvCol.mask = LVCF_FMT | LVCF_WIDTH;
	lvCol.fmt = LVCFMT_LEFT;
	lvCol.cx = MAX_SERVER_NAME_LENGTH;
	m_list.InsertColumn(1, &lvCol);

	m_list.SetImageList (&m_imageList, LVSIL_SMALL);

	oldStyle = :: GetWindowLong(m_list.m_hWnd, GWL_STYLE);

	:: SetWindowLong (m_list.m_hWnd,
						GWL_STYLE, oldStyle | LVS_LIST | LVS_SINGLESEL);

	char buff [500 + 1];
	buff[0] = 0;

	//check if this is a Windows 95 machine
	//This is a Windows 95 machine
	//by getting the info from the registry
	fIsWin95 = TRUE;

	HKEY keyHandle = (HKEY)1;
	long fStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		"System\\CurrentControlSet\\Services\\VxD\\VNETSUP", 0, KEY_READ, &keyHandle);

	if (fStatus == ERROR_SUCCESS)
	{
		DWORD sizebuff = 500;
		DWORD typeValue;

		
		fStatus = RegQueryValueEx(keyHandle, "Workgroup", NULL,
						&typeValue, (LPBYTE)buff, &sizebuff);

	}

	if ( (fStatus != ERROR_SUCCESS) )
	{
		fIsWin95 = FALSE;

		buff[0] = 0;
		//Check if you can call NetWkstaGetInfo in the NETAPI32.DLL
		ULPRET pProcAddr = NULL;
		HINSTANCE hNetApi =  LoadLibrary("NETAPI32.DLL");

		if (hNetApi)
		{
			pProcAddr = (ULPRET) GetProcAddress(hNetApi, "NetWkstaGetInfo");
		}

		if (hNetApi && pProcAddr)
		{
			//Use NetAPI32

			LPBYTE buffer;
			((*pProcAddr)(NULL, 100, &buffer));
			LPWkstaInfo100 lpFred = (LPWkstaInfo100) buffer;
			wsprintf (buff, "%ws", lpFred->wki100_langroup);
		}

		//Tidy up
		if (hNetApi)
			FreeLibrary(hNetApi);
	}

	buff[500] = 0;

	NETRESOURCE nr;
	nr.dwScope = RESOURCE_GLOBALNET;
	nr.dwType = RESOURCETYPE_ANY;
	nr.dwDisplayType = RESOURCEDISPLAYTYPE_DOMAIN;
	nr.dwUsage = RESOURCEUSAGE_CONTAINER;
	nr.lpLocalName = NULL;
	nr.lpRemoteName = buff; 
	nr.lpComment = "";

	//New stuff to get provider name
	DWORD buffSize = 500;
	char provName [500];

	DWORD dwResult = WNetGetProviderName(WNNC_NET_MSNET, provName, &buffSize);

	if (dwResult != WN_SUCCESS)
	{
		dwResult = WNetGetProviderName(WNNC_NET_LANMAN, provName, &buffSize);
	}

	if (dwResult != WN_SUCCESS)
	{
		ODBCTRACE ("\nWBEM ODBC Driver : Failed to get provider name\n");
	}
	else
	{
		ODBCTRACE ("\nWBEM ODBC Driver : Provider name = ");
		ODBCTRACE (provName);
		ODBCTRACE ("\n");
	}

	nr.lpProvider = provName;
	
	//Add first entry in callback list (i.e. previous list)
	pPrevList = new CNetResourceList(nr, FALSE);
	pPrevList->fUseGlobe = TRUE;

	count = 0;
	EnumerateServers(&nr, pPrevList->fUseGlobe);

	//Give Cancel pushbutton focus
	m_cancelButton.SetFocus();

	return TRUE;  // return TRUE unless you set the focus to a control
		      // EXCEPTION: OCX Property Pages should return FALSE
}


void CBrowseDialog :: EnumerateServers(LPNETRESOURCE lpnr, BOOL fUseGlobe)
{
	//Disable controls before enumeration
	BeginWaitCursor();
	m_okButton.EnableWindow(FALSE);
	m_backBitmapButton.EnableWindow(FALSE);
	
	HANDLE hEnum = NULL;
	DWORD dwResult = 0;
	

	//check if this is Windows 95 asking for the Entire Network
	NETRESOURCE nr95;
	if (fIsWin95 && !lpnr)
	{
		nr95.dwScope = RESOURCE_GLOBALNET;
		nr95.dwType = RESOURCETYPE_ANY;
		nr95.dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
		nr95.dwUsage = RESOURCEUSAGE_CONTAINER;
		nr95.lpLocalName = NULL;
		nr95.lpRemoteName = NULL; 
		nr95.lpComment = HMM_STR_MN;
		nr95.lpProvider = HMM_STR_MN;

		dwResult = WNetOpenEnum(RESOURCE_GLOBALNET,
						RESOURCETYPE_ANY, 0, &nr95, &hEnum);
	}
	else
	{
		dwResult = WNetOpenEnum(RESOURCE_GLOBALNET,
						RESOURCETYPE_ANY, 0, lpnr, &hEnum);
	}
	
	//Only disable cancel button after enumeration returned
	m_cancelButton.EnableWindow(FALSE);

	BOOL fUseBackArrow = FALSE; //can we go back to previous screen ?

	if ( dwResult != NO_ERROR )
	{
		EndWaitCursor();
		m_cancelButton.EnableWindow(TRUE);
		m_backBitmapButton.EnableWindow(!fUseGlobe);
		return;
	}

	DWORD dwResultEnum = 0;

	DWORD cbBuffer = 16384; //16k is a reasonable size
	DWORD cEntries = 0xFFFFFFFF; //get all entries
	LPNETRESOURCE lpnrLocal = NULL;
	

	//Check if you need to add a back arrow or globe
	if ( fUseGlobe )
	{
		//Add Globe
		LV_ITEM tempItem1;
		tempItem1.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
		tempItem1.iItem = count++;
		tempItem1.iSubItem = 0;
		tempItem1.pszText = HMM_STR_ENTIRE_NWORK;
		tempItem1.state = 0;
		tempItem1.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
		tempItem1.iImage = HMM_ICON_GLOBE;
		tempItem1.lParam = (DWORD) NULL;
		m_list.InsertItem(&tempItem1);

		//Disable the back arrow
		fUseBackArrow = FALSE;
	}
	else
	{
		//Add Back Arrow

		//Enable the back arrow
		fUseBackArrow = TRUE;

		if (lpnr)
		{
			//Add to head of current selection list for speedy clean up
			pCurrentSelectionList =  new CNetResourceList(*lpnr, FALSE);
			pCurrentItem = pCurrentSelectionList;
		}
	}


	do 
	{
		//Allocate memory for NETRESOURCE structures
		//to retrieve from enumeration
		lpnrLocal = (LPNETRESOURCE) GlobalAlloc (GPTR, cbBuffer);

		if (lpnrLocal)
        {
            dwResultEnum = WNetEnumResource (hEnum, &cEntries,
						    lpnrLocal, &cbBuffer);


		    if ( (dwResultEnum == NO_ERROR))
		    {
			    for (DWORD i = 0; i < cEntries; i++)
			    {
				    //Display NETRESOURCE structure
				    NETRESOURCE fred = lpnrLocal[i];

				    if (fred.lpRemoteName)
				    {
					    //Insert into List View Control
					    LV_ITEM tempItem;
					    tempItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
					    tempItem.iItem = count++;
					    tempItem.iSubItem = 0;
					    tempItem.pszText = fred.lpRemoteName;
					    tempItem.state = 0;
					    tempItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;

					    //Work out which icon to use
					    if (lpnrLocal[i].dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
						    tempItem.iImage = HMM_ICON_SERVER;
					    else if (lpnrLocal[i].dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK)
						    tempItem.iImage = HMM_ICON_NETWORK;
					    else if (lpnrLocal[i].dwDisplayType == RESOURCEDISPLAYTYPE_GENERIC)
						    tempItem.iImage = HMM_ICON_NETWORK;
					    else
						    tempItem.iImage = HMM_ICON_OTHER;

					    
					    //Add to end of current selection list for speedy clean up
					    CNetResourceList* pt =  new CNetResourceList(fred, FALSE);

					    if (pCurrentSelectionList)
					    {
						    pCurrentItem->pNext = pt;
						    pCurrentItem = pt;      
					    }
					    else
					    {
						    pCurrentSelectionList = pt;
						    pCurrentItem = pt;      
					    }
					    
					    tempItem.lParam = (DWORD) pt;
					    m_list.InsertItem(&tempItem);
				    }
			    }
		    }
		    

		    //Tidy up
		    GlobalFree( (HGLOBAL) lpnrLocal);
        }
		else
            break;

	} while (dwResultEnum != ERROR_NO_MORE_ITEMS);

	WNetCloseEnum(hEnum);

	//Re-enable pushbuttons
	m_backBitmapButton.EnableWindow(fUseBackArrow);
	m_cancelButton.EnableWindow(TRUE);
	EndWaitCursor();

//	if (m_list.GetSelectedCount())
//		m_okButton.EnableWindow(TRUE);
}

void CBrowseDialog::OnDblclkList2(int index)
{
	if ((index != -1))
	{
		LV_ITEM tempItem;
		tempItem.mask = LVIF_IMAGE | LVIF_PARAM;
		tempItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
		tempItem.iSubItem = 0;
		tempItem.iItem = index;

		if ( m_list.GetItem(&tempItem) ) 
		{
			
			//Check if you clicked on globe or arrow
			if (tempItem.iImage == HMM_ICON_GLOBE)
			{
				//Remove current items in list view control
				CleanUpListCtrl();
				m_list.DeleteAllItems();

				//Get Microsoft Network Info
				count = 0;

				//Add to start of previous list
				CNetResourceList* pt = pPrevList;
				pPrevList = new CNetResourceList(dummy, TRUE);
				if (pt)
					pPrevList->pNext = pt;

				EnumerateServers(NULL, pPrevList->fUseGlobe);

				//Give Cancel pushbutton focus
				m_cancelButton.SetFocus();
			}
			else
			{
				CNetResourceList* pNR = (CNetResourceList*)tempItem.lParam;

	
				if (pNR && pNR->dwDisplayType != RESOURCEDISPLAYTYPE_SERVER)
				{
					//Setup information for new enumeration
					NETRESOURCE nr2;
					nr2.lpLocalName = NULL;
					nr2.lpRemoteName = NULL;
					nr2.lpComment = NULL;
					nr2.lpProvider = NULL;

					BOOL fNULL = pNR->fIsNULL;

					if (!fNULL)
					{
						Clone(nr2, pNR->dwScope, pNR->dwType, pNR->dwDisplayType, pNR->dwUsage,
							pNR->lpLocalName, pNR->lpRemoteName, pNR->lpComment, pNR->lpProvider); 
					}

					//Add item to front of list
					CNetResourceList* pt = pPrevList;
					pPrevList = new CNetResourceList(nr2, fNULL);
					if (pt)
						pPrevList->pNext = pt;

					//Remove current items in list view control
					CleanUpListCtrl();
					m_list.DeleteAllItems();


					count = 0;

					if (fNULL)
						EnumerateServers(NULL, pPrevList->fUseGlobe);
					else
						EnumerateServers(&nr2, pPrevList->fUseGlobe);

					//Give Cancel pushbutton focus
					m_cancelButton.SetFocus();

					//Tidy up
					delete nr2.lpLocalName;
					delete nr2.lpRemoteName;
					delete nr2.lpComment;
					delete nr2.lpProvider;
				}
				else
				{
					m_okButton.EnableWindow(TRUE);
				}
			}               
		}
	}
}

void CBrowseDialog::OnDblclkList1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	
	*pResult = 0;

	//Get current position of mouse cursor and perform
	//a hit test on the tree control
	POINT cursorPos;
	cursorPos.x = 0;
	cursorPos.y = 0;
	BOOL state = GetCursorPos(&cursorPos);

	m_list.ScreenToClient(&cursorPos);

	UINT fFlags = 0;

	int index = m_list.HitTest(cursorPos, &fFlags);

	if (fFlags & LVHT_ONITEM)
	{
		OnDblclkList2(index);
	}
}


void CBrowseDialog :: CleanUpListCtrl()
{
	//Disable back button (if applicable)
	m_backBitmapButton.EnableWindow(FALSE);

	if (pCurrentSelectionList)
	{
		CNetResourceList* theNext = NULL; 
		do
		{
			theNext = pCurrentSelectionList->pNext;
			delete pCurrentSelectionList;
			pCurrentSelectionList = theNext;
		} while (pCurrentSelectionList);
	}

	pCurrentSelectionList = NULL;
	pCurrentItem = NULL;
}

void CBrowseDialog::OnBackbutton() 
{
	// TODO: Add your control notification handler code here
	//Remove current items in list view control
	CleanUpListCtrl();
	m_list.DeleteAllItems();

	//Remove item from front of list
	CNetResourceList* pt = pPrevList->pNext;
	pPrevList->pNext = NULL;
	delete pPrevList;
	pPrevList = pt;

	//Go back and get previous enumeration
	NETRESOURCE temp;
	temp.lpLocalName = NULL;
	temp.lpRemoteName = NULL;
	temp.lpComment = NULL;
	temp.lpProvider = NULL;


	BOOL fGlobe = pPrevList->fUseGlobe;
	BOOL fNULL = pPrevList->fIsNULL;

	if ( ! fNULL)
	{
		Clone(temp, pPrevList->dwScope, pPrevList->dwType, pPrevList->dwDisplayType, pPrevList->dwUsage,
			pPrevList->lpLocalName, pPrevList->lpRemoteName, pPrevList->lpComment, pPrevList->lpProvider); 
	}

	count = 0;

	if (fNULL)
		EnumerateServers(NULL, fGlobe);
	else
		EnumerateServers(&temp, fGlobe);

	//Give Cancel pushbutton focus
	m_cancelButton.SetFocus();

	//Tidy Up
	delete temp.lpLocalName;
	delete temp.lpRemoteName;
	delete temp.lpComment;
	delete temp.lpProvider;
}

void CBrowseDialog::OnListbutton() 
{
	// TODO: Add your control notification handler code here
	m_listBitmapButton.EnableWindow(FALSE);
	m_detailBitmapButton.EnableWindow(TRUE);

	int cCount = m_list.GetItemCount();

	:: SetWindowLong (m_list.m_hWnd,
						GWL_STYLE, oldStyle | LVS_LIST | LVS_SINGLESEL);
	
	m_list.RedrawItems(0, cCount - 1);
	UpdateWindow();
}

void CBrowseDialog::OnDetailbutton() 
{
	// TODO: Add your control notification handler code here
	m_detailBitmapButton.EnableWindow(FALSE);
	m_listBitmapButton.EnableWindow(TRUE);

	int cCount = m_list.GetItemCount();

	:: SetWindowLong (m_list.m_hWnd,
						GWL_STYLE, oldStyle | LVS_NOCOLUMNHEADER | LVS_ICON | LVS_REPORT | LVS_SINGLESEL);

	m_list.RedrawItems(0, cCount - 1);
	UpdateWindow();
}

BOOL CBrowseDialog::OnNeedText(UINT id, NMHDR* pNMHDR, LRESULT* pResult)
{
	TOOLTIPTEXT* pTTT = (TOOLTIPTEXT*)pNMHDR;
	UINT nID = pNMHDR->idFrom;
	if (pTTT->uFlags & TTF_IDISHWND)
	{
		//idFrom is actually the HWND of the tool
		nID= :: GetDlgCtrlID((HWND)nID);
		switch (nID)
		{
		case IDC_BACKBUTTON:
		{
			pTTT->lpszText = MAKEINTRESOURCE(STR_PREVIOUS);
			pTTT->hinst = AfxGetResourceHandle();
			return (TRUE);
		}
			break;
		case IDC_LISTBUTTON:
		{
			pTTT->lpszText = MAKEINTRESOURCE(STR_LIST_VIEW);
			pTTT->hinst = AfxGetResourceHandle();
			return (TRUE);
		}
			break;
		case IDC_DETAILBUTTON:
		{
			pTTT->lpszText = MAKEINTRESOURCE(STR_REPORT_VIEW);
			pTTT->hinst = AfxGetResourceHandle();
			return (TRUE);
		}
			break;
		default:
			break;
		}
	}
	return (FALSE);
}
void CBrowseDialog :: OnNcDestroy ()
{
	CWindowInfo *pwindowInfo = NULL;
	BOOL found = windowMap.Lookup ((SHORT) ((DWORD)m_hWnd & 0xffff), pwindowInfo);
	ASSERT (found);
	if (found)
	{
		:: SetWindowLong (m_hWnd, GWL_WNDPROC, (DWORD) pwindowInfo->m_oldWindowProc);
		windowMap.RemoveKey ((SHORT) ((DWORD)m_hWnd & 0xffff));
		delete pwindowInfo;
	}
	m_cancelButton.Detach ();
	m_okButton.Detach ();
	m_list.Detach ();
	CDialog :: OnNcDestroy ();
}

void CBrowseDialog::OnOK() 
{
	//Get name of selected item using selected item index
	LV_ITEM tempItem;
	tempItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	tempItem.iItem = iSelectedItem;
	tempItem.iSubItem = 0;
	tempItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
	tempItem.pszText = lpServerName;
	tempItem.cchTextMax = MAX_SERVER_NAME_LENGTH;

	if ( m_list.GetItem(&tempItem) )
	{
		//Copy name of network resource
//		lpServerName[0] = 0;
//		if (tempItem.pszText)
//		{
//			strncpy(lpServerName, tempItem.pszText, MAX_SERVER_NAME_LENGTH);
//			lpServerName[MAX_SERVER_NAME_LENGTH] = 0;
//		}
	}
	
	CDialog::OnOK();
}

//Populates a NETRESOURCE structure with the input parameters
void CBrowseDialog :: Clone(NETRESOURCE &nrClone, DWORD nrScope, DWORD nrType, DWORD nrDisplayType, DWORD nrUsage,
							LPSTR lpLocalName, LPSTR lpRemoteName, LPSTR lpComment, LPSTR lpProvider)
{
	nrClone.lpLocalName = NULL;
	nrClone.lpRemoteName = NULL;
	nrClone.lpComment = NULL;
	nrClone.lpProvider = NULL;

					
	nrClone.dwScope = nrScope;
	nrClone.dwType = nrType;
	nrClone.dwDisplayType = nrDisplayType;
	nrClone.dwUsage = nrUsage;
						
	if (lpLocalName)
	{
		nrClone.lpLocalName = new char [strlen(lpLocalName) + 1];
		nrClone.lpLocalName[0] = 0;
		strcpy(nrClone.lpLocalName, lpLocalName);
	}

	if (lpRemoteName)
	{
		nrClone.lpRemoteName = new char [strlen(lpRemoteName) + 1];
		nrClone.lpRemoteName[0] = 0;
		strcpy(nrClone.lpRemoteName, lpRemoteName);
	}
						
	if (lpComment)
	{
		nrClone.lpComment = new char [strlen(lpComment) + 1];
		nrClone.lpComment[0] = 0;
		strcpy(nrClone.lpComment, lpComment);
	}
						
	if (lpProvider)
	{
		nrClone.lpProvider = new char [strlen(lpProvider) + 1];
		nrClone.lpProvider[0] = 0;
		strcpy(nrClone.lpProvider, lpProvider);
	}
			
}

// -1 if no selected index
int CBrowseDialog::GetSelectedIndex(DWORD &dwDisplayType)
{
	//Check if one item is selected
	int selecCount = m_list.GetSelectedCount();
	int itemCount = m_list.GetItemCount();

	if ( selecCount == 1 )
	{
		int mySelIndex = m_list.GetNextItem ( -1 , LVNI_ALL | LVNI_SELECTED ) ;

		if (mySelIndex != -1)
		{
			LV_ITEM myItem;
			myItem.mask = LVIF_STATE | LVIF_IMAGE | LVIF_PARAM;
			myItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
			myItem.iItem = mySelIndex;
			myItem.iSubItem = 0;

			//Find index to this item
			if ( m_list.GetItem(&myItem) )
			{
				CNetResourceList* pNR = (CNetResourceList*)myItem.lParam;

				if (pNR)
					dwDisplayType = pNR->dwDisplayType;

				return mySelIndex; //break out now
			}
		}
	}

	//No selected item found
	return -1;
}

void CBrowseDialog::OnItemchangedList3(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;

	ODBCTRACE ("\nCBrowseDialog::OnItemchangedList3\n");

	DWORD dwDisplayType = 0;
	int mySelectedIndex = GetSelectedIndex(dwDisplayType);
	if ( mySelectedIndex != -1 )
	{
		iSelectedItem = mySelectedIndex;

		//check if selected item is a server				
		if (dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
			m_okButton.EnableWindow(TRUE);
		else
			m_okButton.EnableWindow(FALSE);
	}
}

void CBrowseDialog::OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODBCTRACE ("\nCBrowseDialog::OnKeyDown\n");

	TV_KEYDOWN* lParam = (TV_KEYDOWN*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;

	//Check if SPACE BAR is pressed (to expand node)
	if ( lParam->wVKey == VK_SPACE )
	{
		DWORD dwDisplayType = 0;
		int mySelectedIndex = GetSelectedIndex(dwDisplayType);
		OnDblclkList2(mySelectedIndex);
	}
	else if (lParam->wVKey == VK_BACK)
	{
		//BACKSPACE PRESSED (for Up One Level)
		if ( m_backBitmapButton.IsWindowEnabled() )
		{
			OnBackbutton();
		}
	}
	else if (lParam->wVKey == 'L')
	{
		//L PRESSED (for List View)
		OnListbutton();
	}
	else if (lParam->wVKey == 'D')
	{
		//D PRESSED (for Details View)
		OnDetailbutton();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\coldefs.cpp ===
/***************************************************************************/
/* COLDEFS.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/

COLATTRIBUTE colAttributeTables[] = {
	/* COUNT */
	{ COLUMN_COUNT_TABLES },

	/* TABLE_QUALIFIER */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "QUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "QUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TABLE_OWNER */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "OWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "OWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TABLE_NAME */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TABLE_TYPE */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TYPENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR)"",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TABLE_REMARKS */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ TRUE,
	/* displaySize      */ 254,
	/* label            */ (LPUSTR) "REMARKS",
	/* length           */ 254,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "REMARKS",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 254,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TABLE_ATTRIBUTES */
	{
	/* count            */ COLUMN_COUNT_TABLES,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ TRUE,
	/* displaySize      */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* label            */ (LPUSTR) "ATTRIBUTES",
	/* length           */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "ATTRIBUTES",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_LONGVARCHAR,
	/* typeName         */ (LPSTR) "LONGVARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
};

COLATTRIBUTE colAttributeColumns[] = {
	/* COUNT */
	{ COLUMN_COUNT_COLUMNS },

	/* COLUMN_QUALIFIER */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "QUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "QUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_OWNER */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "OWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "OWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_TABLE */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_NAME */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "COLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "COLUMNNAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_TYPE */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "TYPE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_TYPENAME */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TYPENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_PRECISION */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "PRECISION",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PRECISION",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_LENGTH */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "LENGTH",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "LENGTH",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_SCALE */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "SCALE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SCALE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_RADIX*/
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "RADIX",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "RADIX",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_NULLABLE */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "NULLABLE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "NULLABLE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_REMARKS */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ TRUE,
	/* displaySize      */ 254,
	/* label            */ (LPUSTR) "REMARKS",
	/* length           */ 254,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "REMARKS",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 254,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* COLUMN_ATTRIBUTES */
	{
	/* count            */ COLUMN_COUNT_COLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* label            */ (LPUSTR) "ATTRIBUTES",
	/* length           */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "ATTRIBUTES",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ ISAM_MAX_LONGVARCHAR, /*SQL_NO_TOTAL,*/
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_LONGVARCHAR,
	/* typeName         */ (LPSTR) "LONGVARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE colAttributeStatistics[] = {
	/* COUNT */
	{ COLUMN_COUNT_STATISTICS },

	/* STATISTIC_QUALIFIER */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "QUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "QUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_OWNER */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "OWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "OWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_NAME */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_NONUNIQUE */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "NONUNIQUE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "NONUNIQUE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_INDEXQUALIFIER */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "INDEXQUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "INDEXQUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_INDEXNAME */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "INDEXNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "INDEXNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_TYPE */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "TYPE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_SEQININDEX */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "SEQININDEX",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SEQININDEX",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_COLUMNNAME */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "COLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "COLUMNNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_COLLATION */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ TRUE,
	/* displaySize      */ 1,
	/* label            */ (LPUSTR) "COLLATION",
	/* length           */ 1,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "COLLATION",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 1,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_CHAR,
	/* typeName         */ (LPSTR) "CHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_CARDINALITY */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "CARDINALITY",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "CARDINALITY",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_PAGES */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "PAGES",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PAGES",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* STATISTIC_FILTERCONDITION */
	{
	/* count            */ COLUMN_COUNT_STATISTICS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "FILTER",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FILTER",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE colAttributeSpecialColumns[] = {
	/* COUNT */
	{ COLUMN_COUNT_SPECIALCOLUMNS },

	/* SPECIALCOLUMN_SCOPE */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "SCOPE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SCOPE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_NAME  */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "COLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "COLUMNNAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_TYPE  */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "TYPE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_TYPENAME */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TYPENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_PRECISION */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "PRECISION",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PRECISION",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_LENGTH */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "LENGTH",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "LENGTH",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_SCALE */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "SCALE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SCALE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* SPECIALCOLUMN_PSEUDOCOLUMN */
	{
	/* count            */ COLUMN_COUNT_SPECIALCOLUMNS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "PSEUDO",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PSEUDO",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE colAttributeTypeInfo[] = {
	/* COUNT */
	{ COLUMN_COUNT_TYPEINFO },

	/* TYPEINFO_NAME */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TYPENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_TYPE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "TYPE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TYPE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_PRECISION */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 10,
	/* label            */ (LPUSTR) "PRECISION",
	/* length           */ 4,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PRECISION",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 10,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_INTEGER,
	/* typeName         */ (LPSTR) "INTEGER",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_PREFIX */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PREFIX",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PREFIX",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_SUFFIX */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "SUFFIX",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SUFFIX",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_PARAMS */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PARAMS",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PARAMS",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_NULLABLE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "NULLABLE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "NULLABLE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_CASESENSITIVE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "CASESENSITIVE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "CASESENSITIVE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_SEARCHABLE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "SEARCHABLE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "SEARCHABLE",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_UNSIGNED */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "UNSIGNED",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "UNSIGNED",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_MONEY */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "MONEY",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "MONEY",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_AUTOINCREMENT */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "AUTOINCREMENT",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "AUTOINCREMENT",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_LOCALNAME */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "LOCALTYPENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "LOCALTYPENAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_MINSCALE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "MINSCALE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "MINSCALE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* TYPEINFO_MAXSCALE */
	{
	/* count            */ COLUMN_COUNT_TYPEINFO,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "MAXSCALE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "MAXSCALE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE colAttributePrimaryKeys[] = {
	/* COUNT */
	{ COLUMN_COUNT_PRIMARYKEYS },

	/* PRIMARYKEY_QUALIFIER */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "QUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "QUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* PRIMARYKEY_OWNER */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "OWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "OWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* PRIMARYKEY_TABLE */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "TABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "TABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* PRIMARYKEY_COLUMN */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "COLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "COLUMNNAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* PRIMARYKEY_KEYSEQ */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "KEYSEQ",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "KEYSEQ",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* PRIMARYKEY_NAME */
	{
	/* count            */ COLUMN_COUNT_PRIMARYKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 254,
	/* label            */ (LPUSTR) "PKNAME",
	/* length           */ 254,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 254,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE colAttributeForeignKeys[] = {
	/* COUNT */
	{ COLUMN_COUNT_FOREIGNKEYS },

	/* FOREIGNKEY_PKQUALIFIER */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PKQUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKQUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_PKOWNER */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PKOWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKOWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_PKTABLE */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PKTABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKTABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_PKCOLUMN */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "PKCOLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKCOLUMNNAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_FKQUALIFIER */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "FKQUALIFIERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FKQUALIFIERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_FKOWNER */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "FKOWNERNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FKOWNERNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_FKTABLE */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "FKTABLENAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FKTABLENAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_FKCOLUMN */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 128,
	/* label            */ (LPUSTR) "FKCOLUMNNAME",
	/* length           */ 128,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FKCOLUMNNAME",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 128,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_KEYSEQ */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "KEYSEQ",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "KEYSEQ",
	/* nullable         */ SQL_NO_NULLS,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_UPDATERULE */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "UPDATERULE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "UPDATERULE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_DELETERULE */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ FALSE,
	/* displaySize      */ 5,
	/* label            */ (LPUSTR) "DELETERULE",
	/* length           */ 2,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "DELETERULE",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 5,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_SMALLINT,
	/* typeName         */ (LPSTR) "SMALLINT",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_FKNAME */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 254,
	/* label            */ (LPUSTR) "FKNAME",
	/* length           */ 254,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "FKNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 254,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	},
	/* FOREIGNKEY_PKNAME */
	{
	/* count            */ COLUMN_COUNT_FOREIGNKEYS,
	/* autoIncrement    */ FALSE,
	/* caseSensitive    */ -2,
	/* displaySize      */ 254,
	/* label            */ (LPUSTR) "PKNAME",
	/* length           */ 254,
	/* money            */ FALSE,
	/* name             */ (LPUSTR) "PKNAME",
	/* nullable         */ SQL_NULLABLE,
	/* ownerName        */ (LPUSTR) "",
	/* precision        */ 254,
	/* qualifierName    */ (LPUSTR) "",
	/* scale            */ 0,
	/* columnSearchable */ SQL_UNSEARCHABLE,
	/* tableName        */ (LPUSTR) "",
	/* type             */ SQL_VARCHAR,
	/* typeName         */ (LPSTR) "VARCHAR",
	/* unsignedAttribute*/ TRUE,
	/* updatable        */ SQL_ATTR_READONLY
	}
};

COLATTRIBUTE FAR *colAttributes[8] = {
	/*           STMT_TYPE_NONE */ NULL,
	/*         STMT_TYPE_TABLES */ colAttributeTables,
	/*        STMT_TYPE_COLUMNS */ colAttributeColumns,
	/*     STMT_TYPE_STATISTICS */ colAttributeStatistics,
	/* STMT_TYPE_SPECIALCOLUMNS */ colAttributeSpecialColumns,
	/*       STMT_TYPE_TYPEINFO */ colAttributeTypeInfo,
	/*    STMT_TYPE_PRIMARYKEYS */ colAttributePrimaryKeys,
	/*    STMT_TYPE_FOREIGNKEYS */ colAttributeForeignKeys
};

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\catalog.cpp ===
/***************************************************************************/
/* CATALOG.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"


/***************************************************************************/

RETCODE SQL_API SQLTables (
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName,
    UCHAR FAR *szTableType,
    SWORD     cbTableType)
{
    LPSTMT  lpstmt;
    SWORD   err;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im (lpstmt, "SQLTables");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }


    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }


	// There are four different operations you may perform through SQLTables, they are :
	// (1) enumerate types
	// (2) enumerate qualifiers
	// (3) enumerate owners
	// (4) enumerate tables

	//[1] Enumerate Types
    /* Is user trying to get a list of table types? */

    if ((TrueSize((LPUSTR)szTableQualifier, cbTableQualifier, 1) == 0) &&
        (TrueSize((LPUSTR)szTableOwner, cbTableOwner, 1) == 0) &&
        (TrueSize((LPUSTR)szTableName, cbTableName, MAX_TABLE_NAME_LENGTH) == 0) &&
        ((szTableType != NULL) &&
         (cbTableType != SQL_NULL_DATA) &&
		 (cbTableType != 0) &&
         (*szTableType == '%') &&
         ((cbTableType == 1) ||
          ((cbTableType == SQL_NTS) && (szTableType[1] == '\0')))))
	{
        /* Set sub-flag to indicate this */
        lpstmt->fStmtSubtype = STMT_SUBTYPE_TABLES_TYPES;

        /* So far no table types have been returned */
        lpstmt->irow = BEFORE_FIRST_ROW;
    }
    else if ((TrueSize((LPUSTR)szTableOwner, cbTableOwner, 1) == 0) &&
			(TrueSize((LPUSTR)szTableName, cbTableName, MAX_TABLE_NAME_LENGTH) == 0) &&
//			(TrueSize((char*)szTableType, cbTableType, 1) == 0) &&
			(TrueSize((LPUSTR)szTableQualifier, cbTableQualifier, 1) != 0) &&
			((*szTableQualifier == '%') || (szTableQualifier[1] == '\0')) &&
			((cbTableQualifier	== 1 ) || (cbTableQualifier == SQL_NTS)))
	{
		//[2] Enumerating Qualifiers

		/* Set sub-flag to indicate this */
		lpstmt->fStmtSubtype = STMT_SUBTYPE_TABLES_QUALIFIERS;

		err = ISAMGetQualifierList(lpstmt->lpdbc->lpISAM, &(lpstmt->lpISAMQualifierList));


		if (err != NO_ISAM_ERR)
		{
            lpstmt->lpISAMQualifierList = NULL;
            lpstmt->errcode = err;
            ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
            return SQL_ERROR;
        }

        // So far no tables returned
        lpstmt->irow = BEFORE_FIRST_ROW;
		lstrcpy((char*)lpstmt->szQualifierName, "");
	}
	else if ((TrueSize((LPUSTR)szTableName, cbTableName, MAX_TABLE_NAME_LENGTH) == 0) &&
			(TrueSize((LPUSTR)szTableType, cbTableType, 1) == 0) &&
			(TrueSize((LPUSTR)szTableQualifier, cbTableQualifier, 1) == 0) &&
			(TrueSize((LPUSTR)szTableOwner, cbTableOwner, 1) != 0) &&
			(*szTableOwner == '%') &&
			((cbTableOwner == 1) ||
			((cbTableOwner == SQL_NTS) && (szTableOwner[1] == '\0'))))

	{
		//[3] Enumerating Owners

		/* Set sub-flag to indicate this */
		lpstmt->fStmtSubtype = STMT_SUBTYPE_TABLES_OWNERS;

        // So far no tables returned
        lpstmt->irow = BEFORE_FIRST_ROW;

	}
	else
	{

		//[4] Enumerating Tables

        /* No.  Figure out how long szTableName really is */
        cbTableName = (SWORD) TrueSize((LPUSTR)szTableName, cbTableName,
                     MAX_TABLE_NAME_LENGTH);


		/* No.  Figure out how long szTableQualifier really is */
		cbTableQualifier = (SWORD) TrueSize((LPUSTR)szTableQualifier, cbTableQualifier,
                     MAX_QUALIFIER_NAME_LENGTH);

		LPCSTR szConstqualifier = (char*)szTableQualifier;

		//If no table qualifier is specified then use the 'current' database
		if (!cbTableQualifier)
		{
			szConstqualifier = (char*) lpstmt->lpdbc->lpISAM->szDatabase;

			cbTableQualifier = (SWORD) TrueSize((LPUSTR)szConstqualifier, SQL_NTS,
                     MAX_QUALIFIER_NAME_LENGTH);
		}

		/* No.  Figure out how long szTableType really is */
		if ( (cbTableType == SQL_NTS) && szTableType)
		{
			cbTableType = (SWORD) lstrlen ((char*)szTableType);
		}

		//if a table type is specified check that we are asking for TABLE or SYSTEM TABLE
		BOOL fWantTables = TRUE;
		BOOL fWantSysTables = FALSE;

		char* lpTempy = (char*)szTableType;
		if (cbTableType && lpTempy && lstrlen(lpTempy))
		{
			//Find out what permuations of table types you require
			fWantSysTables = PatternMatch(TRUE, (LPUSTR)szTableType, cbTableType, (LPUSTR)"%SYSTEM%TABLE%", SQL_NTS, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM));

			if (fWantSysTables)
			{
				//We want SYSTEM TABLE. Check if we also want TABLE
				if ( PatternMatch(TRUE, (LPUSTR)szTableType, cbTableType, (LPUSTR)"%TABLE%,%SYSTEM%TABLE%", SQL_NTS, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM)) ||
				     PatternMatch(TRUE, (LPUSTR)szTableType, cbTableType, (LPUSTR)"%SYSTEM%TABLE%,%TABLE%", SQL_NTS, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM)) )
						fWantTables = TRUE;
				else
						fWantTables = FALSE;
			}
			else
			{
				//We don't want SYSTEM TABLE. Check if we want TABLE
				fWantTables = PatternMatch(TRUE, (LPUSTR)szTableType, cbTableType, (LPUSTR)"%TABLE%", SQL_NTS, ISAMCaseSensitive(lpstmt->lpdbc->lpISAM));
			}
		}
	
		//If we don't want SYSTEM TABLE and TABLE then we don't want any tables
		BOOL fEmptyReq = ( (!fWantTables) && (!fWantSysTables)) ? TRUE :FALSE;

		/* Get list of tables to return (return all tables if no name given)*/
		if (cbTableName == 0)
			err = ISAMGetTableList(lpstmt->lpdbc->lpISAM,
					 (LPUSTR) "%", 1, (LPUSTR)szConstqualifier, cbTableQualifier,
					 &(lpstmt->lpISAMTableList), fWantSysTables, fEmptyReq);
		else
			err = ISAMGetTableList(lpstmt->lpdbc->lpISAM,
					 (LPUSTR)szTableName, cbTableName, 
					 (LPUSTR)szConstqualifier, cbTableQualifier,
					 &(lpstmt->lpISAMTableList), fWantSysTables, fEmptyReq);

		if (err != NO_ISAM_ERR)
		{
            lpstmt->lpISAMTableList = NULL;
            lpstmt->errcode = err;
            ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)
				lpstmt->szISAMError);
            return SQL_ERROR;
        }
	if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            lpstmt->fISAMTxnStarted = TRUE;

        /* Set sub-flag to indicate this */
        lpstmt->fStmtSubtype = STMT_SUBTYPE_TABLES_TABLES;

        /* So far no tables returned */
        lpstmt->irow = BEFORE_FIRST_ROW;
        s_lstrcpy((char*)lpstmt->szTableName, "");
    }

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_TABLES;

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLColumns(
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName,
    UCHAR FAR *szColumnName,
    SWORD     cbColumnName)
{
    LPSTMT  lpstmt;
    SWORD   err;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im(lpstmt, "SQLColumns");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Figure out how long szTableName really is */
    cbTableName = (SWORD) TrueSize((LPUSTR)szTableName, cbTableName,
                                   MAX_TABLE_NAME_LENGTH);

	/* Figure out how long szTableQualifier really is */
    cbTableQualifier = (SWORD) TrueSize((LPUSTR)szTableQualifier, cbTableQualifier,
                                   MAX_QUALIFIER_NAME_LENGTH);

	LPCSTR szConstqualifier = (char*)szTableQualifier;

	//If no table qualifier is specified then use the 'current' database
	if (!cbTableQualifier)
	{
		szConstqualifier = (char*) lpstmt->lpdbc->lpISAM->szDatabase;

		cbTableQualifier = (SWORD) TrueSize((LPUSTR)szConstqualifier, SQL_NTS,
                 MAX_QUALIFIER_NAME_LENGTH);
	}

    /* Get list of tables to return (return all tables if no name given) */
    if (cbTableName == 0)
        err = ISAMGetTableList(lpstmt->lpdbc->lpISAM,
                     (LPUSTR) "%", 1, (LPUSTR)szConstqualifier, cbTableQualifier,
					 &(lpstmt->lpISAMTableList));
    else
        err = ISAMGetTableList(lpstmt->lpdbc->lpISAM,
                     (LPUSTR)szTableName, cbTableName, 
					 (LPUSTR)szConstqualifier, cbTableQualifier,
					 &(lpstmt->lpISAMTableList));
    if (err != NO_ISAM_ERR) {
        lpstmt->lpISAMTableList = NULL;
        lpstmt->errcode = err;
        ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
        return SQL_ERROR;
    }
    if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
        lpstmt->fISAMTxnStarted = TRUE;

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_COLUMNS;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;

    /* Figure out how long szColumnName really is */
    cbColumnName = (SWORD) TrueSize((LPUSTR)szColumnName, cbColumnName,
                           MAX_COLUMN_NAME_LENGTH);

    /* Save column name template (return all columns if no name given) */
    if (cbColumnName != 0) {
        _fmemcpy(lpstmt->szColumnName, szColumnName, cbColumnName);
        lpstmt->szColumnName[cbColumnName] = '\0';
    }
    else {
        s_lstrcpy((char*)lpstmt->szColumnName, "%");
    }

    /* So far no columns returned */
    s_lstrcpy((char*)lpstmt->szTableName, "");
    lpstmt->lpISAMTableDef = NULL;
    lpstmt->irow = BEFORE_FIRST_ROW;

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLStatistics(
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName,
    UWORD     fUnique,
    UWORD     fAccuracy)
{
/*
	//This function is not supported in OLE MS Driver
	LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
*/

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    LPSTMT  lpstmt;
    UCHAR szTable[MAX_TABLE_NAME_LENGTH+1];

    // Get statement handle 
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im (lpstmt, "SQLStatistics");

    // Error if in the middle of a statement already 
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    // Free previously prepared statement if any 
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    // Set type of table 
    lpstmt->fStmtType = STMT_TYPE_STATISTICS;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;

	
    // Figure out how long szTableName really is 
    cbTableName = (SWORD) TrueSize((LPUSTR)szTableName, cbTableName,
                         MAX_TABLE_NAME_LENGTH);

	/* Figure out how long szTableQualifier really is */
	cbTableQualifier = (SWORD) TrueSize((LPUSTR)szTableQualifier, cbTableQualifier,
                    MAX_QUALIFIER_NAME_LENGTH);

	LPSTR szConstqualifier = (char*)szTableQualifier;

	//If no table qualifier is specified then use the 'current' database
	if (!cbTableQualifier)
	{
		szConstqualifier = (char*) lpstmt->lpdbc->lpISAM->szDatabase;

		cbTableQualifier = (SWORD) TrueSize((LPUSTR)szConstqualifier, SQL_NTS,
                 MAX_QUALIFIER_NAME_LENGTH);
	}


    // Open table ofinterst 
    _fmemcpy(szTable, szTableName, cbTableName);
    szTable[cbTableName] = '\0';
    if (ISAMOpenTable(lpstmt->lpdbc->lpISAM, 
		(LPUSTR)szConstqualifier, cbTableQualifier,
		(LPUSTR)szTable, TRUE, &(lpstmt->lpISAMTableDef)) != NO_ISAM_ERR)
        lpstmt->lpISAMTableDef = NULL;
    else if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
        lpstmt->fISAMTxnStarted = TRUE;

    // So far no statistics returned
    s_lstrcpy((char*)lpstmt->szTableName, "");
    lpstmt->irow = BEFORE_FIRST_ROW;

    // Count of rows is not available
    lpstmt->cRowCount = -1;

    // So far no column read 
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLTablePrivileges(
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLColumnPrivileges(
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName,
    UCHAR FAR *szColumnName,
    SWORD     cbColumnName)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLSpecialColumns(
    HSTMT     hstmt,
    UWORD     fColType,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName,
    UWORD     fScope,
    UWORD     fNullable)
{
    LPSTMT  lpstmt;
    UCHAR szTable[MAX_TABLE_NAME_LENGTH+1];

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im(lpstmt, "SQLSpecialColumns");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_SPECIALCOLUMNS;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
    
    /* What kind of special columns? */
    switch (fColType) {
    case SQL_ROWVER:
        /* Auto update columns (there are none) */
        lpstmt->lpISAMTableDef = NULL;
        break;

    case SQL_BEST_ROWID:
        /* Key columns for row.  Figure out how long szTableName really is */
        cbTableName = (SWORD) TrueSize((LPUSTR)szTableName, cbTableName,
                         MAX_TABLE_NAME_LENGTH);

        /* Open table of interst */
        _fmemcpy(szTable, szTableName, cbTableName);
        szTable[cbTableName] = '\0';
        if (ISAMOpenTable(lpstmt->lpdbc->lpISAM, 
						(LPUSTR)szTableQualifier, cbTableQualifier,
						(LPUSTR)szTable, TRUE,
                        &(lpstmt->lpISAMTableDef)) != NO_ISAM_ERR)
            lpstmt->lpISAMTableDef = NULL;
        else if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            lpstmt->fISAMTxnStarted = TRUE;
        break;

    default:
        lpstmt->errcode = ERR_NOTSUPPORTED;
        return SQL_ERROR;
    }

    /* So far no columns returned */
    s_lstrcpy((char*)lpstmt->szTableName, "");
    lpstmt->irow = BEFORE_FIRST_ROW;

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLPrimaryKeys(
    HSTMT     hstmt,
    UCHAR FAR *szTableQualifier,
    SWORD     cbTableQualifier,
    UCHAR FAR *szTableOwner,
    SWORD     cbTableOwner,
    UCHAR FAR *szTableName,
    SWORD     cbTableName)
{
    LPSTMT  lpstmt;
    UCHAR szTable[MAX_TABLE_NAME_LENGTH+1];

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	MyImpersonator im (lpstmt, "SQLPrimaryKeys");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_PRIMARYKEYS;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
    
    /* Figure out how long szTableName really is */
    cbTableName = (SWORD) TrueSize(szTableName, cbTableName,
                         MAX_TABLE_NAME_LENGTH);

    /* Open table of interst */
    _fmemcpy(szTable, szTableName, cbTableName);
    szTable[cbTableName] = '\0';
    if (ISAMOpenTable(lpstmt->lpdbc->lpISAM, 
                        (LPUSTR)szTableQualifier, cbTableQualifier,
                        (LPUSTR) szTable, TRUE,
                        &(lpstmt->lpISAMTableDef)) != NO_ISAM_ERR)
        lpstmt->lpISAMTableDef = NULL;
    else if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
        lpstmt->fISAMTxnStarted = TRUE;

    /* So far no columns returned */
    s_lstrcpy(lpstmt->szTableName, "");
    lpstmt->irow = BEFORE_FIRST_ROW;

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLForeignKeys(
    HSTMT     hstmt,
    UCHAR FAR *szPkTableQualifier,
    SWORD     cbPkTableQualifier,
    UCHAR FAR *szPkTableOwner,
    SWORD     cbPkTableOwner,
    UCHAR FAR *szPkTableName,
    SWORD     cbPkTableName,
    UCHAR FAR *szFkTableQualifier,
    SWORD     cbFkTableQualifier,
    UCHAR FAR *szFkTableOwner,
    SWORD     cbFkTableOwner,
    UCHAR FAR *szFkTableName,
    SWORD     cbFkTableName)
{
    LPSTMT  lpstmt;
    SWORD   err;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;


	MyImpersonator im (lpstmt, "SQLForeignKeys");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Figure out how long szPkTableName and szFkTableName really are */
    cbPkTableName = (SWORD) TrueSize(szPkTableName, cbPkTableName,
                     MAX_TABLE_NAME_LENGTH);
    cbFkTableName = (SWORD) TrueSize(szFkTableName, cbFkTableName,
                     MAX_TABLE_NAME_LENGTH);

    /* Save the tablenames */
    _fmemcpy(lpstmt->szPkTableName, szPkTableName, cbPkTableName);
    lpstmt->szPkTableName[cbPkTableName] = '\0';
    _fmemcpy(lpstmt->szTableName, szFkTableName, cbFkTableName);
    lpstmt->szTableName[cbFkTableName] = '\0';


	LPCSTR szConstqualifier = (char*)szPkTableQualifier;

	//If no table qualifier is specified then use the 'current' database
	if (!cbPkTableQualifier)
	{
		szConstqualifier = (char*) lpstmt->lpdbc->lpISAM->szDatabase;

		cbFkTableQualifier = (SWORD) TrueSize((LPUSTR)szConstqualifier, SQL_NTS,
                 MAX_QUALIFIER_NAME_LENGTH);
	}


    /* Get table list if need be */
    if ((cbPkTableName == 0) || (cbFkTableName == 0)) {
        err = ISAMGetTableList(lpstmt->lpdbc->lpISAM,
                     (LPUSTR) "%", 1, 
		     (LPUSTR)szConstqualifier, cbFkTableQualifier,
                     &(lpstmt->lpISAMTableList));
        if (err != NO_ISAM_ERR) {
            lpstmt->lpISAMTableList = NULL;
            lpstmt->errcode = err;
            ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
            return SQL_ERROR;
        }
        if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            lpstmt->fISAMTxnStarted = TRUE;
    }

    /* So far no primary keys returned */
    lpstmt->irow = BEFORE_FIRST_ROW;

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_FOREIGNKEYS;
    if (cbPkTableName != 0) {
        if (cbFkTableName != 0) 
            lpstmt->fStmtSubtype = STMT_SUBTYPE_FOREIGNKEYS_SINGLE;
        else
            lpstmt->fStmtSubtype = STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_FK_TABLES;
    }
    else {
        lpstmt->fStmtSubtype = STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_PK_TABLES;
    }

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLProcedures(
    HSTMT     hstmt,
    UCHAR FAR *szProcQualifier,
    SWORD     cbProcQualifier,
    UCHAR FAR *szProcOwner,
    SWORD     cbProcOwner,
    UCHAR FAR *szProcName,
    SWORD     cbProcName)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLProcedureColumns(
    HSTMT     hstmt,
    UCHAR FAR *szProcQualifier,
    SWORD     cbProcQualifier,
    UCHAR FAR *szProcOwner,
    SWORD     cbProcOwner,
    UCHAR FAR *szProcName,
    SWORD     cbProcName,
    UCHAR FAR *szColumnName,
    SWORD     cbColumnName)
{
    LPSTMT  lpstmt;

    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\conndlg.cpp ===
// conndlg.cpp : implementation file
//

// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "afxtempl.h"

#include <comdef.h>  //for _bstr_t

#include "resource.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include  "drdbdr.h"

#include "Browse.h"

#include "dlgcback.h"

#include "cominit.h" //for Dcom blanket

#include "htmlhelp.h" //for HELP

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectionDialog dialog


HTREEITEM CConnectionDialog :: InsertItem (CTreeCtrl &treeCtrl,
										   HTREEITEM hParentTreeItem,
										   const char *namespaceName)
{
	TV_INSERTSTRUCT newItem;
	newItem.item.mask = TVIF_TEXT | TVIF_IMAGE	| TVIF_SELECTEDIMAGE | TVIF_PARAM;
	newItem.hParent = hParentTreeItem;
	char *name = new char [strlen (namespaceName) + 1];
	name[0] = 0;
	lstrcpy (name, namespaceName);
	newItem.item.pszText = name;
//	newItem.item.cchTextMax = strlen (namespaceName) + 1;
	//get parent name and prepend to name to generate absolute name
	char *absName = NULL;
	if (hParentTreeItem == TVI_ROOT)
	{
		absName = new char [strlen (namespaceName) + 1];
		absName[0] = 0;
		lstrcpy (absName, namespaceName);
	}
	else
	{
		ISAMTreeItemData* parentData = 
						(ISAMTreeItemData*)treeCtrl.GetItemData (hParentTreeItem);
		absName = new char [strlen (namespaceName) + strlen (parentData->absName) + 2 + 1];
		absName[0] = 0;
		strcpy (absName, parentData->absName);
		strcat (absName, "\\");
		strcat (absName, namespaceName);
	}

	newItem.item.iImage = newItem.item.iSelectedImage = m_idxMode1Image;

	ISAMTreeItemData *itemData = new ISAMTreeItemData;
	itemData->absName = absName;
	itemData->pszText = name; //this copy will be deleted
	itemData->included = FALSE;
	itemData->childInclude = 0;
	itemData->childChildInclude = 0;

	//Add to list for quick cleanup
	if (pCurrentSelectionList)
	{
		pCurrentItem->pNext = itemData;
		pCurrentItem = itemData;	
	}
	else
	{
		pCurrentSelectionList = itemData;
		pCurrentItem = itemData;	
	}

	newItem.item.lParam = (DWORD)itemData;
	return treeCtrl.InsertItem (&newItem);
}

int CConnectionDialog :: FindAbsName (char *name,
										HTREEITEM hStartAt, 
										HTREEITEM& hFoundItem)
{
	if (!name) 
		return FALSE;
	{
		ISAMTreeItemData *pItemData = (ISAMTreeItemData*)m_tree1.GetItemData (hStartAt);
		if (pItemData && pItemData->absName &&
				!_stricmp (name, pItemData->absName))
		{
			hFoundItem = hStartAt;
			return TRUE;
		}
		else
		{
  			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hStartAt))
			{
				if (FindAbsName (name, firstChild, hFoundItem))
					return TRUE;
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
				{
					if (FindAbsName (name, nextSibling, hFoundItem))
						return TRUE;
				}
			}
			return FALSE;
		}
	}
}

int CConnectionDialog :: CreateNamespace (char *name,
										HTREEITEM hStartAt, 
										HTREEITEM& hFoundItem)
{
	hFoundItem = NULL;

	//If we are to create the namespace in the tree control
	//we need to do it relative to its parent namespace
	//The first step therefore is to get a handle to its parent

	//We work out the name of the parent namespace

	//Start at the end of the string and work your way
	//back until you reach a backslash character or
	//you run out of string
	long len = lstrlen(name);

	//Note: a namespace cannot end with a backslash 
	//so we check for this error condition
	long index = len - 1;
	if (name[index] == '\\')
		return FALSE;

	while (index && (name[index] != '\\'))
		index--;

	//We have either run out of string or found a backslash
	if (!index)
	{
		//We have run out of string
		return FALSE;
	}
	else
	{
		name[index] = 0;
		char* parent = name;
		char* child = parent + index + 1;

		//Get Parent 
		HTREEITEM hParent;
		if (! FindAbsName(parent, hStartAt, hParent))
		{
			// Could not get parent, so create it
			CreateNamespace (parent, hStartAt, hParent);
		}

		if (hParent)
		{
			//Found parent, so now create child
			hFoundItem = InsertItem(m_tree1,hParent, (const char*)child);
		}
	}

	return TRUE;
}

int CConnectionDialog :: UnincludedChild (HTREEITEM hStartAt, int checkSelf)
{				 
	if (checkSelf && !(((ISAMTreeItemData*)m_tree1.GetItemData (hStartAt))->included))
	{
		return TRUE;
	}
	else
	{
   		HTREEITEM firstChild = NULL;
		if (firstChild = m_tree1.GetChildItem (hStartAt))
		{
			if (UnincludedChild (firstChild, TRUE))
				return TRUE;
			HTREEITEM nextSibling = firstChild;
			while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
			{
				if (UnincludedChild (nextSibling, TRUE))
					return TRUE;;
			}
		}
		return FALSE;
	}
}
void CConnectionDialog :: GenerateOutMap (HTREEITEM hStartAt)
{
	ISAMTreeItemData *itemData =  (ISAMTreeItemData*)m_tree1.GetItemData (hStartAt);
	if (itemData->included)
	{
		// if there's an unincluded child add this individually and recurse
		// else add deep and no need to recurse

		if (UnincludedChild (hStartAt, FALSE))
		{
			// get name and add	it shallow and recurse
			pMapStringToObOut->SetAt (itemData->absName,
									  new CNamespace (itemData->absName));
   			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hStartAt))
			{
				GenerateOutMap (firstChild);
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
				{
					GenerateOutMap (nextSibling);
				}
			}
		}
		else
		{
			// get name and add with deep flag (no recurse)
			// for now do same as above ie don't use deep flag
			pMapStringToObOut->SetAt (itemData->absName,
									  new CNamespace (itemData->absName));
			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hStartAt))
			{
				GenerateOutMap (firstChild);
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
				{
					GenerateOutMap (nextSibling);
				}
			}
		}
	}
	else
	{
		// just recurse
		HTREEITEM firstChild = NULL;
		if (firstChild = m_tree1.GetChildItem (hStartAt))
		{
			GenerateOutMap (firstChild);
			HTREEITEM nextSibling = firstChild;
			while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
			{
				GenerateOutMap (nextSibling);
			}
		}
	}
}

void CConnectionDialog :: GenerateOutString (HTREEITEM hStartAt)
{
	ISAMTreeItemData *itemData =  (ISAMTreeItemData*)m_tree1.GetItemData (hStartAt);
	if (itemData->included)
	{
		// if there's an unincluded child add this individually and recurse
		// else add deep and no need to recurse

		if (UnincludedChild (hStartAt, FALSE))
		{
			// get name and add	it shallow and recurse
			char *temp = *lpszNamespacesOut;
			if (temp)
			{
				*lpszNamespacesOut = new char [strlen (temp) + 1 + 4 /* for punctuation */
										   + strlen (itemData->absName) +
										   strlen ("shallow")];
				(*lpszNamespacesOut)[0] = 0;
				strcpy (*lpszNamespacesOut, temp);
				strcat (*lpszNamespacesOut, ",");
				strcat (*lpszNamespacesOut, "{");
				strcat (*lpszNamespacesOut, itemData->absName);
				strcat (*lpszNamespacesOut, ",shallow}");
				delete temp;
			}
			else
			{
				*lpszNamespacesOut = new char [strlen (itemData->absName) + 1 + 4 + 
											   strlen ("shallow")];
				(*lpszNamespacesOut)[0] = 0;
				strcpy (*lpszNamespacesOut, "{");
				strcat (*lpszNamespacesOut, itemData->absName);
				strcat (*lpszNamespacesOut, ",shallow}");

			}

   			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hStartAt))
			{
				GenerateOutString (firstChild);
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
				{
					GenerateOutString (nextSibling);
				}
			}
		}
		else
		{
			// get name and add with deep flag (no recurse)
			// for now do same as above ie don't use deep flag
			char *temp = *lpszNamespacesOut;
			if (temp)
			{
				*lpszNamespacesOut = new char [strlen (temp) + 1 + 4 /* for punctuation */
										   + strlen (itemData->absName) +
										   strlen ("deep")];
				(*lpszNamespacesOut)[0] = 0;
				strcpy (*lpszNamespacesOut, temp);
				strcat (*lpszNamespacesOut, ",");
				strcat (*lpszNamespacesOut, "{");
				strcat (*lpszNamespacesOut, itemData->absName);
				strcat (*lpszNamespacesOut, ",deep}");
				delete temp;
			}
			else
			{
				*lpszNamespacesOut = new char [strlen (itemData->absName) + 1 + 4
											 + strlen("deep")];
				(*lpszNamespacesOut)[0] = 0;
				strcpy (*lpszNamespacesOut, "{");
				strcat (*lpszNamespacesOut, itemData->absName);
				strcat (*lpszNamespacesOut, ",deep}");
			}
		}

	}
	else
	{
		// just recurse
		HTREEITEM firstChild = NULL;
		if (firstChild = m_tree1.GetChildItem (hStartAt))
		{
			GenerateOutString (firstChild);
			HTREEITEM nextSibling = firstChild;
			while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
			{
				GenerateOutString (nextSibling);
			}
		}
	}
}

void CConnectionDialog :: UpdateChildChildInclude (HTREEITEM hNode, BOOL fIncrement)
{
	//Get the parent node, so that you can flag that a non-immediate child
	//has been selected
	HTREEITEM hParentNode = m_tree1.GetParentItem(hNode);
	if (hParentNode)
	{
		TV_ITEM tvItem;
		tvItem.hItem = hParentNode;
		tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		if (m_tree1.GetItem (&tvItem))
		{
			ISAMTreeItemData* temp = (ISAMTreeItemData*)tvItem.lParam;
			if (fIncrement)
			{
				++(temp->childChildInclude);

				//update state of parent if no immediate children
				if (0 == temp->childInclude)
				{
					//I can find out the state via the iImage field
					if ( tvItem.iImage == m_idxMode1Image)
					{
						//In state 1, move to state 2
						tvItem.iSelectedImage = tvItem.iImage = m_idxMode2Image;
						m_tree1.SetItem (&tvItem);
					}
					else if ( tvItem.iImage == m_idxMode3Image)
					{
						//In state 3, move to state 4		
						tvItem.iSelectedImage = tvItem.iImage = m_idxMode4Image;
						m_tree1.SetItem (&tvItem);
					}
				}
			}
			else
			{
				--(temp->childChildInclude);

				//update state of parent if no immediate children
				if ((0 == temp->childInclude) && (0 == temp->childChildInclude))
				{
					//I can find out the state via the iImage field
					if ( tvItem.iImage == m_idxMode2Image)
					{
						//In state 2, move to state 1
						tvItem.iSelectedImage = tvItem.iImage = m_idxMode1Image;
						m_tree1.SetItem (&tvItem);
					}
					else if ( tvItem.iImage == m_idxMode4Image)
					{
						//In state 4, move to state 3		
						tvItem.iSelectedImage = tvItem.iImage = m_idxMode3Image;
						m_tree1.SetItem (&tvItem);
					}
				}
			}
		}

		//Recursive call up the chain of parents
		UpdateChildChildInclude(hParentNode, fIncrement);
	}

}

void CConnectionDialog :: AddNamespaces (HTREEITEM hParent,
										  int deep)
{
   	TV_ITEM tvItem;
	tvItem.hItem = hParent;
	tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;
	if (m_tree1.GetItem (&tvItem))
	{
		//If cel not already selected, then select
		if (! ((ISAMTreeItemData*)tvItem.lParam)->included )
		{
			cSelectedCels++;

			//Update count in parent node
			HTREEITEM hParentNode = m_tree1.GetParentItem(hParent);
			if (hParentNode)
			{
				TV_ITEM tvItem2;
				tvItem2.hItem = hParentNode;
				tvItem2.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				if (m_tree1.GetItem (&tvItem2))
				{
					++(((ISAMTreeItemData*)tvItem2.lParam)->childInclude);

					//Parent node must be in either state 1, 2 or 3
					//I can find out the state via the iImage field
					if ( tvItem2.iImage == m_idxMode1Image)
					{
						//In state 1, move to state 2
						//tvItem2.iSelectedImage = tvItem2.iImage = m_idxMode2Image;
						m_tree1.SetItemImage (hParentNode, m_idxMode2Image, m_idxMode2Image);
					}
					else if ( tvItem2.iImage == m_idxMode3Image)
					{
						//In state 3, move to state 4		
						//tvItem2.iSelectedImage = tvItem2.iImage = m_idxMode4Image;
						m_tree1.SetItemImage (hParentNode, m_idxMode4Image, m_idxMode4Image);
					}

					//Now indicate to parents parent that a non-immediate child
					//has been selected
					UpdateChildChildInclude(hParentNode, TRUE);
				}
			}
		}
	
		if (deep)  //recurse
		{
  			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hParent))
			{
				AddNamespaces (firstChild, deep);
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
					AddNamespaces (nextSibling, deep);
			}
		}

		
		m_tree1.GetItem (&tvItem);
		((ISAMTreeItemData*)tvItem.lParam)->included = TRUE;

		//Check if this node has 'included' children
		int children = tvItem.cChildren;
		ISAMTreeItemData* temp = (ISAMTreeItemData*)tvItem.lParam;
		if (children && (temp->childInclude || temp->childChildInclude))
		{
//			tvItem.iSelectedImage = tvItem.iImage = m_idxMode4Image;
			m_tree1.SetItemImage (hParent, m_idxMode4Image, m_idxMode4Image);
		}
		else
		{
//			tvItem.iSelectedImage = tvItem.iImage = m_idxMode3Image;
			m_tree1.SetItemImage (hParent, m_idxMode3Image, m_idxMode3Image);
		}


//		m_tree1.SetItem (&tvItem);
	
	}

	

	//Update state of OK and Cancel pushbutton depending on
	//number of cels selected
	m_okButton.EnableWindow(cSelectedCels ? TRUE : FALSE);
}
																							
void CConnectionDialog :: RemoveNamespaces (HTREEITEM hParent,
											 int deep)
{

   	TV_ITEM tvItem;
	tvItem.hItem = hParent;
	tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN;
	if (m_tree1.GetItem (&tvItem))
	{

		//If cel not unselected, then unselect
		if ( ((ISAMTreeItemData*)tvItem.lParam)->included )
		{
			cSelectedCels--;

			//update state of parent
			HTREEITEM hParentNode = m_tree1.GetParentItem(hParent);
			if (hParentNode)
			{
				TV_ITEM tvItem2;
				tvItem2.hItem = hParentNode;
				tvItem2.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
				if (m_tree1.GetItem (&tvItem2))
				{
					--(((ISAMTreeItemData*)tvItem2.lParam)->childInclude);

					//Parent node must be in either state 2 or 4
					//I can find out the state via the iImage field
					if ( tvItem2.iImage == m_idxMode4Image)
					{
						//In state 4
						if (!((ISAMTreeItemData*)tvItem2.lParam)->childInclude)
						{
							//Check non-immediate children
							if (!((ISAMTreeItemData*)tvItem2.lParam)->childChildInclude)
							{
								//If no more children move to state 3
//								tvItem2.iSelectedImage = tvItem2.iImage = m_idxMode3Image;
////							m_tree1.SetItem (&tvItem2);
								m_tree1.SetItemImage (hParentNode, m_idxMode3Image, m_idxMode3Image);
							}
						}
					}
					else
					{
						//In state 2
						if (!((ISAMTreeItemData*)tvItem2.lParam)->childInclude)
						{
							//Check non-immediate children
							if (!((ISAMTreeItemData*)tvItem2.lParam)->childChildInclude)
							{
								//If no more children move to state 1
//								tvItem2.iSelectedImage = tvItem2.iImage = m_idxMode1Image;
////							m_tree1.SetItem (&tvItem2);
								m_tree1.SetItemImage (hParentNode, m_idxMode1Image, m_idxMode1Image);
							}
						}
					}

					//Now indicate to parents parent that a non-immediate child
					//has been de-selected
					UpdateChildChildInclude(hParentNode, FALSE);
				}
			}
		}

		if (deep)  //recurse
		{
  			HTREEITEM firstChild = NULL;
			if (firstChild = m_tree1.GetChildItem (hParent))
			{
				RemoveNamespaces (firstChild, deep);
				HTREEITEM nextSibling = firstChild;
				while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
					RemoveNamespaces (nextSibling, deep);
			}
		}


		m_tree1.GetItem (&tvItem);
		((ISAMTreeItemData*)tvItem.lParam)->included = FALSE;

		//Check if this node has 'included' children
		int children = tvItem.cChildren;
		ISAMTreeItemData* temp = (ISAMTreeItemData*)tvItem.lParam;
		if (children && (temp->childInclude || temp->childChildInclude))
		{
//			tvItem.iSelectedImage = tvItem.iImage = m_idxMode2Image;
			m_tree1.SetItemImage (hParent, m_idxMode2Image, m_idxMode2Image);
		}
		else
		{
//			tvItem.iSelectedImage = tvItem.iImage = m_idxMode1Image;
			m_tree1.SetItemImage (hParent, m_idxMode1Image, m_idxMode1Image);
		}

////	m_tree1.SetItem (&tvItem);
	}

	

	//Update state of OK and Cancel pushbutton depending on
	//number of cels selected
	m_okButton.EnableWindow(cSelectedCels ? TRUE : FALSE);
}



CConnectionDialog::CConnectionDialog(CWnd* pParent, char *pszServer,
//									 WBEM_LOGIN_AUTHENTICATION loginMethod,
									 char *pszUsername, char *pszPassword,
									 char **pszLocale, char** pszAuthority,
									 BOOL FAR* fSysProp, BOOL fConnParmSpec,
									 CMapStringToOb *pNamespaceMap, 
									 CMapStringToOb *pNamespaceMapOut, 
									 BOOL enableDefaultDatabase, char **connectionString, BOOL FAR* fImpersonate, BOOL FAR* fPassthrghOnly, BOOL FAR* fItprtEmptPwdAsBlk)
	: CDialog(CConnectionDialog::IDD, pParent)
{
	ODBCTRACE(_T("\nWBEM ODBC Driver : CConnectionDialog::CConnectionDialog\n"));
	//{{AFX_DATA_INIT(CConnectionDialog)
	//}}AFX_DATA_INIT
	pMapStringToObOut = pNamespaceMapOut;
	pMapStringToObIn = pNamespaceMap;
//	pServerIn = NULL;
//	pUsernameIn = NULL;
//	pPasswordIn = NULL;
	lpszNamespacesOut = connectionString;
	fDoubleClicked = FALSE;
	fConnParmSpecified = fConnParmSpec;

	//Make copy of Server, UserName and Password memory addresses
	lpszServer = pszServer;
	lpszUserName = pszUsername;
	lpszPassword = pszPassword;

	
	lpszAuthority = NULL;
	lpszLocale = NULL;
	lpszAuthorityOut = pszAuthority;
	lpszLocaleOut = pszLocale;

	if (pszLocale && *pszLocale)
	{
		int localeLen = lstrlen(*pszLocale);
		lpszLocale = new char [localeLen + 1];
		lpszLocale[0] = 0;
		lstrcpy(lpszLocale, *pszLocale);
	}

	if (pszAuthority && *pszAuthority)
	{
		int authLen = lstrlen(*pszAuthority);
		lpszAuthority = new char [authLen + 1];
		lpszAuthority[0] = 0;
		lstrcpy(lpszAuthority, *pszAuthority);
		ODBCTRACE(_T("\nWBEM ODBC Driver : Authority :"));
		ODBCTRACE(_T(lpszAuthority));
		ODBCTRACE(_T("\n"));
	}

//	m_loginMethod = loginMethod;


	//A counter to indicated number of selected namespace cels
	cSelectedCels = 0;

	*connectionString = NULL;

	//Setup System Properties
	fSystemProperties = fSysProp;
	
//	if (pszUsername)
//	{
//		pUsernameIn = new char [strlen (pszUsername) + 1];
//		pUsernameIn[0] = 0;
//		strcpy (pUsernameIn, pszUsername);
//	}
//	if (pszPassword)
//	{
//		pPasswordIn = new char [strlen (pszPassword) + 1];
//		pPasswordIn[0] = 0;
//		strcpy (pPasswordIn, pszPassword);
//	}

	fImpersonation = fImpersonate;
	fPassthroughOnly = fPassthrghOnly;
	fIntpretEmptPwdAsBlank = fItprtEmptPwdAsBlk;

	impersonateMgr = NULL;

 
	if (*fImpersonation)
	{
		//Now check if impersonation is necessary
		//only if connecting locally
		if (IsLocalServer(lpszServer))
		{
			impersonateMgr = new ImpersonationManager(lpszUserName, lpszPassword, lpszAuthority);
		}
		else
		{
			ODBCTRACE("\nWBEM ODBC Driver : Server not detected as local, not impersonating\n");
		}
	}
}


CConnectionDialog :: ~CConnectionDialog()
{
	ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog :: ~CConnectionDialog\n");
	//Tidy Up

//	if (pUsernameIn)
//		delete pUsernameIn;

//	if (pPasswordIn)
//		delete pPasswordIn;

	delete impersonateMgr;
	ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog :: ~CConnectionDialog exit point\n");
}

void CConnectionDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectionDialog)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectionDialog, CDialog)
	//{{AFX_MSG_MAP(CConnectionDialog)
	ON_NOTIFY(NM_CLICK, IDC_TREE1, OnClickTree1)
	ON_NOTIFY(TVN_KEYDOWN, IDC_TREE1, OnKeyDown)
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_TREE1, OnTreeExpand)
	ON_NOTIFY(TVN_DELETEITEM, IDC_TREE1, OnDeleteitemTree1)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(IDC_CHECK1, OnButtonSysProp)
	ON_BN_CLICKED(IDC_CHECK_IMPERSONATE, OnButtonImpersonation)
	ON_BN_CLICKED(IDC_CHECK_PASSTHROUGHONLY, OnButtonPassthroughOnly)
	ON_NOTIFY(NM_DBLCLK, IDC_TREE1, OnDblclkTree1)
	ON_EN_KILLFOCUS(IDC_BROWSE_EDIT, OnKillfocusBrowseEdit)
	ON_EN_CHANGE(IDC_EDIT_USER_NAME, OnUserNameChange)
	ON_EN_CHANGE(IDC_EDIT_PSWD, OnPasswordChange)
	ON_EN_CHANGE(IDC_EDIT_AUTH, OnAuthorityChange)
	ON_EN_CHANGE(IDC_EDIT_LOCALE, OnLocaleChange)
	ON_EN_CHANGE(IDC_BROWSE_EDIT, OnServerChange)
	ON_BN_CLICKED(IDC_REFRESH_BUTTON, OnButtonRefresh)
	ON_BN_CLICKED(IDC_HELP_BUTTON, OnHelp)
	ON_BN_CLICKED(IDC_RADIO_BLANK, OnButtonInterpretEmpty)
	ON_BN_CLICKED(IDC_RADIO_NULL, OnButtonInterpretEmpty)
	ON_WM_NCDESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CConnectionDialog message handlers

void CConnectionDialog::OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult) 
{
	TV_KEYDOWN* lParam = (TV_KEYDOWN*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;

	//Check if SPACE BAR is pressed
	if (lParam->wVKey == VK_SPACE)
	{
		HTREEITEM item = m_tree1.GetSelectedItem();

		//Grab the WM_CHAR message from the message queue
		MSG myMessage;
		BOOL status = GetMessage(&myMessage, lParam->hdr.hwndFrom, WM_CHAR, WM_CHAR);

		if (item)
		{
			//Get the item 
			TV_ITEM tvItem;
			tvItem.hItem = item;
			tvItem.mask = TVIF_STATE | TVIF_PARAM;
			if (m_tree1.GetItem (&tvItem))
			{
				//Check if item is expanded, if not we add/remove in 'deep' mode
				BOOL fDeepMode = (tvItem.state & TVIS_EXPANDED) ? FALSE : TRUE;

				//If the item is 'included' we remove
				//If the item is not 'included' we add
				if ( ((ISAMTreeItemData*)tvItem.lParam)->included )
				{
					RemoveNamespaces(item, fDeepMode);
				}
				else
				{

					BeginWaitCursor();

					BOOL itemSelected = ((ISAMTreeItemData*)tvItem.lParam)->included;
					
					BOOL fChildrenChecked = FALSE;

					//Get immediate child items and expand them to 1 level only
					//Note: Remember to check if it has already been expanded
					HTREEITEM firstChild = NULL;
					if (firstChild = m_tree1.GetChildItem (item))
					{
						//Get absolute name for this item
						TV_ITEM tvItem2;
						tvItem2.hItem = firstChild;
						tvItem2.mask = TVIF_PARAM;
						if (m_tree1.GetItem (&tvItem2))
						{

							//Check if this node has already been checked for children
							fChildrenChecked = ((ISAMTreeItemData*)tvItem2.lParam)->fExpanded;
		
							if (!fChildrenChecked)
							{
								char* txt = ((ISAMTreeItemData*)tvItem2.lParam)->absName;

								ISAMBuildTreeChildren (firstChild,
													 txt,
													 m_tree1,
													 *this,
													 lpszServer,
	//													 m_loginMethod,
													 lpszUserName,
													 lpszPassword,
													 *fIntpretEmptPwdAsBlank,
													 lpszLocale,
													 lpszAuthority,
													  ! itemSelected);
							}
						}

						HTREEITEM nextSibling = firstChild;
						while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
						{
							TV_ITEM tvItem3;
							tvItem3.hItem = nextSibling;
							tvItem3.mask = TVIF_PARAM;
							if (m_tree1.GetItem (&tvItem3))
							{

								//Check if this node has already been checked for children
								fChildrenChecked = ((ISAMTreeItemData*)tvItem3.lParam)->fExpanded;

								if (!fChildrenChecked)
								{
									char* txt = ((ISAMTreeItemData*)tvItem3.lParam)->absName;

									ISAMBuildTreeChildren (nextSibling,
															 txt,
															 m_tree1,
															 *this,
															 lpszServer,
	//															 m_loginMethod,
															 lpszUserName,
															 lpszPassword,
															 *fIntpretEmptPwdAsBlank,
															 lpszLocale,
															 lpszAuthority,
															 ! itemSelected);
								}
							}
						}
					}

					AddNamespaces (item, fDeepMode);

					EndWaitCursor();
				}
			}
		}

	}
}

void CConnectionDialog::OnTreeExpand(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* lParam = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;

	TV_ITEM tvItem = lParam->itemNew;
	UINT action  = lParam->action;
	HTREEITEM item = tvItem.hItem;

	//Check if item is expanded, if not we add/remove in 'deep' mode
	BOOL fExpanding = (action == TVE_EXPAND) ? TRUE : FALSE;

	if (!fExpanding)
		return;

	BeginWaitCursor();

	char* txt = ((ISAMTreeItemData*)tvItem.lParam)->pszText;
	BOOL fChildrenChecked = FALSE;

	//Get immediate child items and expand them to 1 level only
	//Note: Remember to check if it has already been expanded
	HTREEITEM firstChild = NULL;
	if (firstChild = m_tree1.GetChildItem (item))
	{
		//Get absolute name for this item
		TV_ITEM tvItem2;
		tvItem2.hItem = firstChild;
		tvItem2.mask = TVIF_PARAM;
		if (m_tree1.GetItem (&tvItem2))
		{

			//Check if this node has already been checked for children
			fChildrenChecked = ((ISAMTreeItemData*)tvItem2.lParam)->fExpanded;

			if (!fChildrenChecked)
			{
				txt = ((ISAMTreeItemData*)tvItem2.lParam)->absName;

				ISAMBuildTreeChildren (firstChild,
									 txt,
									 m_tree1,
									 *this,
									 lpszServer,
//												 m_loginMethod,
									 lpszUserName,
									 lpszPassword,
									 *fIntpretEmptPwdAsBlank,
									 lpszLocale,
									 lpszAuthority,
									 FALSE);
			}
		}

		HTREEITEM nextSibling = firstChild;
		while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
		{
			TV_ITEM tvItem3;
			tvItem3.hItem = nextSibling;
			tvItem3.mask = TVIF_PARAM;
			if (m_tree1.GetItem (&tvItem3))
			{

				//Check if this node has already been checked for children
				fChildrenChecked = ((ISAMTreeItemData*)tvItem3.lParam)->fExpanded;

				if (!fChildrenChecked)
				{
					txt = ((ISAMTreeItemData*)tvItem3.lParam)->absName;

					ISAMBuildTreeChildren (nextSibling,
											 txt,
											 m_tree1,
											 *this,
											 lpszServer,
//														 m_loginMethod,
											 lpszUserName,
											 lpszPassword,
											 *fIntpretEmptPwdAsBlank,
											 lpszLocale,
											 lpszAuthority,
											 FALSE);
				}
			}
		}
	}

	EndWaitCursor();

}

void CConnectionDialog::OnClickTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	*pResult = 0;

	//Check if you double-clicked
//	if (fDoubleClicked)
//	{
//		fDoubleClicked = FALSE;
//		return;
//	}

	fDoubleClicked = FALSE;

	//Get current position of mouse cursor and perform
	//a hit test on the tree control
	POINT cursorPos;
	GetCursorPos(&cursorPos);

	m_tree1.ScreenToClient(&cursorPos);

	UINT fFlags = 0;
	HTREEITEM item = m_tree1.HitTest(cursorPos, &fFlags);

	if (fFlags & TVHT_ONITEMICON)
	{
		//Support for mouse operation to 'check' the node checkbox
		if (item)
		{
			//Get the item 
			TV_ITEM tvItem;
			tvItem.hItem = item;
			tvItem.mask = TVIF_STATE | TVIF_PARAM;
			if (m_tree1.GetItem (&tvItem))
			{
				//Check if item is expanded, if not we add/remove in 'deep' mode
				BOOL fDeepMode = (tvItem.state & TVIS_EXPANDED) ? FALSE : TRUE;

				//If the item is 'included' we remove
				//If the item is not 'included' we add
				if ( ((ISAMTreeItemData*)tvItem.lParam)->included )
				{
					RemoveNamespaces(item, fDeepMode);
				}
				else
				{

					BeginWaitCursor();

					BOOL itemSelected = ((ISAMTreeItemData*)tvItem.lParam)->included;
					
					BOOL fChildrenChecked = FALSE;

					//Get immediate child items and expand them to 1 level only
					//Note: Remember to check if it has already been expanded
					HTREEITEM firstChild = NULL;
					if (firstChild = m_tree1.GetChildItem (item))
					{
						//Get absolute name for this item
						TV_ITEM tvItem2;
						tvItem2.hItem = firstChild;
						tvItem2.mask = TVIF_PARAM;
						if (m_tree1.GetItem (&tvItem2))
						{

							//Check if this node has already been checked for children
							fChildrenChecked = ((ISAMTreeItemData*)tvItem2.lParam)->fExpanded;
		
							if (!fChildrenChecked)
							{
								char* txt = ((ISAMTreeItemData*)tvItem2.lParam)->absName;

								ISAMBuildTreeChildren (firstChild,
													 txt,
													 m_tree1,
													 *this,
													 lpszServer,
//													 m_loginMethod,
													 lpszUserName,
													 lpszPassword,
													 *fIntpretEmptPwdAsBlank,
													 lpszLocale,
													 lpszAuthority,
													  ! itemSelected);
							}
						}

						HTREEITEM nextSibling = firstChild;
						while (nextSibling = m_tree1.GetNextItem (nextSibling, TVGN_NEXT))
						{
							TV_ITEM tvItem3;
							tvItem3.hItem = nextSibling;
							tvItem3.mask = TVIF_PARAM;
							if (m_tree1.GetItem (&tvItem3))
							{

								//Check if this node has already been checked for children
								fChildrenChecked = ((ISAMTreeItemData*)tvItem3.lParam)->fExpanded;

								if (!fChildrenChecked)
								{
									char* txt = ((ISAMTreeItemData*)tvItem3.lParam)->absName;

									ISAMBuildTreeChildren (nextSibling,
															 txt,
															 m_tree1,
															 *this,
															 lpszServer,
//															 m_loginMethod,
															 lpszUserName,
															 lpszPassword,
															 *fIntpretEmptPwdAsBlank,
															 lpszLocale,
															 lpszAuthority,
															 ! itemSelected);
								}
							}
						}
					}

					AddNamespaces (item, fDeepMode);

					EndWaitCursor();
				}
			}
		}	
	}
}

void CConnectionDialog::OnDeleteitemTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;
}



// Window Procedure to circumvent bug(?) in mfc
CMap<SHORT, SHORT, CWindowInfo*, CWindowInfo*> windowMap;


LRESULT CALLBACK
MySubClassProc (HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	
	CWindowInfo *pwindowInfo = NULL;
	VERIFY (windowMap.Lookup ((SHORT) ((DWORD)hWnd & 0xffff), pwindowInfo) && pwindowInfo);
	return :: CallWindowProc (pwindowInfo->m_oldWindowProc,
							  pwindowInfo->m_hWnd,
							  nMsg, wParam, lParam);
}


BOOL CConnectionDialog::OnInitDialog() 
{
	ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog::OnInitDialog\n");

	CDialog::OnInitDialog(); 
	
	// subclass the window to circumvent a bug (?) in mfc
	WNDPROC oldWindowProc =  (WNDPROC):: SetWindowLong (m_hWnd, GWL_WNDPROC, (DWORD) MySubClassProc);
	CWindowInfo *pwindowInfo = new CWindowInfo (m_hWnd, oldWindowProc);
	windowMap.SetAt ((SHORT)((DWORD)m_hWnd & 0xffff), pwindowInfo);

		// hook up the controls
	m_browseEdit.Attach (::GetDlgItem (m_hWnd, IDC_BROWSE_EDIT));
	m_browse.Attach (::GetDlgItem (m_hWnd, IDC_BUTTON_BROWSE));
	m_cancelButton.Attach(::GetDlgItem (m_hWnd, IDCANCEL));
	m_okButton.Attach (::GetDlgItem (m_hWnd, IDOK));
	m_UserName.Attach(::GetDlgItem (m_hWnd, IDC_EDIT_USER_NAME));
	m_Password.Attach(::GetDlgItem (m_hWnd, IDC_EDIT_PSWD));
	m_Authority.Attach(::GetDlgItem (m_hWnd, IDC_EDIT_AUTH));
	m_Locale.Attach(::GetDlgItem (m_hWnd, IDC_EDIT_LOCALE));
	m_tree1.Attach(::GetDlgItem (m_hWnd, IDC_TREE1));
	m_sysPropCheck.Attach(::GetDlgItem (m_hWnd, IDC_CHECK1));
	m_impersonateCheck.Attach(::GetDlgItem (m_hWnd, IDC_CHECK_IMPERSONATE));
	m_PassthroughOnlyCheck.Attach(::GetDlgItem (m_hWnd, IDC_CHECK_PASSTHROUGHONLY));
	m_messageEdit.Attach (::GetDlgItem (m_hWnd, IDC_MESSAGE));
	m_RefreshButton.Attach (::GetDlgItem (m_hWnd, IDC_REFRESH_BUTTON));
	m_PwdAsNull.Attach (::GetDlgItem (m_hWnd, IDC_RADIO_NULL));
	m_PwdAsBlank.Attach (::GetDlgItem (m_hWnd, IDC_RADIO_BLANK));

	// TODO: Add extra initialization here
	pCurrentSelectionList = NULL;
	pCurrentItem = NULL;


	m_browseEdit.LimitText(MAX_SERVER_NAME_LENGTH);
	m_UserName.LimitText(MAX_USER_NAME_LENGTH);
	m_Password.LimitText(MAX_PASSWORD_LENGTH);

	m_Password.SetPasswordChar('*');

	m_browseEdit.SetWindowText((lpszServer ? lpszServer : ""));
	m_browseEdit.SetModify(FALSE);

	m_UserName.SetWindowText((lpszUserName ? lpszUserName : ""));
	m_UserName.SetModify(FALSE);

	m_Password.SetWindowText((lpszPassword ? lpszPassword : ""));
	m_Password.SetModify(FALSE);

	//Set Authority
	m_Authority.SetWindowText((lpszAuthority ? lpszAuthority : ""));
	m_Authority.SetModify(FALSE);

	//Set Locale
	m_Locale.SetWindowText((lpszLocale ? lpszLocale : ""));
	m_Locale.SetModify(FALSE);

	//Set System Properties checkbox 
	m_sysPropCheck.SetCheck(*fSystemProperties ? 1 : 0);

	//Set Impersonation checkbox
	m_impersonateCheck.SetCheck(impersonateMgr ? 1 : 0);

	//Set Passthrough only checkbox
	m_PassthroughOnlyCheck.SetCheck(*fPassthroughOnly ? 1 : 0);

	//Set the Interpret an empty password as
	m_PwdAsNull.SetCheck(*fIntpretEmptPwdAsBlank ? 0 : 1);
	m_PwdAsBlank.SetCheck(*fIntpretEmptPwdAsBlank ? 1 : 0);

	m_messageEdit.FmtLines(TRUE);
	m_messageEdit.ShowWindow(SW_HIDE);
	m_tree1.EnableWindow(TRUE);
	m_tree1.ShowWindow(SW_SHOWNA);

	char buffer [129];
	buffer[0] = 0;
	LoadString(s_hModule, STR_CONNECT, (char*)buffer, 128);
	m_RefreshButton.SetWindowText(buffer);
	m_RefreshButton.EnableWindow(FALSE);

	// Fill in the first tree with all the namespace information
	// The second tree is empty for now.  In future this will depend on the 
	// connection string


	//Each node in the CTreeCtrl will be in one of the following 4 states

	//  1) node not selected, child nodes not selected
	//  2) node not selected, some or all child nodes selected
	//  3) node selected, no child nodes selected
	//  4) node selected, some or all child nodes selected

	m_imageList.Create (32, 16, TRUE, 25, 0);
	bmap1.LoadBitmap(IDB_BITMAP1);
	bmap2.LoadBitmap(IDB_BITMAP2);
	bmap3.LoadBitmap(IDB_BITMAP3);
	bmap4.LoadBitmap(IDB_BITMAP4);
	bmask.LoadBitmap(IDB_MASK);
	m_idxMode1Image = m_imageList.Add (&bmap1, &bmask);
	m_idxMode2Image = m_imageList.Add (&bmap2, &bmask);
	m_idxMode3Image = m_imageList.Add (&bmap3, &bmask);
	m_idxMode4Image = m_imageList.Add (&bmap4, &bmask);


	m_tree1.SetImageList (&m_imageList, TVSIL_NORMAL);

	//Tidy Up
	bmap1.DeleteObject();
	bmap2.DeleteObject();
	bmap3.DeleteObject();
	bmap4.DeleteObject();
	bmask.DeleteObject();

	LONG oldStyle = :: GetWindowLong(m_tree1.m_hWnd, GWL_STYLE);

	:: SetWindowLong (m_tree1.m_hWnd,
						GWL_STYLE,
						oldStyle | TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT);

	BOOL fStatusOK = TRUE;

	//We may or may not be using impersonation
	//but if we do, has it worked ?
	if (*fImpersonation && impersonateMgr)
	{
		//Check if impersonation request has worked
		if (! impersonateMgr->CanWeImpersonate() )
		{
			fStatusOK = FALSE;
		}
	}

	if (fStatusOK)
	{
		BeginWaitCursor();

		HTREEITEM hDummy;
		SWORD treeStatus = ISAMBuildTree (TVI_ROOT, "root",   /*"root\\default",*/
					   m_tree1, *this,
					   lpszServer ? lpszServer : NULL, // server
	//				   m_loginMethod,
					   lpszUserName ? lpszUserName : NULL, // username
					   lpszPassword ? lpszPassword : NULL, // password
					   *fIntpretEmptPwdAsBlank,
					   lpszLocale,
					   lpszAuthority,
					   TRUE, FALSE, hDummy);	

		EndWaitCursor();

		// enumerate elements in list and set the namespaces passed in in the 
		// connection string to be included
		POSITION pos;
		CString key;
		CNamespace *pNamespace;
		for (pos = pMapStringToObIn->GetStartPosition ();pos != NULL;)
		{
			pMapStringToObIn->GetNextAssoc (pos, key, (CObject*&)pNamespace);
			HTREEITEM hFoundItem;
			int len = (pNamespace->GetName ()).GetLength ();
			LPTSTR str = (pNamespace->GetName ()).GetBuffer (len);
			if (FindAbsName (str, m_tree1.GetRootItem (),  hFoundItem))
			{
				//include it
				AddNamespaces (hFoundItem, FALSE /* shallow */);
			}
			else
			{
				// attempt to create namespace
				if (CreateNamespace (str, m_tree1.GetRootItem (),  hFoundItem))
				{
					//include it
					AddNamespaces (hFoundItem, FALSE /* shallow */);
				}
			}
		}

		//Update state of OK pushbutton depending on
		//number of cels selected
		m_okButton.EnableWindow(cSelectedCels ? TRUE : FALSE);

	}
	else
	{
		//Impersonation failed
		m_tree1.EnableWindow(FALSE);
		m_tree1.ShowWindow(SW_HIDE);

		char buffer [128 + 1];
		buffer[0] = 0;
		LoadString(s_hModule, STR_FAILED_WBEM_CONN, 
			(char*)buffer, 128);
		m_messageEdit.SetWindowText(buffer);
		m_messageEdit.ShowWindow(SW_SHOWNA);
	}

	//Final check to see if proper connection parameters were entered
	if (!fConnParmSpecified)
	{
		ConnectionParameterChange();

		//Give the user name edit box focus
		m_UserName.SetFocus();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConnectionDialog::OnNcDestroy() 
{
	CWindowInfo *pwindowInfo = NULL;
	BOOL found = windowMap.Lookup ((SHORT) ((DWORD)m_hWnd & 0xffff), pwindowInfo);
	ASSERT (found);
	if (found)
	{
		// unsubclass the window
		:: SetWindowLong (m_hWnd, GWL_WNDPROC, (DWORD) pwindowInfo->m_oldWindowProc);
		delete pwindowInfo;
		windowMap.RemoveKey ((SHORT) ((DWORD)m_hWnd & 0xffff));
	}

	m_browseEdit.Detach ();
	m_browse.Detach ();
	m_cancelButton.Detach();
	m_okButton.Detach ();
	m_UserName.Detach();
	m_Password.Detach();
	m_Authority.Detach();
	m_Locale.Detach();
	m_tree1.Detach();
	m_sysPropCheck.Detach();
	m_impersonateCheck.Detach();
	m_PassthroughOnlyCheck.Detach();
	m_messageEdit.Detach();
	m_RefreshButton.Detach();
	m_PwdAsNull.Detach();
	m_PwdAsBlank.Detach();


	CDialog :: OnNcDestroy ();
}

void CConnectionDialog::OnOK() 
{
	// TODO: Add extra validation here
	GenerateOutMap (m_tree1.GetRootItem ());
	GenerateOutString  (m_tree1.GetRootItem ());

	//Copy back new Username and Password
	lpszUserName[0] = 0;
	lpszPassword[0] = 0;
	m_UserName.GetWindowText(lpszUserName, MAX_USER_NAME_LENGTH);
	m_Password.GetWindowText(lpszPassword, MAX_PASSWORD_LENGTH);

	//Copy Authority & Locale
	if (lpszAuthority)
		delete lpszAuthority;

	*lpszAuthorityOut = NULL;

	int AuthLen = m_Authority.GetWindowTextLength();


	if (AuthLen)
	{
		*lpszAuthorityOut = new char [AuthLen + 1];
		(*lpszAuthorityOut)[0] = 0;
		m_Authority.GetWindowText(*lpszAuthorityOut, AuthLen + 1);
		(*lpszAuthorityOut)[AuthLen] = 0;
	}

	if (lpszLocale)
		delete lpszLocale;

	*lpszLocaleOut = NULL;

	int LocaleLen = m_Locale.GetWindowTextLength();


	if (LocaleLen)
	{
		*lpszLocaleOut = new char [LocaleLen + 1];
		(*lpszLocaleOut)[0] = 0;
		m_Locale.GetWindowText(*lpszLocaleOut, LocaleLen + 1);
		(*lpszLocaleOut)[LocaleLen] = 0;
	}
	

	HTREEITEM hTreeItem = m_tree1.GetRootItem();

	CleanUpTreeCtrl(hTreeItem);

	CDialog::OnOK();
}

void CConnectionDialog :: CleanUpTreeCtrl(HTREEITEM& hTreeItem)
{
	if (pCurrentSelectionList)
	{
		ISAMTreeItemData* theNext = NULL; 
		do
		{
			theNext = pCurrentSelectionList->pNext;
			delete pCurrentSelectionList;
			pCurrentSelectionList = theNext;
		} while (pCurrentSelectionList);
	}

	pCurrentSelectionList = NULL;
	pCurrentItem = NULL;

}

void CConnectionDialog::OnButtonSysProp()
{
	//Clicked on the System Properties checkbox
	*fSystemProperties =  m_sysPropCheck.GetCheck() ? TRUE : FALSE;
}

void CConnectionDialog::OnButtonInterpretEmpty()
{
	//Clicked on one of the Interpret empty password as radio buttons
	*fIntpretEmptPwdAsBlank = m_PwdAsBlank.GetCheck() ? TRUE : FALSE;

	ConnectionParameterChange();
}

void CConnectionDialog::OnButtonImpersonation()
{
	//Clicked on the Impersonation checkbox
	*fImpersonation = m_impersonateCheck.GetCheck() ? TRUE : FALSE;
	
	ConnectionParameterChange();
}

void CConnectionDialog::OnButtonPassthroughOnly()
{
	//Clicked on the Passthrough only checkbox
	*fPassthroughOnly = m_PassthroughOnlyCheck.GetCheck() ? TRUE : FALSE;
}


void CConnectionDialog::OnButtonBrowse() 
{
	// TODO: Add your control notification handler code here

	m_browse.EnableWindow(FALSE);
	BeginWaitCursor();

	//Show dialog box
	CBrowseDialog d;
	int result = d.DoModal();

	m_browse.EnableWindow(TRUE);
	EndWaitCursor();

	//abort if OK pushbutton was not pressed
	if (result != IDOK)
		return;

	m_browseEdit.SetWindowText( d.GetServerName() );
	m_browseEdit.SetModify(FALSE);

	//update tree
	RefreshTree();
}

void CConnectionDialog::OnCancel() 
{
	// TODO: Add extra cleanup here
	HTREEITEM hTreeItem = m_tree1.GetRootItem();

	CleanUpTreeCtrl(hTreeItem);
	
	CDialog::OnCancel();
}

BOOL GetWbemDirectory(_bstr_t& wbemDir)
{
	HKEY keyHandle = (HKEY)1;
	TCHAR buff [1001];
	DWORD sizebuff = 1000;

	long fStatus = 0;
	_bstr_t location("Software\\ODBC\\ODBCINST.INI\\WBEM ODBC Driver");

	buff[0] = 0;
	fStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		(LPCTSTR)location, 0, KEY_READ, &keyHandle);

	if (fStatus == ERROR_SUCCESS)
	{
		DWORD typeValue;
		_bstr_t subkey("Help");

		fStatus = RegQueryValueEx(keyHandle, (LPCTSTR)subkey, NULL,
						&typeValue, (LPBYTE)buff, &sizebuff);


		if (fStatus == ERROR_SUCCESS)
		{
			wbemDir = buff;
			return TRUE;
		}

	}
	return FALSE;
}

void CConnectionDialog::OnHelp() 
{
	_bstr_t sName       = ">Main";

	//Get the WBEM directory
	_bstr_t wbemDir;
	if ( !GetWbemDirectory(wbemDir) )
		return;

	_bstr_t sPrefix     = "mk:@MSITStore:" + wbemDir + "\\WBEMDR32.CHM";
	_bstr_t sIndex      = sPrefix + "::" + "/_hmm_connecting_to_an_odbc_data_source.htm";


	HtmlHelp		
		(
				NULL,					// HWND - this is where WM_TCARD messages will be sent
				sName,					// Use "Main" window name
				HH_DISPLAY_TOPIC,		// We want to display a topic please
				(DWORD)(TCHAR*)sIndex		// Full path of topic to display
				);

}


void CConnectionDialog::OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here

	fDoubleClicked = TRUE;
	
	*pResult = 0;
}

void CConnectionDialog::ConnectionParameterChange()
{
	m_tree1.EnableWindow(FALSE);
	m_tree1.ShowWindow(SW_HIDE);
	char buffer [128 + 1];
	buffer[0] = 0;
	LoadString(s_hModule, STR_PLEASE_REFRESH, 
		(char*)buffer, 128);

	m_messageEdit.SetWindowText(buffer);
	m_messageEdit.ShowWindow(SW_SHOWNA);

	LoadString(s_hModule, STR_CONNECT, (char*)buffer, 128);
	m_RefreshButton.SetWindowText(buffer);
	m_RefreshButton.EnableWindow(TRUE);
	m_okButton.EnableWindow(FALSE); 
}

void CConnectionDialog::OnLocaleChange()
{
	ConnectionParameterChange();
}

void CConnectionDialog::OnAuthorityChange()
{
	ConnectionParameterChange();
}

void CConnectionDialog::OnUserNameChange()
{
	ConnectionParameterChange();
}

void CConnectionDialog::OnPasswordChange()
{
	ConnectionParameterChange();
}

void CConnectionDialog::OnServerChange()
{
	ConnectionParameterChange();
}


void CConnectionDialog::OnButtonRefresh()
{
	char buffer [129];
	buffer[0] = 0;

	m_tree1.EnableWindow(TRUE);
	m_tree1.ShowWindow(SW_SHOWNA);
	m_messageEdit.ShowWindow(SW_HIDE);

	//Disable button and rename to CONNECT
	LoadString(s_hModule, STR_CONNECT, (char*)buffer, 128);
	m_RefreshButton.SetWindowText(buffer);
	m_RefreshButton.EnableWindow(FALSE);

	BOOL status = RefreshTree();

	if (status)
	{
		//If refresh was successful
		//enable button and rename to REFRESH
		LoadString(s_hModule, STR_REFRESH, (char*)buffer, 128);
		m_RefreshButton.SetWindowText(buffer);
		m_RefreshButton.EnableWindow(TRUE);
	}

	//Give the tree control or message text focus
	if ( m_tree1.IsWindowEnabled() )
		m_tree1.SetFocus();
	else
		m_messageEdit.SetFocus();
}


void CConnectionDialog::OnKillfocusBrowseEdit() 
{
/*
	// TODO: Add your control notification handler code here

	//Check if server, user name or password have been changed
	//If so, refresh tree
	if ( m_browseEdit.GetModify() || m_UserName.GetModify() || m_Password.GetModify() )
	{
		//reset flags
		m_browseEdit.SetModify(FALSE);
		m_UserName.SetModify(FALSE);
		m_Password.SetModify(FALSE);

		//refresh tree view
		RefreshTree();
	}
*/
}

BOOL CConnectionDialog::RefreshTree()
{
	ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog::RefreshTree\n");

	BOOL status = FALSE;

	//Update tree view with namespaces associated with new server
	HTREEITEM hTreeItem = m_tree1.GetRootItem();
	CleanUpTreeCtrl(hTreeItem);
	m_tree1.DeleteAllItems();
	cSelectedCels = 0;

	//Refresh Window
	UpdateWindow();

	lpszServer[0] = 0;
	lpszUserName[0] = 0;
	lpszPassword[0] = 0;
	m_browseEdit.GetWindowText(lpszServer, MAX_SERVER_NAME_LENGTH);
	m_UserName.GetWindowText(lpszUserName, MAX_USER_NAME_LENGTH);
	m_Password.GetWindowText(lpszPassword, MAX_PASSWORD_LENGTH);


	//Copy Authority & Locale
	if (lpszAuthority)
		delete lpszAuthority;

	lpszAuthority = NULL;

	int AuthLen = m_Authority.GetWindowTextLength();

	if (AuthLen)
	{
		lpszAuthority = new char [AuthLen + 1];
		lpszAuthority[0] = 0;
		m_Authority.GetWindowText(lpszAuthority, AuthLen + 1);
		lpszAuthority[AuthLen] = 0;
		ODBCTRACE(_T("\nWBEM ODBC Driver : CConnectionDialog::RefreshTree\n"));
		ODBCTRACE(_T(" Authority :"));
		ODBCTRACE(_T(lpszAuthority));
		ODBCTRACE(_T("\n"));
	}

	if (lpszLocale)
		delete lpszLocale;

	lpszLocale = NULL;

	int LocaleLen = m_Locale.GetWindowTextLength();

	if (LocaleLen)
	{
		lpszLocale = new char [LocaleLen + 1];
		lpszLocale[0] = 0;
		m_Locale.GetWindowText(lpszLocale, LocaleLen + 1);
		lpszLocale[LocaleLen] = 0;
	}

	//Update impersonation if applicable
	BOOL fImpersonateStatusOK = TRUE;

	if (*fImpersonation)
	{
		ODBCTRACE ("\nWBEM ODBC Driver : Impersonation checkbox ON\n");
		delete impersonateMgr;
		impersonateMgr = NULL;

		//Now check if impersonation is necessary
		//only if connecting locally
		if (IsLocalServer(lpszServer))
		{
			impersonateMgr = new ImpersonationManager(lpszUserName, lpszPassword, lpszAuthority);

			//Check if impersonation request has worked
			if (! impersonateMgr->CanWeImpersonate() )
			{
				ODBCTRACE ("\nWBEM ODBC Driver : We cannot impersonate\n");
				fImpersonateStatusOK = FALSE;
			}
			else
			{
				ODBCTRACE ("\nWBEM ODBC Driver : We can impersonate\n");

				//Do the actual impersonation so cloaking will work
				if ( ! impersonateMgr->ImpersonatingNow() )
					impersonateMgr->Impersonate("CConnectionDialog");

			}
		}
		else
		{
			ODBCTRACE("\nWBEM ODBC Driver : Server not detected as local, not impersonating\n");
		}
	}
	else
	{
		ODBCTRACE ("\nWBEM ODBC Driver : Impersonation checkbox OFF\n");
	}



	BeginWaitCursor();

	//Disable OK pushbutton when updating
	m_okButton.EnableWindow(FALSE);

	//Check if you can connect using specified authentication information
	char* lpRootNamespace = "root";
	DWORD dwAuthLevel = 0;
	DWORD dwImpLevel = 0;
	COAUTHIDENTITY* pAuthIdent = NULL;

	IWbemServicesPtr pGateway = NULL;
	ISAMGetGatewayServer (pGateway,
					lpszServer ? (LPUSTR)lpszServer : NULL, //server
//					m_loginMethod,
					(LPUSTR)lpRootNamespace, 
					lpszUserName ? (LPUSTR)lpszUserName : NULL, // username
				    lpszPassword ? (LPUSTR)lpszPassword : NULL, // password
					(LPUSTR)lpszLocale,									//locale
					(LPUSTR)lpszAuthority,//authority
					dwAuthLevel,
					dwImpLevel,
					*fIntpretEmptPwdAsBlank,
					&pAuthIdent
					);


	

	if ( pAuthIdent )
	{
		WbemFreeAuthIdentity( pAuthIdent );
		pAuthIdent = NULL;
	}

	if (fImpersonateStatusOK && (pGateway != NULL))
	{
		ODBCTRACE ("\nWBEM ODBC Driver : fImpersonateStatusOK && pGateway\n");
	
		
		BOOL fIsLocalConnection = IsLocalServer((LPSTR) lpszServer);

		//cloaking
		if ( fIsLocalConnection && IsW2KOrMore() )
		{
			WbemSetDynamicCloaking(pGateway, dwAuthLevel, dwImpLevel);
		}

		status = TRUE;

		HTREEITEM hDummy;
		ISAMBuildTree (TVI_ROOT, "root",   /*"root\\default",*/
					   m_tree1, *this,
					   lpszServer ? lpszServer : NULL, //server
//					   m_loginMethod,
					   lpszUserName ? lpszUserName : NULL, // username
					   lpszPassword ? lpszPassword : NULL, // password
					   *fIntpretEmptPwdAsBlank,
					   lpszLocale,
					   lpszAuthority,
					   TRUE, FALSE, hDummy);

		//finished impersonating
//		if ( (*fImpersonation) && (impersonateMgr) )
//			impersonateMgr->RevertToYourself("ConnectionDialog");

	}
	else
	{
		ODBCTRACE ("\nWBEM ODBC Driver : Failed Connection\n");

		status = FALSE;

		m_tree1.EnableWindow(FALSE);
		m_tree1.ShowWindow(SW_HIDE);

		char buffer [128 + 1];
		buffer[0] = 0;
		LoadString(s_hModule, STR_FAILED_WBEM_CONN, 
			(char*)buffer, 128);
		m_messageEdit.SetWindowText(buffer);
		m_messageEdit.ShowWindow(SW_SHOWNA);
	}

	EndWaitCursor();

	if (status)
		ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog::RefreshTree returns TRUE\n");
	else
		ODBCTRACE ("\nWBEM ODBC Driver : CConnectionDialog::RefreshTree returns FALSE\n");

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\connect.cpp ===
/***************************************************************************/
/* CONNECT.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "resource.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
#include "odbcinst.h"

BOOL INTFUNC ReadInNamespace (LPSTR lpFrom, SDWORD cbFrom, LPSTR *lpTo,
                      UWORD FAR *pfType, LPSTR FAR *lpRemainder,
                      SDWORD FAR *pcbRemainder);
#define TYPE_NONE 0
#define TYPE_BRACE 1
#define TYPE_SIMPLE_IDENTIFIER 2

/***************************************************************************/
extern "C" BOOL EXPFUNC dlgDirectory(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPUSTR lpszDatabase;

    switch (message) {

    case WM_INITDIALOG:
        SendDlgItemMessage(hDlg, DATABASE_NAME, EM_LIMITTEXT,
                           MAX_DATABASE_NAME_LENGTH, 0L);
        SetWindowLong(hDlg, DWL_USER, lParam);
        SetDlgItemText(hDlg, DATABASE_NAME, (LPSTR) lParam);
        return (TRUE);

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:

            /* Get answer */
            lpszDatabase = (LPUSTR) GetWindowLong(hDlg, DWL_USER);
            GetDlgItemText(hDlg, DATABASE_NAME, (LPSTR) lpszDatabase,
                           MAX_DATABASE_NAME_LENGTH);
            AnsiToOem((LPCSTR) lpszDatabase, (LPSTR) lpszDatabase);

            /* Clear off leading blanks */
            while (*lpszDatabase == ' ')
                s_lstrcpy(lpszDatabase, lpszDatabase+1);

            /* Clear off trailing blanks */
            while (*lpszDatabase != '\0') { 
                if (lpszDatabase[s_lstrlen(lpszDatabase)-1] != ' ')
                    break;
               lpszDatabase[s_lstrlen(lpszDatabase)-1] = '\0';
            }

            /* Get rid of terminating backslash (if any) */
            if (s_lstrlen(lpszDatabase) > 0) {
                if (lpszDatabase[s_lstrlen(lpszDatabase)-1] == '\\')
                    lpszDatabase[s_lstrlen(lpszDatabase)-1] = '\0';
            }
            else {

                /* If no directory specified, use the current directory */
                s_lstrcpy(lpszDatabase, ".");
            }

            /* Return */
            EndDialog(hDlg, TRUE);
            return (TRUE);

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return (TRUE);
        }
        break;
    }
    return (FALSE);
}
/***************************************************************************/

RETCODE SQL_API SQLAllocEnv(
    HENV FAR *phenv)
{
    HGLOBAL   henv;
    LPENV     lpenv;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Allocate memory for the handle */
    henv = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ENV));
    if (henv == NULL || (lpenv = (LPENV)GlobalLock (henv)) == NULL) {
        
        if (henv)
            GlobalFree(henv);

        *phenv = SQL_NULL_HENV;
		OleUninitialize();
        return SQL_ERROR;
    }

    /* So far no connections on this environment */
    lpenv->lpdbcs = NULL;

	ISAMCheckTracingOption();

	ISAMCheckWorkingThread_AllocEnv();

    /* Return success */
    lpenv->errcode = ERR_SUCCESS;
    (lpenv->szISAMError)[0] = 0;
    *phenv = (HENV FAR *)lpenv;
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLAllocConnect(
    HENV     henv,
    HDBC FAR *phdbc)
{
    LPENV   lpenv;
    LPDBC   lpdbc;
    HGLOBAL hdbc;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Allocate memory for the handle */
    lpenv = (LPENV) henv;
    lpenv->errcode = ERR_SUCCESS;
    hdbc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (DBC));
    if (hdbc == NULL || (lpdbc = (LPDBC)GlobalLock (hdbc)) == NULL) {
        
        if (hdbc)
            GlobalFree(hdbc);

        lpenv->errcode = ERR_MEMALLOCFAIL;
        *phdbc = SQL_NULL_HDBC;
        return SQL_ERROR;
    }

    /* Put handle on list of connection handles */
    lpdbc->lpNext = lpenv->lpdbcs;
    lpenv->lpdbcs = lpdbc;
    
    /* So far no statements for this connection */
    lpdbc->lpstmts = NULL;

    /* Rember which environment goes with this connection */
    lpdbc->lpenv = lpenv;

    /* So far no connection */
    (lpdbc->szDSN)[0] = 0;
    lpdbc->lpISAM = NULL;

    /* Initialize transaction information */
    lpdbc->fTxnIsolation = -1;
    lpdbc->fAutoCommitTxn = FALSE;

    /* Return success */
    lpdbc->errcode = ERR_SUCCESS;
    (lpdbc->szISAMError)[0] = 0;
    *phdbc = (HDBC FAR *) lpdbc;


    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLConnect(
    HDBC      hdbc,
    UCHAR FAR *szDSN,
    SWORD     cbDSN,
    UCHAR FAR *szUID,
    SWORD     cbUID,
    UCHAR FAR *szAuthStr,
    SWORD     cbAuthStr)
{
    LPDBC   lpdbc;
    UCHAR   szDatabase[MAX_DATABASE_NAME_LENGTH+1];
    UCHAR   szUsername[MAX_USER_NAME_LENGTH+1];
    UCHAR   szPassword[MAX_PASSWORD_LENGTH+1];
    SWORD   err;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

    /* Error if already connected */
    if (s_lstrlen((char*)lpdbc->szDSN) != 0) {
        lpdbc->errcode = ERR_CONNECTIONINUSE;
        return SQL_ERROR;
    }

    /* Save name of DSN */
    cbDSN = (SWORD) TrueSize((LPUSTR)szDSN, cbDSN, SQL_MAX_DSN_LENGTH);
    _fmemcpy(lpdbc->szDSN, szDSN, cbDSN);
    lpdbc->szDSN[cbDSN] = '\0';

    /* Get user name */
    cbUID = (SWORD) TrueSize((LPUSTR)szUID, cbUID, MAX_USER_NAME_LENGTH);
    _fmemcpy(szUsername, szUID, cbUID);
    szUsername[cbUID] = '\0';
    if (s_lstrlen((char*)szUsername) == 0) {
        SQLGetPrivateProfileString((char*)lpdbc->szDSN, KEY_USERNAME, "",
                   (char*)szUsername, MAX_USER_NAME_LENGTH+1, ODBC_INI);
    }

    /* Get password */
    cbAuthStr = (SWORD) TrueSize((LPUSTR)szAuthStr, cbAuthStr, MAX_PASSWORD_LENGTH);
    _fmemcpy(szPassword, szAuthStr, cbAuthStr);
    szPassword[cbAuthStr] = '\0';
    if (s_lstrlen((char*)szPassword) == 0) {
        SQLGetPrivateProfileString((char*)lpdbc->szDSN, KEY_PASSWORD, "",
                   (char*)szPassword, MAX_PASSWORD_LENGTH+1, ODBC_INI);
    }

	// in this case we will open the default namespace in deep mode
	CMapStringToOb *pMapStringToOb = new CMapStringToOb;
	DWORD dwDummyValue = 0;
	ISAMGetNestedNamespaces (NULL, "root\\default", NULL, dwDummyValue, dwDummyValue, NULL, 
//		WBEM_AUTHENTICATION_DEFAULT, 
				(char*)szUsername, (char*)szPassword, FALSE, NULL, NULL, pMapStringToOb);
	szDatabase[0] = 0;
	lstrcpy ((char*)szDatabase, "root\\default");

	if (lpdbc->lpISAM != NULL)
	{
		ISAMClose(lpdbc->lpISAM);
		lpdbc->lpISAM = NULL;
	}

	err = ISAMOpen((LPUSTR)"", (LPUSTR)szDatabase, NULL, 
//			WBEM_AUTHENTICATION_DEFAULT,
				(LPUSTR)szUsername, (LPUSTR)szPassword, NULL, NULL, FALSE, pMapStringToOb,
				&(lpdbc->lpISAM), (LPUSTR)lpdbc->szISAMError, TRUE, FALSE, FALSE, FALSE);


    if (err != NO_ISAM_ERR) {
        lpdbc->lpISAM = NULL;
        (lpdbc->szDSN)[0] = 0;
        lpdbc->errcode = err;
        return SQL_ERROR;
    }

    /* Initialize transaction states */
    lpdbc->fAutoCommitTxn = TRUE;
    lpdbc->fTxnIsolation = lpdbc->lpISAM->fDefaultTxnIsolation;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLDriverConnect(
    HDBC      hdbc,
    HWND      hwnd,
    UCHAR FAR *szConnStrIn,
    SWORD     cbConnStrIn,
    UCHAR FAR *szConnStrOut,
    SWORD     cbConnStrOutMax,
    SWORD FAR *pcbConnStrOut,
    UWORD     fDriverCompletion)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	LPDBC	  lpdbc;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;
    
    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;


	ODBCTRACE ("\nWBEM ODBC Driver : Enter SQLDriverConnect\n");
	CString myInputConnectionString;
	myInputConnectionString.Format("\nWBEM ODBC Driver :\nszConnStrIn = %s\ncbConnStrIn = %ld\n",
							szConnStrIn, cbConnStrIn);
	ODBCTRACE(myInputConnectionString);

	MyImpersonator im (lpdbc, "SQLDriverConnect");


	//Test
	switch (fDriverCompletion)
	{
	case SQL_DRIVER_PROMPT:
		ODBCTRACE("\nWBEM ODBC Driver : fDriverCompletion = SQL_DRIVER_PROMPT\n");
		break;
	case SQL_DRIVER_COMPLETE:
		ODBCTRACE("\nWBEM ODBC Driver : fDriverCompletion = SQL_DRIVER_COMPLETE\n");
		break;
	case SQL_DRIVER_COMPLETE_REQUIRED:
		ODBCTRACE("\nWBEM ODBC Driver : fDriverCompletion = SQL_DRIVER_COMPLETE_REQUIRED\n");
		break;
	case SQL_DRIVER_NOPROMPT:
		ODBCTRACE("\nWBEM ODBC Driver : fDriverCompletion = SQL_DRIVER_NOPROMPT\n");
		break;
	default:
		ODBCTRACE("\nWBEM ODBC Driver : fDriverCompletion = dunno\n");
		break;
	}

    /* Error if already connected */
    if (s_lstrlen((char*)lpdbc->szDSN) != 0) {
        lpdbc->errcode = ERR_CONNECTIONINUSE;
        return SQL_ERROR;
    }

    /* Parse the connection string */
	ConnectionStringManager connManager (hdbc, hwnd, szConnStrIn, fDriverCompletion);
	RETCODE rc = connManager.Process();

	if (rc != SQL_SUCCESS)
		return rc;

	char* lpszConnStr = connManager.GenerateConnString();
	
	ULONG cOutputLen = lstrlen ((char*)lpszConnStr);

    /* Return the connections string */
	if (szConnStrOut)
	{
		szConnStrOut[0] = 0;
		lpdbc->errcode = ReturnString(szConnStrOut, cbConnStrOutMax,
									  pcbConnStrOut, (LPUSTR)lpszConnStr);
	}
	else
	{
		//No space to return result
		lpdbc->errcode = ERR_DATATRUNCATED;
	}

    if (lpdbc->errcode == ERR_DATATRUNCATED)
	{
		delete lpszConnStr;
        return SQL_SUCCESS_WITH_INFO;
	}

	//Tidy up
	delete lpszConnStr;

	lpdbc->szISAMError[0] = 0;

	CString myOutputConnectionString;
	myOutputConnectionString.Format("\nWBEM ODBC Driver :\nszConnStrOut = %s\ncbConnStrOutMax = %ld\n",
		szConnStrOut, cbConnStrOutMax);

	ODBCTRACE(myOutputConnectionString);
	ODBCTRACE ("\nWBEM ODBC Driver : Exit SQLDriverConnect\n");
    return SQL_SUCCESS;
}


ConnectionStringManager :: ConnectionStringManager(HDBC fHdbc, HWND hwind, UCHAR FAR *szConnStr, UWORD fDvrCompletion)	
{
	//Initialize
	lpdbc = (LPDBC) fHdbc;
	hwnd = hwind;
	fDriverCompletion = fDvrCompletion;
	fOptimization = TRUE; //HMM Level 1 optimization is on by default
	ptr = (char*)szConnStr;
	lpszOutputNamespaces = NULL;
	pMapStringToOb = new CMapStringToOb();
	pMapStringToObOut = new CMapStringToOb();
	szDSN[0] = 0;
	szDriver[0] = 0;
	szDatabase[0] = 0;
	szUsername[0] = 0;
	szPassword[0] = 0;
	szOptimization[0] =0;
	szServer[0] = 0;
	szHome[0] = 0;
	fUsernameSpecified = FALSE;
	fPasswordSpecified = FALSE;
	fServerSpecified   = FALSE;
	fImpersonate       = FALSE;
	fPassthroughOnly   = FALSE;
	fIntpretEmptPwdAsBlank = FALSE;
	fSysProp = FALSE;
//	m_loginMethod = WBEM_AUTHENTICATION_DEFAULT;
	szLocale = NULL;
	szAuthority = NULL;
}

ConnectionStringManager :: ~ConnectionStringManager()
{
	//Tidy up
	delete lpszOutputNamespaces;

	//Check if we have specified enough info in input connection string
	//if so the output pMapStringToObOut will be empty and is not used (so can be deleted)
	//if pMapStringToOb is not empty, then we delete pMapStringToOb
	int cOut = pMapStringToObOut->GetCount();
	BOOL fIsOutEmpty = pMapStringToObOut->IsEmpty();

	if ( (!fIsOutEmpty) && (cOut > 0) )
	{
		//pMapStringToObOut in use, delete pMapStringToOb
		int cIn = pMapStringToOb->GetCount ();
		BOOL fIsInEmpty = pMapStringToOb->IsEmpty();

		if ( (!fIsInEmpty) && (cIn > 0) )
		{
			CString key;
			CNamespace *pNamespace;
			for (POSITION pos = pMapStringToOb->GetStartPosition (); pos != NULL; )
			{
				if (pos)
				{
					pMapStringToOb->GetNextAssoc (pos, key, (CObject*&)pNamespace);
					delete pNamespace;
				}
			}
		}
		delete pMapStringToOb;
	}
	else
	{
		//pMapStringToObOut not in use, delete pMapStringToObOut
		delete pMapStringToObOut;
	}

	delete szLocale;
	delete szAuthority;
}

RETCODE ConnectionStringManager :: Process()
{
	RETCODE rc = SQL_SUCCESS;

	//First Parse the connection string
	rc = Parse();

	if (rc != SQL_SUCCESS)
		return rc;

	//Complement connection string with information in ODBC.INI file
	GetINI();

	//If there is still missing information get it from user via a dialog box
	rc = ShowDialog();

	return rc;
}

//Parse the connection string by separating it into its attribute-keyword pairs
RETCODE ConnectionStringManager :: Parse()
{
	LPSTR	lpszKeyword;    
	LPSTR	lpszValue;
	UCHAR     chr;
	foundDriver = FALSE, 
	foundDSN = FALSE;

	SWORD myStatuscode = NO_ISAM_ERR;

    while (*ptr) 
	{

		/* Skip any leading white spaces */
		while (*ptr == ' ')
			ptr++;

        /* Point at start of next keyword */
        lpszKeyword = ptr;

        /* Find the end of the keyword */
        while ((*ptr != '\0') && (*ptr != '='))
            ptr++;

        /* Error if no value */
        if ((*ptr == '\0') || (ptr == lpszKeyword)) {
            lpdbc->errcode = ERR_INVALIDCONNSTR;
            return SQL_ERROR;
        }

        /* Put a zero terminator on the keyword */
        *ptr = '\0';
        ptr++;

        /* Point at start of the keyword's value */
        lpszValue = ptr;

        /* Find the end of the value */
        while ((*ptr != '\0') && (*ptr != ';'))
            ptr++;

        /* Put a zero terminator on the value */
        chr = *ptr;
        *ptr = '\0';

        /* Save the keyword */
        if (!lstrcmpi(lpszKeyword, KEY_DSN))
		{
			if (!foundDriver && !foundDSN)
			{
				if (lstrlen (lpszValue) < SQL_MAX_DSN_LENGTH)
				{
					lstrcpy((char*)szDSN, lpszValue);
					foundDSN = TRUE;
				}
				else
				{
					// shouldn't get here (DM should catch it)
					return SQL_ERROR;
				}
			}
		}
        else if (!lstrcmpi(lpszKeyword, KEY_DRIVER))
		{
			if (!foundDriver && !foundDSN)
			{
				if (lstrlen (lpszValue) < MAX_DRIVER_LENGTH)
				{
					foundDriver = TRUE;
					lstrcpy((char*)szDriver, lpszValue);
				}
				else
				{
					return SQL_ERROR;
				}
			}
		}
		else if (!lstrcmpi(lpszKeyword, KEY_DATABASE))
		{
			if (lstrlen (lpszValue) < MAX_DATABASE_NAME_LENGTH)
				lstrcpy ((char*)szDatabase, lpszValue);
			else
			{
				return SQL_ERROR;
			}
		}
		else if (!lstrcmpi(lpszKeyword, KEY_UIDPWDDEFINED))
		{
			fUsernameSpecified = TRUE;
			fPasswordSpecified = TRUE;
		}
		else if (!lstrcmpi(lpszKeyword, KEY_IMPERSONATE))
		{
			fImpersonate = TRUE;
		}
		else if (!lstrcmpi(lpszKeyword, KEY_PASSTHROUGHONLY))
		{
			fPassthroughOnly = TRUE;
		}
/*
		else if (!lstrcmpi(lpszKeyword, KEY_LOGINMETHOD))
		{
			if (!lstrcmpi(lpszValue, "Default"))
			{
				m_loginMethod = WBEM_AUTHENTICATION_DEFAULT;
			}
			else if (!lstrcmpi(lpszValue, "NTLM"))
			{
				m_loginMethod = WBEM_AUTHENTICATION_NTLM;
			}
			else
			{
				return SQL_ERROR;
			}
		}
*/
		else if (!lstrcmpi(lpszKeyword, KEY_LOCALE))
		{
			//RAID 42256
//			int localeLen = lstrlen (lpszValue);
			int localeLen = _mbstrlen (lpszValue);
			
			if (szLocale)
				delete szLocale;

			szLocale = new char [localeLen + 1];
			szLocale[0] = 0;
			lstrcpy (szLocale, lpszValue);

		}
		else if (!lstrcmpi(lpszKeyword, KEY_AUTHORITY))
		{
			//RAID 42256
			int authLen = _mbstrlen (lpszValue);
			
			if (szAuthority)
				delete szAuthority;

			szAuthority = new char [authLen + 1];
			szAuthority[0] = 0;
			lstrcpy (szAuthority, lpszValue);
		}
		else if (!lstrcmpi(lpszKeyword, KEY_USERNAME))
		{
			fUsernameSpecified = TRUE;

			//RAID 42256
			if (_mbstrlen (lpszValue) < MAX_USER_NAME_LENGTH)
				lstrcpy ((char*)szUsername, lpszValue);
			else
				return SQL_ERROR;

		}
		else if (!lstrcmpi(lpszKeyword, KEY_PASSWORD))
		{
			fPasswordSpecified = TRUE;

			//RAID 42256
			if (_mbstrlen (lpszValue) < MAX_PASSWORD_LENGTH)
				lstrcpy ((char*)szPassword, lpszValue);
			else
				return SQL_ERROR;
		}
		else if (!lstrcmpi(lpszKeyword, KEY_INTPRET_PWD_BLK))
		{
			fIntpretEmptPwdAsBlank = TRUE;
		}
		else if (!lstrcmpi(lpszKeyword, KEY_SYSPROPS))
		{
			if ( _stricmp(lpszValue, "TRUE") == 0)
			{
				fSysProp = TRUE;
			}
			else
			{
				fSysProp = FALSE;
			}
		}
		else if (!lstrcmpi(lpszKeyword, KEY_OPTIMIZATION))
		{
			if (lstrlen (lpszValue) < MAX_OPTIMIZATION_LENGTH)
			{
				lstrcpy ((char*)szOptimization, lpszValue);

				//Check this value to update optimzation state

				if ( (strcmp(lpszValue, "OFF") == 0) ||
					 (strcmp(lpszValue, "FALSE") == 0) ||
					 (strcmp(lpszValue, "0") == 0) ||
					 (strcmp(lpszValue, "NO") == 0))
				{
					fOptimization = FALSE;
				}
			}
		}
		else if (!lstrcmpi(lpszKeyword, KEY_NAMESPACES))
		{
			// make copy of comma separate list of namespaces
			// pospone parsing of namespaces until the end
			// as this is affected by the values of UID, PWD and SERVER

			//RAID 42256
			lpszOutputNamespaces = new char [_mbstrlen (lpszValue) + 1];
			lpszOutputNamespaces[0] = 0;
			lstrcpy (lpszOutputNamespaces, lpszValue);
		}
		else if (!lstrcmpi(lpszKeyword, KEY_SERVER))
		{
			fServerSpecified = TRUE;

			if (_mbstrlen (lpszValue) < MAX_SERVER_NAME_LENGTH)
				lstrcpy ((char*)szServer, lpszValue);
			else
				return SQL_ERROR;
		}
		else if (!lstrcmpi(lpszKeyword, KEY_HOME))
		{
			//RAID 42256
			if (_mbstrlen (lpszValue) < MAX_HOME_NAME_LENGTH)
				lstrcpy ((char*)szHome, lpszValue);
			else
				return SQL_ERROR;
		}

        /* Restore the input string */
        lpszKeyword[lstrlen(lpszKeyword)] = '=';
        *ptr = chr;
        if (*ptr != '\0')
            ptr++;
    }


	/****** TEST ******/
//	fImpersonate = TRUE;


	//Now it is time to parse the namespaces, if any where specified
	char *lpszRemainder = lpszOutputNamespaces;

	//RAID 42256
	SDWORD cbRemainder = lpszOutputNamespaces ? _mbstrlen (lpszOutputNamespaces) : 0;
	LPSTR lpszToken = NULL;
	UWORD fType;
	while (lpszOutputNamespaces)
	{
		if (ReadInNamespace (lpszRemainder, cbRemainder, &lpszToken, &fType,
							 &lpszRemainder, &cbRemainder) && fType != TYPE_NONE)
		{
			if (fType == TYPE_SIMPLE_IDENTIFIER) 
			{
				/* Create a CNamespace and add it to the namespaceMap*/

				//However, before we do so check if HOME has been defined
				//If so, we assume the NAMESPACES list contain relative names
				//We need to convert them to fully qualified names by prepending
				//the HOME pathname to them
				SWORD cbHomeLen = (szHome ? strlen((char*)szHome) : 0);

				//RAID 42256
				SWORD cbTokenLen = (SWORD) _mbstrlen(lpszToken);
				
				if (cbHomeLen)
				{
					char* lpTempStr = new char [cbHomeLen + cbTokenLen + 2];
					lpTempStr[0] = 0;
					sprintf(lpTempStr, "%s\\%s", (char*)szHome, lpszToken);

					DWORD dwDummyValue = 0;
					myStatuscode = ISAMGetNestedNamespaces (NULL, lpTempStr, NULL, dwDummyValue, dwDummyValue, (char*) szServer, 
//						m_loginMethod, 
						(char*)szUsername,
								 (char*)szPassword, fIntpretEmptPwdAsBlank, szLocale, szAuthority, pMapStringToOb, FALSE);
					delete lpTempStr;

					if (myStatuscode != NO_ISAM_ERR)
						return SQL_ERROR;
				}
				else
				{
					DWORD dwDummyValue = 0;
					myStatuscode = ISAMGetNestedNamespaces (NULL, lpszToken, NULL, dwDummyValue, dwDummyValue, (char*) szServer, 
//						m_loginMethod, 
						(char*)szUsername, (char*)szPassword, fIntpretEmptPwdAsBlank, szLocale, szAuthority, pMapStringToOb, FALSE);

					if (myStatuscode != NO_ISAM_ERR)
						return SQL_ERROR;
				}

				
				delete lpszToken;
				lpszToken = NULL;
			}
			else
			{ // TYPE_BRACE -> isolate the name and the deep flag
				char *name = strtok (lpszToken, ",	");
				char *deep = strtok (NULL, ",	");
				BOOL bDeep = FALSE;

				//However, before we do so check if HOME has been defined
				//If so, we assume the NAMESPACES list contain relative names
				//We need to convert them to fully qualified names by prepending
				//the HOME pathname to them

				//RAID 42256
				SWORD cbHomeLen = (szHome ? _mbstrlen((char*)szHome) : 0);
				SWORD cbTokenLen = (SWORD) _mbstrlen(name);

				BOOL fIsDeepMode = (deep && !_strcmpi (deep, "deep")) ? TRUE : FALSE;

				if (cbHomeLen)
				{
					char* lpTempStr = new char [cbHomeLen + cbTokenLen + 2];
					lpTempStr[0] = 0;
					sprintf(lpTempStr, "%s\\%s", (char*)szHome, name);
					DWORD dwDummyValue = 0;
					myStatuscode = ISAMGetNestedNamespaces (NULL, lpTempStr, NULL, dwDummyValue, dwDummyValue, (char*)szServer, 
//						m_loginMethod, 
					(char*)szUsername, (char*)szPassword, fIntpretEmptPwdAsBlank, szLocale, szAuthority, pMapStringToOb, fIsDeepMode);
					delete lpTempStr;

					if (myStatuscode != NO_ISAM_ERR)
						return SQL_ERROR;
				}
				else
				{
					DWORD dwDummyValue = 0;
					myStatuscode = ISAMGetNestedNamespaces (NULL, name, NULL, dwDummyValue, dwDummyValue, (char*)szServer, 
//						m_loginMethod, 
					(char*)szUsername, (char*)szPassword, fIntpretEmptPwdAsBlank, szLocale, szAuthority, pMapStringToOb, fIsDeepMode);

					if (myStatuscode != NO_ISAM_ERR)
						return SQL_ERROR;
				}
			
				delete lpszToken;
				lpszToken = NULL;
			}
		}
		else
			break;
	}

	return SQL_SUCCESS;
}

void ConnectionStringManager :: GetINI()
{
	if (foundDSN)  
	{
		/* Use the registry to compliment the information in the conn string */
		/* Get the database name from ODBC.INI file if not specified */
		if (lstrlen((char*)szDatabase) == 0) {
			if (lstrlen((char*)szDSN) > 0) {
				SQLGetPrivateProfileString((char*)szDSN, KEY_DATABASE, ".",
					   (char*)szDatabase, MAX_DATABASE_NAME_LENGTH+1, ODBC_INI);
			}
		}

		/* Get the username from ODBC.INI file if not specified */
		if (lstrlen((char*)szUsername) == 0) {
			if (lstrlen((char*)szDSN) > 0) {
				SQLGetPrivateProfileString((char*)szDSN, KEY_USERNAME, "",
					   (char*)szUsername, MAX_USER_NAME_LENGTH+1, ODBC_INI);
			}
		}

		/* Get the password from ODBC.INI file if not specified */
		if (lstrlen((char*)szPassword) == 0) {
			if (lstrlen((char*)szDSN) > 0) {
				SQLGetPrivateProfileString((char*)szDSN, KEY_PASSWORD, "",
					   (char*)szPassword, MAX_PASSWORD_LENGTH+1, ODBC_INI);
			}
		}
	}
}

RETCODE ConnectionStringManager :: ShowDialog()
{
	ODBCTRACE ("\nWBEM ODBC Driver : ConnectionStringManager :: ShowDialog\n");
	
	/* Get missing information from from user */	
    SWORD     err = ISAM_ERROR;

	//Check for no prompt
	if (fDriverCompletion == SQL_DRIVER_NOPROMPT)
	{
		if ((lstrlen ((char*)szDatabase) == 0) ||
			(pMapStringToOb->GetCount() == 0) ||
			(NO_ISAM_ERR != (err = ISAMOpen((LPUSTR)szServer,(LPUSTR)szDatabase, NULL, 
//			m_loginMethod,
				   (LPUSTR)szUsername, (LPUSTR)szPassword, (LPUSTR)szLocale, (LPUSTR)szAuthority, fSysProp, pMapStringToOb,
                   &(lpdbc->lpISAM), (LPUSTR)lpdbc->szISAMError, fOptimization, fImpersonate, fPassthroughOnly, fIntpretEmptPwdAsBlank))))
		{
			lstrcpy((char*)lpdbc->szISAMError, "");
			
			LoadString(s_hModule, ERR_UNABLETOCONNECT, (char*)lpdbc->szISAMError,
					   MAX_ERROR_LENGTH+1);

			lpdbc->lpISAM = NULL;
			lpdbc->errcode = err;
			return SQL_ERROR;
		}
	}
	else if ((fDriverCompletion == SQL_DRIVER_PROMPT) ||
        (!fUsernameSpecified) ||
		 (lstrlen ((char*)szDatabase) == 0) ||
		 (!fPasswordSpecified) ||
		 (pMapStringToOb->GetCount() == 0) ||
		 ((NO_ISAM_ERR != (err = ISAMOpen((LPUSTR)szServer,(LPUSTR)szDatabase, NULL, 
//		 m_loginMethod,
				   (LPUSTR)szUsername, (LPUSTR)szPassword, (LPUSTR)szLocale, (LPUSTR)szAuthority, fSysProp, pMapStringToOb,
                   &(lpdbc->lpISAM), (LPUSTR)lpdbc->szISAMError, fOptimization, fImpersonate, fPassthroughOnly, fIntpretEmptPwdAsBlank))) &&
         (fDriverCompletion != SQL_DRIVER_NOPROMPT))) 
	{
		CWnd parentWnd;
		parentWnd.Attach (hwnd);

		//Clear out namespace list as this will be replaced
		//the CConnectionDialog will return a fully qualified namespace list
		//so we can clear out the HOME pathname
		delete lpszOutputNamespaces;
		szHome[0] =0;

		lpszOutputNamespaces = NULL;


		//Check if server name has been specified
		BOOL fConnParmSpecified = (fServerSpecified && fPasswordSpecified && fUsernameSpecified) ? TRUE : FALSE;
//		BOOL fConnParmSpecified = (fServerSpecified) ? TRUE : FALSE;

		CConnectionDialog connectionDialog (&parentWnd, (char*)szServer,
//			m_loginMethod, 
											(char*)szUsername, (char*)szPassword, 
											&szLocale, &szAuthority, &fSysProp, fConnParmSpecified,
											pMapStringToOb, pMapStringToObOut, 
								(fDriverCompletion == SQL_DRIVER_COMPLETE_REQUIRED),
								&lpszOutputNamespaces, &fImpersonate, &fPassthroughOnly, &fIntpretEmptPwdAsBlank);

		connectionDialog.DoModal ();

/*
		//Update locale and authority
		if (szLocale)
			delete szLocale;

		if (szAuthority)
			delete szAuthority;

		//these values are deleted in destructor
		szLocale = connectionDialog.GetLocale();
		szAuthority = connectionDialog.GetAuthority();
*/

		//Test
		CString myText("\nWBEM ODBC Driver : fIntpretEmptPwdAsBlank = ");
		if (fIntpretEmptPwdAsBlank)
		{
			myText += "BLANK\n";
		}
		else
		{
			myText += "NULL\n";
		}
		ODBCTRACE(myText);

		parentWnd.Detach ();
	}

    /* Analyse dialog box output */
	if (err != NO_ISAM_ERR)
	{
		ImpersonationManager* tmp = NULL;

		if (fImpersonate)
		{
			//Now check if impersonation is necessary
			//only if connecting locally
			if (IsLocalServer((char*)szServer))
			{
				tmp = new ImpersonationManager((char*)szUsername, (char*)szPassword, (char*)szAuthority);
			}
			else
			{
				ODBCTRACE("\nWBEM ODBC Driver : Server not detected as local, not impersonating\n");
			}
		}

		//If szDatabase was previously specified, check if it
		//is still in the namespace list
		BOOL fUseOldszDatabase = FALSE;
		if ( lstrlen((char*)szDatabase) )
		{
			//Search namespace list for old szDatabase
			CString key;
			CNamespace *pNamespace;
			for (POSITION pos = pMapStringToObOut->GetStartPosition (); (!fUseOldszDatabase) && (pos != NULL); )
			{
				if (pos)
				{
					pMapStringToObOut->GetNextAssoc (pos, key, (CObject*&)pNamespace);
					int len = (pNamespace->GetName ()).GetLength ();
					if (len <= MAX_DATABASE_NAME_LENGTH)
					{
						LPTSTR str = (pNamespace->GetName ()).GetBuffer (len);
						if (strcmp((char*)szDatabase, str) == 0)
						{
							//Found original szDatabase
							fUseOldszDatabase = TRUE;

							err = ISAMOpen((LPUSTR)szServer,(LPUSTR)szDatabase, NULL, 
//								m_loginMethod,
								(LPUSTR)szUsername, (LPUSTR)szPassword, (LPUSTR)szLocale, (LPUSTR)szAuthority, fSysProp, pMapStringToObOut,
								&(lpdbc->lpISAM), (LPUSTR)lpdbc->szISAMError, fOptimization, fImpersonate, fPassthroughOnly, fIntpretEmptPwdAsBlank);

							if (err != NO_ISAM_ERR) 
							{
								lpdbc->lpISAM = NULL;
								lpdbc->errcode = err;
								delete tmp;
								return SQL_ERROR;
							}

							delete tmp;
							return SQL_SUCCESS;
						}
					}
				}
			}
		}

		// make szDatabase = to first namespace on list for now
		if ((!fUseOldszDatabase) && pMapStringToObOut->GetCount ())
		{
			CString key;
			CNamespace *pNamespace;
			POSITION pos = pMapStringToObOut->GetStartPosition ();
			if (pos)
			{
				pMapStringToObOut->GetNextAssoc (pos, key, (CObject*&)pNamespace);
				int len = (pNamespace->GetName ()).GetLength ();
				if (len <= MAX_DATABASE_NAME_LENGTH)
				{
					LPTSTR str = (pNamespace->GetName ()).GetBuffer (len);
					szDatabase[0] = 0;
					lstrcpy ((char*)szDatabase, str);

					if (lpdbc->lpISAM != NULL)
					{
						ISAMClose(lpdbc->lpISAM);
						lpdbc->lpISAM = NULL;
					}

					
					err = ISAMOpen((LPUSTR)szServer,(LPUSTR)szDatabase, NULL, 
//						m_loginMethod,
						(LPUSTR)szUsername, (LPUSTR)szPassword, (LPUSTR)szLocale, (LPUSTR)szAuthority, fSysProp, pMapStringToObOut,
						&(lpdbc->lpISAM), (LPUSTR)lpdbc->szISAMError, fOptimization, fImpersonate, fPassthroughOnly, fIntpretEmptPwdAsBlank);
				}
				else
					err = ISAM_NS_OVERMAX;
			}
			else
				err = ISAM_NS_LISTFAIL;
		}
		else
		{
			//Canceled out of the dialog box, so quit
			delete tmp;
			return SQL_NO_DATA_FOUND;
		}

		delete tmp;
			
	}

    if (err != NO_ISAM_ERR) 
	{
        lpdbc->lpISAM = NULL;
        lpdbc->errcode = err;
        return SQL_ERROR;
    }

	return SQL_SUCCESS;
}

char* ConnectionStringManager :: GenerateConnString()
{
	ULONG CLenConnStr = MAX_DRIVER_LENGTH + MAX_DATABASE_NAME_LENGTH +
								  MAX_USER_NAME_LENGTH + MAX_PASSWORD_LENGTH +
								  MAX_BOOLFLAG_LENGTH +
								  MAX_KEYWORD_SEPARATOR_LENGTH + /* combined length of kewords + separators */ 
								  MAX_SERVER_NAME_LENGTH + MAX_OPTIMIZATION_LENGTH + MAX_LOGIN_METHOD_LENGTH + strlen (KEY_NAMESPACES);


	//Check locale and authority
	if (szLocale && lstrlen(szLocale))
	{
		CLenConnStr = CLenConnStr + 8 + lstrlen(szLocale);
	}

	if (szAuthority && lstrlen(szAuthority))
	{
		CLenConnStr = CLenConnStr + 11 + lstrlen(szAuthority);
	}
	
	//RAID 42256
	if (lpszOutputNamespaces)
		CLenConnStr += _mbstrlen (lpszOutputNamespaces);

	char *lpszConnStr = new char [CLenConnStr + 1];
	lpszConnStr[0] = 0;


    /* Put the datasource or driver name on the connection string */
    (lpdbc->szDSN)[0] = 0;

	if (lstrlen((char*)szDSN) != 0) 
	{
        lstrcpy((char*)lpdbc->szDSN, (char*)szDSN);
        lstrcpy((char*)lpszConnStr, KEY_DSN);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szDSN);
    }
    else {
        lstrcpy((char*)lpdbc->szDSN, " ");
        lstrcpy((char*)lpszConnStr, KEY_DRIVER);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szDriver);
    }
        
    /* Put the database name on the connection string */
	if (lstrlen((char*)szDatabase) != 0) {
		lstrcat((char*)lpszConnStr, ";");
		lstrcat((char*)lpszConnStr, KEY_DATABASE);
		lstrcat((char*)lpszConnStr, "=");
		lstrcat((char*)lpszConnStr, (char*)szDatabase);
	}

	/* Put the server on the connection string */
//	if (lstrlen((char*)szServer) != 0)
	{
		lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_SERVER);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szServer);
	}

	/* Put the home on the connection string */
	if (lstrlen((char*)szHome) != 0)
	{
		lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_HOME);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szHome);
	}
/*
	// Put the login method on the connection string
	lstrcat((char*)lpszConnStr, ";");
    lstrcat((char*)lpszConnStr, KEY_LOGINMETHOD);
    lstrcat((char*)lpszConnStr, "=");

	switch (m_loginMethod)
	{
	case WBEM_AUTHENTICATION_DEFAULT:
		lstrcat((char*)lpszConnStr, (char*)"Default");
		break;
	case WBEM_AUTHENTICATION_NTLM:
		lstrcat((char*)lpszConnStr, (char*)"NTLM");
		break;
	default:
		lstrcat((char*)lpszConnStr, (char*)"WBEM");
		break;
	}
*/
	/* put flag to indicate user name and password defined */
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_UIDPWDDEFINED);
        lstrcat((char*)lpszConnStr, "=");
    }

	/* put flag to indicate if impersonation is requested */
	if (fImpersonate)
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_IMPERSONATE);
        lstrcat((char*)lpszConnStr, "=");
    }

	/* put flag to indicate if passthrough only mode is requested */
	if (fPassthroughOnly)
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_PASSTHROUGHONLY);
        lstrcat((char*)lpszConnStr, "=");
    }

    /* Put the user name on the connection string */
//	if (lstrlen ((char*)szUsername) != 0) 
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_USERNAME);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szUsername);
    }

    /* Put the password on the connection string */
//    if (lstrlen((char*)szPassword) != 0) 
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_PASSWORD);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szPassword);
    }

	/* put flag to indicate if you interpet an empty password as blank */
	if (fIntpretEmptPwdAsBlank)
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_INTPRET_PWD_BLK);
        lstrcat((char*)lpszConnStr, "=");
    }

	/* Put the locale on the connection string */
    if (szLocale && lstrlen(szLocale)) 
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_LOCALE);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szLocale);
    }

	/* Put the authority on the connection string */
    if (szAuthority && lstrlen(szAuthority)) 
	{
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_AUTHORITY);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)szAuthority);
    }


	/* Put the system properties flag on the connection string */
    lstrcat((char*)lpszConnStr, ";");
    lstrcat((char*)lpszConnStr, KEY_SYSPROPS);
    lstrcat((char*)lpszConnStr, "=");

	if (fSysProp)
	{
		lstrcat((char*)lpszConnStr, (char*)"TRUE");
	}
	else
	{
		lstrcat((char*)lpszConnStr, (char*)"FALSE");
	}
  

	/* Put the namespaces into the output connection string */
	//RAID 42256
    if (lpszOutputNamespaces && _mbstrlen((char*)lpszOutputNamespaces) != 0) {
        lstrcat((char*)lpszConnStr, ";");
        lstrcat((char*)lpszConnStr, KEY_NAMESPACES);
        lstrcat((char*)lpszConnStr, "=");
        lstrcat((char*)lpszConnStr, (char*)lpszOutputNamespaces);
    }

	return lpszConnStr;
}

/***************************************************************************/

RETCODE SQL_API SQLBrowseConnect(
    HDBC      hdbc,
    UCHAR FAR *szConnStrIn,
    SWORD     cbConnStrIn,
    UCHAR FAR *szConnStrOut,
    SWORD     cbConnStrOutMax,
    SWORD FAR *pcbConnStrOut)
{
    LPDBC  lpdbc;

    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLDisconnect(
    HDBC      hdbc)
{
    LPDBC     lpdbc;
    LPSTMT    lpstmt;
    RETCODE   rc;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;


	MyImpersonator im(lpdbc, "SQLDisconnect");

    /* If transaction in progress, fail */
    if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE) {
        for (lpstmt = lpdbc->lpstmts; lpstmt!=NULL ;lpstmt = lpstmt->lpNext) {
            if (lpstmt->fISAMTxnStarted) {
                lpdbc->errcode = ERR_TXNINPROGRESS;
                return SQL_ERROR;
            }
        }
    }

    /* Close all active statements */
    lpstmt = lpdbc->lpstmts;
    while (lpstmt != NULL) {
        rc = SQLFreeStmt((HSTMT) lpstmt, SQL_CLOSE);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO)) {
            lpdbc->errcode = lpstmt->errcode;
            s_lstrcpy(lpdbc->szISAMError, lpstmt->szISAMError);
            return rc;
        }
        lpstmt = lpstmt->lpNext;
    }

    /* Disconnect */
    (lpdbc->szDSN)[0] = 0;
    
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLFreeConnect(
    HDBC      hdbc)
{
    LPDBC     lpdbc;
    RETCODE   rc;
    LPDBC     lpdbcPrev;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

//	ODBCTRACE(_T("\nWBEM ODBC Driver : SQLFreeConnect\n"));
//	MyImpersonator im (lpdbc);

    /* Deallocate all statements */
    while (lpdbc->lpstmts != NULL) {
        rc = SQLFreeStmt((HSTMT) lpdbc->lpstmts, SQL_DROP);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO)) {
            lpdbc->errcode = lpdbc->lpstmts->errcode;
            s_lstrcpy((char*)lpdbc->szISAMError, (char*)lpdbc->lpstmts->szISAMError);
            return rc;
        }
    }

    /* Close ISAM */
    if (lpdbc->lpISAM != NULL)
	{
        ISAMClose(lpdbc->lpISAM);
		lpdbc->lpISAM = NULL;
	}

    /* Take connection off the list */
    if (lpdbc->lpenv->lpdbcs == lpdbc) {
        lpdbc->lpenv->lpdbcs = lpdbc->lpNext;
    }
    else {
        lpdbcPrev = lpdbc->lpenv->lpdbcs;
        while (lpdbcPrev->lpNext != lpdbc)
            lpdbcPrev = lpdbcPrev->lpNext;
        lpdbcPrev->lpNext = lpdbc->lpNext;
    }

    /* Free the memory */
    GlobalUnlock (GlobalPtrHandle(hdbc));
    GlobalFree (GlobalPtrHandle(hdbc));


	ODBCTRACE("\n****** EXIT SQLFreeConnect ******\n");

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLFreeEnv(
    HENV      henv)
{
    LPENV lpenv;
    RETCODE   rc;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

    /* Get environment handle */
    lpenv = (LPENV) henv;
    lpenv->errcode = ERR_SUCCESS;

    /* Deallocate all connections */
    while (lpenv->lpdbcs != NULL) {
        rc = SQLFreeConnect((HDBC) lpenv->lpdbcs);
        if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO)) {
            lpenv->errcode = lpenv->lpdbcs->errcode;
            s_lstrcpy((char*)lpenv->szISAMError, (char*)lpenv->lpdbcs->szISAMError);
            return rc;
        }
    }

	//decrement reference count on working thread
	ISAMCheckWorkingThread_FreeEnv();

    /* Free the memory */
    GlobalUnlock (GlobalPtrHandle(henv));
    GlobalFree (GlobalPtrHandle(henv));

    return SQL_SUCCESS;
}

/***************************************************************************/
 /////


BOOL INTFUNC ReadInNamespace (LPSTR lpFrom, SDWORD cbFrom, LPSTR *lpTo,
                      UWORD FAR *pfType, LPSTR FAR *lpRemainder,
                      SDWORD FAR *pcbRemainder)

// Retrives a token from input string, and returns the token and a pointer
// to the remainder of the input string.  This makes no assumption about the length
// of the string (including whitespace) between the braces.

{
    int len;

    // Remove leading blanks & ,'s
    while ((cbFrom != 0) &&
           ((*lpFrom == ' ') ||
            (*lpFrom == '\012') ||
            (*lpFrom == '\015') ||
            (*lpFrom == '\011') ||
			(*lpFrom == ','))) {
        lpFrom++;
        cbFrom--;
    }

    // Leave if no more
    if (cbFrom == 0) {
		*lpTo = NULL;
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
		*pfType = TYPE_NONE;
        return TRUE;
    }

    // What kind of token?
    switch (*lpFrom) {

    // End of input
    case '\0':
		*lpTo = NULL;
        *lpRemainder = lpFrom;
        *pcbRemainder = cbFrom;
		*pfType = TYPE_NONE;
        return TRUE;

    // Braced identifier (of form {identifier})
    case '{':
        len = 0;
        lpFrom++;
        cbFrom--;
        while (TRUE) {

            if (cbFrom == 0)
                return FALSE;

            switch (*lpFrom) {
            case '\0':
                return FALSE;

            case '}':
				{
				*lpTo = new char [len+1];
				int i = 0;
				while (i < len)
				{
					*(*lpTo+i) = *(lpFrom-len+i);  
					i++;
				}
				*(*lpTo+i) = '\0';
                lpFrom++;
                cbFrom--;
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
				*pfType = TYPE_BRACE;
                return TRUE;
				}

            default:
                break;
            }
            len++;
            lpFrom++;
            cbFrom--;
        }
        break; // Control should never get here

    // a simple identifier
    default:
        len = 0;
        while (TRUE) {
            if (cbFrom == 0) {
				*lpTo = new char [len + 1];
				int i = 0;
				while (i < len)
				{
					*(*lpTo+i) = *(lpFrom-len+i);  
					i++;
				}
				*(*lpTo+i) = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
				*pfType = TYPE_SIMPLE_IDENTIFIER;
                return TRUE;
            }

            switch (*lpFrom) {
            case ' ':
            case '\012':
            case '\015':
            case '\011':
            case '\0':
			case ',':
				{
				int i = 0;

				//Bug fix Micks code
				if (! (*lpTo) )
				{
					*lpTo = new char [len + 1];
				}

				while (i < len)
				{
					*(*lpTo+i) = *(lpFrom-len+i);  
					i++;
				}
				*(*lpTo+i) = '\0';
                *lpRemainder = lpFrom;
                *pcbRemainder = cbFrom;
				*pfType = TYPE_SIMPLE_IDENTIFIER;
                return TRUE;
				}

            default:
                break;
            }
            len++;
            lpFrom++;
            cbFrom--;
        }
        break; // Control should never get here
    }
    // Control should never get here
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\drdbdr.cpp ===
/***************************************************************************/
/* DRDBDR.C                                                                */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
int junk;
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\dll.cpp ===
/***************************************************************************/
/* DLL.C                                                                   */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/
HINSTANCE NEAR s_hModule;               /* Saved module handle. */

/***************************************************************************/
class CTheApp : public CWinApp
{
	virtual BOOL InitInstance ();
};

BOOL CTheApp :: InitInstance ()
{
	//Enable3dControlsStatic ();
	s_hModule = AfxGetInstanceHandle ();
	return TRUE;
}

CTheApp  theApp;


#if 0
#ifdef WIN32
int __stdcall DllMain(HANDLE hInst,DWORD ul_reason_being_called,LPVOID lpReserved) 
{
    switch (ul_reason_being_called) {
    case DLL_PROCESS_ATTACH:
        s_hModule = (HINSTANCE) hInst; 
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    default:
        break;
    }

    return TRUE;                                                                
                                        
    UNREFERENCED_PARAMETER(lpReserved);                                         
}
#endif
#endif
/***************************************************************************/
#ifndef WIN32
int _export FAR PASCAL libmain(
    HANDLE     hModule,
    short      wDataSeg,
    short      cbHeapSize,
    UCHAR FAR *lszCmdLine)
{
    s_hModule = hModule; 
    return TRUE;
}
#endif

/***************************************************************************/

/*      Entry point to cause DM to load using ordinals */
void EXPFUNC FAR PASCAL LoadByOrdinal(void)
{
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\conndlg.h ===
// conndlg.h : header file
//


//Forward declaration
struct ISAMTreeItemData;
class ImpersonationManager;

/////////////////////////////////////////////////////////////////////////////
// CConnectionDialog dialog                                                //
/////////////////////////////////////////////////////////////////////////////

class CConnectionDialog : public CDialog
{
// Construction
public:
	CConnectionDialog(CWnd* pParent, char*, 
//					  WBEM_LOGIN_AUTHENTICATION loginMethod, 
					  char*,
					  char*, char** locale, char** authority, BOOL FAR*, BOOL, CMapStringToOb*,
					  CMapStringToOb*, BOOL, char**, BOOL *,
					  BOOL *, BOOL *);   // standard constructor

	~CConnectionDialog();

// Dialog Data
	//{{AFX_DATA(CConnectionDialog)
	enum { IDD = IDD_DIALOG_CONNECTION };
	CEdit	m_browseEdit;
	CButton	m_browse;
	CButton	m_cancelButton;
	CButton	m_okButton;
	CButton m_sysPropCheck;
	CButton m_impersonateCheck;
	CButton m_PassthroughOnlyCheck;
	CEdit	m_UserName;
	CEdit	m_Password;
	CEdit	m_Authority;
	CEdit	m_Locale;
	CTreeCtrl	m_tree1;
	CEdit	m_messageEdit;
	CButton	m_RefreshButton;
	CButton m_PwdAsNull;
	CButton m_PwdAsBlank;
	//}}AFX_DATA

	CImageList m_imageList;
	int m_idxSelectedImage, m_idxUnselectedImage, m_idxIncludedSelectedImage,
		m_idxIncludedUnselectedImage;
//	char *pServerIn;
//	char *pUsernameIn;
//	char *pPasswordIn;
	CMapStringToOb *pMapStringToObIn;
//	char *pServerOut;
//	char *pUsernameOut; 
	char *pPasswordOut;
	char *pHomeNamespaceOut;
	CMapStringToOb *pMapStringToObOut;


	char **lpszNamespacesOut;
	char* lpszServer;
	char* lpszUserName;
	char* lpszPassword;
	char* lpszAuthority;
	char* lpszLocale;
	char** lpszAuthorityOut;
	char** lpszLocaleOut;
	BOOL fConnParmSpecified;
	ULONG cSelectedCels;
	BOOL fDoubleClicked;
	CBitmap bmap1;
	CBitmap bmap2;
	CBitmap bmap3;
	CBitmap bmap4;
	CBitmap bmask;
	BOOL FAR* fSystemProperties;
	BOOL FAR* fImpersonation;
	BOOL FAR* fPassthroughOnly;
	BOOL FAR* fIntpretEmptPwdAsBlank;
//	WBEM_LOGIN_AUTHENTICATION m_loginMethod;
	int m_idxMode1Image ,m_idxMode2Image, m_idxMode3Image, m_idxMode4Image;

	ISAMTreeItemData * pCurrentSelectionList;
	ISAMTreeItemData * pCurrentItem;

	ImpersonationManager* impersonateMgr;

	void ConnectionParameterChange();


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectionDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();
	virtual void OnCancel();
	virtual void OnNcDestroy ();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConnectionDialog)
	afx_msg void OnClickTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTreeExpand(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitemTree1(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowse();
	afx_msg void OnButtonRefresh();
	afx_msg void OnButtonSysProp();
	afx_msg void OnButtonInterpretEmpty();
	afx_msg void OnButtonImpersonation();
	afx_msg void OnButtonPassthroughOnly();
	afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusBrowseEdit();
	afx_msg void OnUserNameChange();
	afx_msg void OnLocaleChange();
	afx_msg void OnPasswordChange();
	afx_msg void OnAuthorityChange();
	afx_msg void OnServerChange();
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


public:
	HTREEITEM InsertItem (CTreeCtrl&, HTREEITEM, const char *);
	void AddNamespaces (HTREEITEM, int);
	void RemoveNamespaces (HTREEITEM, int);
	int  FindAbsName (char *name,
										HTREEITEM hStartAt, 
										HTREEITEM& hFoundItem);
	int  CreateNamespace (char *name,
								HTREEITEM hStartAt, 
								HTREEITEM& hFoundItem);
	int  UnincludedChild (HTREEITEM item, int checkSelf);
	void GenerateOutMap (HTREEITEM hStartAt);
	void GenerateOutString (HTREEITEM hStartAt);
	void CleanUpTreeCtrl(HTREEITEM& hTreeItem);
	void UpdateChildChildInclude (HTREEITEM hNode, BOOL fIncrement);

	char* GetAuthority() //on heap (needs to be deleted)
				{return lpszAuthority;}

	char* GetLocale()    //on heap (needs to be deleted)
				{return lpszLocale;}

	BOOL Impersonation()	{ return impersonateMgr ? TRUE : FALSE; }

	BOOL RefreshTree();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\dlgcback.h ===
// Window Procedure to circumvent bug(?) in mfc
struct CWindowInfo {
	HWND m_hWnd;
	WNDPROC m_oldWindowProc;
	CWindowInfo (HWND hWnd, WNDPROC oldWindowProc) : m_hWnd (hWnd),
		m_oldWindowProc (oldWindowProc) {}
};

extern CMap<SHORT, SHORT, CWindowInfo*, CWindowInfo*> windowMap;


extern LRESULT CALLBACK
MySubClassProc (HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\dbase.cpp ===
/***************************************************************************/
/* DBASE.C - This is the module containing the code to read and write      */
/* dBASE files.                                                            */
/*                                                                         */
/* (C) Copyright 1993-96 - SYWARE, Inc. - All rights reserved              */
/***************************************************************************/

#include "precomp.h"
#include "wbemidl.h"
#include "dbase.h"
#include <stdio.h>
#include <time.h>

#define s_lstrcpy(a, b) lstrcpy((LPSTR) a, (LPCSTR) b)
#define s_lstrcat(a, b) lstrcat((LPSTR) a, (LPCSTR) b)
#define s_lstrlen(a) lstrlen((LPCSTR) a)
#define s_lstrcmp(a, b) lstrcmp((LPCSTR) a, (LPCSTR) b)

/***************************************************************************/
#define FIRST_RECORD 0xFFFFFFFF
#define LAST_RECORD 0xFFFFFFFE
/***************************************************************************/

SWORD FAR PASCAL dBaseExtendedOpen(LPUSTR name, BOOL fReadOnly,
                                   UWORD extraColumns, LPDBASEFILE FAR *lpf)
{
/*
    HFILE hf;
    UWORD columnCount;
    UWORD recordLen;
    HGLOBAL h;
    LPDBASEFILE f;
    UWORD i;
    UCHAR FAR * ptr;
    UCHAR fullname[DBASE_MAX_PATHNAME_SIZE+1];

    // Get the filename 
    s_lstrcpy((char*)fullname, name);
    ptr = fullname + s_lstrlen((char*)fullname);
    while ((ptr != fullname) && (*ptr != PATH_SEPARATOR_CHAR) && (*ptr != ':') &&
           (*ptr != '.'))
        ptr--;
    if (*ptr != '.')
        s_lstrcat((char*)fullname, ".dbf");

    // Open the file 
    if (fReadOnly)
        hf = _lopen((LPCSTR)fullname, OF_READ);
    else
        hf = _lopen((LPCSTR)fullname, OF_READWRITE);
    if (hf == HFILE_ERROR)
        return DBASE_ERR_TABLEACCESSERROR;

    //Figure out how many columns there are 
    if (HFILE_ERROR == _llseek(hf, DBASE_HEADER_SIZE_OFFSET, 0)) {
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    if (sizeof(UWORD) != _lread(hf, &columnCount, sizeof(UWORD))) {
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    columnCount = (columnCount - DBASE_HEADER_LENGTH - 1)/
                                DBASE_COLUMN_DESCR_LENGTH;

    // Get record size 
    if (HFILE_ERROR == _llseek(hf, DBASE_RECORD_LENGTH_OFFSET, 0)) {
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    if (sizeof(UWORD) != _lread(hf, &recordLen, sizeof(UWORD))) {
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }

    // Allocate space for handle 
    h = GlobalAlloc (GMEM_MOVEABLE, (sizeof(DBASEFILE) - sizeof(DBASECOL)) +
              (sizeof(DBASECOL) * (columnCount + extraColumns)) + recordLen);
    if (h == NULL || (f = (LPDBASEFILE)GlobalLock (h)) == NULL)
    {
        _lclose(hf);
        return DBASE_ERR_MEMALLOCFAIL;
    }

    // Read in the header 
    if (HFILE_ERROR == _llseek(hf, 0, 0)) {
        GlobalUnlock(h); 
        GlobalFree(h); 
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    if (DBASE_HEADER_LENGTH != _lread(hf, f, DBASE_HEADER_LENGTH)) {
        GlobalUnlock(h); 
        GlobalFree(h); 
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    if (f->encrypted != DBASE_NOT_ENCRYPTED) {
        GlobalUnlock(h); 
        GlobalFree(h); 
        _lclose(hf);
        return DBASE_ERR_CORRUPTFILE;
    }
    f->hf = hf;
    f->columnCount = columnCount;
    f->sortArray = NULL;
    f->currentRecord = 0;
    f->record = ((UCHAR FAR *) (&(f->column))) + 
                ((columnCount+extraColumns) * sizeof(DBASECOL));
    f->headerDirty = FALSE;
    f->recordDirty = FALSE;
    f->newRecord = FALSE;

    // Read in column definition 
    ptr = f->record + 1;
    for (i = 0; (i < columnCount); i++) {
        if (DBASE_COLUMN_DESCR_LENGTH != 
                   _lread(hf, &(f->column[i]), DBASE_COLUMN_DESCR_LENGTH)) {
            GlobalUnlock(h); 
            GlobalFree(h); 
            _lclose(hf);
            return DBASE_ERR_CORRUPTFILE;
        }
        OemToAnsiBuff((LPCSTR) f->column[i].name, f->column[i].name,
                                                 DBASE_COLUMN_NAME_SIZE);
        f->column[i].value = ptr;
        ptr += f->column[i].length;
    }

    *lpf = f;
*/
    return DBASE_ERR_SUCCESS;

}

/***************************************************************************/

SWORD FAR PASCAL dBaseFlushDirtyRecord(LPDBASEFILE f)
{
/*
    LONG offset;
    UCHAR c;
    UDWORD currentRecord;

    // Is there a dirty record? 
    if (f->recordDirty) {

        // Yes.  Write it back 
        f->recordDirty = FALSE;
        if (f->sortArray == NULL)
            currentRecord = f->currentRecord-1;
        else
            currentRecord = f->sortArray[f->currentRecord-1];
        offset = f->headerSize + (currentRecord * f->recordSize);
        if (HFILE_ERROR == _llseek(f->hf, offset, 0)) {
            f->newRecord = FALSE;
            f->currentRecord = 0;
            return DBASE_ERR_CORRUPTFILE;
        }
        AnsiToOemBuff((LPCSTR) f->record, f->record, f->recordSize);
        if (f->recordSize != _lwrite(f->hf, (LPCSTR) f->record, f->recordSize)) {
            f->newRecord = FALSE;
            f->currentRecord = 0;
            return DBASE_ERR_WRITEERROR;
        }

        // Was this a new record? 
        if (f->newRecord) {

            // Yes.  Write the end-of-data mark 
            f->newRecord = FALSE;
            c = DBASE_FILE_END;
            if (1 != _lwrite(f->hf, (LPCSTR) &c, 1)) {
                f->currentRecord = 0;
                return DBASE_ERR_WRITEERROR;
            }
        }

        // Write back the header 
        f->headerDirty = TRUE;
    }
*/
    return DBASE_ERR_SUCCESS;

}
/***************************************************************************/

SWORD FAR PASCAL dBaseQuickSortKeyCompare(LPDBASEFILE f, UWORD icol,
                                          BOOL descending, UDWORD left,
                                          UDWORD right, BOOL FAR *result)

/* Is the key of the left greater than or equal the key of the right? */

{
/*
    SWORD err;
    UWORD size;
    UCHAR szLeft[255];
    UCHAR szRight[255];
    SDOUBLE dblLeft;
    SDOUBLE dblRight;
    BOOL nullLeft;
    BOOL nullRight;

    // Handle boundry conditions 
    if (left == LAST_RECORD) {
        *result = TRUE;
        return DBASE_ERR_SUCCESS;
    }
    if (right == FIRST_RECORD) {
        *result = TRUE;
        return DBASE_ERR_SUCCESS;
    }
    if (left == FIRST_RECORD) {
        *result = FALSE;
        return DBASE_ERR_SUCCESS;
    }
    if (right == LAST_RECORD) {
        *result = FALSE;
        return DBASE_ERR_SUCCESS;
    }

    // Position to the right record 
    if (HFILE_ERROR == _llseek(f->hf, f->headerSize + (right * f->recordSize),
                               0))
        return DBASE_ERR_CORRUPTFILE;

    // Read the right record 
    size = _lread(f->hf, f->record, f->recordSize);
    if (size != f->recordSize)
        return DBASE_ERR_CORRUPTFILE;
    OemToAnsiBuff((LPCSTR) f->record, (LPSTR) f->record, f->recordSize);
    *(f->record) = DBASE_RECORD_NOT_DELETED;

    // Get the right key 
    switch (f->column[icol-1].type) {
    case DBASE_CHAR:
    case DBASE_LOGICAL:
    case DBASE_DATE:
    case DBASE_MEMO:
        err = dBaseColumnCharVal(f, icol, 0, 255, szRight, &nullRight);
        break;
    case DBASE_NUMERIC:
    case DBASE_FLOAT:
        err = dBaseColumnNumVal(f, icol, &dblRight, &nullRight);
        break;
    }
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // If right is null, return TRUE 
    if (nullRight) {
        *result = TRUE;
        return DBASE_ERR_SUCCESS;
    }

    // Position to the left record 
    if (HFILE_ERROR == _llseek(f->hf, f->headerSize + (left * f->recordSize),
                               0))
        return DBASE_ERR_CORRUPTFILE;

    // Read the left record 
    size = _lread(f->hf, f->record, f->recordSize);
    if (size != f->recordSize)
        return DBASE_ERR_CORRUPTFILE;
    OemToAnsiBuff((LPCSTR) f->record, (LPSTR) f->record, f->recordSize);
    *(f->record) = DBASE_RECORD_NOT_DELETED;

    // Get the left key 
    switch (f->column[icol-1].type) {
    case DBASE_CHAR:
    case DBASE_LOGICAL:
    case DBASE_DATE:
    case DBASE_MEMO:
        err = dBaseColumnCharVal(f, icol, 0, 255, szLeft, &nullLeft);
        break;
    case DBASE_NUMERIC:
    case DBASE_FLOAT:
        err = dBaseColumnNumVal(f, icol, &dblLeft, &nullLeft);
        break;
    }
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // If left is null, return FALSE 
    if (nullRight) {
        *result = FALSE;
        return DBASE_ERR_SUCCESS;
    }

    // Compare the keys 
    switch (f->column[icol-1].type) {
    case DBASE_CHAR:
    case DBASE_LOGICAL:
    case DBASE_DATE:
    case DBASE_MEMO:
        if (!descending) {
            if (s_lstrcmp(szLeft, szRight) >= 0)
                *result = TRUE;
            else
                *result = FALSE;
        }
        else {
            if (s_lstrcmp(szLeft, szRight) <= 0)
                *result = TRUE;
            else
                *result = FALSE;
        }
        break;
    case DBASE_NUMERIC:
    case DBASE_FLOAT:
        if (!descending) {
            if (dblLeft >= dblRight)
                *result = TRUE;
            else
                *result = FALSE;
        }
        else {
            if (dblLeft <= dblRight)
                *result = TRUE;
            else
                *result = FALSE;
        }
        break;
    }
*/
    return DBASE_ERR_SUCCESS;

}
/***************************************************************************/

SWORD FAR PASCAL dBaseQuickSort(LPDBASEFILE f, UWORD icol, BOOL descending,
                                UDWORD FAR *sortArray, UDWORD left,
                                UDWORD right)
{
/*
    UDWORD i;
    UDWORD j;
    UDWORD temp;
    SWORD err;
    BOOL result;

    // Q1: 
    if (right <= left)
        return DBASE_ERR_SUCCESS;
        
    // Q2: 
    i = left;
    j = right+1;

    while (TRUE) {

        // Q3: 
        while (TRUE) {
            i++;
            err = dBaseQuickSortKeyCompare(f, icol, descending,
                                  sortArray[i], sortArray[left], &result);
            if (err != DBASE_ERR_SUCCESS)
                return err;
            if (result)
                break;
        }

        // Q4: 
        while (TRUE) {
            j--;
            err = dBaseQuickSortKeyCompare(f, icol, descending,
                                  sortArray[left], sortArray[j], &result);
            if (err != DBASE_ERR_SUCCESS)
                return err;
            if (result)
                break;
        }

        // Q5: 
        if (j <= i)
            break;

        // Q6: 
        temp = sortArray[j];
        sortArray[j] = sortArray[i];
        sortArray[i] = temp;
    }

    // Q5: 
    temp = sortArray[left];
    sortArray[left] = sortArray[j];
    sortArray[j] = temp;

    // Q7: 
    err = dBaseQuickSort(f, icol, descending, sortArray, left, j-1);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Q8: 
    err = dBaseQuickSort(f, icol, descending, sortArray, j+1, right);
    if (err != DBASE_ERR_SUCCESS)
        return err;
*/
    return DBASE_ERR_SUCCESS;

}
/***************************************************************************/
/***************************************************************************/

SWORD FAR PASCAL dBaseCreate(LPUSTR name)
{
/*
    UCHAR FAR * ptr;
    DBASEFILE header;
    HFILE hf;
    int i;
    HANDLE h;
    UCHAR NEAR *fullname;
    UCHAR c;
    HANDLE ht;
    time_t *t;
    struct tm *ts;

    // Get the filename 
    h = LocalAlloc(LMEM_MOVEABLE, DBASE_MAX_PATHNAME_SIZE+1);
    fullname = (UCHAR NEAR *) LocalLock(h);
    lstrcpy(fullname, name);
    ptr = fullname + lstrlen(fullname);
    while ((ptr != fullname) && (*ptr != '\\') && (*ptr != ':') &&
           (*ptr != '.'))
        ptr--;
    if (*ptr != '.')
        lstrcat(fullname, ".dbf");

    // Open the file 
    hf = _lcreat(fullname, 0);
    if (hf == HFILE_ERROR) {
        LocalUnlock(h);
        LocalFree(h);
        return DBASE_ERR_CREATEERROR;
    }

    // Set up the header 
    header.flag = DBASE_3_FILE;
    ht = LocalAlloc(LMEM_MOVEABLE, sizeof(time_t));
    t = (time_t NEAR *) LocalLock(ht);
    time(t);
    ts = localtime(t);
    LocalUnlock(ht);
    LocalFree(ht);
    header.year = ts->tm_year;
    header.month = ts->tm_mon + 1;
    header.day = ts->tm_mday;
    header.recordCount = 0;
    header.headerSize = DBASE_HEADER_LENGTH + 1;
    header.recordSize = 1;
    for (i=0; (i < 2); i++)
        header.reserved1[i] = 0;
    header.transaction = 0;
    header.encrypted = DBASE_NOT_ENCRYPTED;
    for (i=0; (i < 12); i++)
        header.reserved2[i] = 0;
    header.mdx = DBASE_MDX_FLAG_OFF;
    for (i=0; (i < 3); i++)
        header.reserved3[i] = 0;

    // Write the header 
    if (DBASE_HEADER_LENGTH != _lwrite(hf, (LPSTR) &header,
                                       DBASE_HEADER_LENGTH)) {
        _lclose(hf);
        AnsiToOem(fullname, fullname);
#ifdef WIN32
        DeleteFile(fullname);
#else
        remove(fullname);
#endif
        LocalUnlock(h);
        LocalFree(h);
        return DBASE_ERR_WRITEERROR;
    }

    // Write the end-of-columns mark 
    c = DBASE_END_OF_COLUMNS;
    if (1 != _lwrite(hf, &c, 1)) {
        _lclose(hf);
        AnsiToOem(fullname, fullname);
#ifdef WIN32
        DeleteFile(fullname);
#else
        remove(fullname);
#endif
        LocalUnlock(h);
        LocalFree(h);
        return DBASE_ERR_WRITEERROR;
    }

    // Write the end-of-data mark 
    c = DBASE_FILE_END;
    if (1 != _lwrite(hf, &c, 1)) {
        _lclose(hf);
        AnsiToOem(fullname, fullname);
#ifdef WIN32
        DeleteFile(fullname);
#else
        remove(fullname);
#endif
        LocalUnlock(h);
        LocalFree(h);
        return DBASE_ERR_WRITEERROR;
    }

    // Close the file 
    if (HFILE_ERROR == _lclose(hf)) {
        AnsiToOem(fullname, fullname);
#ifdef WIN32
        DeleteFile(fullname);
#else
        remove(fullname);
#endif
        LocalUnlock(h);
        LocalFree(h);
        return DBASE_ERR_CLOSEERROR;
    }
    LocalUnlock(h);
    LocalFree(h);
*/
    return DBASE_ERR_SUCCESS;

}

/***************************************************************************/

SWORD FAR PASCAL dBaseAddColumn(LPUSTR name, LPUSTR colName, UCHAR type,
                               UCHAR length, UCHAR scale)
{
/*
    LPDBASEFILE f;
    LPSTR from;
    int i;
    LONG offset;
    UCHAR c;
    SWORD err;

    // Check the column name 
    if (lstrlen(colName) > DBASE_COLUMN_NAME_SIZE)
        return DBASE_ERR_NOTSUPPORTED;

    // Check the length and scale 
    switch (type) {
    case DBASE_CHAR:
        if ((length == 0) || (length > 254))
            return DBASE_ERR_NOTSUPPORTED;
        scale = 0;
        break;
    case DBASE_NUMERIC:
    case DBASE_FLOAT:
        if ((length == 0) || (length > 19))
            return DBASE_ERR_NOTSUPPORTED;
        if (length == 1) {
            if (scale != 0)
                return DBASE_ERR_NOTSUPPORTED;
        }
        else if (((UCHAR) (scale+2)) > length)
            return DBASE_ERR_NOTSUPPORTED;
        break;
    case DBASE_LOGICAL:
        length = 1;
        scale = 0;
        break;
    case DBASE_DATE:
        length = 8;
        scale = 0;
        break;
    case DBASE_MEMO:
        return DBASE_ERR_NOTSUPPORTED;
    default:
        return DBASE_ERR_NOTSUPPORTED;
    }

    // Open the file 
    err = dBaseExtendedOpen(name, FALSE, 1, &f) ;
    if (err != DBASE_ERR_SUCCESS)
        return err;

    if (f->recordCount != 0) {
        dBaseClose(f);
        return DBASE_ERR_NOTSUPPORTED;
    }

    // Fill in the new entry 
    from = colName;
    for (i=0; (i < DBASE_COLUMN_NAME_SIZE); i++) {
        f->column[f->columnCount].name[i] = *from;
        if (*from != 0)
            from++;
    }
    f->column[f->columnCount].type = type;
    for (i=0; (i < 4); i++)
        f->column[f->columnCount].reserved1[i] = 0;
    f->column[f->columnCount].length = length;
    f->column[f->columnCount].scale = scale;
    for (i=0; (i < 2); i++)
        f->column[f->columnCount].reserved2[i] = 0;
    f->column[f->columnCount].workarea = 0;
    for (i=0; (i < 10); i++)
        f->column[f->columnCount].reserved3[i] = 0;
    f->column[f->columnCount].mdx = DBASE_MDX_FLAG_OFF;
    f->column[f->columnCount].value = NULL;

    // Write the new column information 
    offset = DBASE_HEADER_LENGTH + (f->columnCount*DBASE_COLUMN_DESCR_LENGTH);
    if (HFILE_ERROR == _llseek(f->hf, offset, 0)) {
        dBaseClose(f);
        return DBASE_ERR_CORRUPTFILE;
    }
    AnsiToOemBuff(f->column[f->columnCount].name, 
                  f->column[f->columnCount].name, DBASE_COLUMN_NAME_SIZE);
    if (DBASE_COLUMN_DESCR_LENGTH != _lwrite(f->hf, (LPSTR)
                &(f->column[f->columnCount]), DBASE_COLUMN_DESCR_LENGTH)) {
        dBaseClose(f);
        return DBASE_ERR_WRITEERROR;
    }

    // Adust header information 
    (f->columnCount)++;
    f->headerSize += DBASE_COLUMN_DESCR_LENGTH;
    f->recordSize += length;
    if (type == DBASE_FLOAT)
        f->flag = DBASE_4_FILE;

    // Put in end-of-columns mark 
    c = DBASE_END_OF_COLUMNS;
    if (1 != _lwrite(f->hf, &c, 1)) {
        dBaseClose(f);
        return DBASE_ERR_WRITEERROR;
    }

    // Put in end-of-data mark 
    c = DBASE_FILE_END;
    if (1 != _lwrite(f->hf, &c, 1)) {
        dBaseClose(f);
        return DBASE_ERR_WRITEERROR;
    }

    // Close the file 
    f->headerDirty = TRUE;
    err = dBaseClose(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;
*/
    return DBASE_ERR_SUCCESS;

}

/***************************************************************************/

SWORD FAR PASCAL dBaseOpen(LPUSTR name, BOOL fReadOnly, LPDBASEFILE FAR *lpf)
{
    return dBaseExtendedOpen(name, fReadOnly, 0, lpf);
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnCount(LPDBASEFILE f, UWORD FAR *count)
{
//  *count = f->columnCount;
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnName(LPDBASEFILE f, UWORD icol, LPUSTR name)
{
/*
    int i;

    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;

    for (i = 0; i < DBASE_COLUMN_NAME_SIZE; i++)
        name[i] = f->column[icol-1].name[i];
    name[DBASE_COLUMN_NAME_SIZE] = '\0';
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnType(LPDBASEFILE f, UWORD icol, UCHAR FAR *type)
{
/*
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;

    *type = f->column[icol-1].type;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnLength(LPDBASEFILE f, UWORD icol, UCHAR FAR *len)
{
/*
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;

    *len = f->column[icol-1].length;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnScale(LPDBASEFILE f, UWORD icol, UCHAR FAR *scale)
{
/*
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;

    *scale = f->column[icol-1].scale;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseSort(LPDBASEFILE f, UWORD icol, BOOL descending)
{
/*
    SWORD err;
    HANDLE h;
    UDWORD FAR *sortArray;
    UDWORD idx;

    // Make sure column is really there 
    if ((icol > f->columnCount) || (icol < 0))
        return DBASE_ERR_NOSUCHCOLUMN;

    // Write back any pending writes 
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Remove sort order (if any) 
    if (f->sortArray != NULL) {
        GlobalUnlock(GlobalPtrHandle (f->sortArray));
        GlobalFree(GlobalPtrHandle(f->sortArray));
        f->sortArray = NULL;
    }

    // Is there a new sort? 
    if (icol != 0) {

        // Yes.  Allocate space for new sort 
        h = GlobalAlloc (GMEM_MOVEABLE, (sizeof(UDWORD) * (f->recordCount + 2)));
        if (h == NULL || (sortArray = (UDWORD FAR *)GlobalLock (h)) == NULL)
            return DBASE_ERR_MEMALLOCFAIL;

        // Fill in the sort array 
        sortArray[0] = FIRST_RECORD;
        for (idx = 1; idx < f->recordCount+1; idx++)
            sortArray[idx] = idx-1;
        sortArray[f->recordCount+1] = LAST_RECORD;

        // Sort the records 
        f->currentRecord = 1;
        err = dBaseQuickSort(f, icol, descending, sortArray, 1, f->recordCount);
        if (err != DBASE_ERR_SUCCESS) {
            f->currentRecord = 0;
            GlobalUnlock(h);
            GlobalFree(h);
            return err;
        }
        f->currentRecord = 0;

        // Move the items into place 
        for (idx = 0; idx < f->recordCount; idx++)
            sortArray[idx] = sortArray[idx+1];
        sortArray[f->recordCount] = f->recordCount;
        f->sortArray = sortArray;
    }

    // Position before record 
    f->currentRecord = 0;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseReadFirst(LPDBASEFILE f)
{
/*
    LONG offset;
    SWORD err;
    UWORD size;
    UDWORD currentRecord;

    // Write back any pending writes 
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Position to the first record 
    if (f->sortArray == NULL)
        currentRecord = 0;
    else
        currentRecord = f->sortArray[0];
    offset = f->headerSize + (currentRecord * f->recordSize);
    if (HFILE_ERROR == _llseek(f->hf, offset, 0))
        return DBASE_ERR_CORRUPTFILE;

    // Read the record 
    size = _lread(f->hf, f->record, f->recordSize);
    if (size == 1) {
        if (*(f->record) == DBASE_FILE_END)
            return DBASE_ERR_NODATAFOUND;
        else
            return DBASE_ERR_CORRUPTFILE;
    }
    if (size != f->recordSize)
        return DBASE_ERR_CORRUPTFILE;
    f->currentRecord = 1;

    // If this record is deleted, return next record 
    if (*(f->record) == DBASE_RECORD_DELETED)
        return dBaseReadNext(f);

    // Return record 
    OemToAnsiBuff(f->record, f->record, f->recordSize);
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseReadNext(LPDBASEFILE f)
{
/*
    LONG offset;
    SWORD err;
    UWORD size;
    UDWORD currentRecord;

    // Write back any pending writes 
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Position to the next record 
    if (f->sortArray == NULL)
        currentRecord = f->currentRecord;
    else
        currentRecord = f->sortArray[f->currentRecord];
    offset = f->headerSize + (currentRecord * f->recordSize);
    if (HFILE_ERROR == _llseek(f->hf, offset, 0))
        return DBASE_ERR_CORRUPTFILE;

    // Read the record 
    size = _lread(f->hf, f->record, f->recordSize);
    if (size == 1) {
        if (*(f->record) == DBASE_FILE_END)
            return DBASE_ERR_NODATAFOUND;
        else
            return DBASE_ERR_CORRUPTFILE;
    }
    if (size != f->recordSize)
        return DBASE_ERR_CORRUPTFILE;
    f->currentRecord++;

    // If this record is deleted, return next record 
    if (*(f->record) == DBASE_RECORD_DELETED)
        return dBaseReadNext(f);

    // Return record 
    OemToAnsiBuff(f->record, f->record, f->recordSize);
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnCharVal(LPDBASEFILE f, UWORD icol, UDWORD offset,
                                   SDWORD bufsize, UCHAR FAR *val,
                                   BOOL FAR *isNull)
{
/*

    LPDBASECOL lpCol;
    UCHAR FAR *fromPtr;
    UCHAR FAR *toPtr;
    UCHAR i;
    UWORD year;
    UWORD month;
    UWORD day;
*/
    SWORD err;
/*
    // Make sure data is really there 
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    // Get the data 
    lpCol = &(f->column[icol-1]);
    fromPtr = lpCol->value;
*/
    err = DBASE_ERR_SUCCESS;
/*
    switch (lpCol->type) {
    case DBASE_CHAR:
        toPtr = val;
        *isNull = TRUE;
        if (bufsize <= ((SDWORD) lpCol->length)) {
            err = DBASE_ERR_TRUNCATION;
        }
        else {
            bufsize = lpCol->length;
        }
        for (i=0; i < (UCHAR) bufsize; i++) {
            if (*fromPtr != ' ')
                *isNull = FALSE;
            if (toPtr != NULL) {
                *toPtr = *fromPtr;
                toPtr++;
            }
            fromPtr++;
        }
        if (toPtr != NULL)
            *toPtr = '\0';
        break;
    case DBASE_FLOAT:
    case DBASE_NUMERIC:
        i = lpCol->length;
        while ((*fromPtr == ' ') && (i > 0)) {
            fromPtr++;
            i--;
        }
        toPtr = val;
        *isNull = TRUE;
        for (;i > 0; i--) {
            if (toPtr != NULL) {
                *toPtr = *fromPtr;
                toPtr++;
            }
            fromPtr++;
            *isNull = FALSE;
        }
        if (toPtr != NULL)
            *toPtr = '\0';
        break;
    case DBASE_DATE:
        if (*fromPtr == ' ')
            *isNull = TRUE;
        else {
            *isNull = FALSE;
            year = ((fromPtr[0] & 0x0F) * 1000) +
               ((fromPtr[1] & 0x0F) * 100) +
               ((fromPtr[2] & 0x0F) * 10) +
                (fromPtr[3] & 0x0F);
            month = ((fromPtr[4] & 0x0F) * 10) + (fromPtr[5] & 0x0F);
            day = ((fromPtr[6] & 0x0F) * 10) + (fromPtr[7] & 0x0F);
            if (val != NULL)
                wsprintf(val, "%04d-%02d-%02d", year, month, day);
        }
        break;
    case DBASE_LOGICAL:
        switch (*fromPtr) {
        case 'Y':
        case 'y':
        case 'T':
        case 't':
        case '1':
            if (val != NULL)
                lstrcpy(val, "1");
            *isNull = FALSE;
            break;
        case 'N':
        case 'n':
        case 'F':
        case 'f':
        case '0':
            if (val != NULL)
                lstrcpy(val, "0");
            *isNull = FALSE;
            break;
        case '?':
        case ' ':
            *isNull = TRUE;
            break;
        }
        break;
    case DBASE_MEMO:
        *isNull = TRUE;
        break;
    }
    if ((*isNull) && (val != NULL))
        lstrcpy(val, "");
*/
    return err;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseColumnNumVal(LPDBASEFILE f, UWORD icol,
                                  SDOUBLE FAR *val, BOOL FAR *isNull)
{
/*
    LPDBASECOL lpCol;
    UCHAR i;
    double d;
    BOOL neg;
    UCHAR FAR *fromPtr;
    BOOL foundDecimalPoint;
    short scale;
    BOOL negexp;
    short exp;

    // Make sure data is really there 
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    // Get the data 
    lpCol = &(f->column[icol-1]);
    fromPtr = lpCol->value;
    switch (lpCol->type) {
    case DBASE_CHAR:
    case DBASE_FLOAT:
    case DBASE_NUMERIC:
        *isNull = TRUE;
        for (i=0; i < lpCol->length; i++) {
            if (*fromPtr != ' ')
                break;
            fromPtr++;
        }

        neg = FALSE;
        if (i < lpCol->length) {
            if (*fromPtr == '-') {
                neg = TRUE;
                fromPtr++;
                i++;
            }
        }

        d = 0.0;
        scale = 0;
        foundDecimalPoint = FALSE;
        for (;i < lpCol->length; i++) {
            if (!foundDecimalPoint && (*fromPtr == '.'))
                foundDecimalPoint = TRUE;
            else {
                if ((*fromPtr == 'E') || (*fromPtr == 'e')) {
                    fromPtr++;
                    i++;
                    if (i < lpCol->length) { 
                        if (*fromPtr == '-') {
                            negexp = TRUE;
                            fromPtr++;
                            i++;
                        }
                        else if (*fromPtr == '+') {
                            negexp = FALSE;
                            fromPtr++;
                            i++;
                        }
                        else
                            negexp = FALSE;
                    }
                    else
                        negexp = FALSE;
                    exp = 0;
                    for (;i < lpCol->length; i++) {
                        if ((*fromPtr < '0') || (*fromPtr > '9'))
                           return DBASE_ERR_CONVERSIONERROR;
                        exp = (exp * 10) + (*fromPtr - '0');
                        fromPtr++;
                    }
                    if (negexp)
                        scale = scale + exp;
                    else
                        scale = scale - exp;
                    break;
                }
                if ((*fromPtr < '0') || (*fromPtr > '9'))
                    return DBASE_ERR_CONVERSIONERROR;
                d = (d * 10) + (*fromPtr - '0');
                *isNull = FALSE;
                if (foundDecimalPoint)
                    scale++;
            }
            fromPtr++;
        }

        for (; (0 < scale); scale--)
            d /= 10;
        for (; (0 > scale); scale++)
            d *= 10;

        if (val != NULL) {
            if (neg)
                *val = -d;
            else
                *val = d;
        }
        break;
    case DBASE_DATE:
        return DBASE_ERR_CONVERSIONERROR;
    case DBASE_LOGICAL:
        switch (*fromPtr) {
        case 'Y':
        case 'y':
        case 'T':
        case 't':
        case '1':
            if (val != NULL)
                *val = 1.0;
            *isNull = FALSE;
            break;
        case 'N':
        case 'n':
        case 'F':
        case 'f':
        case '0':
            if (val != NULL)
                *val = 0.0;
            *isNull = FALSE;
            break;
        case '?':
        case ' ':
            *isNull = TRUE;
            break;
        }
        break;
    case DBASE_MEMO:
        *isNull = TRUE;
        break;
    }
    if ((val != NULL) && (*isNull))
        *val = 0.0;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseAddRecord(LPDBASEFILE f)
{
/*
    UWORD i;
    UCHAR FAR * ptr;
    SWORD err;

    // Write dirty record 
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Remove sort order (if any) 
    if (f->sortArray != NULL) {
        GlobalUnlock(GlobalPtrHandle(f->sortArray));
        GlobalFree(GlobalPtrHandle(f->sortArray));
        f->sortArray = NULL;
    }

    // Create null record 
    ptr = f->record;
    for (i=0; i < f->recordSize; i++) {
        *ptr = ' ';
        ptr++;
    }
    f->recordDirty = TRUE;
    f->newRecord = TRUE;

    // Increment record count 
    f->recordCount++;
    f->headerDirty = TRUE;

    // Reset current record 
    f->currentRecord = f->recordCount;
*/  
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseSetColumnCharVal(LPDBASEFILE f, UWORD icol,
                                      UCHAR FAR *val, SDWORD size)
{
/*
    LPDBASECOL lpCol;
    UCHAR FAR *fromPtr;
    UCHAR FAR *toPtr;
    UCHAR FAR *decimalLocation;
    UCHAR FAR *valStart;
    UCHAR FAR *valEnd;
    UCHAR FAR *ptr;
    UCHAR length;
    UCHAR i;
    SWORD extraZeros;
    BOOL negNeeded;
    BOOL foundExp;
    SWORD err;

    // Make sure data is really there 
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    // Set value 
    lpCol = &(f->column[icol-1]);
    toPtr = lpCol->value;
    err = DBASE_ERR_SUCCESS;
    switch (lpCol->type) {
    case DBASE_CHAR:
        fromPtr = val;
        for (i=0; i < lpCol->length; i++) {
            if (((SDWORD) i) == size)
                break;
            *toPtr = *fromPtr;
            toPtr++;
            fromPtr++;
        }
        for (; i < lpCol->length; i++) {
            *toPtr = ' ';
            toPtr++;
        }
        if (((SDWORD) lpCol->length) < size)
            err = DBASE_ERR_TRUNCATION;
        break;
    case DBASE_FLOAT:
    case DBASE_NUMERIC:

        // If a zero length string is specifed, point to a zero 
        if ((lpCol->scale == 0) && (size == 0)) {
            val = "0";
            size = 1;
        }
        
        // Point at start of value 
        length = lpCol->length - 1;
        valStart = val;
        if (*valStart == '-') {
            valStart++;
        }

        // Make sure all characters are legal and find decimal point 
        foundExp = FALSE;
        decimalLocation = NULL;
        fromPtr = valStart;
        i = 0;
        while (((SDWORD) i) < size) {
            if (*fromPtr == '\0')
                break;
            else if (*fromPtr == '.') {
                if ((decimalLocation != NULL) || (foundExp))
                    return DBASE_ERR_CONVERSIONERROR;
                decimalLocation = fromPtr;
            }
            else if ((*fromPtr == 'E') || (*fromPtr == 'e')) {
                if (foundExp)
                    return DBASE_ERR_CONVERSIONERROR;
                foundExp = TRUE;
                if ((*fromPtr == '-') || (*fromPtr == '+')) {
                    fromPtr++;
                    i++;
                }
            }
            else if (!(IsCharAlphaNumeric(*fromPtr)) || IsCharAlpha(*fromPtr))
                return DBASE_ERR_CONVERSIONERROR;
            fromPtr++;
            i++;
        }

        // Scientific notation? 
        if (foundExp) {

            // Yes.  Error if not enough room for value 
            if (size > (SDWORD) lpCol->length)
                return DBASE_ERR_CONVERSIONERROR;

            // Copy the value 
            for (i=0; (SWORD) i < (SWORD) lpCol->length - lstrlen(val); i++) {
                *toPtr = ' ';
                toPtr++;
            }
            fromPtr = val;
            while (*fromPtr) {
                *toPtr = *fromPtr;
                toPtr++;
                fromPtr++;
            }
            break;
        }

        // Find end of value 
        valEnd = fromPtr-1;
        if (decimalLocation == valEnd) {
            valEnd--;
            decimalLocation = NULL;
        }

        // Truncate extra characters at end 
        if (decimalLocation != NULL) {
            if (lpCol->scale == 0) {
                valEnd = decimalLocation-1;
                decimalLocation = NULL;
            }
            else {
                if ((SWORD) lpCol->scale < (valEnd - decimalLocation)) {
                    valEnd = decimalLocation + lpCol->scale;
                }
            }
        }

        // Figure out how many extra zeros need to be added at end 
        if (lpCol->scale == 0)
            extraZeros = 0;
        else if (decimalLocation == NULL)
            extraZeros = lpCol->scale + 1;
        else
            extraZeros = lpCol->scale - (valEnd - decimalLocation);

        // Shave off extra characters in front 
        while ((SWORD) length < (valEnd - valStart) + 1 + extraZeros)
            valStart++;

        // Put in leading spaces 
        for (i=0; 
             (SWORD) i < (length - (valEnd - valStart + 1) - extraZeros); 
             i++) {
            *toPtr = ' ';
            toPtr++;
        }

        // Put in sign if needed 
        negNeeded = FALSE;
        if (*val == '-') {
            for (ptr = valStart; ptr <= valEnd; ptr++) {
                if ((*ptr != '0') && (*ptr != '.')) {
                    negNeeded = TRUE;
                    break;
                }
            }
        }
        if (negNeeded)
            *toPtr = '-';
        else
            *toPtr = ' ';
        toPtr++;

        // Put in value 
        while (valStart <= valEnd) {
            *toPtr = *valStart;
            toPtr++;
            valStart++;
        }

        // Put in required trailing zeros 
        if (extraZeros == lpCol->scale + 1) {
            *toPtr = '.';
            toPtr++;
            extraZeros--;
        }
        while (extraZeros > 0) {
            *toPtr = '0';
            toPtr++;
            extraZeros--;
        }
        break;

    case DBASE_DATE:
        // Make sure value is legal 
        if (size != 10)
            return DBASE_ERR_CONVERSIONERROR;
        for (i=0; i < 10; i++) {
            switch (i) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 6:
            case 9:
                if (!(IsCharAlphaNumeric(val[i])) || IsCharAlpha(val[i]))
                    return DBASE_ERR_CONVERSIONERROR;
                break;
            case 4:
            case 7:
                if (val[i] != '-')
                    return DBASE_ERR_CONVERSIONERROR;
                break;
            case 5:
                if ((val[i] < '0') || (val[i] > '1'))
                    return DBASE_ERR_CONVERSIONERROR;
                break;
            case 8:
                if ((val[i] < '0') && (val[i] > '3'))
                    return DBASE_ERR_CONVERSIONERROR;
                if ((val[i] == '3') && (val[i+1] > '1'))
                    return DBASE_ERR_CONVERSIONERROR;
                break;
            }
        }

        // Copy the value 
        for (i=0; i < 4; i++) {
            *toPtr = val[i];
            toPtr++;
        }
        for (i=5; i < 7; i++) {
            *toPtr = val[i];
            toPtr++;
        }
        for (i=8; i < 10; i++) {
            *toPtr = val[i];
            toPtr++;
        }
        break;
    case DBASE_LOGICAL:
        if (size != 1)
            return DBASE_ERR_CONVERSIONERROR;
        switch (*val) {
        case 'Y':
        case 'y':
        case 'T':
        case 't':
        case '1':
            *toPtr = 'Y';
            break;
        case 'N':
        case 'n':
        case 'F':
        case 'f':
        case '0':
            *toPtr = 'N';
            break;
        case '?':
        case ' ':
            *toPtr = '?';
            break;
        default:
            return DBASE_ERR_CONVERSIONERROR;
        }
        break;
    case DBASE_MEMO:
        break;
    }
    f->recordDirty = TRUE;
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseSetColumnNull(LPDBASEFILE f, UWORD icol)
{
/*
    UCHAR i;
    LPDBASECOL lpCol;

    // Make sure data is really there 
    if ((icol > f->columnCount) || (icol <= 0))
        return DBASE_ERR_NOSUCHCOLUMN;
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    // Set value 
    lpCol = &(f->column[icol-1]);
    if (lpCol->type == DBASE_MEMO)
        return DBASE_ERR_NOTSUPPORTED;
    for (i=0; (i < f->column[icol-1].length); i++)
        f->column[icol-1].value[i] = ' ';
    f->recordDirty = TRUE;
*/
    return DBASE_ERR_SUCCESS;
}
/***************************************************************************/

SWORD FAR PASCAL dBaseDeleteRecord(LPDBASEFILE f)
{
/*
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    if (f->newRecord) {
        f->recordDirty = FALSE;
        f->newRecord = FALSE;
        f->recordCount--;
        f->headerDirty = TRUE;
        f->currentRecord = 0;
    }
    else {
        *(f->record) = DBASE_RECORD_DELETED;
        f->recordDirty = TRUE;
    }
*/  
    return DBASE_ERR_SUCCESS;
}
/***************************************************************************/
SWORD FAR PASCAL dBaseGetBookmark(LPDBASEFILE f, UDWORD far *b)
{
/*
    // Make sure data is really there 
    if (f->currentRecord == 0)
        return DBASE_ERR_NODATAFOUND;
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    if (f->sortArray == NULL)
        *b = f->currentRecord-1;
    else
        *b = f->sortArray[f->currentRecord-1];
*/
    return DBASE_ERR_SUCCESS;
}
/***************************************************************************/
SWORD FAR PASCAL dBasePosition(LPDBASEFILE f, UDWORD b)
{
/*
    LONG offset;
    SWORD err;
    UWORD size;

    // Write back any pending writes 
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;

    // Position to the specified record 
    offset = f->headerSize + (b * f->recordSize);
    if (HFILE_ERROR == _llseek(f->hf, offset, 0))
        return DBASE_ERR_CORRUPTFILE;

    // Read the record 
    size = _lread(f->hf, f->record, f->recordSize);
    if (size == 1) {
        if (*(f->record) == DBASE_FILE_END)
            return DBASE_ERR_NODATAFOUND;
        else
            return DBASE_ERR_CORRUPTFILE;
    }
    if (size != f->recordSize)
        return DBASE_ERR_CORRUPTFILE;
    f->currentRecord = b+1;

    // If this record is deleted, return error 
    if (*(f->record) == DBASE_RECORD_DELETED)
        return DBASE_ERR_NODATAFOUND;

    // Return record 
    OemToAnsiBuff(f->record, f->record, f->recordSize);
*/
    return DBASE_ERR_SUCCESS;
}
/***************************************************************************/

SWORD FAR PASCAL dBaseClose(LPDBASEFILE f)
{
/*
    SWORD err;
    HANDLE ht;
    time_t *t;
    struct tm *ts;

    if (f->headerDirty) {
        ht = LocalAlloc(LMEM_MOVEABLE, sizeof(time_t));
        t = (time_t NEAR *) LocalLock(ht);
        time(t);
        ts = localtime(t);
        LocalUnlock(ht);
        LocalFree(ht);
        f->year = ts->tm_year;
        f->month = ts->tm_mon + 1;
        f->day = ts->tm_mday;
        if (HFILE_ERROR == _llseek(f->hf, 0, 0))
            return DBASE_ERR_CORRUPTFILE; 
        if (DBASE_HEADER_LENGTH != _lwrite(f->hf, (LPSTR) f, DBASE_HEADER_LENGTH))
            return DBASE_ERR_WRITEERROR;
    }
    err = dBaseFlushDirtyRecord(f);
    if (err != DBASE_ERR_SUCCESS)
        return err;
    if (HFILE_ERROR == _lclose(f->hf))
        return DBASE_ERR_CLOSEERROR;
    if (f->sortArray != NULL) {
        GlobalUnlock(GlobalPtrHandle(f->sortArray));
        GlobalFree(GlobalPtrHandle(f->sortArray));
    }
    GlobalUnlock(GlobalPtrHandle(f));
    GlobalFree(GlobalPtrHandle(f));
*/
    return DBASE_ERR_SUCCESS;
}

/***************************************************************************/

SWORD FAR PASCAL dBaseDestroy(LPUSTR name)
{
/*
    UCHAR FAR * ptr;
    HANDLE h;
    UCHAR NEAR *fullname;

    // Get the filename 
    h = LocalAlloc(LMEM_MOVEABLE, DBASE_MAX_PATHNAME_SIZE+1);
    fullname = (UCHAR NEAR *) LocalLock(h);
    lstrcpy(fullname, name);
    ptr = fullname + lstrlen(fullname);
    while ((ptr != fullname) && (*ptr != '\\') && (*ptr != ':') &&
           (*ptr != '.'))
        ptr--;
    if (*ptr != '.')
        lstrcat(fullname, ".dbf");

    AnsiToOem(fullname, fullname);
#ifdef WIN32
    DeleteFile(fullname);
#else
    remove(fullname);
#endif
    LocalUnlock(h);
    LocalFree(h);
*/
    return DBASE_ERR_SUCCESS;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\dbase.h ===
/***************************************************************************/
/* DBASE.H                                                                 */
/* Copyright 1993-96 SYWARE, Inc.  All rights reserved.                    */
/***************************************************************************/
#ifdef _UNIX_

#include "unixdefs.h"
#include "sqltype.h"

#else

#include "windows.h"
#include "windowsx.h"

typedef unsigned char FAR*           LPUSTR;

//#define ODBCVER 0x0210
#include <sql.h>
#include <sqlext.h>
#ifndef RC_INVOKED
#ifndef WIN32
#include <dos.h>
#endif
#endif

#endif

#ifdef _UNIX_
#define PATH_SEPARATOR_CHAR '/'
#define PATH_SEPARATOR_STR  "/"
#else
#define PATH_SEPARATOR_CHAR '\\'
#define PATH_SEPARATOR_STR  "\\"
#endif


#define DBASE_ERR_SUCCESS            0
#define DBASE_ERR_MEMALLOCFAIL       1
#define DBASE_ERR_NODATAFOUND        2
#define DBASE_ERR_WRITEERROR         3
#define DBASE_ERR_TABLEACCESSERROR   4
#define DBASE_ERR_CONVERSIONERROR    5
#define DBASE_ERR_CORRUPTFILE        6
#define DBASE_ERR_CREATEERROR        7
#define DBASE_ERR_CLOSEERROR         8
#define DBASE_ERR_NOTSUPPORTED       9
#define DBASE_ERR_NOSUCHCOLUMN      10
#define DBASE_ERR_TRUNCATION        11
#define DBASE_ERR_NOTNULL           12
#define DBASE_ERR_NULL              13

#define DBASE_MAX_PATHNAME_SIZE 127

#define DBASE_COLUMN_NAME_SIZE 11
typedef struct  tagDBASECOL {
	/* The following fields are in the disk file */
	UCHAR   name[DBASE_COLUMN_NAME_SIZE];
	UCHAR   type;
	UCHAR   reserved1[4];
	UCHAR   length;
	UCHAR   scale;
	UCHAR   reserved2[2];
	UCHAR   workarea;
	UCHAR   reserved3[10];
	UCHAR   mdx;
	/* The following fields are not in the disk file */
	UCHAR FAR * value;
}       DBASECOL,
	FAR *LPDBASECOL;

//forward declaration
class CSafeIEnumWbemClassObject;


#define IMPLTMT_PASSTHROUGH			1
#define BATCH_NUM_OF_INSTANCES		10
typedef struct  tagDBASEFILE {
	UWORD					columnCount;
	UDWORD FAR*				sortArray;


	UDWORD					currentRecord;
	CSafeIEnumWbemClassObject*	tempEnum;
	CMapWordToPtr*			pAllRecords;	//only next 10 for passthrough SQL
	IWbemClassObject*		record;

	//Passthrough SQL specific
	BOOL					fMoreToCome;	//flag to indicate if there are more instances to fetch



}       DBASEFILE,
	FAR * LPDBASEFILE;


#define DBASE_HEADER_LENGTH             32
#define DBASE_COLUMN_DESCR_LENGTH       32
#define DBASE_RECORD_LENGTH_OFFSET      10
#define DBASE_HEADER_SIZE_OFFSET         8
#define DBASE_NOT_ENCRYPTED       0x00
#define DBASE_MDX_FLAG_OFF        0x00
#define DBASE_END_OF_COLUMNS      0x0D
#define DBASE_RECORD_DELETED      0x2A
#define DBASE_RECORD_NOT_DELETED  0x20
#define DBASE_FILE_END            0x1A
#define DBASE_3_FILE              0x03
#define DBASE_4_FILE              0x03
#define DBASE_CHAR         'C'
#define DBASE_NUMERIC      'N'
#define DBASE_FLOAT        'F'
#define DBASE_LOGICAL      'L'
#define DBASE_DATE         'D'
#define DBASE_MEMO         'M'

/***************************************************************************/
SWORD FAR PASCAL dBaseCreate(LPUSTR);
SWORD FAR PASCAL dBaseAddColumn(LPUSTR, LPUSTR, UCHAR, UCHAR, UCHAR);
SWORD FAR PASCAL dBaseOpen(LPUSTR, BOOL, LPDBASEFILE FAR *);
SWORD FAR PASCAL dBaseColumnCount(LPDBASEFILE, UWORD FAR *);
SWORD FAR PASCAL dBaseColumnName(LPDBASEFILE, UWORD, LPUSTR);
SWORD FAR PASCAL dBaseColumnType(LPDBASEFILE, UWORD, UCHAR FAR *);
SWORD FAR PASCAL dBaseColumnLength(LPDBASEFILE, UWORD, UCHAR FAR *);
SWORD FAR PASCAL dBaseColumnScale(LPDBASEFILE, UWORD, UCHAR FAR *);
SWORD FAR PASCAL dBaseSort(LPDBASEFILE, UWORD, BOOL);
SWORD FAR PASCAL dBaseReadFirst(LPDBASEFILE);
SWORD FAR PASCAL dBaseReadNext(LPDBASEFILE);
SWORD FAR PASCAL dBaseColumnCharVal(LPDBASEFILE, UWORD, UDWORD, SDWORD, UCHAR FAR *, BOOL FAR *);
SWORD FAR PASCAL dBaseColumnNumVal(LPDBASEFILE, UWORD, SDOUBLE FAR *, BOOL FAR *);
SWORD FAR PASCAL dBaseAddRecord(LPDBASEFILE);
SWORD FAR PASCAL dBaseSetColumnCharVal(LPDBASEFILE, UWORD, UCHAR FAR *, SDWORD);
SWORD FAR PASCAL dBaseSetColumnNull(LPDBASEFILE, UWORD);
SWORD FAR PASCAL dBaseDeleteRecord(LPDBASEFILE);
SWORD FAR PASCAL dBaseGetBookmark(LPDBASEFILE, UDWORD far *);
SWORD FAR PASCAL dBasePosition(LPDBASEFILE, UDWORD);
SWORD FAR PASCAL dBaseClose(LPDBASEFILE);
SWORD FAR PASCAL dBaseDestroy(LPUSTR);
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\evaluate.h ===
/***************************************************************************/
/* EVALUATE.H                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

typedef struct  tagSTMT      FAR *LPSTMT;

RETCODE INTFUNC SetParameterValue(LPSTMT, LPSQLNODE, SDWORD FAR *, SWORD, PTR, SDWORD);
RETCODE INTFUNC EvaluateExpression(LPSTMT, LPSQLNODE);
RETCODE INTFUNC FetchRow(LPSTMT, LPSQLNODE);
RETCODE INTFUNC ExecuteQuery(LPSTMT, LPSQLNODE);

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\drdbdr.h ===
/***************************************************************************/
/* DRDBDR.H                                                                */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

//#define WINVER 0x0400
#include  <windows.h>
#ifndef RC_INVOKED
#include  <windowsx.h>
#include  <string.h>
#ifndef WIN32
#include  <dos.h>
#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#endif
#endif

//#define ODBCVER 0x0210
#include <sql.h>
#include <sqlext.h>

typedef struct  tagENV       FAR *LPENV;
typedef struct  tagDBC       FAR *LPDBC;
typedef struct  tagSTMT      FAR *LPSTMT;
typedef struct  tagBOUND     FAR *LPBOUND;
typedef struct  tagPARAMETER FAR *LPPARAMETER;

/* C++ LPSTR -> LPUSTR */
typedef unsigned char FAR*           LPUSTR;
typedef const unsigned char FAR*     LPCUSTR;
#define s_lstrcpy(a, b) lstrcpy((LPSTR) a, (LPCSTR) b)
#define s_lstrcat(a, b) lstrcat((LPSTR) a, (LPCSTR) b)
#define s_lstrlen(a) lstrlen((LPCSTR) a)
#define s_lstrcmp(a, b) lstrcmp((LPCSTR) a, (LPCSTR) b)
#define s_lstrcmpi(a, b) lstrcmpi((LPCSTR) a, (LPCSTR) b)

//FOR TRACING
#ifdef WBEMDR32_TRACING
//#define ODBCTRACE OutputDebugString
	#ifndef __DUHDOSOMETHINGING
		#define ODBCTRACE __DuhDoSomething
		void __DuhDoSomething(LPCTSTR myStr,...); 
		#define __DUHDOSOMETHINGING
	#endif
#else
	#ifndef __DUHDONOTHING
		inline void __DuhDoNothing(...) {}
		#define __DUHDONOTHING
	#endif
	#define ODBCTRACE __DuhDoNothing
#endif //WBEMDR32_TRACING


#include "util.h"
#include "sqltype.h"
#include <objbase.h>
#include <initguid.h>

#include "resource.h"
#include "conndlg.h"
#include "isam.h"
#include "parse.h"
#include "bcd.h"
#include "semantic.h"
#include "optimize.h"
#include "evaluate.h"
#include "scalar.h"

/***************************************************************************/
/*      Definitions to be used in function prototypes.                     */
/*      The SQL_API is to be used only for those functions exported for    */
/*              driver manager use.                                        */
/*      The INSTAPI is to be used only for those functions exported for    */
/*              driver administrator use.                                  */
/*      The EXPFUNC is to be used only for those functions exported but    */
/*              used internally, ie, dialog procs.                         */
/*      The INTFUNC is to be used for all other functions.                 */

#ifdef WIN32

#ifndef INTFUNC
#define INTFUNC  __stdcall
#endif

#define EXPFUNC  __stdcall
#else
#define INTFUNC PASCAL
#define EXPFUNC __export CALLBACK
#endif

#ifndef WIN32
#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#endif

/***************************************************************************/

#define BEFORE_FIRST_ROW (-1)
#define AFTER_LAST_ROW (-2)

#define NO_COLUMN 0

extern HINSTANCE NEAR s_hModule;        /* DLL/EXE module handle. */

/* Maximum sizes */
#define MAX_TOKEN_SIZE MAX_CHAR_LITERAL_LENGTH
#define MAX_DRIVER_LENGTH 255
#define MAX_CURSOR_NAME_LENGTH 19
#define MAX_PATHNAME_SIZE MAX_PATH //was 127
#define MAX_COLUMNS_IN_GROUP_BY MAX_COLUMNS_IN_ORDER_BY
#define MAX_BOOLFLAG_LENGTH 5
#define MAX_KEYWORD_SEPARATOR_LENGTH 142 //was 134
#define MAX_KEY_NAME_LENGTH 63




#define NULL_FLAG     'N'
#define NOT_NULL_FLAG ' '

/***************************************************************************/
/* Error codes (also used as string ids in the resource file) */

#define ERR_SUCCESS           NO_ISAM_ERR

#define ERR_MEMALLOCFAIL      (LAST_ISAM_ERROR_CODE +  1)
#define ERR_DATATRUNCATED     (LAST_ISAM_ERROR_CODE +  2)
#define ERR_NOTSUPPORTED      (LAST_ISAM_ERROR_CODE +  3)
#define ERR_INVALIDCURSORNAME (LAST_ISAM_ERROR_CODE +  4)
#define ERR_CURSORNAMEINUSE   (LAST_ISAM_ERROR_CODE +  5)
#define ERR_CONNECTIONINUSE   (LAST_ISAM_ERROR_CODE +  6)
#define ERR_CURSORSTATE       (LAST_ISAM_ERROR_CODE +  7)
#define ERR_INVALIDCOLUMNID   (LAST_ISAM_ERROR_CODE +  8)
#define ERR_NOTCONVERTABLE    (LAST_ISAM_ERROR_CODE +  9)
#define ERR_NOTCAPABLE        (LAST_ISAM_ERROR_CODE + 10)
#define ERR_OUTOFRANGE        (LAST_ISAM_ERROR_CODE + 11)
#define ERR_ASSIGNMENTERROR   (LAST_ISAM_ERROR_CODE + 12)
#define ERR_UNEXPECTEDEND     (LAST_ISAM_ERROR_CODE + 13)
#define ERR_ELEMENTTOOBIG     (LAST_ISAM_ERROR_CODE + 14)
#define ERR_EXPECTEDOTHER     (LAST_ISAM_ERROR_CODE + 15)
#define ERR_MALFORMEDNUMBER   (LAST_ISAM_ERROR_CODE + 16)
#define ERR_UNEXPECTEDTOKEN   (LAST_ISAM_ERROR_CODE + 17)
#define ERR_BADESCAPE         (LAST_ISAM_ERROR_CODE + 18)
#define ERR_INTERNAL          (LAST_ISAM_ERROR_CODE + 19)
#define ERR_ISAM              (LAST_ISAM_ERROR_CODE + 20)
#define ERR_COLUMNNOTFOUND    (LAST_ISAM_ERROR_CODE + 21)
#define ERR_UNKNOWNTYPE       (LAST_ISAM_ERROR_CODE + 22)
#define ERR_INVALIDOPERAND    (LAST_ISAM_ERROR_CODE + 23)
#define ERR_INVALIDTABLENAME  (LAST_ISAM_ERROR_CODE + 24)
#define ERR_ORDINALTOOLARGE   (LAST_ISAM_ERROR_CODE + 25)
#define ERR_ORDERBYTOOLARGE   (LAST_ISAM_ERROR_CODE + 26)
#define ERR_ORDERBYCOLUMNONLY (LAST_ISAM_ERROR_CODE + 27)
#define ERR_UNEQUALINSCOLS    (LAST_ISAM_ERROR_CODE + 28)
#define ERR_INVALIDINSVAL     (LAST_ISAM_ERROR_CODE + 29)
#define ERR_INVALIDINVAL      (LAST_ISAM_ERROR_CODE + 30)
#define ERR_ALIASINUSE        (LAST_ISAM_ERROR_CODE + 31)
#define ERR_COLUMNONLIST      (LAST_ISAM_ERROR_CODE + 32)
#define ERR_INVALIDCOLNAME    (LAST_ISAM_ERROR_CODE + 33)
#define ERR_NOSUCHTYPE        (LAST_ISAM_ERROR_CODE + 34)
#define ERR_BADPARAMCOUNT     (LAST_ISAM_ERROR_CODE + 35)
#define ERR_COLUMNFOUND       (LAST_ISAM_ERROR_CODE + 36)
#define ERR_NODATAFOUND       (LAST_ISAM_ERROR_CODE + 37)
#define ERR_INVALIDCONNSTR    (LAST_ISAM_ERROR_CODE + 38)
#define ERR_UNABLETOCONNECT   (LAST_ISAM_ERROR_CODE + 39)
#define ERR_PARAMETERMISSING  (LAST_ISAM_ERROR_CODE + 40)
#define ERR_DESCOUTOFRANGE    (LAST_ISAM_ERROR_CODE + 41)
#define ERR_OPTOUTOFRANGE     (LAST_ISAM_ERROR_CODE + 42)
#define ERR_INFOUTOFRANGE     (LAST_ISAM_ERROR_CODE + 43)
#define ERR_CANTORDERBYONTHIS (LAST_ISAM_ERROR_CODE + 44)
#define ERR_SORT              (LAST_ISAM_ERROR_CODE + 45)
#define ERR_GROUPBYTOOLARGE   (LAST_ISAM_ERROR_CODE + 46)
#define ERR_CANTGROUPBYONTHIS (LAST_ISAM_ERROR_CODE + 47)
#define ERR_AGGNOTALLOWED     (LAST_ISAM_ERROR_CODE + 48)
#define ERR_NOSELECTSTAR      (LAST_ISAM_ERROR_CODE + 49)
#define ERR_GROUPBY           (LAST_ISAM_ERROR_CODE + 50)
#define ERR_NOGROUPBY         (LAST_ISAM_ERROR_CODE + 51)
#define ERR_ZERODIVIDE        (LAST_ISAM_ERROR_CODE + 52)
#define ERR_PARAMINSELECT     (LAST_ISAM_ERROR_CODE + 53)
#define ERR_CONCATOVERFLOW    (LAST_ISAM_ERROR_CODE + 54)
#define ERR_INVALIDINDEXNAME  (LAST_ISAM_ERROR_CODE + 55)
#define ERR_TOOMANYINDEXCOLS  (LAST_ISAM_ERROR_CODE + 56)
#define ERR_SCALARNOTFOUND    (LAST_ISAM_ERROR_CODE + 57)
#define ERR_SCALARBADARG      (LAST_ISAM_ERROR_CODE + 58)
#define ERR_SCALARNOTSUPPORTED (LAST_ISAM_ERROR_CODE + 59)
#define ERR_TXNINPROGRESS     (LAST_ISAM_ERROR_CODE + 60)
#define ERR_DDLENCOUNTERD     (LAST_ISAM_ERROR_CODE + 61)
#define ERR_DDLIGNORED        (LAST_ISAM_ERROR_CODE + 62)
#define ERR_DDLCAUSEDACOMMIT  (LAST_ISAM_ERROR_CODE + 63)
#define ERR_DDLSTATEMENTLOST  (LAST_ISAM_ERROR_CODE + 64)
#define ERR_MULTICOLUMNSELECT (LAST_ISAM_ERROR_CODE + 65)
#define ERR_NOTSINGLESELECT   (LAST_ISAM_ERROR_CODE + 66)
#define ERR_TABLENOTFOUND     (LAST_ISAM_ERROR_CODE + 67)

#define MAX_ERROR_LENGTH (SQL_MAX_MESSAGE_LENGTH-1)



/***************************************************************************/
/* Statement handles */

typedef struct  tagBOUND {      /* Bound column definition */
    LPBOUND    lpNext;          /*    Next element on linked list */
    UWORD      icol;            /*    Which column is bound */
    SWORD      fCType;          /*    The C type of location to put data into */
    PTR        rgbValue;        /*    The location to put the data into */
    SDWORD     cbValueMax;      /*    Max size of location to put data into */
    SDWORD FAR *pcbValue;       /*    Where to put size of data in rgbValue */
}       BOUND,
    FAR *LPBOUND;

typedef struct  tagPARAMETER {  /* PARAMETER definition */
    LPPARAMETER lpNext;         /*    Next element on linked list */
    UWORD       ipar;           /*    Which parameter */
    SWORD       fCType;         /*    The C type of location to get data from */
    PTR         rgbValue;       /*    The location to get the data from */
    SDWORD FAR  *pcbValue;      /*    Where to get size of data in rgbValue */
}       PARAMETER,
    FAR *LPPARAMETER;

typedef struct  tagKEYINFO {
    UCHAR                szPrimaryKeyName[MAX_KEY_NAME_LENGTH+1];
    UCHAR                szForeignKeyName[MAX_KEY_NAME_LENGTH+1];
    UWORD                iKeyColumns;
    UWORD                cKeyColumns;
    ISAMKEYCOLUMNNAME    PrimaryKeyColumns[MAX_COLUMNS_IN_KEY];
    ISAMKEYCOLUMNNAME    ForeignKeyColumns[MAX_COLUMNS_IN_KEY];
    SWORD                fForeignKeyUpdateRule;
    SWORD                fForeignKeyDeleteRule;
}        KEYINFO,
         FAR * LPKEYINFO;

typedef struct  tagSTMT {       /* Statement handle */
    LPSTMT      lpNext;         /*    Next element on linked list */
    RETCODE     errcode;        /*    Most recent error */
    UCHAR       szError[MAX_TOKEN_SIZE+1]; /* Auxilary error info */
    UCHAR       szISAMError[MAX_ERROR_LENGTH+1];
                                /*    ISAM error message */
    LPDBC       lpdbc;          /*    Connection the statement belongs to */
    UCHAR       szCursor[MAX_CURSOR_NAME_LENGTH+1];
                                /*    Cursor name */
    UINT        fStmtType;      /*    Type of statement active (STMT_TYPE_*) */
    UINT        fStmtSubtype;   /*    Subtype of statement (STMT_SUBTYPE_*) */
    SDWORD      irow;           /*    Current row fethed */
    SWORD       fSqlType;       /*    Type (SQLGetTypeInfo) */
    LPISAMTABLELIST lpISAMTableList;
                                /*    List of tables (SQLTables, */
                                /*        SQLColumns, SQLForeignKeys) */
	LPISAMQUALIFIERLIST lpISAMQualifierList;
								/*    List of qualifiers (SQLTables) */
    UCHAR       szTableName[MAX_TABLE_NAME_LENGTH+1];
                                /*    Table name (SQLTables, SQLColumns, */
                                /*        SQLForeignKeys) */
	UCHAR		szQualifierName[MAX_QUALIFIER_NAME_LENGTH+1];
								/*	  Qualifier name (SQLTables) */
    LPISAMTABLEDEF lpISAMTableDef;
                                /*    Current table (SQLColumns, SQLStatistics) */
    UCHAR       szColumnName[MAX_COLUMN_NAME_LENGTH+1];
                                /*    Template for column match (SQLColumns) */
    UCHAR       szPkTableName[MAX_TABLE_NAME_LENGTH+1];
                                /*    Table name (SQLForeignKeys) */
    KEYINFO FAR *lpKeyInfo;     /*    Key info (SQLForeignKeys) */ 
	UCHAR		szTableType[MAX_TABLE_TYPE_LENGTH + 1];
								/*	  Type of table (either 'TABLE' or 'SYSTEM TABLE' */
    LPSQLTREE   lpSqlStmt;      /*    Current SQL statement (SQLPrepare) */
    BOOL        fPreparedSql;   /*    lpSqlStmt was from SQLPrepare() (not */
                                /*        SQLExecDirect()) */
    LPISAMSTATEMENT lpISAMStatement;
                                /*    A passthrough SQL statement */
    BOOL        fNeedData;      /*    Waiting for data before command can */
                                /*        execute? */
    SQLNODEIDX  idxParameter;   /*    Parameter SQLPutData() is to set */
    SDWORD      cbParameterOffset; /* Next offset to write in idxParameter */
    SDWORD      cRowCount;      /*    Number of INSERT, UPDATE, DELETE rows */
    UWORD       icol;           /*    Column read most recently by SQLGetData() */
    SDWORD      cbOffset;       /*    Next offset to read in icol */
    LPBOUND     lpBound;        /*    List of bound columns */
    LPPARAMETER lpParameter;    /*    List of parameters */
    BOOL        fISAMTxnStarted;/*    Flag specifying a transaction started */
    BOOL        fDMLTxn;        /*    Flag specifying DML executed */
	UDWORD		fSyncMode;		/*	  Indicates if SQL functions are called synchronously or asynchronously */
}       STMT,
    FAR *LPSTMT;

#define STMT_TYPE_NONE           0
#define STMT_TYPE_TABLES         1
#define STMT_TYPE_COLUMNS        2
#define STMT_TYPE_STATISTICS     3
#define STMT_TYPE_SPECIALCOLUMNS 4
#define STMT_TYPE_TYPEINFO       5
#define STMT_TYPE_PRIMARYKEYS    6
#define STMT_TYPE_FOREIGNKEYS    7
#define STMT_TYPE_SELECT         8 /* This must be the last on on the list */

#define STMT_SUBTYPE_NONE              0
#define STMT_SUBTYPE_TABLES_TABLES     1
#define STMT_SUBTYPE_TABLES_TYPES      2
#define STMT_SUBTYPE_TABLES_QUALIFIERS 3 //added by SMW 04/11/96
#define STMT_SUBTYPE_TABLES_OWNERS     4 //added by SMW 04/11/96
#define STMT_SUBTYPE_FOREIGNKEYS_SINGLE             5
#define STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_PK_TABLES 6
#define STMT_SUBTYPE_FOREIGNKEYS_MULTIPLE_FK_TABLES 7





/***************************************************************************/
/* Connection handles */

typedef struct  tagDBC {       /* Connection handle */
    LPDBC      lpNext;         /*    Next element on linked list */
    LPSTMT     lpstmts;        /*    Statements of this connection */
    RETCODE    errcode;        /*    Most recent error */
    UCHAR      szISAMError[MAX_ERROR_LENGTH+1];
                               /*    ISAM error message */
    LPENV      lpenv;          /*    Environment this connection belongs to */
    UCHAR      szDSN[SQL_MAX_DSN_LENGTH+1];
                               /*    Data source of this connection */
    LPISAM     lpISAM;         /*    ISAM connection */
    SDWORD     fTxnIsolation;   /*  User-settable isolation state option */ 
    BOOL       fAutoCommitTxn;  /*  User-settable auto-commit state option */
}       DBC,
    FAR * LPDBC;

/***************************************************************************/
/* Environment handles */

typedef struct  tagENV {       /* Environment handle */
    LPDBC      lpdbcs;         /*    Connections of this environment */
    RETCODE    errcode;        /*    Most recent error */
    UCHAR      szISAMError[MAX_ERROR_LENGTH+1];
                               /*    ISAM error message */
}       ENV,
    FAR * LPENV;

/***************************************************************************/
/* Virtual Tables */


/* For SQLTables()... */

#define TABLE_QUALIFIER             1
#define TABLE_OWNER                 2
#define TABLE_NAME                  3
#define TABLE_TYPE                  4
#define TABLE_REMARKS               5
#define TABLE_ATTRIBUTES			6

#define COLUMN_COUNT_TABLES         6


/* For SQLColumns()... */

#define COLUMN_QUALIFIER            1
#define COLUMN_OWNER                2
#define COLUMN_TABLE                3
#define COLUMN_NAME                 4
#define COLUMN_TYPE                 5
#define COLUMN_TYPENAME             6
#define COLUMN_PRECISION            7
#define COLUMN_LENGTH               8
#define COLUMN_SCALE                9
#define COLUMN_RADIX               10
#define COLUMN_NULLABLE            11
#define COLUMN_REMARKS             12
#define COLUMN_ATTRIBUTES		   13

#define COLUMN_COUNT_COLUMNS       13


/* For SQLStatistics()... */

#define STATISTIC_QUALIFIER         1
#define STATISTIC_OWNER             2
#define STATISTIC_NAME              3
#define STATISTIC_NONUNIQUE         4
#define STATISTIC_INDEXQUALIFIER    5
#define STATISTIC_INDEXNAME         6
#define STATISTIC_TYPE              7
#define STATISTIC_SEQININDEX        8
#define STATISTIC_COLUMNNAME        9
#define STATISTIC_COLLATION        10
#define STATISTIC_CARDINALITY      11
#define STATISTIC_PAGES            12
#define STATISTIC_FILTERCONDITION  13

#define COLUMN_COUNT_STATISTICS    13


/* For SQLSpecialColumns()... */

#define SPECIALCOLUMN_SCOPE         1
#define SPECIALCOLUMN_NAME          2
#define SPECIALCOLUMN_TYPE          3
#define SPECIALCOLUMN_TYPENAME      4
#define SPECIALCOLUMN_PRECISION     5
#define SPECIALCOLUMN_LENGTH        6
#define SPECIALCOLUMN_SCALE         7
#define SPECIALCOLUMN_PSEUDOCOLUMN  8

#define COLUMN_COUNT_SPECIALCOLUMNS 8


/* For SQLGetTypeInfo()... */

#define TYPEINFO_NAME               1
#define TYPEINFO_TYPE               2
#define TYPEINFO_PRECISION          3
#define TYPEINFO_PREFIX             4
#define TYPEINFO_SUFFIX             5
#define TYPEINFO_PARAMS             6
#define TYPEINFO_NULLABLE           7
#define TYPEINFO_CASESENSITIVE      8
#define TYPEINFO_SEARCHABLE         9
#define TYPEINFO_UNSIGNED          10
#define TYPEINFO_MONEY             11
#define TYPEINFO_AUTOINCREMENT     12
#define TYPEINFO_LOCALNAME         13
#define TYPEINFO_MINSCALE          14
#define TYPEINFO_MAXSCALE          15

#define COLUMN_COUNT_TYPEINFO      15


/* For SQLPrimaryKeys()... */

#define PRIMARYKEY_QUALIFIER        1
#define PRIMARYKEY_OWNER            2
#define PRIMARYKEY_TABLE            3
#define PRIMARYKEY_COLUMN           4
#define PRIMARYKEY_KEYSEQ           5
#define PRIMARYKEY_NAME             6

#define COLUMN_COUNT_PRIMARYKEYS    6


/* For SQLForeignKeys()... */

#define FOREIGNKEY_PKQUALIFIER      1
#define FOREIGNKEY_PKOWNER          2
#define FOREIGNKEY_PKTABLE          3
#define FOREIGNKEY_PKCOLUMN         4
#define FOREIGNKEY_FKQUALIFIER      5
#define FOREIGNKEY_FKOWNER          6
#define FOREIGNKEY_FKTABLE          7
#define FOREIGNKEY_FKCOLUMN         8
#define FOREIGNKEY_KEYSEQ           9
#define FOREIGNKEY_UPDATERULE      10
#define FOREIGNKEY_DELETERULE      11
#define FOREIGNKEY_FKNAME          12
#define FOREIGNKEY_PKNAME          13

#define COLUMN_COUNT_FOREIGNKEYS   13
/***************************************************************************/
/* Table of column definitions for virtual tables */

/* For a description of these values, see SQLColAttributed() in the ODBC spec. */

typedef struct  tagCOLATTRIBUTE {
    UWORD        count;       
    SDWORD       autoIncrement;
    SDWORD       caseSensitive; /* If -2, use what ISAMCaseSensitive() returns */
    SDWORD       displaySize;
    LPUSTR        label;
    SDWORD       length;
    SDWORD       money;
    LPUSTR        name;
    SDWORD       nullable;
    LPUSTR        ownerName;
    UDWORD       precision;
    LPUSTR        qualifierName;
    SDWORD       scale;
    SDWORD       columnSearchable;
    LPUSTR        tableName;
    SDWORD       type;
    LPSTR        typeName;
    SDWORD       unsignedAttribute;
    SDWORD       updatable;
}       COLATTRIBUTE;

extern COLATTRIBUTE FAR *colAttributes[8];

/***************************************************************************/
/* Internal data types */

#define TYPE_UNKNOWN       SQL_TYPE_NULL
#define TYPE_DOUBLE        SQL_DOUBLE
#define TYPE_NUMERIC       SQL_NUMERIC
#define TYPE_INTEGER       SQL_INTEGER
#define TYPE_CHAR          SQL_CHAR
#define TYPE_DATE          SQL_DATE
#define TYPE_TIME          SQL_TIME
#define TYPE_TIMESTAMP     SQL_TIMESTAMP
#define TYPE_BINARY        SQL_BINARY

/***************************************************************************/
/* INI file Keys */

#define KEY_DSN			"DSN"
#define KEY_DRIVER		"DRIVER"
#define KEY_DATABASE		"DBQ"
#define KEY_USERNAME		"UID"
#define KEY_PASSWORD		"PWD"
#define KEY_HOST		"RemoteHost"
#define KEY_PORT		"RemotePort"
#define ODBC_INI		"ODBC.INI"
#define KEY_HOME		"HOME"
#define KEY_NAMESPACES		"NAMESPACES"
#define KEY_SERVER		"SERVER"
#define KEY_OPTIMIZATION	"OPTIMIZATION"
#define KEY_SYSPROPS		"SYSPROPS"
#define KEY_LOGINMETHOD		"LOGINMETHOD"
#define KEY_LOCALE			"LOCALE"
#define KEY_AUTHORITY		"AUTHORITY"
#define KEY_UIDPWDDEFINED	"UIDPWDDEFINED"
#define KEY_IMPERSONATE		"IMPERSONATE"
#define KEY_PASSTHROUGHONLY	"PASSTHROUGHONLY"
#define KEY_INTPRET_PWD_BLK	"PWDBLK"

/***************************************************************************/
/* Resource defines for dialog boxes */

#define DATABASE_NAME              100
#define DSN_NAME                   101
#define HOST_NAME                  102
#define PORT_NUMBER                103

#define STR_SETUP                 5000
#define STR_OVERWRITE             5001
#define STR_SUNDAY                5002
#define STR_MONDAY                5003
#define STR_TUESDAY               5004
#define STR_WEDNESDAY             5005
#define STR_THURSDAY              5006
#define STR_FRIDAY                5007
#define STR_SATURDAY              5008
#define STR_JANUARY               5009
#define STR_FEBRUARY              5010
#define STR_MARCH                 5011
#define STR_APRIL                 5012
#define STR_MAY                   5013
#define STR_JUNE                  5014
#define STR_JULY                  5015
#define STR_AUGUST                5016
#define STR_SEPTEMBER             5017
#define STR_OCTOBER               5018
#define STR_NOVEMBER              5019
#define STR_DECEMBER              5020

/* Class to manage SQLDriverConnect connection string */
#define MAX_OPTIMIZATION_LENGTH 5

class ConnectionStringManager
{
private:

LPSTR	ptr;
LPDBC	lpdbc;
HWND    hwnd;
char*	lpszOutputNamespaces;
BOOL	foundDriver; 
BOOL	foundDSN;
BOOL	fOptimization;
UWORD	fDriverCompletion;
BOOL	fUsernameSpecified;
BOOL	fPasswordSpecified;
BOOL	fImpersonate;
BOOL    fServerSpecified;
BOOL	fPassthroughOnly;
BOOL	fIntpretEmptPwdAsBlank;


UCHAR	szDSN[SQL_MAX_DSN_LENGTH+1];
UCHAR	szDriver[MAX_DRIVER_LENGTH+1];
UCHAR	szDatabase[MAX_DATABASE_NAME_LENGTH+1];
UCHAR	szUsername[MAX_USER_NAME_LENGTH+1];
UCHAR	szPassword[MAX_PASSWORD_LENGTH+1];
UCHAR	szOptimization[MAX_OPTIMIZATION_LENGTH+1];
UCHAR	szServer[MAX_SERVER_NAME_LENGTH+1];
UCHAR	szHome[MAX_HOME_NAME_LENGTH+1];

char*	szLocale;
char*	szAuthority;
BOOL	fSysProp;

//WBEM_LOGIN_AUTHENTICATION m_loginMethod;

CMapStringToOb *pMapStringToOb;
CMapStringToOb *pMapStringToObOut;

public:

	//Precesses the connection string
	RETCODE Process();

	//Parse the connection string
	RETCODE Parse();

	//Complement information with information in ODBC.INI file
	void GetINI();

	//If the is still missing information get it from use via dialog box
	RETCODE ShowDialog();

	//Re-generate connection string
	char* GenerateConnString();

	ConnectionStringManager(HDBC fHDBC, HWND hwnd, UCHAR FAR *szConnStr, UWORD fDriverCompletion);
	~ConnectionStringManager();

};

/***************************************************************************/
/* Opt-Tech Sort declaration */
#ifdef WIN32
extern "C" void s_1mains(char *, char *, char *, long *, int *);
#else
void far PASCAL s_1mains(LPSTR, LPSTR, LPSTR, LPLONG, LPINT);
#endif
/***************************************************************************/
#ifdef WIN32
/* Redfine lstrcmp and lstrcmpi back to what everyone expects them to be */
#ifdef lstrcmp
#undef lstrcmp
#endif
#define lstrcmp(left, right) (CompareString(LOCALE_SYSTEM_DEFAULT,      \
                                     SORT_STRINGSORT,                   \
                                     left, -1, right, -1) - 2)
#ifdef lstrcmpi
#undef lstrcmpi
#endif
#define lstrcmpi(left, right) (CompareString(LOCALE_SYSTEM_DEFAULT,     \
                                     NORM_IGNORECASE | SORT_STRINGSORT, \
                                     left, -1, right, -1) - 2)
#endif
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\evaluate.cpp ===
/***************************************************************************/
/* EVALUATE.C                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);


#include "drdbdr.h"
#include <time.h>
#include <memory.h>
/***************************************************************************/
#define SECONDS_PER_DAY (60L * 60L * 24L)

typedef struct HFILE_BUFFERtag {
   HGLOBAL hGlobal;
   HFILE hfile;
   UWORD offset;
   LPSTR ptr;
   char buffer[32768];
} HF_BUFFER, FAR * HFILE_BUFFER;

HFILE_BUFFER _lcreat_buffer(LPCSTR szFilename, int arg)
{
    HGLOBAL h;
    HFILE_BUFFER hf;

    h = GlobalAlloc(GMEM_MOVEABLE, sizeof(HF_BUFFER));
    if (h == NULL)
        return NULL;
    hf = (HFILE_BUFFER) GlobalLock(h);
    if (hf == NULL) {
        GlobalFree(h);
        return NULL;
    }
    hf->hGlobal = h;
    hf->hfile = _lcreat(szFilename, arg);
    if (hf->hfile == HFILE_ERROR) {
        GlobalUnlock(h);
        GlobalFree(h);
        return NULL;
    }
    hf->offset = 0;
    hf->ptr = hf->buffer;
    return hf;
}

HFILE _lclose_buffer(HFILE_BUFFER hf)
{
    HGLOBAL h;

    if (hf->offset != 0) {
        if ((UINT) hf->offset !=
               _lwrite(hf->hfile, hf->buffer, (UINT) hf->offset)) {
            h = hf->hGlobal;
            _lclose(hf->hfile);
            GlobalUnlock(h);
            GlobalFree(h);
            return HFILE_ERROR;
        }
    }
    if (HFILE_ERROR == _lclose(hf->hfile)) {
        h = hf->hGlobal;
        GlobalUnlock(h);
        GlobalFree(h);
        return HFILE_ERROR;
    }
    h = hf->hGlobal;
    GlobalUnlock(h);
    GlobalFree(h);
    return 0;
}

UINT _lwrite_buffer(HFILE_BUFFER hf, LPSTR ptr, UINT len)
{
    UWORD total;
    UWORD count;

    total = 0;
    while (TRUE) {
        if (len > sizeof(hf->buffer) - hf->offset)
            count = sizeof(hf->buffer) - hf->offset;
        else
            count = (UWORD) len;
        _fmemcpy(hf->ptr, ptr, count);
        hf->ptr += (count);
		ptr += (count);
        hf->offset += (count);
        total += (count);
        len -= (count);
        if (len == 0)
            break;
        if (sizeof(hf->buffer) !=
                       _lwrite(hf->hfile, hf->buffer, sizeof(hf->buffer)))
            return ((UINT) HFILE_ERROR);
        hf->offset = 0;
        hf->ptr = hf->buffer;
    }
    return total;
}
/***************************************************************************/
void INTFUNC DateAdd(DATE_STRUCT date, SWORD offset, DATE_STRUCT FAR *result)

/* Adds specified number of days to a date                               */

{
static struct tm tm_time;
	time_t t;

	/* Create time structure */
	tm_time.tm_sec = 0;
	tm_time.tm_min = 0;
	tm_time.tm_hour = 0;
	tm_time.tm_mday = date.day + offset;
	tm_time.tm_mon = date.month - 1;
	tm_time.tm_year = (date.year >= 1900 ? date.year - 1900 : 0);
	tm_time.tm_wday = 0;
	tm_time.tm_yday = 0;
	tm_time.tm_isdst = 0;

	/* Correct values */
	t = mktime(&tm_time);
	if (t == -1) {
		result->year = 0;
		result->month = 0;
		result->day = 0;
		return;
	}

	/* Return answer */
	result->year = tm_time.tm_year + 1900;
	result->month = tm_time.tm_mon + 1;
	result->day = (WORD) tm_time.tm_mday;
}

/***************************************************************************/
int INTFUNC DateDifference(DATE_STRUCT leftDate, DATE_STRUCT rightDate)

/* Compares two dates.                                                   */

{
static struct tm tm_time;
	time_t left_t;
	time_t right_t;

	/* Create left value */
	tm_time.tm_sec = 0;
	tm_time.tm_min = 0;
	tm_time.tm_hour = 0;
	tm_time.tm_mday = leftDate.day;
	tm_time.tm_mon = leftDate.month-1;
	tm_time.tm_year = (leftDate.year >= 1900 ? leftDate.year - 1900 : 0);
	tm_time.tm_wday = 0;
	tm_time.tm_yday = 0;
	tm_time.tm_isdst = 0;
	left_t = mktime(&tm_time);

	/* Create right value */
	tm_time.tm_sec = 0;
	tm_time.tm_min = 0;
	tm_time.tm_hour = 0;
	tm_time.tm_mday = rightDate.day;
	tm_time.tm_mon = rightDate.month-1;
	tm_time.tm_year = (rightDate.year >= 1900 ? rightDate.year - 1900 : 0);
	tm_time.tm_wday = 0;
	tm_time.tm_yday = 0;
	tm_time.tm_isdst = 0;
	right_t = mktime(&tm_time);

	/* Return answer */
	return (int) ((left_t - right_t) / SECONDS_PER_DAY);
}
/***************************************************************************/
int INTFUNC DateCompare(DATE_STRUCT leftDate, DATE_STRUCT rightDate)

/* Compares two dates.                                                   */

{
	if ( (leftDate.year - rightDate.year) != 0 )
		return (int) (leftDate.year -rightDate.year);
	else if ( (leftDate.month - rightDate.month) != 0 )
		return (int) (leftDate.month -rightDate.month);
	else 
		return (int) (leftDate.day -rightDate.day);
}

/***************************************************************************/
int INTFUNC TimeCompare(TIME_STRUCT leftTime, TIME_STRUCT rightTime)

/* Compares two times.                                                   */

{
	if ((leftTime.hour - rightTime.hour) != 0)
		return (int) (leftTime.hour - rightTime.hour);
	else if ((leftTime.minute - rightTime.minute) != 0)
		return (int) (leftTime.minute - rightTime.minute);
	else
		return (int) (leftTime.second - rightTime.second);
}
/***************************************************************************/
int INTFUNC TimestampCompare(TIMESTAMP_STRUCT leftTimestamp,
							 TIMESTAMP_STRUCT rightTimestamp)

/* Compares two timestamp.                                                 */

{
	if ((leftTimestamp.year - rightTimestamp.year) != 0)
		return (int) (leftTimestamp.year - rightTimestamp.year);
	else if ((leftTimestamp.month - rightTimestamp.month) != 0)
		return (int) (leftTimestamp.month - rightTimestamp.month);
	else if ((leftTimestamp.day - rightTimestamp.day) != 0)
		return (int) (leftTimestamp.day - rightTimestamp.day);
	else if ((leftTimestamp.hour - rightTimestamp.hour) != 0)
		return (int) (leftTimestamp.hour - rightTimestamp.hour);
	else if ((leftTimestamp.minute - rightTimestamp.minute) != 0)
		return (int) (leftTimestamp.minute - rightTimestamp.minute);
	else if ((leftTimestamp.second - rightTimestamp.second) != 0)
		return (int) (leftTimestamp.second - rightTimestamp.second);
	else if (leftTimestamp.fraction > rightTimestamp.fraction)
		return 1;//-1;
	else if (leftTimestamp.fraction < rightTimestamp.fraction)
		return -1;//1;
	else
		return 0;
}
/***************************************************************************/
RETCODE INTFUNC NumericCompare(LPSQLNODE lpSqlNode, LPSQLNODE lpSqlNodeLeft,
						UWORD Operator, LPSQLNODE lpSqlNodeRight)

/* Compares two numerical valuesas follows:                                */
/*       lpSqlNode->value.Double = lpSqlNodeLeft Operator lpSqlNodeRight   */
{
	RETCODE err;
	UWORD op;
	SQLNODE sqlNode;
	UCHAR szBuffer[32];

	/* What is the type of the left side? */
	switch (lpSqlNodeLeft->sqlDataType) {
	case TYPE_DOUBLE:
	case TYPE_INTEGER:

		/* Left side is a double or integer.  What is the right side? */
		switch (lpSqlNodeRight->sqlDataType) {
		case TYPE_DOUBLE:
		case TYPE_INTEGER:

			/* Right side is also a double or an integer.  Compare them */
			switch (Operator) {
			case OP_EQ:
				if (lpSqlNodeLeft->value.Double ==
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_NE:
				if (lpSqlNodeLeft->value.Double !=
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_LE:
				if (lpSqlNodeLeft->value.Double <=
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_LT:
				if (lpSqlNodeLeft->value.Double <
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_GE:
				if (lpSqlNodeLeft->value.Double >=
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_GT:
				if (lpSqlNodeLeft->value.Double >
											  lpSqlNodeRight->value.Double)
					lpSqlNode->value.Double = TRUE;
				else
					lpSqlNode->value.Double = FALSE;
				break;
			case OP_LIKE:
			case OP_NOTLIKE:
			default:
				return ERR_INTERNAL;
			}
			break;

		case TYPE_NUMERIC:
			/* Right side is a numeric.  Is left side a double? */
			if (lpSqlNodeLeft->sqlDataType == TYPE_DOUBLE) {

				/* Yes.  Promote the right side to a double */
				sqlNode = *lpSqlNodeRight;
				sqlNode.sqlDataType = TYPE_DOUBLE;
				sqlNode.sqlSqlType = SQL_DOUBLE;
				sqlNode.sqlPrecision = 15;
				sqlNode.sqlScale = NO_SCALE;
				err = CharToDouble(lpSqlNodeRight->value.String,
							   s_lstrlen(lpSqlNodeRight->value.String), FALSE, 
							   -1.7E308, 1.7E308, &(sqlNode.value.Double));
				if (err != ERR_SUCCESS)
					return err;

				/* Compare the two doubles */
				err = NumericCompare(lpSqlNode, lpSqlNodeLeft, Operator,
																   &sqlNode);
				if (err != ERR_SUCCESS)
					return err;
			}

			/* Right side is a numeric.  Is left side an integer? */
			else { /* (lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) */

				/* Yes.  Promote the left side to a numeric */
				sqlNode = *lpSqlNodeLeft;
				sqlNode.sqlDataType = TYPE_NUMERIC;
				sqlNode.sqlSqlType = SQL_NUMERIC;
				sqlNode.sqlPrecision = 10;
				sqlNode.sqlScale = 0;
				if (lpSqlNodeLeft->value.Double != 0.0)
					wsprintf((LPSTR)szBuffer, "%ld", (long) lpSqlNodeLeft->value.Double);
				else
					s_lstrcpy((char*)szBuffer, "");
				sqlNode.value.String = (LPUSTR)szBuffer;

				/* Compare the two numerics */
				err = NumericCompare(lpSqlNode, &sqlNode, Operator,
															  lpSqlNodeRight);
				if (err != ERR_SUCCESS)
					return err;
			}
			break;

		case TYPE_CHAR:
		case TYPE_BINARY:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}
		break;
	case TYPE_NUMERIC:

		/* Left side is a numeric.  What is the right side? */
		switch (lpSqlNodeRight->sqlDataType) {
		case TYPE_DOUBLE:
		case TYPE_INTEGER:

			/* Right side is a double or integer.  Swap left and right and */
			/* then do the comaprison */
			switch (Operator) {
			case OP_EQ:
				op = OP_EQ;
				break;
			case OP_NE:
				op = OP_NE;
				break;
			case OP_LE:
				op = OP_GE;
				break;
			case OP_LT:
				op = OP_GT;
				break;
			case OP_GE:
				op = OP_LE;
				break;
			case OP_GT:
				op = OP_LT;
				break;
			case OP_LIKE:
			case OP_NOTLIKE:
			default:
				return ERR_INTERNAL;
			}
			err = NumericCompare(lpSqlNode, lpSqlNodeRight, op,
														lpSqlNodeLeft);
			if (err != ERR_SUCCESS)
				return err;
			break;

		case TYPE_NUMERIC:
			/* Right side is also numeric.  Compare them as numeric */
			err = BCDCompare(lpSqlNode, lpSqlNodeLeft, Operator, lpSqlNodeRight);
			if (err != ERR_SUCCESS)
				return err;
			break;

		case TYPE_CHAR:
		case TYPE_BINARY:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}
		break;
	case TYPE_CHAR:
	case TYPE_BINARY:
	case TYPE_DATE:
	case TYPE_TIME:
	case TYPE_TIMESTAMP:
		return ERR_INTERNAL;
	default:
		return ERR_NOTSUPPORTED;
	}
	return ERR_SUCCESS;
}
/***************************************************************************/
SWORD INTFUNC ToInteger(LPSQLNODE lpSqlNode)

/* Returns the value of the node (as an integer).  If the data type of the */
/* node is incompatible, zerois returned                                   */
{
	double dbl;
	RETCODE err;

	switch (lpSqlNode->sqlDataType) {
	case TYPE_DOUBLE:
	case TYPE_INTEGER:
		return ((SWORD) lpSqlNode->value.Double);
	case TYPE_NUMERIC:
		err = CharToDouble(lpSqlNode->value.String,
							   s_lstrlen(lpSqlNode->value.String), FALSE, 
							   -1.7E308, 1.7E308, &dbl);
		if (err != ERR_SUCCESS)
			return 0;
		return ((SWORD) dbl);
	case TYPE_CHAR:
	case TYPE_BINARY:
	case TYPE_DATE:
	case TYPE_TIME:
	case TYPE_TIMESTAMP:
	default:
		return 0;
	}
}
/***************************************************************************/
RETCODE INTFUNC NumericAlgebra(LPSQLNODE lpSqlNode, LPSQLNODE lpSqlNodeLeft,
						UWORD Operator, LPSQLNODE lpSqlNodeRight,
						LPUSTR lpWorkBuffer1, LPUSTR lpWorkBuffer2,
						LPUSTR lpWorkBuffer3)

/* Perfoms algebraic operation in two numerical or char values as follows: */
/*       lpSqlNode lpSqlNodeLeft Operator lpSqlNodeRight                   */

{
	RETCODE err;
	SQLNODE sqlNode;
	UCHAR szBuffer[32];

	/* What is the type of the left side? */
	switch (lpSqlNodeLeft->sqlDataType) {
	case TYPE_DOUBLE:
	case TYPE_INTEGER:

		/* Left side is a double or integer.  What is the right side? */
		switch (lpSqlNodeRight != NULL ? lpSqlNodeRight->sqlDataType :
										 lpSqlNodeLeft->sqlDataType) {
		case TYPE_DOUBLE:
		case TYPE_INTEGER:

			/* Right side is also a double or an integer.  Do the operation */
			switch (Operator) {
			case OP_NEG:
				lpSqlNode->value.Double = -(lpSqlNodeLeft->value.Double);
				break;
			case OP_PLUS:
				lpSqlNode->value.Double = lpSqlNodeLeft->value.Double +
											  lpSqlNodeRight->value.Double;
				break;
			case OP_MINUS:
				lpSqlNode->value.Double = lpSqlNodeLeft->value.Double -
											  lpSqlNodeRight->value.Double;
				break;
			case OP_TIMES:
				lpSqlNode->value.Double = lpSqlNodeLeft->value.Double *
											  lpSqlNodeRight->value.Double;
				break;
			case OP_DIVIDEDBY:
				if (lpSqlNodeRight->value.Double != 0.0)
					lpSqlNode->value.Double = lpSqlNodeLeft->value.Double /
											  lpSqlNodeRight->value.Double;
				else
					return ERR_ZERODIVIDE;
				break;
			default:
				return ERR_INTERNAL;
				break;
			}
			break;

		case TYPE_NUMERIC:
			/* Right side is a numeric.  Is left side a double? */
			if (lpSqlNodeLeft->sqlDataType == TYPE_DOUBLE) {

				/* Yes.  Promote the right side to a double */
				sqlNode = *lpSqlNodeRight;
				sqlNode.sqlDataType = TYPE_DOUBLE;
				sqlNode.sqlSqlType = SQL_DOUBLE;
				sqlNode.sqlPrecision = 15;
				sqlNode.sqlScale = NO_SCALE;
				err = CharToDouble(lpSqlNodeRight->value.String,
							   s_lstrlen(lpSqlNodeRight->value.String), FALSE, 
							   -1.7E308, 1.7E308, &(sqlNode.value.Double));
				if (err != ERR_SUCCESS)
					return err;

				/* Compute the result */
				err = NumericAlgebra(lpSqlNode, lpSqlNodeLeft, Operator,
									 &sqlNode, lpWorkBuffer1, lpWorkBuffer2,
									 lpWorkBuffer3);
				if (err != ERR_SUCCESS)
					return err;
			}

			/* Right side is a numeric.  Is left side an integer? */
			else { /* (lpSqlNodeLeft->sqlDataType == TYPE_INTEGER) */

				/* Yes.  Promote the left side to a numeric */
				sqlNode = *lpSqlNodeLeft;
				sqlNode.sqlDataType = TYPE_NUMERIC;
				sqlNode.sqlSqlType = SQL_NUMERIC;
				sqlNode.sqlPrecision = 10;
				sqlNode.sqlScale = 0;
				if (lpSqlNodeLeft->value.Double != 0.0)
					wsprintf((LPSTR)szBuffer, "%ld", (long) lpSqlNodeLeft->value.Double);
				else
					s_lstrcpy((char*)szBuffer, "");
				sqlNode.value.String = (LPUSTR)szBuffer;

				/* Compute the result */
				err = NumericAlgebra(lpSqlNode, &sqlNode, Operator,
									 lpSqlNodeRight, lpWorkBuffer1,
									 lpWorkBuffer2, lpWorkBuffer3);
				if (err != ERR_SUCCESS)
					return err;
			}
			break;

		case TYPE_DATE:
			/* Right side is a date.  Do the operation */
			switch (Operator) {
			case OP_PLUS:
				DateAdd(lpSqlNodeRight->value.Date,
								ToInteger(lpSqlNodeLeft),
								&(lpSqlNode->value.Date));
				break;
			case OP_NEG:
			case OP_MINUS:
			case OP_TIMES:
			case OP_DIVIDEDBY:
			default:
				return ERR_INTERNAL;
			}
			break;
		case TYPE_CHAR:
		case TYPE_BINARY:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}
		break;

	case TYPE_NUMERIC:

		/* Left side is a numeric.  What is the right side? */
		switch (lpSqlNodeRight != NULL ? lpSqlNodeRight->sqlDataType :
										 lpSqlNodeLeft->sqlDataType) {
		case TYPE_DOUBLE:

			/* Right side is a double.  Promote the left side to a double */
			sqlNode = *lpSqlNodeLeft;
			sqlNode.sqlDataType = TYPE_DOUBLE;
			sqlNode.sqlSqlType = SQL_DOUBLE;
			sqlNode.sqlPrecision = 15;
			sqlNode.sqlScale = NO_SCALE;
			err = CharToDouble(lpSqlNodeLeft->value.String,
							   s_lstrlen(lpSqlNodeLeft->value.String), FALSE, 
							   -1.7E308, 1.7E308, &(sqlNode.value.Double));
			if (err != ERR_SUCCESS)
				return err;

			/* Compute the result */
			err = NumericAlgebra(lpSqlNode, &sqlNode, Operator,
								 lpSqlNodeRight, lpWorkBuffer1,
								 lpWorkBuffer2, lpWorkBuffer3);
			if (err != ERR_SUCCESS)
				return err;
			break;

		case TYPE_INTEGER:
			/* Right side is an integer.  Promote the right side to nuemric */
			sqlNode = *lpSqlNodeRight;
			sqlNode.sqlDataType = TYPE_NUMERIC;
			sqlNode.sqlSqlType = SQL_NUMERIC;
			sqlNode.sqlPrecision = 10;
			sqlNode.sqlScale = 0;
			if (lpSqlNodeRight->value.Double != 0.0)
				wsprintf((LPSTR)szBuffer, "%ld", (long) lpSqlNodeRight->value.Double);
			else
				s_lstrcpy((char*)szBuffer, "");
			sqlNode.value.String = szBuffer;

			/* Compute the result */
			err = NumericAlgebra(lpSqlNode, lpSqlNodeLeft, Operator,
								 &sqlNode, lpWorkBuffer1, lpWorkBuffer2,
								 lpWorkBuffer3);
			if (err != ERR_SUCCESS)
				return err;
			break;

		case TYPE_NUMERIC:
			/* Right side is also numeric.  Do the operation */
			err = BCDAlgebra(lpSqlNode, lpSqlNodeLeft, Operator,
							 lpSqlNodeRight, lpWorkBuffer1,
							 lpWorkBuffer2, lpWorkBuffer3);
			if (err != ERR_SUCCESS)
				return err;
			break;

		case TYPE_CHAR:
		case TYPE_BINARY:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}
		break;

	case TYPE_DATE:
		
		/* Left side is a date.  What operator? */
		switch (Operator) {
		case OP_NEG:
			return ERR_INTERNAL;
			break;
		case OP_PLUS:
			DateAdd(lpSqlNodeLeft->value.Date,
							ToInteger(lpSqlNodeRight),
							&(lpSqlNode->value.Date));
			break;
		case OP_MINUS:
			switch (lpSqlNodeRight->sqlDataType) { 
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
			case TYPE_NUMERIC:
				DateAdd(lpSqlNodeLeft->value.Date, (SWORD)
							-(ToInteger(lpSqlNodeRight)),
							&(lpSqlNode->value.Date));
				break;
			case TYPE_CHAR:
			case TYPE_BINARY:
				return ERR_INTERNAL;
				break;
			case TYPE_DATE:
				lpSqlNode->value.Double = DateDifference(
								lpSqlNodeLeft->value.Date,
								lpSqlNodeRight->value.Date);
				break;
			case TYPE_TIME:
				return ERR_INTERNAL;
				break;
			case TYPE_TIMESTAMP:
				return ERR_NOTSUPPORTED;
				break;
			}
			break;
		case OP_TIMES:
		case OP_DIVIDEDBY:
		default:
			return ERR_INTERNAL;
			break;
		}
		break;

	case TYPE_CHAR:
		/* Left side is character.  Concatenate */
        	if ((lpSqlNodeRight->sqlDataType != TYPE_CHAR) ||
                                     (Operator != OP_PLUS))
            	return ERR_INTERNAL;
        	if ((s_lstrlen(lpSqlNodeLeft->value.String) +
             		s_lstrlen(lpSqlNodeRight->value.String)) > lpSqlNode->sqlPrecision)
            		return ERR_CONCATOVERFLOW;
        	s_lstrcpy(lpSqlNode->value.String, lpSqlNodeLeft->value.String);
        	s_lstrcat(lpSqlNode->value.String, lpSqlNodeRight->value.String);
        break;

	case TYPE_BINARY:
	case TYPE_TIME:
	case TYPE_TIMESTAMP:
		return ERR_INTERNAL;
	default:
		return ERR_NOTSUPPORTED;
	}
	return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC SetParameterValue(LPSTMT      lpstmt,
								LPSQLNODE   lpSqlNodeParameter,
								SDWORD FAR *pcbOffset,
								SWORD       fCType,
								PTR         rgbValue,
								SDWORD      cbValue)

/* Sets the value of a parameter node to the value given.  If fCType is    */
/* SQL_C_CHAR and the parameter is TYPE_CHAR (or if fCType is SQL_C_BINARY */
/* and the parameter is TYPE_BINARY), the parameter is written at offset   */
/* (*pcbOffset) and (*pcbOffset) is incremented by the number of           */
/* of characters written.                                                  */

{
	SWORD err;
	SDWORD cbOffset;
	DATE_STRUCT FAR *lpDate;
	TIME_STRUCT FAR *lpTime;
	TIMESTAMP_STRUCT FAR *lpTimestamp;
static time_t t;
	struct tm *ts;
	UCHAR szValue[20];
	LPUSTR lpszValue;
	SDWORD cbVal;
	LPUSTR lpszVal;
	SDWORD i;
	UCHAR nibble;
	LPUSTR lpFrom;
	LPUSTR lpTo;

	/* Null data? */
	err = SQL_SUCCESS;
	if (cbValue == SQL_NULL_DATA) {

		/* Yes.  Set the value to NULL */
		lpSqlNodeParameter->sqlIsNull = TRUE;

		switch (lpSqlNodeParameter->sqlDataType) {
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
			lpSqlNodeParameter->value.Double = 0.0;
			break;
		case TYPE_NUMERIC:
			lpSqlNodeParameter->value.String = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			s_lstrcpy(lpSqlNodeParameter->value.String, "");
			break;
		case TYPE_CHAR:
			lpSqlNodeParameter->value.String = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			s_lstrcpy(lpSqlNodeParameter->value.String, "");
			break;
		case TYPE_DATE:
			lpSqlNodeParameter->value.Date.year = 0;
			lpSqlNodeParameter->value.Date.month = 0;
			lpSqlNodeParameter->value.Date.day = 0;
			break;
		case TYPE_TIME:
			lpSqlNodeParameter->value.Time.hour = 0;
			lpSqlNodeParameter->value.Time.minute = 0;
			lpSqlNodeParameter->value.Time.second = 0;
			break;
		case TYPE_TIMESTAMP:
			lpSqlNodeParameter->value.Timestamp.year = 0;
			lpSqlNodeParameter->value.Timestamp.month = 0;
			lpSqlNodeParameter->value.Timestamp.day = 0;
			lpSqlNodeParameter->value.Timestamp.hour = 0;
			lpSqlNodeParameter->value.Timestamp.minute = 0;
			lpSqlNodeParameter->value.Timestamp.second = 0;
			lpSqlNodeParameter->value.Timestamp.fraction = 0;
			break;
		case TYPE_BINARY:
			lpSqlNodeParameter->value.Binary = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 0;
			break;
		default:
			return ERR_NOTSUPPORTED;
		}
	}
	else {

		/* No.  Set the value to not NULL */
		lpSqlNodeParameter->sqlIsNull = FALSE;

		/* Put the data value into the parse tree */
		switch (lpSqlNodeParameter->sqlDataType) {
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
			if (fCType == SQL_C_BINARY) {
				switch (lpSqlNodeParameter->sqlSqlType) {
				case SQL_CHAR:
				case SQL_VARCHAR:
				case SQL_LONGVARCHAR:
					return ERR_INTERNAL;
				case SQL_BIT:
					fCType = SQL_C_BIT;
					break;
				case SQL_TINYINT:
					fCType = SQL_C_TINYINT;
					break;
				case SQL_SMALLINT:
					fCType = SQL_C_SHORT;
					break;
				case SQL_INTEGER:
					fCType = SQL_C_LONG;
					break;
				case SQL_REAL:
					fCType = SQL_C_FLOAT;
					break;
				case SQL_DECIMAL:
				case SQL_NUMERIC:
				case SQL_BIGINT:
					return ERR_INTERNAL;
				case SQL_FLOAT:
				case SQL_DOUBLE:
					fCType = SQL_C_DOUBLE;
					break;
				case SQL_BINARY:
				case SQL_VARBINARY:
				case SQL_LONGVARBINARY:
				case SQL_DATE:
				case SQL_TIME:
				case SQL_TIMESTAMP:
				default:
					return ERR_INTERNAL;
				}
			}
			switch (fCType) {
			case SQL_C_CHAR:
				err = CharToDouble((LPUSTR)rgbValue, cbValue, FALSE, -1.7E308,
							   1.7E308, &(lpSqlNodeParameter->value.Double));
				if (err != ERR_SUCCESS)
					return err;
				break;
			case SQL_C_SSHORT:
				lpSqlNodeParameter->value.Double = (double)
							 *((short far *) rgbValue);
				break;
			case SQL_C_USHORT:
				lpSqlNodeParameter->value.Double = (double)
							 *((unsigned short far *) rgbValue);
				break;
			case SQL_C_SLONG:
				lpSqlNodeParameter->value.Double = (double)
							 *((long far *) rgbValue);
				break;
			case SQL_C_ULONG:
				lpSqlNodeParameter->value.Double = (double)
							 *((unsigned long far *) rgbValue);
				break;
			case SQL_C_FLOAT:
				lpSqlNodeParameter->value.Double = (double)
							 *((float far *) rgbValue);
				break;
			case SQL_C_DOUBLE:
				lpSqlNodeParameter->value.Double =
							 *((double far *) rgbValue);
				break;
			case SQL_C_BIT:
				lpSqlNodeParameter->value.Double = (double)
							 *((unsigned char far *) rgbValue);
				break;
			case SQL_C_STINYINT:
				lpSqlNodeParameter->value.Double = (double)
							 *((char far *) rgbValue);
				break;
			case SQL_C_UTINYINT:
				lpSqlNodeParameter->value.Double = (double)
							 *((unsigned char far *) rgbValue);
				break;
			case SQL_C_DATE:
			case SQL_C_TIME:
			case SQL_C_TIMESTAMP:
				return ERR_NOTCONVERTABLE;
			case SQL_C_BINARY:
				return ERR_INTERNAL;
			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		case TYPE_NUMERIC:
			if (fCType == SQL_C_BINARY) {
				switch (lpSqlNodeParameter->sqlSqlType) {
				case SQL_CHAR:
				case SQL_VARCHAR:
				case SQL_LONGVARCHAR:
				case SQL_BIT:
				case SQL_TINYINT:
				case SQL_SMALLINT:
				case SQL_INTEGER:
				case SQL_REAL:
					return ERR_INTERNAL;
				case SQL_DECIMAL:
				case SQL_NUMERIC:
				case SQL_BIGINT:
					fCType = SQL_C_CHAR;
					break;
				case SQL_FLOAT:
				case SQL_DOUBLE:
				case SQL_BINARY:
				case SQL_VARBINARY:
				case SQL_LONGVARBINARY:
				case SQL_DATE:
				case SQL_TIME:
				case SQL_TIMESTAMP:
				default:
					return ERR_INTERNAL;
				}
			}

			lpSqlNodeParameter->value.String = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			switch (fCType) {
			case SQL_C_CHAR:

				/* Get true length of source string */
				lpszValue = (LPUSTR) rgbValue;
				if (cbValue == SQL_NTS)
					cbValue = s_lstrlen(lpszValue);
				else if (cbValue < 0)
					cbValue = 0;

				/* Make sure the number is well formed:  Leading blanks... */
				lpszVal = lpszValue;
				cbVal = cbValue;
				while ((cbVal > 0) && (*lpszVal == ' ')) {
					lpszVal++;
					cbVal--;
				}

				/* ...a minus sign... */
				if ((cbVal > 0) && (*lpszVal == '-')) {
					lpszVal++;
					cbVal--;
				}

				/* ...some digits... */
				while ((cbVal > 0) && (*lpszVal >= '0')&&(*lpszVal <= '9')) {
					lpszVal++;
					cbVal--;
				}

				/* ...a decimal point... */
				if ((cbVal > 0) && (*lpszVal == '.')) {
					lpszVal++;
					cbVal--;
				}

				/* ...some more digits... */
				while ((cbVal > 0) && (*lpszVal >= '0')&&(*lpszVal <= '9')) {
					lpszVal++;
					cbVal--;
				}

				/* ...some trailing blanks. */
				while ((cbVal > 0) && (*lpszVal == ' ')) {
					lpszVal++;
					cbVal--;
				}

				/* If there is anything else, error */
				if (cbVal != 0) {
					if (cbValue <= MAX_TOKEN_SIZE) {
						_fmemcpy(lpstmt->szError, lpszValue, (SWORD) cbValue);
						lpstmt->szError[cbValue] = '\0';
					}
					else {
						_fmemcpy(lpstmt->szError, lpszValue, MAX_TOKEN_SIZE);
						lpstmt->szError[MAX_TOKEN_SIZE] = '\0';
					}
					return ERR_MALFORMEDNUMBER;
				}

				break;

			case SQL_C_SSHORT:
				wsprintf((LPSTR)szValue, "%d", *((short far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_USHORT:
				wsprintf((LPSTR)szValue, "%u", *((unsigned short far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_SLONG:
				wsprintf((LPSTR)szValue, "%ld", *((long far *) rgbValue));
				lpszValue = szValue;
				cbValue = lstrlen((char*)szValue);
				break;
			case SQL_C_ULONG:
				wsprintf((LPSTR)szValue, "%lu", *((unsigned long far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_FLOAT:
				if (DoubleToChar((double) *((float far *) rgbValue),
								FALSE,	
							 lpSqlNodeParameter->value.String,
							 lpSqlNodeParameter->sqlPrecision + 2 + 1))
					lpSqlNodeParameter->value.String[
						lpSqlNodeParameter->sqlPrecision + 2 + 1 - 1] = '\0';
				lpszValue = lpSqlNodeParameter->value.String;
				cbValue = s_lstrlen(lpSqlNodeParameter->value.String);
				break;
			case SQL_C_DOUBLE:
				if (DoubleToChar(*((double far *) rgbValue),
								FALSE,
							 lpSqlNodeParameter->value.String,
							 lpSqlNodeParameter->sqlPrecision + 2 + 1))
					lpSqlNodeParameter->value.String[
						lpSqlNodeParameter->sqlPrecision + 2 + 1 - 1] = '\0';
				lpszValue = lpSqlNodeParameter->value.String;
				cbValue = s_lstrlen(lpSqlNodeParameter->value.String);
				break;
			case SQL_C_BIT:
				wsprintf((LPSTR)szValue, "%d", (short)
									 *((unsigned char far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_STINYINT:
				wsprintf((LPSTR)szValue, "%d", (short)
									 *((char far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_UTINYINT:
				wsprintf((LPSTR)szValue, "%d", (short)
									  *((unsigned char far *) rgbValue));
				lpszValue = szValue;
				cbValue = s_lstrlen((char*)szValue);
				break;
			case SQL_C_DATE:
			case SQL_C_TIME:
			case SQL_C_TIMESTAMP:
				 return ERR_NOTCONVERTABLE;
				 break;
			case SQL_C_BINARY:
				return ERR_INTERNAL;
			default:
				return ERR_NOTSUPPORTED;
			}

			/* Normalize the result */
			err = BCDNormalize(lpszValue, cbValue,
						 lpSqlNodeParameter->value.String,
						 lpSqlNodeParameter->sqlPrecision + 2 + 1,
						 lpSqlNodeParameter->sqlPrecision,
						 lpSqlNodeParameter->sqlScale);
			break;

		case TYPE_CHAR:
			lpSqlNodeParameter->value.String = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			switch (fCType) {
			case SQL_C_CHAR:

				/* Get true lengthof source string */
				if (cbValue == SQL_NTS)
					cbValue = s_lstrlen((char*)rgbValue);
				else if (cbValue < 0)
					cbValue = 0;

				/* Figure out the offset to write at */
				if (pcbOffset != NULL)
					cbOffset = *pcbOffset;
				else
					cbOffset = 0;

				/* Make sure we don't write past the end of the buffer */
				if (cbValue > (MAX_CHAR_LITERAL_LENGTH - cbOffset)) {
					cbValue = MAX_CHAR_LITERAL_LENGTH - cbOffset;
					err = ERR_DATATRUNCATED;
				}

				/* Copy the data */
				_fmemcpy(lpSqlNodeParameter->value.String + cbOffset,
								  rgbValue, (SWORD) cbValue);
				lpSqlNodeParameter->value.String[cbValue + cbOffset] = '\0';
				if (pcbOffset != NULL)
					*pcbOffset += (cbValue);
				break;

			case SQL_C_SSHORT:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%d", 
								*((short far *) rgbValue));
				break;
			case SQL_C_USHORT:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%u",
								*((unsigned short far *) rgbValue));
				break;
			case SQL_C_SLONG:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%ld",
								*((long far *) rgbValue));
				break;
			case SQL_C_ULONG:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%lu",
								*((unsigned long far *) rgbValue));
				break;
			case SQL_C_FLOAT:
				if (DoubleToChar((double) *((float far *) rgbValue), TRUE,
							 lpSqlNodeParameter->value.String,
							 MAX_CHAR_LITERAL_LENGTH))
					lpSqlNodeParameter->value.String[
										MAX_CHAR_LITERAL_LENGTH - 1] = '\0';
				break;
			case SQL_C_DOUBLE:
				if (DoubleToChar(*((double far *) rgbValue), TRUE, 
							 lpSqlNodeParameter->value.String,
							 MAX_CHAR_LITERAL_LENGTH))
					lpSqlNodeParameter->value.String[
										MAX_CHAR_LITERAL_LENGTH - 1] = '\0';
				break;
			case SQL_C_BIT:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%d", (short)
							 *((unsigned char far *) rgbValue));
				break;
			case SQL_C_STINYINT:
				wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%d", (short)
							*((char far *) rgbValue));
				break;
			case SQL_C_UTINYINT:
				 wsprintf((LPSTR) lpSqlNodeParameter->value.String, "%d", (short)
							*((unsigned char far *) rgbValue));
				 break;
			case SQL_C_DATE:
				 DateToChar((DATE_STRUCT far *) rgbValue,
							lpSqlNodeParameter->value.String);
				 break;
			case SQL_C_TIME:
				 TimeToChar((TIME_STRUCT far *) rgbValue,
							lpSqlNodeParameter->value.String);
				 break;
			case SQL_C_TIMESTAMP:
				 TimestampToChar((TIMESTAMP_STRUCT far *) rgbValue,
							lpSqlNodeParameter->value.String);
				 break;
			case SQL_C_BINARY:

				/* Get true lengthof source string */
				if (cbValue < 0)
					cbValue = 0;

				/* Figure out the offset to write at */
				if (pcbOffset != NULL)
					cbOffset = *pcbOffset;
				else
					cbOffset = 0;

				/* Make sure we don't write past the end of the buffer */
				if (cbValue > (MAX_CHAR_LITERAL_LENGTH - cbOffset)) {
					cbValue = MAX_CHAR_LITERAL_LENGTH - cbOffset;
					err = ERR_DATATRUNCATED;
				}

				/* Copy the data */
				_fmemcpy(lpSqlNodeParameter->value.String + cbOffset,
								  rgbValue, (SWORD) cbValue);
				lpSqlNodeParameter->value.String[cbValue + cbOffset] = '\0';
				if (pcbOffset != NULL)
					*pcbOffset += (cbValue);
				break;

			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		case TYPE_DATE:
			switch (fCType) {
			case SQL_C_CHAR:
				err = CharToDate((LPUSTR)rgbValue, cbValue,
								 &(lpSqlNodeParameter->value.Date));
				if (err != ERR_SUCCESS)
					return err;
				break;
			case SQL_C_SSHORT:
			case SQL_C_USHORT:
			case SQL_C_SLONG:
			case SQL_C_ULONG:
			case SQL_C_FLOAT:
			case SQL_C_DOUBLE:
			case SQL_C_BIT:
			case SQL_C_STINYINT:
			case SQL_C_UTINYINT:
				return ERR_NOTCONVERTABLE;
			case SQL_C_DATE:
				lpSqlNodeParameter->value.Date =
											*((DATE_STRUCT far *) rgbValue);
				break;
			case SQL_C_TIME:
				return ERR_NOTCONVERTABLE;
			case SQL_C_TIMESTAMP:
				lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValue;
				lpSqlNodeParameter->value.Date.year = lpTimestamp->year;
				lpSqlNodeParameter->value.Date.month = lpTimestamp->month;
				lpSqlNodeParameter->value.Date.day = lpTimestamp->day;
				break;
			case SQL_C_BINARY:
				lpSqlNodeParameter->value.Date =
											*((DATE_STRUCT far *) rgbValue);
				break;
			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		case TYPE_TIME:
			switch (fCType) {
			case SQL_C_CHAR:
				err = CharToTime((LPUSTR)rgbValue, cbValue,
								 &(lpSqlNodeParameter->value.Time));
				if (err != ERR_SUCCESS)
					return err;
				break;
			case SQL_C_SSHORT:
			case SQL_C_USHORT:
			case SQL_C_SLONG:
			case SQL_C_ULONG:
			case SQL_C_FLOAT:
			case SQL_C_DOUBLE:
			case SQL_C_BIT:
			case SQL_C_STINYINT:
			case SQL_C_UTINYINT:
				return ERR_NOTCONVERTABLE;
			case SQL_C_DATE:
				return ERR_NOTCONVERTABLE;
			case SQL_C_TIME:
				lpSqlNodeParameter->value.Time =
											*((TIME_STRUCT far *) rgbValue);
				break;
			case SQL_C_TIMESTAMP:
				lpTimestamp = (TIMESTAMP_STRUCT far *) rgbValue;
				lpSqlNodeParameter->value.Time.hour = lpTimestamp->hour;
				lpSqlNodeParameter->value.Time.minute = lpTimestamp->minute;
				lpSqlNodeParameter->value.Time.second = lpTimestamp->second;
				break;
			case SQL_C_BINARY:
				lpSqlNodeParameter->value.Time =
											*((TIME_STRUCT far *) rgbValue);
				break;
			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		case TYPE_TIMESTAMP:
			switch (fCType) {
			case SQL_C_CHAR:
				err = CharToTimestamp((LPUSTR)rgbValue, cbValue,
								 &(lpSqlNodeParameter->value.Timestamp));
				if (err != ERR_SUCCESS)
					return err;
				break;
			case SQL_C_SSHORT:
			case SQL_C_USHORT:
			case SQL_C_SLONG:
			case SQL_C_ULONG:
			case SQL_C_FLOAT:
			case SQL_C_DOUBLE:
			case SQL_C_BIT:
			case SQL_C_STINYINT:
			case SQL_C_UTINYINT:
				return ERR_NOTCONVERTABLE;
			case SQL_C_DATE:
				lpDate = (DATE_STRUCT far *) rgbValue;
				lpSqlNodeParameter->value.Timestamp.year = lpDate->year;
				lpSqlNodeParameter->value.Timestamp.month = lpDate-> month;
				lpSqlNodeParameter->value.Timestamp.day = lpDate-> day;
				lpSqlNodeParameter->value.Timestamp.hour = 0;
				lpSqlNodeParameter->value.Timestamp.minute = 0;
				lpSqlNodeParameter->value.Timestamp.second = 0;
				lpSqlNodeParameter->value.Timestamp.fraction = 0;
				break;
			case SQL_C_TIME:
				lpTime = (TIME_STRUCT far *) rgbValue;

				time(&t);
				ts = localtime(&t);

				lpSqlNodeParameter->value.Timestamp.year = ts->tm_year + 1900;
				lpSqlNodeParameter->value.Timestamp.month = ts->tm_mon + 1;
				lpSqlNodeParameter->value.Timestamp.day = (UWORD) ts->tm_mday;
				lpSqlNodeParameter->value.Timestamp.hour = (WORD) lpTime->hour;
				lpSqlNodeParameter->value.Timestamp.minute = lpTime->minute;
				lpSqlNodeParameter->value.Timestamp.second = lpTime->second;
				lpSqlNodeParameter->value.Timestamp.fraction = 0;
				break;
			case SQL_C_TIMESTAMP:
				lpSqlNodeParameter->value.Timestamp =
										*((TIMESTAMP_STRUCT far *) rgbValue);
				break;
			case SQL_C_BINARY:
				lpSqlNodeParameter->value.Timestamp =
										*((TIMESTAMP_STRUCT far *) rgbValue);
				break;
			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		case TYPE_BINARY:
			lpSqlNodeParameter->value.Binary = ToString(
					  lpstmt->lpSqlStmt, lpSqlNodeParameter->node.parameter.Value);
			switch (fCType) {
			case SQL_C_CHAR:

				/* Get true length of source string */
				if (cbValue == SQL_NTS)
					cbValue = s_lstrlen((char*)rgbValue);
				else if (cbValue < 0)
					cbValue = 0;

				/* If am odd numbe of characters, discard the last one */
				if (((cbValue/2) * 2) != cbValue)
					cbValue--;

				/* Figure out the offset to write at */
				if (pcbOffset != NULL)
					cbOffset = *pcbOffset;
				else
					cbOffset = 0;

				/* Make sure we don't write past the end of the buffer */
				if (cbValue > ((MAX_BINARY_LITERAL_LENGTH - cbOffset) * 2)) {
					cbValue = (MAX_BINARY_LITERAL_LENGTH - cbOffset) * 2;
					err = ERR_DATATRUNCATED;
				}

				/* Copy the data */
				lpFrom = (LPUSTR) rgbValue;
				lpTo = BINARY_DATA(lpSqlNodeParameter->value.Binary) +
																   cbOffset;
				for (i=0; i < cbValue; i++) {

					/* Convert the next character to a binary digit */
					if ((*lpFrom >= '0') && (*lpFrom <= '9'))
						nibble = *lpFrom - '0';
					else if ((*lpFrom >= 'A') && (*lpFrom <= 'F'))
						nibble = *lpFrom - 'A';
					else if ((*lpFrom >= 'a') && (*lpFrom <= 'f'))
						nibble = *lpFrom - 'a';
					else
						return ERR_NOTCONVERTABLE;

					/* Are we writing the left or right side of the byte? */
					if (((i/2) * 2) != i) {

						/* The left side. Shift the nibble over */
						*lpTo = nibble << 4;
					}
					else {

						/* The right side.  Add the nibble in */
						*lpTo |= (nibble);
						
						/* Point at next binary byte */
						lpTo++;
					}

					/* Look at next character */
					lpFrom++;
				}

				/* Set the new length */
				if (cbOffset == 0)
					BINARY_LENGTH(lpSqlNodeParameter->value.Binary) =
																cbValue/2;
				else
					BINARY_LENGTH(lpSqlNodeParameter->value.Binary) =
																(cbValue/2)+
						BINARY_LENGTH(lpSqlNodeParameter->value.Binary);

				/* Return new offset */
				if (pcbOffset != NULL)
					*pcbOffset += (cbValue/2);
				break;

			case SQL_C_SSHORT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 2);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 2;
				break;
			case SQL_C_USHORT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 2);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 2;
				break;
			case SQL_C_SLONG:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 4);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 4;
				break;
			case SQL_C_ULONG:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 4);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 4;
				break;
			case SQL_C_FLOAT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 4);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 4;
				break;
			case SQL_C_DOUBLE:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 8);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 8;
				break;
			case SQL_C_BIT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 1);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 1;
				break;
			case SQL_C_STINYINT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 1);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 1;
				break;
			case SQL_C_UTINYINT:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 1);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 1;
				break;
			case SQL_C_DATE:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 6);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 6;
				break;
			case SQL_C_TIME:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 6);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 6;
				break;
			case SQL_C_TIMESTAMP:
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  rgbValue, 16);
				BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = 16;
				break;
			case SQL_C_BINARY:

				/* Get true lengthof source string */
				if (cbValue < 0)
					cbValue = 0;

				/* Figure out the offset to write at */
				if (pcbOffset != NULL)
					cbOffset = *pcbOffset;
				else
					cbOffset = 0;

				/* Make sure we don't write past the end of the buffer */
				if (cbValue > (MAX_BINARY_LITERAL_LENGTH - cbOffset)) {
					cbValue = MAX_BINARY_LITERAL_LENGTH - cbOffset;
					err = ERR_DATATRUNCATED;
				}

				/* Copy the data */
				_fmemcpy(BINARY_DATA(lpSqlNodeParameter->value.Binary) +
								  cbOffset, rgbValue, (SWORD) cbValue);
				if (cbOffset == 0)
					BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = cbValue;
				else
					BINARY_LENGTH(lpSqlNodeParameter->value.Binary) = cbValue+
						BINARY_LENGTH(lpSqlNodeParameter->value.Binary);
				if (pcbOffset != NULL)
					*pcbOffset += (cbValue);
				break;

			default:
				return ERR_NOTSUPPORTED;
			}
			break;

		default:
			return ERR_NOTSUPPORTED;
		}
	}
	return err;
}

/***************************************************************************/

RETCODE INTFUNC Rewind(LPSTMT lpstmt, LPSQLNODE lpSqlNode,
			BOOL fOuterJoinIsNull)

/* Rewinds the table or table list identified by lpSqlNode */

{
#define MAX_RESTRICTIONS 10
	LPSQLTREE   lpSql;
	SWORD       err;
	LPSQLNODE   lpSqlNodeComparison;
	LPSQLNODE   lpSqlNodeColumn;
	LPSQLNODE   lpSqlNodeValue;
	LPSQLNODE   lpSqlNodeTable;
	LPSQLNODE   lpSqlNodeTables;
	SQLNODEIDX  idxRestrict;
	UWORD       cRestrict;
	UWORD       fOperator[MAX_RESTRICTIONS];
 	SWORD       fCType[MAX_RESTRICTIONS];
 	PTR         rgbValue[MAX_RESTRICTIONS]; 
	SDWORD      cbValue[MAX_RESTRICTIONS];
	UWORD       icol[MAX_RESTRICTIONS];

	lpSql = lpstmt->lpSqlStmt;
	switch (lpSqlNode->sqlNodeType) {
	case NODE_TYPE_TABLES:
		
		/* Rewind this table */
		lpSqlNodeTable = ToNode(lpSql, lpSqlNode->node.tables.Table);
		err = Rewind(lpstmt, lpSqlNodeTable, fOuterJoinIsNull);
		if (err != ERR_SUCCESS)
			return err;

		/* Are there other tables on the list? */
		if (lpSqlNode->node.tables.Next != NO_SQLNODE) {

			/* Yes.  Find next record */
			while (TRUE) {

				/* Is this the right side of a NULL outer join? */
                if ((lpSqlNodeTable->node.table.OuterJoinPredicate !=
                                NO_SQLNODE) && fOuterJoinIsNull)

                    /* Yes.  This table has NULLs also */
                    err = ISAM_EOF;

                else {

                    /* No.  Position the current table to the next record */
                    err = ISAMNextRecord(lpSqlNodeTable->node.table.Handle, lpstmt);
                    if ((err == NO_ISAM_ERR) || (err == ISAM_EOF))
                        lpstmt->fISAMTxnStarted = TRUE;
                }

                /* End of file? */
                if (err == ISAM_EOF) {

                    /* Yes.  Is this table the right side of an outer join */
                    if (lpSqlNodeTable->node.table.OuterJoinPredicate ==
                                NO_SQLNODE) {

                        /* No.  No more records */
			return ERR_NODATAFOUND;
			}
                    else {

                        /* Yes.  Use a record of all nulls */
                        err = ERR_SUCCESS;
                        lpSqlNodeTable->node.table.AllNull = TRUE;
                        fOuterJoinIsNull = TRUE;
                    }
                }
				else if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}

				/* Rewind the other tables */
				lpSqlNodeTables = ToNode(lpSql, lpSqlNode->node.tables.Next);
				err = Rewind(lpstmt, lpSqlNodeTables, fOuterJoinIsNull);
				if (err == ERR_SUCCESS)
					break;
				if (err != ERR_NODATAFOUND)
					return err;
			}
		}
		break;

	case NODE_TYPE_TABLE:

		/* Did the optimizer find any restrictions? */
		if (lpSqlNode->node.table.Restrict != 0) {

			/* Yes.  For each restriction found... */
            		cRestrict = 0;
            		idxRestrict = lpSqlNode->node.table.Restrict;
            		while (idxRestrict != NO_SQLNODE) {

	                /* Get the restriction */
                	lpSqlNodeComparison = ToNode(lpSql, idxRestrict);


			/* Get the column */
			lpSqlNodeColumn = ToNode(lpSql, lpSqlNodeComparison->node.comparison.Left);
			icol[cRestrict] = lpSqlNodeColumn->node.column.Id;

			/* Get the operator */
			switch (lpSqlNodeComparison->node.comparison.Operator) {
			case OP_EQ:
				fOperator[cRestrict] = ISAM_OP_EQ;
				break;
			case OP_NE:
				fOperator[cRestrict] = ISAM_OP_NE;
				break;
			case OP_LE:
				fOperator[cRestrict] = ISAM_OP_LE;
				break;
			case OP_LT:
				fOperator[cRestrict] = ISAM_OP_LT;
				break;
			case OP_GE:
				fOperator[cRestrict] = ISAM_OP_GE;
				break;
			case OP_GT:
				fOperator[cRestrict] = ISAM_OP_GT;
				break;
			default:
				return ERR_INTERNAL;
			}

			/* Calculate the key value */
			lpSqlNodeValue = ToNode(lpSql,
									lpSqlNodeComparison->node.comparison.Right);
			err = EvaluateExpression(lpstmt, lpSqlNodeValue);
			if (err != ERR_SUCCESS)
				return err;

			/* Put restriction on the list */
			switch (lpSqlNodeValue->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				fCType[cRestrict] = SQL_C_DOUBLE;
                    		rgbValue[cRestrict] = &(lpSqlNodeValue->value.Double); 
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ?
                                   		SQL_NULL_DATA : sizeof(double);
				break;
			case TYPE_NUMERIC:
				fCType[cRestrict] = SQL_C_CHAR; 
                    		rgbValue[cRestrict] = lpSqlNodeValue->value.String;
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                    		s_lstrlen(lpSqlNodeValue->value.String);
				break;
			case TYPE_CHAR:
				fCType[cRestrict] = SQL_C_CHAR;
                    		rgbValue[cRestrict] = lpSqlNodeValue->value.String;
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                    		s_lstrlen(lpSqlNodeValue->value.String);
				break;
			case TYPE_DATE:
				fCType[cRestrict] = SQL_C_DATE; 
                    		rgbValue[cRestrict] = &(lpSqlNodeValue->value.Date),
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ?
                                  		(SDWORD) SQL_NULL_DATA : sizeof(DATE_STRUCT);
				break;
			case TYPE_TIME:
				fCType[cRestrict] = SQL_C_TIME; 
                    		rgbValue[cRestrict] = &(lpSqlNodeValue->value.Time);
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ?
                                  		(SDWORD) SQL_NULL_DATA : sizeof(TIME_STRUCT);
				break;
			case TYPE_TIMESTAMP:
				fCType[cRestrict] = SQL_C_TIMESTAMP; 
                    		rgbValue[cRestrict] = &(lpSqlNodeValue->value.Timestamp);
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ?
                             			(SDWORD) SQL_NULL_DATA : sizeof(TIMESTAMP_STRUCT);
				break;
			case TYPE_BINARY:
				fCType[cRestrict] = SQL_C_BINARY; 
                    		rgbValue[cRestrict] = BINARY_DATA(lpSqlNodeValue->value.Binary);
                    		cbValue[cRestrict] = lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                    		BINARY_LENGTH(lpSqlNodeValue->value.Binary);
				break;
			default:
				return ERR_NOTSUPPORTED;
			}

			/* Increase count */
                	cRestrict++;

 	               /* Leave loop if maximum number of restrictions found */
        	        if (cRestrict >= MAX_RESTRICTIONS)
                	    break;

	                /* Point at next restriction */
        	        idxRestrict = lpSqlNodeComparison->node.comparison.NextRestrict;
            	}

	            /* Apply the restriction */
        	    err = ISAMRestrict(lpSqlNode->node.table.Handle, cRestrict,
                           icol, fOperator, fCType, rgbValue, cbValue);
			if ((err != NO_ISAM_ERR) && (err != ISAM_NOTSUPPORTED)) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				return err;
			}
			else if (err == NO_ISAM_ERR)
                		lpstmt->fISAMTxnStarted = TRUE;
		}

		/* Rewind the table */
		err = ISAMRewind(lpSqlNode->node.table.Handle);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}
		lpstmt->fISAMTxnStarted = TRUE;
        	lpSqlNode->node.table.Rewound = TRUE;
        	lpSqlNode->node.table.AllNull = FALSE;

		break;

	default:
		return ERR_INTERNAL;
	}
	return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC NextRawRecord (LPSTMT       lpstmt, 
							   LPSQLNODE    lpSqlNode)

/* Finds the next record in in the table or table list.                    */
/*                                                                         */
/* If a list of tables is given, the leftmost table spins the slowest      */
/* and the rightmost table spins the fastest.  In otherwords, for each     */
/* row in a table, we iterate over the rows in the tables after that table */

{
	LPSQLTREE   lpSql;
	SWORD err;
	LPSQLNODE lpSqlNodeTable;
	LPSQLNODE lpSqlNodeTables;
	LPSQLNODE lpSqlNodeOuterJoinPredicate;

	lpSql = lpstmt->lpSqlStmt;
	switch (lpSqlNode->sqlNodeType) {
	case NODE_TYPE_TABLES:
		
		/* Are there any more tables on the list? */
		lpSqlNodeTable = ToNode(lpSql, lpSqlNode->node.tables.Table);
        if (lpSqlNode->node.tables.Next != NO_SQLNODE) {

            /* Yes.  Look for next record in the rest of the list */
            while (TRUE) {

                /* Move to the next record on rest of the table list */
                lpSqlNodeTables = ToNode(lpSql, lpSqlNode->node.tables.Next);
		err = NextRawRecord(lpstmt, lpSqlNodeTables);
		if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
				return err;

		/* If a no more records, continue below */
                if (err == ERR_NODATAFOUND)
                    break;

                /* Is this table on right side of an outer join? */
                if (lpSqlNodeTable->node.table.OuterJoinPredicate !=
                                                            NO_SQLNODE) {

                    /* Yes.  Are we on the row of NULLs? */
                    if (!lpSqlNodeTable->node.table.AllNull) {

                        /* No.  Test ON predicate */
                        lpSqlNodeOuterJoinPredicate = ToNode(lpSql,
                            lpSqlNodeTable->node.table.OuterJoinPredicate);

                        /* Test outer join criteria */
                        err = EvaluateExpression(lpstmt,
                                            lpSqlNodeOuterJoinPredicate);
                        if (err != ERR_SUCCESS)
                            return err;

                        /* If record does not pass outer join criteria, */
                        /* try next one */
                        if ((lpSqlNodeOuterJoinPredicate->sqlIsNull) ||
                            (lpSqlNodeOuterJoinPredicate->value.Double !=
                                                                TRUE)) {
                            continue;
                        }

                        /* If record passes outer join criteria, use it */
                        else {
                            lpSqlNodeTable->node.table.Rewound = FALSE;
                        }
                    }
                }
                break;
            }

            /* If a record was found, return it */
            if (err == ERR_SUCCESS)
                break;



		}
		
		/* Loop until a record is found */
		while (TRUE) {

			/* Position to the next record in this table. */
			err = NextRawRecord(lpstmt, lpSqlNodeTable);
			if (err != ERR_SUCCESS)
				return err;

			/* More tables on the list? */
			if (lpSqlNode->node.tables.Next != NO_SQLNODE) {

				/* Yes.  Rewind the other tables on the list */
				lpSqlNodeTables = ToNode(lpSql, lpSqlNode->node.tables.Next);
				err = Rewind(lpstmt, lpSqlNodeTables,
						lpSqlNodeTable->node.table.AllNull);
				if (err == ERR_NODATAFOUND)
					continue;
				if (err != ERR_SUCCESS)
					return err;

				/* Get the first record from the other tables on the list */
				err = NextRawRecord(lpstmt, lpSqlNodeTables);
				if (err == ERR_NODATAFOUND)
					continue;
				if (err != ERR_SUCCESS)
					return err;
			}

			/* Is this table on right side of an outer join? */
            if (lpSqlNodeTable->node.table.OuterJoinPredicate !=
                                                            NO_SQLNODE) {

                /* Yes.  Are we on the row of NULLs? */
                if (!lpSqlNodeTable->node.table.AllNull) {

                    /* No.  Test ON predicate */
                    lpSqlNodeOuterJoinPredicate = ToNode(lpSql,
                            lpSqlNodeTable->node.table.OuterJoinPredicate);

                    /* Test outer join criteria */
                    err = EvaluateExpression(lpstmt,
                                            lpSqlNodeOuterJoinPredicate);
                    if (err != ERR_SUCCESS)
                        return err;

                    /* If record does not pass outer join criteria, */
                    /* try next one */
                    if ((lpSqlNodeOuterJoinPredicate->sqlIsNull) ||
                        (lpSqlNodeOuterJoinPredicate->value.Double != TRUE)) {
                        continue;
                    }

                    /* If record passes outer join criteria, use it */
                    else {
                        lpSqlNodeTable->node.table.Rewound = FALSE;
                    }
                }
            }

			break;
		}
		break;

	case NODE_TYPE_TABLE:

		/* If currently on a record of all NULLs, error */
        	if ((lpSqlNode->node.table.OuterJoinPredicate != NO_SQLNODE) &&
                                    lpSqlNode->node.table.AllNull)
			return ERR_NODATAFOUND;

		/* Are we already on a record of all nulls? */
        if (lpSqlNode->node.table.AllNull)

            /* Yes.  Stay there */
            err = ISAM_EOF;
        else {

            /* No.  Get the next record from the ISAM */
            err = ISAMNextRecord(lpSqlNode->node.table.Handle, lpstmt);
            if ((err == NO_ISAM_ERR) || (err == ISAM_EOF))
                lpstmt->fISAMTxnStarted = TRUE;
        }

        if (err == ISAM_EOF) {

            /* End of table.  If not an outer join, error */
            if (lpSqlNode->node.table.OuterJoinPredicate == NO_SQLNODE)
                return ERR_NODATAFOUND;

            /* If this is not first read, error */
            if (!(lpSqlNode->node.table.Rewound))
                return ERR_NODATAFOUND;

            /* Otherwise, use a record of all NULLs */
            lpSqlNode->node.table.AllNull = TRUE;
        }
		else if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}

		break;

	default:
		return ERR_INTERNAL;
	}
	return ERR_SUCCESS;
}

/***************************************************************************/

RETCODE INTFUNC NextRecord (LPSTMT          lpstmt, 
					LPSQLNODE               lpSqlNode, 
					LPSQLNODE               lpSqlNodePredicate)

/* Finds the next record in in the table or table list identified by       */
/* lpSqlNode that satisfies the predicate lpSqlNodePredicte.               */
/*                                                                         */
/* If a list of tables is given, the leftmost table spins the slowest      */
/* and the rightmost table spins the fastest.  In otherwords, for each     */
/* row in a table, we iterate over the rows in the tables after that table */

{
	SWORD err;

	/* Loop until a record is found */
	while (TRUE) {

		/* Go to next record */
		err = NextRawRecord(lpstmt, lpSqlNode);
		if (err != ERR_SUCCESS)
			return err;

		/* If no predicate, this record qualifies. */
		if (lpSqlNodePredicate == NULL)
			break;

		/* If the predicate is TRUE, return this record */
		err = EvaluateExpression(lpstmt, lpSqlNodePredicate);
		if (err != ERR_SUCCESS)
			return err;
		if (!(lpSqlNodePredicate->sqlIsNull) &&
			(lpSqlNodePredicate->value.Double == TRUE))
			break;
	}
	return ERR_SUCCESS;
}
/***************************************************************************/

int INTFUNC lstrcmp_pad(LPUSTR lpszLeft, LPUSTR lpszRight)

/* Compares two string (blank padding the shorter one to the same length */
/* as the longer one).                                                   */
{
	int cbLeft;
	int cbRight;
	UCHAR chr;
	int result;

	/* Get the length of the two strings */
	cbLeft = s_lstrlen(lpszLeft);
	cbRight = s_lstrlen(lpszRight);

	/* If the strings are the same length, use plain old lstrcmp */
	if (cbLeft == cbRight)
		result = s_lstrcmp(lpszLeft, lpszRight);

	/* If the left one is shorter, swap the strings and try again */
	else if (cbLeft < cbRight)
		result = -(lstrcmp_pad(lpszRight, lpszLeft));

	/* Otherwise the right one is shorter... */
	else {

		/* Truncate the left one to the size of the right one */
		chr = lpszLeft[cbRight];
		lpszLeft[cbRight] = '\0';

		/* Are the strings equal? */
		result = s_lstrcmp(lpszLeft, lpszRight);
		lpszLeft[cbRight] = chr;   /* Untruncate the left one */
		if (result == 0) {

			/* Yes.  Compare remaining characters on the left string to blanks */
			while (cbRight < cbLeft) {
				result = lpszLeft[cbRight] - ' ';
				if (result != 0)
					break;
				cbRight++;
			}
		}
	}
	return result;
}

RETCODE INTFUNC ValueCompare(LPSQLNODE lpSqlNode, LPSQLNODE lpSqlNodeLeft,
                        UWORD Operator, LPSQLNODE lpSqlNodeRight)

/* Compares two values */

{
    RETCODE    err;
    LONG       idx;

    /* Compare values */
    err = ERR_SUCCESS;
    lpSqlNode->sqlIsNull = FALSE;
    switch (lpSqlNodeLeft->sqlDataType) {
    case TYPE_DOUBLE:
    case TYPE_INTEGER:
    case TYPE_NUMERIC:
        err = NumericCompare(lpSqlNode, lpSqlNodeLeft, Operator,
                                                         lpSqlNodeRight);
        if (err != ERR_SUCCESS)
            return err;
        break;

    case TYPE_CHAR:
        switch (Operator) {
        case OP_EQ:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) == 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_NE:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) != 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LE:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) <= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LT:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) < 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GE:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) >= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GT:
            if (lstrcmp_pad(lpSqlNodeLeft->value.String,
                                        lpSqlNodeRight->value.String) > 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LIKE:
            lpSqlNode->value.Double = 
                             PatternMatch(FALSE, lpSqlNodeLeft->value.String, 
                                      s_lstrlen(lpSqlNodeLeft->value.String), 
                                      lpSqlNodeRight->value.String, 
                                      s_lstrlen(lpSqlNodeRight->value.String), 
                                      TRUE);
            break;
        case OP_NOTLIKE:
            lpSqlNode->value.Double = 
                             !(PatternMatch(FALSE, lpSqlNodeLeft->value.String, 
                                        s_lstrlen(lpSqlNodeLeft->value.String), 
                                        lpSqlNodeRight->value.String, 
                                        s_lstrlen(lpSqlNodeRight->value.String), 
                                        TRUE));
            break;
        default:
            err = ERR_INTERNAL;
            break;
        }
        break;
    case TYPE_BINARY:
        switch (Operator) {
        case OP_EQ:
            if (BINARY_LENGTH(lpSqlNodeLeft->value.Binary) ==
                        BINARY_LENGTH(lpSqlNodeRight->value.Binary)) {
                lpSqlNode->value.Double = TRUE;
                for (idx = 0;
                     idx < BINARY_LENGTH(lpSqlNodeRight->value.Binary);
                     idx++) {
                    if (BINARY_DATA(lpSqlNodeLeft->value.Binary)[idx] !=
                            BINARY_DATA(lpSqlNodeRight->value.Binary)[idx]) {
                        lpSqlNode->value.Double = FALSE;
                        break;
                    }
                }
            }
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_NE:
            if (BINARY_LENGTH(lpSqlNodeLeft->value.Binary) ==
                        BINARY_LENGTH(lpSqlNodeRight->value.Binary)) {
                lpSqlNode->value.Double = FALSE;
                for (idx = 0;
                     idx < BINARY_LENGTH(lpSqlNodeRight->value.Binary);
                     idx++) {
                    if (BINARY_DATA(lpSqlNodeLeft->value.Binary)[idx] !=
                            BINARY_DATA(lpSqlNodeRight->value.Binary)[idx]) {
                        lpSqlNode->value.Double = TRUE;
                        break;
                    }
                }
            }
            else
                lpSqlNode->value.Double = TRUE;
            break;
        case OP_LE:
        case OP_LT:
        case OP_GE:
        case OP_GT:
        case OP_LIKE:
        case OP_NOTLIKE:
        default:
            err = ERR_INTERNAL;
            break;
        }
        break;
    case TYPE_DATE:
        switch (Operator) {
        case OP_EQ:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) == 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_NE:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) != 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LE:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) <= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LT:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) < 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GE:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) >= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GT:
            if (DateCompare(lpSqlNodeLeft->value.Date,
                                           lpSqlNodeRight->value.Date) > 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LIKE:
        case OP_NOTLIKE:
        default:
            err = ERR_INTERNAL;
            break;
        }
        break;
    case TYPE_TIME:
        switch (Operator) {
        case OP_EQ:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) == 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_NE:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) != 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LE:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) <= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LT:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) < 0)
                 lpSqlNode->value.Double = TRUE;
            else
                 lpSqlNode->value.Double = FALSE;
            break;
        case OP_GE:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) >= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GT:
            if (TimeCompare(lpSqlNodeLeft->value.Time,
                                        lpSqlNodeRight->value.Time) > 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LIKE:
        case OP_NOTLIKE:
        default:
            err = ERR_INTERNAL;
            break;
        }
        break;
    case TYPE_TIMESTAMP:
        switch (Operator) {
        case OP_EQ:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) == 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_NE:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) != 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LE:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) <= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LT:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) < 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GE:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) >= 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_GT:
            if (TimestampCompare(lpSqlNodeLeft->value.Timestamp,
                                       lpSqlNodeRight->value.Timestamp) > 0)
                lpSqlNode->value.Double = TRUE;
            else
                lpSqlNode->value.Double = FALSE;
            break;
        case OP_LIKE:
        case OP_NOTLIKE:
        default:
            err = ERR_INTERNAL;
            break;
        }
        break;
    default:
        err = ERR_NOTSUPPORTED;
        break;
    }
    return err;
}
/***************************************************************************/
RETCODE INTFUNC RetrieveSortRecordValue(LPSQLNODE lpSqlNodeStmt, LPSQLNODE lpSqlNode,
										UDWORD Offset, UDWORD Length)

/* Retrieves a value from a sort record */

{
	UCHAR      cNullFlag;
	UCHAR      szBuffer[30];
	UWORD      len;
	UDWORD     SortRecordsize;

	szBuffer[0] = 0;
	/* Position to the value */
	if (lpSqlNodeStmt->sqlNodeType != NODE_TYPE_SELECT)
		return ERR_INTERNAL;
	if (!(lpSqlNodeStmt->node.select.ReturningDistinct))
        	SortRecordsize = lpSqlNodeStmt->node.select.SortRecordsize;
	else
		SortRecordsize = lpSqlNodeStmt->node.select.DistinctRecordsize;

	if (_llseek(lpSqlNodeStmt->node.select.Sortfile,
             (lpSqlNodeStmt->node.select.CurrentRow * SortRecordsize)
                                 + Offset - 1, 0) == HFILE_ERROR)
		return ERR_SORT;

	/* Read value */
	switch (lpSqlNode->sqlDataType) {
	case TYPE_DOUBLE:
	case TYPE_INTEGER:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile,
                         &(lpSqlNode->value.Double),
				sizeof(double)) != sizeof(double))
			return ERR_SORT;
		break;

	case TYPE_NUMERIC:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile,
                         lpSqlNode->value.String,
                                (UINT) Length) != (UINT) Length)
			return ERR_SORT;
		lpSqlNode->value.String[Length]='\0';

		/* Remove trailing blanks */
		len = (UWORD) s_lstrlen(lpSqlNode->value.String);
		while ((len > 0) && (lpSqlNode->value.String[len-1] == ' ')) {
			lpSqlNode->value.String[len-1] = '\0';
			len--;
		}
		break;

	case TYPE_CHAR:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile,
                         lpSqlNode->value.String,
                                (UINT) Length) != (UINT) Length)
			return ERR_SORT;
		lpSqlNode->value.String[Length]='\0';

		/* Remove trailing blanks if need be */
		if ((lpSqlNode->sqlSqlType == SQL_VARCHAR) ||
			(lpSqlNode->sqlSqlType == SQL_LONGVARCHAR)) {
			len = (UWORD) s_lstrlen(lpSqlNode->value.String);
			while ((len > 0) && (lpSqlNode->value.String[len-1] == ' ')) {
				lpSqlNode->value.String[len-1] = '\0';
				len--;
			}
		}
		break;

	case TYPE_DATE:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile, szBuffer,
                                (UINT) Length) != (UINT) Length)
			return ERR_SORT;
		CharToDate((LPUSTR)szBuffer, Length, &(lpSqlNode->value.Date));
		break;

	case TYPE_TIME:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile, szBuffer,
                                (UINT) Length) != (UINT) Length)
			return ERR_SORT;
		CharToTime((LPUSTR)szBuffer, Length, &(lpSqlNode->value.Time));
		break;

	case TYPE_TIMESTAMP:
		if (_lread(lpSqlNodeStmt->node.select.Sortfile, szBuffer,
                                (UINT) Length) != (UINT) Length)
			return ERR_SORT;
		CharToTimestamp((LPUSTR)szBuffer, Length, &(lpSqlNode->value.Timestamp));
		break;

	case TYPE_BINARY:
		return ERR_INTERNAL;

	default:
		return ERR_NOTSUPPORTED;
	}

	/* Read NULL flag */
	if (_lread(lpSqlNodeStmt->node.select.Sortfile, &cNullFlag, 1) != 1)
		return ERR_SORT;
	switch (cNullFlag) {
	case NULL_FLAG:
		lpSqlNode->sqlIsNull = TRUE;
		break;
	case NOT_NULL_FLAG:
		lpSqlNode->sqlIsNull = FALSE;
		break;
	default:
		return ERR_SORT;
	}

	return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC TxnCapableForDDL(LPSTMT lpstmt)

/* Makes sure the DDL statements can be executed if DML statements were */
/* encountered */

{
    LPSTMT lpstmtOther;
    RETCODE err;

    /* What transaction capabilities are allowed? */
    switch (lpstmt->lpdbc->lpISAM->fTxnCapable) {
    case SQL_TC_NONE:

        /* No transactions.  Allow all DDL statements all the time */
        break;
    
    case SQL_TC_DML:

        /* Transactions can never DDL statements */
        for (lpstmtOther = lpstmt->lpdbc->lpstmts;
             lpstmtOther != NULL;
             lpstmtOther = lpstmtOther->lpNext) {
            if (lpstmtOther->fDMLTxn)
                return ERR_DDLENCOUNTERD;
        }
        break;

    case SQL_TC_DDL_COMMIT:

        /* Transactions that contain DDL statements cause a commit */
        for (lpstmtOther = lpstmt->lpdbc->lpstmts;
             lpstmtOther != NULL;
             lpstmtOther = lpstmtOther->lpNext) {
            if (lpstmtOther->fDMLTxn) {
                err = SQLTransact(SQL_NULL_HENV, (HDBC)lpstmt->lpdbc,
                                  SQL_COMMIT);
                if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO)) {
                    lpstmt->errcode = lpstmt->lpdbc->errcode;
                    s_lstrcpy(lpstmt->szISAMError, lpstmt->lpdbc->szISAMError);
                    return err;
                }
                if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                    return ERR_DDLSTATEMENTLOST;
                else
                    return ERR_DDLCAUSEDACOMMIT;
            }
        }
        break;

    case SQL_TC_DDL_IGNORE:

        /* DDL statements are ignored within a transaction */
        for (lpstmtOther = lpstmt->lpdbc->lpstmts;
             lpstmtOther != NULL;
             lpstmtOther = lpstmtOther->lpNext) {
            if (lpstmtOther->fDMLTxn)
                return ERR_DDLIGNORED;
        }
        break;

    case SQL_TC_ALL:

        /* Allow all DDL statements all the time */
        break;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
/***************************************************************************/
RETCODE INTFUNC FetchRow(LPSTMT lpstmt, LPSQLNODE lpSqlNode)

/* Fetch the next row from a SELECT */
{
    LPSQLNODE lpSqlNodeTable;
    LPSQLNODE lpSqlNodeTables;
    LPSQLNODE lpSqlNodePredicate;
    LPSQLNODE lpSqlNodeHaving;
    SQLNODEIDX idxTables;
    ISAMBOOKMARK bookmark;
    RETCODE err;

//	ODBCTRACE("\nWBEM ODBC Driver : FetchRow\n");

    /* Error if after the last row */
    if (lpSqlNode->node.select.CurrentRow == AFTER_LAST_ROW)
        return ERR_NODATAFOUND;

    /* Is there a sort file to read from */
    if (lpSqlNode->node.select.Sortfile == HFILE_ERROR) {

        /* No.  Get the table list and predicate node. */
        lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.select.Tables); 
        if (lpSqlNode->node.select.Predicate == NO_SQLNODE)
            lpSqlNodePredicate = NULL;
        else
            lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.select.Predicate); 

        /* Get the next record */
        err = NextRecord(lpstmt, lpSqlNodeTables, lpSqlNodePredicate);
        if (err == ERR_NODATAFOUND) {
            lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
            return err;
        }
        else if (err != ERR_SUCCESS)
            return err;

        /* Set row flag */
        if (lpSqlNode->node.select.CurrentRow == BEFORE_FIRST_ROW)
            lpSqlNode->node.select.CurrentRow = 0;
        else
            lpSqlNode->node.select.CurrentRow++;
    }
    else if (!(lpSqlNode->node.select.ReturningDistinct)) {

        /* Yes.  Look for next record in sort file */
        if (lpSqlNode->node.select.Having == NO_SQLNODE)
            lpSqlNodeHaving = NULL;
        else
            lpSqlNodeHaving =
                    ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.select.Having);
        while (TRUE) {

            /* Set row flag */
            if (lpSqlNode->node.select.CurrentRow == BEFORE_FIRST_ROW) {
                if (lpSqlNode->node.select.RowCount != 0) {
                    lpSqlNode->node.select.CurrentRow = 0;
                }
                else {
                    lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
                    return ERR_NODATAFOUND;
                }
            }
            else if (lpSqlNode->node.select.CurrentRow ==
                                        lpSqlNode->node.select.RowCount-1) {
                lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
                return ERR_NODATAFOUND;
            }
            else
                lpSqlNode->node.select.CurrentRow++;

            /* If no HAVING clause, this record qualifies */
            if (lpSqlNodeHaving == NULL)
                break;

            /* If HAVING condition is satisfied, this record qualifies */
            err = EvaluateExpression(lpstmt, lpSqlNodeHaving);
            if (err != ERR_SUCCESS)
                return err;
            if (!(lpSqlNodeHaving->sqlIsNull) &&
                (lpSqlNodeHaving->value.Double == TRUE))
                break;
        }

        /* Is there a group by? */
        if ((lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) &&
            (!lpSqlNode->node.select.ImplicitGroupby)) {

            /* No.  Position to bookmarks in that row */
            if (_llseek(lpSqlNode->node.select.Sortfile,
                        (lpSqlNode->node.select.CurrentRow *
                                 lpSqlNode->node.select.SortRecordsize) +
                 lpSqlNode->node.select.SortBookmarks - 1, 0) == HFILE_ERROR)
                return ERR_SORT;

            /* For each table... */
            idxTables = lpSqlNode->node.select.Tables;
            while (idxTables != NO_SQLNODE) {

                /* Get the table node */
                lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt, idxTables); 
                lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                        lpSqlNodeTables->node.tables.Table);

                /* Read the bookmark for it */
                if (_lread(lpSqlNode->node.select.Sortfile, &bookmark,
                             sizeof(ISAMBOOKMARK)) != sizeof(ISAMBOOKMARK))
                    return ERR_SORT;

                /* Position to that record */
				if (bookmark.currentRecord == NULL_BOOKMARK)
				{
					lpSqlNodeTable->node.table.AllNull = TRUE;
				}
				else
				{
					lpSqlNodeTable->node.table.AllNull = FALSE;
					err = ISAMPosition(lpSqlNodeTable->node.table.Handle, &bookmark);
					if (err != NO_ISAM_ERR) {
						ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
												(LPUSTR)lpstmt->szISAMError);
						return err;
					}
					lpstmt->fISAMTxnStarted = TRUE;
				}
                /* Point at next table */
                idxTables = lpSqlNodeTables->node.tables.Next;
            }
        }
    }
    else {

        /* Yes.  Look for next record in DISTINCT file.  Set row flag */
        if (lpSqlNode->node.select.CurrentRow == BEFORE_FIRST_ROW) {
            if (lpSqlNode->node.select.RowCount != 0) {
                lpSqlNode->node.select.CurrentRow = 0;
            }
            else {
                lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
                return ERR_NODATAFOUND;
            }
        }
        else if (lpSqlNode->node.select.CurrentRow ==
                                        lpSqlNode->node.select.RowCount-1) {
            lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;
            return ERR_NODATAFOUND;
        }
        else
            lpSqlNode->node.select.CurrentRow++;
    }
    return ERR_SUCCESS;
}
/***************************************************************************/
RETCODE INTFUNC EvaluateExpression(LPSTMT lpstmt, LPSQLNODE lpSqlNode)

/* Eavluates an SQL expression by walking the parse tree, computing */
/* the value of each node with respect to a database record, and    */
/* storing the result in the string area.                           */

{
//	ODBCTRACE ("\nWBEM ODBC Driver : EvaluateExpression\n");
	LPSQLTREE lpSql;
	LPSQLNODE lpSqlNodeLeft = 0;
	LPSQLNODE lpSqlNodeRight = 0;
	RETCODE err;
	SQLNODEIDX idxValues;
	LPSQLNODE  lpSqlNodeValues;
	LPUSTR      lpWorkBuffer1;
	LPUSTR      lpWorkBuffer2;
	LPUSTR      lpWorkBuffer3;
	BOOL       fReturningDistinct;
    	LPSQLNODE  lpSqlNodeSelect;
    	BOOL       fTruncation;
    	BOOL       fIsNull;

	lpSql = lpstmt->lpSqlStmt;
	if (lpSqlNode == NULL)
		return ERR_INTERNAL;

	err = ERR_SUCCESS;
	switch (lpSqlNode->sqlNodeType) { 
	case NODE_TYPE_NONE:
	case NODE_TYPE_ROOT:
	case NODE_TYPE_CREATE:
	case NODE_TYPE_DROP:
	case NODE_TYPE_SELECT:
	case NODE_TYPE_INSERT:
	case NODE_TYPE_DELETE:
	case NODE_TYPE_UPDATE:
	case NODE_TYPE_CREATEINDEX:
    	case NODE_TYPE_DROPINDEX:
	case NODE_TYPE_PASSTHROUGH:
	case NODE_TYPE_TABLES:
	case NODE_TYPE_VALUES:
	case NODE_TYPE_COLUMNS:
	case NODE_TYPE_SORTCOLUMNS:
	case NODE_TYPE_GROUPBYCOLUMNS:
	case NODE_TYPE_UPDATEVALUES:
	case NODE_TYPE_CREATECOLS:
	case NODE_TYPE_TABLE:
		err = ERR_INTERNAL;
		break;
		
	case NODE_TYPE_BOOLEAN:

		/* Evaluate the left child node */
		lpSqlNodeLeft = ToNode(lpSql, lpSqlNode->node.boolean.Left);
		err = EvaluateExpression(lpstmt, lpSqlNodeLeft);
		if (err != ERR_SUCCESS)
			return err;

		/* Is this an AND? */
        if (lpSqlNode->node.boolean.Operator == OP_AND) {

            LPSQLNODE lpSqlNodeAnd;
            BOOL sqlIsNull;
            BOOL fResult;

            /* Yes.  Look at each sub-expression */
            lpSqlNodeAnd = lpSqlNode;
            sqlIsNull = FALSE;
            fResult = TRUE;
            while (TRUE) {

                /* If the left child is FALSE, return FALSE */
                if (!((BOOL) lpSqlNodeLeft->value.Double)) {
                    sqlIsNull = FALSE;
                    fResult = FALSE;
                    break;
                }

                /* If the left child is NULL, the result may be NULL */
                else if (lpSqlNodeLeft->sqlIsNull) {
                    sqlIsNull = TRUE;
                    fResult = FALSE;
                }

                /* Get the right child */
                lpSqlNodeRight = ToNode(lpSql, lpSqlNode->node.boolean.Right);

                /* Is it an AND node? */
                if ((lpSqlNodeRight->sqlNodeType != NODE_TYPE_BOOLEAN) ||
                    (lpSqlNodeRight->node.boolean.Operator != OP_AND)) {

                    /* No.  Evaluate it */
                    err = EvaluateExpression(lpstmt, lpSqlNodeRight);
                    if (err != ERR_SUCCESS)
                        return err;

                    /* If the right child is FALSE, return FALSE */
                    if (!((BOOL) lpSqlNodeRight->value.Double)) {
                        sqlIsNull = FALSE;
                        fResult = FALSE;
                    }

                    /* If the right child is NULL, the result is NULL */
                    else if (lpSqlNodeRight->sqlIsNull) {
                        sqlIsNull = TRUE;
                        fResult = FALSE;
                    }

                    /* Leave the loop */
                    break;

                }

                /* Point to right and continue to walk down the AND nodes */
                lpSqlNode = lpSqlNodeRight;
                lpSqlNodeLeft = ToNode(lpSql, lpSqlNode->node.boolean.Left);
                err = EvaluateExpression(lpstmt, lpSqlNodeLeft);
                if (err != ERR_SUCCESS)
                    return err;
            }

            /* Return result */
            lpSqlNodeAnd->sqlIsNull = sqlIsNull;
            lpSqlNodeAnd->value.Double = fResult;
            break;
        }

		/* Is there a right child? */
		if (lpSqlNode->node.boolean.Right != NO_SQLNODE) {

			/* Yes.  Evaluate it */
			lpSqlNodeRight = ToNode(lpSql, lpSqlNode->node.boolean.Right);
			err = EvaluateExpression(lpstmt, lpSqlNodeRight);
			if (err != ERR_SUCCESS)
				return err;
		}

		if (lpSqlNode->node.boolean.Operator != OP_NOT && lpSqlNodeRight == 0)
				return ERR_INTERNAL;
				
		/* Perform the operation. */
		switch (lpSqlNode->node.boolean.Operator) {
		case OP_NOT:

			/* If child is NULL, return NULL */
			if (lpSqlNodeLeft->sqlIsNull) {
				lpSqlNode->sqlIsNull = TRUE;
				break;
			}

			/* Evaluate expression */
			lpSqlNode->sqlIsNull = FALSE;
			lpSqlNode->value.Double = !((BOOL) lpSqlNodeLeft->value.Double);
			break;

		case OP_AND:

			/* Is left child NULL or TRUE? */
			if ((lpSqlNodeLeft->sqlIsNull) ||
				((BOOL) lpSqlNodeLeft->value.Double)) {

				/* Yes.  If right child is NULL, return NULL */
				if (lpSqlNodeRight->sqlIsNull)
					lpSqlNode->sqlIsNull = TRUE;

				/* If right child TRUE, return left child */
				else if ((BOOL) lpSqlNodeRight->value.Double) {
					lpSqlNode->sqlIsNull = lpSqlNodeLeft->sqlIsNull;
					lpSqlNode->value.Double = lpSqlNodeLeft->value.Double;
				}

				/* Otherwise right child must be FALSE, return FALSE */
				else {
					lpSqlNode->sqlIsNull = FALSE;
					lpSqlNode->value.Double = FALSE;
				}
			}

			/* Otherwise left child must be FALSE, return FALSE */
			else {
				lpSqlNode->sqlIsNull = FALSE;
				lpSqlNode->value.Double = FALSE;
			}
			break;

		case OP_OR:

			/* Is left child NULL or FALSE? */
			if ((lpSqlNodeLeft->sqlIsNull) ||
				(!((BOOL) lpSqlNodeLeft->value.Double))) {

				/* Yes.  If right child is NULL, return NULL */
				if (lpSqlNodeRight->sqlIsNull)
					lpSqlNode->sqlIsNull = TRUE;

				/* If right child FALSE, return left child */
				else if (!((BOOL) lpSqlNodeRight->value.Double)) {
					lpSqlNode->sqlIsNull = lpSqlNodeLeft->sqlIsNull;
					lpSqlNode->value.Double = lpSqlNodeLeft->value.Double;
				}

				/* Otherwise right child must be TRUE, return TRUE */
				else {
					lpSqlNode->sqlIsNull = FALSE;
					lpSqlNode->value.Double = TRUE;
				}
			}

			/* Otherwise left child must be TRUE, return TRUE */
			else {
				lpSqlNode->sqlIsNull = FALSE;
				lpSqlNode->value.Double = TRUE;
			}
			break;

		default:
			err = ERR_INTERNAL;
			break;
		}
		break;

	case NODE_TYPE_COMPARISON:

//		ODBCTRACE ("\nWBEM ODBC Driver : NODE_TYPE_COMPARISON\n");
		/* Evaluate the left child */
		if (lpSqlNode->node.comparison.Operator != OP_EXISTS) {
            		lpSqlNodeLeft = ToNode(lpSql, lpSqlNode->node.comparison.Left);
			err = EvaluateExpression(lpstmt, lpSqlNodeLeft);
			if (err != ERR_SUCCESS)
				return err;
		}

        /* EXISTS operator? */
        if (lpSqlNode->node.comparison.Operator == OP_EXISTS) {

            /* Do the sub-select */
            lpSqlNodeSelect = ToNode(lpSql, lpSqlNode->node.comparison.Left);
            err = ExecuteQuery(lpstmt, lpSqlNodeSelect);
            if (err == ERR_DATATRUNCATED)
                err = ERR_SUCCESS;
            if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                return err;

            /* Try to fetch a row */
            if (err == ERR_SUCCESS) {
                err = FetchRow(lpstmt, lpSqlNodeSelect);
                if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                    return err;
            }

            /* Return result */
            lpSqlNode->sqlIsNull = FALSE;
            if (err == ERR_NODATAFOUND)
                lpSqlNode->value.Double = FALSE;
            else
                lpSqlNode->value.Double = TRUE;
        }

        /* Nested sub-select? */
        else if (lpSqlNode->node.comparison.SelectModifier !=
                                                     SELECT_NOTSELECT) {

            /* Yes.  If left child is NULL, return NULL */
            if (lpSqlNodeLeft->sqlIsNull) {
                lpSqlNode->sqlIsNull = TRUE;
                lpSqlNode->value.Double = 0;
                break;
            }

            /* Do the sub-select */
            fTruncation = FALSE;
            lpSqlNodeSelect = ToNode(lpSql, lpSqlNode->node.comparison.Right);
            lpSqlNodeRight = ToNode(lpSql, lpSqlNodeSelect->node.select.Values);
            lpSqlNodeRight = ToNode(lpSql, lpSqlNodeRight->node.values.Value);
            err = ExecuteQuery(lpstmt,
                            ToNode(lpSql, lpSqlNode->node.comparison.Right));
            if (err == ERR_DATATRUNCATED) {
                fTruncation = TRUE;
                err = ERR_SUCCESS;
            }
            if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                return err;

            /* Get the first value */
            if (err == ERR_SUCCESS) {
//				ODBCTRACE ("\nWBEM ODBC Driver : Get the first value\n");
                err = FetchRow(lpstmt, lpSqlNodeSelect);
                if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                    return err;
            }

            /* Does the select return any rows? */
            if (err == ERR_NODATAFOUND) {

                /* No.  Return result */
                lpSqlNode->sqlIsNull = FALSE;
                switch (lpSqlNode->node.comparison.SelectModifier) {
                case SELECT_NOTSELECT:
                    return ERR_INTERNAL;
                case SELECT_ALL: 
                    lpSqlNode->value.Double = TRUE;
                    break;
                case SELECT_ANY: 
                    lpSqlNode->value.Double = FALSE;
                    break;
                case SELECT_ONE:
                    return ERR_NOTSINGLESELECT;
                    break;
                case SELECT_EXISTS:
                default:
                    return ERR_INTERNAL;
                }
            }
            else {

                /* Yes.  For each value returned */
                fIsNull = FALSE;
                while (TRUE) {

                    /* Get value */
                    err = EvaluateExpression(lpstmt, lpSqlNodeRight);
                    if (err != ERR_SUCCESS)
                        return err;

                    /* Null value? */
                    if (!lpSqlNodeRight->sqlIsNull) {

                        /* No.  Compare the values */
                        err = ValueCompare(lpSqlNode, lpSqlNodeLeft,
                                       lpSqlNode->node.comparison.Operator,
                                       lpSqlNodeRight);
                        if (err != ERR_SUCCESS)
                            return err;

                        /* Add it into the result */
                        switch (lpSqlNode->node.comparison.SelectModifier) {
                        case SELECT_NOTSELECT:
                            return ERR_INTERNAL;
                        case SELECT_ALL: 
                            if (lpSqlNode->value.Double == FALSE) {
                                lpSqlNode->sqlIsNull = FALSE;
                                if (fTruncation)
                                    return ERR_DATATRUNCATED;
                                return ERR_SUCCESS;
                            }
                            break;
                        case SELECT_ANY: 
                            if (lpSqlNode->value.Double == TRUE) {
                                lpSqlNode->sqlIsNull = FALSE;
                                if (fTruncation)
                                    return ERR_DATATRUNCATED;
                                return ERR_SUCCESS;
                            }
                            break;
                        case SELECT_ONE:
                            break;
                        case SELECT_EXISTS:
                        default:
                            return ERR_INTERNAL;
                        }
                    }
                    else
                        fIsNull = TRUE;

                    /* Get next value */
//					ODBCTRACE ("\nWBEM ODBC Driver : Get next value\n");
                    err = FetchRow(lpstmt, lpSqlNodeSelect);
                    if (err == ERR_NODATAFOUND)
                        break;
                    if (err != ERR_SUCCESS)
                        return err;

                    /* Error if too mnay values */
                    if (lpSqlNode->node.comparison.SelectModifier==SELECT_ONE)
                        return ERR_NOTSINGLESELECT;
                }

                /* Figure out final answer */
                err = ERR_SUCCESS;
                if (fIsNull) {
                    lpSqlNode->sqlIsNull = TRUE;
                    lpSqlNode->value.Double = 0;
                }
                else {
                    lpSqlNode->sqlIsNull = FALSE;
                    switch (lpSqlNode->node.comparison.SelectModifier) {
                    case SELECT_NOTSELECT:
                        return ERR_INTERNAL;
                    case SELECT_ALL: 
                        lpSqlNode->value.Double = TRUE;
                        break;
                    case SELECT_ANY: 
                        lpSqlNode->value.Double = FALSE;
                        break;
                    case SELECT_ONE:
                        /* This was set by the call to ValueCompare above */
                        break;
                    case SELECT_EXISTS:
                    default:
                        return ERR_INTERNAL;
                    }
                }

                /* Return truncation error if need be */
                if (fTruncation)
                    err = ERR_DATATRUNCATED;
            }
        }

		/* IN or NOT IN operator? */
		else if ((lpSqlNode->node.comparison.Operator != OP_IN) &&
			(lpSqlNode->node.comparison.Operator != OP_NOTIN)) {

			/* No. Evaluate the right child */
			lpSqlNodeRight = ToNode(lpSql, lpSqlNode->node.comparison.Right);
			err = EvaluateExpression(lpstmt, lpSqlNodeRight);
			if (err != ERR_SUCCESS)
				return err;

			/* Could this be an "IS NULL" or "IS NOT NULL" expression? */
			if (lpSqlNodeRight->sqlIsNull &&
				((lpSqlNodeRight->sqlNodeType == NODE_TYPE_NULL) ||
				 (lpSqlNodeRight->sqlNodeType == NODE_TYPE_PARAMETER))) {

				/* Possibly.  Is this an "IS NULL" expression? */
				if (lpSqlNode->node.comparison.Operator == OP_EQ) {

					/* Yes.  Return TRUE if the left child is NULL.  */
					lpSqlNode->sqlIsNull = FALSE;
					if (lpSqlNodeLeft->sqlIsNull)
						lpSqlNode->value.Double = TRUE;
					else
						lpSqlNode->value.Double = FALSE;
					break;
				}

				/* Is this an "IS NOT NULL" expression? */
				else if (lpSqlNode->node.comparison.Operator == OP_NE) {

					/* Yes.  Return FALSE if the left child is NULL.  */
					lpSqlNode->sqlIsNull = FALSE;
					if (lpSqlNodeLeft->sqlIsNull)
						lpSqlNode->value.Double = FALSE;
					else
						lpSqlNode->value.Double = TRUE;
					break;
				}
			}

			/* If either child is NULL, return NULL */
			if (lpSqlNodeLeft->sqlIsNull || lpSqlNodeRight->sqlIsNull) {
				lpSqlNode->sqlIsNull = TRUE;
				lpSqlNode->value.Double = 0;
				break;
			}

			/* Compare values */
			err = ValueCompare(lpSqlNode, lpSqlNodeLeft,
                        lpSqlNode->node.comparison.Operator, lpSqlNodeRight);
            		if (err != ERR_SUCCESS)
                		return err;
		}
		else {

			/* Yes.  If test value is NULL, return NULL */
			if (lpSqlNodeLeft->sqlIsNull) {
				lpSqlNode->sqlIsNull = TRUE;
				lpSqlNode->value.Double = 0;
				break;
			}

			/* Set up the default answer */
			lpSqlNode->sqlIsNull = FALSE;
			lpSqlNode->value.Double = FALSE;

			/* For each value on list... */
			idxValues = lpSqlNode->node.comparison.Right;
			while (idxValues != NO_SQLNODE) {

				/* Get the value */
				lpSqlNodeValues = ToNode(lpSql, idxValues);
				lpSqlNodeRight = ToNode(lpSql, lpSqlNodeValues->node.values.Value);
				err = EvaluateExpression(lpstmt, lpSqlNodeRight);
				if (err != ERR_SUCCESS)
					return err;

				/* Point at next value */
				idxValues = lpSqlNodeValues->node.values.Next;

				/* If this value is NULL, go on to the next one */
				if (lpSqlNodeRight->sqlIsNull)
					continue;

				/* Compare this value to the test value */
				err = ValueCompare(lpSqlNode, lpSqlNodeLeft, OP_EQ,
                                            lpSqlNodeRight);

				if (err != ERR_SUCCESS)
					return err;
					

				/* If value was found, leave */
				if (lpSqlNode->value.Double == TRUE)
					break;
			}

			/* If NOT IN operator, negate the answer */
			if (lpSqlNode->node.comparison.Operator == OP_NOTIN) {
				if (lpSqlNode->value.Double == TRUE)
					lpSqlNode->value.Double = FALSE;
				else
					lpSqlNode->value.Double = TRUE;
			}
		}
		break;

	case NODE_TYPE_ALGEBRAIC:

		/* Set up return buffer */
		switch (lpSqlNode->sqlDataType) {
		case TYPE_NUMERIC:
			lpSqlNode->value.String =
					ToString(lpSql,lpSqlNode->node.algebraic.Value);
			break;
		case TYPE_CHAR:
			lpSqlNode->value.String =
					ToString(lpSql,lpSqlNode->node.algebraic.Value);
			break;
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			break;
		case TYPE_BINARY:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}
		
		/* Is this value in the sort DISTINCT record? */
		lpSqlNodeSelect = ToNode(lpSql,
                            lpSqlNode->node.algebraic.EnclosingStatement);
        	if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT)
            	fReturningDistinct = FALSE;
        	else
            	fReturningDistinct = lpSqlNodeSelect->node.select.ReturningDistinct;
        	if (!fReturningDistinct) {
		
			/* No.  Evaluate the left child */
			lpSqlNodeLeft = ToNode(lpSql, lpSqlNode->node.algebraic.Left);
			err = EvaluateExpression(lpstmt, lpSqlNodeLeft);
			if (err != ERR_SUCCESS)
				return err;

			/* If left child is NULL, the expression is null */
			if (lpSqlNodeLeft->sqlIsNull) {
				lpSqlNode->sqlIsNull = TRUE;
				break;
			} 

			/* Evaluate the right child (if any) */
			if (lpSqlNode->node.algebraic.Right != NO_SQLNODE) {
				lpSqlNodeRight = ToNode(lpSql, lpSqlNode->node.algebraic.Right);
				err = EvaluateExpression(lpstmt, lpSqlNodeRight);
				if (err != ERR_SUCCESS)
					return err;

				/* If right child is NULL, the expression is null */
				if (lpSqlNodeRight->sqlIsNull) {
					lpSqlNode->sqlIsNull = TRUE;
					break;
				} 
			}
			else
				lpSqlNodeRight = NULL;

			/* Result is not null */
			lpSqlNode->sqlIsNull = FALSE;

			/* Perform the operation */
			lpWorkBuffer1 = NULL;
			lpWorkBuffer2 = NULL;
			lpWorkBuffer3 = NULL;
			switch (lpSqlNode->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
			case TYPE_DATE:
			case TYPE_TIME:
			case TYPE_TIMESTAMP:
				break;
			case TYPE_NUMERIC:
				if ((lpSqlNode->node.algebraic.Operator == OP_TIMES) ||
					(lpSqlNode->node.algebraic.Operator == OP_DIVIDEDBY)) {
					lpWorkBuffer1 =
							ToString(lpSql,lpSqlNode->node.algebraic.WorkBuffer1);
					if (lpSqlNode->node.algebraic.Operator == OP_DIVIDEDBY) {
						lpWorkBuffer2 =
							ToString(lpSql,lpSqlNode->node.algebraic.WorkBuffer2);
						lpWorkBuffer3 =
							ToString(lpSql,lpSqlNode->node.algebraic.WorkBuffer3);
					}
				}
				break;
			case TYPE_CHAR:
				break;
			case TYPE_BINARY:
				return ERR_INTERNAL;
			default:
				return ERR_NOTSUPPORTED;
			}
			err = NumericAlgebra(lpSqlNode, lpSqlNodeLeft,
							lpSqlNode->node.algebraic.Operator, lpSqlNodeRight,
							lpWorkBuffer1, lpWorkBuffer2, lpWorkBuffer3);
			if (err != ERR_SUCCESS)
				return err;
		}
		else {
			/* Yes.  Get the record */
			err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                   lpSqlNode->node.algebraic.DistinctOffset,
                                   lpSqlNode->node.algebraic.DistinctLength);
            if (err != ERR_SUCCESS)
                return err;
        }
        break;

    case NODE_TYPE_SCALAR:

        /* Set up return buffer */
        switch (lpSqlNode->sqlDataType) {
        case TYPE_NUMERIC:
            lpSqlNode->value.String =
                              ToString(lpSql,lpSqlNode->node.scalar.Value);
            break;
        case TYPE_CHAR:
            lpSqlNode->value.String =
                              ToString(lpSql,lpSqlNode->node.scalar.Value);
            break;
        case TYPE_DOUBLE:
        case TYPE_INTEGER:
        case TYPE_DATE:
        case TYPE_TIME:
        case TYPE_TIMESTAMP:
            break;
        case TYPE_BINARY:
            lpSqlNode->value.String =
                              ToString(lpSql,lpSqlNode->node.scalar.Value);
            break;
        default:
            return ERR_NOTSUPPORTED;
        }
        
        /* Is this value in the sort DISTINCT record? */
        lpSqlNodeSelect = ToNode(lpSql,
                            lpSqlNode->node.scalar.EnclosingStatement);
        if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT)
            fReturningDistinct = FALSE;
        else
            fReturningDistinct = lpSqlNodeSelect->node.select.ReturningDistinct;
        if (!fReturningDistinct) {
        
            /* Perform the operation */
            err = EvaluateScalar(lpstmt, lpSqlNode);
            if (err != ERR_SUCCESS)
                return err;
        }
        else {
            /* Yes.  Get the record */
            err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                      lpSqlNode->node.scalar.DistinctOffset,
                                      lpSqlNode->node.scalar.DistinctLength);

			if (err != ERR_SUCCESS)
				return err;
		}

		break;

	case NODE_TYPE_AGGREGATE:

		/* Set up return buffer */
		switch (lpSqlNode->sqlDataType) {
		case TYPE_NUMERIC:
			lpSqlNode->value.String =
					ToString(lpSql,lpSqlNode->node.aggregate.Value);
			break;
		case TYPE_CHAR:
			lpSqlNode->value.String =
					ToString(lpSql,lpSqlNode->node.aggregate.Value);
			break;
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			break;
		case TYPE_BINARY:
			return ERR_INTERNAL;
		default:
			return ERR_NOTSUPPORTED;
		}

		/* Retrieve the value */
		lpSqlNodeSelect = ToNode(lpSql,
                            lpSqlNode->node.aggregate.EnclosingStatement);
        if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT)
            fReturningDistinct = FALSE;
        else
            fReturningDistinct = lpSqlNodeSelect->node.select.ReturningDistinct;
        if (fReturningDistinct) {
            err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                 lpSqlNode->node.aggregate.DistinctOffset,
                                 lpSqlNode->node.aggregate.DistinctLength);
		}
		else {
			err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                      lpSqlNode->node.aggregate.Offset,
                                      lpSqlNode->node.aggregate.Length);
		}
		if (err != ERR_SUCCESS)
			return err;
		break;

	case NODE_TYPE_COLUMN:

		/* Set up return buffer */
		switch (lpSqlNode->sqlDataType) {
		case TYPE_NUMERIC:
			lpSqlNode->value.String = ToString(lpSql,lpSqlNode->node.column.Value);
			break;
		case TYPE_CHAR:
			lpSqlNode->value.String = ToString(lpSql,lpSqlNode->node.column.Value);
			break;
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
			break;
		case TYPE_BINARY:
			lpSqlNode->value.Binary = ToString(lpSql,lpSqlNode->node.column.Value);
			break;
		default:
			return ERR_NOTSUPPORTED;
		}

		/* Is this column in the sort DISTINCT record? */
		lpSqlNodeSelect = ToNode(lpSql,
                            lpSqlNode->node.column.EnclosingStatement);
        if (lpSqlNodeSelect->sqlNodeType != NODE_TYPE_SELECT)
            fReturningDistinct = FALSE;
        else
            fReturningDistinct = lpSqlNodeSelect->node.select.ReturningDistinct;
        if (fReturningDistinct) {


			/* Yes.  Retrieve the value */
			err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                    lpSqlNode->node.column.DistinctOffset,
                                    lpSqlNode->node.column.DistinctLength);
			if (err != ERR_SUCCESS)
				return err;
		}

		/* Is this column in the sort record? */
		else if (!(lpSqlNode->node.column.InSortRecord)) {

			SDWORD size;
			LPSQLNODE   lpSqlNodeTable;

			/* No.  Get the column value from the current record */
			lpSqlNodeTable = ToNode(lpSql, lpSqlNode->node.column.Table);
            		if (!(lpSqlNodeTable->node.table.AllNull)) {
			switch (lpSqlNode->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							  lpSqlNode->node.column.Id, 0, SQL_C_DOUBLE,
							  &(lpSqlNode->value.Double), sizeof(double),
							  &size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else
					lpSqlNode->sqlIsNull = FALSE;
				break;

			case TYPE_NUMERIC:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							lpSqlNode->node.column.Id, 0, SQL_C_CHAR,
							lpSqlNode->value.String,
							(SDWORD) (1 + 2 + lpSqlNode->sqlPrecision),
							&size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else {
					lpSqlNode->sqlIsNull = FALSE;
					BCDNormalize(lpSqlNode->value.String,
								 s_lstrlen(lpSqlNode->value.String),
								 lpSqlNode->value.String,
								 lpSqlNode->sqlPrecision + 2 + 1,
								 lpSqlNode->sqlPrecision,
								 lpSqlNode->sqlScale);
				}
				break;

			case TYPE_CHAR:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							lpSqlNode->node.column.Id, 0, SQL_C_CHAR,
							lpSqlNode->value.String,
							(SDWORD) (1 + lpSqlNode->sqlPrecision),
							&size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else
					lpSqlNode->sqlIsNull = FALSE;
				break;

			case TYPE_DATE:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							  lpSqlNode->node.column.Id, 0, SQL_C_DATE,
							  &(lpSqlNode->value.Date), sizeof(DATE_STRUCT),
							  &size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else
					lpSqlNode->sqlIsNull = FALSE;
				break;

			case TYPE_TIME:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							  lpSqlNode->node.column.Id, 0, SQL_C_TIME,
							  &(lpSqlNode->value.Time), sizeof(TIME_STRUCT),
							  &size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else
					lpSqlNode->sqlIsNull = FALSE;
				break;

			case TYPE_TIMESTAMP:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							  lpSqlNode->node.column.Id, 0, SQL_C_TIMESTAMP,
							  &(lpSqlNode->value.Timestamp), sizeof(TIMESTAMP_STRUCT),
							  &size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA)
					lpSqlNode->sqlIsNull = TRUE;
				else
					lpSqlNode->sqlIsNull = FALSE;
				break;

			case TYPE_BINARY:
				err = ISAMGetData(lpSqlNodeTable->node.table.Handle,
							lpSqlNode->node.column.Id, 0, SQL_C_BINARY,
							BINARY_DATA(lpSqlNode->value.Binary),
							(SDWORD) lpSqlNode->sqlPrecision,
							&size);
				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
				if (size == SQL_NULL_DATA) {
					lpSqlNode->sqlIsNull = TRUE;
					BINARY_LENGTH(lpSqlNode->value.Binary) = 0;
				}
				else {
					lpSqlNode->sqlIsNull = FALSE;
					BINARY_LENGTH(lpSqlNode->value.Binary) = size;
				}
				break;

			default:
				err = ERR_NOTSUPPORTED;
				break;
			}
		}
		else {
			err = NO_ISAM_ERR;
                lpSqlNode->sqlIsNull = TRUE;
                switch (lpSqlNode->sqlDataType) {
                case TYPE_DOUBLE:
                case TYPE_INTEGER:
                    lpSqlNode->value.Double = 0.0;
                    break;
                case TYPE_NUMERIC:
                    s_lstrcpy(lpSqlNode->value.String, "");
                    break;
                case TYPE_CHAR:
                    s_lstrcpy(lpSqlNode->value.String, "");
                    break;
                case TYPE_DATE:
                    lpSqlNode->value.Date.year = 0;
                    lpSqlNode->value.Date.month = 0;
                    lpSqlNode->value.Date.day = 0;
                    break;
                case TYPE_TIME:
                    lpSqlNode->value.Time.hour = 0;
                    lpSqlNode->value.Time.minute = 0;
                    lpSqlNode->value.Time.second = 0;
                    break;
                case TYPE_TIMESTAMP:
                    lpSqlNode->value.Timestamp.year = 0;
                    lpSqlNode->value.Timestamp.month = 0;
                    lpSqlNode->value.Timestamp.day = 0;
                    lpSqlNode->value.Timestamp.hour = 0;
                    lpSqlNode->value.Timestamp.minute = 0;
                    lpSqlNode->value.Timestamp.second = 0;
                    lpSqlNode->value.Timestamp.fraction = 0;
                    break;
                case TYPE_BINARY:
                    BINARY_LENGTH(lpSqlNode->value.Binary) = 0;
                    break;
                default:
                    err = ERR_NOTSUPPORTED;
                    break;
                }
            }
        }
        else {

			/* Yes.  Retrieve the value */
			err = RetrieveSortRecordValue(lpSqlNodeSelect, lpSqlNode,
                                    lpSqlNode->node.column.Offset,
                                    lpSqlNode->node.column.Length);
			if (err != ERR_SUCCESS)
				return err;
		}

		break;

	case NODE_TYPE_STRING:
		lpSqlNode->sqlIsNull = FALSE;
		lpSqlNode->value.String = ToString(lpSql, lpSqlNode->node.string.Value);
		break;
	
	case NODE_TYPE_NUMERIC:
		lpSqlNode->sqlIsNull = FALSE;
		switch(lpSqlNode->sqlDataType) {
		case TYPE_NUMERIC:
			lpSqlNode->value.String =
						 ToString(lpSql, lpSqlNode->node.numeric.Numeric);
			break;
		case TYPE_DOUBLE:
		case TYPE_INTEGER:
			lpSqlNode->value.Double = lpSqlNode->node.numeric.Value;
			break;
		case TYPE_CHAR:
		case TYPE_DATE:
		case TYPE_TIME:
		case TYPE_TIMESTAMP:
		case TYPE_BINARY:
		default:
			return ERR_INTERNAL;
		}
		break;
	
	case NODE_TYPE_PARAMETER:
		break;
	
	case NODE_TYPE_USER:
		lpSqlNode->sqlIsNull = FALSE;
		lpSqlNode->value.String =
				(LPUSTR) ISAMUser(ToNode(lpSql, ROOT_SQLNODE)->node.root.lpISAM);
		break;
	
	case NODE_TYPE_NULL:
		lpSqlNode->sqlIsNull = TRUE;
		break;
	
	case NODE_TYPE_DATE:
		lpSqlNode->sqlIsNull = FALSE;
		lpSqlNode->value.Date = lpSqlNode->node.date.Value;
		break;
	
	case NODE_TYPE_TIME:
		lpSqlNode->sqlIsNull = FALSE;
		lpSqlNode->value.Time = lpSqlNode->node.time.Value;
		break;
	
	case NODE_TYPE_TIMESTAMP:
		lpSqlNode->sqlIsNull = FALSE;
		lpSqlNode->value.Timestamp = lpSqlNode->node.timestamp.Value;
		break;
	
	default:
		return ERR_INTERNAL;
	}
	return err;
}
/***************************************************************************/

RETCODE INTFUNC Sort(LPSTMT   lpstmt, LPSQLNODE lpSqlNodeSelect)

/* Sorts results of a SELECT statement */

{

//	ODBCTRACE("\nWBEM ODBC Driver : Sort\n");
#ifdef WIN32
	UCHAR szTempDir[MAX_PATHNAME_SIZE+1];
	szTempDir[0] = 0;
#endif
	UCHAR szFilename[MAX_PATHNAME_SIZE+1];
	szFilename[0] = 0;
	HFILE_BUFFER hfSortfile;
    	HFILE hfSortfile2;
	LPSQLNODE lpSqlNodeTables;
	LPSQLNODE lpSqlNodePredicate;
	RETCODE err;
	SQLNODEIDX idxSortcolumns;
	LPSQLNODE lpSqlNodeSortcolumns;
	SQLNODEIDX idxGroupbycolumns;
	LPSQLNODE lpSqlNodeGroupbycolumns;
	LPSQLNODE lpSqlNodeColumn;
	SDWORD len;
	PTR ptr;
	SQLNODEIDX idxTableList;
	LPSQLNODE lpSqlNodeTableList;
	LPSQLNODE lpSqlNodeTable;
	ISAMBOOKMARK bookmark;
	UCHAR szBuffer[20+TIMESTAMP_SCALE+1];
	long recordCount;
	int sortStatus;
	UCHAR cNullFlag;
	SQLNODEIDX idxAggregate;
	LPSQLNODE lpSqlNodeAggregate;
	LPSQLNODE lpSqlNodeExpression;
	double dbl;

	szBuffer[0] = 0;

	/* Create temporary file */
#ifdef WIN32
	if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR)szTempDir))
		return ERR_SORT;
	if (!GetTempFileName((LPSTR)szTempDir, "LEM", 0, (LPSTR)szFilename))
		return ERR_SORT;
#else
	GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename);
#endif
	hfSortfile = _lcreat_buffer((LPCSTR) szFilename, 0);
    	if (hfSortfile == NULL)
        	return ERR_SORT;

	/* Get the table list and predicate node. */
	lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt,
                             lpSqlNodeSelect->node.select.Tables); 
    	if (lpSqlNodeSelect->node.select.Predicate == NO_SQLNODE)
        	lpSqlNodePredicate = NULL;
    	else
        	lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt,
                                    lpSqlNodeSelect->node.select.Predicate); 

	/* For each record of result set... */
	lpSqlNodeSelect->node.select.RowCount = 0;
	while (TRUE) {

		/* Get the next record */
		err = NextRecord(lpstmt, lpSqlNodeTables,
						 lpSqlNodePredicate);
		if (err == ERR_NODATAFOUND) {
			if (lpSqlNodeSelect->node.select.CurrentRow == BEFORE_FIRST_ROW) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		lpSqlNodeSelect->node.select.CurrentRow = AFTER_LAST_ROW;
                		return ERR_SUCCESS;
			}
			break;
		}
		else if (err != ERR_SUCCESS) {
			_lclose_buffer(hfSortfile);
            		DeleteFile((LPCSTR) szFilename);
            		return err;
		}

		/* Set row flag */
		if (lpSqlNodeSelect->node.select.CurrentRow == BEFORE_FIRST_ROW)
            		lpSqlNodeSelect->node.select.CurrentRow = 0;
        	else
            		lpSqlNodeSelect->node.select.CurrentRow++;


		/* Increase row count */
		(lpSqlNodeSelect->node.select.RowCount)++;

		/* If there is a GROUP BY, puts the columns in the sort file in */
		/* the order specified by the GROUP BY list.  Otherwise put the */
		/* the column in the sort file in the order specified by the    */
		/* ORDER BY list.  For each sort key value or group by value... */
		if (lpSqlNodeSelect->node.select.ImplicitGroupby) {
			idxGroupbycolumns = NO_SQLNODE;
			idxSortcolumns = NO_SQLNODE;
		}
		else {
			idxGroupbycolumns = lpSqlNodeSelect->node.select.Groupbycolumns;
            		if (idxGroupbycolumns == NO_SQLNODE)
                		idxSortcolumns = lpSqlNodeSelect->node.select.Sortcolumns;
            		else
                		idxSortcolumns = NO_SQLNODE;
		}
		while ((idxSortcolumns != NO_SQLNODE) ||
			   (idxGroupbycolumns != NO_SQLNODE)) {

			/* Get next column */
			if (idxGroupbycolumns != NO_SQLNODE) {
				lpSqlNodeGroupbycolumns =
							ToNode(lpstmt->lpSqlStmt, idxGroupbycolumns);
				lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt,
							lpSqlNodeGroupbycolumns->node.groupbycolumns.Column);
			}
			else {
				lpSqlNodeSortcolumns =
							ToNode(lpstmt->lpSqlStmt, idxSortcolumns);
				lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt,
							lpSqlNodeSortcolumns->node.sortcolumns.Column);
			}

			/* Get its value */
			err = EvaluateExpression(lpstmt, lpSqlNodeColumn);
			if (err != ERR_SUCCESS) {
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return err;
			}

			/* Get length and pointer to key value */
			switch (lpSqlNodeColumn->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				if (lpSqlNodeColumn->sqlIsNull)
					lpSqlNodeColumn->value.Double = -1.7E308; //RAID 27433
				len = sizeof(double);
				ptr = &(lpSqlNodeColumn->value.Double);
				break;
			case TYPE_NUMERIC:
				if (lpSqlNodeColumn->sqlIsNull)
					(lpSqlNodeColumn->value.String)[0] = 0;
				len = lpSqlNodeColumn->sqlPrecision + 2;
				ptr = lpSqlNodeColumn->value.String;

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeColumn->value.String) < len)
					s_lstrcat(lpSqlNodeColumn->value.String, " ");
				break;
			case TYPE_CHAR:                
				if (lpSqlNodeColumn->sqlIsNull)
					(lpSqlNodeColumn->value.String)[0] = 0;
				len = lpSqlNodeColumn->sqlPrecision;
				ptr = lpSqlNodeColumn->value.String;

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeColumn->value.String) < len)
					s_lstrcat(lpSqlNodeColumn->value.String, " ");
				break;
			case TYPE_BINARY:                
				if (lpSqlNodeColumn->sqlIsNull)
					BINARY_LENGTH(lpSqlNodeColumn->value.Binary) = 0;
				len = lpSqlNodeColumn->sqlPrecision;
				ptr = BINARY_DATA(lpSqlNodeColumn->value.Binary);

				/* (zero pad binary values) */
				while (BINARY_LENGTH(lpSqlNodeColumn->value.Binary) < len) {
					BINARY_DATA(lpSqlNodeColumn->value.Binary)[
						BINARY_LENGTH(lpSqlNodeColumn->value.Binary)] = 0;
					BINARY_LENGTH(lpSqlNodeColumn->value.Binary) =
						BINARY_LENGTH(lpSqlNodeColumn->value.Binary) + 1;
				}
				break;
			case TYPE_DATE:                
				if (lpSqlNodeColumn->sqlIsNull) {
					lpSqlNodeColumn->value.Date.year = 0;
					lpSqlNodeColumn->value.Date.month = 0;
					lpSqlNodeColumn->value.Date.day = 0;
				}
				DateToChar(&(lpSqlNodeColumn->value.Date), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIME:                
				if (lpSqlNodeColumn->sqlIsNull) {
					lpSqlNodeColumn->value.Time.hour = 0;
					lpSqlNodeColumn->value.Time.minute = 0;
					lpSqlNodeColumn->value.Time.second = 0;
				}
				TimeToChar(&(lpSqlNodeColumn->value.Time), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIMESTAMP:                
				if (lpSqlNodeColumn->sqlIsNull) {
					lpSqlNodeColumn->value.Timestamp.year = 0;
					lpSqlNodeColumn->value.Timestamp.month = 0;
					lpSqlNodeColumn->value.Timestamp.day = 0;
					lpSqlNodeColumn->value.Timestamp.hour = 0;
					lpSqlNodeColumn->value.Timestamp.minute = 0;
					lpSqlNodeColumn->value.Timestamp.second = 0;
					lpSqlNodeColumn->value.Timestamp.fraction = 0;
				}
				TimestampToChar(&(lpSqlNodeColumn->value.Timestamp), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			default:
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_INTERNAL;
			}

			/* Put value into the file */
			if (_lwrite_buffer(hfSortfile, (LPSTR) ptr, (UINT) len) != (UINT) len) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_SORT;
			}

			/* Put inthe null flag */
			if (lpSqlNodeColumn->sqlIsNull) 
				cNullFlag = NULL_FLAG;
			else
				cNullFlag = NOT_NULL_FLAG;
			if (_lwrite_buffer(hfSortfile, (LPSTR) &cNullFlag, 1) != 1) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_SORT;
			}

			/* Point at next key value */
			if (idxGroupbycolumns != NO_SQLNODE)
				idxGroupbycolumns =
					lpSqlNodeGroupbycolumns->node.groupbycolumns.Next;
			else
				idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
		}

		/* Put the AGG function values into the record */
		idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
		while (idxAggregate != NO_SQLNODE) {

			/* Get next aggregate */
			lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

			/* Get its value */
			if (lpSqlNodeAggregate->node.aggregate.Operator != AGG_COUNT) {
				lpSqlNodeExpression = ToNode(lpstmt->lpSqlStmt,
								   lpSqlNodeAggregate->node.aggregate.Expression);
				err = EvaluateExpression(lpstmt, lpSqlNodeExpression);
				if (err != ERR_SUCCESS) {
					_lclose_buffer(hfSortfile);
                    			DeleteFile((LPCSTR) szFilename);
                    			return err;
				}
			}

			/* Get length and pointer to key value */
			switch (lpSqlNodeAggregate->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				if (lpSqlNodeAggregate->node.aggregate.Operator != AGG_COUNT) {
					if (lpSqlNodeExpression->sqlDataType != TYPE_NUMERIC) {
						if (lpSqlNodeExpression->sqlIsNull)
							lpSqlNodeExpression->value.Double = 0.0;
						len = sizeof(double);
						ptr = &(lpSqlNodeExpression->value.Double);
					}
					else {
						CharToDouble(lpSqlNodeExpression->value.String,
								  s_lstrlen(lpSqlNodeExpression->value.String),
								  FALSE, -1.7E308, 1.7E308, &dbl);
						len = sizeof(double);
						ptr = &dbl;
					}
				}
				else {
					lpSqlNodeAggregate->value.Double = 1.0;
					len = sizeof(double);
					ptr = &(lpSqlNodeAggregate->value.Double);
				}
				break;
			case TYPE_NUMERIC:
				if (lpSqlNodeExpression->sqlIsNull)
					(lpSqlNodeExpression->value.String)[0] = 0;
				len = lpSqlNodeAggregate->node.aggregate.Length;
				ptr = lpSqlNodeExpression->value.String;

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeExpression->value.String) < len)
					s_lstrcat(lpSqlNodeExpression->value.String, " ");
				break;
			case TYPE_CHAR:                
				if (lpSqlNodeExpression->sqlIsNull)
					(lpSqlNodeExpression->value.String)[0] = 0;
				len = lpSqlNodeAggregate->node.aggregate.Length;
				ptr = lpSqlNodeExpression->value.String;

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeExpression->value.String) < len)
					s_lstrcat(lpSqlNodeExpression->value.String, " ");
				break;
			case TYPE_BINARY:                
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_INTERNAL;
			case TYPE_DATE:                
				if (lpSqlNodeExpression->sqlIsNull) {
					lpSqlNodeExpression->value.Date.year = 0;
					lpSqlNodeExpression->value.Date.month = 0;
					lpSqlNodeExpression->value.Date.day = 0;
				}
				DateToChar(&(lpSqlNodeExpression->value.Date), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIME:                
				if (lpSqlNodeExpression->sqlIsNull) {
					lpSqlNodeExpression->value.Time.hour = 0;
					lpSqlNodeExpression->value.Time.minute = 0;
					lpSqlNodeExpression->value.Time.second = 0;
				}
				TimeToChar(&(lpSqlNodeExpression->value.Time), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIMESTAMP:                
				if (lpSqlNodeExpression->sqlIsNull) {
					lpSqlNodeExpression->value.Timestamp.year = 0;
					lpSqlNodeExpression->value.Timestamp.month = 0;
					lpSqlNodeExpression->value.Timestamp.day = 0;
					lpSqlNodeExpression->value.Timestamp.hour = 0;
					lpSqlNodeExpression->value.Timestamp.minute = 0;
					lpSqlNodeExpression->value.Timestamp.second = 0;
					lpSqlNodeExpression->value.Timestamp.fraction = 0;
				}
				TimestampToChar(&(lpSqlNodeExpression->value.Timestamp), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			default:
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_INTERNAL;
			}

			/* Put value into the file */
			if (_lwrite_buffer(hfSortfile, (LPSTR) ptr, (UINT) len) != (UINT) len) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return ERR_SORT;
			}

			/* Put inthe null flag */
			if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_COUNT)
				cNullFlag = NOT_NULL_FLAG;
			else if (lpSqlNodeExpression->sqlIsNull) 
				cNullFlag = NULL_FLAG;
			else
				cNullFlag = NOT_NULL_FLAG;
			if (_lwrite_buffer(hfSortfile, (LPSTR) &cNullFlag, 1) != 1) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return ERR_SORT;
			}

			/* Point at next value */
			idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
		}

		/* For each record in table list... */
		if (lpSqlNodeSelect->node.select.ImplicitGroupby)
			idxTableList = NO_SQLNODE;
		else if (lpSqlNodeSelect->node.select.Groupbycolumns == NO_SQLNODE)
            		idxTableList = lpSqlNodeSelect->node.select.Tables;
		else
			idxTableList = NO_SQLNODE;
		while (idxTableList != NO_SQLNODE) {

			/* Get table */
			lpSqlNodeTableList = ToNode(lpstmt->lpSqlStmt, idxTableList);
			lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
								   lpSqlNodeTableList->node.tables.Table);

			/* Get bookmark of current record */
			if (lpSqlNodeTable->node.table.AllNull)
			{
				bookmark.currentRecord = NULL_BOOKMARK;
			}
			else
			{
				err = ISAMGetBookmark(lpSqlNodeTable->node.table.Handle, &bookmark);
				if (err != ERR_SUCCESS) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					_lclose_buffer(hfSortfile);
                			DeleteFile((LPCSTR) szFilename);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
			}

			/* Put value into the file */
			if (_lwrite_buffer(hfSortfile, (LPSTR) &bookmark, sizeof(ISAMBOOKMARK))
                                    != sizeof(ISAMBOOKMARK)) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_SORT;
            		}

            		/* Point at next table */
            		idxTableList = lpSqlNodeTableList->node.tables.Next;
		}
	}
	if (_lclose_buffer(hfSortfile) == HFILE_ERROR) {
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    	}

	/* Sort the file */
	if (!(lpSqlNodeSelect->node.select.ImplicitGroupby)) {

		/* Sort the file */
		s_1mains((LPSTR) szFilename, (LPSTR) szFilename, (LPSTR)
             		ToString(lpstmt->lpSqlStmt,
                      	lpSqlNodeSelect->node.select.SortDirective),
             		&recordCount, &sortStatus);
		if (sortStatus != 0) {
			DeleteFile((LPCSTR) szFilename);
			return ERR_SORT;
		}
		lpSqlNodeSelect->node.select.RowCount = recordCount;
	}

	/* Open destination file */
	hfSortfile2 = _lopen((LPCSTR) szFilename, OF_READ);
    	if (hfSortfile2 == HFILE_ERROR) {
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_SORT;
    	}

	/* Save name and handle to file of sorted records */
	s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                     lpSqlNodeSelect->node.select.SortfileName), szFilename);
    	lpSqlNodeSelect->node.select.Sortfile = hfSortfile2;
    	lpSqlNodeSelect->node.select.ReturningDistinct = FALSE;

	/* Set up to read first row */
	lpSqlNodeSelect->node.select.CurrentRow = BEFORE_FIRST_ROW;

	return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC GroupBy(LPSTMT   lpstmt, LPSQLNODE lpSqlNodeSelect)

/* Does GROUP BY on results of a SELECT statement */

{
#ifdef WIN32
	UCHAR szTempDir[MAX_PATHNAME_SIZE+1];
	szTempDir[0] = 0;
#endif
	UCHAR szFilename[MAX_PATHNAME_SIZE+1];
	szFilename[0] = 0;
	HFILE_BUFFER hfGroupbyfile;
    	HFILE hfGroupbyfile2;
	HGLOBAL hGlobal;
	LPUSTR lpResultRecord;
	LPUSTR lpCurrentRecord;
	SDWORD cRowCount;
	SDWORD irow;
	SQLNODEIDX idxAggregate;
	LPSQLNODE lpSqlNodeAggregate;
	LPUSTR lpValue;
	LPUSTR lpValueNullFlag;
	LPUSTR lpAggregateValue;
	LPUSTR lpAggregateValueNullFlag;

	/* If nothing to group, just return */
	if (lpSqlNodeSelect->node.select.RowCount == 0)
		return ERR_SUCCESS;

	/* Create temporary file for the result of the group by */
#ifdef WIN32
	if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR)szTempDir))
		return ERR_GROUPBY;
	if (!GetTempFileName((LPSTR)szTempDir, "LEM", 0, (LPSTR)szFilename))
		return ERR_GROUPBY;
#else
	GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename);
#endif
	hfGroupbyfile = _lcreat_buffer((LPCSTR) szFilename, 0);
    	if (hfGroupbyfile == NULL)
        	return ERR_GROUPBY;

	/* Allocate space for a result record buffer */
	hGlobal = GlobalAlloc(GMEM_MOVEABLE,
				(2 * lpSqlNodeSelect->node.select.SortRecordsize));
	if (hGlobal == NULL ||
			   (lpResultRecord = (LPUSTR) GlobalLock(hGlobal)) == NULL) {
		if (hGlobal)
            GlobalFree(hGlobal);

		_lclose_buffer(hfGroupbyfile);
        	DeleteFile((LPCSTR) szFilename);
		return ERR_MEMALLOCFAIL;
	}

	/* Allocate space for current record key buffer */
	lpCurrentRecord = lpResultRecord + lpSqlNodeSelect->node.select.SortRecordsize;

	/* Position to the first record */
	if (_llseek(lpSqlNodeSelect->node.select.Sortfile, 0, 0) == HFILE_ERROR) {
     		GlobalUnlock(hGlobal);
        	GlobalFree(hGlobal);
        	_lclose_buffer(hfGroupbyfile);
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_GROUPBY;
    	}

	/* Read the first record into the result record buffer */
	if (_lread(lpSqlNodeSelect->node.select.Sortfile, lpResultRecord,
                 (UINT) lpSqlNodeSelect->node.select.SortRecordsize) != 
                         (UINT) lpSqlNodeSelect->node.select.SortRecordsize) {
        	GlobalUnlock(hGlobal);
        	GlobalFree(hGlobal);
        	_lclose_buffer(hfGroupbyfile);
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_GROUPBY;
    	}

	/* Initialize the count for averages */
	idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
	while (idxAggregate != NO_SQLNODE) {

		/* Get the function */
		lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

		/* Average operator? */
		if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG) {

			/* Yes.  Point to the value */
			lpAggregateValue = lpResultRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
			lpAggregateValueNullFlag = lpAggregateValue +
								  lpSqlNodeAggregate->node.aggregate.Length;

			/* If not null, set count to one.  Otherwise zero */
			switch (*lpAggregateValueNullFlag) {
			case NULL_FLAG:
				lpSqlNodeAggregate->node.aggregate.Count = 0.0;
				break;
			case NOT_NULL_FLAG:
				lpSqlNodeAggregate->node.aggregate.Count = 1.0;
				break;
			default:
				GlobalUnlock(hGlobal);
                		GlobalFree(hGlobal);
                		_lclose_buffer(hfGroupbyfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_GROUPBY;
			}
		}
				
		/* Do next aggregate */
		idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
	}

	/* For each record... */
	cRowCount = 0;
	for (irow = 1; irow < lpSqlNodeSelect->node.select.RowCount; irow++) {

		/* Read current record */
		if (_lread(lpSqlNodeSelect->node.select.Sortfile, lpCurrentRecord,
                 (UINT) lpSqlNodeSelect->node.select.SortRecordsize) != 
                         (UINT) lpSqlNodeSelect->node.select.SortRecordsize) {
            		GlobalUnlock(hGlobal);
           		GlobalFree(hGlobal);
            		_lclose_buffer(hfGroupbyfile);
            		DeleteFile((LPCSTR) szFilename);
            		return ERR_GROUPBY;
        	}

		/* Does group by key match the key in the result record buffer? */
		if (_fmemcmp(lpResultRecord, lpCurrentRecord,
						 (size_t) lpSqlNodeSelect->node.select.SortKeysize)) {

			/* No.  Calculate averages */
			idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
			while (idxAggregate != NO_SQLNODE) {

				/* Get the function */
				lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

				/* Average operator? */
				if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG) {

					/* Yes.  Point to the value */
					lpAggregateValue = lpResultRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
					lpAggregateValueNullFlag = lpAggregateValue +
								  lpSqlNodeAggregate->node.aggregate.Length;

					/* If not null, calculate average */
					if (*lpAggregateValueNullFlag == NOT_NULL_FLAG)
						*((double FAR *) lpAggregateValue) /=
								(lpSqlNodeAggregate->node.aggregate.Count);
				}
				
				/* Do next aggregate */
				idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
			}

			/* Write result record buffer to the file */
			if (_lwrite_buffer(hfGroupbyfile, (LPSTR) lpResultRecord,
                 			(UINT) lpSqlNodeSelect->node.select.SortRecordsize) != 
                         		(UINT) lpSqlNodeSelect->node.select.SortRecordsize) {
                		GlobalUnlock(hGlobal);
                		GlobalFree(hGlobal);
                		_lclose_buffer(hfGroupbyfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_GROUPBY;
            		}

			/* Increase count of number of records written */
			cRowCount++;

			/* Copy current record to the result record buffer */
			_fmemcpy(lpResultRecord, lpCurrentRecord,
						 (size_t) lpSqlNodeSelect->node.select.SortRecordsize);

			/* Initialize the count for averages */
			idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
			while (idxAggregate != NO_SQLNODE) {

				/* Get the function */
				lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

				/* Average operator? */
				if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG) {

					/* Yes.  Point to the value */
					lpAggregateValue = lpResultRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
					lpAggregateValueNullFlag = lpAggregateValue +
								  lpSqlNodeAggregate->node.aggregate.Length;

					/* If not null, set count to one.  Otherwise zero */
					switch (*lpAggregateValueNullFlag) {
					case NULL_FLAG:
						lpSqlNodeAggregate->node.aggregate.Count = 0.0;
						break;
					case NOT_NULL_FLAG:
						lpSqlNodeAggregate->node.aggregate.Count = 1.0;
						break;
					default:
						GlobalUnlock(hGlobal);
                        			GlobalFree(hGlobal);
                        			_lclose_buffer(hfGroupbyfile);
                        			DeleteFile((LPCSTR) szFilename);
                        			return ERR_GROUPBY;
					}
				}
				
				/* Do next aggregate */
				idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
			}
		}
		else {

			/* Yes.  For each aggregate function... */
			idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
			while (idxAggregate != NO_SQLNODE) {

				/* Get the function */
				lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

				/* Point to the value */
				lpValue = lpCurrentRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
				lpValueNullFlag = lpValue +
								  lpSqlNodeAggregate->node.aggregate.Length;
				lpAggregateValue = lpResultRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
				lpAggregateValueNullFlag = lpAggregateValue +
								  lpSqlNodeAggregate->node.aggregate.Length;

				/* Null value? */
				if (*lpValueNullFlag == NOT_NULL_FLAG) {

					/* No.  Is aggregate value null? */
					if (*lpAggregateValueNullFlag == NOT_NULL_FLAG) {

						/* No.  Is a TYPE_NUMERIC involved? */
						if (lpSqlNodeAggregate->sqlDataType != TYPE_NUMERIC) {

							/* No.  Incorporate field value into aggregate */
							switch (lpSqlNodeAggregate->node.aggregate.Operator) {
							case AGG_AVG:
							case AGG_SUM:
								switch (lpSqlNodeAggregate->sqlDataType) {
								case TYPE_DOUBLE:
								case TYPE_INTEGER:
									*((double FAR *) lpAggregateValue) +=
											  (*((double FAR *) lpValue));
									break;
								case TYPE_NUMERIC:
								case TYPE_CHAR:
								case TYPE_DATE:
								case TYPE_TIME:
								case TYPE_TIMESTAMP:
								case TYPE_BINARY:
								default:
									GlobalUnlock(hGlobal);
                                    					GlobalFree(hGlobal);
                                    					_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
                                    					return ERR_INTERNAL;
								}

								/* Increase count */
								if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG)
                                    					lpSqlNodeAggregate->node.aggregate.Count += (1.0);

								break;
							case AGG_COUNT:
								*((double FAR *) lpAggregateValue) += (1.0);
								break;
							case AGG_MAX:
								switch (lpSqlNodeAggregate->sqlDataType) {
								case TYPE_DOUBLE:
								case TYPE_INTEGER:
									if (*((double FAR *) lpAggregateValue) <
											  *((double FAR *) lpValue))
										*((double FAR *) lpAggregateValue) =
											  *((double FAR *) lpValue);
									break;
								case TYPE_CHAR:
								case TYPE_DATE:
								case TYPE_TIME:
								case TYPE_TIMESTAMP:
									if (_fmemcmp(lpValue,
										 lpAggregateValue, (size_t)
										 lpSqlNodeAggregate->node.aggregate.Length)
													  > 0)
										_fmemcpy(lpAggregateValue,
											 lpValue, (size_t)
									   lpSqlNodeAggregate->node.aggregate.Length);
									break;
								case TYPE_NUMERIC:
								case TYPE_BINARY:
								default:
									GlobalUnlock(hGlobal);
                                    					GlobalFree(hGlobal);
                                    					_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
                                    					return ERR_INTERNAL;
								}
								break;
							case AGG_MIN:
								switch (lpSqlNodeAggregate->sqlDataType) {
								case TYPE_DOUBLE:
								case TYPE_INTEGER:
									if (*((double FAR *) lpAggregateValue) >
											  *((double FAR *) lpValue))
										*((double FAR *) lpAggregateValue) =
											  *((double FAR *) lpValue);
									break;
								case TYPE_CHAR:
								case TYPE_DATE:
								case TYPE_TIME:
								case TYPE_TIMESTAMP:
									if (_fmemcmp(lpValue,
											  lpAggregateValue, (size_t)
										 lpSqlNodeAggregate->node.aggregate.Length)
														  < 0)
										_fmemcpy(lpAggregateValue,
												 lpValue, (size_t)
									   lpSqlNodeAggregate->node.aggregate.Length);
									break;
								case TYPE_NUMERIC:
								case TYPE_BINARY:
								default:
									GlobalUnlock(hGlobal);
                                    					GlobalFree(hGlobal);
                                    					_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
                                    					return ERR_INTERNAL;
								}
								break;
							}
						}
						else {

							SQLNODE left;
							SQLNODE right;
							SQLNODE result;
							/* These buffers must be large enough to */
							/* accomodate the largest SQL_NUMERIC or */
							/* SQL_DECIMAL */
							UCHAR szBufferLeft[64];
							UCHAR szBufferRight[64];
							UWORD len;
							UCHAR szBufferResult[64];
							RETCODE err;

							/* Yes.  Incorporate field value into aggregate */
							switch (lpSqlNodeAggregate->node.aggregate.Operator) {
							case AGG_AVG:
							case AGG_COUNT:
								GlobalUnlock(hGlobal);
								GlobalFree(hGlobal);
								_lclose_buffer(hfGroupbyfile);
                                				DeleteFile((LPCSTR) szFilename);
								return ERR_INTERNAL;
							
							case AGG_MAX:

								/* Create left value */
								left = *lpSqlNodeAggregate;
								_fmemcpy(szBufferLeft, lpAggregateValue,
                                		                   (size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                					szBufferLeft[lpSqlNodeAggregate->node.
                                                   				aggregate.Length] = '\0';
                                					len = (UWORD) s_lstrlen(szBufferLeft);
                                				while ((len > 0) &&
                                       						(szBufferLeft[len-1] == ' ')) {
                                    					szBufferLeft[len-1] = '\0';
                             			       			len--;
                                				}
								left.value.String = (LPUSTR)szBufferLeft;

								/* Create right value */
								right = *lpSqlNodeAggregate;
								_fmemcpy(szBufferRight, lpValue, (size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                					szBufferRight[lpSqlNodeAggregate->node.
                                                   				aggregate.Length] = '\0';
                                				len = (UWORD) s_lstrlen(szBufferRight);
                                				while ((len > 0) &&
                                       					(szBufferRight[len-1] == ' ')) {
                                    					szBufferRight[len-1] = '\0';
                                    					len--;
                                				}
								right.value.String = (LPUSTR)szBufferRight;

								/* Compare the values */
								result.sqlNodeType = NODE_TYPE_COMPARISON;
                                				result.node.comparison.Operator = OP_LT;
                                				result.node.comparison.SelectModifier = SELECT_NOTSELECT;
                                				result.node.comparison.Left = NO_SQLNODE;
                                				result.node.comparison.Right = NO_SQLNODE;
                                				result.node.comparison.fSelectivity = 0;
                                				result.node.comparison.NextRestrict = NO_SQLNODE;
								result.sqlDataType = TYPE_INTEGER;
								result.sqlSqlType = SQL_BIT;
								result.sqlPrecision = 1;
								result.sqlScale = 0;
								err = NumericCompare(&result, &left,
													 OP_LT, &right);
								if (err != ERR_SUCCESS) {
									GlobalUnlock(hGlobal);
									GlobalFree(hGlobal);
									_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
									return err;
								}

								/* If this value is bigger, save it */
								if (result.value.Double == TRUE)
									_fmemcpy(lpAggregateValue, lpValue,
												(size_t)
									   lpSqlNodeAggregate->node.aggregate.Length);
								break;

							case AGG_MIN:

								/* Create left value */
								left = *lpSqlNodeAggregate;
								_fmemcpy(szBufferLeft, lpAggregateValue,
                                                   			(size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                				szBufferLeft[lpSqlNodeAggregate->node.
                                                   			aggregate.Length] = '\0';
                                				len = (UWORD) s_lstrlen(szBufferLeft);
                                				while ((len > 0) &&
                                       					(szBufferLeft[len-1] == ' ')) {
                                    					szBufferLeft[len-1] = '\0';
                                    					len--;
                                				}
								left.value.String = (LPUSTR)szBufferLeft;

								/* Create right value */
								right = *lpSqlNodeAggregate;
								_fmemcpy(szBufferRight, lpValue, (size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                				szBufferRight[lpSqlNodeAggregate->node.
                                                   			aggregate.Length] = '\0';
                                				len = (UWORD) s_lstrlen(szBufferRight);
                                				while ((len > 0) &&
                                       					(szBufferRight[len-1] == ' ')) {
                                    					szBufferRight[len-1] = '\0';
                                    					len--;
                                				}
								right.value.String = (LPUSTR)szBufferRight;

								/* Compare the values */
								result.sqlNodeType = NODE_TYPE_COMPARISON;
                                				result.node.comparison.Operator = OP_GT;
                                				result.node.comparison.SelectModifier = SELECT_NOTSELECT;
                                				result.node.comparison.Left = NO_SQLNODE;
                                				result.node.comparison.Right = NO_SQLNODE;
                                				result.node.comparison.fSelectivity = 0;
                                				result.node.comparison.NextRestrict = NO_SQLNODE;
								result.sqlDataType = TYPE_INTEGER;
								result.sqlSqlType = SQL_BIT;
								result.sqlPrecision = 1;
								result.sqlScale = 0;
								err = NumericCompare(&result, &left,
													 OP_GT, &right);
								if (err != ERR_SUCCESS) {
									GlobalUnlock(hGlobal);
									GlobalFree(hGlobal);
									_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
									return err;
								}

								/* If this value is smaller, save it */
								if (result.value.Double == TRUE)
									_fmemcpy(lpAggregateValue, lpValue,
												(size_t)
									   lpSqlNodeAggregate->node.aggregate.Length);
								break;

							case AGG_SUM:

								/* Create left value */
								left = *lpSqlNodeAggregate;
								_fmemcpy(szBufferLeft, lpAggregateValue,
                                                   			(size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                				szBufferLeft[lpSqlNodeAggregate->node.
                                                   			aggregate.Length] = '\0';
                                				len = (UWORD) s_lstrlen(szBufferLeft);
                                				while ((len > 0) &&
                                       					(szBufferLeft[len-1] == ' ')) {
                                    					szBufferLeft[len-1] = '\0';
                                    					len--;
                                				}
								left.value.String = (LPUSTR)szBufferLeft;

								/* Create right value */
								right = *lpSqlNodeAggregate;
								_fmemcpy(szBufferRight, lpValue, (size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                				szBufferRight[lpSqlNodeAggregate->node.
                                                   			aggregate.Length] = '\0';
                                				len = (UWORD) s_lstrlen(szBufferRight);
                                				while ((len > 0) &&
                                       					(szBufferRight[len-1] == ' ')) {
                                    					szBufferRight[len-1] = '\0';
                                    					len--;
                                				}
								right.value.String = (LPUSTR)szBufferRight;

								/* Add the left value to the right */
								result = *lpSqlNodeAggregate;
								result.value.String = (LPUSTR)szBufferResult;
								err = NumericAlgebra(&result, &left,
										   OP_PLUS, &right, NULL, NULL, NULL);
								if (err != ERR_SUCCESS) {
									GlobalUnlock(hGlobal);
									GlobalFree(hGlobal);
									_lclose_buffer(hfGroupbyfile);
                                    					DeleteFile((LPCSTR) szFilename);
									return err;
								}

								/* Save the result */
								while (s_lstrlen(szBufferResult) < (SDWORD)
                                       					lpSqlNodeAggregate->node.aggregate.Length)
                                    					s_lstrcat(szBufferResult, " ");
                                				_fmemcpy(lpAggregateValue, szBufferResult,
                                            				(size_t)
                                       					lpSqlNodeAggregate->node.aggregate.Length);
                                				break;
							}
						}
					}

					else {

						/* Yes.  Copy value from current record */
						_fmemcpy(lpAggregateValue, lpValue, (size_t)
									  lpSqlNodeAggregate->node.aggregate.Length);
						*lpAggregateValueNullFlag = NOT_NULL_FLAG;

						/* Initilize average count */
						if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG)
							lpSqlNodeAggregate->node.aggregate.Count = 1.0;
					}
				}
				
				/* Do next aggregate */
				idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
			}
		}
	}

	/* Calculate averages */
	idxAggregate = lpSqlNodeSelect->node.select.Aggregates;
	while (idxAggregate != NO_SQLNODE) {

		/* Get the function */
		lpSqlNodeAggregate = ToNode(lpstmt->lpSqlStmt, idxAggregate);

		/* Average operator? */
		if (lpSqlNodeAggregate->node.aggregate.Operator == AGG_AVG) {

			/* Yes.  Point to the value */
			lpAggregateValue = lpResultRecord +
								  lpSqlNodeAggregate->node.aggregate.Offset - 1;
			lpAggregateValueNullFlag = lpAggregateValue +
								  lpSqlNodeAggregate->node.aggregate.Length;

			/* If not null, calculate average */
			if (*lpAggregateValueNullFlag == NOT_NULL_FLAG)
				*((double FAR *) lpAggregateValue) /=
								(lpSqlNodeAggregate->node.aggregate.Count);
		}
				
		/* Do next aggregate */
		idxAggregate = lpSqlNodeAggregate->node.aggregate.Next;
	}

	/* Copy last record to the result record buffer */
	if (_lwrite_buffer(hfGroupbyfile, (LPSTR) lpResultRecord,
                 (UINT) lpSqlNodeSelect->node.select.SortRecordsize) != 
                         (UINT) lpSqlNodeSelect->node.select.SortRecordsize) {
		GlobalUnlock(hGlobal);
		GlobalFree(hGlobal);
		_lclose_buffer(hfGroupbyfile);
        	DeleteFile((LPCSTR) szFilename);
		return ERR_GROUPBY;
	}

	/* Increase count of number of records written */
	cRowCount++;

	/* Free buffers */
	GlobalUnlock(hGlobal);
	GlobalFree(hGlobal);

	/* Close the file */
	if (_lclose_buffer(hfGroupbyfile) == HFILE_ERROR) {
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_GROUPBY;
    	}

	/* Reopen the file for reading */
	hfGroupbyfile2 = _lopen((LPCSTR) szFilename, OF_READ);
    	if (hfGroupbyfile2 == HFILE_ERROR) {
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_GROUPBY;
    	}

	/* Remove the sort file */
	_lclose(lpSqlNodeSelect->node.select.Sortfile);
    	DeleteFile((LPCSTR) ToString(lpstmt->lpSqlStmt,
                                 lpSqlNodeSelect->node.select.SortfileName));


	/* Save name and handle to file of group by records */
	s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                    lpSqlNodeSelect->node.select.SortfileName), szFilename);
    	lpSqlNodeSelect->node.select.Sortfile = hfGroupbyfile2;
    	lpSqlNodeSelect->node.select.ReturningDistinct = FALSE;

	/* Save total number of records in the group by file */
	lpSqlNodeSelect->node.select.RowCount = cRowCount;

	/* Set up to read first row */
	lpSqlNodeSelect->node.select.CurrentRow = BEFORE_FIRST_ROW;

	return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC Distinct(LPSTMT   lpstmt, LPSQLNODE lpSqlNodeSelect)

/* Generates results for SELECT DISTINCT */

{
//	ODBCTRACE("\nWBEM ODBC Driver : Distinct\n");

	UCHAR szTempDir[MAX_PATHNAME_SIZE+1];
	szTempDir[0] = 0;

	UCHAR szFilename[MAX_PATHNAME_SIZE+1];
	UCHAR szFilename2[MAX_PATHNAME_SIZE+1];
	szFilename[0] = 0;
	szFilename2[0] = 0;
	HFILE_BUFFER hfSortfile;
    	HFILE hfSortfile2;
	LPSQLNODE lpSqlNodeTables;
	LPSQLNODE lpSqlNodePredicate;
	LPSQLNODE lpSqlNodeHaving;
	RETCODE err;
	SQLNODEIDX idxTableList;
	LPSQLNODE lpSqlNodeTableList;
	LPSQLNODE lpSqlNodeTable;
	ISAMBOOKMARK bookmark;
	SQLNODEIDX idxValues;
	LPSQLNODE lpSqlNodeValues;
	LPSQLNODE lpSqlNodeValue;
	SDWORD len;
	PTR ptr;
#define NUM_LEN 5
    	UCHAR szFormat[16];
	UCHAR szBuffer[20+TIMESTAMP_SCALE+1];
	UCHAR szSortDirective[64 + 3 + MAX_PATHNAME_SIZE];
	long recordCount;
	int sortStatus;
	UCHAR cNullFlag;
	BOOL fGotOne;

	szBuffer[0] = 0;

	/* Create temporary file */
#ifdef WIN32
	if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR)szTempDir))
		return ERR_SORT;
	if (!GetTempFileName((LPSTR)szTempDir, "LEM", 0, (LPSTR)szFilename))
		return ERR_SORT;
#else
	GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename);
#endif
	hfSortfile = _lcreat_buffer((LPCSTR) szFilename, 0);
    	if (hfSortfile == NULL)
        	return ERR_SORT;

	/* For each record of result set... */
	lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt,
                             lpSqlNodeSelect->node.select.Tables); 
    	if (lpSqlNodeSelect->node.select.Predicate == NO_SQLNODE)
		lpSqlNodePredicate = NULL;
	else
		lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt,
						lpSqlNodeSelect->node.select.Predicate); 
	if (lpSqlNodeSelect->node.select.Having == NO_SQLNODE)
		lpSqlNodeHaving = NULL;
	else
		lpSqlNodeHaving = ToNode(lpstmt->lpSqlStmt,
                                 lpSqlNodeSelect->node.select.Having);
    	wsprintf((LPSTR) szFormat, "%%0%dd", (UWORD) NUM_LEN);
	while (TRUE) {

		/* Is there a sort file to read from? */
		if (lpSqlNodeSelect->node.select.Sortfile == HFILE_ERROR) {

			/* No.  Get the next record */
			try
            {
                err = NextRecord(lpstmt, lpSqlNodeTables, lpSqlNodePredicate);
            }
            catch(...)
            {
				_lclose_buffer(hfSortfile);
                DeleteFile((LPCSTR) szFilename);

                return ERR_MEMALLOCFAIL;
            }

			if (err == ERR_NODATAFOUND) {
				lpSqlNodeSelect->node.select.CurrentRow = AFTER_LAST_ROW;
				break;
			}
			else if (err != ERR_SUCCESS) {
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return err;
			}

			/* Set row flag */
			if (lpSqlNodeSelect->node.select.CurrentRow == BEFORE_FIRST_ROW)
                		lpSqlNodeSelect->node.select.CurrentRow = 0;
            		else
                		lpSqlNodeSelect->node.select.CurrentRow++;
		}
		else {

			/* Yes.  Look for next record in sort file */
			while (TRUE) {

				/* Set row flag */
				if (lpSqlNodeSelect->node.select.CurrentRow == BEFORE_FIRST_ROW) {
                   		if (lpSqlNodeSelect->node.select.RowCount != 0) {
                        		lpSqlNodeSelect->node.select.CurrentRow = 0;
                    		}
                    		else {
                        		lpSqlNodeSelect->node.select.CurrentRow = AFTER_LAST_ROW;
                        		break;
                    		}
                	}
                	else if (lpSqlNodeSelect->node.select.CurrentRow ==
                                  lpSqlNodeSelect->node.select.RowCount-1) {
                    	lpSqlNodeSelect->node.select.CurrentRow = AFTER_LAST_ROW;
                    	break;
                	}
                	else
                    	lpSqlNodeSelect->node.select.CurrentRow++;

				/* If no HAVING clause, this record qualifies */
				if (lpSqlNodeHaving == NULL)
					break;

				/* If HAVING condition is satisfied, this record qualifies */
				err = EvaluateExpression(lpstmt, lpSqlNodeHaving);
				if (err != ERR_SUCCESS) {
					_lclose_buffer(hfSortfile);
                    			DeleteFile((LPCSTR) szFilename);
					return err;
				}
				if (!(lpSqlNodeHaving->sqlIsNull) &&
					(lpSqlNodeHaving->value.Double == TRUE))
					break;
			}
			if (lpSqlNodeSelect->node.select.CurrentRow == AFTER_LAST_ROW)
				break;

			/* Is there a group by? */
			if ((lpSqlNodeSelect->node.select.Groupbycolumns == NO_SQLNODE) &&
                		(!lpSqlNodeSelect->node.select.ImplicitGroupby)) {

				/* No.  Position to bookmarks in that row */
				if (_llseek(lpSqlNodeSelect->node.select.Sortfile,
                   			(lpSqlNodeSelect->node.select.CurrentRow *
                               		lpSqlNodeSelect->node.select.SortRecordsize) +
                   			lpSqlNodeSelect->node.select.SortBookmarks - 1, 0)
                                                         	== HFILE_ERROR) {
                    			_lclose_buffer(hfSortfile);
                    			DeleteFile((LPCSTR) szFilename);
                    			return ERR_SORT;
                		}

				/* For each table... */
				idxTableList = lpSqlNodeSelect->node.select.Tables;
				while (idxTableList != NO_SQLNODE) {

					/* Get the table node */
					lpSqlNodeTableList = ToNode(lpstmt->lpSqlStmt,
												idxTableList);
					lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
										lpSqlNodeTableList->node.tables.Table);

					/* Read the bookmark for it */
					if (_lread(lpSqlNodeSelect->node.select.Sortfile,
                                 		&bookmark, sizeof(ISAMBOOKMARK)) !=
                                                    sizeof(ISAMBOOKMARK)) {
                        			_lclose_buffer(hfSortfile);
                        			DeleteFile((LPCSTR) szFilename);
                        			return ERR_SORT;
                    			}

					/* Position to that record */
					if (bookmark.currentRecord == NULL_BOOKMARK)
					{
						lpSqlNodeTable->node.table.AllNull = TRUE;
					}
					else
					{
						lpSqlNodeTable->node.table.AllNull = FALSE;
						err = ISAMPosition(lpSqlNodeTable->node.table.Handle, &bookmark);
						if (err != NO_ISAM_ERR) {
							ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                            			(LPUSTR) lpstmt->szISAMError);
                        				_lclose_buffer(hfSortfile);
                        				DeleteFile((LPCSTR) szFilename);
                        				return err;
						}
						lpstmt->fISAMTxnStarted = TRUE;
					}

					/* Point at next table */
					idxTableList = lpSqlNodeTableList->node.tables.Next;
				}
			}
		}

		/* Leave if no more records */
		if (lpSqlNodeSelect->node.select.CurrentRow == AFTER_LAST_ROW)
			break;

		/* Put in the record number */
        	wsprintf((LPSTR) szBuffer, (LPSTR) szFormat,
                          (UWORD) lpSqlNodeSelect->node.select.CurrentRow);

			CString myBuffer;
			myBuffer.Format("WBEM ODBC Driver : Distinct : Record Number = %s\n", szBuffer);
			ODBCTRACE(myBuffer);

        	if (_lwrite_buffer(hfSortfile, (LPSTR) szBuffer, NUM_LEN) != NUM_LEN) {
            		_lclose_buffer(hfSortfile);
            		DeleteFile((LPCSTR) szFilename);
            		return ERR_SORT;
        	}

		/* Put the columns in the sort file in the order specified by the */
		/* select list.  For each value... */
		idxValues = lpSqlNodeSelect->node.select.Values;
		fGotOne = FALSE;
		while (idxValues != NO_SQLNODE) {

			/* Get next column */
			lpSqlNodeValues = ToNode(lpstmt->lpSqlStmt, idxValues);
			lpSqlNodeValue = ToNode(lpstmt->lpSqlStmt,
									   lpSqlNodeValues->node.values.Value);

			/* Does the value need to be put in the file? */
			switch (lpSqlNodeValue->sqlNodeType) {
			case NODE_TYPE_COLUMN:
			case NODE_TYPE_AGGREGATE:
			case NODE_TYPE_ALGEBRAIC:
			case NODE_TYPE_SCALAR:
				/* Yes.  Continue below */
				fGotOne = TRUE;
				break;

			case NODE_TYPE_STRING:
			case NODE_TYPE_NUMERIC:
			case NODE_TYPE_PARAMETER:
			case NODE_TYPE_USER:
			case NODE_TYPE_NULL:
			case NODE_TYPE_DATE:
			case NODE_TYPE_TIME:
			case NODE_TYPE_TIMESTAMP:
				/* No.  Go to next value */
				idxValues = lpSqlNodeValues->node.values.Next;
				continue;

			case NODE_TYPE_CREATE:
			case NODE_TYPE_DROP:
			case NODE_TYPE_SELECT:
			case NODE_TYPE_INSERT:
			case NODE_TYPE_DELETE:
			case NODE_TYPE_UPDATE: 
			case NODE_TYPE_CREATEINDEX:
            		case NODE_TYPE_DROPINDEX:
			case NODE_TYPE_PASSTHROUGH:
			case NODE_TYPE_TABLES:
			case NODE_TYPE_VALUES:
			case NODE_TYPE_COLUMNS:
			case NODE_TYPE_SORTCOLUMNS:
			case NODE_TYPE_GROUPBYCOLUMNS:
			case NODE_TYPE_UPDATEVALUES:
			case NODE_TYPE_CREATECOLS:
			case NODE_TYPE_BOOLEAN:
			case NODE_TYPE_COMPARISON:
			case NODE_TYPE_TABLE:
			default:
				return ERR_INTERNAL;
			}

			/* Get its value */
			err = EvaluateExpression(lpstmt, lpSqlNodeValue);
			if (err != ERR_SUCCESS) {
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return err;
			}

			/* Get length and pointer to key value */
			switch (lpSqlNodeValue->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				if (lpSqlNodeValue->sqlIsNull)
					lpSqlNodeValue->value.Double = 0.0;
				len = sizeof(double);
				ptr = &(lpSqlNodeValue->value.Double);
				break;
			case TYPE_NUMERIC:
				if (lpSqlNodeValue->sqlIsNull)
					(lpSqlNodeValue->value.String)[0] = 0;
				len = lpSqlNodeValue->sqlPrecision + 2;
				ptr = lpSqlNodeValue->value.String;

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeValue->value.String) < len)
					s_lstrcat(lpSqlNodeValue->value.String, " ");
				break;
			case TYPE_CHAR:                
				if (lpSqlNodeValue->sqlIsNull)
					(lpSqlNodeValue->value.String)[0] = 0;
				len = lpSqlNodeValue->sqlPrecision;
				ptr = lpSqlNodeValue->value.String;

				ODBCTRACE(_T("\nWBEM ODBC Driver : Distinct : String = "));

				if ((LPSTR)ptr)
				{
					ODBCTRACE((LPSTR)ptr);

					CString myString;
					myString.Format(" length = %ld\n", s_lstrlen((LPSTR)ptr));
					ODBCTRACE(myString);
				}
				else
				{
					ODBCTRACE(_T("NULL\n"));
				}

				/* (blank pad string values) */
				while (s_lstrlen(lpSqlNodeValue->value.String) < len)
					s_lstrcat(lpSqlNodeValue->value.String, " ");
				break;
			case TYPE_BINARY:                
				if (lpSqlNodeValue->sqlIsNull)
					BINARY_LENGTH(lpSqlNodeValue->value.Binary) = 0;
				len = lpSqlNodeValue->sqlPrecision;
				ptr = BINARY_DATA(lpSqlNodeValue->value.Binary);

				/* (zero pad binary values) */
				while (BINARY_LENGTH(lpSqlNodeValue->value.Binary) < len) {
					BINARY_DATA(lpSqlNodeValue->value.Binary)[
						BINARY_LENGTH(lpSqlNodeValue->value.Binary)] = 0;
					BINARY_LENGTH(lpSqlNodeValue->value.Binary) =
						BINARY_LENGTH(lpSqlNodeValue->value.Binary) + 1;
				}
				break;
			case TYPE_DATE:                
				if (lpSqlNodeValue->sqlIsNull) {
					lpSqlNodeValue->value.Date.year = 0;
					lpSqlNodeValue->value.Date.month = 0;
					lpSqlNodeValue->value.Date.day = 0;
				}
				DateToChar(&(lpSqlNodeValue->value.Date), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIME:                
				if (lpSqlNodeValue->sqlIsNull) {
					lpSqlNodeValue->value.Time.hour = 0;
					lpSqlNodeValue->value.Time.minute = 0;
					lpSqlNodeValue->value.Time.second = 0;
				}
				TimeToChar(&(lpSqlNodeValue->value.Time), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			case TYPE_TIMESTAMP:                
				if (lpSqlNodeValue->sqlIsNull) {
					lpSqlNodeValue->value.Timestamp.year = 0;
					lpSqlNodeValue->value.Timestamp.month = 0;
					lpSqlNodeValue->value.Timestamp.day = 0;
					lpSqlNodeValue->value.Timestamp.hour = 0;
					lpSqlNodeValue->value.Timestamp.minute = 0;
					lpSqlNodeValue->value.Timestamp.second = 0;
					lpSqlNodeValue->value.Timestamp.fraction = 0;
				}
				TimestampToChar(&(lpSqlNodeValue->value.Timestamp), (LPUSTR)szBuffer);
				len = s_lstrlen((char*)szBuffer);
				ptr = szBuffer;
				break;
			default:
				_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return ERR_INTERNAL;
			}

			/* Put value into the file */
			if (_lwrite_buffer(hfSortfile, (LPSTR) ptr, (UINT) len) != (UINT) len) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_SORT;
            		}

			/* Put in the null flag */
			if (lpSqlNodeValue->sqlIsNull) 
				cNullFlag = NULL_FLAG;
			else
				cNullFlag = NOT_NULL_FLAG;
			if (_lwrite_buffer(hfSortfile, (LPSTR) &cNullFlag, 1) != 1) {
                		_lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
                		return ERR_SORT;
            		}

			/* Point at next value */
			idxValues = lpSqlNodeValues->node.values.Next;
		}

		/* If no fields in sort record, put a constant in */
		if (!fGotOne) {
			if (_lwrite_buffer(hfSortfile, "LEM", 3) != 3) {
               			 _lclose_buffer(hfSortfile);
                		DeleteFile((LPCSTR) szFilename);
				return ERR_SORT;
			}
		}
	}
	if (_lclose_buffer(hfSortfile) == HFILE_ERROR) {
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_SORT;
    	}

	/* Create a destination file */
#ifdef WIN32
    if (!GetTempFileName((LPSTR) szTempDir, "LEM", 0, (LPSTR) szFilename2)) {
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    }
#else
    GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename2);
#endif
    hfSortfile2 = _lcreat((LPCSTR) szFilename2, 0);
    if (hfSortfile2 == HFILE_ERROR) {
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    }
    _lclose(hfSortfile2);

	/* Sort the file */
	s_1mains((LPSTR) szFilename, (LPSTR) szFilename2, (LPSTR)
             ToString(lpstmt->lpSqlStmt,
                      lpSqlNodeSelect->node.select.DistinctDirective),
             &recordCount, &sortStatus);
	if (sortStatus != 0) {
        	DeleteFile((LPCSTR) szFilename2);
        	DeleteFile((LPCSTR) szFilename);
        	return ERR_SORT;
    	}
    	DeleteFile((LPCSTR) szFilename);

/* Sort the file again (to put the values back into the original order) */
    if (lpSqlNodeSelect->node.select.Sortcolumns != NO_SQLNODE) {
#ifdef WIN32
        if (szTempDir[s_lstrlen(szTempDir)-1] != '\\')
            s_lstrcat(szTempDir, "\\");
#else
        GetTempFileName(NULL, "LEM", 0, (LPSTR) szTempDir);
        while (szTempDir[s_lstrlen(szTempDir)-1] != '\\')
            szTempDir[s_lstrlen(szTempDir)-1] = '\0';
#endif
        wsprintf((LPSTR) szSortDirective, "S(1,%d,N,A)F(FIX,%d)W(%s)", (WORD) NUM_LEN,
              (WORD) lpSqlNodeSelect->node.select.DistinctRecordsize,
              (LPSTR) szTempDir);
        s_1mains((LPSTR) szFilename2, (LPSTR) szFilename2,
                 (LPSTR) szSortDirective, &recordCount, &sortStatus);
        if (sortStatus != 0) {
            DeleteFile((LPCSTR) szFilename2);
            return ERR_SORT;
        }
    }
    lpSqlNodeSelect->node.select.RowCount = recordCount;

	
	/* Open destination file */
	hfSortfile2 = _lopen((LPCSTR) szFilename2, OF_READ);
    	if (hfSortfile2 == HFILE_ERROR) {
        	DeleteFile((LPCSTR) szFilename2);
        	return ERR_SORT;
    	}

	/* Save name and handle to file of sorted records */
	s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                    lpSqlNodeSelect->node.select.SortfileName), szFilename2);
    	lpSqlNodeSelect->node.select.Sortfile = hfSortfile2;
    	lpSqlNodeSelect->node.select.ReturningDistinct = TRUE;

	/* Set up to read first row */
	lpSqlNodeSelect->node.select.CurrentRow = BEFORE_FIRST_ROW;

	return ERR_SUCCESS;
}

/***************************************************************************/
RETCODE INTFUNC MSAccess(LPSTMT lpstmt, LPSQLNODE lpSqlNodeSelect,
                         SQLNODEIDX idxSelectStatement)

/* Evaluates optimized MSAccess statement */

{
//	ODBCTRACE("\nWBEM ODBC Driver : MSAccess\n");
    UCHAR szTempDir[MAX_PATHNAME_SIZE+1];
    UCHAR szFilename[MAX_PATHNAME_SIZE+1];
    UCHAR szFilename2[MAX_PATHNAME_SIZE+1];
    HFILE hfSortfile;
    LPSQLNODE lpSqlNodeTables;
    LPSQLNODE lpSqlNodeTable;
    LPSQLNODE lpSqlNodePredicate;
    LPSQLNODE lpSqlNodeKeycondition;
    SQLNODEIDX idxPredicate;
    SQLNODEIDX idxKeycondition;
    RETCODE err;
    ISAMBOOKMARK bookmark;
    long recordCount;
    int sortStatus;
#define NUM_LEN 5
    UCHAR szFormat[16];
    UCHAR szBuffer[NUM_LEN+1];
    UCHAR szSortDirective[64 + 3 + MAX_PATHNAME_SIZE];

    /* Create temporary file */
#ifdef WIN32
    if (!GetTempPath(MAX_PATHNAME_SIZE+1, (LPSTR) szTempDir))
        return ERR_SORT;
    if (!GetTempFileName((LPSTR) szTempDir, "LEM", 0, (LPSTR) szFilename))
        return ERR_SORT;
#else
    GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename);
#endif
    hfSortfile = _lcreat((LPCSTR) szFilename, 0);
    if (hfSortfile == HFILE_ERROR)
        return ERR_SORT;

    /* Get the table and predicate node. */
    lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt,
                             lpSqlNodeSelect->node.select.Tables); 
    lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt, lpSqlNodeTables->node.tables.Table);
    lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt,
                                lpSqlNodeSelect->node.select.Predicate); 

    /* For each of the key conditions...*/
    wsprintf((LPSTR) szFormat, "%%0%dd", (UWORD) NUM_LEN);
    lpSqlNodeSelect->node.select.RowCount = 0;
    while (lpSqlNodePredicate != NULL) {

        /* Get the next key condition */
        if ((lpSqlNodePredicate->sqlNodeType == NODE_TYPE_BOOLEAN) && 
            (lpSqlNodePredicate->node.boolean.Operator == OP_OR)) {
            idxKeycondition = lpSqlNodePredicate->node.boolean.Left;
            lpSqlNodeKeycondition = ToNode(lpstmt->lpSqlStmt,
                                              idxKeycondition);
            idxPredicate = lpSqlNodePredicate->node.boolean.Right;
            lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt, idxPredicate);
        }
        else {
            idxKeycondition = idxPredicate;
            lpSqlNodeKeycondition = lpSqlNodePredicate;
            idxPredicate = NO_SQLNODE;
            lpSqlNodePredicate = NULL;
        }

        /* Set the optimization predicate */
        lpSqlNodeTable->node.table.cRestrict = 0;
        lpSqlNodeTable->node.table.Restrict = NO_SQLNODE;
        err = FindRestriction(lpstmt->lpSqlStmt,
                ISAMCaseSensitive(lpstmt->lpdbc->lpISAM),
                lpSqlNodeTable, idxKeycondition, idxSelectStatement,
                &(lpSqlNodeTable->node.table.cRestrict),
                &(lpSqlNodeTable->node.table.Restrict));
        if (err != ERR_SUCCESS) {
            lpSqlNodeTable->node.table.cRestrict = 0;
            lpSqlNodeTable->node.table.Restrict = NO_SQLNODE;
            return err;
        }

        /* Rewind the table */
        err = Rewind(lpstmt, lpSqlNodeTable, FALSE);
        if (err != ERR_SUCCESS) {
            lpSqlNodeTable->node.table.cRestrict = 0;
            lpSqlNodeTable->node.table.Restrict = NO_SQLNODE;
            return err;
        }
        
        /* Clear the optimization predicate */
        lpSqlNodeTable->node.table.cRestrict = 0;
        lpSqlNodeTable->node.table.Restrict = NO_SQLNODE;

        /* Set up to read first row */
        lpSqlNodeSelect->node.select.CurrentRow = BEFORE_FIRST_ROW;

        /* For each record of result set... */
        while (TRUE) {
        
            /* Get the next record */
            err = NextRecord(lpstmt, lpSqlNodeTables,
                         lpSqlNodeKeycondition);
            if (err == ERR_NODATAFOUND) 
                break;
            else if (err != ERR_SUCCESS) {
                _lclose(hfSortfile);
                DeleteFile((LPCSTR) szFilename);
                return err;
            }

            /* Set row flag */
            if (lpSqlNodeSelect->node.select.CurrentRow == BEFORE_FIRST_ROW)
                lpSqlNodeSelect->node.select.CurrentRow = 0;
            else
                lpSqlNodeSelect->node.select.CurrentRow++;

            /* Increase row count */
            (lpSqlNodeSelect->node.select.RowCount)++;

            /* Get bookmark of current record */
			if (lpSqlNodeTable->node.table.AllNull)
			{
				bookmark.currentRecord = NULL_BOOKMARK;
			}
			else
			{
				err = ISAMGetBookmark(lpSqlNodeTable->node.table.Handle, &bookmark);
				if (err != ERR_SUCCESS) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					_lclose(hfSortfile);
					DeleteFile((LPCSTR) szFilename);
					return err;
				}
				lpstmt->fISAMTxnStarted = TRUE;
			}

            /* Put value into the file */
            wsprintf((LPSTR) szBuffer, (LPSTR) szFormat,
                             (UWORD) lpSqlNodeSelect->node.select.RowCount);
            if (_lwrite(hfSortfile, (LPSTR) szBuffer, NUM_LEN) != NUM_LEN) {
                _lclose(hfSortfile);
                DeleteFile((LPCSTR) szFilename);
                return ERR_SORT;
            }
            if (_lwrite(hfSortfile, (LPSTR) &bookmark, sizeof(ISAMBOOKMARK))
                                    != sizeof(ISAMBOOKMARK)) {
                _lclose(hfSortfile);
                DeleteFile((LPCSTR) szFilename);
                return ERR_SORT;
            }
        }
    }
    if (lpSqlNodeSelect->node.select.RowCount == 0) {
        _lclose(hfSortfile);
        DeleteFile((LPCSTR) szFilename);
        lpSqlNodeSelect->node.select.CurrentRow = AFTER_LAST_ROW;
        return ERR_SUCCESS;
    }
    _lclose(hfSortfile);

    /* Create a destination file */
#ifdef WIN32
    if (!GetTempFileName((LPSTR) szTempDir, "LEM", 0, (LPSTR) szFilename2)) {
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    }
#else
    GetTempFileName(NULL, "LEM", 0, (LPSTR) szFilename2);
#endif
    hfSortfile = _lcreat((LPCSTR) szFilename2, 0);
    if (hfSortfile == HFILE_ERROR) {
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    }
    _lclose(hfSortfile);

    
    /* Get name of workspace directory */
#ifdef WIN32
    if (szTempDir[s_lstrlen(szTempDir)-1] != '\\')
        s_lstrcat(szTempDir, "\\");
#else
    GetTempFileName(NULL, "LEM", 0, (LPSTR) szTempDir);
    while (szTempDir[s_lstrlen(szTempDir)-1] != '\\')
        szTempDir[s_lstrlen(szTempDir)-1] = '\0';
#endif

    /* Sort the file and remove duplicate bookmarks */
    wsprintf((LPSTR) szSortDirective, "S(%d,%d,W,A)DUPO(B%d,%d,%d)F(FIX,%d)W(%s)",
              (WORD) NUM_LEN+1, (WORD) sizeof(ISAMBOOKMARK),
              (WORD) (sizeof(ISAMBOOKMARK) + NUM_LEN), (WORD) NUM_LEN+1,
              (WORD) sizeof(ISAMBOOKMARK),
              (WORD) (sizeof(ISAMBOOKMARK) + NUM_LEN),
              (LPSTR) szTempDir);
    s_1mains((LPSTR) szFilename, (LPSTR) szFilename2,
             (LPSTR) szSortDirective, &recordCount, &sortStatus);
    if (sortStatus != 0) {
        DeleteFile((LPCSTR) szFilename2);
        DeleteFile((LPCSTR) szFilename);
        return ERR_SORT;
    }
    DeleteFile((LPCSTR) szFilename);

    /* Sort the file again (to put the values back into the original order) */
    wsprintf((LPSTR) szSortDirective, "S(1,%d,N,A)F(FIX,%d)W(%s)", (WORD) NUM_LEN,
              (WORD) (sizeof(ISAMBOOKMARK) + NUM_LEN),
              (LPSTR) szTempDir);
    s_1mains((LPSTR) szFilename2, (LPSTR) szFilename2,
             (LPSTR) szSortDirective, &recordCount, &sortStatus);
    if (sortStatus != 0) {
        DeleteFile((LPCSTR) szFilename2);
        return ERR_SORT;
    }
    lpSqlNodeSelect->node.select.RowCount = recordCount;

    /* Open destination file */
    hfSortfile = _lopen((LPCSTR) szFilename2, OF_READ);
    if (hfSortfile == HFILE_ERROR) {
        DeleteFile((LPCSTR) szFilename2);
        return ERR_SORT;
    }

    /* Save name and handle to file of records found */
    s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                    lpSqlNodeSelect->node.select.SortfileName), szFilename2);
    lpSqlNodeSelect->node.select.Sortfile = hfSortfile;

    /* Set up to read first row */
    lpSqlNodeSelect->node.select.CurrentRow = BEFORE_FIRST_ROW;

    return ERR_SUCCESS;
}
/***************************************************************************/

RETCODE INTFUNC ExecuteQuery(LPSTMT   lpstmt, LPSQLNODE lpSqlNode)

/* Executes the current query */

{
	LPUSTR       lpstrTablename;
	LPUSTR       lpstrColumnname;
	LPISAMTABLEDEF lpISAMTableDef;
	SWORD       err;
	SWORD       finalErr;
	SQLNODEIDX  idxTables;
	SQLNODEIDX  idxSqlNodeColumns;
	SQLNODEIDX  idxSqlNodeValues;
	SQLNODEIDX  idxSqlNodeSets;
	SQLNODEIDX  idxSortcolumns;
	SQLNODEIDX  idxParameter;
	LPSQLNODE   lpSqlNodeTables;
	LPSQLNODE   lpSqlNodeTable;
	LPSQLNODE   lpSqlNodeColumns;
	LPSQLNODE   lpSqlNodeColumn;
	LPSQLNODE   lpSqlNodeValues;
	LPSQLNODE   lpSqlNodeValue; 
	LPSQLNODE   lpSqlNodePredicate;
	LPSQLNODE   lpSqlNodeSets; 
	LPSQLNODE   lpSqlNodeSortcolumns;
	LPSQLNODE   lpSqlNodeParameter;
	LPSQLNODE   lpSqlNodeSelect; 
	UWORD       idx;
	BOOL        fSelect;
    	BOOL        fSubSelect;

//	ODBCTRACE ("\nWBEM ODBC Driver : ExecuteQuery\n");

    	/* Nested sub-select? */
    	if (lpSqlNode == NULL) {

        /* No.  Count of rows is not available */
        fSubSelect = FALSE;
	lpstmt->cRowCount = -1;

	/* If there are passthrough parameters, send them now */
	lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
	if (lpSqlNode->node.root.passthroughParams) {
		idxParameter = lpSqlNode->node.root.parameters;
		while (idxParameter != NO_SQLNODE) {
			lpSqlNodeParameter = ToNode(lpstmt->lpSqlStmt, idxParameter);
			switch (lpSqlNodeParameter->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_DOUBLE,
							  &(lpSqlNodeParameter->value.Double),
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
									sizeof(double));
				break;
			case TYPE_NUMERIC:
			case TYPE_CHAR:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_CHAR, lpSqlNodeParameter->value.String,
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
								 s_lstrlen(lpSqlNodeParameter->value.String));
				break;
			case TYPE_BINARY:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_BINARY,
							  BINARY_DATA(lpSqlNodeParameter->value.Binary),
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
							 BINARY_LENGTH(lpSqlNodeParameter->value.Binary));
				break;
			case TYPE_DATE:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_DATE, &(lpSqlNodeParameter->value.Date),
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
								  sizeof(DATE_STRUCT));
				break;
			case TYPE_TIME:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_TIME, &(lpSqlNodeParameter->value.Time),
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
								  sizeof(TIME_STRUCT));
				break;
			case TYPE_TIMESTAMP:
				err = ISAMParameter(lpstmt->lpISAMStatement,
							  lpSqlNodeParameter->node.parameter.Id,
							  SQL_C_TIMESTAMP,
							  &(lpSqlNodeParameter->value.Timestamp),
							  lpSqlNodeParameter->sqlIsNull ? SQL_NULL_DATA :
								  sizeof(TIMESTAMP_STRUCT));
				break;
			default:
				return ERR_NOTSUPPORTED;
			}
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				return err;
			}
			lpstmt->fISAMTxnStarted = TRUE;
                	idxParameter = lpSqlNodeParameter->node.parameter.Next;
		}
	}

	/* Get the root node of the operation */
	lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
	lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.root.sql);
    }
    else {

        /* Yes.  It is a sub-select */
        fSubSelect = TRUE;
    }

    finalErr = ERR_SUCCESS;
    fSelect = FALSE;

	switch (lpSqlNode->sqlNodeType) {

	/* Create a table */
	case NODE_TYPE_CREATE:

		/* Make sure this DDL statement is allowed now */
        	err = TxnCapableForDDL(lpstmt);
        	if (err == ERR_DDLIGNORED) 
            		return ERR_DDLIGNORED;
        	else if (err == ERR_DDLCAUSEDACOMMIT)
            		finalErr = ERR_DDLCAUSEDACOMMIT;
        	else if (err != ERR_SUCCESS)
            		return err;

		/* Find the table to create */
		lpstrTablename = ToString(lpstmt->lpSqlStmt, lpSqlNode->node.create.Table);

		/* Create the table */
		err = ISAMCreateTable(lpstmt->lpdbc->lpISAM,
										 (LPUSTR) lpstrTablename, &lpISAMTableDef);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}
		if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            		lpstmt->fISAMTxnStarted = TRUE;

		/* Add the columns to the table */
		lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.create.Columns);
		while (TRUE) {

			/* Error if wrong node type */
			if (lpSqlNode->sqlNodeType != NODE_TYPE_CREATECOLS) {
				ISAMCloseTable(lpISAMTableDef);
				if (NO_ISAM_ERR ==
                     			ISAMDeleteTable(lpstmt->lpdbc->lpISAM, (LPUSTR) lpstrTablename)) {
                    			if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                        			lpstmt->fISAMTxnStarted = TRUE;
                		}
				return ERR_INTERNAL;
			}

			/* Get column name */
			lpstrColumnname = ToString(lpstmt->lpSqlStmt,
							lpSqlNode->node.createcols.Name);

			/* Add the column to the table */
			err = ISAMAddColumn(lpISAMTableDef, (LPUSTR) lpstrColumnname,
				   lpSqlNode->node.createcols.iSqlType,
				   lpSqlNode->node.createcols.Param1, lpSqlNode->node.createcols.Param2);
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				ISAMCloseTable(lpISAMTableDef);
				if (NO_ISAM_ERR ==
                     			ISAMDeleteTable(lpstmt->lpdbc->lpISAM, (LPUSTR) lpstrTablename)) {
                    		if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                        		lpstmt->fISAMTxnStarted = TRUE;
                		}
				return err;
			}
			if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                		lpstmt->fISAMTxnStarted = TRUE;

			/* Find next column */
			if (lpSqlNode->node.createcols.Next == NO_SQLNODE)
				break;
			lpSqlNode = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.createcols.Next);
		}

		/* Close the table */
		err = ISAMCloseTable(lpISAMTableDef);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			if (NO_ISAM_ERR ==
                 		ISAMDeleteTable(lpstmt->lpdbc->lpISAM, (LPUSTR) lpstrTablename)) {
                	if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                    		lpstmt->fISAMTxnStarted = TRUE;
            		}
			return err;
		}
		
		break;

	/* Drop a table */
	case NODE_TYPE_DROP:

		/* Make sure this DDL statement is allowed now */
        	err = TxnCapableForDDL(lpstmt);
        	if (err == ERR_DDLIGNORED) 
            		return ERR_DDLIGNORED;
        	else if (err == ERR_DDLCAUSEDACOMMIT)
            		finalErr = ERR_DDLCAUSEDACOMMIT;
        	else if (err != ERR_SUCCESS)
            		return err;

		/* Find the table to drop */
		lpstrTablename = ToString(lpstmt->lpSqlStmt, lpSqlNode->node.drop.Table);

		/* Drop the table */
		err = ISAMDeleteTable(lpstmt->lpdbc->lpISAM, (LPUSTR) lpstrTablename);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}
		if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            		lpstmt->fISAMTxnStarted = TRUE;

		break;

	/* SELECT statement */
	case NODE_TYPE_SELECT:

		/* Is there a passthrough SQL statement? */
		lpstmt->fDMLTxn = TRUE;
        	fSelect = TRUE;
        	if (!fSubSelect) {

		if (lpstmt->lpISAMStatement != NULL) {

			/* Yes.  Execute it now */
			err = ISAMExecute(lpstmt->lpISAMStatement,
                                 &(lpSqlNode->node.select.RowCount));
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				return err;
			}
                	lpstmt->fISAMTxnStarted = TRUE;
            	}
            	else {
                	lpSqlNode->node.select.RowCount = -1;

			}
		}
		
		/* Is there a pushdown sort? */
		if ((lpSqlNode->node.select.Sortcolumns != NO_SQLNODE) &&
			lpSqlNode->node.select.fPushdownSort) {

			UWORD          icol[MAX_COLUMNS_IN_ORDER_BY];
			BOOL           fDescending[MAX_COLUMNS_IN_ORDER_BY];

			/* Yes.  For each table... */
			idxTables = lpSqlNode->node.select.Tables;
			while (idxTables != NO_SQLNODE) {

				/* If no pushdown sort for this table, leave the loop */
				/* (since there will be no pushdowns for any of the */
				/* subsequent tables either) */
				lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt, idxTables);
				lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
											  lpSqlNodeTables->node.tables.Table);
				if (lpSqlNodeTable->node.table.Sortcount == 0)
					break;

				/* Create sort info arrays.  For each column in sequence... */
				idxSortcolumns = lpSqlNodeTable->node.table.Sortcolumns;
				for (idx = 0; idx < lpSqlNodeTable->node.table.Sortcount; idx++) {

					/* Get the column description */
					lpSqlNodeSortcolumns = ToNode(lpstmt->lpSqlStmt,
												  idxSortcolumns);
					lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt,
								   lpSqlNodeSortcolumns->node.sortcolumns.Column);

					/* Put information into the array */
					icol[idx] = lpSqlNodeColumn->node.column.Id;
					fDescending[idx] =
								lpSqlNodeSortcolumns->node.sortcolumns.Descending;

					/* Look at next column */
					idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
				}

				/* Get the records in sorted order */
				err = ISAMSort(lpSqlNodeTable->node.table.Handle,
							   lpSqlNodeTable->node.table.Sortcount,
							   icol, fDescending);

				/* Can this sort be pushed down? */
				if (err == ISAM_NOTSUPPORTED) {

					/* No.  Turn off all the sorts */
					idxTables = lpSqlNode->node.select.Tables;
					while (idxTables != NO_SQLNODE) {
						lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt, idxTables);
						lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
											  lpSqlNodeTables->node.tables.Table);
						if (lpSqlNodeTable->node.table.Sortcount == 0)
							break;
						err = ISAMSort(lpSqlNodeTable->node.table.Handle, 0,
									   icol, fDescending);
						if ((err != NO_ISAM_ERR) &&
                                                		(err != ISAM_NOTSUPPORTED)) {
						   ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
											   (LPUSTR)lpstmt->szISAMError);
							return err;
						}
						if (err == NO_ISAM_ERR)
                            				lpstmt->fISAMTxnStarted = TRUE;
                        			idxTables = lpSqlNodeTables->node.tables.Next;
					}

					/* Don't try to do pushdown sort again */
					lpSqlNode->node.select.fPushdownSort = FALSE;

					/* Leave this loop */
					break;
				}
				else if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				else
                    			lpstmt->fISAMTxnStarted = TRUE;

				/* Look at next table */
				idxTables = lpSqlNodeTables->node.tables.Next;
			}
		}

		/* Rewind the tables */
		lpSqlNodeTables = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.select.Tables);
 		err = Rewind(lpstmt, lpSqlNodeTables, FALSE); 
		if (err == ERR_NODATAFOUND) {
			if (!fSubSelect) {

			lpstmt->fStmtType = STMT_TYPE_SELECT;
			lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
			lpstmt->cRowCount = 0;
			}
			lpSqlNode->node.select.RowCount = 0;
           		lpSqlNode->node.select.CurrentRow = AFTER_LAST_ROW;

			if (!fSubSelect) {
				lpstmt->icol = NO_COLUMN;
				lpstmt->cbOffset = 0;
			}
			break;
		}
		else if (err != ERR_SUCCESS)
			return err;
		
		/* Show a SELECT statement as the active statement */
		if (!fSubSelect) {
			lpstmt->fStmtType = STMT_TYPE_SELECT;
			lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;
		}

		/* So far no data read */
		lpSqlNode->node.select.CurrentRow = BEFORE_FIRST_ROW;

		/* So far no column read */
		if (!fSubSelect) {
			lpstmt->icol = NO_COLUMN;
			lpstmt->cbOffset = 0;
		}

		/* Is a sort needed? */
		if (((lpSqlNode->node.select.Sortcolumns != NO_SQLNODE) ||
			 (lpSqlNode->node.select.ImplicitGroupby)) &&
			(!lpSqlNode->node.select.fPushdownSort)) {

			/* Yes.  Do it */
			err = Sort(lpstmt, lpSqlNode);
			if (err != ERR_SUCCESS)
				return err;
		}

		/* Is group by needed? */
		if ((lpSqlNode->node.select.Groupbycolumns != NO_SQLNODE) || 
			(lpSqlNode->node.select.ImplicitGroupby)) {

			/* Yes.  Do it */
			err = GroupBy(lpstmt, lpSqlNode);
			if (err != ERR_SUCCESS) {
				if (lpSqlNode->node.select.Sortfile != HFILE_ERROR) {
                    			_lclose(lpSqlNode->node.select.Sortfile);
                    			lpSqlNode->node.select.Sortfile = HFILE_ERROR;
                    			lpSqlNode->node.select.ReturningDistinct = FALSE;
                    				DeleteFile((LPCSTR) ToString(lpstmt->lpSqlStmt,
                                  	lpSqlNode->node.select.SortfileName));
                    			s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                                  	lpSqlNode->node.select.SortfileName), "");
                		}
				return err;
			}
		}

		/* Is DISTINCT specified? */
		if (lpSqlNode->node.select.Distinct) {

			/* Yes.  Do it */
			err = Distinct(lpstmt, lpSqlNode);
			if (err != ERR_SUCCESS) {
				if (lpSqlNode->node.select.Sortfile != HFILE_ERROR) {
                    			_lclose(lpSqlNode->node.select.Sortfile);
                    			lpSqlNode->node.select.Sortfile = HFILE_ERROR;
                    			lpSqlNode->node.select.ReturningDistinct = FALSE;
                    				DeleteFile((LPCSTR) ToString(lpstmt->lpSqlStmt,
                                  	lpSqlNode->node.select.SortfileName));
                    			s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                                  	lpSqlNode->node.select.SortfileName), "");
                		}
				return err;
			}
		}

        /* MSAccess optimization needed? */
        if (lpSqlNode->node.select.fMSAccess) {

            /* Yes.  Do it */
            err = MSAccess(lpstmt, lpSqlNode,
                    ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE)->node.root.sql);
            if (err != ERR_SUCCESS) {
                if (lpSqlNode->node.select.Sortfile != HFILE_ERROR) {
                    _lclose(lpSqlNode->node.select.Sortfile);
                    lpSqlNode->node.select.Sortfile = HFILE_ERROR;
                    lpSqlNode->node.select.ReturningDistinct = FALSE;
                    DeleteFile((LPCSTR) ToString(lpstmt->lpSqlStmt,
                                  lpSqlNode->node.select.SortfileName));
                    s_lstrcpy(ToString(lpstmt->lpSqlStmt,
                                  lpSqlNode->node.select.SortfileName), "");
                }
                return err;
            }
        }

        /* Return the row count */
        if (!fSubSelect) {
            lpstmt->cRowCount = lpSqlNode->node.select.RowCount;
		}
		break;

	/* INSERT statement */
	case NODE_TYPE_INSERT:
	{
	/* Sub-select? */
        lpSqlNodeSelect = ToNode(lpstmt->lpSqlStmt,
                                 lpSqlNode->node.insert.Values);
        if (lpSqlNodeSelect->sqlNodeType == NODE_TYPE_SELECT) {
            err = ExecuteQuery(lpstmt, lpSqlNodeSelect);
            if (err == ERR_DATATRUNCATED) {
                finalErr = ERR_DATATRUNCATED;
                err = ERR_SUCCESS;
            }
            if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                return err;
        }
        else
            lpSqlNodeSelect = NULL;

        /* Insert rows into the table */
        lpstmt->cRowCount = 0;
        while (TRUE) {

            /* Get next row to insert */
            if (lpSqlNodeSelect != NULL) {
                if (err == ERR_SUCCESS) {
//					ODBCTRACE("\nWBEM ODBC Driver : Get next row to insert\n");
                    err = FetchRow(lpstmt, lpSqlNodeSelect);
                    if ((err != ERR_SUCCESS) && (err != ERR_NODATAFOUND))
                        return err;
                }

                /* Leave if no more rows */
                if (err == ERR_NODATAFOUND)
                    break;

                /* Get list of values */
                idxSqlNodeValues = lpSqlNodeSelect->node.select.Values;
            }
            else {
                idxSqlNodeValues = lpSqlNode->node.insert.Values;
            }

		/* Add a row to the table. */
		lpstmt->fDMLTxn = TRUE;
            	lpSqlNodeTable =
                     ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.insert.Table); 
            	lpISAMTableDef = lpSqlNodeTable->node.table.Handle;
		
		err = ISAMInsertRecord(lpISAMTableDef);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}
		lpstmt->fISAMTxnStarted = TRUE;
		
		/* Evaluate each column value and copy it into the new record. */
		idxSqlNodeColumns = lpSqlNode->node.insert.Columns;
		while (idxSqlNodeColumns != NO_SQLNODE) {
			lpSqlNodeColumns = ToNode(lpstmt->lpSqlStmt, idxSqlNodeColumns);
			lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt, lpSqlNodeColumns->node.columns.Column);
			lpSqlNodeValues = ToNode(lpstmt->lpSqlStmt, idxSqlNodeValues);
			lpSqlNodeValue = ToNode(lpstmt->lpSqlStmt, lpSqlNodeValues->node.values.Value);

			err = EvaluateExpression(lpstmt, lpSqlNodeValue);
			if (err != ERR_SUCCESS) {
				if (ERR_SUCCESS == ISAMDeleteRecord(lpISAMTableDef))
                        lpstmt->fISAMTxnStarted = TRUE;
				return err;
			}
			switch (lpSqlNodeColumn->sqlDataType) {
			case TYPE_DOUBLE:
			case TYPE_INTEGER:
			{
				switch (lpSqlNodeValue->sqlDataType) {
				case TYPE_DOUBLE:
				case TYPE_INTEGER:
					lpSqlNodeColumn->value.Double =
											lpSqlNodeValue->value.Double;
					break;
				case TYPE_NUMERIC:
					if (!(lpSqlNodeValue->sqlIsNull))
						CharToDouble(lpSqlNodeValue->value.String,
							   s_lstrlen(lpSqlNodeValue->value.String), FALSE, 
							   -1.7E308, 1.7E308,
							   &(lpSqlNodeColumn->value.Double));
					else
						lpSqlNodeColumn->value.Double = 0.0;
					break;
				case TYPE_CHAR:
				case TYPE_BINARY:
				case TYPE_DATE:
				case TYPE_TIME:
				case TYPE_TIMESTAMP:
				default:
					return ERR_INTERNAL;
				}
				err = ISAMPutData(lpISAMTableDef,
						   lpSqlNodeColumn->node.column.Id, SQL_C_DOUBLE,
						   &(lpSqlNodeColumn->value.Double),
						   lpSqlNodeValue->sqlIsNull ?
								   (SDWORD) SQL_NULL_DATA : sizeof(double));
				if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
			}
				break;
			case TYPE_NUMERIC:
			{
				lpSqlNodeColumn->value.String = ToString(lpstmt->lpSqlStmt,
										  lpSqlNodeColumn->node.column.Value);
				switch (lpSqlNodeValue->sqlDataType) {
				case TYPE_DOUBLE:
				case TYPE_INTEGER:
					if (!(lpSqlNodeValue->sqlIsNull)) {
                            			if (DoubleToChar(lpSqlNodeValue->value.Double,
                                  			FALSE, lpSqlNodeColumn->value.String,
                                  			1 + 2 + lpSqlNodeColumn->sqlPrecision)) {
                                			lpSqlNodeColumn->value.String[1 + 2 +
                                    			lpSqlNodeColumn->sqlPrecision - 1] = '\0';
                                			finalErr = ERR_DATATRUNCATED;
                            			}
                        		}		
                        		else
                            			s_lstrcpy(lpSqlNodeColumn->value.String, "0");
					break;
				case TYPE_NUMERIC:
					s_lstrcpy(lpSqlNodeColumn->value.String,
							lpSqlNodeValue->value.String);
					break;
				case TYPE_CHAR:
				case TYPE_BINARY:
				case TYPE_DATE:
				case TYPE_TIME:
				case TYPE_TIMESTAMP:
				default:
					return ERR_INTERNAL;
				}
				err = BCDNormalize(lpSqlNodeColumn->value.String,
								s_lstrlen(lpSqlNodeColumn->value.String),
								lpSqlNodeColumn->value.String,
								1 + 2 + lpSqlNodeColumn->sqlPrecision,
								lpSqlNodeColumn->sqlPrecision,
								lpSqlNodeColumn->sqlScale);
				if (err == ERR_DATATRUNCATED) {
                        		finalErr = ERR_DATATRUNCATED;
                        		err = ERR_SUCCESS;
                    		}

				if (err == ERR_SUCCESS) {

				err = ISAMPutData(lpISAMTableDef,
							   lpSqlNodeColumn->node.column.Id, SQL_C_CHAR,
							   lpSqlNodeColumn->value.String,
							   lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
									s_lstrlen(lpSqlNodeColumn->value.String));
				if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                            		lpstmt->fISAMTxnStarted = TRUE;
                    	}
			}
				break;
			case TYPE_CHAR:                
				err = ISAMPutData(lpISAMTableDef,
                               		lpSqlNodeColumn->node.column.Id, 
                               		SQL_C_CHAR, lpSqlNodeValue->value.String, 
                               		lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                    	s_lstrlen(lpSqlNodeValue->value.String));
                    		if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
				break;
			case TYPE_BINARY:                
				err = ISAMPutData(lpISAMTableDef, lpSqlNodeColumn->node.column.Id, 
                                	SQL_C_BINARY, BINARY_DATA(lpSqlNodeValue->value.Binary),
                                   	lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                      	BINARY_LENGTH(lpSqlNodeValue->value.Binary));
                    		if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
				break;
			case TYPE_DATE:                
				err = ISAMPutData(lpISAMTableDef, lpSqlNodeColumn->node.column.Id, 
                               		SQL_C_DATE, &(lpSqlNodeValue->value.Date), 
                               		lpSqlNodeValue->sqlIsNull ?
                              		(SDWORD) SQL_NULL_DATA : sizeof(DATE_STRUCT));
                    		if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
				break;
			case TYPE_TIME:                
				err = ISAMPutData(lpISAMTableDef, lpSqlNodeColumn->node.column.Id, 
                               		SQL_C_TIME, &(lpSqlNodeValue->value.Time), 
                               		lpSqlNodeValue->sqlIsNull ?
                              		(SDWORD) SQL_NULL_DATA : sizeof(TIME_STRUCT));
                    		if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
				break;
			case TYPE_TIMESTAMP:                
				err = ISAMPutData(lpISAMTableDef, lpSqlNodeColumn->node.column.Id, 
                               		SQL_C_TIMESTAMP, &(lpSqlNodeValue->value.Timestamp), 
                               		lpSqlNodeValue->sqlIsNull ?
                              		(SDWORD) SQL_NULL_DATA : sizeof(TIMESTAMP_STRUCT));
                    		if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        		lpstmt->fISAMTxnStarted = TRUE;
				break;
			default:
				err = ERR_INTERNAL;
			}
			if (err == ISAM_TRUNCATION) {
                    		finalErr = ERR_DATATRUNCATED;
                    		err = NO_ISAM_ERR;
                	}
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				if (ERR_SUCCESS == ISAMDeleteRecord(lpISAMTableDef))
                        		lpstmt->fISAMTxnStarted = TRUE;
				return err;
			}
			
			idxSqlNodeColumns = lpSqlNodeColumns->node.columns.Next;
			idxSqlNodeValues = lpSqlNodeValues->node.values.Next;
		}
		
		/* Write the updated row to the table. */
		err = ISAMUpdateRecord(lpISAMTableDef);
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			if (ERR_SUCCESS == ISAMDeleteRecord(lpISAMTableDef))
                    		lpstmt->fISAMTxnStarted = TRUE;
			return err;
		}
		lpstmt->fISAMTxnStarted = TRUE;

		/* Increment row count */
            	lpstmt->cRowCount++;

            	/* Leave if just inserting a single row */
            	if (lpSqlNodeSelect == NULL)
                	break;
		}
	}
		break;

	/* DELETE statement */
	case NODE_TYPE_DELETE:
	{	
		/* Get the table handle and predicate node. */
		lpstmt->fDMLTxn = TRUE;
        	lpSqlNodeTable = ToNode (lpstmt->lpSqlStmt, lpSqlNode->node.delet.Table); 
        	lpISAMTableDef = lpSqlNodeTable->node.table.Handle;
        	if (lpSqlNode->node.delet.Predicate == NO_SQLNODE)
			lpSqlNodePredicate = NULL;
		else
			lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt,
                                        lpSqlNode->node.delet.Predicate); 
		
		/* Rewind the table */
		err = Rewind(lpstmt, lpSqlNodeTable, FALSE);
		if (err != ERR_SUCCESS)
			return err;

		/* Delete each record that satisfies the WHERE clause. */
		lpstmt->cRowCount = 0;
		while (TRUE) {

			/* Get next record */
			err = NextRecord(lpstmt, lpSqlNodeTable,
							 lpSqlNodePredicate);
			if (err == ERR_NODATAFOUND)
				break;
			else if (err != ERR_SUCCESS)
				return err;

			/* Delete record */
			err = ISAMDeleteRecord(lpISAMTableDef);
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				return err;
			}
			lpstmt->fISAMTxnStarted = TRUE;

			/* Increase count */
			(lpstmt->cRowCount)++;
		}
		
	}
		break;

	/* UPDATE statement */
	case NODE_TYPE_UPDATE: 
	{	
		/* Get the table handle, predicate node. */
		lpstmt->fDMLTxn = TRUE;
        	lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt, lpSqlNode->node.update.Table); 
        	lpISAMTableDef = lpSqlNodeTable->node.table.Handle;
        	if (lpSqlNode->node.update.Predicate == NO_SQLNODE)
			lpSqlNodePredicate = NULL;
		else
			lpSqlNodePredicate = ToNode(lpstmt->lpSqlStmt,
                                        lpSqlNode->node.update.Predicate); 

		/* Rewind the table */
		err = Rewind(lpstmt, lpSqlNodeTable, FALSE);
		if (err != ERR_SUCCESS)
			return err;

		/* Update each record that satisfies the WHERE clause. */
		lpstmt->cRowCount = 0;
		while (TRUE) {

			/* Get next record */
			err = NextRecord(lpstmt, lpSqlNodeTable,
							 lpSqlNodePredicate);
			if (err == ERR_NODATAFOUND)
				break;
			else if (err != ERR_SUCCESS)
				return err;
		
			/* For each set column... */
			idxSqlNodeSets = lpSqlNode->node.update.Updatevalues;
			while (idxSqlNodeSets != NO_SQLNODE) {

				/* Get the column */
				lpSqlNodeSets = ToNode(lpstmt->lpSqlStmt, idxSqlNodeSets);
				lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt, lpSqlNodeSets->node.updatevalues.Column);
	
				/* Get the value to set the column to */
				lpSqlNodeValue = ToNode(lpstmt->lpSqlStmt, lpSqlNodeSets->node.updatevalues.Value);
				err = EvaluateExpression(lpstmt, lpSqlNodeValue);
				if (err != ERR_SUCCESS)
					return err;

				/* Put the data into the record */
				switch (lpSqlNodeColumn->sqlDataType) {
				case TYPE_DOUBLE:
				case TYPE_INTEGER:
					switch (lpSqlNodeValue->sqlDataType) {
					case TYPE_DOUBLE:
					case TYPE_INTEGER:
						lpSqlNodeColumn->value.Double =
											lpSqlNodeValue->value.Double;
						break;
					case TYPE_NUMERIC:
						if (!(lpSqlNodeValue->sqlIsNull))
							CharToDouble(lpSqlNodeValue->value.String,
							   s_lstrlen(lpSqlNodeValue->value.String), FALSE, 
							   -1.7E308, 1.7E308,
							   &(lpSqlNodeColumn->value.Double));
						else
							lpSqlNodeColumn->value.Double = 0.0;
						break;
					case TYPE_CHAR:
					case TYPE_BINARY:
					case TYPE_DATE:
					case TYPE_TIME:
					case TYPE_TIMESTAMP:
					default:
						return ERR_INTERNAL;
					}
					err = ISAMPutData(lpISAMTableDef,
						   lpSqlNodeColumn->node.column.Id, SQL_C_DOUBLE,
						   &(lpSqlNodeColumn->value.Double),
						   lpSqlNodeValue->sqlIsNull ?
								   (SDWORD) SQL_NULL_DATA : sizeof(double));
					if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				case TYPE_NUMERIC:
					lpSqlNodeColumn->value.String =ToString(lpstmt->lpSqlStmt,
										  lpSqlNodeColumn->node.column.Value);
					switch (lpSqlNodeValue->sqlDataType) {
					case TYPE_DOUBLE:
					case TYPE_INTEGER:
						if (!(lpSqlNodeValue->sqlIsNull)) {
                            				if (DoubleToChar(lpSqlNodeValue->value.Double,
                                    				FALSE, lpSqlNodeColumn->value.String,
                                    				1 + 2 + lpSqlNodeColumn->sqlPrecision)) {
                                				lpSqlNodeColumn->value.String[
                                    				1+2+lpSqlNodeColumn->sqlPrecision-1]='\0';
                                				finalErr = ERR_DATATRUNCATED;
                            				}
                        			}
                        			else
                            				s_lstrcpy(lpSqlNodeColumn->value.String, "0");
						break;
					case TYPE_NUMERIC:
						s_lstrcpy(lpSqlNodeColumn->value.String,
								lpSqlNodeValue->value.String);
						break;
					case TYPE_CHAR:
					case TYPE_BINARY:
					case TYPE_DATE:
					case TYPE_TIME:
					case TYPE_TIMESTAMP:
					default:
						return ERR_INTERNAL;
					}
					err = BCDNormalize(lpSqlNodeColumn->value.String,
								s_lstrlen(lpSqlNodeColumn->value.String),
								lpSqlNodeColumn->value.String,
								1 + 2 + lpSqlNodeColumn->sqlPrecision,
								lpSqlNodeColumn->sqlPrecision,
								lpSqlNodeColumn->sqlScale);
					if (err == ERR_DATATRUNCATED) {
                        			finalErr = ERR_DATATRUNCATED;
                        			err = ERR_SUCCESS;
                    			}

					if (err == ERR_SUCCESS) {

					err = ISAMPutData(lpISAMTableDef,
							   lpSqlNodeColumn->node.column.Id, SQL_C_CHAR,
							   lpSqlNodeColumn->value.String,
							   lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
									s_lstrlen(lpSqlNodeColumn->value.String));

					if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                            			lpstmt->fISAMTxnStarted = TRUE;
                    			
					}
					break;
				case TYPE_CHAR:
					err = ISAMPutData(lpISAMTableDef, 
                                  		lpSqlNodeColumn->node.column.Id, SQL_C_CHAR, 
                                  		lpSqlNodeValue->value.String, 
                                  		lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                     		s_lstrlen(lpSqlNodeValue->value.String));
                    			if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				case TYPE_BINARY:
					err = ISAMPutData(lpISAMTableDef, 
                                  		lpSqlNodeColumn->node.column.Id, SQL_C_BINARY, 
                                  		BINARY_DATA(lpSqlNodeValue->value.Binary), 
                                  		lpSqlNodeValue->sqlIsNull ? SQL_NULL_DATA :
                                     		BINARY_LENGTH(lpSqlNodeValue->value.Binary));
                    			if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				case TYPE_DATE:                
					err = ISAMPutData(lpISAMTableDef,
                            			lpSqlNodeColumn->node.column.Id, SQL_C_DATE, 
                            			&(lpSqlNodeValue->value.Date),
                            			lpSqlNodeValue->sqlIsNull ?
                               			(SDWORD) SQL_NULL_DATA : sizeof(DATE_STRUCT));
                    			if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				case TYPE_TIME:                
					err = ISAMPutData(lpISAMTableDef,
                            			lpSqlNodeColumn->node.column.Id, SQL_C_TIME, 
                            			&(lpSqlNodeValue->value.Time),
                            			lpSqlNodeValue->sqlIsNull ?
                               			(SDWORD) SQL_NULL_DATA : sizeof(TIME_STRUCT));
                    			if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				case TYPE_TIMESTAMP:                
					err = ISAMPutData(lpISAMTableDef,
                            			lpSqlNodeColumn->node.column.Id, SQL_C_TIMESTAMP, 
                            			&(lpSqlNodeValue->value.Timestamp),
                            			lpSqlNodeValue->sqlIsNull ?
                               			(SDWORD) SQL_NULL_DATA : sizeof(TIMESTAMP_STRUCT));
                    			if ((err == NO_ISAM_ERR) || (err == ISAM_TRUNCATION))
                        			lpstmt->fISAMTxnStarted = TRUE;
					break;
				default:
					return ERR_INTERNAL;
				}
				if (err == ISAM_TRUNCATION) {
                    			finalErr = ERR_DATATRUNCATED;
                    			err = NO_ISAM_ERR;
                		}

				if (err != NO_ISAM_ERR) {
					ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
										(LPUSTR)lpstmt->szISAMError);
					return err;
				}
				
				idxSqlNodeSets = lpSqlNodeSets->node.updatevalues.Next;
			}
			
			/* Write the updated row to the table. */
			err = ISAMUpdateRecord (lpISAMTableDef);
			if (err != NO_ISAM_ERR) {
				ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
									(LPUSTR)lpstmt->szISAMError);
				return err;
			}
			lpstmt->fISAMTxnStarted = TRUE;

			/* Increase count */
			(lpstmt->cRowCount)++;
		} 

	}
		break;

    case NODE_TYPE_CREATEINDEX:
        {
            UWORD       icol[MAX_COLUMNS_IN_INDEX];
            BOOL        fDescending[MAX_COLUMNS_IN_INDEX];
            UWORD       count;
            
            /* Make sure this DDL statement is allowed now */
            err = TxnCapableForDDL(lpstmt);
            if (err == ERR_DDLIGNORED) 
                return ERR_DDLIGNORED;
            else if (err == ERR_DDLCAUSEDACOMMIT)
                finalErr = ERR_DDLCAUSEDACOMMIT;
            else if (err != ERR_SUCCESS)
                return err;

            /* Get handle to table */
            lpSqlNodeTable = ToNode(lpstmt->lpSqlStmt,
                                lpSqlNode->node.createindex.Table); 
            lpISAMTableDef = lpSqlNodeTable->node.table.Handle;

            /* Get definition of the index */
            idxSortcolumns = lpSqlNode->node.createindex.Columns;
            count = 0;
            while (idxSortcolumns != NO_SQLNODE) {
                lpSqlNodeSortcolumns =
                                   ToNode(lpstmt->lpSqlStmt, idxSortcolumns);
                lpSqlNodeColumn = ToNode(lpstmt->lpSqlStmt,
                              lpSqlNodeSortcolumns->node.sortcolumns.Column);
                icol[count] = lpSqlNodeColumn->node.column.Id;
                fDescending[count] =
                        lpSqlNodeSortcolumns->node.sortcolumns.Descending;
                count++;
                idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
            }

            /* Create the index */
            err = ISAMCreateIndex(lpISAMTableDef,
                                  ToString(lpstmt->lpSqlStmt,
                                          lpSqlNode->node.createindex.Index),
                                  lpSqlNode->node.createindex.Unique,
                                  count, icol, fDescending);
            if (err != NO_ISAM_ERR) {
                ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM,
                                                        (LPUSTR) lpstmt->szISAMError);
                return err;
            }
            if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
                lpstmt->fISAMTxnStarted = TRUE;
        }
        break;

    case NODE_TYPE_DROPINDEX:
        /* Make sure this DDL statement is allowed now */
        err = TxnCapableForDDL(lpstmt);
        if (err == ERR_DDLIGNORED) 
            return ERR_DDLIGNORED;
        else if (err == ERR_DDLCAUSEDACOMMIT)
            finalErr = ERR_DDLCAUSEDACOMMIT;
        else if (err != ERR_SUCCESS)
            return err;

        /* Delete the index */
        err = ISAMDeleteIndex(lpstmt->lpdbc->lpISAM,
                              ToString(lpstmt->lpSqlStmt,
                                       lpSqlNode->node.dropindex.Index));
        if (err != NO_ISAM_ERR) {
            ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR) lpstmt->szISAMError);
            return err;
        }
        if (lpstmt->lpdbc->lpISAM->fSchemaInfoTransactioned)
            lpstmt->fISAMTxnStarted = TRUE;
        break;


	case NODE_TYPE_PASSTHROUGH:
		err = ISAMExecute(lpstmt->lpISAMStatement, &(lpstmt->cRowCount));
		if (err != NO_ISAM_ERR) {
			ISAMGetErrorMessage(lpstmt->lpdbc->lpISAM, (LPUSTR)lpstmt->szISAMError);
			return err;
		}
		lpstmt->fISAMTxnStarted = TRUE;
		break;

	/* Internal error if these nodes are hanging off the root */
	case NODE_TYPE_TABLES:
	case NODE_TYPE_VALUES:
	case NODE_TYPE_COLUMNS:
	case NODE_TYPE_SORTCOLUMNS:
	case NODE_TYPE_GROUPBYCOLUMNS:
	case NODE_TYPE_UPDATEVALUES:
	case NODE_TYPE_CREATECOLS:
	case NODE_TYPE_BOOLEAN:
	case NODE_TYPE_COMPARISON:
	case NODE_TYPE_ALGEBRAIC:
	case NODE_TYPE_SCALAR:
	case NODE_TYPE_AGGREGATE:
	case NODE_TYPE_TABLE:
	case NODE_TYPE_COLUMN:
	case NODE_TYPE_STRING:
	case NODE_TYPE_NUMERIC:
	case NODE_TYPE_PARAMETER:
	case NODE_TYPE_USER:
	case NODE_TYPE_NULL:
	case NODE_TYPE_DATE:
	case NODE_TYPE_TIME:
	case NODE_TYPE_TIMESTAMP:
	default:
		return ERR_INTERNAL;
	}
	if (!fSelect && (lpstmt->lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE) &&
                                          lpstmt->lpdbc->fAutoCommitTxn) {
        err = SQLTransact(SQL_NULL_HENV, (HDBC)lpstmt->lpdbc, SQL_COMMIT);
        if ((err != SQL_SUCCESS) && (err != SQL_SUCCESS_WITH_INFO)) {
            lpstmt->errcode = lpstmt->lpdbc->errcode;
            s_lstrcpy(lpstmt->szISAMError, lpstmt->lpdbc->szISAMError);
            return lpstmt->errcode;
        }
    }
    return finalErr;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\execute.cpp ===
/***************************************************************************/
/* EXECUTE.C                                                               */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
/***************************************************************************/

RETCODE SQL_API SQLExecute(
    HSTMT   hstmt)          /* statement to execute. */
{
    LPSTMT  lpstmt;
    LPSQLNODE lpSqlNode;
    SQLNODEIDX  idxParameter;
    LPSQLNODE   lpSqlNodeParameter;
    LPPARAMETER lpParameter;
    SDWORD      cbValue;
    BOOL        fDataTruncated;

    /* Get handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;


	MyImpersonator im (lpstmt, "SQLExecute");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
        
    /* Error if no SQL statement available */
    if (lpstmt->lpSqlStmt == NULL) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Get the root of the SQL tree */
    lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
    if (lpSqlNode->sqlNodeType != NODE_TYPE_ROOT) {
        lpstmt->errcode = ERR_INTERNAL;
        return SQL_ERROR;
    }

    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* Do parameter substitution */
    lpstmt->fNeedData = FALSE;
    lpstmt->idxParameter = NO_SQLNODE;
    lpstmt->cbParameterOffset = -1;
    fDataTruncated = FALSE;
    idxParameter = lpSqlNode->node.root.parameters;
    while (idxParameter != NO_SQLNODE) {

        /* Get the parameter node in the SQL tree */
        lpSqlNodeParameter = ToNode(lpstmt->lpSqlStmt, idxParameter);

        /* Find the parameter specification in the list of bound parameters */
        for (lpParameter = lpstmt->lpParameter;
             lpParameter != NULL;
             lpParameter = lpParameter->lpNext) {
            if (lpParameter->ipar == lpSqlNodeParameter->node.parameter.Id)
                break;
        }
        if (lpParameter == NULL) {
            lpstmt->fNeedData = FALSE;
            lpstmt->errcode = ERR_PARAMETERMISSING;
            return SQL_ERROR;
        }

        /* Get length of parameter */
        if (lpParameter->pcbValue != NULL)
            cbValue = *(lpParameter->pcbValue);
        else
            cbValue = SQL_NTS;

        /* Is this a data-at-exec parameter? */
        if ((cbValue != SQL_DATA_AT_EXEC)  &&
            (cbValue > SQL_LEN_DATA_AT_EXEC(0))) {

            /* No.  Mark it */
            lpSqlNodeParameter->node.parameter.AtExec = FALSE;

            /* Copy the value into the parameter node */
            lpstmt->errcode = SetParameterValue(lpstmt, lpSqlNodeParameter,
                  NULL, lpParameter->fCType, lpParameter->rgbValue, cbValue);
            if (lpstmt->errcode == ERR_DATATRUNCATED) {
                fDataTruncated = TRUE;
                lpstmt->errcode = ERR_SUCCESS;
            }
            if (lpstmt->errcode != ERR_SUCCESS) {
                lpstmt->fNeedData = FALSE;
                return SQL_ERROR;
            }
        }
        else {
            /* Yes.  Mark it */
            lpSqlNodeParameter->node.parameter.AtExec = TRUE;

            /* Set flag saying data is still needed */
            lpstmt->fNeedData = TRUE;
            lpstmt->cbParameterOffset = 0;
        }

        /* Point to the next parameter */
        idxParameter = lpSqlNodeParameter->node.parameter.Next;
    }

    /* Are any parameters still needed? */
    if (lpstmt->fNeedData)

        /* Yes.  let caller know that */
        return SQL_NEED_DATA;

    else {

        /* No.  Perform the operation now */
       lpstmt->errcode = ExecuteQuery(lpstmt, NULL);
       if ((lpstmt->errcode == ERR_DATATRUNCATED) ||
           (lpstmt->errcode == ERR_DDLIGNORED) ||
           (lpstmt->errcode == ERR_DDLCAUSEDACOMMIT))
           return SQL_SUCCESS_WITH_INFO;
       if (lpstmt->errcode != ERR_SUCCESS)
           return SQL_ERROR;
    }

    if (fDataTruncated) {
        lpstmt->errcode = ERR_DATATRUNCATED;
        return SQL_SUCCESS_WITH_INFO;
    }
    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLExecDirect(
    HSTMT     hstmt,
    UCHAR FAR *szSqlStr,
    SDWORD    cbSqlStr)
{
    LPSTMT lpstmt;
    RETCODE rc;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	//Check if size is given as SQL_NTS, if so calculate real size
	if ( (cbSqlStr == SQL_NTS) && szSqlStr)
        cbSqlStr = lstrlen((char*)szSqlStr);

    /* Get handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;


	MyImpersonator im (lpstmt, "SQLExecDirect");

    /* Prepare the statement */
    rc = SQLPrepare(hstmt, szSqlStr, cbSqlStr);

    if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO))
        return rc;
        
    /* Execute it */
    rc = SQLExecute(hstmt);

    /* If execution caused a commit and the commit wiped out the prepared */
    /* statement, try again.  It will work this time since the transaction */
    /* has been committed */
    if ((rc == SQL_ERROR) && (lpstmt->errcode == ERR_DDLSTATEMENTLOST)) {
        rc = SQLExecDirect(hstmt, szSqlStr, cbSqlStr);
        if ((rc == SQL_SUCCESS) || (rc == SQL_SUCCESS_WITH_INFO)) {
            lpstmt->errcode = ERR_DDLCAUSEDACOMMIT;
            rc = SQL_SUCCESS_WITH_INFO;
        }
        return rc;
    }
    
    /* If execution failed, get rid of prepared statement */
    if ((rc != SQL_SUCCESS) && (rc != SQL_SUCCESS_WITH_INFO) &&
        (rc != SQL_NEED_DATA)) {
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }
    
    /* If not a SELECT statement, get rid of prepared statement */
    else if ((lpstmt->fStmtType != STMT_TYPE_SELECT) &&
             (rc != SQL_NEED_DATA)) {
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
    }
    
    /* Otherwise, set flag so statement will be discarded in SQLFreeStmt() */
    else {
        lpstmt->fPreparedSql = FALSE;
    }

    return rc;
}

/***************************************************************************/

RETCODE SQL_API SQLNativeSql(
    HDBC      hdbc,
    UCHAR FAR *szSqlStrIn,
    SDWORD     cbSqlStrIn,
    UCHAR FAR *szSqlStr,
    SDWORD     cbSqlStrMax,
    SDWORD FAR *pcbSqlStr)
{
    LPDBC  lpdbc;

    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_NOTSUPPORTED;
    return SQL_ERROR;
}

/***************************************************************************/

RETCODE SQL_API SQLParamData(
    HSTMT   hstmt,
    PTR FAR *prgbValue)
{
    LPSTMT  lpstmt;
    LPSQLNODE lpSqlNode;
    LPSQLNODE lpSqlNodeParameter;
    LPPARAMETER lpParameter;

    /* Get handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLParamData");
	
    /* Error if no more parameters to return */
    if (!(lpstmt->fNeedData)) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Error if data was not provided for the previous parameter */
    if (lpstmt->cbParameterOffset == -1) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Point at next parameter */
    if (lpstmt->idxParameter == NO_SQLNODE) {
        lpSqlNode = ToNode(lpstmt->lpSqlStmt, ROOT_SQLNODE);
        lpstmt->idxParameter = lpSqlNode->node.root.parameters;
    }
    else {
        lpSqlNodeParameter = ToNode(lpstmt->lpSqlStmt, lpstmt->idxParameter);
        lpstmt->idxParameter = lpSqlNodeParameter->node.parameter.Next;
    }

    /* Skip over all parameters that are not SQL_DATA_AT_EXEC */
    while (TRUE) {
        if (lpstmt->idxParameter == NO_SQLNODE) {

            /* If no more paramaeters, execute the query now */
            lpstmt->fNeedData = FALSE;
            lpstmt->cbParameterOffset = -1;
            lpstmt->errcode = ExecuteQuery(lpstmt, NULL);

            /* If an SQLExecDirect() on something other than a SELECT, get */
            /* rid of prepared statement */
            if ((lpstmt->fStmtType != STMT_TYPE_SELECT) &&
                                             !lpstmt->fPreparedSql) {
                FreeTree(lpstmt->lpSqlStmt);
                lpstmt->lpSqlStmt = NULL;
            }

            /* Leave */
            if ((lpstmt->errcode == ERR_DATATRUNCATED) ||
                (lpstmt->errcode == ERR_DDLIGNORED) ||
                (lpstmt->errcode == ERR_DDLCAUSEDACOMMIT))
                return SQL_SUCCESS_WITH_INFO;	
            if (lpstmt->errcode != ERR_SUCCESS)
               return SQL_ERROR;
            return SQL_SUCCESS;

        }
        lpSqlNodeParameter = ToNode(lpstmt->lpSqlStmt, lpstmt->idxParameter);
        if (lpSqlNodeParameter->node.parameter.AtExec)
            break;
        lpstmt->idxParameter = lpSqlNodeParameter->node.parameter.Next;
    }

    /* Find the parameter definition (create by SQLBindParameter) */
    for (lpParameter = lpstmt->lpParameter;
         lpParameter != NULL;
         lpParameter = lpParameter->lpNext) {
        if (lpParameter->ipar == lpSqlNodeParameter->node.parameter.Id)
            break;
    }
    if (lpParameter == NULL) {
        lpstmt->errcode = ERR_INTERNAL;
        return SQL_ERROR;
    }

    /* Return rgbValue */
    if (prgbValue != NULL)
        *prgbValue = lpParameter->rgbValue;
    lpstmt->cbParameterOffset = -1;

    return SQL_NEED_DATA;
}

/***************************************************************************/

RETCODE SQL_API SQLPutData(
    HSTMT   hstmt,
    PTR     rgbValue,
    SDWORD  cbValue)
{
    LPSTMT  lpstmt;
    LPSQLNODE lpSqlNodeParameter;
    LPPARAMETER lpParameter;

    /* Get handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLPutData");

    /* Error if no parameter value needed */
    if (!(lpstmt->fNeedData) || (lpstmt->idxParameter == NO_SQLNODE)) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Find the parameter definition (create by SQLBindParameter) */
    lpSqlNodeParameter = ToNode(lpstmt->lpSqlStmt, lpstmt->idxParameter);
    for (lpParameter = lpstmt->lpParameter;
         lpParameter != NULL;
         lpParameter = lpParameter->lpNext) {
        if (lpParameter->ipar == lpSqlNodeParameter->node.parameter.Id)
            break;
    }
    if (lpParameter == NULL) {
        lpstmt->errcode = ERR_INTERNAL;
        return SQL_ERROR;
    }

    /* Save the value */
    if (lpstmt->cbParameterOffset == -1)
        lpstmt->cbParameterOffset = 0;
    lpstmt->errcode = SetParameterValue(lpstmt, lpSqlNodeParameter,
                                        &(lpstmt->cbParameterOffset),
                                        lpParameter->fCType, rgbValue,
                                        cbValue);
    if (lpstmt->errcode == ERR_DATATRUNCATED)
        return SQL_SUCCESS_WITH_INFO;
    else if (lpstmt->errcode != ERR_SUCCESS) {
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        return SQL_ERROR;
    }

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLCancel(
    HSTMT   hstmt)
{
    return SQLFreeStmt(hstmt, SQL_CLOSE);
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\info.cpp ===
/***************************************************************************/
/* INFO.C                                                                  */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include <objbase.h>
#include <initguid.h>

#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"

/***************************************************************************/
RETCODE SQL_API SQLGetInfo(
    HDBC      hdbc,
    UWORD     fInfoType,
    PTR       rgbInfoValue,
    SWORD     cbInfoValueMax,
    SWORD FAR *pcbInfoValue)
{
    LPDBC lpdbc;

    /* Get connection handle */
    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpdbc, "SQLGetInfo");

    /* Return the info value */
    switch (fInfoType) {

    /* INFOs that return a string */
//	case SQL_ACCESSIBLE_PROCEDURES:
    case SQL_ACCESSIBLE_TABLES:
	case SQL_OUTER_JOINS:
	case SQL_DATA_SOURCE_READ_ONLY:
    case SQL_MAX_ROW_SIZE_INCLUDES_LONG:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "Y");
        break;
	case SQL_ACCESSIBLE_PROCEDURES:
    case SQL_COLUMN_ALIAS:
    case SQL_EXPRESSIONS_IN_ORDERBY:
    case SQL_LIKE_ESCAPE_CLAUSE:
    case SQL_MULT_RESULT_SETS:
    case SQL_NEED_LONG_DATA_LEN:
    case SQL_ODBC_SQL_OPT_IEF:
    case SQL_ORDER_BY_COLUMNS_IN_SELECT:
    case SQL_PROCEDURES:
    case SQL_ROW_UPDATES:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "N");
        break;
    case SQL_DATA_SOURCE_NAME:
        if (s_lstrcmp( (char*)lpdbc->szDSN, " "))
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, lpdbc->szDSN);
        else
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "");
        break;
    case SQL_DATABASE_NAME:
        if (lpdbc->lpISAM != NULL)
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                  pcbInfoValue, (LPUSTR) ISAMDatabase(lpdbc->lpISAM));
        else
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                  pcbInfoValue, (LPUSTR) "");
        break;
    case SQL_KEYWORDS:
    case SQL_OWNER_TERM:
    case SQL_PROCEDURE_TERM:
//    case SQL_SERVER_NAME:
    case SQL_SPECIAL_CHARACTERS:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "");
        break;
	case SQL_SERVER_NAME:
	{
		LPUSTR pName = ISAMServer(lpdbc->lpISAM);

		if (!pName)
		{
			lpdbc->errcode = ERR_ISAM;
		}
		else
		{
			lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, pName);
			delete (LPSTR)pName;
		}
	}
		break;
    case SQL_MULTIPLE_ACTIVE_TXN:
        if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE) {
            if (lpdbc->lpISAM->fMultipleActiveTxn)
                lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                            pcbInfoValue, (LPUSTR) "Y");
            else
                lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                            pcbInfoValue, (LPUSTR) "N");
        }
        else
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                          pcbInfoValue, (LPUSTR) "N");
        break;
    case SQL_QUALIFIER_TERM:
		lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "Namespace");
        break;
    case SQL_QUALIFIER_NAME_SEPARATOR:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) ".");
		break;
    case SQL_SEARCH_PATTERN_ESCAPE:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "\\");
        break;
    case SQL_DBMS_NAME:
	{
		LPUSTR pName = ISAMName(lpdbc->lpISAM);

		if (!pName)
		{
			lpdbc->errcode = ERR_ISAM;
		}
		else
		{
			lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, pName);
			delete (LPSTR)pName;
		}
	}
        break;
    case SQL_DBMS_VER:
	{
		LPUSTR pVersion = ISAMVersion(lpdbc->lpISAM);

		if (!pVersion)
		{
			lpdbc->errcode = ERR_ISAM;
		}
		else
		{
			lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, pVersion);
			delete (LPSTR)pVersion;
		}
	}
        break;
    case SQL_DRIVER_NAME:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) ISAMDriver(lpdbc->lpISAM));
        break;
    case SQL_DRIVER_ODBC_VER:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "02.10");
        break;
    case SQL_DRIVER_VER:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "01.00.0000");
        break;
    case SQL_IDENTIFIER_QUOTE_CHAR:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "\"");
        break;
    case SQL_TABLE_TERM:
        lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "Class");
        break;
    case SQL_USER_NAME:
            lpdbc->errcode = ReturnString(rgbInfoValue, cbInfoValueMax,
                                      pcbInfoValue, (LPUSTR) "");
        break;


    /* INFOs that return a two byte value */
    
    case SQL_ACTIVE_CONNECTIONS:
    case SQL_ACTIVE_STATEMENTS:
    case SQL_MAX_COLUMNS_IN_INDEX:
    case SQL_MAX_COLUMNS_IN_SELECT:
    case SQL_MAX_COLUMNS_IN_TABLE:
    case SQL_MAX_OWNER_NAME_LEN:
    case SQL_MAX_PROCEDURE_NAME_LEN:
    case SQL_MAX_TABLES_IN_SELECT:
        *(SWORD FAR *)rgbInfoValue = 0;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
	case SQL_MAX_QUALIFIER_NAME_LEN:
        *(SWORD FAR *)rgbInfoValue = 128;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_CONCAT_NULL_BEHAVIOR:
        *(SWORD FAR *)rgbInfoValue = SQL_CB_NON_NULL;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_CORRELATION_NAME:
        *(SWORD FAR *)rgbInfoValue = SQL_CN_ANY;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_CURSOR_COMMIT_BEHAVIOR:
    case SQL_CURSOR_ROLLBACK_BEHAVIOR:
        if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE) {
            if (lpdbc->lpISAM->fSchemaInfoTransactioned)
                *(SWORD FAR *)rgbInfoValue = SQL_CB_DELETE;
            else
                *(SWORD FAR *)rgbInfoValue = SQL_CB_CLOSE;
        }
        else
            *(SWORD FAR *)rgbInfoValue = SQL_CB_CLOSE;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_FILE_USAGE:
        *(SWORD FAR *)rgbInfoValue = SQL_FILE_NOT_SUPPORTED;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_GROUP_BY:
        *(SWORD FAR *)rgbInfoValue = SQL_GB_GROUP_BY_CONTAINS_SELECT;//SQL_GB_NOT_SUPPORTED;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_IDENTIFIER_CASE:
        *(SWORD FAR *)rgbInfoValue = SQL_IC_MIXED;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_QUOTED_IDENTIFIER_CASE:
        *(SWORD FAR *)rgbInfoValue = SQL_IC_SENSITIVE;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_COLUMN_NAME_LEN:
        *(SWORD FAR *)rgbInfoValue = ISAMMaxColumnNameLength(lpdbc->lpISAM);
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_COLUMNS_IN_GROUP_BY:
        *(SWORD FAR *)rgbInfoValue = 0; //was MAX_COLUMNS_IN_GROUP_BY;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_COLUMNS_IN_ORDER_BY:
        *(SWORD FAR *)rgbInfoValue = MAX_COLUMNS_IN_ORDER_BY;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_CURSOR_NAME_LEN:
        *(SWORD FAR *)rgbInfoValue = MAX_CURSOR_NAME_LENGTH;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_TABLE_NAME_LEN:
        *(SWORD FAR *)rgbInfoValue = ISAMMaxTableNameLength(lpdbc->lpISAM);
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_MAX_USER_NAME_LEN:
        *(SWORD FAR *)rgbInfoValue = MAX_USER_NAME_LENGTH;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_NON_NULLABLE_COLUMNS:
        *(SWORD FAR *)rgbInfoValue = SQL_NNC_NON_NULL;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_NULL_COLLATION:
        *(SWORD FAR *)rgbInfoValue = SQL_NC_LOW;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_ODBC_API_CONFORMANCE:
        *(SWORD FAR *)rgbInfoValue = SQL_OAC_LEVEL1;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_ODBC_SAG_CLI_CONFORMANCE:
        *(SWORD FAR *)rgbInfoValue = SQL_OSCC_COMPLIANT;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_ODBC_SQL_CONFORMANCE:
        *(SWORD FAR *)rgbInfoValue = SQL_OSC_MINIMUM;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_QUALIFIER_LOCATION:
        *(SWORD FAR *)rgbInfoValue = SQL_QL_START;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;
    case SQL_TXN_CAPABLE:
        *(SWORD FAR *)rgbInfoValue = lpdbc->lpISAM->fTxnCapable;
        if (pcbInfoValue != NULL) *pcbInfoValue = 2;
        break;


    /* INFOs that return a four byte value */
    case SQL_ALTER_TABLE:
    case SQL_BOOKMARK_PERSISTENCE:
    
    case SQL_FETCH_DIRECTION:
    case SQL_LOCK_TYPES:
    case SQL_MAX_INDEX_SIZE:
    case SQL_MAX_ROW_SIZE:
    case SQL_MAX_STATEMENT_LEN:
    case SQL_OWNER_USAGE:
    case SQL_POS_OPERATIONS:
    case SQL_POSITIONED_STATEMENTS:
    case SQL_SCROLL_CONCURRENCY:
    case SQL_SCROLL_OPTIONS:
    case SQL_STATIC_SENSITIVITY:
    case SQL_UNION:
        *(SDWORD FAR *)rgbInfoValue = 0;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
	
    case SQL_SUBQUERIES:
		*(SDWORD FAR *)rgbInfoValue =	SQL_SQ_CORRELATED_SUBQUERIES |
										SQL_SQ_COMPARISON |
										SQL_SQ_EXISTS |
										SQL_SQ_IN |
										SQL_SQ_QUANTIFIED;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
	case SQL_QUALIFIER_USAGE:
        *(SDWORD FAR *)rgbInfoValue = SQL_QU_DML_STATEMENTS;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_DEFAULT_TXN_ISOLATION:
        if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE)
            *(SDWORD FAR *)rgbInfoValue = lpdbc->lpISAM->fDefaultTxnIsolation;
        else
            *(SDWORD FAR *)rgbInfoValue = 0;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_TXN_ISOLATION_OPTION:
        if (lpdbc->lpISAM->fTxnCapable != SQL_TC_NONE)
            *(SDWORD FAR *)rgbInfoValue =
                        lpdbc->lpISAM->fTxnIsolationOption;
        else
            *(SDWORD FAR *)rgbInfoValue = 0;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_GETDATA_EXTENSIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_GD_ANY_COLUMN | SQL_GD_ANY_ORDER |
                                      SQL_GD_BOUND;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_MAX_CHAR_LITERAL_LEN:
        *(SDWORD FAR *)rgbInfoValue = MAX_CHAR_LITERAL_LENGTH;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_MAX_BINARY_LITERAL_LEN:
        *(SDWORD FAR *)rgbInfoValue = 0;// was MAX_BINARY_LITERAL_LENGTH;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_OJ_CAPABILITIES:
        *(SDWORD FAR *)rgbInfoValue = SQL_OJ_LEFT |
                                      SQL_OJ_NESTED |
                                      SQL_OJ_NOT_ORDERED |
                                      SQL_OJ_ALL_COMPARISON_OPS;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_BIGINT:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_BINARY:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_BIT:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_CHAR:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_DATE:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BINARY |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_DECIMAL:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_DOUBLE:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_FLOAT:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_INTEGER:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_LONGVARBINARY:
    case SQL_CONVERT_LONGVARCHAR:
        *(SDWORD FAR *)rgbInfoValue = 0;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_NUMERIC:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_REAL:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_SMALLINT:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_TIME:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BINARY |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_TIMESTAMP:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BINARY |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_TINYINT:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_VARBINARY:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_VARCHAR:
        *(SDWORD FAR *)rgbInfoValue = SQL_CVT_BIGINT |
                                      SQL_CVT_BINARY |
                                      SQL_CVT_BIT |
                                      SQL_CVT_CHAR |
                                      SQL_CVT_DATE |
                                      SQL_CVT_DECIMAL |
                                      SQL_CVT_DOUBLE |
                                      SQL_CVT_FLOAT |
                                      SQL_CVT_INTEGER |
                                      SQL_CVT_NUMERIC |
                                      SQL_CVT_REAL |
                                      SQL_CVT_SMALLINT |
                                      SQL_CVT_TIME |
                                      SQL_CVT_TIMESTAMP |
                                      SQL_CVT_TINYINT |
                                      SQL_CVT_VARBINARY |
                                      SQL_CVT_VARCHAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_CONVERT_FUNCTIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_FN_CVT_CONVERT;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_NUMERIC_FUNCTIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_FN_NUM_ABS |
                                      SQL_FN_NUM_ACOS |
                                      SQL_FN_NUM_ASIN |
                                      SQL_FN_NUM_ATAN |
                                      SQL_FN_NUM_ATAN2 |
                                      SQL_FN_NUM_CEILING |
                                      SQL_FN_NUM_COS |
                                      SQL_FN_NUM_COT |
                                      SQL_FN_NUM_DEGREES |
                                      SQL_FN_NUM_EXP |
                                      SQL_FN_NUM_FLOOR |
                                      SQL_FN_NUM_LOG |
                                      SQL_FN_NUM_LOG10 |
                                      SQL_FN_NUM_MOD |
                                      SQL_FN_NUM_PI |
                                      SQL_FN_NUM_POWER |
                                      SQL_FN_NUM_RADIANS |
                                      SQL_FN_NUM_RAND |
                                      SQL_FN_NUM_ROUND |
                                      SQL_FN_NUM_SIGN |
                                      SQL_FN_NUM_SIN |
                                      SQL_FN_NUM_SQRT |
                                      SQL_FN_NUM_TRUNCATE |
                                      SQL_FN_NUM_TAN ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_STRING_FUNCTIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_FN_STR_ASCII |
                                      SQL_FN_STR_CHAR |
                                      SQL_FN_STR_CONCAT |
                                      SQL_FN_STR_DIFFERENCE |
                                      SQL_FN_STR_INSERT |
                                      SQL_FN_STR_LCASE |
                                      SQL_FN_STR_LEFT |
                                      SQL_FN_STR_LENGTH |
                                      SQL_FN_STR_LOCATE |
                                      SQL_FN_STR_LOCATE_2 |
                                      SQL_FN_STR_LTRIM |
                                      SQL_FN_STR_REPEAT |
                                      SQL_FN_STR_REPLACE |
                                      SQL_FN_STR_RIGHT |
                                      SQL_FN_STR_RTRIM |
                                      SQL_FN_STR_SOUNDEX |
                                      SQL_FN_STR_SPACE |
                                      SQL_FN_STR_SUBSTRING |
                                      SQL_FN_STR_UCASE ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_SYSTEM_FUNCTIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_FN_SYS_DBNAME |
                                      SQL_FN_SYS_IFNULL |
                                      SQL_FN_SYS_USERNAME ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_TIMEDATE_ADD_INTERVALS:
    case SQL_TIMEDATE_DIFF_INTERVALS:
        *(SDWORD FAR *)rgbInfoValue = /* SQL_FN_TSI_FRAC_SECOND | */
                                      SQL_FN_TSI_SECOND |
                                      SQL_FN_TSI_MINUTE |
                                      SQL_FN_TSI_HOUR |
                                      SQL_FN_TSI_DAY |
                                      SQL_FN_TSI_WEEK |
                                      SQL_FN_TSI_MONTH |
                                      SQL_FN_TSI_QUARTER |
                                      SQL_FN_TSI_YEAR ;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    case SQL_TIMEDATE_FUNCTIONS:
        *(SDWORD FAR *)rgbInfoValue = SQL_FN_TD_CURDATE |
                                      SQL_FN_TD_CURTIME |
                                      SQL_FN_TD_DAYNAME |
                                      SQL_FN_TD_DAYOFMONTH |
                                      SQL_FN_TD_DAYOFWEEK |
                                      SQL_FN_TD_DAYOFYEAR |
                                      SQL_FN_TD_HOUR |
                                      SQL_FN_TD_MINUTE |
                                      SQL_FN_TD_MONTH |
                                      SQL_FN_TD_MONTHNAME |
                                      SQL_FN_TD_NOW |
                                      SQL_FN_TD_QUARTER |
                                      SQL_FN_TD_SECOND |
                                      SQL_FN_TD_TIMESTAMPADD |
                                      SQL_FN_TD_TIMESTAMPDIFF |
                                      SQL_FN_TD_WEEK |
                                      SQL_FN_TD_YEAR;
        if (pcbInfoValue != NULL) *pcbInfoValue = 4;
        break;
    default:
           lpdbc->errcode = ERR_NOTSUPPORTED;
        return SQL_ERROR;
    }

    if (lpdbc->errcode == ERR_DATATRUNCATED)
        return SQL_SUCCESS_WITH_INFO;

	if (lpdbc->errcode == ERR_ISAM)
		return SQL_ERROR;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetTypeInfo(
    HSTMT   hstmt,
    SWORD   fSqlType)
{
    LPSTMT  lpstmt;

    /* Get statement handle */
    lpstmt = (LPSTMT) hstmt;
    lpstmt->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpstmt, "SQLGetTypeInfo");

    /* Error if in the middle of a statement already */
    if (lpstmt->fStmtType != STMT_TYPE_NONE) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }
    if (lpstmt->fNeedData) {
        lpstmt->errcode = ERR_CURSORSTATE;
        return SQL_ERROR;
    }

    /* Free previously prepared statement if any */
    if (lpstmt->lpSqlStmt != NULL) {        
        FreeTree(lpstmt->lpSqlStmt);
        lpstmt->lpSqlStmt = NULL;
        lpstmt->fPreparedSql = FALSE;
        if (lpstmt->lpISAMStatement != NULL) {
            ISAMFreeStatement(lpstmt->lpISAMStatement);
            lpstmt->lpISAMStatement = NULL;
        }
        lpstmt->fNeedData = FALSE;
        lpstmt->idxParameter = NO_SQLNODE;
        lpstmt->cbParameterOffset = -1;
        lpstmt->cRowCount = -1;
    }

    /* Set type of table */
    lpstmt->fStmtType = STMT_TYPE_TYPEINFO;
    lpstmt->fStmtSubtype = STMT_SUBTYPE_NONE;

    /* Remember which type to get information for */
    lpstmt->fSqlType = fSqlType;

    /* So far no types returned */
    lpstmt->irow = BEFORE_FIRST_ROW;
    
    /* Count of rows is not available */
    lpstmt->cRowCount = -1;

    /* So far no column read */
    lpstmt->icol = NO_COLUMN;
    lpstmt->cbOffset = 0;

    return SQL_SUCCESS;
}

/***************************************************************************/

RETCODE SQL_API SQLGetFunctions(
    HDBC      hdbc,
    UWORD     fFunction,
    UWORD FAR *pfExists)
{
    LPDBC lpdbc;
    UWORD i;

    lpdbc = (LPDBC) hdbc;
    lpdbc->errcode = ERR_SUCCESS;

	//To make guarentee Ole is initialized per thread
	COleInitializationManager myOleManager;

	MyImpersonator im (lpdbc, "SQLGetFunctions");

    switch (fFunction) { 
    case SQL_API_ALL_FUNCTIONS:
        pfExists[SQL_API_ALL_FUNCTIONS] = FALSE;
        for (i=1; i < 100; i++)
            SQLGetFunctions(hdbc, i, &(pfExists[i]));
        break;
    case SQL_API_SQLALLOCENV:
    case SQL_API_SQLALLOCCONNECT:
    case SQL_API_SQLALLOCSTMT:
    case SQL_API_SQLBINDCOL:
    case SQL_API_SQLBINDPARAMETER:
    case SQL_API_SQLCANCEL:
    case SQL_API_SQLCOLATTRIBUTES:
    case SQL_API_SQLCOLUMNS:
    case SQL_API_SQLCONNECT:
	case SQL_API_SQLDATASOURCES:
    case SQL_API_SQLDESCRIBECOL:
    case SQL_API_SQLDISCONNECT:
    case SQL_API_SQLDRIVERCONNECT:
	case SQL_API_SQLDRIVERS:
    case SQL_API_SQLERROR:
    case SQL_API_SQLEXECDIRECT:
    case SQL_API_SQLEXECUTE:
    case SQL_API_SQLFETCH:
    case SQL_API_SQLFOREIGNKEYS:
    case SQL_API_SQLFREEENV:
    case SQL_API_SQLFREECONNECT:
    case SQL_API_SQLFREESTMT:
    case SQL_API_SQLGETCONNECTOPTION:
    case SQL_API_SQLGETDATA:
    case SQL_API_SQLGETINFO:
    case SQL_API_SQLGETCURSORNAME:
    case SQL_API_SQLGETFUNCTIONS:
	case SQL_API_SQLGETSTMTOPTION:
    case SQL_API_SQLGETTYPEINFO:
    case SQL_API_SQLMORERESULTS:
    case SQL_API_SQLNUMRESULTCOLS:
    case SQL_API_SQLPARAMDATA:
    case SQL_API_SQLPUTDATA:
    case SQL_API_SQLPREPARE:
    case SQL_API_SQLROWCOUNT:
    case SQL_API_SQLSETCONNECTOPTION:
    case SQL_API_SQLSETCURSORNAME:
    case SQL_API_SQLSETSTMTOPTION:
    case SQL_API_SQLSPECIALCOLUMNS:
    case SQL_API_SQLSTATISTICS:
    case SQL_API_SQLTABLES:
//    case SQL_API_SQLTRANSACT:
        *pfExists = TRUE;
        break;
    default:
        *pfExists = FALSE;
        break;
    }

    return SQL_SUCCESS;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\optimize.cpp ===
/***************************************************************************/
/* OPTIMIZE.C                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);

#include "drdbdr.h"
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/* MSAccess commonly passes predicates in the form:                        */
/*                                                                         */
/*                               OR                                        */
/*                              /  \                                       */
/*                        key-cond  OR                                     */
/*                                 /  \                                    */
/*                           key-cond  OR                                  */
/*                                    /  \                                 */
/*                              key-cond  OR                               */
/*                                       /  \                              */
/*                                 key-cond  OR                            */
/*                                          /  \                           */
/*                                    key-cond  OR                         */
/*                                             /  \                        */
/*                                       key-cond  OR                      */
/*                                                /  \                     */
/*                                          key-cond  OR                   */
/*                                                   /  \                  */
/*                                             key-cond  OR                */
/*                                                      /  \               */
/*                                                key-cond  key-cond       */
/*                                                                         */
/*                     Note: there are exactly 9 OR nodes.                 */
/*                                                                         */
/* There are ten key-cond in the tree and the structure of all ten are the */
/* same.  Each key-cond node is either a basic-model of:                   */
/*                                                                         */
/*                              EQUAL                                      */
/*                              /  \                                       */
/*                         COLUMN  PARAMETER                               */
/*                                                                         */
/* or the complex-model:                                                   */
/*                               AND                                       */
/*                              /  \                                       */
/*                     basic-model  AND                                    */
/*                                 /  \                                    */
/*                        basic-model   .                                  */
/*                                      .                                  */
/*                                      .                                  */
/*                                      AND                                */
/*                                     /  \                                */
/*                           basic-model  basic-model                      */
/*                                                                         */
/*            Note: there are a small number of AND nodex (6 or less)      */
/*                                                                         */
/*                                                                         */
/* The following routines test a predicate to see if it is in this form:   */

/***************************************************************************/

BOOL INTFUNC CheckBasicModel(LPSQLTREE lpSql, SQLNODEIDX predicate)

/* Tests to see if given node is in basic-model form */

{
    LPSQLNODE lpSqlNode;
    LPSQLNODE lpSqlNodeLeft;
    LPSQLNODE lpSqlNodeRight;

    if (predicate == NO_SQLNODE)
        return FALSE;
    lpSqlNode = ToNode(lpSql, predicate);
    if (lpSqlNode->sqlNodeType != NODE_TYPE_COMPARISON)
        return FALSE;
    if (lpSqlNode->node.comparison.Operator != OP_EQ)
        return FALSE;

    lpSqlNodeLeft = ToNode(lpSql, lpSqlNode->node.comparison.Left);
    if (lpSqlNodeLeft->sqlNodeType != NODE_TYPE_COLUMN)
        return FALSE;

    lpSqlNodeRight = ToNode(lpSql, lpSqlNode->node.comparison.Right);
    if (lpSqlNodeRight->sqlNodeType != NODE_TYPE_PARAMETER)
        return FALSE;

    return TRUE;
}

/***************************************************************************/

BOOL INTFUNC CheckModel(LPSQLTREE lpSql, SQLNODEIDX predicate, int count)

/* Tests to see if given node is in basic-model or complex-model form */

{
    LPSQLNODE lpSqlNode;

    if (count > 6)
        return FALSE;

    lpSqlNode = ToNode(lpSql, predicate);
    if (lpSqlNode->sqlNodeType == NODE_TYPE_COMPARISON)
        return CheckBasicModel(lpSql, predicate);

    if (lpSqlNode->sqlNodeType != NODE_TYPE_BOOLEAN)
        return FALSE;
    if (lpSqlNode->node.boolean.Operator != OP_AND)
        return FALSE;

    if (!CheckBasicModel(lpSql, lpSqlNode->node.boolean.Left))
        return FALSE;
    return CheckModel(lpSql, lpSqlNode->node.boolean.Right, count + 1);
}

/***************************************************************************/

SQLNODEIDX INTFUNC FindModel(LPSQLTREE lpSql, SQLNODEIDX predicate, int count)

/* Tests to make sure predicate has nine OR nodes and returns the right */
/* child of the ninth one */

{
    LPSQLNODE lpSqlNode;

    if (predicate == NO_SQLNODE)
        return NO_SQLNODE;
    lpSqlNode = ToNode(lpSql, predicate);
    if (lpSqlNode->sqlNodeType != NODE_TYPE_BOOLEAN)
        return NO_SQLNODE;
    if (lpSqlNode->node.boolean.Operator != OP_OR)
        return NO_SQLNODE;

    if (count < 9)
        return FindModel(lpSql, lpSqlNode->node.boolean.Right, count + 1);

    if (!CheckModel(lpSql, lpSqlNode->node.boolean.Right, 1))
        return NO_SQLNODE;
    return lpSqlNode->node.boolean.Right;
}

/***************************************************************************/

BOOL INTFUNC CompareTree(LPSQLTREE lpSql, SQLNODEIDX tree, SQLNODEIDX model)

/* Tests to see if the given tree and model have the same structure */

{
    LPSQLNODE lpSqlNode;
    LPSQLNODE lpSqlNodeModel;

    if (tree == NO_SQLNODE)
        return FALSE;
    lpSqlNode = ToNode(lpSql, tree);
    lpSqlNodeModel = ToNode(lpSql, model);
    if (lpSqlNode->sqlNodeType != lpSqlNodeModel->sqlNodeType)
        return FALSE;
    switch (lpSqlNodeModel->sqlNodeType) {
    case NODE_TYPE_BOOLEAN:
        if (lpSqlNode->node.boolean.Operator !=
                                lpSqlNodeModel->node.boolean.Operator)
            return FALSE;
        if (!CompareTree(lpSql, lpSqlNode->node.boolean.Left,
                                     lpSqlNodeModel->node.boolean.Left))
            return FALSE;
        if (!CompareTree(lpSql, lpSqlNode->node.boolean.Right,
                                     lpSqlNodeModel->node.boolean.Right))
            return FALSE;
        break;
    case NODE_TYPE_COMPARISON:
        if (lpSqlNode->node.comparison.Operator !=
                                lpSqlNodeModel->node.comparison.Operator)
            return FALSE;
        if (!CompareTree(lpSql, lpSqlNode->node.comparison.Left,
                                     lpSqlNodeModel->node.comparison.Left))
            return FALSE;
        if (!CompareTree(lpSql, lpSqlNode->node.comparison.Right,
                                     lpSqlNodeModel->node.comparison.Right))
            return FALSE;
        break;
    case NODE_TYPE_COLUMN:
        if (lpSqlNode->node.column.Id != lpSqlNodeModel->node.column.Id)
            return FALSE;
        break;
    case NODE_TYPE_PARAMETER:
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************/

BOOL INTFUNC CheckMSAccessPredicate(LPSQLTREE lpSql, SQLNODEIDX predicate)

/* Checks to see if prediciate is in the form documented above */

{
    SQLNODEIDX model;
    LPSQLNODE lpSqlNode;
    WORD i;

    model = FindModel(lpSql, predicate, 1);
    if (model == NO_SQLNODE)
        return FALSE;

    lpSqlNode = ToNode(lpSql, predicate);
    for (i = 1; i < 10; i++) {
        if (!CompareTree(lpSql, lpSqlNode->node.boolean.Left, model))
            return FALSE;
        lpSqlNode = ToNode(lpSql, lpSqlNode->node.boolean.Right);
    }
    return TRUE;
}
/***************************************************************************/
/***************************************************************************/
RETCODE INTFUNC FindRestriction(LPSQLTREE lpSql, BOOL fCaseSensitive,
                   LPSQLNODE lpSqlNodeTable, SQLNODEIDX idxPredicate,
                   SQLNODEIDX idxEnclosingStatement,
                   UWORD FAR *lpcRestriction, SQLNODEIDX FAR *lpRestriction)

/* Find the index of NODE_TYPE_COMPARISON nodes in the form:                */
/*                                                                          */
/*               <column> <op> <value>                                      */
/*               <column> <op> <anothercolumn>                              */
/*                                                                          */
/* where <column> is a column of the table identified by lpSqlNodeTable and */
/* <anothercolumn> is a column in a slower moving table.  The nodes are     */
/* returned in fSelectivity order (the most selective being first).         */

{
    LPSQLNODE  lpSqlNodePredicate;
    LPSQLNODE  lpSqlNodeRight;
    SQLNODEIDX idxLeft;
    SQLNODEIDX idxRight;
    LPSQLNODE  lpSqlNodeColumn;
    LPSQLNODE  lpSqlNodeValue;
    BOOL       fSwap;
    LPUSTR     lpTableAlias;
    LPUSTR     lpColumnAlias;
    LPSQLNODE  lpSqlNodeTables;
    LPSQLNODE  lpSqlNodeOtherTable;
    SQLNODEIDX idxPrev;
    SQLNODEIDX idxCurr;
    LPSQLNODE  lpSqlNodePredicatePrev;
    LPSQLNODE  lpSqlNodePredicateCurr;
    BOOL       fRightMightBeSlower;

    /* If no predicate, return */
    if (idxPredicate == NO_SQLNODE)
        return ERR_SUCCESS;

    /* What kind of predicate? */
    lpSqlNodePredicate = ToNode(lpSql, idxPredicate);
    switch (lpSqlNodePredicate->sqlNodeType) {
    case NODE_TYPE_CREATE:
    case NODE_TYPE_DROP:
    case NODE_TYPE_SELECT:
    case NODE_TYPE_INSERT:
    case NODE_TYPE_DELETE:
    case NODE_TYPE_UPDATE:
    case NODE_TYPE_CREATEINDEX:
    case NODE_TYPE_DROPINDEX:
    case NODE_TYPE_PASSTHROUGH:
    case NODE_TYPE_TABLES:
    case NODE_TYPE_VALUES:
    case NODE_TYPE_COLUMNS:
    case NODE_TYPE_SORTCOLUMNS:
    case NODE_TYPE_GROUPBYCOLUMNS:
    case NODE_TYPE_UPDATEVALUES:
    case NODE_TYPE_CREATECOLS:
        return ERR_INTERNAL;

    case NODE_TYPE_BOOLEAN:

        /* Boolean expression.  Look at each sub-expression */
        while (TRUE) {

            /* If not an AND expression, it can't be used.  Stop looking */
            if (lpSqlNodePredicate->node.boolean.Operator != OP_AND)
                return ERR_SUCCESS;

            /* Find nodes on the left side */
            FindRestriction(lpSql, fCaseSensitive,
                      lpSqlNodeTable, lpSqlNodePredicate->node.boolean.Left,
                      idxEnclosingStatement, lpcRestriction, lpRestriction);

            /* Get the right child */
            lpSqlNodeRight = ToNode(lpSql, lpSqlNodePredicate->node.boolean.Right);

            /* Is it a BOOLEAN node? */
            if (lpSqlNodeRight->sqlNodeType != NODE_TYPE_BOOLEAN) {

                /* No.  Find nodes on the right side */
                idxRight = FindRestriction(lpSql, fCaseSensitive,
                      lpSqlNodeTable, lpSqlNodePredicate->node.boolean.Right,
                      idxEnclosingStatement, lpcRestriction, lpRestriction);
                return ERR_SUCCESS;
            }

            /* Point to right and continue to walk down the AND nodes */
            lpSqlNodePredicate = lpSqlNodeRight;
        }
        break;  /* Control should never get here */

    case NODE_TYPE_COMPARISON:
	{
        /* If not the right operator, the comparison cannot be used */
        switch (lpSqlNodePredicate->node.comparison.Operator) {
        case OP_EQ:
        case OP_NE:
        case OP_LE:
        case OP_LT:
        case OP_GE:
        case OP_GT:
            break;
        case OP_IN:
        case OP_NOTIN:
        case OP_LIKE:
        case OP_NOTLIKE:
        case OP_EXISTS:
            return ERR_SUCCESS;
        default:
            return ERR_INTERNAL;
        }

        /* Get column of the comparison */
        lpSqlNodeColumn = ToNode(lpSql, lpSqlNodePredicate->node.comparison.Left);
        if (lpSqlNodeColumn->sqlNodeType != NODE_TYPE_COLUMN) {

            /* The left side is not a column reference.  Swap the two sides */
            fSwap = TRUE;
            lpSqlNodeValue = lpSqlNodeColumn;

            /* Is the right side a column reference? */
            lpSqlNodeColumn = ToNode(lpSql, lpSqlNodePredicate->node.comparison.Right);
            if (lpSqlNodeColumn->sqlNodeType != NODE_TYPE_COLUMN) {

                /* No.  The comparison cannot be used. */
                return ERR_SUCCESS;
            }
        }
        else {

            /* Get the value node */
            fSwap = FALSE;
            lpSqlNodeValue = ToNode(lpSql, lpSqlNodePredicate->node.comparison.Right);

            /* Is the rightside a column too? */
            if (lpSqlNodeValue->sqlNodeType == NODE_TYPE_COLUMN) {

                /* Yes.  Get the list of tables */
                lpSqlNodeTables = ToNode(lpSql, idxEnclosingStatement);

                /* If not a SELECT statement, <column> <op> <anothercolumn> */
                /*  cannot be used since the <othercolumn> would have to    */
                /*  to be in the same table.                                */
                if (lpSqlNodeTables->sqlNodeType != NODE_TYPE_SELECT)
                    return ERR_SUCCESS;
                lpSqlNodeTables = ToNode(lpSql, lpSqlNodeTables->node.select.Tables);

                /* If the rightside column is in this table, swap the sides */
                if (lpSqlNodeTable == ToNode(lpSql, lpSqlNodeValue->node.column.TableIndex))
		{
		    fSwap = TRUE;
                    lpSqlNodeValue = lpSqlNodeColumn;
                    lpSqlNodeColumn = ToNode(lpSql,
                    lpSqlNodePredicate->node.comparison.Right);
		}

                /* If the rightside column's table is in the same or a */
                /* faster moving table than the leftside column's table */
                /* the comparison cannot be used since the value of the */
                /* rightside column won't be constant for any given row */
                /* in the leftside table.  See if the rightside column is */
                /* in a slower moving table thanthe leftside column. */
                fRightMightBeSlower = TRUE;
                while (TRUE) {

                    /* Get next table */
                    lpSqlNodeOtherTable = ToNode(lpSql, lpSqlNodeTables->node.tables.Table);
                    lpTableAlias = ToString(lpSql, lpSqlNodeOtherTable->node.table.Alias);

                    /* If we get here and the current table is the */
                    /* leftside column's table, that means the rightside */
                    /* column's table has not been found on the list yet. */
                    /* Clear the flag so, if we happen to find the */
                    /* rightside column's table later on in the list, we */
                    /* will know that the rightside column's table is */ 
                    /* definitely not a slower moving than the leftside */
                    /* column's table */
                    if (lpSqlNodeOtherTable == ToNode(lpSql,lpSqlNodeColumn->node.column.TableIndex))
			return NO_SQLNODE;

                    /* Case sensitive names? */ 
                    if (lpSqlNodeOtherTable == ToNode(lpSql, lpSqlNodeValue->node.column.TableIndex))
			break;

                    /* Are we at the end of the list of tables? */
                    if (lpSqlNodeTables->node.tables.Next == NO_SQLNODE) {

                        /* Yes.  We never found the rightside column's */
                        /* table on the list.  This means the rightside */
                        /* column's table must be in a statement that */
                        /* encloses the SELECT statement identified by */
                        /* idxEnclosingStatement, so the rightside */
                        /* column's table is definitately slower moving. */  
                        /* The comparison may be able to be used. */
                        break;
                    }

                    /* Point to next table */
                    lpSqlNodeTables = ToNode(lpSql, lpSqlNodeTables->node.tables.Next);
                }
            }
        }

        /* If not <column> <op> <value> or <column> <op> <anothercolumn>, */
        /* the comparison can't be used */
        switch (lpSqlNodeValue->sqlNodeType) {
        case NODE_TYPE_CREATE:
        case NODE_TYPE_DROP:
           return ERR_INTERNAL;

        case NODE_TYPE_SELECT:
           return ERR_SUCCESS;

        case NODE_TYPE_INSERT:
        case NODE_TYPE_DELETE:
        case NODE_TYPE_UPDATE:
        case NODE_TYPE_CREATEINDEX:
        case NODE_TYPE_DROPINDEX:
        case NODE_TYPE_PASSTHROUGH:
        case NODE_TYPE_TABLES:
        case NODE_TYPE_VALUES:
        case NODE_TYPE_COLUMNS:
        case NODE_TYPE_SORTCOLUMNS:
        case NODE_TYPE_GROUPBYCOLUMNS:
        case NODE_TYPE_UPDATEVALUES:
        case NODE_TYPE_CREATECOLS:
        case NODE_TYPE_BOOLEAN:
        case NODE_TYPE_COMPARISON:
           return ERR_INTERNAL;

        case NODE_TYPE_ALGEBRAIC:
        case NODE_TYPE_SCALAR:
        case NODE_TYPE_AGGREGATE:
           return ERR_SUCCESS;

        case NODE_TYPE_TABLE:
           return ERR_INTERNAL;

        case NODE_TYPE_COLUMN:
        case NODE_TYPE_STRING:
        case NODE_TYPE_NUMERIC:
        case NODE_TYPE_PARAMETER:
        case NODE_TYPE_USER:
        case NODE_TYPE_NULL:
        case NODE_TYPE_DATE:
        case NODE_TYPE_TIME:
        case NODE_TYPE_TIMESTAMP:
            break;

        default:
            return ERR_INTERNAL;
        }

        /* If column is not in this table, the comparison cannot be used */
        lpTableAlias = ToString(lpSql, lpSqlNodeTable->node.table.Alias);
        lpColumnAlias = ToString(lpSql, lpSqlNodeColumn->node.column.Tablealias);
        
	if (lpSqlNodeTable != ToNode(lpSql, lpSqlNodeColumn->node.column.TableIndex))
		return NO_SQLNODE;

        /* This comparison can be used.  Swap the sides if need be */
        if (fSwap) {
            idxLeft = lpSqlNodePredicate->node.comparison.Left;
            lpSqlNodePredicate->node.comparison.Left =
                                      lpSqlNodePredicate->node.comparison.Right;
            lpSqlNodePredicate->node.comparison.Right = idxLeft;

            switch (lpSqlNodePredicate->node.comparison.Operator) {
            case OP_EQ:
            case OP_NE:
                break;
            case OP_LE:
                lpSqlNodePredicate->node.comparison.Operator = OP_GE;
                break;
            case OP_LT:
                lpSqlNodePredicate->node.comparison.Operator = OP_GT;
                break;
            case OP_GE:
                lpSqlNodePredicate->node.comparison.Operator = OP_LE;
                break;
            case OP_GT:
                lpSqlNodePredicate->node.comparison.Operator = OP_LT;
                break;
            case OP_IN:
            case OP_NOTIN:
            case OP_LIKE:
            case OP_NOTLIKE:
            default:
                return ERR_INTERNAL;
            }
        }

        /* Get the selectivity of the column */
	ClassColumnInfoBase* cInfoBase = (lpSqlNodeTable->node.table.Handle)->pColumnInfo;

	if ( !cInfoBase->IsValid() )
	{
            return NO_SQLNODE;
	}

	lpSqlNodePredicate->node.comparison.fSelectivity = cInfoBase->GetSelectivity();

        /* Is the selectivity non-zero? */
        if (lpSqlNodePredicate->node.comparison.fSelectivity != 0) {

            /* Put the predicate on the list */
            idxPrev = NO_SQLNODE;
            idxCurr = *lpRestriction;
            while (idxCurr != NO_SQLNODE) {
                lpSqlNodePredicateCurr = ToNode(lpSql, idxCurr);
                if (lpSqlNodePredicateCurr->node.comparison.fSelectivity <
                                lpSqlNodePredicate->node.comparison.fSelectivity)
                    break;
                idxPrev = idxCurr;
                idxCurr = lpSqlNodePredicateCurr->node.comparison.NextRestrict;
            }
            lpSqlNodePredicate->node.comparison.NextRestrict = idxCurr;
            if (idxPrev != NO_SQLNODE) {
                lpSqlNodePredicatePrev = ToNode(lpSql, idxPrev);
                lpSqlNodePredicatePrev->node.comparison.NextRestrict = idxPredicate;
            }
            else {
                *lpRestriction = idxPredicate;
            }

            /* Increase count */
            *lpcRestriction = (*lpcRestriction) + 1;
        }

        return ERR_SUCCESS;
    }
    case NODE_TYPE_ALGEBRAIC:
    case NODE_TYPE_SCALAR:
    case NODE_TYPE_AGGREGATE:
    case NODE_TYPE_TABLE:
    case NODE_TYPE_COLUMN:
    case NODE_TYPE_STRING:
    case NODE_TYPE_NUMERIC:
    case NODE_TYPE_PARAMETER:
    case NODE_TYPE_USER:
    case NODE_TYPE_NULL:
    case NODE_TYPE_DATE:
    case NODE_TYPE_TIME:
    case NODE_TYPE_TIMESTAMP:
    default:
        return ERR_INTERNAL;
    }
    /* Control never gets here */
}        
/***************************************************************************/

RETCODE INTFUNC Optimize(LPSQLTREE lpSql, SQLNODEIDX idxStatement,
                         BOOL fCaseSensitive)

/* Optimizes a parse tree */

{
    LPSQLNODE lpSqlNode;
    SQLNODEIDX idxPredicate;
    LPSQLNODE lpSqlNodeTableList;
    LPSQLNODE lpSqlNodeFirstTable;
    LPSQLNODE lpSqlNodeTables;
    LPSQLNODE lpSqlNodeTable;
    SQLNODEIDX idxSortcolumns;
    UWORD     tableSequenceNumber;
    LPSQLNODE lpSqlNodeSortcolumns;
    LPSQLNODE lpSqlNodeColumn;
    LPUSTR    lpColumnAlias;
//    LPUSTR    lpTableAlias;
    UWORD     idx;
    UWORD     i;
    SQLNODEIDX idxTables;
    LPSQLNODE lpSqlNodeTablesPrev;
    RETCODE   err;
#define NUM_LEN 5

    /* Return if nothing to optimize */
    if (idxStatement == NO_SQLNODE)
        return ERR_SUCCESS;

	//Add table cartesian product optimization here
	LPSQLNODE lpRootNode = ToNode(lpSql, ROOT_SQLNODE);

	//Sai Wong
	LPSQLNODE lpSqlNode2 = ToNode(lpSql, lpRootNode->node.root.sql);
//	LPSQLNODE lpSqlNode2 = ToNode(lpSql, idxStatement);

	TableColumnInfo optimizationInfo (&lpRootNode, &lpSqlNode2);

	//For each table in table list, check if there are any references
	//to its child columns
	if (optimizationInfo.IsValid())
	{
		//Point to beginning of select list
		if (lpSqlNode2->node.select.Tables != NO_SQLNODE)
		{
			LPSQLNODE lpSelectList = ToNode(lpSql, lpSqlNode2->node.select.Tables);
			LPSQLNODE lpSqlNodeTable = NULL;
			LPSQLNODE lpPrevNode = NULL;
			SQLNODEIDX idxNode = NO_SQLNODE;
			SQLNODEIDX idxSelectNode = lpSqlNode2->node.select.Tables;
			SQLNODEIDX idxPrevNode = NO_SQLNODE;
			BOOL fFirstTime = TRUE;
			while (lpSelectList)
			{
				//Sai added
				SQLNODEIDX lpSqlNodeTables = lpSelectList->node.tables.Table;
				lpSqlNodeTable = ToNode(lpSql, lpSqlNodeTables);

				if ( optimizationInfo.IsTableReferenced(lpSqlNodeTable->node.table.Handle) ||
					optimizationInfo.IsZeroOrOneList()  )
				{
//					ODBCTRACE ("\nWBEM ODBC Driver: Table is referenced or there is only one table\n");
				}
				else
				{
					ODBCTRACE ("\nWBEM ODBC Driver: Table is not referenced so we REMOVE FROM TABLELIST\n");

					//We now need to remove table from tablelist
					if (fFirstTime)
					{
						idxNode = lpSqlNode2->node.select.Tables;
						lpSqlNode2->node.select.Tables = lpSelectList->node.tables.Next;
						lpSelectList->node.tables.Next = NO_SQLNODE;
				//		FreeTreeSemantic(lpSql, idxNode);

						//Prepare for next interation
						//fFirstTime = FALSE;
						idxSelectNode = lpSqlNode2->node.select.Tables;
						FreeTreeSemantic(lpSql, idxNode);

						if (idxSelectNode != NO_SQLNODE)
						{
							lpSelectList = ToNode(lpSql, idxSelectNode);
						}
						else
						{
							lpSelectList = NULL;
						}

						continue;
					}
					else
					{
						idxNode = lpPrevNode->node.tables.Next;
						lpPrevNode->node.tables.Next = lpSelectList->node.tables.Next;
						lpSelectList->node.tables.Next = NO_SQLNODE;
					//	FreeTreeSemantic(lpSql, idxNode);

						//Prepare for next interation
						fFirstTime = FALSE;
						idxSelectNode = lpPrevNode->node.tables.Next;
						FreeTreeSemantic(lpSql, idxNode);

						if (idxSelectNode != NO_SQLNODE)
						{
							lpSelectList = ToNode(lpSql, idxSelectNode);
							lpPrevNode = ToNode(lpSql, idxPrevNode);
						}
						else
						{
							lpSelectList = NULL;
						}

						continue;
					}

				}


				//Prepare for next interation
				fFirstTime = FALSE;
				lpPrevNode = lpSelectList;
				idxPrevNode = idxSelectNode;

				if (lpSelectList->node.tables.Next != NO_SQLNODE)
				{
					idxSelectNode = lpSelectList->node.tables.Next;
					lpSelectList = ToNode(lpSql, idxSelectNode); 
				}
				else
				{
					idxSelectNode = NO_SQLNODE;
					lpSelectList = NULL;
				}
			}
		}
	}


    /* Find predicate, list of tables, and first table on that list.  At */
    /* the same time, walk the tree to optimize any nested sub-selects */
    lpSqlNode = ToNode(lpSql, idxStatement);
    lpSqlNodeTableList = NULL;
    lpSqlNodeFirstTable = NULL;
    switch (lpSqlNode->sqlNodeType) {

    case NODE_TYPE_CREATE:
        break;

    case NODE_TYPE_DROP:
        break;

    case NODE_TYPE_SELECT:

        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.select.Tables, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;
        err = Optimize(lpSql, lpSqlNode->node.select.Predicate, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;
        err = Optimize(lpSql, lpSqlNode->node.select.Having, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;

        lpSqlNodeTableList = ToNode(lpSql, lpSqlNode->node.select.Tables);
        lpSqlNodeFirstTable = ToNode(lpSql, lpSqlNodeTableList->node.tables.Table);
        idxPredicate = lpSqlNode->node.select.Predicate;
        break;

    case NODE_TYPE_INSERT:
        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.insert.Values, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;
        break;

    case NODE_TYPE_DELETE:

        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.delet.Predicate, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;

        lpSqlNodeTableList = NULL;
        lpSqlNodeFirstTable = ToNode(lpSql, lpSqlNode->node.delet.Table);
        idxPredicate = lpSqlNode->node.delet.Predicate;
        break;

    case NODE_TYPE_UPDATE:

        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.update.Predicate, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;

        lpSqlNodeTableList = NULL;
        lpSqlNodeFirstTable = ToNode(lpSql, lpSqlNode->node.update.Table);
        idxPredicate = lpSqlNode->node.update.Predicate;
        break;
    
    case NODE_TYPE_CREATEINDEX:
        break;

    case NODE_TYPE_DROPINDEX:
        break;

    case NODE_TYPE_PASSTHROUGH:
        break;

    case NODE_TYPE_TABLES:

        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.tables.Table, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;
        err = Optimize(lpSql, lpSqlNode->node.tables.Next, fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;

        break;

    case NODE_TYPE_VALUES:
        break;

    case NODE_TYPE_COLUMNS:
    case NODE_TYPE_SORTCOLUMNS:
    case NODE_TYPE_GROUPBYCOLUMNS:
    case NODE_TYPE_UPDATEVALUES:
    case NODE_TYPE_CREATECOLS:
        return ERR_INTERNAL;

    case NODE_TYPE_BOOLEAN:

        /* Optimize any nested sub-selects */
        while (TRUE) {

            /* Optimize left child */
            err = Optimize(lpSql, lpSqlNode->node.boolean.Left, fCaseSensitive);
            if (err != ERR_SUCCESS)
                return err;

            /* Leave loop if no right child */
            if (lpSqlNode->node.boolean.Right == NO_SQLNODE)
                break;

            /* Is right child a NODE_TYPE_BOOLEAN node? */
            if (ToNode(lpSql, lpSqlNode->node.boolean.Right)->sqlNodeType !=
                                               NODE_TYPE_BOOLEAN) {

                /* No.  Optimize that and leave the loop */
                err = Optimize(lpSql, lpSqlNode->node.boolean.Right,
                                fCaseSensitive);
                if (err != ERR_SUCCESS)
                    return err;
                break;
            }

            /* Optimize the right node on next iteration of the loop */
            lpSqlNode = ToNode(lpSql, lpSqlNode->node.boolean.Right);
        }

        break;

    case NODE_TYPE_COMPARISON:

        /* Optimize any nested sub-selects */
        if (lpSqlNode->node.comparison.Operator == OP_EXISTS) {
            err = Optimize(lpSql, lpSqlNode->node.comparison.Left,
                           fCaseSensitive);
            if (err != ERR_SUCCESS)
                return err;
        }
        else if (lpSqlNode->node.comparison.SelectModifier !=
                                                        SELECT_NOTSELECT) {
            err = Optimize(lpSql, lpSqlNode->node.comparison.Right,
                           fCaseSensitive);
            if (err != ERR_SUCCESS)
                return err;
        }
        break;

    case NODE_TYPE_ALGEBRAIC:
    case NODE_TYPE_SCALAR:
    case NODE_TYPE_AGGREGATE:
        return ERR_INTERNAL;

    case NODE_TYPE_TABLE:

        /* Optimize any nested sub-selects */
        err = Optimize(lpSql, lpSqlNode->node.table.OuterJoinPredicate,
                       fCaseSensitive);
        if (err != ERR_SUCCESS)
            return err;

        break;

    case NODE_TYPE_COLUMN:
    case NODE_TYPE_STRING:
    case NODE_TYPE_NUMERIC:
    case NODE_TYPE_PARAMETER:
    case NODE_TYPE_USER:
    case NODE_TYPE_NULL:
    case NODE_TYPE_DATE:
    case NODE_TYPE_TIME:
    case NODE_TYPE_TIMESTAMP:
    default:
        return ERR_INTERNAL;
    }

    /* Is this a SELECT statement? */
    if (lpSqlNode->sqlNodeType == NODE_TYPE_SELECT) {

        /* Yes.  For each sort column... */
        idxSortcolumns = lpSqlNode->node.select.Sortcolumns;
        tableSequenceNumber = 0;
        while ((idxSortcolumns != NO_SQLNODE) && 
               (lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) &&
               (!lpSqlNode->node.select.ImplicitGroupby) &&
               (!lpSqlNode->node.select.Distinct)) {

            /* Get the sort column */
            lpSqlNodeSortcolumns = ToNode(lpSql, idxSortcolumns);
            lpSqlNodeColumn = ToNode(lpSql,
                                 lpSqlNodeSortcolumns->node.sortcolumns.Column);

            /* If not a simple column reference, we cannot optimize the */
            /* sort by simply rearranging the order the tables are cycled */
            /* through and pushing the sorting down to the ISAM level. */ 
            /* Leave the loop */
            if (lpSqlNodeColumn->sqlNodeType != NODE_TYPE_COLUMN)
                break;

            /* Get the sort column's table name */
            lpColumnAlias = ToString(lpSql, lpSqlNodeColumn->node.column.Tablealias);

            /* Find the table of the column on the table list */
            lpSqlNodeTable = ToNode(lpSql, lpSqlNodeColumn->node.column.TableIndex);

            /* We cannot pushdown the sort if it involves an outer join */
            /* column.  Leave the loop */
            if (lpSqlNodeTable->node.table.OuterJoinPredicate != NO_SQLNODE)
                break;

            /* Has a column for this table already been found in sort list? */
            if (lpSqlNodeTable->node.table.Sortsequence == 0) {

                /* No.  This is the beginning of a sequence of columns for */
                /* this table.  Save the sequence number. */
                tableSequenceNumber++;
                lpSqlNodeTable->node.table.Sortsequence = tableSequenceNumber;
                lpSqlNodeTable->node.table.Sortcount = 1;
                lpSqlNodeTable->node.table.Sortcolumns = idxSortcolumns;
            }
            else {

                /* Yes.  If not part of the current table sequence we */
                /* cannot optimize the sort by simply rearranging the */
                /* order the tables are cycled through and pushing the */
                /* sorting down to the ISAM level.  Leave the loop */
                if (lpSqlNodeTable->node.table.Sortsequence != tableSequenceNumber)
                    break;
            
                /* Increase the number of columns to sort this table by */
                lpSqlNodeTable->node.table.Sortcount++;
            }

            /* Do the next column */
            idxSortcolumns = lpSqlNodeSortcolumns->node.sortcolumns.Next;
        }

        /* Can we optimize the sort by pushing the sorting down to the */
        /* ISAM level? */
        if ((idxSortcolumns == NO_SQLNODE) && 
               (lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) &&
               (!lpSqlNode->node.select.ImplicitGroupby) &&
               (!lpSqlNode->node.select.Distinct)) {

            /* Yes.  Rearrange the table order.  Move the table with the   */
            /* first sort column to the front of the table table list,     */
            /* move the table of the second column to the next position,   */
            /* etc.  The processing of a SELECT statement does a cartesian */
            /* product of the tables on the table list, with the table at  */ 
            /* the beginning of the list "spinning" slowest (see           */
            /* NextRecord() in EVALUATE.C).  Putting the table with the    */
            /* first column to sort by at the front of the list will cause */ 
            /* the records to be considered in sorted order at execution   */ 
            /* time.  For each table with sort columns...                  */
            for (idx = 0; idx < tableSequenceNumber; idx++) {

                /* Find the idx'th table */
                idxTables = lpSqlNode->node.select.Tables;
                lpSqlNodeTables = lpSqlNodeTableList;
                lpSqlNodeTable = lpSqlNodeFirstTable;
                lpSqlNodeTablesPrev = NULL;
                while (TRUE) {

                    /* If this is the table, leave the loop */
                    if (lpSqlNodeTable->node.table.Sortsequence == (idx + 1))
                        break;

                    /* Internal error if no more tables */
                    if (lpSqlNodeTables == NULL)
                        return ERR_INTERNAL;
                    if (lpSqlNodeTables->node.tables.Next == NO_SQLNODE)
                        return ERR_INTERNAL;

                    /* Do the next table on the list */
                    lpSqlNodeTablesPrev = lpSqlNodeTables;
                    idxTables = lpSqlNodeTables->node.tables.Next;
                    lpSqlNodeTables = ToNode(lpSql, lpSqlNodeTables->node.tables.Next);
                    lpSqlNodeTable = ToNode(lpSql, lpSqlNodeTables->node.tables.Table);
                }

                /* Remove the table found from the list */
                if (lpSqlNodeTablesPrev == NULL)
                    lpSqlNode->node.select.Tables = lpSqlNodeTables->node.tables.Next;
                else
                    lpSqlNodeTablesPrev->node.tables.Next =
                                               lpSqlNodeTables->node.tables.Next;

                /* Find the entry before the idx'th position of the list */
                lpSqlNodeTablesPrev = NULL;
                for (i=0; i < idx; i++) {
                    if (lpSqlNodeTablesPrev == NULL)
                        lpSqlNodeTablesPrev =
                                ToNode(lpSql, lpSqlNode->node.select.Tables);
                    else
                        lpSqlNodeTablesPrev =
                             ToNode(lpSql, lpSqlNodeTablesPrev->node.tables.Next);
                }

                /* Put the table found in the idx'th position of the list */
                if (lpSqlNodeTablesPrev == NULL) {
                    lpSqlNodeTables->node.tables.Next = lpSqlNode->node.select.Tables;
                    lpSqlNode->node.select.Tables = idxTables;
                }
                else {
                    lpSqlNodeTables->node.tables.Next =
                                  lpSqlNodeTablesPrev->node.tables.Next;
                    lpSqlNodeTablesPrev->node.tables.Next = idxTables;
                }

                /* Recalculate the table list and table pointers */
                lpSqlNodeTableList = ToNode(lpSql, lpSqlNode->node.select.Tables);
                lpSqlNodeFirstTable = ToNode(lpSql,
                                          lpSqlNodeTableList->node.tables.Table);

            }

            /* Set flag to enable the pushdown sort */
            lpSqlNode->node.select.fPushdownSort = TRUE;
        }
        else {
            /* No.  Remove the markers */
            lpSqlNodeTables = lpSqlNodeTableList;
            lpSqlNodeTable = lpSqlNodeFirstTable;
            while (TRUE) {

                /* Remove the markers for this table */
                lpSqlNodeTable->node.table.Sortsequence = 0;
                lpSqlNodeTable->node.table.Sortcount = 0;
                lpSqlNodeTable->node.table.Sortcolumns = NO_SQLNODE;

                /* Leave if no more tables */
                if (lpSqlNodeTables == NULL)
                    break;
                if (lpSqlNodeTables->node.tables.Next == NO_SQLNODE)
                    break;

                /* Do the next table on the list */
                lpSqlNodeTables = ToNode(lpSql, lpSqlNodeTables->node.tables.Next);
                lpSqlNodeTable = ToNode(lpSql, lpSqlNodeTables->node.tables.Table);
            }
        }
    }

    /* For each table... */
    lpSqlNodeTables = lpSqlNodeTableList;
    lpSqlNodeTable = lpSqlNodeFirstTable;
    while (lpSqlNodeTable != NULL) {

        /* Find the selective conditions that uses a column in this table */
        lpSqlNodeTable->node.table.cRestrict = 0;
        lpSqlNodeTable->node.table.Restrict = NO_SQLNODE;
        if (lpSqlNodeTable->node.table.OuterJoinPredicate == NO_SQLNODE)
            FindRestriction(lpSql, fCaseSensitive, lpSqlNodeTable,
                       idxPredicate, idxStatement,
                       &(lpSqlNodeTable->node.table.cRestrict),
                       &(lpSqlNodeTable->node.table.Restrict));
        else
            FindRestriction(lpSql, fCaseSensitive, lpSqlNodeTable,
                       lpSqlNodeTable->node.table.OuterJoinPredicate,
                       idxStatement, &(lpSqlNodeTable->node.table.cRestrict),
                       &(lpSqlNodeTable->node.table.Restrict));
        
        /* Leave if no more tables */
        if (lpSqlNodeTables == NULL)
            break;
        if (lpSqlNodeTables->node.tables.Next == NO_SQLNODE)
            break;

        /* Do the next table on the list */
        lpSqlNodeTables = ToNode(lpSql, lpSqlNodeTables->node.tables.Next);
        lpSqlNodeTable = ToNode(lpSql, lpSqlNodeTables->node.tables.Table);
    }

    /* Check to see if this is a funny MSAccess query */
    if ((lpSqlNode->sqlNodeType == NODE_TYPE_SELECT) &&
        (!(lpSqlNode->node.select.Distinct)) &&
        (lpSqlNodeTableList->node.tables.Next == NO_SQLNODE) &&
        (lpSqlNode->node.select.Groupbycolumns == NO_SQLNODE) &&
        (lpSqlNode->node.select.Having == NO_SQLNODE) &&
        (lpSqlNode->node.select.Sortcolumns == NO_SQLNODE) &&
        (ToNode(lpSql, ROOT_SQLNODE)->node.root.sql == idxStatement)) {
        if (CheckMSAccessPredicate(lpSql, lpSqlNode->node.select.Predicate)) {
            lpSqlNode->node.select.fMSAccess = TRUE;
            lpSqlNode->node.select.SortRecordsize = NUM_LEN + sizeof(ISAMBOOKMARK);
            lpSqlNode->node.select.SortBookmarks = NUM_LEN + 1;
        }
    }

    return ERR_SUCCESS;
}
/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\optimize.h ===
/***************************************************************************/
/* OPTIMIZE.H                                                              */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/

RETCODE INTFUNC Optimize(LPSQLTREE, SQLNODEIDX, BOOL);
RETCODE INTFUNC FindRestriction(LPSQLTREE, BOOL, LPSQLNODE, SQLNODEIDX,
                                SQLNODEIDX, UWORD FAR *, SQLNODEIDX FAR *);

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\odbc\isam.cpp ===
/***************************************************************************/
/* ISAM.C                                                                  */
/* Copyright (C) 1995-96 SYWARE Inc., All rights reserved                  */
/***************************************************************************/
// Commenting #define out - causing compiler error - not sure if needed, compiles
// okay without it.
//#define WINVER 0x0400
#include "precomp.h"
#include "wbemidl.h"

#include <comdef.h>
//smart pointer
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);
//_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);
_COM_SMARTPTR_TYPEDEF(IWbemClassObject,				IID_IWbemClassObject);
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet,			IID_IWbemQualifierSet);


#include "drdbdr.h"
#include "float.h"
#include "resource.h"
#include <comdef.h>  //for _bstr_t
#include <vector>

#include "cominit.h" //for Dcom blanket

#include <process.h> //for _beginthreadex

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//Some standard SYNTAX/CIMTYPE qualifier string constants

//#define WBEM_WSYNTAX_CHAR				L"CHAR"
//#define WBEM_WSYNTAX_INT8				L"INT8"
#define WBEM_WSYNTAX_UINT8				L"UINT8"
#define WBEM_WSYNTAX_SINT8				L"SINT8"
//#define WBEM_WSYNTAX_UCHAR				L"UCHAR"
//#define WBEM_WSYNTAX_BYTE				L"BYTE"
//#define WBEM_WSYNTAX_INT64				L"INT64"
#define WBEM_WSYNTAX_SINT64				L"SINT64"
#define WBEM_WSYNTAX_UINT64				L"UINT64"
//#define WBEM_WSYNTAX_INTERVAL			L"INTERVAL"
#define WBEM_WSYNTAX_DATETIME			L"DATETIME"
//#define WBEM_WSYNTAX_DATE				L"DATE"
//#define WBEM_WSYNTAX_TIME				L"TIME"
#define WBEM_WSYNTAX_STRING				L"STRING"
//#define WBEM_WSYNTAX_DWORD				L"DWORD"
//#define WBEM_WSYNTAX_ULONG				L"ULONG"
//#define WBEM_WSYNTAX_UINT				L"UINT"
#define WBEM_WSYNTAX_SINT32				L"SINT32"
#define WBEM_WSYNTAX_UINT32				L"UINT32"
//#define WBEM_WSYNTAX_LONG				L"LONG"
//#define WBEM_WSYNTAX_INT					L"INT"
//#define WBEM_WSYNTAX_INTEGER				L"INTEGER"
//#define WBEM_WSYNTAX_INT32				L"INT32"
//#define WBEM_WSYNTAX_WCHAR				L"WCHAR"
//#define WBEM_WSYNTAX_WCHAR_T				L"WCHAR_T"
//#define WBEM_WSYNTAX_INT16				L"INT16"
//#define WBEM_WSYNTAX_SHORT				L"SHORT"
#define WBEM_WSYNTAX_SINT16				L"SINT16"
#define WBEM_WSYNTAX_UINT16				L"UINT16"
//#define WBEM_WSYNTAX_USHORT				L"USHORT"
//#define WBEM_WSYNTAX_WORD				L"WORD"
//#define WBEM_WSYNTAX_CHAR				L"CHAR" 

#define WBEM_WSYNTAX_STRING_LEN			6
#define WBEM_SYNTAX_STRING				"STRING"

#define WBEM_VARIANT_VT_I1				1
#define WBEM_VARIANT_VT_UI1				2
#define WBEM_VARIANT_VT_BSTR			3
#define WBEM_VARIANT_VT_I4				4
#define WBEM_VARIANT_VT_UI4				5
#define WBEM_VARIANT_VT_I2				6
#define WBEM_VARIANT_VT_UI2				7
#define WBEM_VARIANT_VT_R4				8
#define WBEM_VARIANT_VT_R8				9
#define WBEM_VARIANT_VT_I8				10
#define WBEM_VARIANT_VT_UI8				11
#define WBEM_VARIANT_VT_BOOL			12
#define WBEM_VARIANT_VT_ARRAY_I1		13
#define WBEM_VARIANT_VT_ARRAY_UI1		14
#define WBEM_VARIANT_VT_ARRAY_BSTR		15
#define WBEM_VARIANT_VT_ARRAY_I4		16
#define WBEM_VARIANT_VT_ARRAY_UI4		17
#define WBEM_VARIANT_VT_ARRAY_I2		18
#define WBEM_VARIANT_VT_ARRAY_UI2		19
#define WBEM_VARIANT_VT_ARRAY_R4		20
#define WBEM_VARIANT_VT_ARRAY_R8		21
#define WBEM_VARIANT_VT_ARRAY_I8		22
#define WBEM_VARIANT_VT_ARRAY_UI8		23
#define WBEM_VARIANT_VT_ARRAY_BOOL		24

#define WBEM_DSDT_UNKNOWN			0
#define WBEM_DSDT_SINT8				1
#define	WBEM_DSDT_UINT8				2
#define	WBEM_DSDT_SINT64				3
#define	WBEM_DSDT_UINT64				4
//#define	WBEM_DSDT_INTERVAL			5
#define	WBEM_DSDT_TIMESTAMP			6
//#define	WBEM_DSDT_DATE				7
//#define	WBEM_DSDT_TIME				8
#define	WBEM_DSDT_SMALL_STRING		9
#define	WBEM_DSDT_STRING				10
#define	WBEM_DSDT_UINT32				11
#define	WBEM_DSDT_SINT32				12
#define	WBEM_DSDT_SINT16				13
#define	WBEM_DSDT_UINT16				14
#define	WBEM_DSDT_REAL				15
#define	WBEM_DSDT_DOUBLE				16
#define	WBEM_DSDT_BIT				17
#define	WBEM_DSDT_SINT8_ARRAY		18
#define	WBEM_DSDT_UINT8_ARRAY		19
#define	WBEM_DSDT_UINT32_ARRAY		20
#define	WBEM_DSDT_SINT32_ARRAY		21
#define	WBEM_DSDT_BOOL_ARRAY			22
#define	WBEM_DSDT_SINT16_ARRAY		23
#define	WBEM_DSDT_UINT16_ARRAY		24
#define	WBEM_DSDT_REAL_ARRAY			25
#define	WBEM_DSDT_DOUBLE_ARRAY		26
#define	WBEM_DSDT_SINT64_ARRAY		27
#define	WBEM_DSDT_UINT64_ARRAY		28
#define	WBEM_DSDT_STRING_ARRAY		29
//#define	WBEM_DSDT_INTERVAL_ARRAY		30
#define	WBEM_DSDT_TIMESTAMP_ARRAY	31
//#define	WBEM_DSDT_DATE_ARRAY			32
//#define	WBEM_DSDT_TIME_ARRAY			33
#define	WBEM_DSDT_SMALL_STRING_ARRAY		34


BSTR			gpPrincipal = NULL;


BOOL g_DebugTracingSwitchedOn = FALSE; //global variable

void __DuhDoSomething(LPCTSTR myStr,...)
{
	if (g_DebugTracingSwitchedOn)
	{
		OutputDebugString(myStr);

		//Write data to file
/*
		FILE* hfile = fopen("wbemdr32.log", "a");

		if (hfile)
		{
			fwrite(myStr, _mbstrlen(myStr) + 1, _mbstrlen(myStr) + 1, hfile);
			fclose(hfile);
		}
*/
	}
}



//used to create and manage worker thread
CWorkerThreadManager glob_myWorkerThread;



BOOL IsW2KOrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}


HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel)
{
	ODBCTRACE("\nWBEM ODBC Driver : WbemSetDynamicCloaking\n");

    HRESULT hres;

    if(!IsW2KOrMore())
    {
        // Not NT5 --- don't bother
        // ========================
		ODBCTRACE("\nWBEM ODBC Driver : WbemSetDynamicCloaking : Not NT5 --- don't bother\n");
        return WBEM_S_FALSE;
    }

    // Try to get IClientSecurity from it
    // ==================================

    IClientSecurity* pSec;
    hres = pProxy->QueryInterface(IID_IClientSecurity, (void**)&pSec);
    if(FAILED(hres))
    {
        // Not a proxy --- not a problem
        // =============================
		ODBCTRACE("\nWBEM ODBC Driver : WbemSetDynamicCloaking : Not a proxy --- not a problem\n");
        return WBEM_S_FALSE;
    }

	DWORD dwSize = 1000;
	char buffer[1001];
	buffer[0] = 0;
	if ( GetUserName(buffer, &dwSize) )
	{
		CString lpMessage;
		lpMessage.Format("\nUser Account just before SetBlanket is %ld characters long : %s\n", dwSize, buffer);

		ODBCTRACE(lpMessage);
	}
	else
	{
		ODBCTRACE("\nGetUserName call failed just before SetBlanket\n");
	}

    hres = pSec->SetBlanket(pProxy, 
					RPC_C_AUTHN_DEFAULT,//0xa,//RPC_C_AUTHN_WINNT, 
                    RPC_C_AUTHZ_DEFAULT,//0,//RPC_C_AUTHZ_NONE, 
					NULL, 
					RPC_C_AUTHN_LEVEL_CONNECT,//2,//dwAuthnLevel, 
                    RPC_C_IMP_LEVEL_IMPERSONATE,//3,//dwImpLevel, 
					NULL, 
					EOAC_DYNAMIC_CLOAKING//0x20
					);
    pSec->Release();

	if (SUCCEEDED(hres))
	{
		ODBCTRACE("\nWBEM ODBC Driver : WbemSetDynamicCloaking : SUCCEEDED\n");
	}
	else
	{
		ODBCTRACE("\nWBEM ODBC Driver : WbemSetDynamicCloaking : FAILED\n");
	}

    return hres;
}

HRESULT ISAMSetCloaking1(IUnknown* pProxy, BOOL fIsLocalConnection, BOOL fW2KOrMore, DWORD dwAuthLevel, DWORD dwImpLevel,
				 BSTR authorityBSTR, BSTR userBSTR, BSTR passwdBSTR, COAUTHIDENTITY ** gpAuthIdentity)
{
	HRESULT sc = WBEM_S_FALSE;

	if ( fIsLocalConnection && fW2KOrMore )
	{
		sc = WbemSetDynamicCloaking(pProxy, dwAuthLevel, dwImpLevel);

	}
	else
	{
		sc = SetInterfaceSecurityEx(pProxy, authorityBSTR, userBSTR, passwdBSTR, 
			   dwAuthLevel, dwImpLevel, EOAC_NONE, gpAuthIdentity, &gpPrincipal );
	}

	return sc;
}


HRESULT ISAMSetCloaking2(IUnknown* pProxy, BOOL fIsLocalConnection, BOOL fW2KOrMore, DWORD dwAuthLevel, DWORD dwImpLevel,
				 COAUTHIDENTITY * gpAuthIdentity)
{
	HRESULT sc = WBEM_S_FALSE;

	if ( fIsLocalConnection && fW2KOrMore )
	{
		sc = WbemSetDynamicCloaking(pProxy, dwAuthLevel, dwImpLevel);

	}
	else
	{
		SetInterfaceSecurityEx(pProxy, gpAuthIdentity, gpPrincipal, dwAuthLevel, dwImpLevel);
	}

	return sc;
}

void ISAMCheckWorkingThread_AllocEnv()
{
	ODBCTRACE("\nISAMCheckWorkingThread_AllocEnv\n");

	//Create working thread if necessary
	if (! glob_myWorkerThread.GetThreadHandle() && ! glob_myWorkerThread.IsValid() )
	{
		ODBCTRACE("\nCreateWorkerThread\n");
		glob_myWorkerThread.CreateWorkerThread();
	}
	else
	{
		//increament ref count on working thread
		MyWorkingThreadParams* m_params = new MyWorkingThreadParams(NULL, NULL, 0, NULL);

		//post message to create this object on working thread
		CString sMessage;
		sMessage.Format( "\nCreateWorkerThread : post message to thread %ld\n", glob_myWorkerThread.GetThreadId() );
		ODBCTRACE(sMessage);
		EnterCriticalSection(& (glob_myWorkerThread.m_cs) );
		ResetEvent(m_params->m_EventHnd);
		LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );
		BOOL status = PostThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REFCOUNT_INCR, 0, (LPARAM)m_params);
		WaitForSingleObject(m_params->m_EventHnd, INFINITE);

		ODBCTRACE("\nISAMCheckWorkingThread_AllocEnv : exit\n");

		delete m_params;
	}
}


void ISAMCheckWorkingThread_FreeEnv()
{
	//decrement ref count
	MyWorkingThreadParams* m_params = new MyWorkingThreadParams(NULL, NULL, 0, NULL);

	//post message to create this object on working thread
	EnterCriticalSection(& (glob_myWorkerThread.m_cs) );
	HANDLE EventHnd = m_params->m_EventHnd;
	ResetEvent(EventHnd);
	LeaveCriticalSection(& (glob_myWorkerThread.m_cs) );
	BOOL status = PostThreadMessage(glob_myWorkerThread.GetThreadId(), MYUSRMESS_REFCOUNT_DECR, 0, (LPARAM)m_params);
	WaitForSingleObject(EventHnd, INFINITE);
	delete m_params;

	//if zero shut down thread
	if ( ! glob_myWorkerThread.GetRefCount() )
	{
		ISAMCloseWorkerThread1();

		//invalidate it
		glob_myWorkerThread.Invalidate();
	}
}


void ISAMCheckTracingOption()
{
	//Read the registry setting to determine if you 
	//want to enable tracing and set the global variable accordingly
	
	//by default logging is switched off
	g_DebugTracingSwitchedOn = FALSE;

	HKEY keyHandle = (HKEY)1;
	long fStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		"Software\\Microsoft\\WBEM", 0, KEY_READ, &keyHandle);

	if (fStatus == ERROR_SUCCESS)
	{
		DWORD dwLogging;
		DWORD sizebuff = sizeof(DWORD);
		DWORD typeValue;

		
		fStatus = RegQueryValueEx(keyHandle, "ODBC Logging", NULL,
						&typeValue, (LPBYTE)&dwLogging, &sizebuff);

		if ( (fStatus == ERROR_SUCCESS) && dwLogging )
		{
			//switch on logging if 'ODBC Logging' is set to a non-zero number
			g_DebugTracingSwitchedOn = TRUE;
		}

		RegCloseKey(keyHandle);
	}
}


void INTFUNC ISAMGetSelectStarList(char** lpWQLSelectStarList,      //OUT 
								   TableColumnInfo* pSelectInfo,    //IN 
								   LPISAM lpISAM);

void Utility_GetLocaleIDFromString(IN char* lpValue, OUT DWORD& _dwLocale)
{
	_bstr_t sFullLocaleStr = lpValue;

	if(!_wcsnicmp(sFullLocaleStr, L"MS\\", 3))
	{
		DWORD dwLocale = 0;

		_bstr_t sHexLocaleID = &((wchar_t*)sFullLocaleStr)[3];

		swscanf( sHexLocaleID, L"%x", &dwLocale);

		// Only set if we have a result
		if(dwLocale)
			_dwLocale = dwLocale;
	}
}

UINT Utility_GetCodePageFromLCID(LCID lcid)
{
	char szLocale[12];
	UINT cp;
    int iNumChars = 0;

	iNumChars = GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, szLocale, sizeof(szLocale));
    if (iNumChars)
	{
        szLocale[iNumChars] = '\0';
		cp = strtoul(szLocale, NULL, 10);
		if (cp)
			return cp;
	}
	return GetACP();
}

void Utility_SetThreadLocale(IN char* lpValue, ULPSETTHREADLOCALE pProcSetThreadLocale)
{
	// Default to local system Locale
	DWORD dwLocaleID = GetSystemDefaultLCID();

	if(lpValue && strlen(lpValue))
	{
		//Get the locale id from string
		Utility_GetLocaleIDFromString(lpValue, dwLocaleID);
	}


	

	if (pProcSetThreadLocale)
	{
		//Now set the thread locale
		if((*pProcSetThreadLocale)(dwLocaleID))
		{
			CString myText;
			myText.Format("\nWBEM ODBC Driver : Set ThreadLocaleID OK to: %d\n",dwLocaleID);
			ODBCTRACE(myText);
		}
		else
		{
			(*pProcSetThreadLocale)(GetSystemDefaultLCID());
			CString myText;
			myText.Format("\nWBEM ODBC Driver : Set ThreadLocaleID OK to system default: %d\n",GetSystemDefaultLCID());
			ODBCTRACE(myText);
		}
	}

}

int Utility_WideCharToDBCS(IN _bstr_t& _sWCharData,
							char**   rgbValue, 
							SDWORD  cbValueMax)
{
	DWORD dwDBCSBuffLen =  cbValueMax;

	UINT cpThread = Utility_GetCodePageFromLCID(GetThreadLocale());

	// Tried WC_COMPOSITECHECK, didn't seem to work on Japanese machine
	int dwDBCSLen = WideCharToMultiByte(cpThread,WC_COMPOSITECHECK, (const wchar_t*)_sWCharData, -1, 
								*rgbValue, cbValueMax, NULL, NULL);

	//The return length included the NULL terminator
	//so we need to remove this
	if (dwDBCSLen)
		--dwDBCSLen;

	return dwDBCSLen;
}

void Utility_DBCSToWideChar(IN const char* _dbcsData,
								OUT wchar_t** _sOutData, SWORD cbLen)
{
	DWORD dwDbcsLen = cbLen ? (cbLen+1) : (_mbstrlen(_dbcsData)+1);

	// alloca is much faster (see TN059)
	*_sOutData = new wchar_t [dwDbcsLen + 1];
	*_sOutData[0] = 0;

	
	UINT cpThread = Utility_GetCodePageFromLCID(GetThreadLocale());

	// tried MB_COMPOSITE didn't work on German machine
	int dwNumWideChars = MultiByteToWideChar(cpThread, MB_PRECOMPOSED, _dbcsData, 
									cbLen ? dwDbcsLen : -1,
									*_sOutData,dwDbcsLen);

	if (!dwNumWideChars)
	{
		*_sOutData[0] = 0;
	}
	else
	{
		if (cbLen)
			(*_sOutData)[cbLen] = 0;
	}
}

class ThreadLocaleIdManager
{
private:
	LCID m_lcid;
	HINSTANCE	hKernelApi;
	ULPSETTHREADLOCALE pProcSetThreadLocale;
public :
	ThreadLocaleIdManager(IN LPISAM lpISAM);
	ThreadLocaleIdManager(LPUSTR lpLocale);
	~ThreadLocaleIdManager();
};

ThreadLocaleIdManager::ThreadLocaleIdManager(IN LPISAM lpISAM)
{
	hKernelApi = NULL;
	//Save current thread locale id
	m_lcid = GetThreadLocale();

	pProcSetThreadLocale = NULL;
	if (lpISAM->hKernelApi)
	{
		pProcSetThreadLocale = (ULPSETTHREADLOCALE) GetProcAddress(lpISAM->hKernelApi, "SetThreadLocale");
	}

	//Change thread locale id
	Utility_SetThreadLocale(lpISAM->m_Locale, pProcSetThreadLocale);
}

ThreadLocaleIdManager::ThreadLocaleIdManager(LPUSTR lpLocale)
{
	hKernelApi =  LoadLibrary("KERNEL32.DLL");

	m_lcid = GetThreadLocale();

	pProcSetThreadLocale = NULL;
	if (hKernelApi)
	{
		pProcSetThreadLocale = (ULPSETTHREADLOCALE) GetProcAddress(hKernelApi, "SetThreadLocale");
	}

	//Change thread locale id
	Utility_SetThreadLocale((char*)lpLocale, pProcSetThreadLocale);
}

ThreadLocaleIdManager::~ThreadLocaleIdManager()
{
	//Restore thread locale id on destruction
	if (pProcSetThreadLocale)
	{
		(*pProcSetThreadLocale)(m_lcid);
	}

	if (hKernelApi)
	{
		BOOL status = FreeLibrary(hKernelApi);

		if (! status)
		{
			DWORD err = GetLastError();
			CString message ("\n\n***** FreeLibrary KERNEL32 failed : %ld*****\n\n", err);
			ODBCTRACE(message);
		}
	}
}

void ISAMStringConcat(char** resultString, char* myStr)
{
	if (myStr)
	{
		ULONG len = s_lstrlen(myStr);

		ULONG oldLen = 0;
		
		if (resultString && *resultString)
			oldLen = s_lstrlen(*resultString);

		char* buffer = new char [oldLen + len + 1];
		buffer[0] = 0;

		if (oldLen)
		{
			sprintf (buffer, "%s%s", *resultString, myStr);
		}
		else
		{
			s_lstrcpy(buffer, myStr);
		}

		//delete old string
		if (resultString && *resultString)
			delete (*resultString);

		//replace with new string
		*resultString = buffer;
	}
}

ImpersonationManager::ImpersonationManager(char* org_szUser, char* org_szPassword, char* org_szAuthority)
{
	ODBCTRACE(_T("\nWBEM ODBC Driver : ImpersonationManager constructor\n"));

	hToken = NULL;
	hAdvApi = NULL;
//	hKernelApi = NULL;
	pProcLogonUser = NULL;
	pProcImpersonateLoggedOnUser = NULL;
	pProcRevertToSelf = NULL;
	fImpersonatingNow = FALSE;


	//We need to do a LoadLibrary
	//as the inpersonation struff is not avaiable on
	//Windows 95 and Win32s
	fImpersonate = DoInitialChecks();

	if ( CanWeImpersonate() )
	{
		//Extract logon info 
		ExtractLogonInfo(org_szUser, org_szPassword, org_szAuthority);
	}
}

void ImpersonationManager::ExtractLogonInfo(char* org_szUser, char* szPassword, char* szAuthority)
{
	//The user name could be the domain and user id
	//Make a copy of the username
	szUser[0] = 0;
	if (org_szUser && strlen(org_szUser))
		strncpy(szUser, org_szUser, MAX_USER_NAME_LENGTH);
	szUser[MAX_USER_NAME_LENGTH] = 0;

	//Find backslash character
	char* lpDomain = NULL;
	char* lpUser = szUser;

	int ch = '\\';
	char* backslashPtr = strchr(szUser, ch);

	if (backslashPtr)
	{
		//Found backslash, therefore username
		//is domain<blackslash>userid
		lpDomain = szUser;
		lpUser = backslashPtr + 1;
		*backslashPtr = 0; //NULL the backslash so we get two strings
	}
	else
	{
		//no domain in user name
		//so set domain to authority value
		lpDomain = szAuthority;
	}

	//Call LogonUser via pointer to function	
	BOOL status = (*pProcLogonUser)( lpUser, 
					 lpDomain,
					 szPassword,
					 LOGON32_LOGON_INTERACTIVE,
					 LOGON32_PROVIDER_DEFAULT,
					 &hToken
					);

	if (!status)
	{
		status = (*pProcLogonUser)( lpUser, 
					 lpDomain,
					 szPassword,
					 LOGON32_LOGON_BATCH,
					 LOGON32_PROVIDER_DEFAULT,
					 &hToken
					);
	}

	if (status)
	{
		ODBCTRACE(_T("\nWBEM ODBC Driver : LogonUser call SUCCEEDED, now impersonating user "));
		ODBCTRACE(_T(lpUser));

		if (lpDomain && strlen(lpDomain))
		{
			ODBCTRACE(_T(" on domain "));
			ODBCTRACE(_T(lpDomain));
		}
		ODBCTRACE(_T("\n"));

		Impersonate();
	}
	else
	{
		ODBCTRACE(_T("\nWBEM ODBC Driver : LogonUser call failed, not doing impersonation for user "));
		ODBCTRACE(_T(lpUser));

		if (lpDomain && strlen(lpDomain))
		{
			ODBCTRACE(_T(" on domain "));
			ODBCTRACE(_T(lpDomain));
		}
		ODBCTRACE(_T("\n"));
		CString lastErr;
		lastErr.Format ("Last Error = %ld \n", GetLastError() );
		ODBCTRACE (lastErr);

		hToken = NULL;
		fImpersonate = FALSE;
	}
}

BOOL ImpersonationManager::DoInitialChecks()
{
	BOOL fError = FALSE;

	//Retieve pointer to functions you want to call
	// (only on Windows NT)
	hAdvApi =  LoadLibrary("ADVAPI32.DLL");
//	hKernelApi =  LoadLibrary("KERNEL32.DLL");

//	if (hAdvApi && hKernelApi)
	if (hAdvApi)
	{
		//LogonUser
		pProcLogonUser = (ULPLOGONUSER) GetProcAddress(hAdvApi, "LogonUserA");

		//ImpersonateLoggedOnUser
		pProcImpersonateLoggedOnUser = (ULPIMPERSONLOGGEDONUSER) GetProcAddress(hAdvApi, "ImpersonateLoggedOnUser");

		//RevertToSelf
		pProcRevertToSelf = (ULPREVERTTOSELF) GetProcAddress(hAdvApi, "RevertToSelf");

		//Check that you have valid pointers to all of these functions
		if ( (!pProcLogonUser) || (!pProcImpersonateLoggedOnUser) || (!pProcRevertToSelf) )
		{
			fError = TRUE;
		}
	}
	else
	{
		fError = TRUE;
		hAdvApi = NULL;
	}
	
	if (fError)
	{
		//Can't load libaries so fail
		ODBCTRACE(_T("\nWBEM ODBC Driver : Impersonation libraries/function failier !!!\n"));
		if (hAdvApi)
		{
			FreeLibrary(hAdvApi);
			hAdvApi = NULL;
		}

//		if (hKernelApi)
//		{
//			FreeLibrary(hKernelApi);
//			hKernelApi = NULL;
//		}
	}
	else
	{
		//success
		ODBCTRACE(_T("\nWBEM ODBC Driver : We can do impersonation !!!\n"));
		return TRUE;
	}


	//Default is failure to impersonate
	return FALSE;
}

ImpersonationManager::~ImpersonationManager()
{
	ODBCTRACE(_T("\nWBEM ODBC Driver : ImpersonationManager DESTRUCTOR\n"));

	//If you are doing a SQLDisconnect this class will
	//be deleted by something like ISAMClose
	//Revert back to original user at this point
	//as it won't be done in destructor of MyImpersonator
	RevertToYourself();

	if (hAdvApi)
	{
		ODBCTRACE(_T("\nWBEM ODBC Driver : FreeLibrary(hAdvApi)\n"));
		FreeLibrary(hAdvApi);
	}

//	if (hKernelApi)
//	{
//		FreeLibrary(hKernelApi);
//	}

	if (hToken)
	{
		ODBCTRACE(_T("\nWBEM ODBC Driver : CloseHandle(hToken)\n"));
		CloseHandle(hToken);
	}

}

void ImpersonationManager::Impersonate(char* str)
{
	if (fImpersonatingNow)
	{
		ODBCTRACE("\nWBEM ODBC Driver : ImpersonationManager::Impersonate - already impersonating\n");
	}

	//Call ImpersonateLoggedOnUser via pointer to function
	if ( CanWeImpersonate() && hToken && !fImpersonatingNow )
	{
		BOOL status = (*pProcImpersonateLoggedOnUser)( hToken );

		CString myText(_T("\nWBEM ODBC Driver : "));

		//Name of function
		if (str)
		{
			myText += str;
			myText += _T(" : ");
		}
		
		myText += _T("Impersonating the logged on user ");

		//User account you are impersonating
		if (szUser)
		{
			myText += _T("[");
			myText += _T(szUser);
			myText += _T("]");
		}

		if (status)
		{
			myText += _T("\n");
		}
		else
		{
			myText += _T(" FAILED\n");
		}

		ODBCTRACE(myText);

		if (status)
			fImpersonatingNow = TRUE;
	}
}

void ImpersonationManager::RevertToYourself(char* str)
{
	//If impersonation is taking place 
	//revert to original user

	//Call RevertToSelf via pointer to function
	if ( CanWeImpersonate() && fImpersonatingNow )
	{
		(*pProcRevertToSelf)();
		fImpersonatingNow = FALSE;

		CString myText(_T("\nWBEM ODBC Driver : "));
		if (str)
		{
			myText += _T(str);
			myText += _T(" : ");
		}
		myText += _T("Reverting To Self\n");

		ODBCTRACE(myText);
	}
}

/***********************************************/
MyImpersonator::MyImpersonator(LPDBC myHandle, char* str)
{
	hdl = myHandle;
	hstmt = NULL;
	lpISAM = NULL;
	lpImpersonator = NULL;
	displayStr = str;

	if (hdl->lpISAM && hdl->lpISAM->Impersonate)
	{
		hdl->lpISAM->Impersonate->Impersonate(displayStr);
	}
}

MyImpersonator::MyImpersonator(LPSTMT myHandle, char* str)
{
	hdl = NULL;
	lpISAM = NULL;
	hstmt = myHandle;
	displayStr = str;
	lpImpersonator = NULL;

	if (hstmt->lpdbc && hstmt->lpdbc->lpISAM && hstmt->lpdbc->lpISAM->Impersonate)
	{
		hstmt->lpdbc->lpISAM->Impersonate->Impersonate(displayStr);
	}
}

MyImpersonator::MyImpersonator(LPISAM myHandle, char* str)
{
	hdl = NULL;
	hstmt = NULL;
	lpISAM = myHandle;
	displayStr = str;
	lpImpersonator = NULL;

	if ( !lpISAM )
		ODBCTRACE("\nWBEM ODBC Driver : lpISAM is NULL\n");

	if (lpISAM && lpISAM->Impersonate)
	{
		BOOL copyOfFlag = lpISAM->Impersonate->fImpersonatingNow;
		lpISAM->Impersonate->fImpersonatingNow = FALSE;
		lpISAM->Impersonate->Impersonate(displayStr);
		lpISAM->Impersonate->fImpersonatingNow = copyOfFlag;
	}
	else
	{
		ODBCTRACE("\nWBEM ODBC Driver : lpISAM->Impersonate is NULL\n");
	}
}


MyImpersonator::MyImpersonator(char* szUser, char* szPassword, char* szAuthority, char* str)
{
	hdl = NULL;
	hstmt = NULL;
	lpISAM = NULL;
	displayStr = str;
	lpImpersonator = new ImpersonationManager(szUser, szPassword, szAuthority);
	lpImpersonator->Impersonate(displayStr);
}

MyImpersonator::~MyImpersonator()
{
	if (hdl)
	{
		if (hdl->lpISAM && hdl->lpISAM->Impersonate)
		{
			hdl->lpISAM->Impersonate->RevertToYourself(displayStr);
		}
	}
	else if (hstmt)
	{
		if (hstmt->lpdbc && hstmt->lpdbc->lpISAM && hstmt->lpdbc->lpISAM->Impersonate)
		{
			hstmt->lpdbc->lpISAM->Impersonate->RevertToYourself(displayStr);
		}
	}
	else if (lpISAM)
	{
		if (lpISAM->Impersonate)
		{
			BOOL copyOfFlag = lpISAM->Impersonate->fImpersonatingNow;
			lpISAM->Impersonate->fImpersonatingNow = TRUE;
			lpISAM->Impersonate->RevertToYourself(displayStr);
			lpISAM->Impersonate->fImpersonatingNow = copyOfFlag;
		}
	}
	else if (lpImpersonator)
	{
		//deleting will call RevertToYourself
		delete lpImpersonator;
	}
}


CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
	m_temp = NULL;
}

CBString::CBString(WCHAR* pwszString, BOOL fInterpretAsBlank)
{
	m_temp = NULL;
	m_pString = NULL;
	if (pwszString)
	{
		if ( wcslen(pwszString) )
		{
			m_pString = SysAllocString(pwszString);
		}
		else
		{
			//OK, we have a string of zero length
			//check if we interpret this as blank or NULL
			if (fInterpretAsBlank)
			{
				m_temp = new wchar_t[1];
				m_temp[0] = 0;
				m_pString = SysAllocString(m_temp);
			}
		}
	}
}

CBString::~CBString()
{
	delete m_temp;

    if(m_pString) {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}


/***************************************************************************/

/* Formats string parameter for output in square braces  */

SWORD INTFUNC ISAMFormatCharParm (char* theValue, BOOL &fOutOfBufferSpace,
			char* rgbValue, SDWORD cbValueMax, SDWORD FAR* pcbValue,
			BOOL fIsBinaryOutput, SDWORD fInt64Check = 0, BOOL fAllElements = TRUE)
{
	//Now we must add in string value in the format [string]
	//However, if the string contains either [ or ] we must double
	//this character in the string sequence
	fOutOfBufferSpace = FALSE;

	//First store a reference to length of current string
	//in case we run out of buffer space when adding this string
	SDWORD pcbOldValue = (*pcbValue);

	//Do we need to show surrounding braces
	//Not for binary output or if we only want to 
	//show one instance
	BOOL fSurroundingBraces = TRUE;

	if (fIsBinaryOutput)
		fSurroundingBraces = FALSE;

	if (!fAllElements)
		fSurroundingBraces = FALSE;

	//Add leading [ character (not for binary)
	if (fSurroundingBraces)
	{
		if ((1 + (*pcbValue)) <= cbValueMax)
		{
			rgbValue[(*pcbValue)] = '[';
			(*pcbValue) += 1;
		}
		else
		{
			fOutOfBufferSpace = TRUE;
		}
	}

	//Add each character in string checking for [ or ] (not for binary)
	ULONG cLengthOfElementString = 0;

	if (theValue)
		cLengthOfElementString = lstrlen(theValue);

	if (!fOutOfBufferSpace && cLengthOfElementString)
	{	
		//Copy each character
		ULONG cIndex = 0;
		while ( (!fOutOfBufferSpace) && theValue[cIndex] )
		{
			//How much buffer space do we have left
			SDWORD cbSpaceLeft = cbValueMax  - (*pcbValue);

			//???We need to add the character(s) and a NULL terminator
//			if ( (fSurroundingBraces) && ((theValue[cIndex] == '[') || (theValue[cIndex] == ']')) 
//							&& (cbSpaceLeft >= 2) )
			if ( (fSurroundingBraces) && ((theValue[cIndex] == '[') || (theValue[cIndex] == ']')) )
			{
//				if (cbSpaceLeft >= 3)
				if (cbSpaceLeft >= 2)
				{
					//Add the character in TWICE
					rgbValue[(*pcbValue)] = theValue[cIndex];
					rgbValue[(*pcbValue) + 1] = theValue[cIndex];
					//rgbValue[(*pcbValue) + 2] = 0;
					(*pcbValue) += 2;
				}
				else
				{
					fOutOfBufferSpace = TRUE;
				}
			}
			else
			{
//				if (cbSpaceLeft >= 2)
				if (cbSpaceLeft)
				{
					//Add the character in ONCE
					rgbValue[(*pcbValue)] = theValue[cIndex];
					//rgbValue[(*pcbValue) + 1] = 0;
					(*pcbValue) += 1;
				}
				else
				{
					fOutOfBufferSpace = TRUE;
				}
			}

			//Extra check if this is a 64 bit integer
			if (fInt64Check == WBEM_DSDT_SINT64)
			{
				switch (theValue[cIndex])
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case '+':
				case '-':
					//OK
					break;
				default:
				{
					*pcbValue = 0;
					return ERR_INVALID_INTEGER;
				}
					break;
				}
			}

			if (fInt64Check == WBEM_DSDT_UINT64)
			{
				switch (theValue[cIndex])
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					//OK
					break;
				default:
				{
					*pcbValue = 0;
					return ERR_INVALID_INTEGER;
				}
					break;
				}
			}

			cIndex++;
		}
	}

	//Add trailing ] character (not for binary)
	if (fSurroundingBraces)
	{
		if ((!fOutOfBufferSpace) && ((1 + (*pcbValue)) <= cbValueMax))
		{
			rgbValue[(*pcbValue)] = ']';
			(*pcbValue) += 1;
		}
		else
		{
			fOutOfBufferSpace = TRUE;
		}
	}

	//If you run out of buffer space indicate to truncate
	if (fOutOfBufferSpace)
	{
		(*pcbValue) = pcbOldValue;
		return ISAM_TRUNCATION;
	}

	return NO_ISAM_ERR;
}

/***************************************************************************/

/* This static function attempts to extract the precision from a property SYNTAX/CIMTYPE string */
/* The SYNTAX/CIMTYPE string will be in the format:                                             */
/*						name(precision)    [   e.g. STRING(10)   ]                              */
/* The value of 'name' is input as the 1st parameter to this function                           */
/* The 2nd parameter to this function is the whole SYNTAX/CIMTYPE string                        */
/* The return value is the precision extracted                                                  */
/* If an error occurs 0 is returned                                                             */

static LONG GetPrecisionFromSyntaxStr(char* lpHeaderStr, char* lpString)
{
	//Check for a valid input strings
	if (!lpHeaderStr || !lpString)
		return 0;

	//Check lengths of strings
	LONG cHeaderLen = lstrlen(lpHeaderStr);
	LONG cStrLen = lstrlen(lpString);

	if ( !cHeaderLen || !cStrLen || (cStrLen < cHeaderLen) )
		return 0;

	//Set position to expected '('
	char* pSearchPos = lpString + cHeaderLen;
	char* pNumStart = NULL;

	//skip leading white space
	while (*pSearchPos && (*pSearchPos == ' '))
	{
		pSearchPos += 1;
	}

	if (*pSearchPos != '(')
	{
		return 0;
	}
	else
	{
		//OK, matched the first '(', now continue searching
		//until you reach the end of the string or the ')'
		pSearchPos += 1;
		pNumStart = pSearchPos;
		while ( *pSearchPos != ')' )
		{
			//Check if we have reached end of string before
			//finding the ')'. If so return 0
			if (*pSearchPos == 0)
				return 0;
			else
				pSearchPos += 1;
		}

		*pSearchPos = 0;

	}
	return atoi (pNumStart);
}

/***************************************************************************/

BOOL INTFUNC ISAMGetWbemVariantType(LONG pType, SWORD& wTheVariantType)
{
	BOOL fValidType = TRUE;

	switch ( pType )
	{
	case CIM_SINT8: //was VT_I1:
		{
			wTheVariantType = WBEM_VARIANT_VT_I1;
		}
		break;
	case CIM_UINT8: //was VT_UI1:
		{
			wTheVariantType = WBEM_VARIANT_VT_UI1;
		}
		break;
	case CIM_SINT16: //was VT_I2:
		{
			wTheVariantType = WBEM_VARIANT_VT_I2;
		}
		break;
	case CIM_UINT16: //was VT_UI2:
		{
			wTheVariantType = WBEM_VARIANT_VT_UI2;
		}
		break;
	case CIM_REAL32: //was VT_R4:
		{
			wTheVariantType = WBEM_VARIANT_VT_R4;
		}
		break;
	case CIM_REAL64: //was VT_R8:
		{
			wTheVariantType = WBEM_VARIANT_VT_R8;
		}
		break;
	case CIM_BOOLEAN: //was VT_BOOL:
		{
			wTheVariantType = WBEM_VARIANT_VT_BOOL;
		}
		break;
	case CIM_SINT32: //was VT_I4:
		{
			wTheVariantType = WBEM_VARIANT_VT_I4;
		}
		break;
	case CIM_UINT32: //was VT_UI4:
		{
			wTheVariantType = WBEM_VARIANT_VT_UI4;
		}
		break;
	case CIM_SINT64: //was VT_I8:
		{
			wTheVariantType = WBEM_VARIANT_VT_I8;
		}
		break;
	case CIM_UINT64: //was VT_UI8:
		{
			wTheVariantType = WBEM_VARIANT_VT_UI8;
		}
		break;
	case CIM_REFERENCE:
	case CIM_STRING: //was VT_BSTR
	case CIM_DATETIME:
		{
			wTheVariantType = WBEM_VARIANT_VT_BSTR;
		}
		break;
	default:
		{
			//Check if it is a CIM_FLAG_ARRAY type
			
			if (pType == (CIM_FLAG_ARRAY | CIM_SINT8))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_I1;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_UINT8))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_UI1;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_SINT32))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_I4;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_UINT32))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_UI4;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_SINT16))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_I2;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_UINT16))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_UI2;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_SINT64))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_I8;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_UINT64))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_UI8;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_REAL32))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_R4;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_REAL64))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_R8;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_BOOLEAN))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_BOOL;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_STRING))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_BSTR;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_REFERENCE))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_BSTR;
			}
			else if (pType == (CIM_FLAG_ARRAY | CIM_DATETIME))
			{
				wTheVariantType = WBEM_VARIANT_VT_ARRAY_BSTR;
			}
			else
			{
				//unknown type
				fValidType = FALSE;
			}
		}
		break;
	}

	return fValidType;
}

/***************************************************************************/

BOOL INTFUNC ISAMGetDataSourceDependantTypeInfo(SWORD wVariantType, BSTR syntaxStr, SDWORD maxLenVal, SWORD& wDSDT, SWORD& fSqlType, UDWORD& cbPrecision)
{
	//Initialize
	BOOL fValidType = TRUE;
	wDSDT = WBEM_DSDT_UNKNOWN;

	switch (wVariantType)
	{
	case WBEM_VARIANT_VT_I1:
	{
		fSqlType = SQL_TINYINT;
		cbPrecision = UTINYINT_PRECISION;
		wDSDT = WBEM_DSDT_SINT8;
	}
		break;
	case WBEM_VARIANT_VT_UI1:
	{
		fSqlType = SQL_TINYINT;
		cbPrecision = UTINYINT_PRECISION;
		wDSDT = WBEM_DSDT_UINT8;
	}
		break;
	case WBEM_VARIANT_VT_I2:
	{
		wDSDT = WBEM_DSDT_SINT16;
		fSqlType = SQL_SMALLINT;
		cbPrecision = SMALLINT_PRECISION;
	}
		break;
	case WBEM_VARIANT_VT_UI2:
	{
		wDSDT = WBEM_DSDT_UINT16;
		fSqlType = SQL_SMALLINT;
		cbPrecision = SMALLINT_PRECISION;
	}
		break;
	case WBEM_VARIANT_VT_I4:
	{
		wDSDT = WBEM_DSDT_SINT32;
		fSqlType = SQL_INTEGER;
		cbPrecision = ULONG_PRECISION;
	}
		break;
	case WBEM_VARIANT_VT_UI4:
	{
		wDSDT = WBEM_DSDT_UINT32;
		fSqlType = SQL_INTEGER;
		cbPrecision = ULONG_PRECISION;
	}
		break;
	case WBEM_VARIANT_VT_I8:
	{
		fSqlType = SQL_BIGINT;
		cbPrecision = 19;
		wDSDT = WBEM_DSDT_SINT64;
	}
		break;
	case WBEM_VARIANT_VT_UI8:
	{
		fSqlType = SQL_BIGINT;
		cbPrecision = 20;
		wDSDT = WBEM_DSDT_UINT64;
	}
		break;
	case WBEM_VARIANT_VT_BSTR:
	{
		if (syntaxStr)
		{
			if (_wcsnicmp(WBEM_WSYNTAX_STRING, syntaxStr, WBEM_WSYNTAX_STRING_LEN) ==0)
			{
				LONG cbThePrecision = 254;

				//The precision of a string could optionally be stored in
				//the MAXLEN qualifier, let us try and get it
				if (maxLenVal > 0)
				{
					cbThePrecision = maxLenVal;

					//Double check for *bad* MAXLEN values
					if (cbThePrecision == 0)
					{
						cbThePrecision = 254;
					}
				}
				
				
				if (cbThePrecision > 254)
				{
					fSqlType = SQL_LONGVARCHAR;
					//Got precision, so use it
					cbPrecision = (cbThePrecision > (long)ISAM_MAX_LONGVARCHAR) ? ISAM_MAX_LONGVARCHAR : cbThePrecision;

					wDSDT = WBEM_DSDT_STRING;
				}
				else
				{
					fSqlType = SQL_VARCHAR;
					
					if (cbThePrecision)
					{
						//Got precision, so use it
						cbPrecision = cbThePrecision;
					}
					else
					{
						//Could not get precision so use default
						cbPrecision = 254;
					}

					wDSDT = WBEM_DSDT_SMALL_STRING;
				}
			}
			else if(_wcsicmp(WBEM_WSYNTAX_DATETIME, syntaxStr) == 0)
			{
				fSqlType = SQL_TIMESTAMP;
#if TIMESTAMP_SCALE
				cbPrecision = 20 + TIMESTAMP_SCALE;
#else
				cbPrecision = 19;
#endif

				wDSDT = WBEM_DSDT_TIMESTAMP;
			}
			else
			{
				//No match, default to SMALL_STRING
				fSqlType = SQL_VARCHAR;
				cbPrecision = 254;
				wDSDT = WBEM_DSDT_SMALL_STRING;
			}

		}
		else
		{
			//No Syntax string, default to SMALL_STRING
			fSqlType = SQL_VARCHAR;
			cbPrecision = 254;
			wDSDT = WBEM_DSDT_SMALL_STRING;
		}
	}
		break;
	case WBEM_VARIANT_VT_R4:
	{
		fSqlType = SQL_DOUBLE;
		cbPrecision = REAL_PRECISION;
		wDSDT = WBEM_DSDT_REAL;
	}
		break;
	case WBEM_VARIANT_VT_R8:
	{
		fSqlType = SQL_DOUBLE;
		cbPrecision = DOUBLE_PRECISION;
		wDSDT = WBEM_DSDT_DOUBLE; //WBEM_DSDT_REAL;
	}
		break;
	case WBEM_VARIANT_VT_BOOL:
	{
		fSqlType = SQL_BIT;
		cbPrecision = BOOL_PRECISION;
		wDSDT = WBEM_DSDT_BIT; //WBEM_DSDT_REAL;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_I1:
	{
		fSqlType = SQL_TINYINT;//SQL_LONGVARBINARY;
		cbPrecision = 3;//ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_SINT8_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_UI1:
	{
		fSqlType = SQL_TINYINT; //SQL_LONGVARBINARY;
		cbPrecision = 3; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_UINT8_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_I2:
	{
		fSqlType = SQL_SMALLINT; //SQL_LONGVARBINARY;
		cbPrecision = 5; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_SINT16_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_UI2:
	{
		fSqlType = SQL_SMALLINT; //SQL_LONGVARBINARY;
		cbPrecision = SMALLINT_PRECISION; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_UINT16_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_I4:
	{
		fSqlType = SQL_INTEGER; //SQL_LONGVARBINARY;
		cbPrecision = 10; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_SINT32_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_UI4:
	{
		fSqlType = SQL_INTEGER; //SQL_LONGVARBINARY;
		cbPrecision = 10; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_UINT32_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_I8:
	{
		fSqlType = SQL_BIGINT; //SQL_LONGVARBINARY;
		cbPrecision = 19; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_SINT64_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_UI8:
	{
		fSqlType = SQL_BIGINT; //SQL_LONGVARBINARY;
		cbPrecision = 20; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_UINT64_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_BOOL:
	{
		fSqlType = SQL_BIT; //SQL_LONGVARBINARY;
		cbPrecision = BOOL_PRECISION; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_BOOL_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_R4:
	{
		fSqlType = SQL_DOUBLE; //SQL_LONGVARBINARY;
		cbPrecision = REAL_PRECISION; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_REAL_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_R8:
	{
		fSqlType = SQL_DOUBLE; //SQL_LONGVARBINARY;
		cbPrecision = 15; //ISAM_MAX_LONGVARCHAR;
		wDSDT = WBEM_DSDT_DOUBLE_ARRAY;
	}
		break;
	case WBEM_VARIANT_VT_ARRAY_BSTR:
	{
		fSqlType = SQL_VARCHAR; //SQL_LONGVARCHAR; //SQL_LONGVARBINARY;
		cbPrecision = 254; //ISAM_MAX_LONGVARCHAR;
		
		if (syntaxStr)
		{
			
			if (_wcsnicmp(WBEM_WSYNTAX_STRING, syntaxStr, WBEM_WSYNTAX_STRING_LEN) ==0)
			{
				LONG cbThePrecision = 254;

				//The precision of a string could optionally be stored in
				//the MAXLEN qualifier, let us try and get it
				if (maxLenVal > 0)
				{
					cbThePrecision = maxLenVal;

					//Double check for *bad* MAXLEN values
					if (cbThePrecision == 0)
					{
						cbThePrecision = 254;
					}
				}
				
				
				if (cbThePrecision > 254)
				{
					fSqlType = SQL_LONGVARCHAR;
					//Got precision, so use it
					cbPrecision = (cbThePrecision > (long)ISAM_MAX_LONGVARCHAR) ? ISAM_MAX_LONGVARCHAR : cbThePrecision;

					wDSDT = WBEM_DSDT_STRING_ARRAY;
				}
				else
				{
					fSqlType = SQL_VARCHAR;
					
					if (cbThePrecision)
					{
						//Got precision, so use it
						cbPrecision = cbThePrecision;
					}
					else
					{
						//Could not get precision so use default
						cbPrecision = 254;
					}

					wDSDT = WBEM_DSDT_SMALL_STRING_ARRAY;
				}
			}
			else if (_wcsicmp(WBEM_WSYNTAX_DATETIME, syntaxStr) == 0)
			{
				wDSDT = WBEM_DSDT_TIMESTAMP_ARRAY;

				fSqlType = SQL_TIMESTAMP;
#if TIMESTAMP_SCALE
				cbPrecision = 20 + TIMESTAMP_SCALE;
#else
				cbPrecision = 19;
#endif
			}
			else
			{
				//No match, default to SMALL STRING array
				wDSDT = WBEM_DSDT_SMALL_STRING_ARRAY;
			}
		}
		else
		{
			//No Syntax String, default to SMALL STRING array
			wDSDT = WBEM_DSDT_SMALL_STRING_ARRAY;
		}
	}
		break;
	default:
		fValidType = FALSE;
		break;
	}

	//Return indication if this is a valid type
	return fValidType;
}

/***************************************************************************/

/* Returns Data-Source Dependent type name in pre-allocated buffer */

void INTFUNC ISAMGetDataSourceDependantTypeStr(SWORD wDSDT, char* lpString)
{
	lpString[0] = 0;

	switch (wDSDT)
	{
	case WBEM_DSDT_SINT8:
		lstrcpy(lpString, "SINT8");
		break;
	case WBEM_DSDT_UINT8:
		lstrcpy(lpString, "UINT8");
		break;
	case WBEM_DSDT_SINT64:
		lstrcpy(lpString, "SINT64");
		break;
	case WBEM_DSDT_UINT64:
		lstrcpy(lpString, "UINT64");
		break;
//	case WBEM_DSDT_INTERVAL:
//		lstrcpy(lpString, "INTERVAL");
//		break;
	case WBEM_DSDT_TIMESTAMP:
		lstrcpy(lpString, "TIMESTAMP");
		break;
//	case WBEM_DSDT_DATE:
//		lstrcpy(lpString, "DATE");
//		break;
//	case WBEM_DSDT_TIME:
//		lstrcpy(lpString, "TIME");
//		break;
	case WBEM_DSDT_SMALL_STRING:
		lstrcpy(lpString, "SMALL_STRING");
		break;
	case WBEM_DSDT_STRING:
		lstrcpy(lpString, "STRING");
		break;
	case WBEM_DSDT_UINT32:
		lstrcpy(lpString, "UINT32");
		break;
	case WBEM_DSDT_SINT32:
		lstrcpy(lpString, "SINT32");
		break;
	case WBEM_DSDT_SINT16:
		lstrcpy(lpString, "SINT16");
		break;
	case WBEM_DSDT_UINT16:
		lstrcpy(lpString, "UINT16");
		break;
	case WBEM_DSDT_REAL:
		lstrcpy(lpString, "REAL");
		break;
	case WBEM_DSDT_DOUBLE:
		lstrcpy(lpString, "DOUBLE");
		break;
	case WBEM_DSDT_BIT:
		lstrcpy(lpString, "BIT");
		break;
	case WBEM_DSDT_SINT8_ARRAY:
		lstrcpy(lpString, "SINT8_ARRAY");
		break;
	case WBEM_DSDT_UINT8_ARRAY:
		lstrcpy(lpString, "UINT8_ARRAY");
		break;
	case WBEM_DSDT_UINT32_ARRAY:
		lstrcpy(lpString, "UINT32_ARRAY");
		break;
	case WBEM_DSDT_SINT32_ARRAY:
		lstrcpy(lpString, "SINT32_ARRAY");
		break;
	case WBEM_DSDT_BOOL_ARRAY:
		lstrcpy(lpString, "BOOL_ARRAY");
		break;
	case WBEM_DSDT_SINT16_ARRAY:
		lstrcpy(lpString, "SINT16_ARRAY");
		break;
	case WBEM_DSDT_UINT16_ARRAY:
		lstrcpy(lpString, "UINT16_ARRAY");
		break;
	case WBEM_DSDT_REAL_ARRAY:
		lstrcpy(lpString, "REAL_ARRAY");
		break;
	case WBEM_DSDT_DOUBLE_ARRAY:
		lstrcpy(lpString, "DOUBLE_ARRAY");
		break;
	case WBEM_DSDT_SINT64_ARRAY:
		lstrcpy(lpString, "SINT64_ARRAY");
		break;
	case WBEM_DSDT_UINT64_ARRAY:
		lstrcpy(lpString, "UINT64_ARRAY");
		break;
	case WBEM_DSDT_STRING_ARRAY:
		lstrcpy(lpString, "STRING_ARRAY");
		break;
	case WBEM_DSDT_SMALL_STRING_ARRAY:
		lstrcpy(lpString, "SMALL_STRING_ARRAY");
		break;
//	case WBEM_DSDT_INTERVAL_ARRAY:
//		lstrcpy(lpString, "INTERVAL_ARRAY");
//		break;
	case WBEM_DSDT_TIMESTAMP_ARRAY:
		lstrcpy(lpString, "TIMESTAMP_ARRAY");
		break;
//	case WBEM_DSDT_DATE_ARRAY:
//		lstrcpy(lpString, "DATE_ARRAY");
//		break;
//	case WBEM_DSDT_TIME_ARRAY:
//		lstrcpy(lpString, "TIME_ARRAY");
//		break;
	default:
		break;
	}
}

/***************************************************************************/
/***************************************************************************/
/***************************************************************************/

//
// Methods for ClassColumnInfo 
//

/***************************************************************************/

/* ClassColumnInfo constructor                                             */
/*                                                                         */
/* Parameter pType is the Variant type of the property                     */                        //
/* Parameter pSYNTAX contains NULL or the SYNTAX string for the property   */
/* Parameter fGotSyntax indicates if a SYNTAX string is present            */
/* This class is only used internaly by ClassColumnInfoBase and provides   */
/* extracts property attribute values, like type, precision, scale         */ 

ClassColumnInfo :: ClassColumnInfo(LONG pType, VARIANT* pSYNTAX, SDWORD maxLenVal, BOOL fGotSyntax, BOOL fIsLazy)
{
	//Initialize
	VariantInit(&aVariantSYNTAX);
	szTypeName[0] = 0;
	fValidType = TRUE;
	varType = pType;
	SWORD wDSDT = WBEM_DSDT_UNKNOWN;
	SWORD wTheVariantType = 0;
	ibScale = 0;
	fIsLazyProperty = fIsLazy;

	//Make a copy of input variants
	if (fGotSyntax)
		VariantCopy(&aVariantSYNTAX, pSYNTAX);

	//Now work out info

    // Get the column Type, Precision, Scale etc...
	//You may need to get info from both column value
	//and SYNTAX attributes in order to map column type to SQL_* type
	//You may be able to directly map variant type to SQL_* type
	//however, for some variant types there may be multiple mappings
	//and so the SYNTAX attribute needs to be fetched in order to 
	//complete the mapping to SQL_* type.
	fValidType = ISAMGetWbemVariantType(pType, wTheVariantType);
	

	if (fValidType)
	{
		fValidType = ISAMGetDataSourceDependantTypeInfo
					(wTheVariantType, 
					(fGotSyntax && aVariantSYNTAX.bstrVal) ? aVariantSYNTAX.bstrVal : NULL,
					maxLenVal,
					wDSDT, fSqlType, cbPrecision);
			
		if (fValidType)
			ISAMGetDataSourceDependantTypeStr(wDSDT, (char*)szTypeName);
	}

}

/***************************************************************************/

/* Destructor */

ClassColumnInfo :: ~ClassColumnInfo()
{
	//Tidy up
	VariantClear(&aVariantSYNTAX);
}

/***************************************************************************/

//
// Methods of Class ClassColumnInfoBase
//

/***************************************************************************/
/***************************************************************************/
/***************************************************************************/

/* ClassColumnInfoBase Constructor     */
/*                                     */
/* This class is used as a repository  */
/* to extract information about a      */
/* property                            */

ClassColumnInfoBase :: ClassColumnInfoBase(LPISAMTABLEDEF pOrgTableDef, BOOL fIs__Gen)
{
	//Initialize
	isValid = TRUE;
	pTableDef = pOrgTableDef;
	pColumnInformation = NULL;
	iColumnNumber = 0;
	fIs__Generic = fIs__Gen;
	cSystemProperties = 0;

	embedded = NULL;
	embeddedSize = 0;

	//We need to get column information for a column
	//The information we need is stored in a VALUE variant and the property attribute "SYNTAX"
	//To get the property attribute "SYNTAX" variant we need the property/column name

	//Get the column/property name
	//We do this by getting the list of all property names in a SAFEARRAY

	//create SAFEARRAY to store BSTR's
	rgSafeArray = NULL;
	
	//Check for pass-through SQL
	if ( ! (pTableDef->pSingleTable) )
	{
		isValid = FALSE;
		return;
	}


	//Get the names of all the properties/columns
	SCODE scT = pTableDef->pSingleTable->GetNames ( NULL, 0, NULL, &rgSafeArray );

	if (FAILED(scT))
	{
		rgSafeArray = NULL;
		isValid = FALSE;
	}
	else
	{
		SafeArrayLock(rgSafeArray);
	}

	//Work out number of properties/columns	
	SafeArrayGetLBound(rgSafeArray, 1, &iLBound );
	SafeArrayGetUBound(rgSafeArray, 1, &iUBound );
	cColumnDefs = (UWORD)   (iUBound - iLBound + 1);

	if (fIs__Generic)
	{
		//This class is the prototype class for 
		//a passthrough SQL result set
		//calculate additional embedded proprties
		Get__GenericProfile();
	}
}

/***************************************************************************/

/* Destructor */

ClassColumnInfoBase :: ~ClassColumnInfoBase()
{
	//Tidy Up
	if (rgSafeArray)
	{
		SafeArrayUnlock(rgSafeArray);
		SafeArrayDestroy(rgSafeArray);
	}

	if (pColumnInformation)
		delete pColumnInformation;

//SAI ADDED	if (cSystemProperties)
	{
		if (embedded)
		{
			for (UWORD i = 0; i < embeddedSize; i++)
			{
				if (embedded[i])
				{
					delete embedded[i];
					embedded[i] = NULL;
				}
			}

			delete embedded;
			embedded = NULL;
		}
	}
}

/***************************************************************************/

/* Sets up extra column information for the selected */
/* column if required                                */

BOOL ClassColumnInfoBase :: Setup(LONG iColumnNum)
{
	//Sets up extra column information of specified column
	if ( (!pColumnInformation) || (iColumnNumber != iColumnNum) )
	{
		//Wrong column info, delete old column info
		//and create for new column
		if (pColumnInformation)
		{
			delete pColumnInformation;
			pColumnInformation = NULL;
		}

		//Setup column info
		if ( FAILED(GetColumnInfo(iColumnNum)) )
		{
			return FALSE;
		}
		else
		{
			
			//Check the newly created column information
			if (! pColumnInformation->IsValidInfo() )
				return FALSE;

			iColumnNumber = iColumnNum;
		}
	}

	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetVariantType(LONG iColumnNum, LONG &lVariant)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	lVariant = pColumnInformation->GetVariantType();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetSQLType(LONG iColumnNum, SWORD &wSQLType)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	wSQLType = pColumnInformation->GetSQLType();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetTypeName(LONG iColumnNum, UCHAR* &pbTypeName)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	pbTypeName = pColumnInformation->GetTypeName();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetPrecision(LONG iColumnNum, UDWORD &uwPrecision)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	uwPrecision = pColumnInformation->GetPrecision();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetScale(LONG iColumnNum, SWORD &wScale)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	wScale = pColumnInformation->GetScale();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: IsNullable(LONG iColumnNum, SWORD &wNullable)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	wNullable = pColumnInformation->IsNullable();
	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: IsLazy(LONG iColumnNum, BOOL &fLazy)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	fLazy = pColumnInformation->IsLazy();

	return TRUE;
}

/***************************************************************************/

BOOL ClassColumnInfoBase :: GetDataTypeInfo(LONG iColumnNum, LPSQLTYPE &pSQLType)
{
	if ( !Setup(iColumnNum) )
		return FALSE;

	pSQLType = pColumnInformation->GetDataTypeInfo();
	return TRUE;

}

/***************************************************************************/

SWORD ClassColumnInfoBase :: GetColumnName(LONG iColumnNumber, LPSTR pColumnName, LPSTR pColumnAlias)
{
	//Create a store for column name
	BSTR lpbString;

	//Now we want column number "iColumnNumber"

	CBString myString;
	if (fIs__Generic)
	{
		CBString myAlias;
		GetClassObject(iColumnNumber, myString, myAlias);
		lpbString = myString.GetString();

		//Copy across alias
		if (pColumnAlias)
		{
			pColumnAlias[0] = 0;

			//RAID 42256
			char* pTemp = (char*) pColumnAlias;
			_bstr_t myValue((BSTR)myAlias.GetString());
			Utility_WideCharToDBCS(myValue, &pTemp, MAX_COLUMN_NAME_LENGTH);

			pColumnAlias[MAX_COLUMN_NAME_LENGTH] = 0;
		}
	}
	else
	{
		if ( FAILED(SafeArrayGetElement(rgSafeArray, &iColumnNumber, &lpbString)) )
		{
			return SQL_ERROR;
		}
	}

	//copy column name
	pColumnName[0] = 0;

	//RAID 42256
	char* pTemp = (char*) pColumnName;
	_bstr_t myValue((BSTR)lpbString);
	Utility_WideCharToDBCS(myValue, &pTemp, MAX_COLUMN_NAME_LENGTH);

	pColumnName[MAX_COLUMN_NAME_LENGTH] = 0;

	//SAI ADDED
	if (!fIs__Generic)
		SysFreeString(lpbString);


	return SQL_SUCCESS;
}

/***************************************************************************/

// Checked for SetInterfaceSecurityEx on IWbemServices

UWORD ClassColumnInfoBase ::Get__GenericProfile()
{

	UWORD propertyCount = cColumnDefs;
	SAFEARRAY FAR* rgSafeArrayExtra = NULL;

	//Get the names of the non-system properties/columns
	SCODE scT = pTableDef->pSingleTable->GetNames ( NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &rgSafeArrayExtra );

	if (FAILED(scT))
	{
		rgSafeArrayExtra = NULL;
		return cColumnDefs;
	}


	//Lower bound
	LONG iLBoundExtra;

	//Upper bound
	LONG iUBoundExtra;
	SafeArrayGetLBound(rgSafeArrayExtra, 1, &iLBoundExtra );
	SafeArrayGetUBound(rgSafeArrayExtra, 1, &iUBoundExtra );
	UWORD cNumColumnDefs = (UWORD)   (iUBoundExtra - iLBoundExtra + 1);


	//As we know the total number of properties (cColumnDefs)
	//and the total number of non-system properties (cNumColumnDefs)
	//we can calculate the number of system properties
	cSystemProperties = cColumnDefs - cNumColumnDefs;


	embedded = new CEmbeddedDataItems* [cNumColumnDefs];
	embeddedSize = cNumColumnDefs;

	for (long i = 0; i < embeddedSize; i++)
	{
		embedded[i] = new CEmbeddedDataItems();
	}


	//Update number of columns (from ISAMTableDef)
	if (pTableDef && pTableDef->passthroughMap)
	{
		cColumnDefs = (UWORD) pTableDef->passthroughMap->GetCount();
	}


	for (i = 0; i < cNumColumnDefs; i++)
	{
		//Create a store for column name
		BSTR lpbString;

		//Now we want column number "i"
		if ( FAILED(SafeArrayGetElement(rgSafeArrayExtra, &i, &lpbString)) )
		{
			return cColumnDefs;
		}

		//Get the property type and value
		CIMTYPE vType;
		VARIANT pVal;

		if ( FAILED(pTableDef->pSingleTable->Get(lpbString, 0, &pVal, &vType, 0)) )
		{
			return cColumnDefs;
		}

		//We are looking for embedded objects
		if (vType == CIM_OBJECT)
		{

			(embedded[i])->embeddedName = lpbString;

			IWbemClassObject* myEmbeddedObj = NULL;


			IUnknown* myUnk = pVal.punkVal;
			//(5)
			myUnk->QueryInterface(IID_IWbemClassObject, (void**)&myEmbeddedObj);
		

			if (myEmbeddedObj)
			{
				//Get the __CLASS property
				//Get the property type and value
				VARIANT pVal2;

				CBString cimClass(L"__CLASS", FALSE);
				if ( SUCCEEDED(myEmbeddedObj->Get(cimClass.GetString(), 0, &pVal2, NULL, 0)) )
				{
					_bstr_t wEmbeddedClassName = pVal2.bstrVal;

					(embedded[i])->cClassObject = NULL;

					IWbemServicesPtr myServicesPtr = NULL;
					ISAMGetIWbemServices(pTableDef->lpISAM, *(pTableDef->pGateway2), myServicesPtr);
					myServicesPtr->GetObject(wEmbeddedClassName, 0, pTableDef->pContext, &((embedded[i])->cClassObject), NULL);

					VariantClear(&pVal2);
				}

				myEmbeddedObj->Release();
			}

			VariantClear(&pVal);
		}

		SysFreeString(lpbString);
	}

	//Tidy Up
	SafeArrayDestroy(rgSafeArrayExtra);

	return propertyCount;
}

/***************************************************************************/
IWbemClassObject* ClassColumnInfoBase :: GetClassObject(LONG iColumnNumber, CBString& lpPropName, CBString& cbTableAlias)
{
	//Examine the zero-based column number and return the 
	//parent class object containing the requested property

	if (pTableDef->passthroughMap)
	{
		PassthroughLookupTable* passthroughElement = NULL;
		WORD myIndex = (WORD)iColumnNumber;
		BOOL status = pTableDef->passthroughMap->Lookup(myIndex, (void*&)passthroughElement);

		if (status)
		{
			lpPropName.AddString(passthroughElement->GetColumnName(), FALSE);
			char* lpTableAlias = passthroughElement->GetTableAlias();
			
			if (!lpTableAlias || !strlen(lpTableAlias))
				return NULL;

			cbTableAlias.AddString(lpTableAlias, FALSE);


			//Now get the class object
			UWORD cNumColumnDefs = cColumnDefs; //(as this value has been updated)

			UWORD index = 0;
			while (index < cNumColumnDefs)
			{
				if ((embedded[index])->embeddedName.GetString())
				{
					if (_wcsicmp((embedded[index])->embeddedName.GetString(), cbTableAlias.GetString()) == 0)
					{
						//found embedded object
						return ((embedded[index])->cClassObject);
					}
				}
				index++;
			}
		}
		
	}

	
	//should not reach here
	return NULL;
}

/***************************************************************************/

SWORD ClassColumnInfoBase :: GetColumnInfo(LONG iColumnNumber)
{
	//Create a store for column name
	BSTR lpbString;
	IWbemClassObjectPtr parentClass = NULL;

	CBString myString;
	if (fIs__Generic)
	{
		CBString myAlias; //not used
		parentClass = GetClassObject(iColumnNumber, myString, myAlias);
		lpbString = myString.GetString();

	}
	else
	{
		parentClass = pTableDef->pSingleTable;

		//Now we want column number "iColumnNumber"
		if ( FAILED(SafeArrayGetElement(rgSafeArray, &iColumnNumber, &lpbString)) )
		{
			return SQL_ERROR;
		}

	}

	

#ifdef TESTING
	//copy column name
	char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
	pColumnName[0] = 0;
	wcstombs(pColumnName, lpbString, MAX_COLUMN_NAME_LENGTH);
	pColumnName[MAX_COLUMN_NAME_LENGTH] = 0;
#endif


	//Get the "Type" value
	CIMTYPE pColumnType;
	if ( FAILED(parentClass->Get(lpbString, 0, NULL, &pColumnType, 0)) )
	{
		if (!fIs__Generic)
			SysFreeString(lpbString);

		return SQL_ERROR;
	}

	//flag to indicate if property is marked 'lazy'
	BOOL fIsLazyProperty = FALSE;

	//Now get the qualifiers (if available)
	IWbemQualifierSetPtr pQualifierSet = NULL;
	if ( S_OK != (parentClass->GetPropertyQualifierSet
										(lpbString, &pQualifierSet)) )
	{
		if (!fIs__Generic)
			SysFreeString(lpbString);

		//No qualifers, therefore no CIMTYPE, MAX & LAZY qualifiers 
		pColumnInformation = new ClassColumnInfo(pColumnType, NULL, NULL, FALSE, fIsLazyProperty);

        return SQL_SUCCESS;
	}

	//Get the lazy qualifer (if applicable)
	VARIANT pValLazy;
	BSTR lazyStr = SysAllocString(WBEMDR32_L_LAZY);
	if ( S_OK == (pQualifierSet->Get(lazyStr, 0, &pValLazy, NULL)) )
	{
		fIsLazyProperty = TRUE;	
		VariantClear(&pValLazy);
	}
	else
	{
		fIsLazyProperty = FALSE;
	}
	SysFreeString(lazyStr);

	VARIANT pVal;

	//Get the CIMTYPE qualifier
	BSTR cimTypeStr = SysAllocString(WBEMDR32_L_CIMTYPE);
	if ( S_OK != (pQualifierSet->Get(cimTypeStr, 0, &pVal, NULL)) )
	{
		//No CIMTYPE qualifier (therefore no max string)
		pColumnInformation = new ClassColumnInfo(pColumnType, NULL,//&pVal
			 NULL, FALSE, fIsLazyProperty);
	}
	else
	{
		//Got the CIMTYPE qualifier

		//Now get the optional MAX qualifier
		long cbMaxValue = 0;
		VARIANT pVal2;
		BSTR maxStr = SysAllocString(WBEMDR32_L_MAX);
		if ( S_OK != (pQualifierSet->Get(maxStr, 0, &pVal2, NULL)) )
		{
			//Got CIMTYPE but no MAX qualifier
			pColumnInformation = new ClassColumnInfo(pColumnType, &pVal, NULL, TRUE, fIsLazyProperty);
		}
		else
		{
			//Got CIMTYPE and got MAX qualifier
			SDWORD maxLenVal = pVal2.iVal;
			pColumnInformation = new ClassColumnInfo(pColumnType, &pVal, maxLenVal, TRUE, fIsLazyProperty);

			VariantClear(&pVal2);
		}
		SysFreeString(maxStr);

		VariantClear(&pVal);
	}

	SysFreeString(cimTypeStr);

	if (!fIs__Generic)
		SysFreeString(lpbString);

	return SQL_SUCCESS;
}

/***************************************************************************/

SWORD ClassColumnInfoBase :: GetKey(LONG iColumnNumber, BOOL &isAKey)
{
	//We return FALSE for now as we don't support SQLPrimaryKeys

	//If we do implement SQLPrimaryKeys we can comment out the next two lines
	isAKey = FALSE;
	return SQL_SUCCESS;

	//Create a store for column name
	BSTR lpbString;

	//Now we want column number "iColumnNumber"
	if ( FAILED(SafeArrayGetElement(rgSafeArray, &iColumnNumber, &lpbString)) )
	{
        return SQL_ERROR;
	}

	//Now get the Key attribute value (if available)
	IWbemQualifierSetPtr pQualifierSet = NULL;
	if ( S_OK != (pTableDef->pSingleTable->GetPropertyQualifierSet
										(lpbString, &pQualifierSet)) )
	{
		SysFreeString(lpbString);

        return SQL_ERROR;
	}


	//SAI ADDED - Tidy up
	SysFreeString(lpbString);
	lpbString = NULL;

	//Now get the KEY attribute value (if available)

	VARIANT pVal;
	isAKey = FALSE;
	BSTR keyBSTR = SysAllocString(WBEMDR32_L_KEY);
	if ( S_OK == (pQualifierSet->Get(keyBSTR, 0, &pVal, NULL)) )
	{
		isAKey = (pVal.boolVal != 0) ? TRUE : FALSE;

		//TidyUp
		VariantClear(&pVal);
	}
	SysFreeString(keyBSTR);


	return SQL_SUCCESS;
}

/***************************************************************************/

SWORD ClassColumnInfoBase :: GetColumnAttr(LONG iColumnNumber, LPSTR pAttrStr, SDWORD cbValueMax, SDWORD &cbBytesCopied)
{
	SWORD err = SQL_SUCCESS;
	cbBytesCopied = 0;

	//Create a store for column name
	BSTR lpbString;

	//Now we want column number "iColumnNumber"

	if ( FAILED(SafeArrayGetElement(rgSafeArray, &iColumnNumber, &lpbString)) )
	{
        return SQL_ERROR;
	}

#ifdef TESTING
	//copy column name
	char pColumnName [MAX_COLUMN_NAME_LENGTH+1];
	pColumnName[0] = 0;
	wcstombs(pColumnName, lpbString, MAX_COLUMN_NAME_LENGTH);
	pColumnName[MAX_COLUMN_NAME_LENGTH] = 0;
#endif

	//Get attributes for chosen column
	IWbemQualifierSetPtr pQualifierSet = NULL;
	if ( S_OK != (pTableDef->pSingleTable->GetPropertyQualifierSet(lpbString, &pQualifierSet)) )
	{
		SysFreeString(lpbString);

        return SQL_ERROR;
	}

	SysFreeString(lpbString);
	lpbString = NULL;

	//Get CIMTYPE String
	VARIANT pVal2;
	BSTR syntaxStr = NULL;
	BOOL fClearpVal2 = FALSE;
	BSTR cimTypeBSTR = SysAllocString(WBEMDR32_L_CIMTYPE);
	if ( S_OK == (pQualifierSet->Get(cimTypeBSTR, 0, &pVal2, NULL)) )
	{
		if (pVal2.bstrVal)
			syntaxStr = pVal2.bstrVal;

		fClearpVal2 = TRUE;
	}
	SysFreeString(cimTypeBSTR);

	//Get the MAX String
	VARIANT pVal3;
	SDWORD maxLenVal = 0;
	BOOL fClearpVal3 = FALSE;
	BSTR maxBSTR = SysAllocString(WBEMDR32_L_MAX);
	if ( S_OK == (pQualifierSet->Get(maxBSTR, 0, &pVal3, NULL)) )
	{
		maxLenVal = pVal3.iVal;
		fClearpVal3 = TRUE;
	}
	SysFreeString(maxBSTR);


	//Now get list of attribute names from attribute set

	//create SAFEARRAY to store attribute names
	SAFEARRAY FAR* rgNames = NULL;

	//Fetch attribute names
	pQualifierSet->GetNames(0, &rgNames);
	SafeArrayLock(rgNames);

	//Get the upper and lower bounds of SAFEARRAY
	long lowerBound;
	SafeArrayGetLBound(rgNames, 1, &lowerBound);

	long upperBound;
	SafeArrayGetUBound(rgNames, 1, &upperBound);

	//Get each name out
	BSTR pTheAttrName;

	for (long ix = lowerBound; ix <= upperBound; ix++)
	{
		if ( SUCCEEDED(SafeArrayGetElement(rgNames, &ix, &pTheAttrName)) )
		{
			//Get variant value of named attribute
			VARIANT pVal;
			if ( S_OK == (pQualifierSet->Get(pTheAttrName, 0, &pVal, NULL)) )
			{
				//Decode variant value, as we do not know actual size of value
				//beforehand we will create buffers in increments of 200 bytes 
				//until we can get the value with truncation
				ULONG cwAttemptToGetValue = 0;
				ULONG wBufferLen = 0;
				char* buffer = NULL;
				SDWORD cbValue;
				SWORD err = ISAM_TRUNCATION;
				while ( err == ISAM_TRUNCATION )
				{
					if (buffer)
						delete buffer;

					wBufferLen = 200 * (++cwAttemptToGetValue);

					buffer = new char [wBufferLen + 1];
					buffer[0] = 0;

					err = ISAMGetValueFromVariant(pVal, SQL_C_CHAR, buffer, wBufferLen, &cbValue, 0, syntaxStr, maxLenVal);
				}
				
				VariantClear (&pVal);

				if (fClearpVal2)
					VariantClear (&pVal2);

				if (fClearpVal3)
					VariantClear (&pVal3);


				//Check for error
				if (err != NO_ISAM_ERR)
				{
					pTableDef->lpISAM->errcode = err;
					SafeArrayUnlock(rgNames);
					SafeArrayDestroy(rgNames);

					SysFreeString(pTheAttrName);

					delete buffer;
					return SQL_ERROR;
				}

				//Once we have the name and value of the attribute let us try and add 
				//it to the output buffer

				//First try and save the attribute name

				//Save old number of bytes copied so that if truncation
				//occurs we can roll back to original state
				SDWORD pdbOldValue = cbBytesCopied;

				//If this is not the first attribute in the list
				//we must separate the attribute/value pairs with "\n" character
				if ( (cbValueMax - cbBytesCopied) && cbBytesCopied)
				{
					pAttrStr[cbBytesCopied++] = '\n';
				}

				//Now add in attribute name
				//first convert it from a BSTR to a char*
				char* lpTheAttrString = NULL;
				ULONG cLength = 0;

				if (pTheAttrName)
				{
					cLength = wcslen(pTheAttrName);
					lpTheAttrString = new char [cLength + 1];
					lpTheAttrString[0] = 0;
					wcstombs(lpTheAttrString, pTheAttrName, cLength);
					lpTheAttrString[cLength] = 0;
				}

				BOOL fOutOfBufferSpace = FALSE;

				err = ISAMFormatCharParm (lpTheAttrString, fOutOfBufferSpace,
							pAttrStr, cbValueMax, &cbBytesCopied, FALSE);

				delete lpTheAttrString;


				//Now add in value
				if (err == NO_ISAM_ERR)
				{
					err = ISAMFormatCharParm (buffer, fOutOfBufferSpace,
							pAttrStr, cbValueMax, &cbBytesCopied, FALSE);
				}

				delete buffer;
				buffer = NULL;

				if (err != NO_ISAM_ERR)
				{
					//Truncation took place so rollback
					cbBytesCopied = pdbOldValue;

					//Null terminate
					pAttrStr[cbBytesCopied] = 0;
					SafeArrayUnlock(rgNames);
					SafeArrayDestroy(rgNames);

					SysFreeString(pTheAttrName);

					return SQL_SUCCESS_WITH_INFO;
				}

				//Null terminate
				pAttrStr[cbBytesCopied] = 0;
			}
			else
			{
				//Error, tidy up and then quit

				SysFreeString(pTheAttrName);

				SafeArrayUnlock(rgNames);
				SafeArrayDestroy(rgNames);
				return SQL_ERROR;
			}

			SysFreeString(pTheAttrName);
		}
		else
		{
			//Error, tidy up and then quit
			SafeArrayUnlock(rgNames);
			SafeArrayDestroy(rgNames);
			return SQL_ERROR;
		}
	}


	//Tidy Up
	SafeArrayUnlock(rgNames);
	SafeArrayDestroy(rgNames);

	return SQL_SUCCESS;
}

/***************************************************************************/

SWORD INTFUNC ISAMGetTableAttr(LPISAMTABLEDEF lpISAMTableDef, LPSTR pAttrStr, SDWORD cbValueMax, SDWORD &cbBytesCopied)
{
	SWORD err = SQL_SUCCESS;
	cbBytesCopied = 0;

	//Get attributes for chosen table
	IWbemQualifierSetPtr pQualifierSet = NULL;
	if ( S_OK != (lpISAMTableDef->pSingleTable->GetQualifierSet(&pQualifierSet)) )
	{
        return SQL_ERROR;
	}

	

	//Now get list of attribute names from attribute set

	//create SAFEARRAY to store attribute names
	SAFEARRAY FAR* rgNames = NULL;

	//Fetch attribute names
	pQualifierSet->GetNames(0, &rgNames);
	SafeArrayLock(rgNames);

	//Get the upper and lower bounds of SAFEARRAY
	long lowerBound;
	SafeArrayGetLBound(rgNames, 1, &lowerBound);

	long upperBound;
	SafeArrayGetUBound(rgNames, 1, &upperBound);

	//Get each name out
	BSTR pTheAttrName;

	for (long ix = lowerBound; ix <= upperBound; ix++)
	{
		if ( SUCCEEDED(SafeArrayGetElement(rgNames, &ix, &pTheAttrName)) )
		{
			//Get variant value of named attribute
			VARIANT pVal;
			if ( S_OK == (pQualifierSet->Get(pTheAttrName, 0, &pVal, NULL)) )
			{
				//Get attribute set for column
				IWbemQualifierSetPtr pQualifierSet2 = NULL;
				if ( S_OK != (lpISAMTableDef->pSingleTable->GetPropertyQualifierSet(pTheAttrName, &pQualifierSet2)) )
				{
					SysFreeString(pTheAttrName);

					return SQL_ERROR;
				}

				//Get CIMTYPE String
				VARIANT pVal2;
				BSTR syntaxStr = NULL;
				BOOL fClearpVal2 = FALSE;
				BSTR cimTypeBSTR = SysAllocString(WBEMDR32_L_CIMTYPE);
				if ( S_OK == (pQualifierSet2->Get(cimTypeBSTR, 0, &pVal2, NULL)) )
				{
					if (pVal2.bstrVal)
						syntaxStr = pVal2.bstrVal;

					fClearpVal2 = TRUE;
				}
				SysFreeString(cimTypeBSTR);

				//Get the MAX String
				VARIANT pVal3;
				SDWORD maxLenVal = 0;
				BOOL fClearpVal3 = FALSE;
				BSTR maxBSTR = SysAllocString(WBEMDR32_L_MAX);
				if ( S_OK == (pQualifierSet->Get(maxBSTR, 0, &pVal3, NULL)) )
				{
					maxLenVal = pVal3.iVal;
					fClearpVal3 = TRUE;
				}
				SysFreeString(maxBSTR);

				//Decode variant value, as we do not know actual size of value
				//beforehand we will create buffers in increments of 200 bytes 
				//until we can get the value with truncation
				ULONG cwAttemptToGetValue = 0;
				ULONG wBufferLen = 0;
				char* buffer = NULL;
				SDWORD cbValue;
				SWORD err = ISAM_TRUNCATION;
				while ( err == ISAM_TRUNCATION )
				{
					if (buffer)
						delete buffer;

					wBufferLen = 200 * (++cwAttemptToGetValue);

					buffer = new char [wBufferLen + 1];
					buffer[0] = 0;
					err = ISAMGetValueFromVariant(pVal, SQL_C_CHAR, buffer, wBufferLen, &cbValue, 0, syntaxStr, maxLenVal);
				}

				VariantClear (&pVal);

				if (fClearpVal2)
					VariantClear (&pVal2);

				if (fClearpVal3)
					VariantClear (&pVal3);

				//Check for error
				if (err != NO_ISAM_ERR)
				{
					lpISAMTableDef->lpISAM->errcode = err;
					SafeArrayUnlock(rgNames);
					SafeArrayDestroy(rgNames);

					SysFreeString(pTheAttrName);

					delete buffer;
					return SQL_ERROR;
				}

				//Once we have the name and value of the attribute let us try and add 
				//it to the output buffer

				//First try and save the attribute name

				//Save old number of bytes copied so that if truncation
				//occurs we can roll back to original state
				SDWORD pdbOldValue = cbBytesCopied;

				//If this is not the first attribute in the list
				//we must separate the attribute/value pairs with "\n" character
				if ( (cbValueMax - cbBytesCopied) && cbBytesCopied)
				{
					pAttrStr[cbBytesCopied++] = '\n';
				}

				//Now add in attribute name
				//first convert it from a BSTR to a char*
				char* lpTheAttrString = NULL;
				ULONG cLength = 0;

				if (pTheAttrName)
				{
					cLength = wcslen(pTheAttrName);
					lpTheAttrString = new char [cLength + 1];
					lpTheAttrString[0] = 0;
					wcstombs(lpTheAttrString, pTheAttrName, cLength);
					lpTheAttrString[cLength] = 0;
				}

				BOOL fOutOfBufferSpace = FALSE;

				err = ISAMFormatCharParm (lpTheAttrString, fOutOfBufferSpace,
							pAttrStr, cbValueMax, &cbBytesCopied, FALSE);

				delete lpTheAttrString;


				//Now add in value
				if (err == NO_ISAM_ERR)
				{
					err = ISAMFormatCharParm (buffer, fOutOfBufferSpace,
							pAttrStr, cbValueMax, &cbBytesCopied, FALSE);
				}

				delete buffer;
				buffer = NULL;

				if (err != NO_ISAM_ERR)
				{
					//Truncation took place so rollback
					cbBytesCopied = pdbOldValue;

					//Null terminate
					pAttrStr[cbBytesCopied] = 0;

					SysFreeString(pTheAttrName);

					return SQL_SUCCESS_WITH_INFO;
				}

				//Null terminate
				pAttrStr[cbBytesCopied] = 0;
			}
			else
			{
				//Error, tidy up and then quit
				SafeArrayUnlock(rgNames);
				SafeArrayDestroy(rgNames);
				return SQL_ERROR;
			}

			SysFreeString(pTheAttrName);
		}
		else
		{
			//Error, tidy up and then quit
			SafeArrayUnlock(rgNames);
			SafeArrayDestroy(rgNames);
			return SQL_ERROR;
		}
	}


	//Tidy Up
	SafeArrayUnlock(rgNames);
	SafeArrayDestroy(rgNames);

	return SQL_SUCCESS;
}

/***************************************************************************/

UWORD INTFUNC GetNumberOfColumnsInTable(LPISAMTABLEDEF    lpISAMTableDef)
{
	//Get number of columns
	ClassColumnInfoBase* cInfoBase = lpISAMTableDef->pColumnInfo;

	if ( !cInfoBase->IsValid() )
	{
		return 0;
	}

	return cInfoBase->GetNumberOfColumns();
}

/***************************************************************************/

/* This method checks if a string contains any  */
/* character preference control characters      */
/* such as %, _, \\                             */
/*                                              */
/* this method was cut and pasted out of an     */
/* existing class and converted into a function */

static BOOL INTFUNC IsRegularExpression(char* lpPattern)
{
	//First check if input string is valid and if it has any 
	//characters to check for
	ULONG cLen = 0;
	char m_cWildcard = '%';
	char m_cAnySingleChar = '_';
	char m_cEscapeSeq = '\\';
	

	if (lpPattern)
		cLen = strlen (lpPattern);

	ULONG iIndex = 0;

	if (cLen)
	{
		//Go through string checking for the 'wildcard' and 'single char' characters
		while (iIndex < cLen)
		{
			//Check for 'wildcard' and 'single char' characters
			if ( (lpPattern[iIndex] == m_cWildcard) || (lpPattern[iIndex] == m_cAnySingleChar) )
			{
				return TRUE;
			}

			//Skip any characters which are preceeded by escape sequence character
			if ( lpPattern[iIndex] == m_cEscapeSeq)
			{
				//skip escape character and next one
				iIndex++;
			}

			//Increment index in string
			iIndex++;

		}

	}
	else
	{
		//No character to check
		return FALSE;
	}


	//If you reach here then input string must not be a regular expression
	return FALSE;
}

/***************************************************************************/

CNotifyTableNames ::CNotifyTableNames(LPISAMTABLELIST lpTblList)
{
	//Initialize reference count and backpointer to table list
	m_cRef = 0;
	lpISAMTableList = lpTblList;

	//create mutex (no owed by anyone yet)
	m_mutex = CreateMutex(NULL, FALSE, NULL);
}

/***************************************************************************/

CNotifyTableNames :: ~CNotifyTableNames()
{
	//Tidy Up
	CloseHandle(m_mutex);
}

/***************************************************************************/

STDMETHODIMP_(ULONG) CNotifyTableNames :: AddRef(void)
{
	return ++m_cRef;
}

/***************************************************************************/

STDMETHODIMP_(ULONG) CNotifyTableNames :: Release(void)  // FOLLOWUP: why is the decrement commented out?
{
//	if  (--m_cRef != 0)
//	{
//		return m_cRef;
//	}
	
	//If you reached this point the reference count is zero
	//Therefore we have got all information back
	lpISAMTableList->iIndex = lpISAMTableList->pTblList->GetHeadPosition();
	lpISAMTableList->fGotAllInfo = TRUE;

	delete this;
	return 0;
}

/***************************************************************************/

STDMETHODIMP CNotifyTableNames :: QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
	*ppv = NULL;

	if (IID_IUnknown == riid || IID_IWbemObjectSink == riid)
		*ppv = this;

	if (*ppv == NULL)
		return ResultFromScode(E_NOINTERFACE);


	return NOERROR;
}

/***************************************************************************/

STDMETHODIMP_(SCODE) CNotifyTableNames :: Notify(long lObjectCount, IWbemClassObject** pObjArray)	
{

	//remember to mutex protect writing to table list
	WaitForSingleObject(m_mutex, INFINITE);
	for (long i = 0; i < lObjectCount; i++)
	{
		if (pObjArray[i])
		{
			pObjArray[i]->AddRef();
			lpISAMTableList->pTblList->AddTail(pObjArray[i]);
		}
	}
	ReleaseMutex(m_mutex);

	return WBEM_NO_ERROR;
}

/***************************************************************************/

/* Setups up ISAM structure which stores data-source information */

SWORD INTFUNC ISAMOpen(LPUSTR lpszServer,
					   LPUSTR lpszDatabase,
					   LPUSTR lpszDSN,
//					   WBEM_LOGIN_AUTHENTICATION loginMethod,
					   LPUSTR lpszUsername,
					   LPUSTR lpszPassword,
					   LPUSTR lpszLocale,
					   LPUSTR lpszAuthority,
					   BOOL  fSysProps,
					   CMapStringToOb *pNamespaceMap,
					   LPISAM FAR *lplpISAM, 
					   LPUSTR lpszErrorMessage,
					   BOOL  fOptimization,
					   BOOL  fImpersonation,
					   BOOL  fPassthroughOnly,
					   BOOL  fIntpretEmptPwdAsBlk)
{
    s_lstrcpy(lpszErrorMessage, "");

//	ODBCTRACE("\nWBEM ODBC Driver : ISAMOpen\n");

	//Extra check for table qualifier
	if (!lpszDatabase || !s_lstrlen (lpszDatabase)) // need to check in args here too 
	{
        LoadString(s_hModule, ISAM_NS_QUALMISSING, (LPSTR)lpszErrorMessage,
                   MAX_ERROR_LENGTH+1);
		*lplpISAM = NULL;
		return ISAM_NS_QUALMISSING;
	}

    HGLOBAL  h;
    LPISAM   lpISAM;

    h = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (ISAM));
    if (h == NULL || (lpISAM = (LPISAM) GlobalLock (h)) == NULL) {
        
        if (h)
            GlobalFree(h);

        LoadString(s_hModule, ISAM_MEMALLOCFAIL, (LPSTR)lpszErrorMessage,
                   MAX_ERROR_LENGTH+1);
		*lplpISAM = NULL;
        return ISAM_MEMALLOCFAIL;
    }
    lpISAM->cSQLTypes = NumTypes();
    lpISAM->SQLTypes = SQLTypes;

    lpISAM->fTxnCapable = SQL_TC_NONE;
    lpISAM->fSchemaInfoTransactioned = FALSE;
    lpISAM->fMultipleActiveTxn = FALSE;
    lpISAM->fTxnIsolationOption = SQL_TXN_READ_UNCOMMITTED;
    lpISAM->fDefaultTxnIsolation = SQL_TXN_READ_UNCOMMITTED;
    lpISAM->udwNetISAMVersion = 0;

	lpISAM->hKernelApi = LoadLibrary("KERNEL32.DLL");

    lpISAM->netConnection = NULL;
    lpISAM->netISAM = NET_OPAQUE_INVALID;
    lpISAM->fCaseSensitive = FALSE;
    s_lstrcpy(lpISAM->szName, "");
    s_lstrcpy(lpISAM->szVersion, "");
    lpISAM->cbMaxTableNameLength = 0;
    lpISAM->cbMaxColumnNameLength = 0;

	//WBEM Client Recognition variables
	//(dummy values which will be overridden)
	lpISAM->dwAuthLevel = 0;
	lpISAM->dwImpLevel = 0;
	lpISAM->gpAuthIdentity = NULL;


	lpISAM->pNamespaceMap = pNamespaceMap;
	s_lstrcpy (lpISAM->szServer, lpszServer);
	s_lstrcpy (lpISAM->szDatabase, lpszDatabase);
	s_lstrcpy (lpISAM->szUser, lpszUsername);
	s_lstrcpy (lpISAM->szPassword, lpszPassword);
	s_lstrcpy (lpISAM->szRootDb, "root");

	//Flags for cloaking
	lpISAM->fIsLocalConnection = IsLocalServer((LPSTR) lpszServer);
	lpISAM->fW2KOrMore = IsW2KOrMore();

	//Make copies of locale and authority
	lpISAM->m_Locale = NULL;
	
	if (lpszLocale)
	{
		int localeLen = lstrlen((char*)lpszLocale);
		lpISAM->m_Locale = new char [localeLen + 1];
		(lpISAM->m_Locale)[0] = 0;
		lstrcpy(lpISAM->m_Locale, (char*)lpszLocale);

	}

	lpISAM->m_Authority = NULL;

	if (lpszAuthority)
	{
		int authLen = lstrlen((char*)lpszAuthority);
		lpISAM->m_Authority = new char [authLen + 1];
		(lpISAM->m_Authority)[0] = 0;
		lstrcpy(lpISAM->m_Authority, (char*)lpszAuthority);

	}
		
	lpISAM->fOptimization = fOptimization;
	lpISAM->fSysProps = fSysProps;
	lpISAM->fPassthroughOnly = fPassthroughOnly;
	lpISAM->fIntpretEmptPwdAsBlank = fIntpretEmptPwdAsBlk;

	//Check if impersonation is requested
	lpISAM->Impersonate = NULL;
	if (fImpersonation)
	{
		//Now check if impersonation is necessary
		//only if connecting locally
		if (IsLocalServer((LPSTR) lpszServer))
		{
			lpISAM->Impersonate = new ImpersonationManager(lpISAM->szUser, lpISAM->szPassword, lpISAM->m_Authority);
		}
		else
		{
			ODBCTRACE("\nWBEM ODBC Driver : Server not detected as local, not impersonating\n");
		}
	}

    lpISAM->errcode = NO_ISAM_ERR;

	//SAI new - make sure there is nothing in old
	//ISAM before you assign to it
	if (*lplpISAM)
		ISAMClose(*lplpISAM);

    *lplpISAM = lpISAM;

	//Check if impersonation worked
	if (fImpersonation && lpISAM->Impersonate)
	{
		if ( ! lpISAM->Impersonate->CanWeImpersonate() )
		{
			lpISAM->pNamespaceMap = NULL; //protect against deleting namespace map
			ISAMClose(lpISAM);
			*lplpISAM = NULL;
			return ISAM_ERROR;
		}
	}

    return NO_ISAM_ERR;
}

/***************************************************************************/

/* Creates a communication channel to the Gateway Server */
// Checked for SetInterfaceSecurityEx on IWbemServices

void INTFUNC ISAMGetGatewayServer(IWbemServicesPtr& pGateway, LPISAM lpISAM, LPUSTR lpQualifierName, 
											SWORD cbQualifierName)
{
	ThreadLocaleIdManager myThread(lpISAM);

	//First get the locator interface
	IWbemLocator* pLocator = NULL;

	SCODE sc = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER , IID_IWbemLocator, (void**) (&pLocator) );


	//Bug fix for dbWeb
	if ( FAILED(sc) )
	{
		//If you fail, initialize OLE and try again
		OleInitialize(0);
		sc = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER , IID_IWbemLocator, (void**) (&pLocator) );
	}

	if ( FAILED(sc) )
	{	
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 2 : Error position 1\n");
		return;
	}

	//Get user and password fields

	//Get handle to gateway server interface
	pGateway = NULL;
	long refcount = 0;

	//Check if we want the default database or something else

	//We will be building the fully qualified database pathname
	//so we work out some lengths first
	SWORD cbServerLen = (SWORD) _mbstrlen((LPSTR)lpISAM->szServer);
	
	//RAID 57673 WMI has changed such that if you
	//connect locally and pass a username and password
	//it will fail
	//Check for local connection
//	CBString myServerStr;
//	myServerStr.AddString( (LPSTR)lpISAM->szServer, FALSE );
//	CServerLocationCheck myCheck (myServerStr);
	BOOL fIsLocalConnection = lpISAM->fIsLocalConnection;//myCheck.IsLocal();


	//Used to store the fully qualified database pathname
	wchar_t pWcharName [MAX_DATABASE_NAME_LENGTH+1];
	pWcharName[0] = 0;

	if (cbQualifierName)
	{
		//We want something else

		//We need to prepend server name to qualifier name
		//Need to make sure everything fits in buffer size
		if ( (cbServerLen + cbQualifierName + 1) > MAX_DATABASE_NAME_LENGTH )
		{
			pLocator->Release();
			ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 2 : Error position 2\n");
			return;
		}

	
		CBString namespaceBSTR;
		//Construct string
		if (cbServerLen)
		{
			char pCharName [MAX_DATABASE_NAME_LENGTH+1];
			pCharName[0] = 0;
			sprintf (pCharName, "%s\\%s", (LPUSTR)lpISAM->szServer, (LPSTR)lpQualifierName);

			CString myText;
			myText.Format("\nWBEM ODBC Driver : Connecting using : %s\n", pCharName);
			ODBCTRACE(myText);

			//Convert to wide string
			namespaceBSTR.AddString(pCharName, FALSE);
		}
		else
		{
			if (lpQualifierName)
			{
				namespaceBSTR.AddString((LPSTR)lpQualifierName, FALSE, cbQualifierName);
			}
		}

		//Convert wide characters to BSTR for DCOM
		//----------------------------------------
		CBString userBSTR;

		if (!fIsLocalConnection)
			userBSTR.AddString((LPSTR)lpISAM->szUser, FALSE);

		CBString passwdBSTR;

		if (!fIsLocalConnection)
			passwdBSTR.AddString((LPSTR)lpISAM->szPassword, lpISAM->fIntpretEmptPwdAsBlank);

		CBString localeBSTR;
		CBString authorityBSTR;

		localeBSTR.AddString(lpISAM->m_Locale, FALSE);

		//Get the local and authority fields
		authorityBSTR.AddString(lpISAM->m_Authority, FALSE);

		sc = pLocator->ConnectServer (namespaceBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), localeBSTR.GetString(), 0, authorityBSTR.GetString(), NULL, &pGateway);


		if (sc == S_OK)
		{
			sc  = GetAuthImp( pGateway, &(lpISAM->dwAuthLevel), &(lpISAM->dwImpLevel));
			if(sc == S_OK)
			{
				if (lpISAM->dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
					lpISAM->dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;

				if ( lpISAM->gpAuthIdentity )
				{
					WbemFreeAuthIdentity( lpISAM->gpAuthIdentity );
					lpISAM->gpAuthIdentity = NULL;
				}


				sc = ISAMSetCloaking1( pGateway, 
						lpISAM->fIsLocalConnection, 
						lpISAM->fW2KOrMore, 
						lpISAM->dwAuthLevel, 
						lpISAM->dwImpLevel,
						authorityBSTR.GetString(), 
						userBSTR.GetString(), 
						passwdBSTR.GetString(), 
						&(lpISAM->gpAuthIdentity) );
/*
				if ( fIsLocalConnection && IsW2KOrMore() )
				{
					WbemSetDynamicCloaking(pGateway, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
				}
				else
				{
					sc = SetInterfaceSecurityEx(pGateway, authorityBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), 
						   lpISAM->dwAuthLevel, lpISAM->dwImpLevel, EOAC_NONE, &(lpISAM->gpAuthIdentity), &gpPrincipal );
				}
*/
			}
		}
	}
	else
	{
		//We want the default database

		//Get default connection from LPISAM == <root>\default

		//We need to prepend server name to <root>\default
		//Need to make sure everything fits in buffer size
		SWORD cbRootLen = strlen ((LPSTR)lpISAM->szRootDb);
		
		if ( (cbServerLen + cbRootLen + 9) > MAX_DATABASE_NAME_LENGTH)
		{
			pLocator->Release();
			ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 2 : Error position 3\n");
			return;
		}

		//Construct string
		CBString namespaceBSTR;
		if (cbServerLen)
		{
			char pCharName [MAX_DATABASE_NAME_LENGTH+1];
			pCharName[0] = 0;
			sprintf (pCharName, "%s\\%s\\default", (LPUSTR)lpISAM->szServer, (LPSTR)lpISAM->szRootDb);

			//Convert to wide string
			namespaceBSTR.AddString(pCharName, FALSE);
		}
		else
		{
			if ((LPSTR)lpISAM->szRootDb)
			{
				char pCharName [MAX_DATABASE_NAME_LENGTH+1];
				pCharName[0] = 0;
				sprintf (pCharName, "%s\\default", (LPSTR)lpISAM->szRootDb);
				namespaceBSTR.AddString(pCharName, FALSE);
			}
		}

		//Convert wide characters to BSTR for DCOM
		//----------------------------------------
		CBString userBSTR;

		if (!fIsLocalConnection)
			userBSTR.AddString((LPSTR)lpISAM->szUser, FALSE);


		CBString passwdBSTR;

		if (!fIsLocalConnection)
			passwdBSTR.AddString((LPSTR)lpISAM->szPassword, lpISAM->fIntpretEmptPwdAsBlank);


		CBString localeBSTR;
		CBString authorityBSTR;

		//Get the local and authority fields
		localeBSTR.AddString(lpISAM->m_Locale, FALSE);

		authorityBSTR.AddString(lpISAM->m_Authority, FALSE);

		sc = pLocator->ConnectServer (namespaceBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), localeBSTR.GetString(), 0, authorityBSTR.GetString(), NULL, &pGateway);

		if (sc == S_OK)
		{
			sc  = GetAuthImp( pGateway, &(lpISAM->dwAuthLevel), &(lpISAM->dwImpLevel));
			if(sc == S_OK)
			{
				if (lpISAM->dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
					lpISAM->dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;


				if ( lpISAM->gpAuthIdentity )
				{
					WbemFreeAuthIdentity( lpISAM->gpAuthIdentity );
					lpISAM->gpAuthIdentity = NULL;
				}

				sc = ISAMSetCloaking1( pGateway, 
						lpISAM->fIsLocalConnection, 
						lpISAM->fW2KOrMore, 
						lpISAM->dwAuthLevel, 
						lpISAM->dwImpLevel,
						authorityBSTR.GetString(), 
						userBSTR.GetString(), 
						passwdBSTR.GetString(), 
						&(lpISAM->gpAuthIdentity) );

/*
				if ( fIsLocalConnection && IsW2KOrMore() )
				{
					WbemSetDynamicCloaking(pGateway, lpISAM->dwAuthLevel, lpISAM->dwImpLevel);
				}
				else
				{
					sc = SetInterfaceSecurityEx(pGateway, authorityBSTR.GetString(), userBSTR.GetString(), passwdBSTR.GetString(), 
						   lpISAM->dwAuthLevel, lpISAM->dwImpLevel, EOAC_NONE, &(lpISAM->gpAuthIdentity), &gpPrincipal);
				}
*/
			}
		}

	}

	//We have now finished with the locator so we can release it
	pLocator->Release();

	if ( FAILED(sc) )
	{
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 2 : Error position 4\n");
		return;
	}
}

/***************************************************************************/

/* Creates a communication channel to the Gateway Server */
// Checked for SetInterfaceSecurityEx on IWbemServices

void INTFUNC ISAMGetGatewayServer(IWbemServicesPtr& pGateway,
											LPUSTR lpServerName, 
//											WBEM_LOGIN_AUTHENTICATION loginMethod, 
											LPUSTR objectPath, LPUSTR lpUserName, LPUSTR lpPassword, LPUSTR lpLocale, LPUSTR lpAuthority,
											DWORD &dwAuthLevel, DWORD &dwImpLevel, BOOL fIntpretEmptPwdAsBlank, COAUTHIDENTITY** ppAuthIdent)
{
	ThreadLocaleIdManager myThread(lpLocale);

	*ppAuthIdent = NULL;

	IWbemLocator* pLocator = NULL;

	SCODE sc = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER , IID_IWbemLocator, (void**) (&pLocator) );

	if ( FAILED(sc) )
	{
		ODBCTRACE("\nWBEM ODBC Driver : ISAMGetGatewayServer version 1 : Error position 1\n");
		return;
	}

	pGateway = NULL;

