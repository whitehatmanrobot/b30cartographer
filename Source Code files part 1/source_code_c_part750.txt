alueNames[NUM_IDS] =
    {
        L"Current",
        L"Default",
        L"LastKnownGood",
        L"Failed"
    };

    DWORD   idArray[NUM_IDS];
    HKEY    selectKey  = 0;
    DWORD   status     = NO_ERROR;
    DWORD   bufferSize = 0;
    DWORD   newId      = 0;
    DWORD   i          = 0;

    //
    // Get the Select Key
    //
    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                SELECT_KEY,
                0L,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &selectKey);

    if (status != NO_ERROR)
    {
        return status;
    }

    //
    // Fill in the idArray
    //
    for (i = 0; i < NUM_IDS; i++)
    {
        bufferSize = sizeof(DWORD);
        //
        // ISSUE-2002/02/26-brucegr: Check data type matches REG_DWORD
        //
        status = RegQueryValueEx(
            selectKey,
            SelectValueNames[i],
            NULL,
            NULL,
            (LPBYTE)&idArray[i],
            &bufferSize);

        if (status != NO_ERROR)
        {
            idArray[i] = 0;
        }
    }

    status = ERROR_NO_MORE_ITEMS;

    for(newId = 1; newId < 1000; newId++)
    {
        BOOL inArray = FALSE;

        for(i = 0; i < NUM_IDS; i++)
        {
            if(idArray[i] == newId)
            {
                inArray = TRUE;
                break;
            }
        }

        if (!inArray)
        {
            status = RegSetValueEx(
                        selectKey,
                        SelectValueNames[LKG_ID],
                        0,
                        REG_DWORD,
                        (LPBYTE)&newId,
                        sizeof(DWORD));
            break;
        }
    }

    RegCloseKey(selectKey);

    return status;

}

BOOL
DeleteAdapterGuidsKeys(
    VOID
    )
{
    HKEY  hKey, hSubKey;
    DWORD dwError = NO_ERROR;
    int   i = 0;
    TCHAR SubKeyName[MAX_PATH * 2];

    //
    // Open HKLM\System\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}
    //
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }

    //
    // Now enumerate all subkeys.  For each subkey delete the adapter GUID.
    //
    while( (dwError = RegEnumKey( hKey, i, SubKeyName, sizeof(SubKeyName)/sizeof(SubKeyName[0]))) == ERROR_SUCCESS)
    {
        //
        // Check if the key is a probable GUID.
        // If it's a GUID key, delete the adapter GUIDs only
        //
        if (SubKeyName[0] == TEXT('{'))
        {
            
            //
            // If we were able to delete the key,then its okay, other wise 
            // increment the counter.
            //
            if ( ( dwError = SHDeleteKey(hKey, SubKeyName) )  !=  ERROR_SUCCESS ) 
                i++;
        }
        else
        {
            // 
            // If we didn't find one go to next subkey.
            //
            i++;
        }
    }

    RegCloseKey( hKey );

    return TRUE;
}

BOOL
RemoveNetworkSettings(
    LPTSTR  lpszSysprepINFPath
    )

/*++
===============================================================================
Routine Description:

    This routine will enumerate each physical NIC, call into the netsetup
    code to save the settings, and then delete the network card.
    When a new NIC is enumerated on the target machine, netsetup will apply the
    settings that were saved away

    If the LegacyNIC != 0 value exists in SYSPREP.INF in the [Unattended] section, then
    the previous behavior will be preserved, since removing a legacy NIC card
    will not work, because it will not be re-enumerated/detected on the next boot
Arguments:

    lpszSysprepINFPath  pointer to the SYSPREP.INF file. Can be NULL, in which case
    a non-legacy NIC is assumed

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
    HDEVINFO        DeviceInfoSet;
    DWORD           dwIdx;
    SP_DEVINFO_DATA DevInfoData;
    HKEY            hDevRegKey;
    DWORD           dwChar;
    DWORD           dwSize;
    FARPROC pNetSetupPrepareSysPrep = NULL;
    BOOL            DoLegacy = FALSE;

    HMODULE hNetShell = LoadLibraryA( "netshell.dll" );

    if (hNetShell) {
        pNetSetupPrepareSysPrep = GetProcAddress( hNetShell, "NetSetupPrepareSysPrep" );
        if (!pNetSetupPrepareSysPrep) {
            DoLegacy = TRUE;
            FreeLibrary( hNetShell );
        }

    }
    else {
        return FALSE;
    }

    // See if we are dealing with a legacy NIC
    if ((lpszSysprepINFPath != NULL)
         && GetPrivateProfileInt( TEXT( "Unattended" ),
                                  TEXT( "LegacyNIC" ),
                                  0,
                                  lpszSysprepINFPath)) {
        //
        // ISSUE-2002/02/26-brucegr: If we set DoLegacy to TRUE, then we don't free hNetShell!
        //
        DoLegacy = TRUE;
    }

    if (!DoLegacy)
    {
        // Call the netcfg function to save the networking settings
        pNetSetupPrepareSysPrep();

        FreeLibrary( hNetShell );

        // Enumerate and delete all phyiscal NICs
        DeviceInfoSet = SetupDiGetClassDevs(&GUID_DEVCLASS_NET,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);

        if(DeviceInfoSet == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }

        dwIdx = 0;
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        while (SetupDiEnumDeviceInfo(DeviceInfoSet, dwIdx, &DevInfoData))
        {

            hDevRegKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                              &DevInfoData,
                                              DICS_FLAG_GLOBAL,
                                              0,
                                              DIREG_DRV,
                                              KEY_READ);
            if (hDevRegKey == INVALID_HANDLE_VALUE)
            {
                // Not sure why it would ever return INVALID_HANDLE_VALUE, but 
                // we don't care and should continue.
                ++dwIdx;
                continue;
            }

            dwChar = 0;
            dwSize = sizeof(DWORD);
            RegQueryValueEx(hDevRegKey,
                            L"Characteristics",
                            NULL,
                            NULL,
                            (LPBYTE) &dwChar,
                            &dwSize);
            RegCloseKey(hDevRegKey);
            if (dwChar & NCF_PHYSICAL)
            {
                // This is one to delete
                SetupDiCallClassInstaller(DIF_REMOVE, DeviceInfoSet, &DevInfoData);
            }
            ++dwIdx;
        }

        // Cleanup
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }
    
    //
    // Delete the adapter GUIDs keys so we don't get multiple Local Area Connection # displays.
    //
    return DeleteAdapterGuidsKeys();
}

BOOL
ProcessUniquenessValue(
    LPTSTR lpszDLLPath
    )
{
    BOOL bRet = FALSE;

    //
    // Make sure we were passed something valid...
    //
    if ( lpszDLLPath && *lpszDLLPath )
    {
        LPWSTR pSrch;
        
        //
        // Look for the comma that separates the DLL and the entrypoint...
        //
        if ( pSrch = wcschr( lpszDLLPath, L',' ) )
        {
            CHAR szEntryPointA[MAX_PATH] = {0};

            // We found one, now NULL the string at the comma...
            //
            *(pSrch++) = L'\0';

            //
            // If there's still something after the comma, and we can convert it 
            // into ANSI for GetProcAddress, then let's proceed...
            //
            if ( *pSrch &&
                 ( 0 != WideCharToMultiByte( CP_ACP,
                                             0,
                                             pSrch,
                                             -1,
                                             szEntryPointA,
                                             ARRAYSIZE(szEntryPointA),
                                             NULL,
                                             NULL ) ) )
            {
                HMODULE hModule = NULL;

                try 
                {
                    //
                    // Load and call the entry point.
                    //
                    if ( hModule = LoadLibrary( lpszDLLPath ) )
                    {
                        FARPROC fpEntryPoint;
                        
                        if ( fpEntryPoint = GetProcAddress(hModule, szEntryPointA) )
                        {
                            //
                            // Do it, ignoring any return value/errors
                            //
                            fpEntryPoint();

                            //
                            // We made it this far, consider this a success...
                            //
                            bRet = TRUE;
                        }
                    }
                } 
                except(EXCEPTION_EXECUTE_HANDLER) 
                {
                    //
                    // We don't do anything with the exception code...
                    //
                }

                //
                // Free the library outside the try/except block in case the function faulted.
                //
                if ( hModule ) 
                {
                    FreeLibrary( hModule );
                }
            }
        }
    }

    return bRet;
}

VOID 
ProcessUniquenessKey(
    BOOL fBeforeReseal
    )
{
    HKEY   hKey;
    TCHAR  szRegPath[MAX_PATH] = {0};
    LPTSTR lpszBasePath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep\\");

    //
    // Build a path to the registry key we want to process...
    //
    lstrcpyn( szRegPath, lpszBasePath, ARRAYSIZE(szRegPath) );
    lstrcpyn( szRegPath + lstrlen(szRegPath), 
              fBeforeReseal ? TEXT("SysprepBeforeExecute") : TEXT("SysprepAfterExecute"),
              ARRAYSIZE(szRegPath) - lstrlen(szRegPath) );

    //
    // We want to make sure an Administrator is doing this, so get KEY_ALL_ACCESS
    //
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szRegPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey ) )
    {
        DWORD dwValues          = 0,
              dwMaxValueLen     = 0,
              dwMaxValueNameLen = 0;
        //
        // Query the key to find out some information we care about...
        //
        if ( ( ERROR_SUCCESS == RegQueryInfoKey( hKey,                  // hKey
                                                 NULL,                  // lpClass
                                                 NULL,                  // lpcClass
                                                 NULL,                  // lpReserved
                                                 NULL,                  // lpcSubKeys
                                                 NULL,                  // lpcMaxSubKeyLen
                                                 NULL,                  // lpcMaxClassLen
                                                 &dwValues,             // lpcValues
                                                 &dwMaxValueNameLen,    // lpcMaxValueNameLen
                                                 &dwMaxValueLen,        // lpcMaxValueLen
                                                 NULL,                  // lpcbSecurityDescriptor
                                                 NULL ) ) &&            // lpftLastWriteTime
             ( dwValues > 0 ) &&
             ( dwMaxValueNameLen > 0) &&
             ( dwMaxValueLen > 0 ) )
        {
            //
            // Allocate buffers large enough to hold the data we want...
            //
            LPBYTE lpData      = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwMaxValueLen );
            LPTSTR lpValueName = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, ( dwMaxValueNameLen + 1 ) * sizeof(TCHAR) );
            
            //
            // Make sure we could allocate our buffers... otherwise bail out
            //
            if ( lpData && lpValueName )
            {
                DWORD dwIndex   = 0;
                BOOL  bContinue = TRUE;

                //
                // Enumerate through the key values and call the DLL entrypoints...
                //
                while ( bContinue )
                {
                    DWORD dwType,
                          cbData         = dwMaxValueLen,
                          dwValueNameLen = dwMaxValueNameLen + 1;

                    bContinue = ( ERROR_SUCCESS == RegEnumValue( hKey,
                                                                 dwIndex++,
                                                                 lpValueName,
                                                                 &dwValueNameLen,
                                                                 NULL,
                                                                 &dwType,
                                                                 lpData,
                                                                 &cbData ) );

                    //
                    // Make sure we got some data of the correct format...
                    //
                    if ( bContinue && ( REG_SZ == dwType ) && ( cbData > 0 ) )
                    {
                        //
                        // Now split up the string and call the entrypoints...
                        //
                        ProcessUniquenessValue( (LPTSTR) lpData );
                    }
                }
            }

            //
            // Clean up any buffers we may have allocated...
            //
            if ( lpData )
            {
                HeapFree( GetProcessHeap(), 0, lpData );
            }

            if ( lpValueName )
            {
                HeapFree( GetProcessHeap(), 0, lpValueName );
            }
        }

        //
        // Close the key...
        //
        RegCloseKey( hKey );
    }
}

VOID
RunExternalUniqueness(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine will call out to any external dlls that will allow
    3rd party apps to make their stuff unique.

    We'll look in 2 inf files:
    %windir%\inf\minioc.inf
    %systemroot%\sysprep\provider.inf

    In each of these files, we'll look in the [SysprepBeforeExecute] section
    for any entries.  The entries must look like:
    dllname,entrypoint

    We'll load the dll and call into the entry point.  Errors are ignored.

Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
FARPROC     MyProc;
WCHAR       InfPath[MAX_PATH];
WCHAR       DllName[MAX_PATH];
WCHAR       EntryPointNameW[MAX_PATH];
CHAR        EntryPointNameA[MAX_PATH];
HINF        AnswerInf;
HMODULE     DllHandle;
INFCONTEXT  InfContext;
DWORD       i;
PCWSTR      SectionName = L"SysprepBeforeExecute";
BOOL        LineExists;

    //
    // =================================
    // Minioc.inf
    // =================================
    //

    //
    // Build the path.
    //
    if (!GetWindowsDirectory( InfPath, MAX_PATH ))
        return;

    StringCchCat( InfPath, AS ( InfPath ), TEXT("\\inf\\minioc.inf") );

    //
    // See if he's got an entry
    // section.
    //
    // NTRAID#NTBUG9-551511-2002/02/26-brucegr: We should make sure that MINIOC.INF is digitally signed before opening!
    // ISSUE-2002/02/26-brucegr: You can OR in both INF style bits! 
    //
    AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( AnswerInf == INVALID_HANDLE_VALUE ) {
        //
        // Try an old-style.
        //
        AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_OLDNT, NULL );
    }

    if( AnswerInf != INVALID_HANDLE_VALUE ) {
        //
        // Process each line in our section
        //
        LineExists = SetupFindFirstLine( AnswerInf, SectionName, NULL, &InfContext );

        while( LineExists ) {

            //
            // ISSUE-2002/02/26-brucegr: Why not use SetupGetStringFieldA with EntryPointNameA?
            //
            if( SetupGetStringField( &InfContext, 1, DllName, sizeof(DllName)/sizeof(TCHAR), NULL) ) {
                if( SetupGetStringField( &InfContext, 2, EntryPointNameW, sizeof(EntryPointNameW)/sizeof(TCHAR), NULL )) {

                    DllHandle = NULL;

                    //
                    // Load and call the entry point.
                    //
                    try {
                        if( DllHandle = LoadLibrary(DllName) ) {

                            //
                            // No Unicode version of GetProcAddress(). Convert string to ANSI.
                            //
                            i = WideCharToMultiByte(CP_ACP,0,EntryPointNameW,-1,EntryPointNameA,MAX_PATH,NULL,NULL);

                            if( MyProc = GetProcAddress(DllHandle, EntryPointNameA) ) {
                                //
                                // Do it, ignoring any return value/errors
                                //
                                MyProc();
                            }
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                    }

                    if( DllHandle ) {
                        FreeLibrary( DllHandle );
                    }

                }
            }

            LineExists = SetupFindNextLine(&InfContext,&InfContext);
        }

        SetupCloseInfFile( AnswerInf );
    }

    //
    // ISSUE-2002/02/26-brucegr: Why are we duplicating the same INF processing code from above?!!!!
    //


    //
    // =================================
    // Provider.inf
    // =================================
    //

    ProcessUniquenessKey( TRUE );
}

BOOL PrepForSidGen
(
    void
)
{
    DWORD           l;
    HKEY            hKey, hKeyNew;
    DWORD           d;
    DWORD           Size;
    DWORD           Type;
    TCHAR           SetupExecuteValue[1024];

    //
    // =================================
    // Set the value of the SetupExecute subkey.
    // =================================
    //

    //
    // Open the Session Manager key.
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }


    //
    // Set the Key.
    //
    StringCchCopy ( SetupExecuteValue, AS ( SetupExecuteValue ), TEXT(SYSCLONE_PART2) );
    SetupExecuteValue[lstrlen(SetupExecuteValue) + 1] = L'\0';

    //
    // ISSUE-2002/02/26-brucegr: Are we stomping anything that is already in SetupExecute?
    //
    l = RegSetValueEx(hKey,
                      TEXT("SetupExecute"),
                      0,
                      REG_MULTI_SZ,
                      (CONST BYTE *)SetupExecuteValue,
                      (lstrlen( SetupExecuteValue ) + 2) * sizeof(TCHAR));
    RegCloseKey(hKey);
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // =================================
    // Let's bump the size of the registry quota a bit so that
    // setupcl.exe can run.  He'll pop it back down.
    // =================================
    //

    //
    // Open HKLM\System\CurrentControlSet\Control
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // Query the value of the RegistrySizeLimit Key.
    //
    l = RegQueryValueEx(hKey,
                        TEXT("RegistrySizeLimit"),
                        NULL,
                        &Type,
                        (LPBYTE)&d,
                        &Size);

    if( l == ERROR_SUCCESS )
    {
        //
        // Got it.  Bump the value.
        //
        d += REGISTRY_QUOTA_BUMP; //Increase by some amount to load the repair hives
        //
        // Set the key.
        //
        l = RegSetValueEx(hKey,
                          TEXT("RegistrySizeLimit"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&d,
                          sizeof(DWORD) );
        if(l != NO_ERROR)
        {
           SetLastError(l);
           //
           // ISSUE-2002/02/26-brucegr: Need to call RegCloseKey!
           //
           return FALSE;
        }
    }
    else
    {
         //
        // Darn!  The value probably doesn't exist.
        // Ignore it and expect stuff to work. Only repair hives cannot be fixed
        //

    }

    RegCloseKey(hKey);

    //
    // =================================
    // See if anyone wants to reset uniqueness
    // in their component.  
    // =================================
    //
    RunExternalUniqueness();

    return TRUE;
}

BOOL SetCloneTag
(
    void
)
{
    HKEY    hKey;
    DWORD   l;
    TCHAR   DateString[1024];
    time_t  ltime;
    LPTSTR  lpszDate;

    //
    // =================================
    // Put a unique identifier into the registry so we know this machine
    // has been cloned.
    // =================================
    //

    //
    // Open HKLM\System\Setup
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    //
    // Set HKLM\System\Setup\CloneTag.  We're going to
    // pickup a date string and write it out.
    //
    time( &ltime );
    ZeroMemory(DateString, sizeof(DateString));
    //
    // ISSUE-2002/02/26-brucegr: This function smells horrid!
    //
    lpszDate = _wctime( &ltime );
    if ( lpszDate )
    {
        StringCchCopy( DateString, AS ( DateString ), lpszDate );
        l = RegSetValueEx(hKey,
                            TEXT("CloneTag"),
                            0,
                            REG_MULTI_SZ,
                            (CONST BYTE *)DateString,
                            (lstrlen( DateString ) + 2) * sizeof(TCHAR));
    }

    RegCloseKey(hKey);
    if(l != NO_ERROR)
    {
        SetLastError(l);
        return FALSE;
    }

    return (TRUE);
}


BOOL SetBigLbaSupport
(
    LPTSTR lpszSysprepINFPath
)
{
    HKEY    hKey;
    DWORD   dwError, dwValue;
    TCHAR   szEnableBigLba[MAX_PATH] = TEXT("\0");

    
    if ( ( lpszSysprepINFPath ) && 
         ( *lpszSysprepINFPath ) &&
         ( GetPrivateProfileString( TEXT( "Unattended" ), TEXT( "EnableBigLba" ), L"", szEnableBigLba, sizeof(szEnableBigLba)/sizeof(TCHAR), lpszSysprepINFPath ) ) )
    {
        // They would like to enable BigLba support.  If the user does not specify "Yes" for this key, we do not
        // touch the key (even if they specify "No").  This is By Design
        //
        if (LSTRCMPI(szEnableBigLba, TEXT("YES")) == 0)
        {
            // Open base key and subkey
            //
            dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("System\\CurrentControlSet\\Services\\Atapi\\Parameters"),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey );
            
            // Determine if opening the key was successful
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }

            // Set the value in the registry
            //
            dwValue = 1;
            dwError = RegSetValueEx(hKey,
                              TEXT("EnableBigLba"),
                              0,
                              REG_DWORD,
                              (CONST BYTE *)&dwValue,
                              sizeof(DWORD));
            
            // Close the key
            //
            RegCloseKey(hKey);

            // Return the error if the SetValue failed
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL RemoveTapiSettings
(
    LPTSTR  lpszSysprepINFPath
)
{
    HKEY    hKey;
    DWORD   dwError, dwValue;
    TCHAR   szTapiConfigured[MAX_PATH]  = TEXT("\0"),
            szKeyPath[MAX_PATH]         = TEXT("\0");

    
    if ( ( lpszSysprepINFPath ) && 
         ( *lpszSysprepINFPath ) &&
         ( GetPrivateProfileString( TEXT( "Unattended" ), TEXT( "TapiConfigured" ), TEXT(""), szTapiConfigured, sizeof(szTapiConfigured)/sizeof(TCHAR), lpszSysprepINFPath ) ) )
    {

        // Only if the user specifies No will we remove the registry tapi settings
        //
        if (LSTRCMPI(szTapiConfigured, TEXT("NO")) == 0)
        {
            // Open base key and subkey
            //
            dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey );
            
            // Determine if opening the key was successful
            //
            if(dwError != NO_ERROR)
            {
                SetLastError(dwError);
                return FALSE;
            }
            
            // We enumerate the locations keys and delete any subkeys
            //
            while ( RegEnumKey(hKey, 0, szKeyPath, sizeof(szKeyPath)/sizeof(TCHAR)) == ERROR_SUCCESS )
            {
                // Delete the key and all subkeys
                //
                //
                // NTRAID#NTBUG9-551815-2002/02/26-brucegr: If delete fails, should increment RegEnumKey index
                //
                SHDeleteKey(hKey, szKeyPath) ;
            }

            // Close the key
            //
            RegCloseKey(hKey);
        }
    }

    return TRUE;
}


//
// =================================
// Modify the HKLM\System\Setup\DiskDuplicator Key appropriately.
// =================================
//
BOOL SetOEMDuplicatorString
(
    LPTSTR  lpszSysprepINFPath
)
{
    TCHAR   szOEMDuplicatorString[256];
    DWORD   l;
    HKEY    hKey;

    ZeroMemory(szOEMDuplicatorString, sizeof(szOEMDuplicatorString));

    // See if the DiskDuplicator string is present in the
    // unattend file.
    GetPrivateProfileString( TEXT( "GuiUnattended" ),
                             TEXT( "OEMDuplicatorString" ),
                             L"",
                             szOEMDuplicatorString,
                             sizeof(szOEMDuplicatorString)/sizeof(TCHAR),
                             lpszSysprepINFPath );

    if( szOEMDuplicatorString[0] )
    {
        //
        // ISSUE-2002/02/26-brucegr: This doesn't ensure double termination for REG_MULTI_SZ...
        //
        // Ensure it is not bigger than 255 chars
        szOEMDuplicatorString[255] = TEXT('\0');

        // Open HKLM\System\Setup
        l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\Setup"),
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );

        if(l != NO_ERROR)
        {
            SetLastError(l);
            return FALSE;
        }

        l = RegSetValueEx(hKey,
                          TEXT( "OEMDuplicatorString" ),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)szOEMDuplicatorString,
                          (lstrlen( szOEMDuplicatorString ) + 2) * sizeof(TCHAR));
        RegCloseKey(hKey);
        if(l != NO_ERROR)
        {
            SetLastError(l);
            return FALSE;
        }
    }

    return (TRUE);
}

// Reset OOBE settings so it doesn't think it ran already
//
void ResetOobeSettings()
{
    HKEY hkOobe;
    TCHAR szOobeInfoFile[MAX_PATH];

    // Remove HKLM\Software\Microsoft\Windows\CurrentVersion\Setup\OOBE
    //
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"), &hkOobe)) {
        //
        // ISSUE-2002/02/26-brucegr: Why get lError?  It's not used
        //
        LONG lError = SHDeleteKey(hkOobe, TEXT("OOBE"));
        RegCloseKey(hkOobe);
    }

    // Build the path to oobeinfo.ini if oobe directory exists for personal
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No error checking for GetSystemDirectory
    //
    GetSystemDirectory(szOobeInfoFile, MAX_PATH);
    OPKAddPathN (szOobeInfoFile, TEXT("oobe"), AS ( szOobeInfoFile ) );
    if (PathIsDirectory(szOobeInfoFile)) {
        OPKAddPathN(szOobeInfoFile, TEXT("oobeinfo.ini"), AS ( szOobeInfoFile ) );

        // Remove the RetailOOBE key in oobeinfo.ini
        //
        WritePrivateProfileString(TEXT("StartupOptions"), TEXT("RetailOOBE"), NULL /*Remove it*/, szOobeInfoFile);
    }
}


/*++
===============================================================================
Routine Description:

    This routine will setup the first application to run when the machine
    with the image applied to it is run.

    The first run application will either be setup, in MiniSetup mode, or MSOOBE

    The decision for what it will be is based on the product type.

    For Personal/Professional, MSOOBE
    For Professional, default will be MSOOBE, but can be overriden by the OEM to be
    MiniSetup
    For Server, and DTC, MiniSetup


Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/
BOOL SetupFirstRunApp
(
    void
)
{
    DWORD           dwError;
    DWORD           dwValue;
    HKEY            hKeySetup;
    TCHAR           Value[MAX_PATH + 1]; // +1 is for second NULL char at end of REG_MULTI_SZ reg type
    OSVERSIONINFOEX verInfo;
    BOOL            bUseMSOOBE = FALSE, bPro = FALSE;

    // Open HKLM\System\Setup
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeySetup );

    if(dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }


    // Check the product type, to determine what program we should run
    if (IsPersonalSKU() || (bPro = IsProfessionalSKU())) {
        bUseMSOOBE = TRUE;

        if (bMiniSetup == TRUE && bPro)
            bUseMSOOBE = FALSE;
    }
    else
        bUseMSOOBE = FALSE;

    // Start OOBE on next boot
    //
    if (bUseMSOOBE)
    {
        //
        // ISSUE-2002/02/26-brucegr: If anything fails, machine is screwed.  Should restore settings on failure?
        //

        // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
        dwValue = SETUPTYPE_NOREBOOT;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SetupType"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(DWORD));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // Set these keys for OEM
        //
        dwValue = 1;
        dwError = RegSetValueEx(hKeySetup, TEXT("MiniSetupInProgress"), 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SystemSetupInProgress"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
        dwError = RegSetValueEx(hKeySetup, TEXT("OobeInProgress"), 0, REG_DWORD, (CONST BYTE *)&dwValue, sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // =================================
        // Modify the HKLM\System\Setup\CmdLine key to run MSBOOBE
        // =================================
        ExpandEnvironmentStrings(TEXT("%SystemRoot%\\System32\\oobe\\msoobe.exe /f"), Value, sizeof(Value)/sizeof(Value[0]));
        Value[lstrlen(Value) + 1] = L'\0';

        dwError = RegSetValueEx(hKeySetup,
                          TEXT("CmdLine"),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)Value,
                          (lstrlen( Value ) + 2) * sizeof(TCHAR));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
    }
    else
    {
        //
        // ISSUE-2002/02/26-brucegr: We are duplicating some of the above code again!
        //

        // Start MiniSetup on next boot
        //

        //
        // =================================
        // Modify the HKLM\System\Setup\SetupType Key appropriately (set it to 1 so we
        // go into GUI-mode setup as if this were a full install.
        // =================================
        //
        dwValue= SETUPTYPE;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SetupType"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        //
        // =================================
        // Modify the HKLM\System\Setup\SystemSetupInProgress.
        // =================================
        //
        dwValue = 1;
        dwError = RegSetValueEx(hKeySetup,
                          TEXT("SystemSetupInProgress"),
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dwValue,
                          sizeof(dwValue));

        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // Setup for PnP
        if( PnP )
        {
            dwValue = 1;
            dwError = RegSetValueEx(hKeySetup,
                               TEXT("MiniSetupDoPnP"),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&dwValue,
                               sizeof(dwValue) );
            if(dwError != NO_ERROR)
            {
                RegCloseKey(hKeySetup);
                SetLastError(dwError);
                return FALSE;
            }
        }

        //
        // =================================
        // Create HKLM\System\Setup\MiniSetupInProgress key and set to 1.  This tells LSA to
        // skip generating a new SID.  He wants to because he thinks we're
        // setting up a machine for the first time.  This also tells
        // a few other people (networking, ...) that we're doing a
        // boot into the mini wizard.
        // =================================
        //
        dwValue = 1;
        dwError = RegSetValueEx( hKeySetup,
                           TEXT("MiniSetupInProgress"),
                           0,
                           REG_DWORD,
                           (CONST BYTE *)&dwValue,
                           sizeof(dwValue) );
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }

        // =================================
        // Modify the HKLM\System\Setup\CmdLine key appropriately so we do a mini
        // version of gui-mode setup.
        // =================================

        StringCchCopy (Value, AS ( Value ), TEXT("setup.exe -newsetup -mini"));
        Value[lstrlen(Value) + 1] = L'\0';

        dwError = RegSetValueEx(hKeySetup,
                          TEXT("CmdLine"),
                          0,
                          REG_MULTI_SZ,
                          (CONST BYTE *)Value,
                          (lstrlen( Value ) + 2) * sizeof(TCHAR));
        if(dwError != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(dwError);
            return FALSE;
        }
    }

    RegCloseKey(hKeySetup);
    return (TRUE);
}

BOOL
IsSetupClPresent(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine tests to see if the SID generator is present on the system.
    The SID generator will be required to run on reboot, so if it's not here,
    we need to know.

Arguments:

    None.

Return Value:

    TRUE - The SID generator is present.

    FALSE - The SID generator is not present.

===============================================================================
--*/

{
WCHAR               NewFileName[MAX_PATH];
WCHAR               OldFileName[MAX_PATH];
WIN32_FIND_DATA     findData;
HANDLE              FindHandle;
UINT                OldMode;
DWORD               Error;
WCHAR               *wstr_ptr;


    //
    // First, try and copy a setupcl.exe into the system directory.
    // If there's not one in our current directory, forget about it and
    // keep going.  The user may already have one installed.
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetSystemDirectory failure
    //
    GetSystemDirectory( NewFileName, MAX_PATH );

    StringCchCat( NewFileName, AS ( NewFileName ),  TEXT( "\\" ) );
    StringCchCat( NewFileName, AS ( NewFileName ),  TEXT(SYSCLONE_PART2) );

    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetModuleFileName failure
    //
    GetModuleFileName(NULL,OldFileName,MAX_PATH);
    //
    // ISSUE-2002/02/26-brucegr: Use PathRemoveFileSpec instead of this horrid code
    //
    wstr_ptr = wcsrchr( OldFileName, TEXT( '\\' ) );
    if (wstr_ptr)
        *wstr_ptr = 0;

    StringCchCat( OldFileName, AS ( OldFileName ), TEXT( "\\" ) );
    StringCchCat( OldFileName, AS ( OldFileName ), TEXT(SYSCLONE_PART2) );

    if( !CopyFile( OldFileName, NewFileName, FALSE ) ) {
        Sleep( 500 );
        if( !CopyFile( OldFileName, NewFileName, FALSE ) ) {
            //
            // ISSUE-2002/02/26-brucegr: Why get the error code if we overwrite it below?
            //
            Error = GetLastError();
        }
    }

    //
    // ISSUE-2002/02/26-brucegr: NewFileName should already be constructed... this seems redundant
    //

    //
    // Generate path to the system32 directory, then tack on the
    // name of the SID generator.
    //
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: No checking for GetSystemDirectory failure
    //
    GetSystemDirectory( NewFileName, MAX_PATH );

    StringCchCat( NewFileName, AS ( NewFileName ), TEXT("\\") );
    StringCchCat( NewFileName, AS ( NewFileName ), TEXT(SYSCLONE_PART2) );

    //
    // Now see if he exists...
    //

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // ISSUE-2002/02/26-brucegr: Use GetFileAttributes instead of FindFirstFile
    //

    //
    // See if he's there.
    //
    FindHandle = FindFirstFile( NewFileName, &findData );

    if(FindHandle == INVALID_HANDLE_VALUE) {
        //
        // Nope...
        //
        Error = GetLastError();
    } else {
        //
        // Yep.  Close him.
        //
        FindClose(FindHandle);
        Error = NO_ERROR;
    }

    //
    // Restore error mode.
    //
    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);

}

BOOL FCheckBuildMassStorageSectionFlag(TCHAR* pszSysprepInf)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwReturn = 0;
    BOOL  fReturn = FALSE;

    // If key is missing we default to no, we don't want to build the section
    // but we still process the section if user manually added keys to this
    // section.
    //
    //
    // ISSUE-2002/02/26-brucegr: dwReturn isn't really used
    //
    if (dwReturn = GetPrivateProfileString(SYSPREP_SECTION, SYSPREP_BUILDMASSSTORAGE_KEY,
                            TEXT("NO"), szValue, MAX_PATH, pszSysprepInf))
    {
        if (LSTRCMPI(szValue, TEXT("YES")) == 0)
            fReturn = TRUE;
        else if (LSTRCMPI(szValue, TEXT("NO")) == 0)
            fReturn = FALSE;
    }
    return fReturn;
}

VOID BuildMassStorageSection(BOOL fForceBuild)
{
    LPDEVIDLIST lpDeviceIDList = NULL;
    DWORD       dwNumDevIDs = 0, dwGuids = 0, dwIdxDevIDs = 0;
    TCHAR       szSysPrepInf[MAX_PATH];

    GUID    rgGuids[3];
    TCHAR   *prgInfs[] = { TEXT("machine.inf"), TEXT("pnpscsi.inf"), TEXT("scsi.inf"), TEXT("mshdc.inf") };

    /* Types of mass storage devices GUIDs  */
    rgGuids[0] = GUID_DEVCLASS_SYSTEM;          /* machine.inf  */
    rgGuids[1] = GUID_DEVCLASS_SCSIADAPTER;     /* scsi.inf     */
    rgGuids[2] = GUID_DEVCLASS_HDC;             /* mshdc.inf    */

    /* Only from these inf */
    
    //
    // NTRAID#NTBUG9-551815-2002/02/26-brucegr: Need to check GetModuleFileName return value
    //
    GetModuleFileName(NULL, szSysPrepInf, MAX_PATH);
    PathRemoveFileSpec(szSysPrepInf);
    OPKAddPathN ( szSysPrepInf, TEXT("sysprep.inf"), AS ( szSysPrepInf ) );

    // Only build if user requested it
    //
    if (!fForceBuild && !FCheckBuildMassStorageSectionFlag(szSysPrepInf))
        return;

    //
    // =================================
    // Remove [sysprepcleanup] which will be added during PopulateDeviceDatabase().
    // =================================
    //
    WritePrivateProfileSection(L"sysprepcleanup", NULL, szSysPrepInf);

    // Loop thru all the mass storage devices
    //
    for (dwGuids = 0; dwGuids < (sizeof(rgGuids) / sizeof(rgGuids[0])); dwGuids++) {
        // Build a list of mass storage devices
        //
        if (BuildDeviceIDList(SYSPREPMASSSTORAGE_SECTION,
                           szSysPrepInf,
                           (LPGUID)&rgGuids[dwGuids],
                           &lpDeviceIDList,
                           &dwNumDevIDs,
                           TRUE,
                           FALSE))
        {
            // Write the mass storage info to sysprep.inf
            //
            for(dwIdxDevIDs = 0; dwIdxDevIDs < dwNumDevIDs; ++dwIdxDevIDs)
            {
                BOOL fInfFound = FALSE;

                // Check if this inf if in our Infs table
                //
                int iCmp = 0;
                for (iCmp = 0; iCmp < (sizeof(prgInfs)/sizeof(prgInfs[0])); iCmp++) {
                    //
                    // ISSUE-2002/02/26-brucegr: Can we use something better than StrStrI?
                    //
                    if (StrStrI(lpDeviceIDList[dwIdxDevIDs].szINFFileName, prgInfs[iCmp])) {
                        fInfFound = TRUE;
                        break;
                    }
                }

                if (fInfFound) 
                {
                    // Check HardwareID first then check the CompatID
                    //
                    if (lpDeviceIDList[dwIdxDevIDs].szHardwareID[0]) 
                    {
                        // Use only the infs we care about
                        //
                        WritePrivateProfileString(SYSPREPMASSSTORAGE_SECTION,
                                                  lpDeviceIDList[dwIdxDevIDs].szHardwareID,
                                                  lpDeviceIDList[dwIdxDevIDs].szINFFileName,
                                                  szSysPrepInf);
                    }
                    else if (lpDeviceIDList[dwIdxDevIDs].szCompatibleID[0])
                    {
                        // Use only the infs we care about
                        //
                        WritePrivateProfileString(SYSPREPMASSSTORAGE_SECTION,
                                                  lpDeviceIDList[dwIdxDevIDs].szCompatibleID,
                                                  lpDeviceIDList[dwIdxDevIDs].szINFFileName,
                                                  szSysPrepInf);
                    }
                }
            }

            // Free the allocated list
            //
            LocalFree(lpDeviceIDList);
        }
    }
}

DWORD
ReArm(
      VOID
      )
/*++
===============================================================================
Routine Description:

    This routine returns either the error code or success.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - ReArm succeeded and shortcut restored.

    Error code    - ReArm failed.

===============================================================================
--*/

{
    DWORD     dwError     = ERROR_FILE_NOT_FOUND;
    BYTE      bDummy      = 1;

    typedef DWORD (WINAPI* MYPROC)(BYTE*);

    // Use Loadlibrary/GetProcAddress because Riprep needs to support Windows 2000 
    //
    HINSTANCE   hInst   = LoadLibrary(L"syssetup.dll");
    if (hInst) {
        MYPROC fnProc;
        if ( fnProc = (MYPROC)GetProcAddress(hInst, "SetupOobeBnk") ) {
            dwError = fnProc(&bDummy);
        }

        FreeLibrary(hInst);
    }

    // Return error code or success
    //
    return dwError;
}


BOOL FCommonReseal
    (
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine is the common reseal code for both Riprep and Sysprep.

Arguments:

    None.

Return Value:

    TRUE  - success
    FALSE - failure

Remarks:

    This routine should only cleanup registry keys as it is being called by
    AdjustRegistry() which is the last step of Riprep after the network is
    removed.

===============================================================================
--*/

{
    HKEY hKey = NULL;
    SC_HANDLE schService;
    SC_HANDLE schSystem;
    TCHAR szUrllog[MAX_PATH];
    DWORD dwLen;

    //
    // ISSUE-2002/02/26-brucegr: Make sure all intermediate return points are necessary!
    //

    //
    // =================================
    // Clear the MRU list on the machine.
    // =================================
    //
    NukeMruList();

    //
    // =================================
    // Clear recent apps
    // =================================
    //

    ClearRecentApps();

    //
    // =================================
    // Delete User Specific Settings from all user profiles.
    // =================================
    //

    NukeUserSettings();

    //
    // =================================
    // Remove HKLM\System\MountedDevices key.
    // =================================
    //
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   TEXT("System"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) ) 
    {
        RegDeleteKey(hKey, TEXT("MountedDevices"));
        RegCloseKey(hKey);
    }

    //
    // =================================
    // Remove Desktop Cleanup wizard registry key to reset cleanup timer
    // =================================
    //
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_CURRENT_USER,
                                   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\CleanupWiz"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) )
    {
        RegDeleteValue(hKey, TEXT("Last used time"));
        RegCloseKey(hKey);
    }
  
    //
    // =================================
    // Windows Update Cleanup
    //
    // Do all of the following during SYSPREP -reseal before the system is rebooted:
    //
    // 1) stop the WUAUSERV service
    // 2) delete %ProgramFiles%\WindowsUpdate\urllog.dat (note WindowsUpdate is a hiiden directory.  I don't believe this will cause any issues).
    // 3) remove the following registry entries under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate
    //    Delete value/data pair: PingID
    //    DO NOT DELETE key subtree: Auto Update
    //    Delete value/data pair: Auto Update\AUState
    //    Delete value/data pair: Auto Update\LastWaitTimeout
    //    Delete key subtree: IUControl
    //    Delete key subtree: OemInfo  
    // =================================
    //
    // 1) stop the WUAUSERV service
    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if (schSystem)
    {
        schService = OpenService( schSystem,
                                  TEXT("WUAUSERV"),
                                  SC_MANAGER_ALL_ACCESS);
        if ( schService )
        {
            SERVICE_STATUS ss;
            ControlService( schService, SERVICE_CONTROL_STOP, &ss );
            CloseServiceHandle( schService );
        }
        CloseServiceHandle( schSystem );
    }

    // 2) delete %ProgramFiles%\WindowsUpdate\urllog.dat (note WindowsUpdate is a hiiden directory.  I don't believe this will cause any issues).
    dwLen=ExpandEnvironmentStrings(TEXT("%ProgramFiles%\\WindowsUpdate\\urllog.dat"),szUrllog,MAX_PATH);
    if (dwLen && dwLen < MAX_PATH)
        DeleteFile(szUrllog);

    // 3) remove the following registry entries under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate
    //    Delete value/data pair: PingID
    //    DO NOT DELETE key subtree: Auto Update
    //    Delete value/data pair: Auto Update\AUState
    //    Delete value/data pair: Auto Update\LastWaitTimeout
    //    Delete key subtree: IUControl
    //    Delete key subtree: OemInfo  
    if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"),
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey)) )
    {
        RegDeleteValue(hKey, TEXT("PingID"));
        RegDeleteValue(hKey, TEXT("Auto Update\\AUState"));
        RegDeleteValue(hKey, TEXT("Auto Update\\LastWaitTimeout"));
        RegDeleteKey(hKey, TEXT("IUControl"));
        RegDeleteKey(hKey, TEXT("OemInfo"));
        RegCloseKey(hKey);
    }
    
    //
    // =================================
    // Modify any install paths that may be required
    // for our reboot into gui-mode.
    // =================================
    //
    FixDevicePaths();

    //
    // =================================
    // Clear out winlogon's memory of the last user and domain.
    // =================================
    //
    if( !DeleteWinlogonDefaults() ) {
        return FALSE;
    }

    // Remove Cryptography key so it gets re-generated, only do this if the SIDS have been regenerated
    //
    if ( !NoSidGen )
    {
        if ( NO_ERROR == (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("SOFTWARE\\Microsoft\\Cryptography"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKey)) )
        {
            RegDeleteValue(hKey, TEXT("MachineGuid"));
            RegCloseKey(hKey);
        }
    }

    // Set the cloned tag in the registry
    if (!SetCloneTag())
        return FALSE;

    // Sets whether msoobe or mini-setup on first end user boot
    //
    if (!SetupFirstRunApp())
        return FALSE;

    //
    // =================================
    // Clear the LastKnownGood ControlSet.
    // =================================
    //
    if (NO_ERROR != NukeLKGControlSet())
        return FALSE;

    //
    // =================================
    // Clear the eventlogs on the machine.
    // This is the last thing that we should do.
    // =================================
    //
    NukeEventLogs();

    // Common reseal succeeded
    //
    return TRUE;
}

BOOL
AdjustFiles(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine allows cleanup to happen before files are copied to the server
    by Riprep.  

Arguments:

    None.

Return Value:

    None.

Remarks:
    
    This routine should be called before AdjustRegistry() for Riprep.  Sysprep 
    needs to call this before FCommonReseal(). 

===============================================================================
--*/
{
    BOOL bUseMSOOBE = FALSE, 
         bPro = FALSE,
         fReturn = TRUE;

    TCHAR szSysprepFolder[MAX_PATH] = TEXT("\0");

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    //
    // Check the product type.
    //
    if (IsPersonalSKU() || (bPro = IsProfessionalSKU())) {
        bUseMSOOBE = TRUE;

        if (bMiniSetup == TRUE && bPro)
            bUseMSOOBE = FALSE;
    }
    else
        bUseMSOOBE = FALSE;

    if (bUseMSOOBE)
    {
        //
        // Prepare for Oobe
        //
    }
    else
    {
        //
        // Prepare for MiniSetup
        //
    }

    //
    // =================================
    // Clear the SMS settings and INI file.
    // =================================
    //
    NukeSmsSettings();

    //
    // =================================
    // Clean up Digital Rights Media information.
    // =================================
    //
    
#if !(defined(AMD64) || defined(IA64))
    //
    // This only works on x86. There is no 64-bit library available for us
    // to call into right now.
    //
    if ( GetWindowsDirectory(szSysprepFolder, sizeof(szSysprepFolder)/sizeof(szSysprepFolder[0])) )
    {
        CHAR szLogFileA[MAX_PATH];
        BOOL bLog = TRUE;

        // This will look something like this: "c:\windows".  Make the character after the '\' NULL, and 
        // append the name of the file to it.
        //
        szSysprepFolder[3] = UNICODE_NULL;
        PathAppend(szSysprepFolder, TEXT("SYSPREP"));
             
        // Create the folder if it does not exist
        //
        if ( !PathFileExists(szSysprepFolder) ) 
        {
            bLog = CreateDirectory(szSysprepFolder, NULL);
        }
        
        PathAppend(szSysprepFolder, CLEANDRM_LOGFILE);

        // Convert UNICODE string to ANSI string.
        //
        if ( WideCharToMultiByte(CP_ACP, 0, szSysprepFolder, -1, szLogFileA, sizeof(szLogFileA), NULL, NULL) )
        {
            CleanDRM( bLog ? szLogFileA : NULL );
        }
        else 
        {
            fReturn = FALSE;
        }
    }
    else 
    {
        fReturn = FALSE;
    }


               
#endif // #if !(defined(AMD64) || defined(IA64))

    //
    // =================================
    // Clear OOBE settings for both minisetup and oobe.
    // =================================
    //
    ResetOobeSettings();

    //
    // =================================
    // Clear the eventlogs on the machine.
    // This is the last thing that we should do.
    // =================================
    //
    NukeEventLogs();

    //
    // =================================
    // Delete temporary files.
    // =================================
    //

    NukeTemporaryFiles();

    return fReturn;
}

BOOL
AdjustRegistry(
    IN BOOL fRemoveNetworkSettings
    )

/*++
===============================================================================
Routine Description:

    This routine actually adds in the registry entry to enable our second half
    to execute.

Arguments:

    fRemoveNetworkSettings - indicates if network settings should be removed

Return Value:

    None

===============================================================================
--*/

{
    HKEY            hKey;
    TCHAR           szSysprepINFPath[MAX_PATH];
    BOOL            fPopulated = FALSE;

    // Formulate the path to SYSPRE.INF, since we will need it later to look up
    // sysprep options
    if (!GetWindowsDirectory( szSysprepINFPath, MAX_PATH ))
        return FALSE;

    StringCchCopy ( &szSysprepINFPath[3], AS ( szSysprepINFPath ) - 3, TEXT("sysprep\\sysprep.inf") );

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // Set OEMDuplicatorString
    if (!SetOEMDuplicatorString(szSysprepINFPath))
        return (FALSE);

    // Fill in the [sysprepMassStorage] section for PopulateDeviceDatabase()
    //
    BuildMassStorageSection(FALSE);

    //
    // =================================
    // Fixup boot devices.
    // =================================
    //
    if (!PopulateDeviceDatabase(&fPopulated))
        return FALSE;

    //
    // Perform miscellaneous registry modifications
    //
	
    // Determine if we should set the BigLba support in registry
    //
    if ( !SetBigLbaSupport(szSysprepINFPath) )
    {
        return FALSE;
    }
    
    // Determine if we should remove the TAPI settings in registry
    //
    if ( !RemoveTapiSettings(szSysprepINFPath) )
    {
        return FALSE;
    }
    
    //
    // Remove the LastAliveStamp value so that we don't get erroneous entries into the even log
    // and avoid pop-ups on first boot saying that the machine has been shutdown improperly.
    //
    if ( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, STR_REG_KEY_RELIABILITY, &hKey) )
    {
        RegDeleteValue(hKey, STR_REG_VALUE_LASTALIVESTAMP);
        RegCloseKey(hKey);
    }

    //
    // =================================
    // Reset network settings last so if any errors happen before we still
    // have network access.
    // =================================
    //
    if (fRemoveNetworkSettings)
    {
        if (!RemoveNetworkSettings(szSysprepINFPath))
            return FALSE;
    }


    //
    // =================================
    // Change our boot timeout to 1.
    // =================================
    //
    ChangeBootTimeout( 1 );

    // Do common reseal code for both Sysprep and Riprep
    //
    if (!FCommonReseal())
        return FALSE;

    return TRUE;

}

BOOL 
CreateSysprepTemporaryDevnode(
    HDEVINFO*        phDevInfo, 
    SP_DEVINFO_DATA* pDeviceInfoData
    )
/*++
===============================================================================
Routine Description:

Arguments:

    None.

Return Value:

    TRUE if everything is OK, FALSE otherwise.

Assumptions:

    1. No HardwareID exceeds MAX_PATH characters.

===============================================================================
--*/
{
    if (phDevInfo) {
        //
        // Create a dummy devnode
        //
        *phDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
        if (*phDevInfo == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // Initialize the DriverInfoData struct
        //
        pDeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Create the devnode
        //
        if (pDeviceInfoData && !SetupDiCreateDeviceInfo(*phDevInfo,
                                     L"SYSPREP_TEMPORARY",
                                     (LPGUID)&GUID_NULL,
                                     NULL,
                                     NULL,
                                     DICD_GENERATE_ID,
                                     pDeviceInfoData)) {
            //
            // ISSUE-2002/02/26-brucegr: Destroy the info list and set phDevInfo to INVALID_HANDLE_VALUE?
            //
            return FALSE;
        }
    }
        
    return TRUE;
}

BOOL InsertCleanupNode(PPCLEANUP_NODE ppCleanupList, PCLEANUP_NODE pAddNode)
{
    PPCLEANUP_NODE ppl = ppCleanupList;
    while ( *ppl != NULL && (0 < lstrcmpi(pAddNode->pszService, (*ppl)->pszService))
          )
    {
        ppl = &((*ppl)->pNext);
    }
    if (*ppl && (0 == lstrcmpi(pAddNode->pszService, (*ppl)->pszService)))
    {
        free(pAddNode);
        return FALSE;
    }

    pAddNode->pNext = *ppl;
    *ppl = pAddNode;
    return TRUE;
}

PCLEANUP_NODE FindCleanupNode(PPCLEANUP_NODE ppCleanupList, LPTSTR pszServiceName)
{
    PCLEANUP_NODE pTemp = *ppCleanupList;
    while (pTemp) 
    {
        if (0 == lstrcmpi(pTemp->pszService, pszServiceName))
            return pTemp;

        pTemp = pTemp->pNext;
    }
    return NULL;
}

void FreeCleanupList(PPCLEANUP_NODE ppCleanupList)
{
    while (*ppCleanupList) 
    {
        PCLEANUP_NODE pTemp = *ppCleanupList;
        *ppCleanupList = (*ppCleanupList)->pNext;

        free(pTemp->pszService);
        free(pTemp);
    }
    *ppCleanupList = NULL;
}

BOOL AddCleanupNode(
    LPTSTR pszServiceName 
    )
/*++
===============================================================================
Routine Description:
    
    When populating the [SysprepCleanup] section we need to check if the service
    or filters already exists in the this section before we enter a duplicate
    entry.

Arguments:

    LPTSTR pszServiceName  - Service/Filter name.

Return Value:

    TRUE if a duplicate found, FALSE otherwise.

Assumptions:

    1. No duplicate entries in [SysprepCleanup] section.

===============================================================================
--*/
{
    BOOL fAdded = FALSE;

    // 
    // Find the Service in our list.
    //
    if (pszServiceName && (NULL == FindCleanupNode(&g_pCleanupListHead, pszServiceName))) 
    {
        PCLEANUP_NODE pNode = (PCLEANUP_NODE)malloc(sizeof(CLEANUP_NODE));
        if (pNode) 
        {
            int nLen = lstrlen ( pszServiceName ) + 1;
            pNode->pszService = (LPTSTR)malloc( nLen  * sizeof ( TCHAR ) );

            if ( pNode->pszService ) 
            {
                StringCchCopy (pNode->pszService, nLen, pszServiceName);
            }
            pNode->pNext = NULL;
       
            // 
            // We didn't find it so add it to our list.  
            // We will not add duplicates to our list.
            //
            fAdded = InsertCleanupNode(&g_pCleanupListHead, pNode);        
        }
    }
    
    return fAdded;
}

BOOL
PopulateDeviceDatabase(
    IN BOOL* pfPopulated
    )
/*++
===============================================================================
Routine Description:

    Parse the [SysprepMassStorage] section in the sysprep.inf file and
    populate the critical device database with the specified devices to ensure
    that we can boot into the miniwizard when moving the image to a target
    system with different boot storage devices.

    The installed services/upperfilters/lowerfilters will be recorded, so
    that on the next boot into the mini-wizard those without an associated
    device will be disabled (the cleanup stage) in order not to unnecessarily
    degrade Windows start time.

Arguments:

    None.

Return Value:

    TRUE if everything is OK, FALSE otherwise.

Assumptions:

    1. No HardwareID exceeds MAX_PATH characters.

    2. No field on a line in the [SysprepMassStorage] section exceeds MAX_PATH
       characters.

    3. No service's/upperfilter's/lowerfilter's name exceeds MAX_PATH characters.

    4. DirectoryOnSourceDevice, source DiskDescription, or source DiskTag
       (applying to vendor-supplied drivers) cannot exceed MAX_PATH characters.
===============================================================================
--*/

{
    BOOL                 bAllOK = TRUE;
    PCWSTR               pszSectionName = L"SysprepMassStorage";
    WCHAR                szSysprepInfFile[] = L"?:\\sysprep\\sysprep.inf";
#ifdef DEBUG_LOGLOG
    WCHAR                szLogFile[] = L"?:\\sysprep.log";
#endif
    WCHAR                szBuffer[MAX_PATH], *pszFilter;
    CHAR                 szOutBufferA[MAX_PATH];
    HANDLE               hInfFile = INVALID_HANDLE_VALUE;
    HINF                 hAnswerInf = INVALID_HANDLE_VALUE;
    BOOL                 bLineExists;
    INFCONTEXT           InfContext;
    HDEVINFO             hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA      DeviceInfoData;
    SP_DEVINSTALL_PARAMS DevInstallParams;
    SP_DRVINFO_DATA      DriverInfoData;
    HSPFILEQ             QueueHandle = INVALID_HANDLE_VALUE;
    DWORD                dwSize = 0;
    BOOL                 bNodeCreated = FALSE;
    WCHAR                DirectoryOnSourceDevice[MAX_PATH];
    WCHAR                DiskDescription[MAX_PATH];
    WCHAR                DiskTag[MAX_PATH];
    PSYSPREP_QUEUE_CONTEXT pSysprepContext;


    if (!GetWindowsDirectory(szBuffer, MAX_PATH))
        return FALSE;

    szSysprepInfFile[0] = szBuffer[0];

#ifdef DEBUG_LOGLOG
    szLogFile[0] = szBuffer[0];
    DeleteFile(szLogFile);
    LOG_Init(szLogFile);
    LOG_Write(L">>\r\n>> PopulateDeviceDatabase\r\n>>\r\n");
    LOG_Write(L"Sysprep.inf=%s", szSysprepInfFile);
#endif





    //
    // =================================
    // Open the sysprep.inf file.  Since we don't know what the user has in
    // here, so try opening as both styles.
    // =================================
    //

    //
    // ISSUE-2002/02/26-brucegr: You can specify both bits in one call...
    //
    hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_WIN4, NULL);
    if (hAnswerInf == INVALID_HANDLE_VALUE) {
        hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_OLDNT, NULL);
        if (hAnswerInf == INVALID_HANDLE_VALUE) {

            //
            // User didn't give us a sysprep.inf.  Return as if nothing
            // happened.
            //
            return TRUE;
        }
    }


    //
    // open the same inf file to record upper filters, lower filters, and
    // services of the added devices
    //
    hInfFile = CreateFile(szSysprepInfFile,
                          GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                          NULL);
    if (hInfFile == INVALID_HANDLE_VALUE) {
        goto PDD_Critical_Error_Handler;
    }

    //
    // =================================
    // Create/clear [sysprepcleanup] which should be at the bottom of the file.
    // =================================
    //
    WritePrivateProfileSection(L"sysprepcleanup", L"", szSysprepInfFile);


    //
    // =================================
    // Create a dummy devnode
    // =================================
    //

    bNodeCreated = CreateSysprepTemporaryDevnode(&hDevInfo, &DeviceInfoData);

    // Initialize the DriverInfoData struct
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!bNodeCreated)
        goto PDD_Critical_Error_Handler;

    //
    // =================================
    // Process each line in our section.  Each line should look like:
    // <hardware-id>=<inf pathname>
    // or in the case of drivers that aren't on the product CD:
    // <hardware-id>=<inf pathname>,<directory on recovery floppy>,<description of recovery floppy>,<disk tag of recovery floppy>
    //
    // If we see an entry like this, we'll know that in the case of system recovery, the
    // file should be retrived from a floppy, and not the Windows CD.
    // =================================
    //

    bLineExists = SetupFindFirstLine(hAnswerInf, pszSectionName, NULL, &InfContext);

    //
    // =================================
    // Let caller know we've go entries to populate.
    // =================================
    //
    if (pfPopulated)
        *pfPopulated = bLineExists;

    while (bLineExists) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"");
#endif


        //
        // =================================
        // Step 1: Set the hardwareID of the devnode.
        // =================================
        //

        //
        // retrieve the hardwareID from the line
        //
        ZeroMemory( szBuffer, sizeof(szBuffer) );
        dwSize = MAX_PATH - 2;

        if (!SetupGetStringField(&InfContext, 0, szBuffer, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"HardwareID=%s", szBuffer);
#endif

        //
        // and then set it to the devnode,
        //
        if ( !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                                &DeviceInfoData,
                                                SPDRP_HARDWAREID,
                                                (PBYTE)szBuffer,
                                                (lstrlen(szBuffer) + 2) * sizeof(WCHAR) ) ) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            // If someone removed the devnode, we need to re-create it and repeat this pnp device
            //
            if (ERROR_NO_SUCH_DEVINST == GetLastError()) {                

                // Re-create the SYSPREP_TEMPORARY devnode again
                //
                bAllOK = CreateSysprepTemporaryDevnode(&hDevInfo, &DeviceInfoData);
                bNodeCreated = bAllOK;

                // Set the hardwareID again
                //
                //
                // NTRAID#NTBUG9-551868-2002/02/26-brucegr: Need to increase size parameter by one WCHAR
                //
                if ( bNodeCreated && 
                     !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                                        &DeviceInfoData,
                                                        SPDRP_HARDWAREID,
                                                        (PBYTE)szBuffer,
                                                        ( lstrlen(szBuffer) + 2 ) * sizeof(WCHAR) ) ) {
                    // We failed again, then quit 
                    //
                    bAllOK = FALSE;
                    goto PDD_Critical_Error_Handler;
                }
            }
            else {
                bAllOK = FALSE;
                goto PDD_Next_Inf_Line;
            }
        }

        //
        // make sure that there's no existing compatible list, since we're reusing
        // the dummy devnode
        //
        if (!SetupDiDestroyDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Build the SP_DEVINSTALL_PARAMS for this node.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if (!SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // set the Flags field: only search the INF file specified in DriverPath field;
        // don't create a copy queue, use the provided one in FileQueue; don't call the
        // Configuration Manager while populating the CriticalDeviceDatabase.
        //
        DevInstallParams.Flags |= DI_ENUMSINGLEINF;
        DevInstallParams.Flags |= DI_NOVCP;
        DevInstallParams.Flags |= DI_DONOTCALLCONFIGMG;

        //
        // set the file queue field
        //
        QueueHandle = SetupOpenFileQueue();
        if (QueueHandle == INVALID_HANDLE_VALUE) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }
        DevInstallParams.FileQueue = QueueHandle;

        //
        // set the device's inf pathname
        //
        dwSize = MAX_PATH;
        if (!SetupGetStringField(&InfContext, 1, szBuffer, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }
        ExpandEnvironmentStrings(szBuffer, DevInstallParams.DriverPath, MAX_PATH);

#ifdef DEBUG_LOGLOG
        LOG_Write(L"DriverPath=%s", DevInstallParams.DriverPath);
#endif

        if (!SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Register the newly created device instance with the PnP Manager.
        //
        if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 2: Perform a compatible driver search.
        // =================================
        //

        if (!SetupDiBuildDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        // Make sure there is at least 1 compat driver for this device.
        // If there is not, and then we just process the next one in the list
        if (!SetupDiEnumDriverInfo(hDevInfo,
                                   &DeviceInfoData,
                                   SPDIT_COMPATDRIVER,
                                   0,
                                   &DriverInfoData))
        {
            // Check to see what the error was. Any error other than ERROR_NO_MORE_ITEMS
            // will be flaged, by setting the bAllOK return value to FALSE
            if (ERROR_NO_MORE_ITEMS != GetLastError())
            {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
            }
            goto PDD_Next_Inf_Line;
        }

        //
        // =================================
        // Step 3: Select the best compatible driver.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 4: Install the driver files.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Need to commit the file queue here, so the later steps can properly
        // be executed in case the device doesn't use the already existing
        // coinstaller(s).
        //
        pSysprepContext = (PSYSPREP_QUEUE_CONTEXT) InitSysprepQueueCallback();

        //
        // Retrieve DirectoryOnSourceDevice from the inf line, if any
        //
        dwSize = MAX_PATH;
        DirectoryOnSourceDevice[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 2, DirectoryOnSourceDevice, dwSize, &dwSize)) {
            DirectoryOnSourceDevice[0] = L'\0';
        }
        if (DirectoryOnSourceDevice[0] != L'\0') {
            pSysprepContext->DirectoryOnSourceDevice = DirectoryOnSourceDevice;
        }

        //
        // Retrieve DiskDescription from the inf line, if any
        //
        dwSize = MAX_PATH;
        DiskDescription[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 3, DiskDescription, dwSize, &dwSize)) {
            DiskDescription[0] = L'\0';
        }
        if (DiskDescription[0] != L'\0') {
            pSysprepContext->DiskDescription = DiskDescription;
        }

        //
        // Retrieve DiskTag from the inf line, if any
        //
        dwSize = MAX_PATH;
        DiskTag[0] = L'\0';
        if (!SetupGetStringField(&InfContext, 4, DiskTag, dwSize, &dwSize)) {
            DiskTag[0] = L'\0';
        }
        if (DiskTag[0] != L'\0') {
            pSysprepContext->DiskTag = DiskTag;
        }

        //
        // Commit the file queue
        //
        if (!SetupCommitFileQueue(NULL,
                                  QueueHandle,
                                  SysprepQueueCallback,
                                  pSysprepContext)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
        }
        FreeSysprepContext(pSysprepContext);

        // 
        // =================================
        // Step 4a: Dis-associate file copy queue before we close
        //          the queue.
        // =================================
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if (!SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        //
        // Remove the DI_NOVCP flag and NULL out the FileQueue.
        //
        DevInstallParams.Flags &= ~DI_NOVCP;
        DevInstallParams.FileQueue = NULL;
        if (!SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }

        SetupCloseFileQueue(QueueHandle);
        QueueHandle = INVALID_HANDLE_VALUE;





        //
        // =================================
        // Step 5: Register the device-specific coinstallers.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 6: Install the device.
        // =================================
        //

        if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                       hDevInfo,
                                       &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto PDD_Next_Inf_Line;
        }





        //
        // =================================
        // Step 7: Retrieve upper filters, lower filters,
        //         and controlling service, save them back
        //         to the inf file.
        // =================================
        //

        //
        // retrieve device upperfilters (REG_MULTI_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_UPPERFILTERS,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        for (pszFilter = szBuffer; *pszFilter; pszFilter += (lstrlen(pszFilter) + 1)) {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Upperfilter=%S\r\n", pszFilter);
            if (AddCleanupNode(pszFilter)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Upperfilter=%s", pszFilter);
#endif
        }

        //
        // retrieve device lowerfilters (REG_MULTI_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_LOWERFILTERS,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        for (pszFilter = szBuffer; *pszFilter; pszFilter += (lstrlen(pszFilter) + 1)) {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Lowerfilter=%S\r\n", pszFilter);
            if (AddCleanupNode(pszFilter)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Lowerfilter=%s", pszFilter);
#endif
        }

        //
        // retrieve device its controlling service (REG_SZ)
        //
        if (!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                              &DeviceInfoData,
                                              SPDRP_SERVICE,
                                              NULL,
                                              (PBYTE)szBuffer,
                                              sizeof(szBuffer),
                                              NULL)) {
            szBuffer[0] = L'\0';
        }

        if (szBuffer[0] != L'\0') {
            StringCchPrintfA(szOutBufferA, AS ( szOutBufferA ), "Service=%S\r\n", szBuffer);
            if (AddCleanupNode(szBuffer)) {
                SetFilePointer(hInfFile, 0L, 0L, FILE_END);
                WriteFile(hInfFile, szOutBufferA, strlen(szOutBufferA), &dwSize, NULL);
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service=%s", szBuffer);
#endif
        }

PDD_Next_Inf_Line:

        if (QueueHandle != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(QueueHandle);
            QueueHandle = INVALID_HANDLE_VALUE;
        }

        //
        // Get the next line from the relevant section in the inf file.
        //
        bLineExists = SetupFindNextLine(&InfContext, &InfContext);
    }





    //
    // =================================
    // Cleanup for a successful run
    // =================================
    //

    //
    // remove the SYSPREP_TEMPORARY node under Root
    //
    SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData);

    SetupDiDestroyDeviceInfoList(hDevInfo);

    CloseHandle(hInfFile);

    SetupCloseInfFile(hAnswerInf);

    //
    // Backup the system hive to the Repair folder
    //
    if (!BackupHives()) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"ERROR - Unable to backup the system hive.");
#endif
        bAllOK = FALSE;
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    FreeCleanupList(&g_pCleanupListHead);

    return bAllOK;





//
// =================================
PDD_Critical_Error_Handler:
// =================================
//

#ifdef DEBUG_LOGLOG
    LOG_WriteLastError();
#endif

    if (QueueHandle != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(QueueHandle);
    }

    //
    // remove the SYSPREP_TEMPORARY node under Root
    //
    if (bNodeCreated) {
        SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData);
    }

    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    if (hInfFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hInfFile);
    }

    if (hAnswerInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hAnswerInf);
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    FreeCleanupList(&g_pCleanupListHead);

    return FALSE;
}

/*++
===============================================================================
Routine Description:

    Check to see if the service name passed in is in use by a PnP enumerated
    device.

Arguments:

    lpszServiceName

Return Value:

    TRUE.   The service is in use, or will be in use by a device (as evidenced by
            the presence of the service name as a registry property for an enumerated
            device)

    FALSE.  The service is not in use.
            If LastError is set, then a bad thing happed, otherwise the service is
            just not being used

Assumptions:

===============================================================================
--*/
BOOL ServiceInUseByDevice
(
    LPTSTR  lpszServiceName
)
{
    HDEVINFO            DeviceInfoSet;
    HDEVINFO            NewDeviceInfoSet;
    DWORD               i;
    SP_DEVINFO_DATA     DevInfoData;
    TCHAR               szServiceName[MAX_PATH];
    TCHAR               szDeviceClass[MAX_PATH];
    BOOL                bRet = FALSE;
    TCHAR               szLegacyClass[MAX_CLASS_NAME_LEN];

    // Clear the last error
    SetLastError(0);

    // Get the Class description for LegacyDriver
    if (!SetupDiClassNameFromGuid(&GUID_DEVCLASS_LEGACYDRIVER,
                                  szLegacyClass,
                                  sizeof(szLegacyClass)/sizeof(TCHAR),
                                  NULL))
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to get LegacyDriver Class NAME");
#endif
        // NOTE: LastError will be set to the appropriate error code by
        // SetupDiGetClassDescription
        return FALSE;
    }


    // Create a device information set that will be used to enumerate all
    // present devices
    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to Create a device info list");
#endif
        SetLastError(E_FAIL);
        return FALSE;
    }

    // Get a list of all present devices on the system
    NewDeviceInfoSet = SetupDiGetClassDevsEx(NULL,
                                             NULL,
                                             NULL,
                                             DIGCF_PRESENT | DIGCF_ALLCLASSES,
                                             DeviceInfoSet,
                                             NULL,
                                             NULL);

    if(NewDeviceInfoSet == INVALID_HANDLE_VALUE)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Unable to enumerate present devices");
#endif
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        SetLastError(E_FAIL);
        return FALSE;
    }

    // Enumerate the list of devices, checking to see if the service listed in the
    // registry matches the service we are interested in.
    i = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    while (SetupDiEnumDeviceInfo(NewDeviceInfoSet, i, &DevInfoData))
    {
        // See if this is devnode is using the service we care about.
        // if so, then we will check to see if it is a legacy devnode. If it
        // is NOT a legacy devnode, then we will not mess with it, because
        // the service is in use by a real device.
        if (SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                             &DevInfoData,
                                             SPDRP_SERVICE,
                                             NULL,
                                             (PBYTE) szServiceName,
                                             sizeof(szServiceName),
                                             NULL))
        {
            // See if this is the service we are looking for
            if (0 == lstrcmpiW(lpszServiceName, szServiceName))
            {
                // Check for a legacy class device
                if (SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                                     &DevInfoData,
                                                     SPDRP_CLASS,
                                                     NULL,
                                                     (PBYTE) szDeviceClass,
                                                     sizeof(szDeviceClass),
                                                     NULL))
                {
                    // We have the class, lets see if it is a legacy device
                    if (0 != lstrcmpiW(szLegacyClass, szDeviceClass))
                    {
                        // it is NOT a legacy device, so this service is in use!
                        bRet = TRUE;
                        break;
                    }
                }
                else
                {
                    // We don't know the class, but it is not legacy (otherwise we
                    // would have gotten the class returned above, so assume it is
                    // is use!
                    bRet = TRUE;
                    break;
                }
            }
        }
        ++i;
    }

    // Clean up the device info sets that were allocated
    SetupDiDestroyDeviceInfoList(NewDeviceInfoSet);
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return bRet;
}

BOOL
CleanDeviceDatabase(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Parse the [SysprepCleanup] section in the sysprep.inf file, which was
    created during the PopulateDeviceDatabase stage, and disable those
    listed services/upperfilters/lowerfilters which don't have associated
    physical devices.

    The strategy here is that we try to stop each listed service/upperfilter/
    lowerfilter.  It will only be stopped if it's not currently running (so
    not controlling a PnP devnode), or is associated with a legacy devnode
    (Root\LEGACY_<SvcName>\0000).  Once it can be stopped, we can safely
    disable it.

Arguments:

    None.

Return Value:

    TRUE.   No errors encountered

    FALSE.  Some error occurred.  It's not likely that the call will be able
            to do much though.

Assumptions:

    1. All listed services/upperfilters/lowerfilters have no dependencies.

    2. No service's/upperfilter's/lowerfilter's name exceeds MAX_PATH characters.
===============================================================================
--*/

{
    BOOL             bAllOK = TRUE;
    PCWSTR           pszSectionName = L"SysprepCleanup";
    WCHAR            szSysprepInfFile[] = L"?:\\sysprep\\sysprep.inf";
#ifdef DEBUG_LOGLOG
    WCHAR            szLogFile[] = L"?:\\sysprep.log";
#endif
    WCHAR            szServiceName[MAX_PATH];
    WCHAR            szBuffer[MAX_PATH], *pszDevID;
    HINF             hAnswerInf = INVALID_HANDLE_VALUE;
    BOOL             bLineExists;
    INFCONTEXT       InfContext;
    DWORD            dwSize;
    CONFIGRET        cfgRetVal;
    HDEVINFO         hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA  DeviceInfoData;
    SC_HANDLE        hSC = NULL;
    SC_HANDLE        hSvc = NULL;
    LPQUERY_SERVICE_CONFIG psvcConfig = NULL;
    DWORD            Type, l;
    HKEY             hKey;


    if (!GetWindowsDirectory(szBuffer, MAX_PATH)) {
        //
        // Unable to get Windows Directory
        //
        return FALSE;
    }

    szSysprepInfFile[0] = szBuffer[0];

#ifdef DEBUG_LOGLOG
    szLogFile[0] = szBuffer[0];
    LOG_Init(szLogFile);
    LOG_Write(L">>\r\n>> CleanDeviceDatabase\r\n>>\r\n");
    LOG_Write(L"Sysprep.inf=%s", szSysprepInfFile);
#endif





    //
    // =================================
    // HACK.  Winlogon may erroneously append a ',' onto
    // the end of the path to explorer.  This would normally
    // get fixed up by ie.inf, but for the sysprep case,
    // this inf isn't run, so we'll continue to have this
    // bad path in the registry.  Fix it here.
    // =================================
    //

    //
    // Open HKLM\Software\Microsoft\Windows NT\CurrentVersion\WinLogon
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKey );
    if( l == NO_ERROR ) {
        //
        // Query the value of the Shell Key.
        //
        //
        // ISSUE-2002/02/26-brucegr: dwSize = sizeof(szBuffer);
        //
        dwSize = sizeof(szBuffer)/sizeof(szBuffer[0]);
        l = RegQueryValueEx( hKey,
                             TEXT("Shell"),
                             NULL,
                             &Type,
                             (LPBYTE)szBuffer,
                             &dwSize );

        if( l == NO_ERROR ) {
            pszDevID = wcschr( szBuffer, L',' );

            if( pszDevID ) {

                //
                // We hit, so we should set it back to "Explorer.exe"
                //
                StringCchCopy ( szBuffer, AS ( szBuffer ), L"Explorer.exe" );

                //
                // Now set the key with our new value.
                //
                l = RegSetValueEx( hKey,
                                   TEXT("Shell"),
                                   0,
                                   REG_SZ,
                                   (CONST BYTE *)szBuffer,
                                   (lstrlen( szBuffer ) + 1) * sizeof(WCHAR));
            }
        }

        RegCloseKey(hKey);
    }


    //
    // =================================
    // Open the sysprep.inf file.  Since we don't know what the user has in
    // here, so try opening as both styles.
    // =================================
    //

    //
    // ISSUE-2002/02/26-brucegr: You can pass in both bits in one call to SetupOpenInfFile
    //
    hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_WIN4, NULL);
    if (hAnswerInf == INVALID_HANDLE_VALUE) {
        hAnswerInf = SetupOpenInfFile(szSysprepInfFile, NULL, INF_STYLE_OLDNT, NULL);
        if (hAnswerInf == INVALID_HANDLE_VALUE) {

            //
            // User didn't give us a sysprep.inf.  Return as if nothing
            // happened.
            //
            return TRUE;
        }
    }

    //
    // =================================
    // Remove the buildmassstoragesection=yes if it exists.  
    // =================================
    //
    WritePrivateProfileString(SYSPREP_SECTION, SYSPREP_BUILDMASSSTORAGE_KEY, NULL, szSysprepInfFile);

    //
    // =================================
    // Establish a connection to the service control manager on the local
    // computer to retrieve status and reconfig services.
    // =================================
    //

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL) {
        goto CDD_Critical_Error_Handler;
    }





    //
    // =================================
    // Process each line in our section
    // =================================
    //

    bLineExists = SetupFindFirstLine(hAnswerInf, pszSectionName, NULL, &InfContext);

    while (bLineExists) {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"");
#endif
        //
        // We've got a line, and it should look like:
        //     <key>=<service name>
        //





        //
        // =================================
        // Retrieve the service name from the line
        // =================================
        //

        dwSize = MAX_PATH;
        if (!SetupGetStringField(&InfContext, 1, szServiceName, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"Service=%s", szServiceName);
#endif

        //
        // ISSUE-2002/02/26-brucegr: EXPENSIVE!!!  Should build the in-use service list once and then loop through INF.
        //                        Code is currently enumerating all devices for every INF entry.  Bad times.
        //

        // Check to see if the service is in use by a currently present, enumerated
        // device. If it is, then skip it, otherwise try to stop it, etc
        if (ServiceInUseByDevice(szServiceName))
        {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service is in use by a device. Skipping...");
#endif
            goto CDD_Next_Inf_Line;
        }
        else
        {
            if (E_FAIL == GetLastError())
            {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }
#ifdef DEBUG_LOGLOG
            LOG_Write(L"Service is not in use by a device. Attempting to disable...");
#endif

        }

        //
        // =================================
        // Open the service to query its status, start type, and disable
        // it if it is not running and not yet disabled.
        // =================================
        //

        hSvc = OpenService(
                    hSC,
                    szServiceName,
                    SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG
                    );
        if (hSvc == NULL) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }


        //
        // =================================
        // If PnP driver then don't disable the service and continue.  
        // =================================
        //
        if (IsPnPDriver(szServiceName)) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"IsPnPDriver() returned TRUE.  Continue to next entry.");
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }
    

        //
        // =================================
        // Query the service start type.
        // =================================
        //

    psvcConfig = (LPQUERY_SERVICE_CONFIG) malloc(sizeof(QUERY_SERVICE_CONFIG));
        if (psvcConfig == NULL) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"ERROR@malloc - Not enough memory.");
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

        if (!QueryServiceConfig(hSvc, psvcConfig, sizeof(QUERY_SERVICE_CONFIG), &dwSize)) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }
            else {
                //
                // Need to expand the service configuration buffer and call the API again.
                //
                void *pTemp = realloc(psvcConfig, dwSize);
                if (pTemp == NULL) {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"ERROR@realloc - Not enough memory.");
#endif
                    bAllOK = FALSE;
                    goto CDD_Next_Inf_Line;
                }

                psvcConfig = (LPQUERY_SERVICE_CONFIG) pTemp;

                if (!QueryServiceConfig(hSvc, psvcConfig, dwSize, &dwSize)) {
#ifdef DEBUG_LOGLOG
                    LOG_WriteLastError();
#endif
                    bAllOK = FALSE;
                    goto CDD_Next_Inf_Line;
                }
            }
        }

#ifdef DEBUG_LOGLOG
        switch(psvcConfig->dwStartType) {
        case SERVICE_BOOT_START:
            LOG_Write(L"StartType=SERVICE_BOOT_START");
            break;
        case SERVICE_SYSTEM_START:
            LOG_Write(L"StartType=SERVICE_SYSTEM_START");
            break;
        case SERVICE_AUTO_START:
            LOG_Write(L"StartType=SERVICE_AUTO_START");
            break;
        case SERVICE_DEMAND_START:
            LOG_Write(L"StartType=SERVICE_DEMAND_START");
            break;
        case SERVICE_DISABLED:
            LOG_Write(L"StartType=SERVICE_DISABLED");
            break;
        }
#endif


        //
        // =================================
        // Retrieve device IDs for the device instances controlled by the service.
        // ISSUE-2002/02/26-brucegr: Need to call CM_Get_Device_ID_List_Size to get 
        // the required buffer size. But we're OK here, since by reaching this point, 
        // we know we have a single device instance.
        // =================================
        //

        cfgRetVal = CM_Get_Device_ID_List(
                            szServiceName,
                            szBuffer,
                            sizeof(szBuffer)/sizeof(WCHAR),
                            CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                            );
        if (cfgRetVal != CR_SUCCESS) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"ERROR@CM_Get_Device_ID_List - (%08X)", cfgRetVal);
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }


        //
        // =================================
        // Remove all "bogus" devnodes.
        // =================================
        //

        //
        // Create an empty device information set.
        //
        hDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
        if (hDevInfo == INVALID_HANDLE_VALUE) {
#ifdef DEBUG_LOGLOG
            LOG_WriteLastError();
#endif
            bAllOK = FALSE;
            goto CDD_Next_Inf_Line;
        }

        for (pszDevID = szBuffer; *pszDevID; pszDevID += (lstrlen(pszDevID) + 1)) {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"--> removing %s...", pszDevID);
#endif

            //
            // Open a device instance into the hDevInfo set
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            if (!SetupDiOpenDeviceInfo(
                        hDevInfo,
                        pszDevID,
                        NULL,
                        0,
                        &DeviceInfoData)
                        ) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                continue;
            }

            if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &DeviceInfoData)) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
            }

#ifdef DEBUG_LOGLOG
            LOG_Write(L"--> successfully done!");
#endif
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
        hDevInfo = INVALID_HANDLE_VALUE;


        //
        // =================================
        // Disable stopped and not-yet-disabled services
        // =================================
        //
#ifdef DEBUG_LOGLOG
        LOG_Write(L"--> changing StartType to SERVICE_DISABLED...");
#endif
        if (!ChangeServiceConfig(
                    hSvc,
                    SERVICE_NO_CHANGE,
                    SERVICE_DISABLED,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    psvcConfig->lpDisplayName)) {
#ifdef DEBUG_LOGLOG
                LOG_WriteLastError();
#endif
                bAllOK = FALSE;
                goto CDD_Next_Inf_Line;
            }

#ifdef DEBUG_LOGLOG
        LOG_Write(L"--> successfully done!");
#endif

CDD_Next_Inf_Line:

        if (psvcConfig != NULL) {
            free(psvcConfig);
            psvcConfig = NULL;
        }

        if (hSvc != NULL) {
            CloseServiceHandle(hSvc);
            hSvc = NULL;
        }

        //
        // Get the next line from the relevant section in the inf file
        //
        bLineExists = SetupFindNextLine(&InfContext, &InfContext);
    }


    //
    // =================================
    // Cleanup for a successful run
    // =================================
    //

    CloseServiceHandle(hSC);

    SetupCloseInfFile(hAnswerInf);

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    return bAllOK;

//
// =================================
CDD_Critical_Error_Handler:
//
// =================================
#ifdef DEBUG_LOGLOG
    LOG_WriteLastError();
#endif

    if (hSvc != NULL) {
        CloseServiceHandle(hSvc);
    }

    if (hSC != NULL) {
        CloseServiceHandle(hSC);
    }

    if (hAnswerInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hAnswerInf);
    }

#ifdef DEBUG_LOGLOG
    LOG_DeInit();
#endif

    return FALSE;
}

BOOL
IsPnPDriver(
    IN  LPTSTR ServiceName
    )
/*++

Routine Description:

    This function checks whether a specified driver is a PnP driver

Arguments:

    ServiceName - Specifies the driver of interest.

Return Value:

    TRUE - if the driver is a PnP driver or if this cannot be determined.

    FALSE - if the service is not a PnP driver.

--*/
{
    CONFIGRET   Status;
    BOOL        fRetStatus = TRUE;
    WCHAR *     pBuffer;
    ULONG       cchLen, ulRegDataType;
    WCHAR       szClassGuid[MAX_GUID_STRING_LEN];
    DEVNODE     DevNode;

    //
    // Allocate a buffer for the list of device instances associated with
    // this service
    //
    Status = CM_Get_Device_ID_List_Size(
                    &cchLen,                        // list length in wchars
                    ServiceName,                    // pszFilter
                    CM_GETIDLIST_FILTER_SERVICE);   // filter is a service name

    if (Status != CR_SUCCESS)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"CM_Get_Device_ID_List_Size failed %#lx for service %ws\n",
                       Status, ServiceName);
#endif
        return TRUE;
    }

    //
    // If there are no devnodes, this is not a PnP driver
    //
    if (cchLen == 0)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"IsPnPDriver: %ws is not a PnP driver (no devnodes)\n",
                       ServiceName);
#endif
        return FALSE;
    }

    pBuffer = (WCHAR *) LocalAlloc(0, cchLen * sizeof(WCHAR));
    if (pBuffer == NULL)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"Couldn't allocate buffer for device list, error %lu\n",
                      GetLastError());
#endif
        return TRUE;
    }

    //
    // Initialize parameters for CM_Get_Device_ID_List, the same way as is
    // normally done in the client side of the API
    //
    pBuffer[0] = L'\0';

    //
    // Get the list of device instances that are associated with this service
    //
    // (For legacy and PNP-aware services, we could get an empty device list.)
    //
    Status = CM_Get_Device_ID_List(
                    ServiceName,                    // pszFilter
                    pBuffer,                        // buffer for device list
                    cchLen,                         // buffer length in wchars
                    CM_GETIDLIST_FILTER_SERVICE |   // filter is a service name
                    CM_GETIDLIST_DONOTGENERATE      // do not generate an instance if none exists
                    );

    if (Status != CR_SUCCESS)
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"CM_Get_Device_ID_List failed %#lx for service %ws\n",
                       Status, ServiceName);
#endif
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // If there's more than one devnode, this is a PnP driver
    //
    if (*(pBuffer + wcslen(pBuffer) + 1) != L'\0')
    {
#ifdef DEBUG_LOGLOG
        LOG_Write(L"IsPnPDriver: %ws is a PnP driver (more than 1 devnode)\n",
                       ServiceName);
#endif
        LocalFree(pBuffer);
        return TRUE;
    }

    //
    // This has only one DevNode so lets check if it's legacy.
    // Use CM_LOCATE_DEVNODE_PHANTOM because the DevNode may not be considered alive but
    // exists in the registry.
    //
    if ( CR_SUCCESS == CM_Locate_DevNode(&DevNode, pBuffer, CM_LOCATE_DEVNODE_PHANTOM) )
    {
        //
        // Get the class GUID of this driver
        //
        cchLen = sizeof(szClassGuid);

        Status = CM_Get_DevNode_Registry_Property(
                        DevNode,                        // devnode
                        CM_DRP_CLASSGUID,               // property to get
                        &ulRegDataType,                 // pointer to REG_* type
                        szClassGuid,                    // return buffer
                        &cchLen,                        // buffer length in bytes
                        0                               // flags
                        );

        if (Status != CR_SUCCESS)
        {
#ifdef DEBUG_LOGLOG
            LOG_Write(L"CM_Get_DevNode_Registry_Property failed %#lx for service %ws\n",
                           Status, ServiceName);
#endif
            LocalFree(pBuffer);
            return TRUE;
        }

        //
        // If the single devnode's class is LegacyDriver,
        // this is not a PnP driver
        //
        fRetStatus = (_wcsicmp(szClassGuid, LEGACYDRIVER_STRING) != 0);

#ifdef DEBUG_LOGLOG
            LOG_Write(L"IsPnPDriver: %ws %ws a PnP driver\n",
                       ServiceName, fRetStatus ? L"is" : L"is not");
#endif
    }

    LocalFree(pBuffer);
    return fRetStatus;
}

BOOL
BackupHives(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Copy the system hive over into the repair directory.  This is required
    if the user has asked us to fixup the critical device database (which
    will change the contents of the system hive).

Arguments:

    None.

Return Value:

    TRUE if the operation succeeds, FALSE otherwise.
===============================================================================
--*/
{
    WCHAR szRepairSystemHive[MAX_PATH];
    WCHAR szRepairSystemHiveBackup[MAX_PATH];
    HKEY  hkey;
    LONG  lStatus;


    //
    // Get the full pathname of the "system" file in the repair directory.
    //
    if (!GetWindowsDirectory(szRepairSystemHive, MAX_PATH))
        return FALSE;

    StringCchCat (szRepairSystemHive, AS ( szRepairSystemHive ), L"\\repair\\system");

    //
    // Generate the full pathname of the backup copy of the current "system" file.
    StringCchCopy (szRepairSystemHiveBackup, AS ( szRepairSystemHiveBackup ), szRepairSystemHive);
    //
    // ISSUE-2002/02/26-brucegr: This should be szRepairSystemHiveBackup!!!!
    //
    StringCchCat(szRepairSystemHive, AS ( szRepairSystemHive ),  L".bak");

    //
    //  Open the root of the system hive.
    //
    lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"system",
                           REG_OPTION_RESERVED,
                           READ_CONTROL,
                           &hkey);

    if (lStatus == ERROR_SUCCESS) {
        //
        // First, rename the current "system" file to "system.bak", so that
        // we can restore it if RegSaveKey fails.
        //
        SetFileAttributes(szRepairSystemHiveBackup, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szRepairSystemHiveBackup);
        SetFileAttributes(szRepairSystemHive, FILE_ATTRIBUTE_NORMAL);
        MoveFile(szRepairSystemHive, szRepairSystemHiveBackup);

        //
        // Save the registry system hive into the "system" file.
        //

        //
        // ISSUE-2002/02/26-brucegr: We need to make sure we have SE_BACKUP_NAME privilege
        //
        lStatus = RegSaveKey(hkey, szRepairSystemHive, NULL);

        if (lStatus == ERROR_SUCCESS) {
            //
            // Now we can safely delete the backup copy.
            //
            DeleteFile(szRepairSystemHiveBackup);
        }
        else {
            //
            // Otherwise we need to restore the system file from the backup.
            //
            MoveFile(szRepairSystemHiveBackup, szRepairSystemHive);
        }

        RegCloseKey(hkey);
    }

    return (lStatus == ERROR_SUCCESS);
}


VOID
FreeSysprepContext(
    IN PVOID SysprepContext
    )
{
    PSYSPREP_QUEUE_CONTEXT Context = SysprepContext;

    try {
        if(Context->DefaultContext) {
            SetupTermDefaultQueueCallback(Context->DefaultContext);
        }
        free(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


PVOID
InitSysprepQueueCallback(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Initialize the data structure used for the callback that fires when
    we commit the file copy queue.

Arguments:


Return Value:


===============================================================================
--*/
{
    PSYSPREP_QUEUE_CONTEXT SysprepContext;

    SysprepContext = malloc(sizeof(SYSPREP_QUEUE_CONTEXT));

    if(SysprepContext) {

        SysprepContext->DirectoryOnSourceDevice = NULL;
        SysprepContext->DiskDescription = NULL;
        SysprepContext->DiskTag = NULL;

        SysprepContext->DefaultContext = SetupInitDefaultQueueCallbackEx( NULL,
                                                                          INVALID_HANDLE_VALUE,
                                                                          0,
                                                                          0,
                                                                          NULL );
    }

    return SysprepContext;
}


UINT
SysprepQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
/*++
===============================================================================
Routine Description:

    Callback function for setupapi to use as he's copying files.

    We'll use this to ensure that the files we copy get appended to
    setup.log, which in turn may get used when/if the user ever tries to
    use Windows repair capabilities.

Arguments:


Return Value:


===============================================================================
--*/
{
UINT                    Status;
PSYSPREP_QUEUE_CONTEXT  SysprepContext = Context;
PFILEPATHS              FilePaths = (PFILEPATHS)Param1;

    // 
    // Make sure that if we get these notification to check Param1.
    //
    switch (Notification) {
        case SPFILENOTIFY_COPYERROR:
            {
                //
                // Copy error happened log and skip this file.
                //
#ifdef DEBUG_LOGLOG
                LOG_Write(L"SysprepQueueCallback: SPFILENOTIFY_COPYERROR - %s, %s, %s, %s, %s", 
                   (PWSTR) FilePaths->Source,
                   (PWSTR) FilePaths->Target,
                   SysprepContext->DirectoryOnSourceDevice,
                   SysprepContext->DiskDescription,
                   SysprepContext->DiskTag);
#endif
                return FILEOP_SKIP;
            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:        
            {
                //
                // If user specified an OEM driver file and path break and let 
                // the DefaultQueueCallback handle it.
                //
               PSOURCE_MEDIA pSourceMedia = (PSOURCE_MEDIA)Param1;
               if (pSourceMedia) {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"SysprepQueueCallback: SPFILENOTIFY_NEEDMEDIA - %s, %s, %s, %s, %s", 
                       (PWSTR) pSourceMedia->SourcePath,
                       (PWSTR) pSourceMedia->SourceFile,
                       (PWSTR) pSourceMedia->Tagfile,
                       (PWSTR) pSourceMedia->Description);
#endif
                    if (pSourceMedia->SourcePath && lstrlen(pSourceMedia->SourcePath) && 
                        pSourceMedia->SourceFile && lstrlen(pSourceMedia->SourceFile))
                        break; // continue if SourcePath and SourceFile is specified
                    else
                        return FILEOP_SKIP;
               }           
            }
            break;

        default:
            break;
    }

    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback( SysprepContext->DefaultContext,
                                        Notification,
                                        Param1,
                                        Param2 );

    switch(Notification) {
        case SPFILENOTIFY_ENDCOPY:

            //
            // The copy just finished.  Let's log the
            // file.
            //
            LogRepairInfo( (PWSTR) FilePaths->Source,
                           (PWSTR) FilePaths->Target,
                           SysprepContext->DirectoryOnSourceDevice,
                           SysprepContext->DiskDescription,
                           SysprepContext->DiskTag );

            break;

        default:
            break;
    }

    return Status;

}


BOOL
ValidateAndChecksumFile(
    IN  PCWSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++
===============================================================================

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage - Receives flag indicating whether the file is an
                NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
            image (for nt images) and that we can read the image.

Return Value:

    BOOL - Returns TRUE if the flie was validated, and in this case,
           IsNtImage, Checksum, and Valid will contain the result of
           the validation.
           This function will return FALSE, if the file could not be
           validated, and in this case, the caller should call GetLastError()
           to find out why this function failed.

===============================================================================
--*/

{
DWORD           Error;
PVOID           BaseAddress;
ULONG           FileSize;
HANDLE          hFile;
HANDLE          hSection;
PIMAGE_NT_HEADERS NtHeaders;
ULONG           HeaderSum;


    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //

    Error = pSetupOpenAndMapFileForRead( Filename,
                                        &FileSize,
                                        &hFile,
                                        &hSection,
                                        &BaseAddress );

    if( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        return(FALSE);
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return(TRUE);
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    pSetupUnmapAndCloseFile( hFile, hSection, BaseAddress );
    return( TRUE );
}


VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    )
/*++
===============================================================================
Routine Description:

    This function will log the fact that a file was installed into the
    machine.  This will enable Windows repair functionality to be alerted
    that in case of a repair, this file will need to be restored.

Arguments:


Return Value:


===============================================================================
--*/
{
WCHAR           RepairLog[MAX_PATH];
BOOLEAN         IsNtImage;
ULONG           Checksum;
BOOLEAN         Valid;
WCHAR           Filename[MAX_PATH];
WCHAR           SourceName[MAX_PATH];
DWORD           LastSourceChar, LastTargetChar;
DWORD           LastSourcePeriod, LastTargetPeriod;
WCHAR           Line[MAX_PATH];
WCHAR           tmp[MAX_PATH];


    if (!GetWindowsDirectory( RepairLog, MAX_PATH ))
        return;

    StringCchCat( RepairLog, AS ( RepairLog ), L"\\repair\\setup.log" );

    if( ValidateAndChecksumFile( Target, &IsNtImage, &Checksum, &Valid )) {

        //
        // Strip off drive letter.
        //

        StringCchPrintf(
            Filename,
            AS ( Filename ),
            L"\"%s\"",
            Target+2
            );

        //
        // Convert source name to uncompressed form.
        //
        StringCchCopy ( SourceName, AS ( SourceName ), wcsrchr( Source, (WCHAR)'\\' ) + 1 );

        if(!SourceName [ 0 ] ) {
            return;
        }
        LastSourceChar = wcslen (SourceName) - 1;

        if(SourceName[LastSourceChar] == L'_') {
            LastSourcePeriod = (DWORD)(wcsrchr( SourceName, (WCHAR)'.' ) - SourceName);

            if(LastSourceChar - LastSourcePeriod == 1) {
                //
                // No extension - just truncate the "._"
                //
                SourceName[LastSourceChar-1] = L'\0';
            } else {
                //
                // Make sure the extensions on source and target match.
                // If this fails, we can't log the file copy
                //
                LastTargetChar = wcslen (Target) - 1;
                LastTargetPeriod = (ULONG)(wcsrchr( Target, (WCHAR)'.' ) - Target);

                if( _wcsnicmp(
                    SourceName + LastSourcePeriod,
                    Target + LastTargetPeriod,
                    LastSourceChar - LastSourcePeriod - 1 )) {
                    return;
                }

                if(LastTargetChar - LastTargetPeriod < 3) {
                    //
                    // Short extension - just truncate the "_"
                    //
                    SourceName[LastSourceChar] = L'\0';
                } else {
                    //
                    // Need to replace "_" with last character from target
                    //
                    SourceName[LastSourceChar] = Target[LastTargetChar];
                }
            }
        }





        //
        // Write the line.
        //
        if( (DirectoryOnSourceDevice) &&
            (DiskDescription) &&
            (DiskTag) ) {

            //
            // Treat this as an OEM file.
            //
            StringCchPrintf( Line,
                             AS ( Line ),
                             L"\"%s\",\"%x\",\"%s\",\"%s\",\"%s\"",
                             SourceName,
                             Checksum,
                             DirectoryOnSourceDevice,
                             DiskDescription,
                             DiskTag );

        } else {

            //
            // Treat this as an "in the box" file.
            //
            StringCchPrintf( Line,
                             AS ( Line ),      
                             L"\"%s\",\"%x\"",
                             SourceName,
                             Checksum );
        }

        if (GetPrivateProfileString(L"Files.WinNt",Filename,L"",tmp,sizeof(tmp)/sizeof(tmp[0]),RepairLog)) {
            //
            // there is already an entry for this file present (presumably
            // from textmode phase of setup.) Favor this entry over what we
            // are about to add
            //
        } else {
            WritePrivateProfileString(
                L"Files.WinNt",
                Filename,
                Line,
                RepairLog);
        }

    }
}




#ifdef _X86_

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )

/*++
===============================================================================
Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.
===============================================================================
--*/

{
HFILE               hfile;
ULONG               FileSize;
PUCHAR              buf = NULL,p1,p2;
BOOL                b;
CHAR                TimeoutLine[256];
CHAR                szBootIni[] = "?:\\BOOT.INI";
UINT                OldMode;
WIN32_FIND_DATA     findData;
HANDLE              FindHandle;
WCHAR               DriveLetter;
WCHAR               tmpBuffer[MAX_PATH];

    //
    // Generate path to the boot.ini file.  This is actually more
    // complicated than one might think.  It will almost always
    // be located on c:, but the user may have remapped his drive
    // letters.
    //
    // We'll use a brute-force method here and look for the first
    // instance of boot.ini.  We've got two factors going for us
    // here:
    //   1. boot.ini be on the lower-drive letters, so look there
    //      first
    //   2. I can't think of a scenario where he would have multiple
    //      boot.ini files, so the first one we find is going to be
    //      the right one.
    //

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    StringCchCopy ( tmpBuffer, AS ( tmpBuffer ), TEXT( "?:\\BOOT.INI" ) );
    for( DriveLetter = 'c'; DriveLetter <= 'z'; DriveLetter++ ) {
        tmpBuffer[0] = DriveLetter;

        //
        // See if he's there.
        //
        //
        // ISSUE-2002/02/26-brucegr: Use GetFileAttributes/GetFileAttributesEx instead of FindFirstFile!
        //
        FindHandle = FindFirstFile( tmpBuffer, &findData );

        if(FindHandle != INVALID_HANDLE_VALUE) {

            //
            // Yep.  Close him and break the for-loop.
            //
            FindClose(FindHandle);
            break;
        }
    }
    SetErrorMode(OldMode);

    if( DriveLetter > 'z' ) {
        return FALSE;
    }

    szBootIni[0] = (CHAR)DriveLetter;

    StringCchPrintfA (TimeoutLine,AS ( TimeoutLine ), "timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //
    //
    // ISSUE-2002/02/26-brucegr: Why can't we use PrivateProfile APIs?
    //
    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {

        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {

            if((_llseek(hfile,0,0) != -1)
            && (buf = malloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            free(buf);
        }
        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        free(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.
    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);

    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        free(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile,buf        ,p1-buf             ) != (UINT)(-1))
      &&  (_lwrite(hfile,TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile,p2         ,buf+FileSize-p2    ) != (UINT)(-1)));

    _lclose(hfile);
    free(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributesA(
        szBootIni,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
        );

    return(b);
}

#else

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )

/*++
===============================================================================
Routine Description:

    Changes the boot timeout value in NVRAM.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.
===============================================================================
--*/

{
    NTSTATUS Status;
    BOOT_OPTIONS BootOptions;

    BootOptions.Version = BOOT_OPTIONS_VERSION;
    BootOptions.Length =  sizeof(BootOptions);
    BootOptions.Timeout = Timeout;

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetBootOptions(&BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    return (NT_SUCCESS(Status));
}

#endif

// Disable System Restore
//
void DisableSR()
{
    HINSTANCE   hInst   = LoadLibrary(FILE_SRCLIENT_DLL);
    if (hInst) {
        FARPROC fnProc;
        if ( fnProc = GetProcAddress(hInst, "DisableSR") ) {
            fnProc(NULL);
        }

        FreeLibrary(hInst);
    }
}

// Enable System Restore
//
void EnableSR()
{
    HINSTANCE   hInst   = LoadLibrary(FILE_SRCLIENT_DLL);
    if (hInst) {
        FARPROC fnProc;
        if ( fnProc = GetProcAddress(hInst, "EnableSR") ) {
            fnProc(NULL);
        }

        FreeLibrary(hInst);
    }
}

LPTSTR OPKAddPathN(LPTSTR lpPath, LPCTSTR lpName, DWORD cbPath)
{
    LPTSTR lpTemp = lpPath;

    // Validate the parameters passed in.
    //
    if ( ( lpPath == NULL ) ||
         ( lpName == NULL ) )
    {
        return NULL;
    }

    // Find the end of the path.
    //
    while ( *lpTemp )
    {
        lpTemp = CharNext(lpTemp);
        if ( cbPath )
        {
            cbPath--;
        }
    }

    // If no trailing backslash on the path then add one.
    //
    if ( ( lpTemp > lpPath ) &&
         ( *CharPrev(lpPath, lpTemp) != CHR_BACKSLASH ) )
    {
        // Make sure there is room in the path buffer to
        // add the backslash and the null terminator.
        //
        if ( cbPath < 2 )
        {
            return NULL;
        }

        *lpTemp = CHR_BACKSLASH;
        lpTemp = CharNext(lpTemp);
        cbPath--;
    }
    else
    {
        // Make sure there is at least room for the null
        // terminator.
        //
        if ( cbPath < 1 )
        {
            return NULL;
        }
    }

    // Make sure there is no preceeding spaces or backslashes
    // on the name to add.
    //
    while ( ( *lpName == CHR_SPACE ) ||
            ( *lpName == CHR_BACKSLASH ) )
    {
        lpName = CharNext(lpName);
    }

    // Add the new name to existing path.
    //
    lstrcpyn(lpTemp, lpName, cbPath);

    // Trim trailing spaces from result.
    //
    while ( ( lpTemp > lpPath ) &&
            ( *(lpTemp = CharPrev(lpPath, lpTemp)) == CHR_SPACE ) )
    {
        *lpTemp = NULLCHR;
    }

    return lpPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\sysprep_.h ===
#ifndef _SYSPREP_H
#define _SYSPREP_H

#include <cfgmgr32.h>
#include <setupapi.h>

// ============================================================================
// USEFUL STRINGS
// ============================================================================

#define SYSCLONE_PART2              "setupcl.exe"
#define IDS_ADMINISTRATOR           1

// ============================================================================
// USEFUL CONSTANTS
// ============================================================================

#define SETUPTYPE                   1        // from winlogon\setup.h
#define SETUPTYPE_NOREBOOT          2
#define REGISTRY_QUOTA_BUMP         (10* (1024 * 1024))
#define DEFAULT_REGISTRY_QUOTA      (32 * (1024 * 1024))
#define SFC_DISABLE_NOPOPUPS        4        // from sfc.h
#define FILE_SRCLIENT_DLL           L"SRCLIENT.DLL"

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif // ARRAYSIZE

#define ARRAYSIZE(a)         ( sizeof(a) / sizeof(a[0]) )

#ifdef AS
#undef AS
#endif // AS

#define AS(a)               ARRAYSIZE(a)

// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

BOOL
IsDomainMember(
    VOID
    );

BOOL
ResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    );

BOOL
DeleteWinlogonDefaults(
    VOID
    );

VOID
FixDevicePaths(
    VOID
    );

BOOL
NukeUserSettings(
        VOID
        );

BOOL
NukeMruList(
    VOID
    );

BOOL
RemoveNetworkSettings(
    LPTSTR  lpszSysprepINFPath
    );

VOID
RunExternalUniqueness(
    VOID
    );

BOOL
IsSetupClPresent(
    VOID
    );

//
// from spapip.h
//
BOOL
pSetupIsUserAdmin(
    VOID
    );

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR
    );

BOOL
EnablePrivilege(
    IN PCTSTR,
    IN BOOL
    );

VOID 
BuildMassStorageSection(
    IN BOOL
    );

DWORD
ReArm(
    VOID
    );

BOOL
AdjustRegistry(
    IN BOOL RemoveNetworkSettings
    );

BOOL
AdjustFiles(
    VOID
    );

BOOL
PopulateDeviceDatabase(
    OUT BOOL*
    );


BOOL
CleanDeviceDatabase(
    VOID
    );

BOOL
BackupHives(
    VOID
    );

VOID
FreeSysprepContext(
    IN PVOID SysprepContext
    );

PVOID
InitSysprepQueueCallback(
    VOID
    );

UINT
SysprepQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    );

BOOL
ChangeBootTimeout(
    IN UINT
    );

VOID 
DisableSR(
    VOID
    );

VOID 
EnableSR(
    VOID
    );

BOOL 
LocateWinBOM
(
    LPTSTR lpFileName
);

BOOL PrepForSidGen
(
    void
);

VOID
NukeEventLogs(
    VOID
    );

BOOL SetCloneTag
(
    void
);

BOOL SetupFirstRunApp
(
    void
);

BOOL SetOEMDuplicatorString
(
    LPTSTR  lpszSysprepINFPath
);

BOOL SetBigLbaSupport
(
    LPTSTR  lpszSysprepINFPath
);

BOOL RemoveTapiSettings
(
    LPTSTR  lpszSysprepINFPath
);

BOOL IsPnPDriver
(
    IN  LPTSTR ServiceName
);

LPTSTR OPKAddPathN
(
    LPTSTR lpPath, 
    LPCTSTR lpName, 
    DWORD cbPath
);

#endif // _SYSPREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\tape.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    tape.h

Abstract:

    These are the structures and defines that are used in the
    SCSI tape class drivers. The tape class driver is separated
    into two modules. Tape.c contains code common to all tape
    class drivers including the driver's major entry points.
    The major entry point names each begin with the prefix
    'ScsiTape.' The second module is the device specific code.
    It provides support for a set of functions. Each device
    specific function name is prefixed by 'Tape.'

Author:

    Mike Glass

Revision History:

--*/

#include "scsi.h"
#include "class.h"

//
// Define the maximum inquiry data length.
//

#define MAXIMUM_TAPE_INQUIRY_DATA 252

//
// Tape device data
//

typedef struct _TAPE_DATA {
     ULONG        Flags;
     ULONG        CurrentPartition;
     PVOID        DeviceSpecificExtension;
     PSCSI_INQUIRY_DATA InquiryData;
} TAPE_DATA, *PTAPE_DATA;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION) + sizeof(TAPE_DATA)


//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;


//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;


//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;



//
// The following routines are the exported entry points for
// all tape class drivers. Note all these routines name start
// with 'ScsiTape.'
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ScsiTapeInitialize(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiTapeCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiTapeDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
// The following routines are provided by the tape
// device-specific module. Each routine name is
// prefixed with 'Tape.'

NTSTATUS
TapeCreatePartition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeErase(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TapeError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
TapeGetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapePrepare(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetDriveParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetMediaParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TapeSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
TapeVerifyInquiry(
    IN PSCSI_INQUIRY_DATA LunInfo
    );

NTSTATUS
TapeWriteMarks(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\undo.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    undo.h

Abstract:

    Declares the interfaces for osuninst.lib, a library of uninstall functions.

Author:

    Jim Schmidt (jimschm) 19-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef enum {
    Uninstall_Valid = 0,                    // uninstall is possible (backup image passed sanity check)
    Uninstall_DidNotFindRegistryEntries,    // reg entries that point to backup image/prev os data are gone
    Uninstall_DidNotFindDirOrFiles,         // one or more backup files are missing, or undo dir is gone
    Uninstall_InvalidOsVersion,             // api called on an unexpected platform (example: user copied dll to Win2k)
    Uninstall_NotEnoughPrivileges,          // can't evaluate backup image because of lack of authority
    Uninstall_FileWasModified,              // backup image was tampered with by someone
    Uninstall_Unsupported,                  // uninstall is not supported
    Uninstall_NewImage,                     // image is less than 7 days old (not exposed by osuninst.dll)
    Uninstall_CantRetrieveSystemInfo,       // cannot retrieve integrity information from registry
    Uninstall_WrongDrive,                   // user had changed layout,disk,file system.
    Uninstall_DifferentNumberOfDrives,      // user had added/removed drive(s)
    Uninstall_NotEnoughSpace,               // not enough space to perform uninstall
    Uninstall_Exception,                    // caller passed in invalid arg to an osuninst.dll api
    Uninstall_OldImage,                     // image is more than 30 days old
    Uninstall_NotEnoughMemory,              // not enough memory to perform uninstall
    Uninstall_DifferentDriveLetter,         // user has changed drive letter
    Uninstall_DifferentDriveFileSystem,     // user has changed drive file system
    Uninstall_DifferentDriveGeometry,       // drive geometry has been changed
    Uninstall_DifferentDrivePartitionInfo   // drive partition has changed
} UNINSTALLSTATUS;

typedef enum {
    Uninstall_DontCare = 0,                 // try to avoid using this value; instead expand this enum whenever possible
    Uninstall_FatToNtfsConversion,          // caller is going to convert FAT to NTFS
    Uninstall_PartitionChange,              // caller is going to alter the partition configuration
    Uninstall_Upgrade                       // caller is going to upgrade the OS
} UNINSTALLTESTCOMPONENT;


//
// NOTE: BackedUpOsVersion is filled only when Uninstall_Valid is returned
//

UNINSTALLSTATUS
IsUninstallImageValid (
    IN      UNINSTALLTESTCOMPONENT ComponentToTest,
    OUT     OSVERSIONINFOEX *BackedUpOsVersion              OPTIONAL
    );

BOOL
RemoveUninstallImage (
    VOID
    );

ULONGLONG
GetUninstallImageSize (
    VOID
    );

BOOL
ProvideUiAlerts (
    IN      HWND UiParent
    );

BOOL
ExecuteUninstall (
    VOID
    );


typedef UNINSTALLSTATUS(WINAPI * ISUNINSTALLIMAGEVALID)(UNINSTALLTESTCOMPONENT, OSVERSIONINFOEX *);
typedef ULONGLONG(WINAPI * GETUNINSTALLIMAGESIZE)(VOID);
typedef BOOL(WINAPI * REMOVEUNINSTALLIMAGE)(VOID);
typedef BOOL(WINAPI * PROVIDEUIALERTS)(HWND);
typedef BOOL(WINAPI * EXECUTEUNINSTALL)(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization

Author:

    Richard Firth (rfirth) 15-May-1991

Revision History:

    03-Jan-1992 rfirth
        Added ILLEGAL_FAT_CHARS and ILLEGAL_HPFS_CHARS (from fsrtl\name.c)

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.
--*/

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
#define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
#define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
#define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets
//

#define NON_COMPONENT_CHARS TEXT("\\/:")
#define ILLEGAL_CHARS_STR   TEXT("\"<>|")
#define DOT_AND_SPACE_STR   TEXT(". ")
#define PATH_SEPARATORS     TEXT("\\/")

//
// Combinations of the above
//

#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  TEXT("\"/\\[]:|<>+=;,?") CTRL_CHARS_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |
//

#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR TEXT("\"*+,/:;<=>?[\\]|")

//
// Characters which may not appear in a canonicalized HPFS filename are:
//
//  0x00 - 0x1f " * / : < > ? \ |
//

#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR TEXT("\"*/:<>?\\|")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\unittest.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	 unittest.h  

Abstract:

	 This is the source file for the unit test support lib

Author(s):

	 Vincent Geglia
     
Environment:

	 User Mode

Notes:

    USER32.LIB, and KERNEL32.LIB must be linked with this
    WINDOWS.H must be #included prior to this header file


Revision History:

    Initial version,    011119, vincentg
	 

--*/

//
// General includes
//

//
// NTLOG definitions
//

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__

//
// Define progress bits
// These bits are used to track the progress through
// a given function, for the purposes of providing
// proper cleanup.  They are also useful for debugging.
//

//
// Progress macros
//

#if 0
    #define FORCEERRORPATH
    #define FORCEERRORPATHBIT               0x2
#endif

#if 0
    #ifdef DBG
        #define ECHOPROGRESSDATA
    #endif
#endif

#ifdef ECHOPROGRESSDATA 

    #define PROGRESS_INIT(x)            DWORD   progressbits = 0;   \
                                        UCHAR   functionname [100]; \
                                        strcpy (functionname, x);   \
                                        printf("****\nFunction: %s\n(module %s, line %d)\nPROGRESS TRACKING INITIALIZED\n****\n\n", functionname, __FILE__, __LINE__);
    #ifdef FORCEERRORPATH
        #define PROGRESS_UPDATE(x)          printf("****\nFunction: %s\n(module %s, line %d)\nPROGRESS UPDATE (WAS %08lx", functionname, __FILE__, __LINE__, progressbits); \
                                            printf(", NOW %08lx).\nForcing error path %08lx\n****\n\n", progressbits |= x, FORCEERRORPATHBIT);\
                                            if (progressbits & FORCEERRORPATHBIT) {\
                                                goto exitcleanup;\
                                            }
    #else                                       
        #define PROGRESS_UPDATE(x)          printf("****\nFunction: %s\n(module %s, line %d)\nPROGRESS UPDATE (WAS %08lx", functionname, __FILE__, __LINE__, progressbits); \
                                            printf(", NOW %08lx).\n****\n\n", progressbits |= x);
    #endif
                                               
    #define PROGRESS_GET                progressbits
    #define PROGRESS_END                progressbits = 0
    
#else

    #define PROGRESS_INIT(x)            DWORD   progressbits = 0
    #define PROGRESS_UPDATE(x)          progressbits |= x
    #define PROGRESS_GET                progressbits
    #define PROGRESS_END                progressbits = 0

#endif

//
// Globals
//

HANDLE  g_log = INVALID_HANDLE_VALUE;
BOOL    g_usentlog = FALSE;
BOOL    g_genericresult = TRUE;

typedef HANDLE  (*Dll_tlCreateLog) (LPSTR, DWORD);
typedef BOOL    (*Dll_tlAddParticipant) (HANDLE, DWORD, int);
typedef BOOL    (*Dll_tlStartVariation) (HANDLE);
typedef BOOL    (*Dll_tlLog) (HANDLE, DWORD, LPCSTR, int,...);
typedef DWORD   (*Dll_tlEndVariation) (HANDLE);
typedef BOOL    (*Dll_tlRemoveParticipant) (HANDLE);
typedef BOOL    (*Dll_tlDestroyLog) (HANDLE);
typedef VOID    (*Dll_tlReportStats) (HANDLE);

Dll_tlCreateLog         _tlCreateLog;
Dll_tlAddParticipant    _tlAddParticipant;
Dll_tlDestroyLog        _tlDestroyLog;
Dll_tlEndVariation      _tlEndVariation;
Dll_tlLog               _tlLog;  
Dll_tlRemoveParticipant _tlRemoveParticipant;
Dll_tlStartVariation    _tlStartVariation;
Dll_tlReportStats       _tlReportStats;

//
// Definitions
//

#define LOGINFO(x)     LogNTLOG (g_log, LOG_INFO, x)
#define LOGENTRYTEXTLENGTH  12
#define LOGENTRYTEXTPASS    "\n**PASS**: \0"
#define LOGENTRYTEXTFAIL    "\n**FAIL**: \0"
#define LOGENTRYTEXTINFO    "\n**INFO**: \0"

//
// Structures
//

typedef enum {
    UNIT_TEST_STATUS_SUCCESS = 0,
    UNIT_TEST_STATUS_NOT_RUN,
    UNIT_TEST_STATUS_FAILURE
} UNIT_TEST_STATUS;

typedef enum {
    LOG_PASS = 0,
    LOG_FAIL,
    LOG_INFO
} LOG_ENTRY_TYPE;

//
// Function prototypes
//

BOOL
UtInitLog
    (
        PUCHAR  Logfilename
    );

VOID
UtCloseLog
    (
        VOID
    );

VOID
UtLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText,
        ...
    );

VOID
UtLogINFO
    (
        PUCHAR          LogText,
        ...
    );

VOID
UtLogPASS
    (
        PUCHAR          LogText,
        ...
    );

VOID
UtLogFAIL
    (
        PUCHAR          LogText,
        ...
    );

PUCHAR
UtParseCmdLine
    (
        PUCHAR  Search,
        int     Argc,
        char    *Argv[]
    );

//
// Private function prototypes
//

BOOL
UtpInitGenericLog
    (
        PUCHAR  Logfilename
    );

BOOL
UtpInitNtLog
    (
        PUCHAR  Logfilename
    );

VOID
UtpCloseGenericLog
    (
        VOID
    );

VOID
UtpCloseNtLog
    (
        VOID
    );

VOID
UtpLogGenericLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText
    );

VOID
UtpLogNtLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText
    );

//
// Code
//

BOOL
UtInitLog
    (
        PUCHAR  Logfilename
    )

/*++

Routine Description:

    This routine sets up the unit test log mechanism

Arguments:

    None
    
Return Value:

    TRUE if successful
    FALSE if unsuccessful
    
    N.B. - FALSE is returned if a log session already exists.

--*/

//
// InitNTLOG progress bits
//

#define UtInitLog_ENTRY             0x00000001
#define UtInitLog_LOADNTLOG         0x00000002
#define UtInitLog_COMPLETION        0x00000004

{
    UCHAR   logfilepath [MAX_PATH];
    DWORD   logstyle;
    BOOL    bstatus = FALSE;
    HMODULE ntlogmodule = NULL;
    
    PROGRESS_INIT ("UtInitLog");
    PROGRESS_UPDATE (UtInitLog_ENTRY);

    if (g_log != INVALID_HANDLE_VALUE) {

        bstatus = FALSE;
        goto exitcleanup;
    }

    //
    // Try to initialize NTLOG first
    //
    
    PROGRESS_UPDATE (UtInitLog_LOADNTLOG);
    ntlogmodule = LoadLibrary ("NTLOG.DLL");

    if (ntlogmodule != NULL) {

        
        if (!(_tlCreateLog            = (Dll_tlCreateLog)        GetProcAddress (ntlogmodule, "tlCreateLog_A"))      ||
            !(_tlAddParticipant       = (Dll_tlAddParticipant)   GetProcAddress (ntlogmodule, "tlAddParticipant"))   ||
            !(_tlDestroyLog           = (Dll_tlDestroyLog)       GetProcAddress (ntlogmodule, "tlDestroyLog"))       ||
            !(_tlEndVariation         = (Dll_tlEndVariation)     GetProcAddress (ntlogmodule, "tlEndVariation"))     ||
            !(_tlLog                  = (Dll_tlLog)              GetProcAddress (ntlogmodule, "tlLog_A"))            ||
            !(_tlRemoveParticipant    = (Dll_tlRemoveParticipant)GetProcAddress (ntlogmodule, "tlRemoveParticipant"))||
            !(_tlStartVariation       = (Dll_tlStartVariation)   GetProcAddress (ntlogmodule, "tlStartVariation"))   ||
            !(_tlReportStats          = (Dll_tlReportStats)      GetProcAddress (ntlogmodule, "tlReportStats"))
            )

        {
            bstatus = FALSE;
            goto exitcleanup;
        } 

        bstatus = UtpInitNtLog (Logfilename);
        
        if (bstatus == TRUE) {

            g_usentlog = TRUE;
        }

    } else {

        bstatus = UtpInitGenericLog (Logfilename);

        if (bstatus == TRUE) {

            g_usentlog = FALSE;
            g_genericresult = TRUE;
        }
    }
    
    PROGRESS_UPDATE (UtInitLog_COMPLETION);

exitcleanup:

    //
    // Cleanup
    //

    
    PROGRESS_END;
    
    return bstatus;
}

VOID
UtCloseLog
    (
        VOID
    )

/*++

Routine Description:

    This routine closes the logging session and summarizes results

Arguments:

    None
    
Return Value:

    None

--*/

{
    if (g_usentlog == TRUE) {

        UtpCloseNtLog ();

    } else {

        UtpCloseGenericLog ();
    }

    g_log = INVALID_HANDLE_VALUE;
}

VOID
UtLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText,
        ...
    )

/*++

Routine Description:

    This routine logs an entry to a unit test logging session.

Arguments:

    A log entry type
    Text to log
    
Return Value:

    None

--*/

//
// UtLog progress bits
//

#define UtLog_ENTRY                     0x00000001
#define UtLog_LOG                       0x00000002
#define UtLog_COMPLETION                0x00000004

{
    va_list va;
    UCHAR   logtext[1000];
    
    PROGRESS_INIT ("UtLog");
    PROGRESS_UPDATE (UtLog_ENTRY);

    if (g_log == INVALID_HANDLE_VALUE) {

        goto exitcleanup;
    }

    va_start (va, LogText);
    _vsnprintf (logtext, sizeof (logtext), LogText, va);
    va_end (va);
    
    if (g_usentlog == TRUE) {

        UtpLogNtLog (LogEntryType, logtext);

    } else {
        
        UtpLogGenericLog (LogEntryType, logtext);
    }

    PROGRESS_UPDATE (UtLog_LOG);
    PROGRESS_UPDATE (UtLog_COMPLETION);

exitcleanup:

    PROGRESS_END;
    return;
}

VOID
UtLogINFO
    (
        PUCHAR          LogText,
        ...
    )

/*++

Routine Description:

    This routine logs an INFO entry

Arguments:

    Text describing the entry    
    
Return Value:

    None

--*/

{
    va_list va;
    
    va_start (va, LogText);
    UtLog (LOG_INFO, LogText, va);
    va_end (va);
}

VOID
UtLogPASS
    (
        PUCHAR          LogText,
        ...
    )

/*++

Routine Description:

    This routine logs a PASS entry

Arguments:

    Text describing the entry    
    
Return Value:

    None

--*/

{
    va_list va;
    
    va_start (va, LogText);
    UtLog (LOG_INFO, LogText, va);
    va_end (va);
}

VOID
UtLogFAIL
    (
        PUCHAR          LogText,
        ...
    )

/*++

Routine Description:

    This routine logs an FAIL entry

Arguments:

    Text describing the entry    
    
Return Value:

    None

--*/

{
    va_list va;
    
    va_start (va, LogText);
    UtLog (LOG_FAIL, LogText, va);
    va_end (va);
}

PUCHAR
UtParseCmdLine
    (
        PUCHAR  Search,
        int     Argc,
        char    *Argv[]
    )

/*++

Routine Description:

    This routine parses the command line

Arguments:

    Search - string to search for
    Argc - argc passed into main
    Argv - argv passed into main
    
Return Value:

    A pointer to the first instance of the string in the parameter list or
    NULL if the string does not exist

--*/

{
    int     count = 0;
    PUCHAR  instance;

    for (count = 0; count < Argc; count ++) {

        instance = strstr (Argv[count], Search);
        
        if (instance) {

            return instance;
        }
    }

    return 0;

}

BOOL
UtpInitGenericLog
    (
        PUCHAR  Logfilename
    )

/*++

Routine Description:

    This routine initializes a generic log (no NTLOG available)

Arguments:

    Name of log file to create
    
Return Value:

    TRUE if successful
    FALSE if unsuccessful

--*/

#define UtpInitGenericLog_ENTRY         0x00000001
#define UtpInitGenericLog_CREATEFILE    0x00000002
#define UtpInitGenericLog_COMPLETION    0x00000004

{
    UCHAR   logfilepath [MAX_PATH];
    BOOL    bstatus = FALSE;
    
    PROGRESS_INIT ("UtpInitGenericLog");
    PROGRESS_UPDATE (UtpInitGenericLog_ENTRY);
    
    if (strlen (Logfilename) > MAX_PATH) {

        goto exitcleanup;
    }

    strcpy (logfilepath, Logfilename);
    strcat (logfilepath, ".log");

    g_log = CreateFile (logfilepath,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                        NULL);

    if (g_log == INVALID_HANDLE_VALUE) {

        goto exitcleanup;
    }

    PROGRESS_UPDATE (UtpInitGenericLog_CREATEFILE);

    UtLog (LOG_INFO, "GENERICLOG: %s initialized.", logfilepath);
    
    bstatus = TRUE;
    
    PROGRESS_UPDATE (UtpInitGenericLog_COMPLETION);
    
exitcleanup:
    
    PROGRESS_END;
    return bstatus;
}

BOOL
UtpInitNtLog
    (
        PUCHAR  Logfilename
    )

/*++

Routine Description:

    This routine initializes an NTLOG log file

Arguments:

    Name of log file to create
    
Return Value:

    TRUE if successful
    FALSE if unsuccessful

--*/

//
// InitNTLOG progress bits
//

#define UtpInitNtLog_ENTRY             0x00000001
#define UtpInitNtLog_CREATELOG         0x00000002
#define UtpInitNtLog_ADDPARTICIPANT    0x00000004
#define UtpInitNtLog_COMPLETION        0x00000008


{
    UCHAR   logfilepath [MAX_PATH];
    DWORD   logstyle;
    BOOL    bstatus = FALSE;
    
    PROGRESS_INIT ("UtpInitNtLog");
    PROGRESS_UPDATE (UtpInitNtLog_ENTRY);

    if (strlen (Logfilename) > MAX_PATH) {

        goto exitcleanup;
    }

    strcpy (logfilepath, Logfilename);
    strcat (logfilepath, ".log");

    logstyle = TLS_LOGALL | TLS_MONITOR | TLS_REFRESH;
	g_log = _tlCreateLog(logfilepath, logstyle);

    if (g_log == INVALID_HANDLE_VALUE) {

        goto exitcleanup;
    }

    PROGRESS_UPDATE (UtpInitNtLog_CREATELOG);

    bstatus = _tlAddParticipant (g_log, 0, 0);

    if (bstatus == FALSE) {

        goto exitcleanup;
    }

    PROGRESS_UPDATE (UtpInitNtLog_ADDPARTICIPANT);

    UtLog (LOG_INFO, "NTLOG: %s initialized.", logfilepath);
    
    PROGRESS_UPDATE (UtpInitNtLog_COMPLETION);

    bstatus = TRUE;
    
exitcleanup:

    //
    // Cleanup
    //
    
    if (!(PROGRESS_GET & UtpInitNtLog_COMPLETION)) {
    
        if (PROGRESS_GET & UtpInitNtLog_ADDPARTICIPANT) {
            
            _tlRemoveParticipant (g_log);
        }
                
        if (PROGRESS_GET & UtpInitNtLog_CREATELOG) {
            
            _tlDestroyLog (g_log);
        }

        g_log = INVALID_HANDLE_VALUE;
    }

    if (PROGRESS_GET & UtpInitNtLog_COMPLETION) {

        g_usentlog = TRUE;
    }
    
    PROGRESS_END;
    
    return bstatus;
}

VOID
UtpCloseGenericLog
    (
        VOID
    )

/*++

Routine Description:

    This routine closes a generic logging session.

Arguments:

    None
    
Return Value:

    None

--*/


{
    if (g_genericresult == TRUE) {

        UtLog (LOG_INFO, "** TEST PASSED **");

    } else {
        
        UtLog (LOG_INFO, "** TEST FAILED **");

    }

    FlushFileBuffers (g_log);
    CloseHandle (g_log);
}

VOID
UtpCloseNtLog
    (
        VOID
    )

/*++

Routine Description:

    This routine closes an NTLOG logging session.

Arguments:

    None
    
Return Value:

    None

--*/

//
// CloseNTLOG progress bits
//

#define UtpCloseNtLog_ENTRY             0x00000001
#define UtpCloseNtLog_SUMMARIZE         0x00000002
#define UtpCloseNtLog_REMOVEPARTICIPANT 0x00000004
#define UtpCloseNtLog_DESTROYLOG        0x00000008
#define UtpCloseNtLog_COMPLETION        0x00000010

{
    BOOL    bstatus = FALSE;

    PROGRESS_INIT ("UtpCloseNtLog");
    PROGRESS_UPDATE (UtpCloseNtLog_ENTRY);
    
    if (g_log == INVALID_HANDLE_VALUE) {

        goto exitcleanup;
    }
    
    _tlReportStats (g_log);
    
    PROGRESS_UPDATE (UtpCloseNtLog_SUMMARIZE);
    
    bstatus = _tlRemoveParticipant (g_log);

    if (bstatus == FALSE) {

        goto exitcleanup;
    }

    PROGRESS_UPDATE (UtpCloseNtLog_REMOVEPARTICIPANT);
    
    bstatus = _tlDestroyLog (g_log);

    if (bstatus == FALSE) {

        goto exitcleanup;
    }

    PROGRESS_UPDATE (UtpCloseNtLog_DESTROYLOG);

    PROGRESS_UPDATE (UtpCloseNtLog_COMPLETION);

exitcleanup:

    PROGRESS_END;
    return;
}



VOID
UtpLogGenericLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText
    )

/*++

Routine Description:

    This routine enters a log event for a generic log file

Arguments:

    LogEntryType - The type of entry to log
    LogText - Text describing the logging event
    
Return Value:

    None

--*/

#define UtpLogGenericLog_ENTRY          0x00000001
#define UtpLogGenericLog_LOG            0x00000002
#define UtpLogGenericLog_COMPLETION     0x00000004

{
    UCHAR   logentrytypetext [LOGENTRYTEXTLENGTH];
    DWORD   byteswritten = 0;
    BOOL    bstatus = FALSE;

    PROGRESS_INIT ("UtpLogGenericLog");
    PROGRESS_UPDATE (UtpLogGenericLog_ENTRY);
    
    ZeroMemory (logentrytypetext, sizeof (logentrytypetext));
    
    //
    // Update our generic result - if we see a variation fail, the
    // whole test is considered a failure.
    //
    
    if (g_genericresult == TRUE) {

        g_genericresult = LogEntryType == LOG_FAIL ? FALSE : TRUE;
    }

    switch (LogEntryType) {
    
    case LOG_PASS:
        strcpy (logentrytypetext, LOGENTRYTEXTPASS);
        break;

    case LOG_FAIL:
        strcpy (logentrytypetext, LOGENTRYTEXTFAIL);
        break;
    
    case LOG_INFO:
        strcpy (logentrytypetext, LOGENTRYTEXTINFO);
        break;

    default:
        break;
    }

    bstatus = WriteFile (g_log,
                         logentrytypetext,
                         sizeof (logentrytypetext),
                         &byteswritten,
                         NULL);

    bstatus = WriteFile (g_log,
                         LogText,
                         strlen (LogText),
                         &byteswritten,
                         NULL);

    printf("%s%s", logentrytypetext, LogText);
    
    PROGRESS_UPDATE (UtpLogGenericLog_LOG);
    PROGRESS_UPDATE (UtpLogGenericLog_COMPLETION);
}

VOID
UtpLogNtLog
    (
        LOG_ENTRY_TYPE  LogEntryType,
        PUCHAR          LogText
    )

/*++

Routine Description:

    This routine enters a log event for NTLOG log files

Arguments:

    LogEntryType - The type of entry to log
    LogText - Text describing the logging event
    
Return Value:

    None

--*/

#define UtpLogNtLog_ENTRY               0x00000001
#define UtpLogNtLog_LOG                 0x00000002
#define UtpLogNtLog_COMPLETION          0x00000004

{
    DWORD   loglevel = 0;
    BOOL    bstatus = FALSE;
    
    PROGRESS_INIT ("UtpLogNtLog");
    PROGRESS_UPDATE (UtpLogNtLog_ENTRY);

    loglevel = (LogEntryType == LOG_PASS ? TLS_PASS : 0) |
               (LogEntryType == LOG_FAIL ? TLS_SEV1 : 0) |
               (LogEntryType == LOG_INFO ? TLS_INFO : 0);
    
    bstatus = _tlLog (g_log, loglevel | TL_VARIATION, LogText);
    
    PROGRESS_UPDATE (UtpLogNtLog_LOG);
    PROGRESS_UPDATE (UtpLogNtLog_COMPLETION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\vdmapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1998 Microsoft Corporation

Module Name:

    vdmapi.h

Abstract:

    This module defines the private MVDM APIs

Created:

    02-Apr-1992

Revision History:

    Created 02-Apr-1992 Sudeep Bharati

--*/

#define MAXIMUM_VDM_COMMAND_LENGTH	128
#define MAXIMUM_VDM_ENVIORNMENT 	32*1024
#define MAXIMUM_VDM_CURRENT_DIR 	64

// The following value can be used to allocate space for the largest possible
// path string in ansi, including directory, drive letter and file name.
// I originally coded this with 13 for the path name, but DOS seems to be
// able to handle one more, thus the 14.
#define MAXIMUM_VDM_PATH_STRING     MAXIMUM_VDM_CURRENT_DIR+3+14

// VDMState defines
#define ASKING_FOR_FIRST_COMMAND   0x1   // Very First call.
#define ASKING_FOR_WOW_BINARY      0x2   // Caller is WOWVDM
#define ASKING_FOR_DOS_BINARY      0x4   // Caller is DOSVDM
#define ASKING_FOR_SECOND_TIME     0x8   // Caller is asking second time after
#define INCREMENT_REENTER_COUNT   0x10   // Increment the re-entrancy count
#define DECREMENT_REENTER_COUNT   0x20   // Decrement the re-entrancy count
#define NO_PARENT_TO_WAKE         0x40   // Just get the next command, dont wake up anyone
                                         // allocating bigger buffers.
#define RETURN_ON_NO_COMMAND      0x80   // if there is no command return without blocking
#define ASKING_FOR_PIF           0x100   // To get the exe name to find out PIF
                                         // early in the VDM initialization.
#define STARTUP_INFO_RETURNED    0x200   // on return if this bit is set means
                                         // startupinfo structure was filled in.
#define ASKING_FOR_ENVIRONMENT   0x400   // ask for environment only
#define ASKING_FOR_SEPWOW_BINARY 0x800   // Caller is Separate WOW
#define ASKING_FOR_WOWPROCLIST  0x1000   // get the list of wow processes
#define ASKING_FOR_WOWTASKLIST  0x4000   // get the list of tasks in this wow process
#define ASKING_TO_ADD_WOWTASK   0x8000   // add info about a wow task.  
    

typedef struct _VDMINFO {
    ULONG  iTask;
    ULONG  dwCreationFlags;
    ULONG  ErrorCode;
    ULONG  CodePage;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    LPVOID CmdLine;
    LPVOID AppName;
    LPVOID PifFile;
    LPVOID CurDirectory;
    LPVOID Enviornment;
    ULONG  EnviornmentSize;
    STARTUPINFOA StartupInfo;
    LPVOID Desktop;
    ULONG  DesktopLen;
    LPVOID Title;
    ULONG  TitleLen;
    LPVOID Reserved;
    ULONG  ReservedLen;
    USHORT CmdSize;
    USHORT AppLen;
    USHORT PifLen;
    USHORT CurDirectoryLen;
    USHORT VDMState;
    USHORT CurDrive;
    BOOLEAN fComingFromBat;
} VDMINFO, *PVDMINFO;

//
// used to store shared task and ntvdm process info list 
//

#define MAX_SHARED_OBJECTS  200

typedef struct _SHAREDTASK {
    DWORD   dwThreadId;
    WORD    hTask16;
    WORD    hMod16;
    CHAR    szModName[9];
    CHAR    szFilePath[128];
} SHAREDTASK, *LPSHAREDTASK;

typedef struct _SHAREDPROCESS {
    DWORD   dwProcessId;
    DWORD   dwAttributes;           // WOW_SYSTEM for shared WOW
    LPTHREAD_START_ROUTINE pfnW32HungAppNotifyThread;  // For VDMTerminateTask
} SHAREDPROCESS, *LPSHAREDPROCESS;


// for CmdBatNotification

#define CMD_BAT_OPERATION_TERMINATING   0
#define CMD_BAT_OPERATION_STARTING      1

//
// Message sent by BaseSrv to shared WOWEXEC to tell it to call
// GetNextVDMCommand.  No longer will a thread in WOW be blocked
// in GetNextVDMCommand all the time.
//

#define WM_WOWEXECSTARTAPP         (WM_USER)    // also in mvdm\inc\wowinfo.h

//
//  MVDM apis
//

VOID
APIENTRY
VDMOperationStarted(
    IN BOOL IsWowCaller
    );

BOOL
APIENTRY
GetNextVDMCommand(
    PVDMINFO pVDMInfo
    );

VOID
APIENTRY
ExitVDM(
    IN BOOL IsWowCaller,
    IN ULONG iWowTask
    );

BOOL
APIENTRY
SetVDMCurrentDirectories(
    IN ULONG  cchCurDir,
    IN CHAR   *lpszCurDir
);

ULONG
APIENTRY
GetVDMCurrentDirectories(
    IN ULONG  cchCurDir,
    IN CHAR   *lpszCurDir
);

VOID
APIENTRY
CmdBatNotification(
    IN ULONG    fBeginEnd
);

NTSTATUS
APIENTRY
RegisterWowExec(
    IN HANDLE   hwndWowExec
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\vdmtib.inc ===
IFDEF NEC_98
FIXED_NTVDMSTATE_SEGMENT equ 00060H
else
FIXED_NTVDMSTATE_SEGMENT equ 00070H
endif
FIXED_NTVDMSTATE_OFFSET equ 00014H
FIXED_NTVDMSTATE_LINEAR EQU     ((FIXED_NTVDMSTATE_SEGMENT  SHL  4 ) + FIXED_NTVDMSTATE_OFFSET)
FIXED_NTVDMSTATE_SIZE equ 00004H

;
;  VdmFlags
;

VDM_INT_HARDWARE equ 00001H
VDM_INT_TIMER equ 00002H
VDM_INTERRUPT_PENDING equ 00003H
VDM_INTS_HOOKED_IN_PM equ 00004H
VDM_BREAK_EXCEPTIONS equ 00008H
VDM_BREAK_DEBUGGER equ 00010H
VDM_PROFILE equ 00020H
VDM_ANALYZE_PROFILE equ 00040H
VDM_TRACE_HISTORY equ 00080H
VDM_32BIT_APP equ 00100H
VDM_VIRTUAL_INTERRUPTS equ 00200H
VDM_VIRTUAL_AC equ 040000H
VDM_VIRTUAL_NT equ 04000H
MIPS_BIT_MASK equ 00400H
VDM_ON_MIPS equ 00400H
VDM_EXEC equ 00800H
VDM_RM equ 01000H
VDM_USE_DBG_VDMEVENT equ 04000H
VDM_WOWBLOCKED equ 0100000H
VDM_IDLEACTIVITY equ 0200000H
VDM_WOWHUNGAPP equ 0800000H
VDM_PE_MASK equ 080000000H

;
;  Interrupt handler flags
;

VDM_INT_INT_GATE equ 00001H
VDM_INT_TRAP_GATE equ 00000H
VDM_INT_32 equ 00002H
VDM_INT_16 equ 00000H
VDM_INT_HOOKED equ 00004H

;
;  EFlags values
;

EFLAGS_TF_MASK equ 00100H
EFLAGS_INTERRUPT_MASK equ 00200H
EFLAGS_IOPL_MASK equ 03000H
EFLAGS_NT_MASK equ 04000H

;
;  Selector Flags
;

SEL_TYPE_READ equ 00001H
SEL_TYPE_WRITE equ 00002H
SEL_TYPE_EXECUTE equ 00004H
SEL_TYPE_BIG equ 00008H
SEL_TYPE_ED equ 00010H
SEL_TYPE_2GIG equ 00020H

;
;  VdmEvent Enumerations
;

VdmIO equ 00000H
VdmStringIO equ 00001H
VdmMemAccess equ 00002H
VdmIntAck equ 00003H
VdmBop equ 00004H
VdmError equ 00005H
VdmIrq13 equ 00006H
VdmMaxEvent equ 00007H

;
;  VdmTib offsets
;

VtMonitorContext equ 0000CH
VtVdmContext equ 002D8H
VtInterruptTable equ 00004H
VtFaultTable equ 00008H
VtEventInfo equ 005A4H
VtEIEvent equ 005A8H
VtEIInstSize equ 005ACH
VtEIBopNumber equ 005B0H
VtEIIntAckInfo equ 005B0H
VtDpmiInfo equ 00634H
EiEvent equ 00004H
EiInstructionSize equ 00008H
EiBopNumber equ 0000CH
EiIntAckInfo equ 0000CH

;
;  WOW TD offsets
;

WtdFastWowEsp equ 00008H

;
;  VdmInterrupHandler offsets
;

ViCsSelector equ 00000H
ViEip equ 00004H
ViFlags equ 00002H
VDM_INTERRUPT_HANDLER_SIZE equ 00008H

;
;  VdmFaultHandler offsets
;

VfCsSelector equ 00000H
VfEip equ 00004H
VfSsSelector equ 00002H
VfEsp equ 00008H
VfFlags equ 0000CH
VDM_FAULT_HANDLER_SIZE equ 00010H

;
;  VdmDpmiInfo offsets
;

VpLockCount equ 00000H
VpFlags equ 00002H
VpSsSelector equ 00004H
VpSaveSsSelector equ 00006H
VpSaveEsp equ 00008H
VpSaveEip equ 0000CH
VpDosxIntIret equ 00010H
VpDosxIntIretD equ 00014H
VpDosxFaultIret equ 00018H
VpDosxFaultIretD equ 0001CH
VpDosxRmReflector equ 00020H

;
;  VdmTrace codes
;

VDMTR_KERNEL_OP_PM equ 00001H
VDMTR_KERNEL_OP_V86 equ 00002H
VDMTR_KERNEL_HW_INT equ 00003H

;
;  Misc defines
;

DBG_SINGLESTEP equ 00005H
DBG_BREAK equ 00006H
DBG_GPFAULT equ 00007H
DBG_STACKFAULT equ 00010H
STATUS_VDM_EVENT equ 040000005H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wbasek.h ===
/************************************************************************
*                                                                       *
*   wbasek.h -- This header is included by ntuser\kernel\userk.h        *
*                                                                       *
*   Copyright (c) Microsoft Corp.  All rights reserved.                 *
*                                                                       *
************************************************************************/
#ifndef _WBASEK_
#define _WBASEK_


#define WINBASEAPI DECLSPEC_IMPORT
#define WAIT_FAILED ((DWORD)0xFFFFFFFF)
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )
#define WAIT_ABANDONED         ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0       ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_IO_COMPLETION                  STATUS_USER_APC
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;
#endif

//
// System time is represented with the following structure:
//


typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

#define INFINITE            0xFFFFFFFF  // Infinite timeout
#define MAXINTATOM 0xC000
#define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)
#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_USECOUNTCHARS    0x00000008
#define STARTF_USEFILLATTRIBUTE 0x00000010
#define STARTF_RUNFULLSCREEN    0x00000020  // ignored for non-x86 platforms
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USESTDHANDLES    0x00000100
#define STARTF_USEHOTKEY        0x00000200
#define STARTF_HASSHELLDATA     0x00000400

#endif // _WBASEK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\vdm.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    vdm.h

Abstract:

    This include file defines the usermode visible portions of the vdm support

Author:

Revision History:

--*/

/* XLATOFF */

#ifndef _VDM_H_
#define _VDM_H_



typedef enum _VdmServiceClass {
    VdmStartExecution,         // is also defined in ntos\ke\i386\biosa.asm
    VdmQueueInterrupt,
    VdmDelayInterrupt,
    VdmInitialize,
    VdmFeatures,
    VdmSetInt21Handler,
    VdmQueryDir,
    VdmPrinterDirectIoOpen,
    VdmPrinterDirectIoClose,
    VdmPrinterInitialize,
    VdmSetLdtEntries,
    VdmSetProcessLdtInfo,
    VdmAdlibEmulation,
    VdmPMCliControl,
    VdmQueryVdmProcess
} VDMSERVICECLASS, *PVDMSERVICECLASS;


#if defined (_NTDEF_)

NTSYSCALLAPI
NTSTATUS
NtVdmControl(
    IN VDMSERVICECLASS Service,
    IN OUT PVOID ServiceData
    );

typedef struct _VdmQueryDirInfo {
    HANDLE FileHandle;
    PVOID FileInformation;
    ULONG Length;
    PUNICODE_STRING FileName;
    ULONG FileIndex;
} VDMQUERYDIRINFO, *PVDMQUERYDIRINFO;

//
// Definitions for VdmQueryVdmProcessData
//

typedef struct _VDM_QUERY_VDM_PROCESS_DATA {
        HANDLE          ProcessHandle;
        BOOLEAN         IsVdmProcess;
}VDM_QUERY_VDM_PROCESS_DATA, *PVDM_QUERY_VDM_PROCESS_DATA;

#endif


/*
 *  The Vdm Virtual Ica
 *  note: this structure definition is duplicated in
 *        mvdm\softpc\base\inc\ica.c. KEEP IN SYNC
 *
 */
typedef struct _VdmVirtualIca{
        LONG      ica_count[8]; /* Count of Irq pending not in irr      */
        LONG      ica_int_line; /* Current pending interrupt            */
        LONG      ica_cpu_int;  /* The state of the INT line to the CPU */
        USHORT    ica_base;     /* Interrupt base address for cpu       */
        USHORT    ica_hipri;    /* Line no. of highest priority line    */
        USHORT    ica_mode;     /* Various single-bit modes             */
        UCHAR     ica_master;   /* 1 = Master; 0 = Slave                */
        UCHAR     ica_irr;      /* Interrupt Request Register           */
        UCHAR     ica_isr;      /* In Service Register                  */
        UCHAR     ica_imr;      /* Interrupt Mask Register              */
        UCHAR     ica_ssr;      /* Slave Select Register                */
} VDMVIRTUALICA, *PVDMVIRTUALICA;


//
// copied from softpc\base\system\ica.c
//
#define ICA_AEOI 0x0020
#define ICA_SMM  0x0200
#define ICA_SFNM 0x0100


#if defined(i386)
#define VDM_PM_IRETBOPSEG  0x147
#define VDM_PM_IRETBOPOFF  0x6
#define VDM_PM_IRETBOPSIZE 8
#else
#define VDM_PM_IRETBOPSEG  0xd3
#define VDM_PM_IRETBOPOFF  0x0
#define VDM_PM_IRETBOPSIZE 4
#endif

#define VDM_RM_IRETBOPSIZE 4



// VDM state which was earlier in vdmtib->flags has been moved to
// dos arena at following fixed address.
#ifdef _VDMNTOS_

#define  FIXED_NTVDMSTATE_LINEAR    VdmFixedStateLinear
#define  FIXED_NTVDMSTATE_SIZE      4

#else  // _VDMNTOS_

/* XLATON */
#define  FIXED_NTVDMSTATE_SEGMENT   0x70

#define  FIXED_NTVDMSTATE_OFFSET    0x14
#define  FIXED_NTVDMSTATE_LINEAR    ((FIXED_NTVDMSTATE_SEGMENT << 4) + FIXED_NTVDMSTATE_OFFSET)
#define  FIXED_NTVDMSTATE_SIZE      4
/* XLATOFF */

#endif // _VDMNTOS_

#if defined (i386)
  // defined on x86 only since on mips we must reference thru sas
#define  pNtVDMState                ((PULONG)FIXED_NTVDMSTATE_LINEAR)
#endif

/* XLATON */
//
// Vdm State Flags
//
#define VDM_INT_HARDWARE        0x00000001
#define VDM_INT_TIMER           0x00000002
// defined as VDM_INTS_HOOKED_IN_PM in mvdm\inc\vint.h
#define VDM_INT_HOOK_IN_PM      0x00000004

   // A bitMask which includes all interrupts
#define VDM_INTERRUPT_PENDING   (VDM_INT_HARDWARE | VDM_INT_TIMER)

#define VDM_BREAK_EXCEPTIONS    0x00000008
#define VDM_BREAK_DEBUGGER      0x00000010
#define VDM_PROFILE             0x00000020
#define VDM_ANALYZE_PROFILE     0x00000040
#define VDM_TRACE_HISTORY       0x00000080

#define VDM_32BIT_APP           0x00000100
#define VDM_VIRTUAL_INTERRUPTS  0x00000200
#define VDM_ON_MIPS             0x00000400
#define VDM_EXEC                0x00000800
#define VDM_RM                  0x00001000
#define VDM_USE_DBG_VDMEVENT    0x00004000

#define VDM_WOWBLOCKED          0x00100000
#define VDM_IDLEACTIVITY        0x00200000
#define VDM_TIMECHANGE          0x00400000
#define VDM_WOWHUNGAPP          0x00800000

#define VDM_HANDSHAKE           0x01000000

#define VDM_PE_MASK             0x80000000

/* XLATOFF */

#if DBG
#define INITIAL_VDM_TIB_FLAGS (VDM_USE_DBG_VDMEVENT | VDM_BREAK_DEBUGGER | VDM_TRACE_HISTORY)
#else
#define INITIAL_VDM_TIB_FLAGS (VDM_USE_DBG_VDMEVENT | VDM_BREAK_DEBUGGER)
#endif


//
// bits defined in Eflags
//
#define EFLAGS_TF_MASK  0x00000100
#define EFLAGS_IF_MASK  0x00000200
#define EFLAGS_PL_MASK  0x00003000
#define EFLAGS_NT_MASK  0x00004000
#define EFLAGS_RF_MASK  0x00010000
#define EFLAGS_VM_MASK  0x00020000
#define EFLAGS_AC_MASK  0x00040000

//
// If the size of the structure is changed, ke\i386\instemul.asm must
// be modified too.  If not, it will fail to build
//
#pragma pack(1)
typedef struct _Vdm_InterruptHandler {
    USHORT  CsSelector;
    USHORT  Flags;
    ULONG   Eip;
} VDM_INTERRUPTHANDLER, *PVDM_INTERRUPTHANDLER;
#pragma pack()

typedef struct _Vdm_FaultHandler {
    USHORT  CsSelector;
    USHORT  SsSelector;
    ULONG   Eip;
    ULONG   Esp;
    ULONG   Flags;
} VDM_FAULTHANDLER, *PVDM_FAULTHANDLER;

#pragma pack(1)
typedef struct _VdmDpmiInfo {        /* VDMTIB */
    USHORT LockCount;
    USHORT Flags;
    USHORT SsSelector;
    USHORT SaveSsSelector;
    ULONG  SaveEsp;
    ULONG  SaveEip;
    ULONG  DosxIntIret;
    ULONG  DosxIntIretD;
    ULONG  DosxFaultIret;
    ULONG  DosxFaultIretD;
    ULONG  DosxRmReflector;
} VDM_DPMIINFO, *PVDM_DPMIINFO;
#pragma pack()

//
// Interrupt handler flags
//

#define VDM_INT_INT_GATE        0x00000001
#define VDM_INT_TRAP_GATE       0x00000000
#define VDM_INT_32              0x00000002
#define VDM_INT_16              0x00000000
#define VDM_INT_HOOKED          0x00000004

#pragma pack(1)
//
// CAVEAT: This structure was designed to be exactly 64 bytes in size.
// There is code that assumes that an array of these structures
// will fit neatly into a 4096 byte page.
//
typedef struct _VdmTraceEntry {
    USHORT Type;
    USHORT wData;
    ULONG lData;
    ULONG Time;
    ULONG eax;
    ULONG ebx;
    ULONG ecx;
    ULONG edx;
    ULONG esi;
    ULONG edi;
    ULONG ebp;
    ULONG esp;
    ULONG eip;
    ULONG eflags;
    USHORT cs;
    USHORT ds;
    USHORT es;
    USHORT fs;
    USHORT gs;
    USHORT ss;
} VDM_TRACEENTRY, *PVDM_TRACEENTRY;
#pragma pack()

#pragma pack(1)
typedef struct _VdmTraceInfo {
    PVDM_TRACEENTRY pTraceTable;
    UCHAR Flags;
    UCHAR NumPages;             // size of trace buffer in 4k pages
    USHORT CurrentEntry;
    LARGE_INTEGER TimeStamp;
} VDM_TRACEINFO, *PVDM_TRACEINFO;
#pragma pack()

//
// Definitions for flags in VDM_TRACEINFO
//

#define VDMTI_TIMER_MODE    3
#define VDMTI_TIMER_TICK    1
#define VDMTI_TIMER_PERFCTR 2
#define VDMTI_TIMER_STAT    3
#define VDMTI_TIMER_PENTIUM 3

//
// Kernel trace entry types
//
#define VDMTR_KERNEL_OP_PM  1
#define VDMTR_KERNEL_OP_V86 2
#define VDMTR_KERNEL_HW_INT 3


#if defined(i386)

typedef struct _VdmIcaUserData {
    PVOID                  pIcaLock;       // rtl critical section
    PVDMVIRTUALICA         pIcaMaster;
    PVDMVIRTUALICA         pIcaSlave;
    PULONG                 pDelayIrq;
    PULONG                 pUndelayIrq;
    PULONG                 pDelayIret;
    PULONG                 pIretHooked;
    PULONG                 pAddrIretBopTable;
    PHANDLE                phWowIdleEvent;
    PLARGE_INTEGER         pIcaTimeout;
    PHANDLE                phMainThreadSuspended;
}VDMICAUSERDATA, *PVDMICAUSERDATA;

typedef struct _VdmDelayIntsServiceData {
        ULONG       Delay;          /* Delay Time in usecs              */
        ULONG       DelayIrqLine;   /* IRQ Number of ints delayed       */
        HANDLE      hThread;        /* Thread Handle of CurrentMonitorTeb */
}VDMDELAYINTSDATA, *PVDMDELAYINTSDATA;

typedef struct _VDMSET_INT21_HANDLER_DATA {
        ULONG       Selector;
        ULONG       Offset;
        BOOLEAN     Gate32;
}VDMSET_INT21_HANDLER_DATA, *PVDMSET_INT21_HANDLER_DATA;

typedef struct _VDMSET_LDT_ENTRIES_DATA {
        ULONG Selector0;
        ULONG Entry0Low;
        ULONG Entry0Hi;
        ULONG Selector1;
        ULONG Entry1Low;
        ULONG Entry1Hi;
}VDMSET_LDT_ENTRIES_DATA, *PVDMSET_LDT_ENTRIES_DATA;

typedef struct _VDMSET_PROCESS_LDT_INFO_DATA {
        PVOID LdtInformation;
        ULONG LdtInformationLength;
}VDMSET_PROCESS_LDT_INFO_DATA, *PVDMSET_PROCESS_LDT_INFO_DATA;

//
// Define the action code of VDM_ADLIB_DATA
//

#define ADLIB_USER_EMULATION     0      // default action
#define ADLIB_DIRECT_IO          1
#define ADLIB_KERNEL_EMULATION   2

typedef struct _VDM_ADLIB_DATA {
        USHORT VirtualPortStart;
        USHORT VirtualPortEnd;
        USHORT PhysicalPortStart;
        USHORT PhysicalPortEnd;
        USHORT Action;
}VDM_ADLIB_DATA, *PVDM_ADLIB_DATA;

//
// Definitions for Protected Mode DOS apps cli control
//

#define PM_CLI_CONTROL_DISABLE  0
#define PM_CLI_CONTROL_ENABLE   1
#define PM_CLI_CONTROL_CHECK    2
#define PM_CLI_CONTROL_SET      3
#define PM_CLI_CONTROL_CLEAR    4

typedef struct _VDM_PM_CLI_DATA {
        ULONG Control;
}VDM_PM_CLI_DATA, *PVDM_PM_CLI_DATA;

//
// Definitions for VdmInitialize
//

typedef struct _VDM_INITIALIZE_DATA {
        PVOID           TrapcHandler;
        PVDMICAUSERDATA IcaUserData;
}VDM_INITIALIZE_DATA, *PVDM_INITIALIZE_DATA;

#if defined (_NTDEF_)
typedef enum _VdmEventClass {
    VdmIO,
    VdmStringIO,
    VdmMemAccess,
    VdmIntAck,
    VdmBop,
    VdmError,
    VdmIrq13,
    VdmHandShakeAck,
    VdmMaxEvent
} VDMEVENTCLASS, *PVDMEVENTCLASS;

// VdmPrinterInfo

#define VDM_NUMBER_OF_LPT       3

#define PRT_MODE_NO_SIMULATION  1
#define PRT_MODE_SIMULATE_STATUS_PORT   2
#define PRT_MODE_DIRECT_IO      3
#define PRT_MODE_VDD_CONNECTED  4

#define PRT_DATA_BUFFER_SIZE    16

typedef struct _Vdm_Printer_Info {
    PUCHAR prt_State;
    PUCHAR prt_Control;
    PUCHAR prt_Status;
    PUCHAR prt_HostState;
    USHORT prt_PortAddr[VDM_NUMBER_OF_LPT];
    HANDLE prt_Handle[VDM_NUMBER_OF_LPT];
    UCHAR  prt_Mode[VDM_NUMBER_OF_LPT];
    USHORT prt_BytesInBuffer[VDM_NUMBER_OF_LPT];
    UCHAR  prt_Buffer[VDM_NUMBER_OF_LPT][PRT_DATA_BUFFER_SIZE];
    ULONG  prt_Scratch;
} VDM_PRINTER_INFO, *PVDM_PRINTER_INFO;


typedef struct _VdmIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Read;
} VDMIOINFO, *PVDMIOINFO;

typedef struct _VdmFaultInfo{
    ULONG  FaultAddr;
    ULONG  RWMode;
} VDMFAULTINFO, *PVDMFAULTINFO;


typedef struct _VdmStringIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Rep;
    BOOLEAN Read;
    ULONG Count;
    ULONG Address;
} VDMSTRINGIOINFO, *PVDMSTRINGIOINFO;

typedef ULONG VDMBOPINFO;
typedef NTSTATUS VDMERRORINFO;


typedef ULONG VDMINTACKINFO;
#define VDMINTACK_RAEOIMASK  0x0000ffff
#define VDMINTACK_SLAVE      0x00010000
#define VDMINTACK_AEOI       0x00020000

// Family table definition for Dynamic Patch Module support
typedef struct _tagFAMILY_TABLE {
    int      numHookedAPIs;           // number of hooked API's in this family
    PVOID    hModShimEng;             // hMod of shim engine
    PVOID    hMod;                    // hMod of associated loaded dll.
    PVOID   *DpmMisc;                 // ptr to DPM Module specific data
    PVOID   *pDpmShmTbls;             // array of ptrs to API family shim tables
    PVOID   *pfn;                     // array of ptrs to hook functions
} FAMILY_TABLE, *PFAMILY_TABLE;

typedef struct _VdmEventInfo {
    ULONG Size;
    VDMEVENTCLASS Event;
    ULONG InstructionSize;
    union {
        VDMIOINFO IoInfo;
        VDMSTRINGIOINFO StringIoInfo;
        VDMBOPINFO BopNumber;
        VDMFAULTINFO FaultInfo;
        VDMERRORINFO ErrorStatus;
        VDMINTACKINFO IntAckInfo;
    };
} VDMEVENTINFO, *PVDMEVENTINFO;


// Sudeepb 12-Mar-1993
// Scratch areas are used from VDMTib to get user space while
// in kernel. This allows us to make Nt APIs (faster) from kernel
// rather than Zw apis (slower). These are currently being used
// for DOS read/write.

typedef struct _Vdm_Tib {
    ULONG Size;
    PVDM_INTERRUPTHANDLER VdmInterruptTable;
    PVDM_FAULTHANDLER VdmFaultTable;
    CONTEXT MonitorContext;
    CONTEXT VdmContext;
    VDMEVENTINFO EventInfo;
    VDM_PRINTER_INFO PrinterInfo;
    ULONG TempArea1[2];                 // Scratch area
    ULONG TempArea2[2];                 // Scratch aArea
    VDM_DPMIINFO DpmiInfo;
    VDM_TRACEINFO TraceInfo;
    ULONG IntelMSW;
    LONG NumTasks;
    PFAMILY_TABLE *pDpmFamTbls;  // array of ptrs to API family tables
    BOOLEAN ContinueExecution;
} VDM_TIB, *PVDM_TIB;

//
// Feature flags returned by NtVdmControl(VdmFeatures...)
//

// System/processor supports fast emulation for IF instructions
#define V86_VIRTUAL_INT_EXTENSIONS 0x00000001   // in v86 mode
#define PM_VIRTUAL_INT_EXTENSIONS  0x00000002   // in protected mode (non-flat)

#endif   // if defined _NTDEF_
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winbasep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winbasep.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the Base
    component.

--*/
#ifndef _WINBASEP_
#define _WINBASEP_
#ifdef __cplusplus
extern "C" {
#endif
#define FILE_FLAG_GLOBAL_HANDLE         0x00800000
#define FILE_FLAG_MM_CACHED_FILE_HANDLE 0x00400000
WINBASEAPI
DWORD
WINAPI
HeapCreateTagsW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPCWSTR lpTagPrefix,
    IN LPCWSTR lpTagNames
    );

typedef struct _HEAP_TAG_INFO {
    DWORD dwNumberOfAllocations;
    DWORD dwNumberOfFrees;
    DWORD dwBytesAllocated;
} HEAP_TAG_INFO, *PHEAP_TAG_INFO;
typedef PHEAP_TAG_INFO LPHEAP_TAG_INFO;

WINBASEAPI
LPCWSTR
WINAPI
HeapQueryTagW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN WORD wTagIndex,
    IN BOOL bResetCounters,
    OUT LPHEAP_TAG_INFO TagInfo
    );

typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

BOOL
WINAPI
HeapSummary(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    OUT LPHEAP_SUMMARY lpSummary
    );

BOOL
WINAPI
HeapExtend(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpBase,
    IN DWORD dwBytes
    );

typedef struct _HEAP_USAGE_ENTRY {
    struct _HEAP_USAGE_ENTRY *lpNext;
    PVOID lpAddress;
    DWORD dwBytes;
    DWORD dwReserved;
} HEAP_USAGE_ENTRY, *PHEAP_USAGE_ENTRY;

typedef struct _HEAP_USAGE {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
    PHEAP_USAGE_ENTRY lpEntries;
    PHEAP_USAGE_ENTRY lpAddedEntries;
    PHEAP_USAGE_ENTRY lpRemovedEntries;
    DWORD Reserved[ 8 ];
} HEAP_USAGE, *PHEAP_USAGE;

BOOL
WINAPI
HeapUsage(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN BOOL bFirstCall,
    IN BOOL bLastCall,
    OUT PHEAP_USAGE lpUsage
    );

#define HFINDFILE HANDLE                        //
#define INVALID_HFINDFILE       ((HFINDFILE)-1) //
typedef DWORD (*PFNWAITFORINPUTIDLE)(HANDLE hProcess, DWORD dwMilliseconds);
VOID RegisterWaitForInputIdle(PFNWAITFORINPUTIDLE);

#define STARTF_HASSHELLDATA     0x00000400
#define STARTF_TITLEISLINKNAME  0x00000800
WINBASEAPI
BOOL
WINAPI
CreateProcessInternalA(
    IN HANDLE hUserToken,
    IN LPCSTR lpApplicationName,
    IN LPSTR lpCommandLine,
    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN BOOL bInheritHandles,
    IN DWORD dwCreationFlags,
    IN LPVOID lpEnvironment,
    IN LPCSTR lpCurrentDirectory,
    IN LPSTARTUPINFOA lpStartupInfo,
    OUT LPPROCESS_INFORMATION lpProcessInformation,
    OUT PHANDLE hRestrictedUserToken
    );
WINBASEAPI
BOOL
WINAPI
CreateProcessInternalW(
    IN HANDLE hUserToken,
    IN LPCWSTR lpApplicationName,
    IN LPWSTR lpCommandLine,
    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
    IN BOOL bInheritHandles,
    IN DWORD dwCreationFlags,
    IN LPVOID lpEnvironment,
    IN LPCWSTR lpCurrentDirectory,
    IN LPSTARTUPINFOW lpStartupInfo,
    OUT LPPROCESS_INFORMATION lpProcessInformation,
    OUT PHANDLE hRestrictedUserToken
    );
#ifdef UNICODE
#define CreateProcessInternal  CreateProcessInternalW
#else
#define CreateProcessInternal  CreateProcessInternalA
#endif // !UNICODE

#if (_WIN32_WINNT >= 0x0500)

#define PRIVCOPY_FILE_METADATA           0x010  // Copy compression, DACL, (encryption)
#define PRIVCOPY_FILE_SACL               0x020  // Copy SACL
#define PRIVCOPY_FILE_OWNER_GROUP        0x040  // Copy owner & group
#define PRIVCOPY_FILE_DIRECTORY          0x080  // Copy directory file like a file
#define PRIVCOPY_FILE_BACKUP_SEMANTICS   0x100  // Use FILE_FLAG_BACKUP_SEMANTICS on open/creates.
#define PRIVCOPY_FILE_SUPERSEDE          0x200  // Replace original dest with source
#define PRIVCOPY_FILE_SKIP_DACL          0x400  // Workaround for csc/roamprofs
#define PRIVCOPY_FILE_VALID_FLAGS   (PRIVCOPY_FILE_METADATA|PRIVCOPY_FILE_SACL|PRIVCOPY_FILE_OWNER_GROUP|PRIVCOPY_FILE_DIRECTORY|PRIVCOPY_FILE_SUPERSEDE|PRIVCOPY_FILE_BACKUP_SEMANTICS|PRIVCOPY_FILE_SKIP_DACL)

#define PRIVPROGRESS_REASON_NOT_HANDLED                 4

#define PRIVCALLBACK_STREAMS_NOT_SUPPORTED              2
#define PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED          5
#define PRIVCALLBACK_COMPRESSION_FAILED                 6
#define PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED           8
#define PRIVCALLBACK_ENCRYPTION_FAILED                  9
#define PRIVCALLBACK_EAS_NOT_SUPPORTED                  10
#define PRIVCALLBACK_SPARSE_NOT_SUPPORTED               11
#define PRIVCALLBACK_SPARSE_FAILED                      12
#define PRIVCALLBACK_DACL_ACCESS_DENIED                 13
#define PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED          14
#define PRIVCALLBACK_OWNER_GROUP_FAILED                 19
#define PRIVCALLBACK_SACL_ACCESS_DENIED                 15
#define PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED 16
#define PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE           17

#define PRIVMOVE_FILEID_DELETE_OLD_FILE     0x01
#define PRIVMOVE_FILEID_IGNORE_ID_ERRORS    0x02

BOOL
APIENTRY
PrivMoveFileIdentityW(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );

BOOL
APIENTRY
PrivCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    );
#endif // (_WIN32_WINNT >= 0x0500)

    
WINBASEAPI
DWORD
WINAPI
AddLocalAlternateComputerNameA (
    IN LPCSTR lpDnsFQHostname,
    IN ULONG    ulFlags
    );
WINBASEAPI
DWORD
WINAPI
AddLocalAlternateComputerNameW (
    IN LPCWSTR lpDnsFQHostname,
    IN ULONG    ulFlags
    );
#ifdef UNICODE
#define AddLocalAlternateComputerName  AddLocalAlternateComputerNameW
#else
#define AddLocalAlternateComputerName  AddLocalAlternateComputerNameA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
RemoveLocalAlternateComputerNameA (
    IN LPCSTR lpAltDnsFQHostname,
    IN ULONG    ulFlags
    );
WINBASEAPI
DWORD
WINAPI
RemoveLocalAlternateComputerNameW (
    IN LPCWSTR lpAltDnsFQHostname,
    IN ULONG    ulFlags
    );
#ifdef UNICODE
#define RemoveLocalAlternateComputerName  RemoveLocalAlternateComputerNameW
#else
#define RemoveLocalAlternateComputerName  RemoveLocalAlternateComputerNameA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
SetLocalPrimaryComputerNameA (
    IN LPCSTR  lpAltDnsFQHostname,
    IN ULONG     ulFlags
    );
WINBASEAPI
DWORD
WINAPI
SetLocalPrimaryComputerNameW (
    IN LPCWSTR  lpAltDnsFQHostname,
    IN ULONG     ulFlags
    );
#ifdef UNICODE
#define SetLocalPrimaryComputerName  SetLocalPrimaryComputerNameW
#else
#define SetLocalPrimaryComputerName  SetLocalPrimaryComputerNameA
#endif // !UNICODE

typedef enum _COMPUTER_NAME_TYPE {
    PrimaryComputerName,
    AlternateComputerNames,
    AllComputerNames,
    ComputerNameTypeMax
} COMPUTER_NAME_TYPE ;

WINBASEAPI
DWORD
WINAPI
EnumerateLocalComputerNamesA (
    IN COMPUTER_NAME_TYPE        NameType,
    IN ULONG                     ulFlags,
    IN OUT LPSTR               lpDnsFQHostname,
    IN OUT LPDWORD               nSize
    );
WINBASEAPI
DWORD
WINAPI
EnumerateLocalComputerNamesW (
    IN COMPUTER_NAME_TYPE        NameType,
    IN ULONG                     ulFlags,
    IN OUT LPWSTR               lpDnsFQHostname,
    IN OUT LPDWORD               nSize
    );
#ifdef UNICODE
#define EnumerateLocalComputerNames  EnumerateLocalComputerNamesW
#else
#define EnumerateLocalComputerNames  EnumerateLocalComputerNamesA
#endif // !UNICODE


BOOL
WINAPI
CloseProfileUserMapping( VOID );

BOOL
WINAPI
OpenProfileUserMapping( VOID );

typedef struct _VIRTUAL_BUFFER {
    PVOID Base;
    PVOID CommitLimit;
    PVOID ReserveLimit;
} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER;

BOOLEAN
WINAPI
CreateVirtualBuffer(
    OUT PVIRTUAL_BUFFER Buffer,
    IN ULONG CommitSize OPTIONAL,
    IN ULONG ReserveSize OPTIONAL
    );

int
WINAPI
VirtualBufferExceptionHandler(
    IN ULONG ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PVIRTUAL_BUFFER Buffer
    );

BOOLEAN
WINAPI
ExtendVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer,
    IN PVOID Address
    );

BOOLEAN
WINAPI
TrimVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    );

BOOLEAN
WINAPI
FreeVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    );


//
// filefind stucture shared with ntvdm, jonle
// see mvdm\dos\dem\demsrch.c
//
typedef struct _FINDFILE_HANDLE {
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;

#define BASE_FIND_FIRST_DEVICE_HANDLE (HANDLE)1

WINBASEAPI
BOOL
WINAPI
GetDaylightFlag(VOID);

WINBASEAPI
BOOL
WINAPI
SetDaylightFlag(
    BOOL fDaylight
    );

WINBASEAPI
BOOL
WINAPI
FreeLibrary16(
    HINSTANCE hLibModule
    );

WINBASEAPI
FARPROC
WINAPI
GetProcAddress16(
    HINSTANCE hModule,
    LPCSTR lpProcName
    );

WINBASEAPI
HINSTANCE
WINAPI
LoadLibrary16(
    LPCSTR lpLibFileName
    );

WINBASEAPI
BOOL
APIENTRY
NukeProcess(
    DWORD ppdb,
    UINT uExitCode,
    DWORD ulFlags);

WINBASEAPI
HGLOBAL
WINAPI
GlobalAlloc16(
    UINT uFlags,
    DWORD dwBytes
    );

WINBASEAPI
LPVOID
WINAPI
GlobalLock16(
    HGLOBAL hMem
    );

WINBASEAPI
BOOL
WINAPI
GlobalUnlock16(
    HGLOBAL hMem
    );

WINBASEAPI
HGLOBAL
WINAPI
GlobalFree16(
    HGLOBAL hMem
    );

WINBASEAPI
DWORD
WINAPI
GlobalSize16(
    HGLOBAL hMem
    );


WINBASEAPI
DWORD
WINAPI
RegisterServiceProcess(
    IN DWORD dwProcessId,
    IN DWORD dwServiceType
    );

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001



WINBASEAPI
VOID
WINAPI
ReinitializeCriticalSection(
    IN LPCRITICAL_SECTION lpCriticalSection
    );


//
// New Multi-User specific routines to support per session
// network driver mappings. Related to Wksvc changes
//

WINBASEAPI
BOOL
WINAPI
DosPathToSessionPathA(
    IN  DWORD   SessionId,
    IN  LPCSTR  pInPath,
    OUT LPSTR  *ppOutPath
    );
WINBASEAPI
BOOL
WINAPI
DosPathToSessionPathW(
    IN  DWORD   SessionId,
    IN  LPCWSTR  pInPath,
    OUT LPWSTR  *ppOutPath
    );

//terminal server time zone support
BOOL
WINAPI
SetClientTimeZoneInformation(
     IN CONST TIME_ZONE_INFORMATION *ptzi
     );

#ifdef UNICODE
#define DosPathToSessionPath DosPathToSessionPathW
#else
#define DosPathToSessionPath DosPathToSessionPathA
#endif // !UNICODE

#define COMPLUS_ENABLE_64BIT           0x00000001

#define COMPLUS_INSTALL_FLAGS_INVALID  (~(COMPLUS_ENABLE_64BIT))

ULONG
WINAPI
GetComPlusPackageInstallStatus(
    VOID
    );

BOOL
WINAPI
SetComPlusPackageInstallStatus(
    ULONG ComPlusPackage
    );
#ifdef __cplusplus
}
#endif
#endif  // ndef _WINBASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winbrand.h ===
/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    winbrand.h

Abstract:

    Definitions for Windows Branding Resources

Notes:

    1 ) Window Branding resource DLL will be shared by multiple components, thus component owners have to 
    do their best practices to avoid resource id and name conflicts. 

    To avoid id conflicts, owners should use RESOURCE_ID_BLOCK_SiZE as the base resource id 
    range unit, and define component resource base ID and block numbers for each resource 
    type as appropriate. Before adding resources, owners have to make sure newly defined IDs 
    are not overlapping other components' id ranges

    For resource id name defines, owner should include the component name in name define to
    avoid conflicts. 

    See below for an example of defining string IDs for foo.dll

    #define IDS_BASE_FOO_DLL        1000
    #define IDS_BLOCK_NUM_FOO_DLL   2

    //
    // Foo.dll occupies resource string id range 1000 - 1199 
    //

    #define IDS_XXX_FOO_DLL     1000
    ... 
    #define IDS_YYY_FOO_DLL     1101



Revision History:



*/


#ifndef __WINBRAND_H_
#define __WINBRAND_H_

#define RESOURCE_ID_BLOCK_SiZE     100



//
// msgina.dll occupies resource bitmap ID range 1000-1099
//

#define IDB_BASE_MSGINA_DLL                                 1000
#define IDB_BLOCK_NUM_MSGINA_DLL                            1

#define IDB_SMALL_PROTAB_8_MSGINA_DLL                       1000
#define IDB_MEDIUM_PROTAB_8_MSGINA_DLL                      1001
#define IDB_MEDIUM_PROTAB_4_MSGINA_DLL                      1002
#define IDB_SMALL_PROTAB_4_MSGINA_DLL                       1003
#define IDB_SMALL_PROMED_8_MSGINA_DLL                       1004
#define IDB_MEDIUM_PROMED_8_MSGINA_DLL                      1005
#define IDB_MEDIUM_PROMED_4_MSGINA_DLL                      1006
#define IDB_SMALL_PROMED_4_MSGINA_DLL                       1007
#define IDB_SMALL_SRVAPP_4_MSGINA_DLL                       1008
#define IDB_MEDIUM_SRVAPP_4_MSGINA_DLL                      1009
#define IDB_SMALL_SRVAPP_8_MSGINA_DLL                       1010
#define IDB_MEDIUM_SRVAPP_8_MSGINA_DLL                      1011

//
// shell32.dll occupies resource bitmap ID range 1100-1199
//

#define IDB_BASE_SHELL32_DLL                                1100
#define IDB_BLOCK_NUM_SHELL32_DLL                           1

#define IDB_ABOUTTABLETPC16_SHELL32_DLL                     1100
#define IDB_ABOUTTABLETPC256_SHELL32_DLL                    1101
#define IDB_ABOUTMEDIACENTER16_SHELL32_DLL                  1102
#define IDB_ABOUTMEDIACENTER256_SHELL32_DLL                 1103
#define IDB_ABOUTAPPLIANCE16_SHELL32_DLL                    1104
#define IDB_ABOUTAPPLIANCE256_SHELL32_DLL                   1105

//
// logon.scr occupies resource bitmap ID range 1200-1299
//
#define IDB_TABLETPC_LOGON_SCR                              1200
#define IDB_MEDIACENTER_LOGON_SCR                           1201


#define IDB_BASE_EXPLORER_EXE               1300

#define IDB_TABLETPC_STARTBKG               1301
#define IDB_MEDIACENTER_STARTBKG            1302


//
// sysdm.cpl occupies resource string ID range 2000-2099
//

#define IDS_BASE_SYSDM_CPL                                  2000
#define IDS_BLOCK_NUM_SYSDM_CPL                             1

#define IDS_WINVER_TABLETPC_SYSDM_CPL                       2000
#define IDS_WINVER_MEDIACENTER_SYSDM_CPL                    2001
#define IDS_WINVER_APPLIANCE_SYSDM_CPL                      2002


#endif //__WINBRAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winnlsp.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winnlsp.h

Abstract:

    Private procedure declarations, constant definitions, and macros for the
    NLS component.

--*/

#ifndef _WINNLSP_
#define _WINNLSP_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Flags for DLL Code Page Translation Function.
//
#define NLS_CP_CPINFO             0x10000000
#define NLS_CP_CPINFOEX           0x20000000
#define NLS_CP_MBTOWC             0x40000000
#define NLS_CP_WCTOMB             0x80000000


#define NORM_STOP_ON_NULL         0x10000000  // stop at the null termination

#define LCMAP_IGNOREDBCS          0x80000000  // don't casemap DBCS characters

#define LOCALE_IGEOID                 0x0000005B   // geographical location id
//
// LCType to represent the registry locale value
//
#define LOCALE_SLOCALE                (-1)
#define DATE_ADDHIJRIDATETEMP     0x80000000  // use AddHijriDateTemp reg value
WINBASEAPI
BOOL
WINAPI
InvalidateNLSCache(void);


//
//  This private API is only called by the Complex Script
//  Language Pack (CSLPK).
//
ULONG
WINAPI NlsGetCacheUpdateCount(void);


//
// This API is called only from intl.cpl when the user
// locale changes.
//
void
WINAPI
NlsResetProcessLocale(void);

//
// This API is called by system console Apps
//
LANGID
WINAPI
SetThreadUILanguage(WORD wReserved);

//
// This API can be used to verify if a UI language is installed.
//
BOOL
WINAPI
IsValidUILanguage(LANGID UILangID);
//
// These definitions are used by both winnls and base\server
//

//
//  Names of Registry Value Entries.
//
#define NLS_VALUE_ACP              L"ACP"
#define NLS_VALUE_OEMCP            L"OEMCP"
#define NLS_VALUE_MACCP            L"MACCP"
#define NLS_VALUE_DEFAULT          L"Default"

//  User Info
#define NLS_VALUE_LOCALE           L"Locale"
#define NLS_VALUE_SLANGUAGE        L"sLanguage"
#define NLS_VALUE_ICOUNTRY         L"iCountry"
#define NLS_VALUE_SCOUNTRY         L"sCountry"
#define NLS_VALUE_SLIST            L"sList"
#define NLS_VALUE_IMEASURE         L"iMeasure"
#define NLS_VALUE_IPAPERSIZE       L"iPaperSize"
#define NLS_VALUE_SDECIMAL         L"sDecimal"
#define NLS_VALUE_STHOUSAND        L"sThousand"
#define NLS_VALUE_SGROUPING        L"sGrouping"
#define NLS_VALUE_IDIGITS          L"iDigits"
#define NLS_VALUE_ILZERO           L"iLZero"
#define NLS_VALUE_INEGNUMBER       L"iNegNumber"
#define NLS_VALUE_SNATIVEDIGITS    L"sNativeDigits"
#define NLS_VALUE_IDIGITSUBST      L"NumShape"
#define NLS_VALUE_SCURRENCY        L"sCurrency"
#define NLS_VALUE_SMONDECIMALSEP   L"sMonDecimalSep"
#define NLS_VALUE_SMONTHOUSANDSEP  L"sMonThousandSep"
#define NLS_VALUE_SMONGROUPING     L"sMonGrouping"
#define NLS_VALUE_ICURRDIGITS      L"iCurrDigits"
#define NLS_VALUE_ICURRENCY        L"iCurrency"
#define NLS_VALUE_INEGCURR         L"iNegCurr"
#define NLS_VALUE_SPOSITIVESIGN    L"sPositiveSign"
#define NLS_VALUE_SNEGATIVESIGN    L"sNegativeSign"
#define NLS_VALUE_STIMEFORMAT      L"sTimeFormat"
#define NLS_VALUE_STIME            L"sTime"
#define NLS_VALUE_ITIME            L"iTime"
#define NLS_VALUE_ITLZERO          L"iTLZero"
#define NLS_VALUE_ITIMEMARKPOSN    L"iTimePrefix"
#define NLS_VALUE_S1159            L"s1159"
#define NLS_VALUE_S2359            L"s2359"
#define NLS_VALUE_SSHORTDATE       L"sShortDate"
#define NLS_VALUE_SDATE            L"sDate"
#define NLS_VALUE_IDATE            L"iDate"
#define NLS_VALUE_SYEARMONTH       L"sYearMonth"
#define NLS_VALUE_SLONGDATE        L"sLongDate"
#define NLS_VALUE_ICALENDARTYPE    L"iCalendarType"
#define NLS_VALUE_IFIRSTDAYOFWEEK  L"iFirstDayOfWeek"
#define NLS_VALUE_IFIRSTWEEKOFYEAR L"iFirstWeekOfYear"


//
//  String constants for CreateSection/OpenSection name string.
//
#define NLS_SECTION_CPPREFIX       L"\\NLS\\NlsSectionCP"
#define NLS_SECTION_LANGPREFIX     L"\\NLS\\NlsSectionLANG"

#define NLS_SECTION_UNICODE        L"\\NLS\\NlsSectionUnicode"
#define NLS_SECTION_LOCALE         L"\\NLS\\NlsSectionLocale"
#define NLS_SECTION_CTYPE          L"\\NLS\\NlsSectionCType"
#define NLS_SECTION_SORTKEY        L"\\NLS\\NlsSectionSortkey"
#define NLS_SECTION_SORTTBLS       L"\\NLS\\NlsSectionSortTbls"
#define NLS_SECTION_LANG_INTL      L"\\NLS\\NlsSectionLANG_INTL"
#define NLS_SECTION_LANG_EXCEPT    L"\\NLS\\NlsSectionLANG_EXCEPT"
#define NLS_SECTION_GEO            L"\\NLS\\NlsSectionGeo"

//
//  Unicode file names.
//  These files will always be installed by setup in the system directory,
//  so there is no need to put these names in the registry.
//
#define NLS_FILE_UNICODE           L"unicode.nls"
#define NLS_FILE_LOCALE            L"locale.nls"
#define NLS_FILE_CTYPE             L"ctype.nls"
#define NLS_FILE_SORTKEY           L"sortkey.nls"
#define NLS_FILE_SORTTBLS          L"sorttbls.nls"
#define NLS_FILE_LANG_INTL         L"l_intl.nls"
#define NLS_FILE_LANG_EXCEPT       L"l_except.nls"
#define NLS_FILE_GEO               L"geo.nls"

//
//  Default file names if registry is corrupt.
//
#define NLS_DEFAULT_FILE_ACP       L"c_1252.nls"
#define NLS_DEFAULT_FILE_OEMCP     L"c_437.nls"



//
//  Default section names if registry is corrupt.
//
#define NLS_DEFAULT_SECTION_ACP    L"\\NLS\\NlsSectionCP1252"
#define NLS_DEFAULT_SECTION_OEMCP  L"\\NLS\\NlsSectionCP437"

#ifdef _WINDOWS_BASE
//
//  winnls routines that are called from base\server.  The prototypes must
//  continue to match the typedefs.
//

typedef ULONG
(*PNLS_CONVERT_INTEGER_TO_STRING)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);
ULONG
NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);

typedef BOOL
(*PGET_CP_FILE_NAME_FROM_REGISTRY)(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);
BOOL
GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);

typedef ULONG
(*PCREATE_NLS_SECURITY_DESCRIPTOR)(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    UINT                    SecurityDescriptorSize,
    ACCESS_MASK             AccessMask);

ULONG
CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    UINT                    SecurityDescriptorSize,
    ACCESS_MASK             AccessMask);

typedef ULONG
(*PGET_NLS_SECTION_NAME)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);
ULONG
GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);


typedef WINBASEAPI BOOL
(WINAPI *PIS_VALID_CODEPAGE)(
    UINT CodePage);
WINBASEAPI BOOL WINAPI
IsValidCodePage(
    UINT CodePage);

typedef ULONG
(*POPEN_DATA_FILE)(HANDLE *phFile, LPWSTR pFile);
ULONG OpenDataFile(HANDLE *phFile, LPWSTR pFile);

typedef ULONG
(*PGET_DEFAULT_SORTKEY_SIZE)(PLARGE_INTEGER pSize);
ULONG GetDefaultSortkeySize(PLARGE_INTEGER pSize);

typedef ULONG
(*PGET_LINGUIST_LANG_SIZE)(PLARGE_INTEGER pSize);
ULONG GetLinguistLangSize(PLARGE_INTEGER pSize);

typedef BOOL
(*PVALIDATE_LOCALE)(LCID Locale);
BOOL ValidateLocale(LCID Locale);

typedef BOOL
(*PVALIDATE_LCTYPE)(PVOID pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);
BOOL ValidateLCType(PNLS_USER_INFO pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);

typedef BOOL
(*PNLS_LOAD_STRING_EX_W)(HMODULE hModule, UINT wID, LPWSTR lpBuffer, int cchBufferMax, WORD wLangId);
int NlsLoadStringExW(HMODULE hModule, UINT wID, LPWSTR lpBuffer, int cchBufferMax, WORD wLangId);

#endif // _WINDOWS_BASE

#ifdef __cplusplus
}
#endif

#endif // _WINNLSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winnt32p.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winnt32p.h

Abstract:

    Header file for winnt32 plug-in down-level-side DLLs.

Author:

    Ted Miller (tedm) 6 December 1996

Revision History:

--*/
#ifndef WINNT32P_H
#define WINNT32P_H

#include <prsht.h>


//
// winnt32 dll main exported routine prototype
//
DWORD
WINAPI
winnt32 (
    IN      PCSTR DefaultSourcePath,    OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    );

typedef
DWORD
(WINAPI* PWINNT32) (
    IN      PCTSTR DefaultSourcePath,   OPTIONAL
    IN      HWND Dlg,                   OPTIONAL
    IN      HANDLE WinNT32Stub,         OPTIONAL
    OUT     PCSTR* RestartCmdLine       OPTIONAL
    );

//
// WMX_ACTIVATEPAGE is sent when a page is being activated or deactivated.
//
// (The plug-in's pages do not receive WM_NOTIFY with PSN_SETACTIVE and
// PSN_KILLACTIVE -- they get a WMX_ACTIVATEPAGE instead.)
//
// wParam non-0: activating
// wParam 0    : deactivating
// lParam      : unused.
//
// Return non-0 to accept (de)activation, 0 to not accept it. The semantics
// of not accepting (de)activation are exactly the same as for the
// PSN_SETACTIVE/PSN_KILLACTIVE case.
//
#define WMX_ACTIVATEPAGE        (WM_APP+0)

//
// WMX_BBTEXT can be send by a page when is want's to hide and start the billboard
//
// wParam non-0: start billboard, the wizard page will hide itself
// wParam 0    : Stop billboard, The wizard page will call this if it shows again.
// lParam      : unused.
//
// If the SendMessage returns TRUE, the billboard is started/stopped
//
#define WMX_BBTEXT             (WM_APP+1)

//
// WMX_BBPROGRESSGAUGE send by the page when is wants to show/hide the progress gauge on the billboard
//
// wParam non-0: show the progerss gauge on the billboard
// wParam 0    : hide the progerss gauge on the billboard
// lParam      : unused.
// 
#define WMX_BBPROGRESSGAUGE    (WM_APP+2)

//
// WMX_PBM_* private progress bar messages for the billboard.
#define WMX_PBM_SETRANGE       (WM_APP+3)
#define WMX_PBM_SETPOS         (WM_APP+4)
#define WMX_PBM_DELTAPOS       (WM_APP+5)
#define WMX_PBM_SETSTEP        (WM_APP+6)
#define WMX_PBM_STEPIT         (WM_APP+7)
//
// WMX_BB_SETINFOTEXT sets the text in the info window on the billboard
//
// wParam not used
// lParam pointer to the text which should be displayed on the billboard info window
//
// This message should only be used with SendMessage. The billboard makes a copy of the text
// passed in.
//        
#define WMX_BB_SETINFOTEXT     (WM_APP+8)

//
// WMX_BB_ADVANCE_SETUPPHASE lets the wizard/billboard know that a setup phase is finished
// and the time estimate can advance to the next phase. 
// In the win9x upgrade, there can be 2 phases. 1. create/update the hardware compatibility
// database. 2. Create the upgrade report.
// Phase 1 does not need to run if the db which comes with the products is still correct.
//
#define WMX_BB_ADVANCE_SETUPPHASE (WM_APP+9)


//
#define WMX_SETPROGRESSTEXT (WM_APP+10)

//
// WMX_QUERYCANCEL is sent to allow a page to do a custom processing of QueryCancel
//
// wParam      : unused
// lParam      : pointer to a BOOL variable indicating outcome (when return==TRUE)
//               *lParam == TRUE means user wants to cancel the wizard
//               *lParam == FALSE means user may continue
//
// Return non-0 to specify the QueryCancel was handled by the page and the
// answer to the QueryCancel request is in *lParam (see above)
// Return 0 to specify that the default QueryCancel action must be taken
//
#define WMX_QUERYCANCEL         (WM_APP+11)

// More progress message for the billboard
#define WMX_PBM_SETBARCOLOR     (WM_APP+12)

//
// First custom window message a plug-in can use.
// Do NOT use any below this value.
//
#define WMX_PLUGIN_FIRST        (WM_APP+1000)

//
// IDs the plug-in must use for its title and subtitle text on each
// wizard page.
//
#define ID_TITLE_TEXT           1000
#define ID_SUBTITLE_TEXT        1029

//
// Define types for routines that the plug-in DLL must export.
//



//
// Maximum source count..
//
#define MAX_SOURCE_COUNT 8


/*
    This structure contains the information that is passed to a Winnt32 plug-in in
    its Init function.

    UnattendedFlag - Supplies the address of the global attended flag within
        winnt32 itself. A plugin should react accordingly to setup being in
        unattended mode.

    CancelledFlag - supplies the address of a global variable within
        winnt32 itself. If the plug-in encounters a fatal error while
        processing later it should inform the user, set the BOOL to which
        this parameter points to TRUE, and do the following:

        PropSheet_PressButton(WizardDialogBox,PSBTN_CANCEL);

        where WizardDialogBox is the window handle of the wizard dialog box
        (typically obtained via GetParent(hdlg) where hdlg is the
        window handle of a page in the wizard).

    AbortedFlag - supplies the address of a global variable within winnt32 itself.
        If the plugin would like to exit setup, but not show the unsuccessfull
        completion page, it should set both CancelledFlag and AbortedFlag to TRUE.

    UpgradeFlag - supplies the address of a global variable that will
        indicate whether the user is upgrading or installing a new fresh
        copy of NT. The plug-in must sample this value when it is asked to
        activate its pages and take appropriate action (ie, not activating
        if the user is not upgrading). The value this pointer points to
        is NOT valid until after the plug-in's pages are first
        activated.

    LocalSourceModeFlag - supplies the address of a global variable that will
        indicate whether the user is installing via local source mode or not.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    CdRomInstallFlag - supplies the address of a global variable that will
        indicate whetherthe user is installing via CdRom or not. This
        parameter is not valid until after the plug-in's pages are first
        activated.

    NotEnoughSpaceBlockFlag - supplies the address of a global variable that will
        indicate wether setup should halt setup and exit if it detects that
        there is not enough space to complete setup (not enough space for the ~ls dir.)

    LocalSourceDrive - supplies the address of a global variable that will indicate
        the drive number of the local source directory. (2 = C, 3 = D, etc...) This is
        not valid until after winnt32 builds the copy list. 0 indicates an invalid drive.

    LocalSourceSpaceRequired - supplies the address of a global variable that indicates the amount
        of space on the LocalSourceDrive required by winnt32. This is not valid until after
        winnt32 builds the copy list.

    UnattendedScriptFile - supplies the address of a global variable that will
        contain the unattend script file (such as passed in on the command line.)
        This parameter is not valid until after the plug-in's pages are first
        activated.

    SourcePath - supplies an array of SourcePaths that indicate where the
        NT source files exist. This parameter is not valid until after the
        plug-in's pages are first activated.

    SourceCount - supplies the count of SourcePaths in the above array.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    UpgradeOptions - supplies a multistring of special Upgrade commandline options
        to the dll. These options are of the form /#U:[Option] so, for example,
        if someone started winnt32 with the commandline winnt32 /#U:FOO /#U:BAR,
        this string would eventually contain "FOO\0BAR\0\0" This parameter is not
        valid untila after the upgrade plug-in's pages are first activated.

    ProductType - Specifies the type of product being installed.  The value this pointer
        points to is NOT valid until after the plug-in's pages are first activated.

    BuildNumber - Specifies the build of NT being installed.

    ProductVersion - Specifies the version of NT being installed.  The major version is
        in the high byte, and the minor version is in the low byte.

    Debug - Specifies if WINNT32 is the checked build (TRUE) or the free build (FALSE).

    PreRelease - Specifies if the current build is a pre-release (TRUE) or final release (FALSE).

*/

typedef enum {
    UNKNOWN,
    NT_WORKSTATION,
    NT_SERVER
} PRODUCTTYPE;

// UPD_FLAGS_* can be set in SetupFlags to let the upgrade DLL know somethings about setup
// 
// Setup is run in Typical mode. The upgrade DLL should proceed with defaults 
// and not ask the user any question if possible.
#define UPG_FLAG_TYPICAL    0x1



//
// What are the ProductType values in dosnet.inf?
//
#define PROFESSIONAL_PRODUCTTYPE (0)
#define SERVER_PRODUCTTYPE (1)
#define ADVANCEDSERVER_PRODUCTTYPE (2)
#define DATACENTER_PRODUCTTYPE (3)
#define PERSONAL_PRODUCTTYPE (4)
#define BLADESERVER_PRODUCTTYPE (5)
#define SMALLBUSINESS_PRODUCTTYPE (6)

//
// This value is for coding purposes only
//
#define UNKNOWN_PRODUCTTYPE ((UINT)(-1))


typedef struct tagWINNT32_PLUGIN_INIT_INFORMATION_BLOCK {
    UINT        Size;
    BOOL     *  UnattendedFlag;
    BOOL     *  CancelledFlag;
    BOOL     *  AbortedFlag;
    BOOL     *  UpgradeFlag;
    BOOL     *  LocalSourceModeFlag;
    BOOL     *  CdRomInstallFlag;
    BOOL     *  NotEnoughSpaceBlockFlag;
    DWORD    *  LocalSourceDrive;
    LONGLONG *  LocalSourceSpaceRequired;
    LPCTSTR  *  UnattendedScriptFile;
    LPCTSTR  *  SourceDirectories;
    DWORD    *  SourceDirectoryCount;
    LPCTSTR  *  UpgradeOptions;
    PRODUCTTYPE * ProductType;
    DWORD       BuildNumber;
    WORD        ProductVersion;         // i.e., MAKEWORD(5,0)
    BOOL        Debug;
    BOOL        PreRelease;
    BOOL     *  ForceNTFSConversion;
    UINT     *  Boot16;                 // Win9x upgrade only
    UINT     *  ProductFlavor;          // See *_PRODUCTTYPE above
    DWORD    *  SetupFlags;             // See UPD_FLAGS_  above
    BOOL     *  UnattendSwitchSpecified;
    BOOL     *  DUCompletedSuccessfully;    // flag SET when DU completes successfully
} WINNT32_PLUGIN_INIT_INFORMATION_BLOCK,*PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK;


typedef BOOL (*READ_DISK_SECTORS_PROC) (TCHAR,UINT,UINT,UINT,PBYTE);

typedef struct tagWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK {



    UINT      Size;
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK BaseInfo;
    LPCTSTR   UpgradeSourcePath;
    PLONGLONG WinDirSpace;
    PUINT     RequiredMb;
    PUINT     AvailableMb;
    LPCTSTR * OptionalDirectories;
    DWORD   * OptionalDirectoryCount;
    UINT    * UpgradeFailureReason;
    READ_DISK_SECTORS_PROC ReadDiskSectors;
    PCTSTR    DynamicUpdateLocalDir;
    PCTSTR    DynamicUpdateDrivers;
    BOOL    * UpginfsUpdated;

} WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK, *PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK;


/*++

UPGRADEFAILURES is a list of reasons that an upgrade cannot be performed. This list allows winnt32 to own certain messages
for failures, but for the upgrade dll to do the actual checking for those failures.

If you define a FAILREASON(<x>) you need to add a MSG_<x> to the winnt32 dll message.mc file.

This macro expansion list will create an enumerated type FAILREASON_<x> as well as populate an array of potential
failure messages.


++*/
#define UPGRADEFAILURES                         \
    FAILREASON(UPGRADE_OK)                      \
    FAILREASON(UPGRADE_OTHER_OS_FOUND)          \

#define FAILREASON(x) REASON_##x,

enum {UPGRADEFAILURES /*,*/ REASON_LAST_REASON};

#undef FAILREASON

typedef
DWORD
(CALLBACK WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE)(
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK Info
    );

typedef WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_INIT_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to initialize the plug-in dll.

Arguments:

    Info - A WINNT32_PLUGIN_INIT_INFORMATION_BLOCK. See above for details.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE)(
    PUINT            PageCount1,
    LPPROPSHEETPAGE *Pages1,
    PUINT            PageCount2,
    LPPROPSHEETPAGE *Pages2,
    PUINT            PageCount3,
    LPPROPSHEETPAGE *Pages3
    );

typedef WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_GETPAGES_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to retrieve wizard pages from the
    plug-in dll.

    Note that the plug-in does NOT need to worry about drawing watermarks
    or background bitmaps, or the separator between a header-area watermark
    and the body of its pages. Winnt32 does all this automatically.

    The plugin should, however, have regular static text controls in the
    header area. Static text controls in that area should use the reserved
    IDs (see above) for the title and subtitle, since winnt32 will automatically
    change the font and size of that text when the page is displayed.

Arguments:

    PageCount1 - receives the number of pages in the first set of contiguous
        pages.

    Pages1 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount2 - receives the number of pages in the second set of contiguous
        pages.

    Pages2 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount3 - receives the number of pages in the third set of contiguous
        pages.

    Pages3 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE)(
    LPCTSTR FileName
    );

typedef WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to request the plug-in write to the
    parameters file that will be passed to text mode setup (ie, winnt.sif).

Arguments:

    FileName - supplies the filename of the .ini-style file to be written to.
        This file is the parameters file plus any user-specified unattend file.
        The plug-in should make whatever modifications are meaningful to it.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
VOID
(CALLBACK WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_CLEANUP_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 in the case where installation is
    aborted after the wizard has been started.

    The plug-in should silently perform whatever cleanup is needs to
    to undo any changes it made to the user's system.

Arguments:

    None.

Return Value:

    None.

--*/

typedef
BOOL
(CALLBACK WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE * PWINNT32_PLUGIN_VIRUSSCANNER_CHECK_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 when running on win9x machines.

    The plugin should do a check for any virus scanners on the machine that could cause setup
    to be unable to complete installation (locking the MBR, for instance.) The plugin is also
    responsible for communicating any problems to the user.

Arguments:

    None.

Return Value:

    TRUE if there are no virus scanners to worry about, FALSE otherwise.

--*/



typedef
PTSTR
(CALLBACK WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE * PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE;


//
// Names of routines that must be exported by the plug-in dll.
//
#define WINNT32_PLUGIN_INIT_NAME        "Winnt32PluginInit"
#define WINNT32_PLUGIN_GETPAGES_NAME    "Winnt32PluginGetPages"
#define WINNT32_PLUGIN_WRITEPARAMS_NAME "Winnt32WriteParams"
#define WINNT32_PLUGIN_CLEANUP_NAME     "Winnt32Cleanup"
#define WINNT32_PLUGIN_VIRUSSCANCHECK_NAME "Winnt32VirusScannerCheck"
#define WINNT32_PLUGIN_GETOPTIONALDIRS_NAME "Winnt32GetOptionalDirectories"

//
// Names of routines that must be exported by the Dynamic Update dll.
//
#define API_DU_ISSUPPORTED          "DuIsSupported"
#define API_DU_INITIALIZEA          "DuInitializeA"
#define API_DU_INITIALIZEW          "DuInitializeW"
#define API_DU_QUERYUNSUPDRVSA      "DuQueryUnsupportedDriversA"
#define API_DU_QUERYUNSUPDRVSW      "DuQueryUnsupportedDriversW"
#define API_DU_DODETECTION          "DuDoDetection"
#define API_DU_BEGINDOWNLOAD        "DuBeginDownload"
#define API_DU_ABORTDOWNLOAD        "DuAbortDownload"
#define API_DU_UNINITIALIZE         "DuUninitialize"

#ifdef UNICODE
#define API_DU_INITIALIZE           API_DU_INITIALIZEW
#define API_DU_QUERYUNSUPDRVS       API_DU_QUERYUNSUPDRVSW
#else
#define API_DU_INITIALIZE           API_DU_INITIALIZEA
#define API_DU_QUERYUNSUPDRVS       API_DU_QUERYUNSUPDRVSA
#endif

//
// Messages that must be sent by the Dynamic Update dll.
//
#define WMX_SETUPUPDATE_PROGRESS_NOTIFY WMX_PLUGIN_FIRST+1001
// WPARAM will be the updated Total Size (shouldn't change, but could possibly)
// LPARAM will be the updated downloaded size
// Time remaining after the initial estimate will need to be calculated by setup.

#define WMX_SETUPUPDATE_RESULT          WMX_PLUGIN_FIRST+1000
// WPARAM will be the result code of the operation (one of the DU_STATUS_* below)
// LPARAM is meaningful only if wParam==DU_STATUS_FAILED and gives more info about the error

#define DU_STATUS_SUCCESS           1
#define DU_STATUS_ABORT             2
#define DU_STATUS_FAILED            3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winperfp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winperfp.h

Abstract:

    Private header file used by various internal components related to perflib
    and associated tools.
    NOTE: At least one source file must include this with _INIT_WINPERFP_ defined
          and also include <initguid.h> so that storage for global variables and
          proper routines are included.

    To use debug tracing, just call WinPerfStartTrace(hKey), where hKey can be
    an opened key to HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib.
    If hKey is NULL, the routine will open it automatically.

--*/

#ifndef _WINPERFP_H_
#define _WINPERFP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>
#include <setupbat.h>

// Increasing debug trace levels. Higher level always includes tracing lower levels.
#define WINPERF_DBG_TRACE_NONE      0       // no trace
#define WINPERF_DBG_TRACE_FATAL     1       // Print fatal error traces only
#define WINPERF_DBG_TRACE_ERROR     2       // All errors
#define WINPERF_DBG_TRACE_WARNING   3       // Warnings as well
#define WINPERF_DBG_TRACE_INFO      4       // Informational traces as well
#define WINPERF_DBG_TRACE_ALL       255     // All traces

//  Data structure definitions.

//
// PERFLIB Tracing routines definition. Starts from 10
//

#define PERF_OPEN_KEY               10    // PerfOpenKey
#define PERF_REG_QUERY_VALUE        11    // PerfRegQueryValue
#define PERF_REG_CLOSE_KEY          12    // PerfRegCloseKey
#define PERF_REG_SET_VALUE          13    // PerfRegSetValue
#define PERG_REG_ENUM_KEY           14    // PerfRegEnumKey
#define PERF_REG_QUERY_INFO_KEY     15    // PerfRegQueryInfoKey
#define PERF_REG_ENUM_VALUE         16    // PerfRegEnumValue
#define PERF_ENUM_TEXT_VALUE        17    // PerfEnumTextValue
#define PERF_ALLOC_INIT_EXT         18    // AllocateAndInitializeExtObject
#define PERF_OPEN_EXT_OBJS          19    // OpenExtensibleObjects
#define PERF_SERVICE_IS_TRUSTED     20    // ServiceIsTrustedByDefault
#define PERF_CLOSE_EXTOBJLIB        21    // CloseExtObjectLibrary
#define PERF_OPEN_EXTOBJLIB         22    // OpenExtObjectLibrary
#define PERF_QUERY_EXTDATA          23    // QueryExtensibleData
#define PERF_GET_NAMES              24    // PerfGetNames
#define PERF_GET_PERFLIBVALUE       25    // GetPerflibKeyValue
#define PERF_TIMER_FUNCTION         26    // PerflibTimerFunction
#define PERF_START_TIMER_FUNCTION   27    // StartPerflibFunctionTimer
#define PERF_DESTROY_TIMER_FUNCTION 28    // DestroyPerflibFunctionTimer
#define PERF_GET_DDLINFO            29    // GetPerfDllFileInfo
#define PERF_DISABLE_PERFLIB        30    // DisablePerfLibrary
#define PERF_DISABLE_LIBRARY        31    // DisableLibrary
#define PERF_UPDATE_ERROR_COUNT     32    // PerfUpdateErrorCount

#define PERF_TIMERFUNCTION          33
#define PERF_STARTFUNCTIONTIMER     34
#define PERF_KILLFUNCTIONTIMER      35
#define PERF_DESTROYFUNCTIONTIMER   36

// LOADPERF trace routine definition, starts from 10
//
#define LOADPERF_DLLENTRYPOINT                 10
#define LOADPERF_GETSTRINGRESOURCE             11
#define LOADPERF_GETFORMATRESOURCE             12
#define LOADPERF_DISPLAYCOMMANDHELP            13
#define LOADPERF_TRIMSPACES                    14
#define LOADPERF_ISDELIMITER                   15
#define LOADPERF_GETITEMFROMSTRING             16
#define LOADPERF_REPORTLOADPERFEVENT           17
#define LOADPERF_LOADPERFGRABMUTEX             18
#define LOADPERF_LOADPERFSTARTEVENTLOG         19
#define LOADPERF_LOADPERFDBGTRACE              20
#define LOADPERF_VERIFYREGISTRY                21

#define LOADPERF_SIGNALWMIWITHNEWDATA          25
#define LOADPERF_LODCTRCOMPILEMOFFILE          26
#define LOADPERF_LODCTRCOMPILEMOFBUFFER        27

#define LOADPERF_DUMPNAMETABLE                 30
#define LOADPERF_DUMPPERFSERVICEENTRIES        31
#define LOADPERF_DUMPPERFLIBENTRIES            32
#define LOADPERF_BUILDSERVICELISTS             33
#define LOADPERF_BACKUPPERFREGISTRYTOFILEW     34
#define LOADPERF_RESTOREPERFREGISTRYFROMFILEW  35
#define LOADPERF_REPAIRPERFREGISTRY            36

#define LOADPERF_FORMATPERFNAME                40
#define LOADPERF_GETPERFTYPEINFO               41
#define LOADPERF_GETPERFOBJECTGUID             42
#define LOADPERF_GENERATEMOFHEADER             43
#define LOADPERF_GENERATEMOFOBJECT             44
#define LOADPERF_GENERATEMOFOBJECTTAIL         45
#define LOADPERF_GENERATEMOFCOUNTER            46
#define LOADPERF_GENERATEMOFINSTANCES          47

#define LOADPERF_UNLODCTR_BUILDNAMETABLE       50
#define LOADPERF_GETDRIVERFROMCOMMANDLINE      51
#define LOADPERF_FIXNAMES                      52
#define LOADPERF_UNLOADCOUNTERNAMES            53
#define LOADPERF_UNLOADPERFCOUNTERTEXTSTRINGS  54

#define LOADPERF_MAKETEMPFILENAME              60
#define LOADPERF_WRITEWIDESTRINGTOANSIFILE     61
#define LOADPERF_LODCTR_BUILDNAMETABLE         62
#define LOADPERF_MAKEBACKUPCOPYOFLANGUAGEFILES 63
#define LOADPERF_GETFILEFROMCOMMANDLINE        64
#define LOADPERF_LODCTRSERSERVICEASTRUSTED     65
#define LOADPERF_GETDRIVERNAME                 66
#define LOADPERF_BUILDLANGUAGETABLES           67
#define LOADPERF_LOADINCLUDEFILE               68
#define LOADPERF_PARSETEXTID                   69
#define LOADPERF_FINDLANGUAGE                  70
#define LOADPERF_GETVALUE                      71
#define LOADPERF_GETVALUEFROMINIKEY            72
#define LOADPERF_ADDENTRYTOLANGUAGE            73
#define LOADPERF_CREATEOBJECTLIST              74
#define LOADPERF_LOADLANGUAGELISTS             75
#define LOADPERF_SORTLANGUAGETABLES            76
#define LOADPERF_GETINSTALLEDLANGUAGELIST      77
#define LOADPERF_CHECKNAMETABLE                78
#define LOADPERF_UPDATEEACHLANGUAGE            79
#define LOADPERF_UPDATEREGISTRY                80
#define LOADPERF_GETMOFFILEFROMINI             81
#define LOADPERF_OPENCOUNTERANDBUILDMOFFILE    82
#define LOADPERF_INSTALLPERFDLL                83
#define LOADPERF_LOADPERFCOUNTERTEXTSTRINGS    84
#define LOADPERF_LOADMOFFROMINSTALLEDSERVICE   85
#define LOADPERF_UPDATEPERFNAMEFILES           86
#define LOADPERF_SETSERVICEASTRUSTED           87

#define LOADPERF_GETINCLUDEFILENAME            90
#define LOADPERF_BACKUPINIFILE                 91
#define LOADPERF_CHECKANDCREATEPATH            92
#define LOADPERF_CHECKANDCOPYFILE              93

//
// Convenient macros to determine string sizes
//

// Macro to compute the actual size of a WCHAR or DBCS string

#define WSTRSIZE(str) (ULONG) ( (str) ? ((PCHAR) &str[wcslen(str)] - (PCHAR)str) + sizeof(UNICODE_NULL) : 0 )
#define STRSIZE(str)  (ULONG) ( (str) ? ((PCHAR) &str[strlen(str)] - (PCHAR)str) + 1 : 0 )

#define TRACE_WSTR(str)       str, WSTRSIZE(str)
#define TRACE_STR(str)        str, STRSIZE(str)
#define TRACE_DWORD(dwValue)  & dwValue, sizeof(dwValue)

//
// For debug tracing
//
#define TRACE(L, X) if (g_dwTraceLevel >= L) WinPerfDbgTrace X

VOID
WinPerfDbgTrace(
    IN LPCGUID Guid,
    IN ULONG  LineNumber,
    IN ULONG  ModuleNumber,
    IN ULONG  OptArgs,
    IN ULONG  Status,
    ...
    );

#define ARG_TYPE_ULONG          0
#define ARG_TYPE_WSTR           1
#define ARG_TYPE_STR            2
#define ARG_TYPE_ULONG64        3

// n must be 1 through 8. x is the one of above types
#define ARG_DEF(x, n)  (x << ((n-1) * 4))

ULONG
WinPerfStartTrace(
    IN HKEY hKey
    );

DEFINE_GUID( /* 51af3adb-28b1-4ba5-b59a-3aeec16deb3c */
    PerflibGuid,
    0x51af3adb,
    0x28b1,
    0x4ba5,
    0xb5, 0x9a, 0x3a, 0xee, 0xc1, 0x6d, 0xeb, 0x3c
  );
DEFINE_GUID( /* 275a79bb-9980-42ba-bafe-a92ded1192cf */
        LoadPerfGuid,
        0x275a79bb,
        0x9980,
        0x42ba,
        0xba, 0xfe, 0xa9, 0x2d, 0xed, 0x11, 0x92, 0xcf);

extern const WCHAR cszTraceLevel[];
extern const WCHAR cszTraceLogName[];
extern const WCHAR cszTraceFileValue[];
extern const WCHAR cszDefaultTraceFileName[];

extern TRACEHANDLE g_hTraceHandle;
extern DWORD g_dwTraceLevel;

#ifdef _PERFLIB_H_
#define WinperfQueryValueEx(a,b,c,d,e,f) PrivateRegQueryValueExT(a, (LPVOID)b, c, d, e, f, TRUE)
#else
#define WinperfQueryValueEx RegQueryValueExW
#endif

//
// Below is necessary for global variables and routine to
// be included to each dll or exe
//
#ifdef _INIT_WINPERFP_
const WCHAR cszTraceLevel[]           = L"DebugTraceLevel";
const WCHAR cszTraceFileValue[]       = L"DebugTraceFile";
const WCHAR cszPerfDebugTraceLevel[]  = L"PerfDebugTraceLevel";
const WCHAR cszTraceLogName[]         = L"PerfDbg Logger";
const WCHAR cszDefaultTraceFile[]     = L"PerfDbg.Etl";
const WCHAR cszDefaultTraceFileName[] = L"C:\\perfdbg.etl";
TRACEHANDLE g_hTraceHandle            = 0;
DWORD       g_dwTraceLevel            = WINPERF_DBG_TRACE_NONE;
LONG        g_lDbgStarted             = 0;

ULONG
WinPerfStartTrace(
    IN HKEY hKey                // Key to Perflib or NULL
    )
{
    CHAR Buffer[1024];
    PCHAR ptr;
    DWORD status, dwType, dwSize;
    PEVENT_TRACE_PROPERTIES Properties;
    TRACEHANDLE TraceHandle;
    BOOL  bLocalKey   = FALSE;
    BOOL  bUseDefault = TRUE;
    WCHAR FileName[MAX_PATH + 1];
    LPWSTR szTraceFileName = NULL;
    ULONG lFileNameSize = 0;
    DWORD dwTraceLevel = WINPERF_DBG_TRACE_NONE;
    HKEY  hKeySetup;
    HKEY  hLocalKey    = hKey;
    DWORD dwSetupInProgress = 0;
    HRESULT hError = S_OK;

    if (InterlockedCompareExchange(& g_lDbgStarted, 1, 0) != 0) {
        return g_dwTraceLevel;
    }

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\Setup",
                           0L,
                           KEY_READ,
                           & hKeySetup);
    if (status == ERROR_SUCCESS) {
        dwSize = sizeof(DWORD);
        dwType = 0;
        status = WinperfQueryValueEx(hKeySetup,
                                     L"SystemSetupInProgress",
                                     NULL,
                                     & dwType,
                                     (LPBYTE) & dwSetupInProgress,
                                     & dwSize);
        if (status == ERROR_SUCCESS && dwType == REG_DWORD
                                    && dwSetupInProgress != 0) {
            // System setup in progress, check whether "PerfDebugTraceLevel"
            // is defined in [UserData] section of setup answer file
            // $winnt$.inf;
            //
            WCHAR szAnswerFile[MAX_PATH + 1];

            ZeroMemory(szAnswerFile, sizeof(WCHAR) * (MAX_PATH + 1));
            GetSystemDirectoryW(szAnswerFile, MAX_PATH);
#ifdef _STRSAFE_H_INCLUDED_
            hError = StringCchCatW(szAnswerFile, MAX_PATH, L"\\");
            if (SUCCEEDED(hError)) {
                hError = StringCchCatW(szAnswerFile, MAX_PATH, WINNT_GUI_FILE_W);
            }
#else
            lstrcatW(szAnswerFile, L"\\");
            lstrcatW(szAnswerFile, WINNT_GUI_FILE_W);
#endif
            if (SUCCEEDED(hError)) {
                dwTraceLevel = GetPrivateProfileIntW(
                        WINNT_USERDATA_W, cszPerfDebugTraceLevel, WINPERF_DBG_TRACE_NONE, szAnswerFile);
            }
            else {
                dwTraceLevel = WINPERF_DBG_TRACE_NONE;
            }
        }
        CloseHandle(hKeySetup);
    }

    status = ERROR_SUCCESS;

    if (hLocalKey == NULL) {
        status = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib",
                        0L,
                        KEY_READ,
                        & hLocalKey);
        if (status == ERROR_SUCCESS) {
            bLocalKey = TRUE;
        }
        else {
            hLocalKey = NULL;
        }
    }
    if (dwTraceLevel == WINPERF_DBG_TRACE_NONE) {
        if (hLocalKey != NULL) {
            dwSize = sizeof(DWORD);
            dwType = 0;
            status = WinperfQueryValueEx(hLocalKey,
                        cszTraceLevel,
                        NULL,
                        & dwType,
                        (LPBYTE) & dwTraceLevel,
                        & dwSize);
            if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                dwTraceLevel = WINPERF_DBG_TRACE_NONE;
                if (bLocalKey) {
                    CloseHandle(hLocalKey);
                }
            }
        }
    }

    if (dwTraceLevel == WINPERF_DBG_TRACE_NONE)
        return WINPERF_DBG_TRACE_NONE;

    if (hLocalKey != NULL) {
        dwType = 0;
        dwSize = (MAX_PATH + 1) * sizeof(WCHAR);
        status = WinperfQueryValueEx(hLocalKey,
                                     cszTraceFileValue,
                                     NULL,
                                     & dwType,
                                     (LPBYTE) FileName,
                                     & dwSize);
        if ((status == ERROR_SUCCESS) && (dwType == REG_SZ)) {
            bUseDefault = FALSE;
        }
        if (bLocalKey) {
            CloseHandle(hLocalKey);
        }
    }
    if (! bUseDefault) {
        szTraceFileName = & FileName[0];
        lFileNameSize   = WSTRSIZE(FileName);
    }
    else {
        if (GetSystemWindowsDirectoryW(FileName, MAX_PATH) > 0) {
#ifdef _STRSAFE_H_INCLUDED_
            hError = StringCchCatW(FileName, MAX_PATH + 1, L"\\");
            if (SUCCEEDED(hError)) {
                hError = StringCchCatW(FileName, MAX_PATH + 1, cszDefaultTraceFile);
            }
#else
            lstrcatW(FileName, L"\\");
            lstrcatW(FileName, cszDefaultTraceFile);
#endif
            if (SUCCEEDED(hError)) {
                szTraceFileName = & FileName[0];
                lFileNameSize   = WSTRSIZE(FileName);
            }
            else {
                szTraceFileName = (LPWSTR) &cszDefaultTraceFileName[0];
                lFileNameSize   = sizeof(cszDefaultTraceFileName);
            }
        }
        else {
            szTraceFileName = (LPWSTR) &cszDefaultTraceFileName[0];
            lFileNameSize   = sizeof(cszDefaultTraceFileName);
        }
    }

    if (sizeof(EVENT_TRACE_PROPERTIES) + sizeof(cszTraceLogName) + lFileNameSize > 1024) {
        // static buffer cannot hold information for QueryTrace()/StartTrace() call,
        // bail out and don't turn on debug event tracing.
        //
        g_dwTraceLevel = WINPERF_DBG_TRACE_NONE;
        return WINPERF_DBG_TRACE_NONE;
    }

    g_dwTraceLevel = dwTraceLevel;
    RtlZeroMemory(Buffer, 1024);
    Properties = (PEVENT_TRACE_PROPERTIES) &Buffer[0];
    Properties->Wnode.BufferSize = 1024;
    Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                    sizeof(cszTraceLogName);
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);
    status = QueryTraceW(0, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        g_hTraceHandle = (TRACEHANDLE) Properties->Wnode.HistoricalContext;
        return dwTraceLevel;
    }

    //
    // Reinitialize structure again for StartTrace()
    //
    RtlZeroMemory(Buffer, 1024);
    Properties->Wnode.BufferSize = 1024;
    Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Properties->BufferSize  = 64;
    Properties->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL |
                              EVENT_TRACE_USE_PAGED_MEMORY |
                              EVENT_TRACE_FILE_MODE_APPEND;
    Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                    sizeof(cszTraceLogName);
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LoggerNameOffset);
    RtlCopyMemory(ptr, cszTraceLogName, sizeof(cszTraceLogName));
    ptr = (PCHAR) ((PCHAR) &Buffer[0] + Properties->LogFileNameOffset);
    RtlCopyMemory(ptr, szTraceFileName, lFileNameSize);
    status = StartTraceW(& TraceHandle, cszTraceLogName, Properties);
    if (status == ERROR_SUCCESS) {
        g_hTraceHandle = TraceHandle;
        return dwTraceLevel;
    }

    g_dwTraceLevel = WINPERF_DBG_TRACE_NONE;
    g_hTraceHandle = (TRACEHANDLE) 0;
    return WINPERF_DBG_TRACE_NONE;
}

VOID
WinPerfDbgTrace(
    IN LPCGUID Guid,
    IN ULONG  LineNumber,
    IN ULONG  ModuleNumber,
    IN ULONG  OptArgs,
    IN ULONG  Status,
    ...
    )
{
    ULONG ErrorCode;
    struct _MY_EVENT {
        EVENT_TRACE_HEADER Header;
        MOF_FIELD          MofField[MAX_MOF_FIELDS];
    } MyEvent;
    ULONG   i;
    va_list ArgList;
    PVOID   source;
    SIZE_T  len;
    DWORD   dwLastError;

    dwLastError = GetLastError();
    RtlZeroMemory(& MyEvent, sizeof(EVENT_TRACE_HEADER));

    va_start(ArgList, Status);
    for (i = 3; i < MAX_MOF_FIELDS; i ++) {
        source = va_arg(ArgList, PVOID);
        if (source == NULL)
            break;
        len = va_arg(ArgList, SIZE_T);
        if (len == 0)
            break;
        MyEvent.MofField[i].DataPtr = (ULONGLONG) source;
        MyEvent.MofField[i].Length  = (ULONG) len;
    }
    va_end(ArgList);

    MyEvent.Header.Class.Type   = (UCHAR) ModuleNumber;
    MyEvent.Header.Size         = (USHORT) (sizeof(EVENT_TRACE_HEADER) + (i * sizeof(MOF_FIELD)));
    MyEvent.Header.Flags        = WNODE_FLAG_TRACED_GUID |
                                  WNODE_FLAG_USE_MOF_PTR |
                                  WNODE_FLAG_USE_GUID_PTR;
    MyEvent.Header.GuidPtr      = (ULONGLONG) Guid;
    MyEvent.MofField[0].DataPtr = (ULONGLONG) &LineNumber;
    MyEvent.MofField[0].Length  = sizeof(LineNumber);
    MyEvent.MofField[1].DataPtr = (ULONGLONG) &Status;
    MyEvent.MofField[1].Length  = sizeof(Status);
    MyEvent.MofField[2].DataPtr = (ULONGLONG) &OptArgs;
    MyEvent.MofField[2].Length  = sizeof(OptArgs);

    __try {
        ErrorCode = TraceEvent(g_hTraceHandle, (PEVENT_TRACE_HEADER) & MyEvent);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = GetLastError();
    }
    SetLastError(dwLastError);
}

#endif // _INIT_WINPERFP_

#include <poppack.h>

#endif // _WINPERFP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wmitrace.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wmiTrace.h

Abstract:

    WMI-based TRACEing kd extension header file

Author:

    Glenn R. Peterson (glennp) 2000 Apr 27

Revision History:

--*/

#ifndef _WMITRACE_H
#define _WMITRACE_H

#include "dbgeng.h"
//
//  Data Structures
//
typedef struct sttWmiTracingKdSortEntry
{
    ULONGLONG   Address;
    union {
        LARGE_INTEGER   Key;
        ULONGLONG       Keyll;  // Sort Key 2
    };
    ULONG       SequenceNo;     // Sort Key 1
    ULONG       Ordinal;        // Sort Key 3
    ULONG       Offset;
    ULONG       Length;
    WMI_HEADER_TYPE HeaderType;
    WMI_BUFFER_SOURCE BufferSource;
    USHORT      CpuNo;
}  WMITRACING_KD_SORTENTRY,  *PWMITRACING_KD_SORTENTRY;


//
//  Procedure Parameters
//
typedef ULONGLONG (__cdecl *WMITRACING_KD_FILTER) (
    PVOID               UserContext,
    const PEVENT_TRACE  pstHeader
    );

typedef int       (__cdecl *WMITRACING_KD_COMPARE) (
    const WMITRACING_KD_SORTENTRY  *SortElement1,
    const WMITRACING_KD_SORTENTRY  *SortElement2
    );

typedef void      (__cdecl *WMITRACING_KD_OUTPUT) (
    PVOID                           UserContext,
    PLIST_ENTRY                     GuidListHeadPtr,
    const WMITRACING_KD_SORTENTRY  *SortInfo,
    const PEVENT_TRACE              pstEvent
    );

//
//  Procedures
//


VOID
wmiTraceDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );

VOID
wmiLogDump(
    ULONG                   LoggerId,
    PVOID                   UserContext,
    PLIST_ENTRY             GuidListHeadPtr,
    WMITRACING_KD_FILTER    Filter,
    WMITRACING_KD_COMPARE   Compare,
    WMITRACING_KD_OUTPUT    Output
    );

ULONG
WmiFormatTraceData(
    PDEBUG_CONTROL     Ctrl,
    ULONG     Mask,
    ULONG     DataLen, 
    PVOID     Data
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wmiumkm.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiumkm.h

Abstract:

    Private definitions for WMI communications between user and kernel modes

Author:

    AlanWar

Environment:

    Kernel and User modes

Revision History:


--*/

#ifndef _WMIUMKM_
#define _WMIUMKM_
#if (_MSC_VER > 1020)
#pragma once
#endif
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

//
// This defines the guid under which the default WMI security descriptor
// is maintained.
DEFINE_GUID(DefaultSecurityGuid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#define DefaultSecurityGuidName L"00000000-0000-0000-0000-000000000000"

#ifndef _WMIKM_

//
// This defines the codes used to define what a request must do. These
// definitions must match the same in wmium.h
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = 0,
    WmiGetSingleInstance = 1,
    WmiChangeSingleInstance = 2,
    WmiChangeSingleItem = 3,
    WmiEnableEvents = 4,
    WmiDisableEvents  = 5,
    WmiEnableCollection = 6,
    WmiDisableCollection = 7,
    WmiRegisterInfo = 8,
    WmiExecuteMethodCall = 9,
    WmiSetTraceNotify = 10
} WMIACTIONCODE;

#endif

#if defined(_WINNT_) || defined(WINNT)

typedef enum
{
    WmiStartLoggerCode = 32,
    WmiStopLoggerCode = 33,
    WmiQueryLoggerCode = 34,
    WmiTraceEventCode = 35,
    WmiUpdateLoggerCode = 36,
    WmiFlushLoggerCode = 37,
    WmiMBRequest = 38,
    WmiRequestDied = 39,
    WmiTraceMessageCode = 40,
    WmiSetMarkCode = 41,
    WmiNtdllLoggerCode = 42,
    WmiClockTypeCode = 43

#ifdef NTPERF
    ,
    WmiSwitchBufferCode = 63
#endif
} WMITRACECODE;
#endif

typedef enum
{
    WmiReadNotifications = 64,
    WmiGetNextRegistrant = 65,
#ifndef MEMPHIS    
    WmiOpenGuid = 66,
#endif    
    WmiNotifyUser = 67,
    WmiGetAllRegistrant = 68,
    WmiGenerateEvent = 69,

    WmiTranslateFileHandle = 71,
    WmiGetVersion = 73,
    WmiCheckAccess = 74,
        
    WmiQueryAllMultiple = 75,
    WmiQuerySingleMultiple = 76,
    WmiEnumerateGuidList = 77,
    WmiQueryDataBlockInformation = 78,
    WmiOpenGuidForQuerySet = 79,
    WmiOpenGuidForEvents = 80,
    WmiReceiveNotif = 81,
    WmiEnableDisableTracelogProvider = 82,
    WmiRegisterGuids = 83,
    WmiCreateUMLogger = 84,
    WmiMBReply = 85,
    WmiEnumerateMofResouces = 86,
    WmiUnregisterDP = 87,
    WmiEnumerateGuidListAndProperties = 88,
    WmiNotifyLanguageChange = 89,
    WmiMarkHandleAsClosed = 90
} WMISERVICECODES;

#define WMIUMKM_LL(x) L##x
#define WMIUMKM_L(x)  WMIUMKM_LL(x)
//
// This defines the name of the WMI device that manages service IOCTLS
//
#define WMIServiceDeviceObjectName L"\\Device\\WMIDataDevice"

#define WMIServiceDeviceName_A    "\\\\.\\WMIDataDevice"
#define WMIServiceDeviceName_W  WMIUMKM_L(WMIServiceDeviceName_A)
#define WMIServiceDeviceName         TEXT(WMIServiceDeviceName_A)

#define WMIServiceSymbolicLinkName_A "\\DosDevices\\WMIDataDevice"
#define WMIServiceSymbolicLinkName_W      WMIUMKM_L(WMIServiceSymbolicLinkName_A)
#define WMIServiceSymbolicLinkName             TEXT(WMIServiceSymbolicLinkName_A)

#define WMIAdminDeviceObjectName       L"\\Device\\WMIAdminDevice"
#define WMIAdminDeviceName_A "\\\\.\\WMIAdminDevice"
#define WMIAdminDeviceName_W WMIUMKM_L(WMIAdminDeviceName_A)
#define WMIAdminDeviceName TEXT(WMIAdminDeviceName_A)
#define WMIAdminSymbolicLinkName TEXT("\\DosDevices\\WMIAdminDevice")

#ifdef MEMPHIS
//
// This id the name of the device that handles query/set IOCTLS. On memphis
// it is the same as the service device name.
#define WMIDataDeviceObjectName  L"\\Device\\WMIDevice"

#define WMIDataDeviceName_A     "\\\\.\\WMIServiceDevice")
#define WMIDataDeviceName_W   WMIUMKM_L(WMIDataDeviceName_A)
#define WMIDataDeviceName          TEXT(WMIDataDeviceName_A)

#define WMIDataSymbolicLinkName_A "\\DosDevices\\WMIServiceDevice"
#define WMIDataSymbolicLinkName_W      WMIUMKM_L(WMIDataSymbolicLinkName_A)
#define WMIDataSymbolicLinkName             TEXT(WMIDataSymbolicLinkName_A)

#else

#define WMIDataDeviceObjectName   WMIServiceDeviceObjectName
#define WMIDataDeviceName_A       WMIServiceDeviceName_A
#define WMIDataDeviceName_W       WMIServiceDeviceName_W
#define WMIDataDeviceName         WMIServiceDeviceName
#define WMIDataSymbolicLinkName_A WMIServiceSymbolicLinkName_A
#define WMIDataSymbolicLinkName_W WMIServiceSymbolicLinkName_W
#define WMIDataSymbolicLinkName   WMIServiceSymbolicLinkName

#endif

//
// This defines the data structure that is used to pass a handle from
// um to km. In 32bit code a handle has 32bits and in 64bit code a handle 
// has 64 bits and both call into the kernel which is 64bits. In order to
// insure that the data structures compile to the same size on 32 and 64
// bit systems we define the union with a dummy 64bit value so the field is
// forced to be 64 bits in all code. Note that the object manager always
// ignores the top 32bits of the handle in order to support 32 bit code
// that only maintains 32 bit handles
//
typedef union
{
    HANDLE  Handle;
    ULONG64 Handle64;
    ULONG32 Handle32;
} HANDLE3264, *PHANDLE3264;

typedef HANDLE3264 PVOID3264;

#ifdef _WIN64
#define WmipSetHandle3264(Handle3264, XHandle) \
    (Handle3264).Handle = XHandle
#else
#define WmipSetHandle3264(Handle3264, XHandle) \
{ (Handle3264).Handle64 = 0; (Handle3264).Handle32 = (ULONG32)XHandle; }
#endif
#define WmipSetPVoid3264 WmipSetHandle3264

//
// This IOCTL will return when a KM notification has been generated that
// requires user mode attention.
//   BufferIn - Not used
//   BufferOut - Buffer to return notification information
#define IOCTL_WMI_READ_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReadNotifications, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return with the next set of unprocessed registration info
// BufferIn - Not used
// BufferOut - Buffer to return registration information
#define IOCTL_WMI_GET_NEXT_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetNextRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

#ifndef MEMPHIS        
//
// This IOCTL will return a handle to a guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_OPEN_GUID \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuid, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_WMI_OPEN_GUID_FOR_QUERYSET \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuidForQuerySet, METHOD_BUFFERED, FILE_READ_ACCESS)
              
#define IOCTL_WMI_OPEN_GUID_FOR_EVENTS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuidForEvents, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif
        
// This IOCTL will perform a query for all data items of a data block
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_ALL_DATA \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllData, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will query for a single instance
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetSingleInstance, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will set a single instance
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleInstance, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will set a single item
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_ITEM \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleItem, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable an event
// BufferIn - Incoming WNODE event item to enable
#define IOCTL_WMI_ENABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable an event
// BufferIn - Incoming WNODE event item to disable
#define IOCTL_WMI_DISABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable collection
// BufferIn - Incoming WNODE describing what to enable for collection
#define IOCTL_WMI_ENABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable collection
// BufferIn - Incoming WNODE describing what to disable for collection
#define IOCTL_WMI_DISABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will return the registration information for a specific provider
// BufferIn - Provider handle
// BufferOut - Buffer to return WMI information
#define IOCTL_WMI_GET_REGINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterInfo, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will execute a method on a device
// BufferIn - WNODE_METHOD_ITEM
// BufferOut - WNODE_METHOD_ITEM
#define IOCTL_WMI_EXECUTE_METHOD \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiExecuteMethodCall, METHOD_BUFFERED, FILE_WRITE_ACCESS)

          
// This IOCTL will do a query all data multiple
// BufferIn - WMIQADMULTIPLE
// BufferOut - Linked WNODE_ALL_DATA with results
#define IOCTL_WMI_QAD_MULTIPLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryAllMultiple, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This specifies the maxiumum number of handles that can be passed to
// query all data multiple and query single instance multiple
//
#define QUERYMULIPLEHANDLELIMIT  0x1000

typedef struct 
{
    ULONG HandleCount;
    HANDLE3264 Handles[1];
} WMIQADMULTIPLE, *PWMIQADMULTIPLE;

// This IOCTL will do a query single instance multiple
// BufferIn - WMIQSIMULTIPLE
// BufferOut - Linked WNODE_SINGLE_INSTANCE with results
#define IOCTL_WMI_QSI_MULTIPLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQuerySingleMultiple, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#ifndef MEMPHIS
typedef struct
{
    USHORT Length;
    USHORT MaximumLength;
    union
    {
        PWSTR  Buffer;
        ULONG64 Dummy;
    };  
} UNICODE_STRING3264, *PUNICODE_STRING3264;

typedef struct
{
    HANDLE3264 Handle;
    UNICODE_STRING3264 InstanceName;
} WMIQSIINFO, *PWMIQSIINFO;
typedef struct
{
    ULONG QueryCount;
    WMIQSIINFO QsiInfo[1];
} WMIQSIMULTIPLE, *PWMIQSIMULTIPLE;
#endif        
          
// This IOCTL will mark the object as not longer able to receive events
// BufferIn - WMIMARKASCLOSED
// BufferOut - 
#define IOCTL_WMI_MARK_HANDLE_AS_CLOSED \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiMarkHandleAsClosed, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct
{
    HANDLE3264 Handle;
} WMIMARKASCLOSED, *PWMIMARKASCLOSED;


// This IOCTL will register for receiving an event
// BufferIn - WMIRECEIVENOTIFICATIONS
// BufferOut - WMIRECEIVENOTIFICATIONS
#define IOCTL_WMI_RECEIVE_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReceiveNotif, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// WmiReceiveNotification
//

#define RECEIVE_ACTION_NONE             1   // No special action required
#define RECEIVE_ACTION_CREATE_THREAD    2   // Mark guid objects as requiring
                                            // a new thread to be
                                            // created
typedef struct
{
    //
    // List of guid notification handles
    //
    ULONG HandleCount;
    ULONG Action;
    PVOID3264 /* PUSER_THREAD_START_ROUTINE */ UserModeCallback;
    HANDLE3264 UserModeProcess;
    HANDLE3264 Handles[1];
} WMIRECEIVENOTIFICATION, *PWMIRECEIVENOTIFICATION;       
          
          
// This IOCTL will cause a registration notification to be generated
// BufferIn - Not used
// BufferOut - Not used
#define IOCTL_WMI_NOTIFY_USER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyUser, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will return with the all registration info
// BufferIn - Not used
// BufferOut - Buffer to return all registration information
#define IOCTL_WMI_GET_ALL_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will cause certain data providers to generate events
// BufferIn - WnodeEventItem to use in firing event
// BufferOut - Not Used
#define IOCTL_WMI_GENERATE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGenerateEvent, METHOD_BUFFERED, FILE_WRITE_ACCESS)


// This IOCTL will translate a File Object into a device object
// BufferIn - pointer to incoming WMIFILETODEVICE structure
// BufferOut - outgoing WMIFILETODEVICE structure
#define IOCTL_WMI_TRANSLATE_FILE_HANDLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTranslateFileHandle, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will check if the caller has desired access to the guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_CHECK_ACCESS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCheckAccess, METHOD_BUFFERED, FILE_READ_ACCESS)
        
//
// This IOCTL will determine the version of WMI
// BufferIn - Not used
// BufferOut - WMIVERSIONINFO
#define IOCTL_WMI_GET_VERSION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetVersion, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - Not used
// BufferOut - WMIGUIDLISTINFO
//
#define IOCTL_WMI_ENUMERATE_GUIDS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateGuidList, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - Not used
// BufferOut - WMIGUIDLISTINFO
//
#define IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateGuidListAndProperties, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// WmiEnumerateGuidList - Enumerate guids

//
// WMIGUIDPROPERTIES structure is used to return the properties of 
// all the registered guids in the EnumerateGuids call. The properties
// GuidType - ( 0-TraceControlGuid, 1-TraceGuid, 2-DataGuid, 3-EventGuid )
// LoggerId - If Trace guid and enabled, indicates the LoggerId to which this
//            Guid is currently logging data
// EnableLevel - If Trace guid and enabled, indicates the level of logging
// EnableFlags - If Trace guid and enabled, indicates the flags used in logging.
// IsEnabled   - Indicates whether this Guid is enabled currently. For data
//               guids this means if collection is enabled, 
//               For event guids this means if events are enabled,
//               For trace guids this means trace logging is enabled. 
// 

typedef struct 
{
    GUID Guid;
    ULONG GuidType; // 0-TraceControlGuid, 1-TraceGuid, 2-DataGuid, 3-EventGuid
    ULONG LoggerId;   
    ULONG EnableLevel;
    ULONG EnableFlags;
    BOOLEAN IsEnabled; 
} WMIGUIDPROPERTIES, *PWMIGUIDPROPERTIES;


typedef struct
{
    ULONG TotalGuidCount;
    ULONG ReturnedGuidCount;
    WMIGUIDPROPERTIES GuidList[1];
} WMIGUIDLISTINFO, *PWMIGUIDLISTINFO;
          
//
// This IOCTL will return a list of guids registered with WMI
// BufferIn - WMIGUIDINFO
// BufferOut - WMIGUIDINFO
//
#define IOCTL_WMI_QUERY_GUID_INFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryDataBlockInformation, METHOD_BUFFERED, FILE_READ_ACCESS)
          
//
// This IOCTL will return the list of mof resources registered
//
// BufferIn - not used
// BufferOut - WMIMOFLIST
#define IOCTL_WMI_ENUMERATE_MOF_RESOURCES \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnumerateMofResouces, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    ULONG RegPathOffset;
    ULONG ResourceOffset;
    ULONG Flags;
} WMIMOFENTRY, *PWMIMOFENTRY;
#define WMIMOFENTRY_FLAG_USERMODE   0x00000001

          
typedef struct
{
    ULONG MofListCount;
    WMIMOFENTRY MofEntry[1];
} WMIMOFLIST, *PWMIMOFLIST;


//
// This IOCTL notifies the kernel that a language has been added or
// removed on a MUI system
//
// BufferIn - WMILANGUAGECHANGE
// BufferOut - not used
#define IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyLanguageChange, METHOD_BUFFERED, FILE_READ_ACCESS)

#define MAX_LANGUAGE_SIZE 0x100
typedef struct
{
    WCHAR Language[MAX_LANGUAGE_SIZE];
    ULONG Flags;
} WMILANGUAGECHANGE, *PWMILANGUAGECHANGE;
#define WMILANGUAGECHANGE_FLAG_ADDED   0x00000001
#define WMILANGUAGECHANGE_FLAG_REMOVED 0x00000002


#define MOFEVENT_ACTION_IMAGE_PATH 0
#define MOFEVENT_ACTION_REGISTRY_PATH 1
#define MOFEVENT_ACTION_LANGUAGE_CHANGE 2
#define MOFEVENT_ACTION_BINARY_MOF 3

#if defined(_WINNT_) || defined(WINNT)

#ifndef MEMPHIS       

#define WMIMAXREGGUIDCOUNT          65536

//
// This IOCTL will Register a set of guids with WMI
//
// BufferIn - WMIREGREQUEST followed by WMIREGINFOW 
// BufferOut - TRACEGUIDMAP[GuidCount] followed by WMIUMREGRESULTS.
//
#define IOCTL_WMI_REGISTER_GUIDS CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterGuids, METHOD_BUFFERED, FILE_READ_ACCESS)


typedef struct
{
    union {
        POBJECT_ATTRIBUTES ObjectAttributes;
        ULONG64 Dummy;
    };
    ULONG Cookie;
    ULONG WmiRegInfo32Size;
    ULONG WmiRegGuid32Size;
} WMIREGREQUEST, *PWMIREGREQUEST;

typedef struct
{
    HANDLE3264 RequestHandle;
    ULONG64 LoggerContext;
    BOOLEAN MofIgnored;
} WMIREGRESULTS, *PWMIREGRESULTS;
//
// This IOCTL will unregister a data provider
//
// BufferIn - WMIUNREGGUIDS
// BufferOut - WMIUNREGGUIDS
//
#define IOCTL_WMI_UNREGISTER_GUIDS CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUnregisterDP, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    IN GUID Guid;
    IN HANDLE3264 RequestHandle;    
    OUT ULONG64 LoggerContext;
} WMIUNREGGUIDS, *PWMIUNREGGUIDS;

//
// This IOCTL will Create a user mode logger
//
// BufferIn - PWMICREATEUMLOGGER
// BufferOut - PWMICREATEUMLOGGER

typedef struct
{
    IN  POBJECT_ATTRIBUTES ObjectAttributes;
    IN  GUID ControlGuid;
    OUT HANDLE3264 ReplyHandle;
    OUT ULONG ReplyCount;
} WMICREATEUMLOGGER, *PWMICREATEUMLOGGER;

typedef struct
{
    IN  ULONG ObjectAttributes;
    IN  GUID ControlGuid;
    OUT HANDLE3264 ReplyHandle;
    OUT ULONG ReplyCount;
} WMICREATEUMLOGGER32, *PWMICREATEUMLOGGER32;

#define IOCTL_WMI_CREATE_UM_LOGGER CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCreateUMLogger, METHOD_BUFFERED, FILE_READ_ACCESS)


//
// This IOCTL will reply to a MB request
//
// BufferIn - WMIMBREPLY
// BufferOut - not used

typedef struct
{
    HANDLE3264 Handle;
    ULONG ReplyIndex;
    UCHAR Message[1];
} WMIMBREPLY, *PWMIMBREPLY;

#define IOCTL_WMI_MB_REPLY CTL_CODE(FILE_DEVICE_UNKNOWN, WmiMBReply, METHOD_BUFFERED, FILE_READ_ACCESS)


//
// This IOCTL will start an instance of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is started
#define IOCTL_WMI_START_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStartLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will stop an instance of a logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information when logger is stopped
#define IOCTL_WMI_STOP_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStopLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will update an existing logger attributes
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_UPDATE_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUpdateLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will flush all buffers of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is flushed
#define IOCTL_WMI_FLUSH_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiFlushLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will query a logger for its information
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_QUERY_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will synchronize a trace record to the logger
// BufferIn - Trace record, with handle set
// BufferOut - Not used
#define IOCTL_WMI_TRACE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceEventCode, METHOD_NEITHER, FILE_WRITE_ACCESS)
          
//
// This IOCTL will synchronize a trace Message to the logger
// BufferIn - Trace record, with handle 
// BufferOut - Not used
#define IOCTL_WMI_TRACE_MESSAGE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceMessageCode, METHOD_NEITHER, FILE_WRITE_ACCESS)

//
// This IOCTL will set a mark in kernel logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Not used
#define IOCTL_WMI_SET_MARK \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiSetMarkCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will set/get the logger information in the GuidEntry
// in case we are starting NTDLL heap or crit sec tracing
// BufferIn - WMINTDLLLOGGERINFO structure
// BufferOut - updated WMINTDLLLOGGERINFO in case of Get.

#define IOCTL_WMI_NTDLL_LOGGERINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNtdllLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_WMI_CLOCK_TYPE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiClockTypeCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef NTPERF
//
// This IOCTL will switch a buffer for UserMode Logging
// BufferIn - WMI_SWITCH_PERFMEM_BUFFER_INFORMATION structure
// BufferOut - Not used
#define IOCTL_WMI_SWITCH_BUFFER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiSwitchBufferCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif //NTPERF
#endif
#endif // WINNT

//
// Notifications from kernel mode WMI to user mode WMI
//
#define NOTIFICATIONTYPES ULONG

                                    // A new data provider is being registered
#define RegistrationAdd       0x00000001
                                    // A data provider is being removed
#define RegistrationDelete    0x00000002
                                    // A data provider is being updated
#define RegistrationUpdate    0x00000004
                                    // An event is fired by a data provider
#define EventNotification     0x00000008

#define NOTIFICATIONSLOT_MASK_NOTIFICATIONTYPES (RegistrationAdd | \
                                                 RegistrationDelete | \
                                                 RegistrationUpdate)

#define INTERNALNOTIFICATIONSIZE (sizeof(WNODE_HEADER) + sizeof(KMREGINFO))


//
// This is used in IOCTL_WMI_GET_ALL_REGISTRANT to report the list of
// registered KM data providers to the WMI service
typedef struct
{
    OUT ULONG ProviderId;    // Provider Id (or device object pointer)
    OUT ULONG Flags;        // REGENTRY_FLAG_*
} KMREGINFO, *PKMREGINFO;

#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info

//
// This structure is used in IOCTL_WMI_TRANSLATE_FILE_HANDLE
typedef struct
{
    union
    {
        IN HANDLE3264 FileHandle;  // File handle whose instance name is needed
        OUT ULONG SizeNeeded;      // If incoming buffer too small then this
                                   // returns with number bytes needed.
    };
    IN HANDLE3264 KernelHandle;    // Kernel handle for data block
    OUT ULONG BaseIndex;           // 
    OUT USHORT InstanceNameLength; // Length of instance name in bytes
    OUT WCHAR InstanceNames[1];    // Instance name in unicode
} WMIFHTOINSTANCENAME, *PWMIFHTOINSTANCENAME;

#ifndef MEMPHIS

//
// This is used in IOCTL_WMI_OPEN_GUID

// Guid must be in the form \WmiGuid\00000000-0000-0000-0000-000000000000

#define WmiGuidObjectDirectory L"\\WmiGuid\\"
#define WmiGuidObjectDirectoryLength  (sizeof(WmiGuidObjectDirectory) / sizeof(WCHAR))

#define WmiGuidGuidPosition 9

#define WmiSampleGuidObjectName L"\\WmiGuid\\00000000-0000-0000-0000-000000000000"
#define WmiGuidObjectNameLength ((sizeof(WmiSampleGuidObjectName) / sizeof(WCHAR))-1)  // 45

typedef struct
{
    IN POBJECT_ATTRIBUTES ObjectAttributes;
    IN ACCESS_MASK DesiredAccess;

    OUT HANDLE3264 Handle;
} WMIOPENGUIDBLOCK, *PWMIOPENGUIDBLOCK;

typedef struct
{
    IN UINT32 /* POBJECT_ATTRIBUTES32 */ ObjectAttributes;
    IN ACCESS_MASK DesiredAccess;

    OUT HANDLE3264 Handle;
} WMIOPENGUIDBLOCK32, *PWMIOPENGUIDBLOCK32;

typedef struct
{
    GUID Guid;
    ACCESS_MASK DesiredAccess;
} WMICHECKGUIDACCESS, *PWMICHECKGUIDACCESS;
#endif

//
// This is the header in front of a WNODE request
typedef struct
{
    ULONG ProviderId;       // Provider Id of target device
} WMITARGET, *PWMITARGET;


typedef struct
{
    ULONG Length;               // Length of this header
    ULONG Count;                // Count of device object to target
    UCHAR Template[sizeof(WNODE_ALL_DATA)];    // Template WNODE_ALL_DATA
    WMITARGET Target[1];        // Provider ids for device object targets
} WMITARGETHEADER, *PWMITARGETHEADER;

//
// This is used to retrieve the internal version of WMI in IOCTL_WMI_GET_VERSION

#define WMI_CURRENT_VERSION 1

typedef struct
{
    ULONG32 Version;
} WMIVERSIONINFO, *PWMIVERSIONINFO;


//
// WmiQueryGuidInfo
typedef struct
{
       HANDLE3264 KernelHandle;
    BOOLEAN IsExpensive;
}  WMIQUERYGUIDINFO, *PWMIQUERYGUIDINFO;


#if defined(_WINNT_) || defined(WINNT)

//
// Used to enable and disable a tracelog provider
//
// BufferIn - WmiTraceEnableDisableInfo
// BufferOut - 
#define IOCTL_WMI_ENABLE_DISABLE_TRACELOG \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableDisableTracelogProvider, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct
{
    GUID Guid;
    ULONG64 LoggerContext;
    BOOLEAN Enable;
} WMITRACEENABLEDISABLEINFO, *PWMITRACEENABLEDISABLEINFO;
              
#define EVENT_TRACE_INTERNAL_FLAG_PRIVATE   0x01

#endif // WINNT

typedef struct
{
    ULONGLONG   GuidMapHandle; 
    GUID        Guid;
    ULONGLONG   SystemTime;
} TRACEGUIDMAP, *PTRACEGUIDMAP;

typedef struct
{
    WNODE_HEADER Wnode;
    ULONG64      LoggerContext;
    ULONG64      SecurityToken;
} WMITRACE_NOTIFY_HEADER, *PWMITRACE_NOTIFY_HEADER;

#ifndef MEMPHIS

#define ENABLECRITSECTRACE          0x1
#define DISABLECRITSECTRACE         0xFFFFFFFE
#define ENABLEHEAPTRACE             0x2
#define DISABLEHEAPTRACE            0xFFFFFFFD
#define DISABLENTDLLTRACE           0xFFFFFFFC

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default: 4200 )
#endif

#endif // _WMIUMKM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wmikm.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wmikm.h

Abstract:

    This module defines the WMI types, constants, and functions that are
    exposed to internal device drivers.

Revision History:

--*/

#ifndef _WMIKM_H_
#define _WMIKM_H_

#include <evntrace.h>
#include <wmistr.h>

#define IRP_MN_SET_TRACE_NOTIFY             0x0A

//
// The following is set for a KM provider who is considered private to
// kernel tracing
//
#define WMIREG_FLAG_TRACE_PROVIDER          0x00010000

//
// The following mask is to extract the trace callout class
//
#define WMIREG_FLAG_TRACE_NOTIFY_MASK       0x00F00000

//
// We use 4 bits for the trace callout classes.
//
#define WMIREG_NOTIFY_DISK_IO               1 << 20
#define WMIREG_NOTIFY_TDI_IO                2 << 20

//
// Public routines to break down the Loggerhandle
//
#define KERNEL_LOGGER_ID                      0xFFFF    // USHORT only

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT  LoggerId;           // Actual Id of the logger
    UCHAR   Level;              // Enable level passed by control caller
    UCHAR   InternalFlag;       // Reserved
    ULONG   EnableFlags;        // Enable flags passed by control caller
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;


#define WmiGetLoggerId(LoggerContext) \
    (((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId == \
        (USHORT)KERNEL_LOGGER_ID) ? \
        KERNEL_LOGGER_ID : \
        ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->LoggerId

#define WmiGetLoggerEnableFlags(LoggerContext) \
   ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->EnableFlags
#define WmiGetLoggerEnableLevel(LoggerContext) \
    ((PTRACE_ENABLE_CONTEXT) (&LoggerContext))->Level

#define WmiSetLoggerId(Id, Context) \
     (((PTRACE_ENABLE_CONTEXT)Context)->LoggerId = (USHORT) (Id  ? \
                           (USHORT)Id: (USHORT)KERNEL_LOGGER_ID));

typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // buffer size for logging (in kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // aging decay time, in minutes
    ULONG Wow;                          // TRUE if the logger started under WOW64
    union {
        HANDLE  LogFileHandle;          // handle to logfile
        ULONG64 LogFileHandle64;
    };

// data returned to caller
        ULONG NumberOfBuffers;          // no of buffers in use
        ULONG FreeBuffers;              // no of buffers free
        ULONG EventsLost;               // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    union {
        HANDLE  LoggerThreadId;         // thread id of Logger
        ULONG64 LoggerThreadId64;       // thread is of Logger
    };
    union {
        UNICODE_STRING LogFileName;     // used only in WIN64
        UNICODE_STRING64 LogFileName64; // Logfile name: only in WIN32
    };

// mandatory data provided by caller
    union {
        UNICODE_STRING LoggerName;      // Logger instance name in WIN64
        UNICODE_STRING64 LoggerName64;  // Logger Instance name in WIN32
    };

// private
    union {
        PVOID   Checksum;
        ULONG64 Checksum64;
    };
    union {
        PVOID   LoggerExtension;
        ULONG64 LoggerExtension64;
    };
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;

//
// structure for NTDLL tracing
//

typedef struct
{
        BOOLEAN IsGet;
        PWMI_LOGGER_INFORMATION LoggerInfo;
} WMINTDLLLOGGERINFO, *PWMINTDLLLOGGERINFO;

typedef struct _TIMED_TRACE_HEADER {
    USHORT          Size;
    USHORT          Marker;
    ULONG32         EventId;
    union {
        LARGE_INTEGER   TimeStamp;
        ULONG64         LoggerId;
    };
} TIMED_TRACE_HEADER, *PTIMED_TRACE_HEADER;

typedef enum tagWMI_CLOCK_TYPE {
    WMICT_DEFAULT,
    WMICT_SYSTEMTIME,
    WMICT_PERFCOUNTER,
    WMICT_PROCESS,
    WMICT_THREAD,
    WMICT_CPUCYCLE
} WMI_CLOCK_TYPE;

//
// Trace Control APIs
//
NTKERNELAPI
NTSTATUS
WmiStartTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiQueryTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiStopTrace(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiUpdateTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTKERNELAPI
NTSTATUS
WmiFlushTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );
//
// Trace Provider APIs
//
NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceEvent(
    IN PWNODE_HEADER Wnode,
    IN KPROCESSOR_MODE RequestorMode
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceFastEvent(
    IN PWNODE_HEADER Wnode
    );

NTKERNELAPI
LONG64
FASTCALL
WmiGetClock(
    IN WMI_CLOCK_TYPE ClockType,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
FASTCALL
WmiGetClockType(
    IN TRACEHANDLE LoggerHandle,
    OUT WMI_CLOCK_TYPE *ClockType
    );

// begin_ntddk begin_wdm begin_ntifs

#ifdef RUN_WPP

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN ...
    );

NTKERNELAPI
NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
    );


#endif // #ifdef RUN_WPP

#ifndef TRACE_INFORMATION_CLASS_DEFINE
typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass
} TRACE_INFORMATION_CLASS;

NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );
#define TRACE_INFORMATION_CLASS_DEFINE
#endif // TRACE_INFOPRMATION_CLASS_DEFINE


#endif // _WMIKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\winsvcp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winsvcp.h

Abstract:

    Contains internal interfaces exported by the service controller.

Author:

    Anirudh Sahni (anirudhs)        14-Feb-1996

Environment:

    User Mode -Win32

Revision History:

    14-Feb-1996     anirudhs
        Created.

--*/

#ifndef _WINSVCP_INCLUDED
#define _WINSVCP_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

//
// Name of event to pulse to request a device-arrival broadcast,
// deliberately cryptic
//
#define SC_BSM_EVENT_NAME   L"ScNetDrvMsg"

//
// Name of event the SCM will set once service auto-start is
// complete.  It will never be reset.
//
#define SC_AUTOSTART_EVENT_NAME   L"SC_AutoStartComplete"

//
// Named events the SCM uses for handshaking with setup.exe
// during OOBE setup.
//
#define SC_OOBE_PNP_DONE             L"OOBE_PNP_DONE"
#define SC_OOBE_MACHINE_NAME_DONE    L"OOBE_MACHINE_NAME_DONE"

//
// This is the same as EnumServicesStatus except for the additional
// parameter pszGroupName.  The enumerated services are restricted
// to those belonging to the group named in pszGroupName.
// If pszGroupName is NULL this API is identical to EnumServicesStatus.
//
// If we decide to publish this API we should modify the parameter
// list to be extensible to future types of enumerations without needing
// to add a new API for each type of enumeration.
//
// This API is not supported on machines running Windows NT version 3.51
// or earlier, except if pszGroupName is NULL, in which case the call
// maps to EnumServicesStatus.
//
WINADVAPI
BOOL
WINAPI
EnumServiceGroupW(
    SC_HANDLE               hSCManager,
    DWORD                   dwServiceType,
    DWORD                   dwServiceState,
    LPENUM_SERVICE_STATUSW  lpServices,
    DWORD                   cbBufSize,
    LPDWORD                 pcbBytesNeeded,
    LPDWORD                 lpServicesReturned,
    LPDWORD                 lpResumeHandle,
    LPCWSTR                 pszGroupName
    );

//
// Callback function passed to PnP for them to call when a service
// needs to receive notification of PnP events
//
typedef DWORD (*PSCMCALLBACK_ROUTINE)(
    SERVICE_STATUS_HANDLE    hServiceStatus,
    DWORD                    OpCode,
    DWORD                    dwEventType,
    LPARAM                   EventData,
    LPDWORD                  lpdwHandlerRetVal
    );

//
// Callback function passed to PnP for them to call to validate
// a service calling RegisterDeviceNotification
//
typedef DWORD (*PSCMAUTHENTICATION_CALLBACK)(
    IN  LPWSTR                   lpServiceName,
    OUT SERVICE_STATUS_HANDLE    *lphServiceStatus
    );

//
// Private client-side API for RegisterDeviceNotification to look
// up a service's display name given its SERVICE_STATUS_HANDLE
//
DWORD
I_ScPnPGetServiceName(
    IN  SERVICE_STATUS_HANDLE  hServiceStatus,
    OUT LPWSTR                 lpServiceName,
    IN  DWORD                  cchBufSize
    );

//
// Private API for Terminal Server to tell the SCM to send
// console switch notification to services that are interested
//
DWORD
I_ScSendTSMessage(
    DWORD        OpCode,
    DWORD        dwEvent,
    DWORD        cbData,
    LPBYTE       lpData
    );

#if DBG
void
SccInit(
    DWORD dwReason
    );
#endif // DBG

#ifdef __cplusplus
}   // extern "C"
#endif

#endif  // _WINSVCP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wow64reg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wow64reg.c

Abstract:

    This module define some APIs a client can use to access the registry in the mix mode.

    The possible scenario is

    1. 32 bit Apps need to access 64 bit registry key.
    2. 64 bit Apps need to access 32-bit registry key.
    3. The actual redirected path from a given path.

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/ 

 

#ifndef __WOW64REG_H__
#define __WOW64REG_H__

//#define LOG_REGISTRY  //define this to turn on logging for registry

#define WOW64_REGISTRY_SETUP_KEY_NAME L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\ISN Nodes"
#define WOW64_REGISTRY_SETUP_KEY_NAME_REL_PARENT L"SOFTWARE\\Microsoft\\WOW64"
#define WOW64_REGISTRY_SETUP_KEY_NAME_REL L"SOFTWARE\\Microsoft\\WOW64\\ISN Nodes"
#define MACHINE_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"
#define WOW64_REGISTRY_ISN_NODE_NAME L"ISN Nodes"
#define WOW64_RUNONCE_SUBSTR L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"

#define WOW64_32BIT_MACHINE_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node"

#define WOW64_SYSTEM_DIRECTORY_NAME L"SysWow64"
#define NODE_NAME_32BIT L"Wow6432Node"
#define NODE_NAME_32BIT_LEN ((sizeof (NODE_NAME_32BIT)-sizeof(UNICODE_NULL))/sizeof (WCHAR))

#define WOW6432_VALUE_KEY_NAME L"Wow6432KeyValue"

#define ISN_NODE_MAX_LEN 256
#define ISN_NODE_MAX_NUM 30

#define EVENT_WOW64_RUNNING32BIT_APPLICATION 1108

#define SHRED_MEMORY_NAME L"Wow64svc Shared Memory"                 // different process can open this for possible interaction
#define WOW64_SVC_REFLECTOR_EVENT_NAME L"Wow64svc reflector Event"  // different process can use this to ping wow64svc
#define WOW64_SVC_REFLECTOR_MUTEX_NAME L"Wow64svc reflector Mutex"  // different process can use this to synchronize 


#define TAG_KEY_ATTRIBUTE_32BIT_WRITE 0x00000001 //written by 32bit apps
#define TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE   0x00000002 //written by reflector

#define WOW64_REFLECTOR_DISABLE  0x00000001
#define WOW64_REFLECTOR_ENABLE   0x00000002


typedef struct _IsnNode {
    WCHAR NodeName [ISN_NODE_MAX_LEN];
    WCHAR NodeValue [ISN_NODE_MAX_LEN];
    DWORD Flag;
    HKEY   hKey;
}ISN_NODE_TYPE;

typedef enum _WOW6432VALUEKEY_TYPE { 
        None=0,
        Copy,       // it's a copy
        Reflected,    // if it's not a cpoy then it has been reflected on the otherside
        NonMergeable  // This key should not be merged.
}WOW6432_VALUEKEY_TYPE;

typedef struct _WOW6432VALUEKEY {

    WOW6432_VALUEKEY_TYPE ValueType; //define if it's a copy from the other side
    SIZE_T Reserve;
    ULONGLONG TimeStamp;  // time() stamp to track time when it was copied etc.

}WOW6432_VALUEKEY;

typedef WCHAR NODETYPE[ISN_NODE_MAX_LEN];

#define REG_OPTION_OPEN_32BITKEY  KEY_WOW64_32KEY              
#define REG_OPTION_OPEN_64BITKEY  KEY_WOW64_64KEY           

#define KEY_WOW64_OPEN             KEY_WOW64_64KEY
                                                    // This bit is set to make
                                                    // special meaning to Wow64
#ifndef KEY_WOW64_RES
#define KEY_WOW64_RES              (KEY_WOW64_64KEY | KEY_WOW64_32KEY)
#endif


#define WOW64_MAX_PATH 2048 
#ifdef __cplusplus
extern "C" {
#endif

LONG 
Wow64RegOpenKeyEx(
  IN  HKEY hKey,         // handle to open key
  IN  LPCWSTR lpSubKey,  // address of name of subkey to open
  IN  DWORD ulOptions,   // reserved    current implementation is zero means default.
  IN  REGSAM samDesired, // security access mask
  OUT PHKEY phkResult    // address of handle to open key
);

LONG 
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCWSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPWSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
);

BOOL
HandleToKeyName ( 
    IN HANDLE Key,
    IN PWCHAR KeyName,
    IN OUT DWORD * dwSize
    );

BOOL
CreateNode (
    PWCHAR Path
    );

HKEY
OpenNode (
    IN PWCHAR NodeName
    );

BOOL
CheckAndCreateNode (
    IN PWCHAR Name
    );

LONG 
RegReflectKey (
  HKEY hKey,         // handle to open key
  LPCTSTR lpSubKey,   // subkey name
  DWORD   dwOption   // option flag
);

BOOL 
Map64bitTo32bitKeyName (
    IN  PWCHAR Name64Key,
    OUT PWCHAR Name32Key
    );

BOOL 
Map32bitTo64bitKeyName (
    IN  PWCHAR Name32Key,
    OUT PWCHAR Name64Key
    );

// API called from wow64services

BOOL
InitReflector ();

BOOL 
StartReflector ();

BOOL 
StopReflector ();

BOOL
Wow64RegNotifyLoadHive (
    PWCHAR Name
    );

BOOL
Wow64RegNotifyUnloadHive (
    PWCHAR Name
    );

BOOL
Wow64RegNotifyLoadHiveByHandle (
    HKEY hKey
    );

BOOL
Wow64RegNotifyUnloadHiveByHandle (
    HKEY hKey
    );

BOOL
Wow64RegNotifyLoadHiveUserSid (
    PWCHAR lpwUserSid
    );

BOOL
Wow64RegNotifyUnloadHiveUserSid (
    PWCHAR lpwUserSid
    );

//Called from advapi32 to set a key dirty or need cleanup.
BOOL 
Wow64RegSetKeyDirty (
    HANDLE hKeyBase
    );
//Called from advapi32 to sync a key in case that need synchronization.
BOOL
Wow64RegCloseKey (
    HANDLE hKeyBase
    );
//Called from advapi32 to delete a key on the mirror side.
BOOL
Wow64RegDeleteKey (
    HKEY hBase,
    WCHAR  *SubKey
    );

//Called from advapi to get an handle to remapped key that is on reflection list.
HKEY
Wow64OpenRemappedKeyOnReflection (
    HKEY hKey
    );

void
InitializeWow64OnBoot(
    DWORD dwFlag
    );

BOOL
Wow64InitRegistry(
    DWORD dwFlag
    );

BOOL
Wow64CloseRegistry (
	DWORD dwFlag
	);

BOOL
QueryKeyTag (
    HKEY hBase,
    DWORD *dwAttribute
    );

BOOL
Wow64SyncCLSID();

BOOL
IsExemptRedirectedKey (
    IN  PWCHAR SrcKey,
    OUT PWCHAR DestKey
    );

BOOL
IsOnReflectionByHandle ( 
    HKEY KeyHandle 
    );

#ifdef __cplusplus
}
#endif

#endif //__WOW64REG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wowcmndg.h ===
/******************************Module*Header*******************************\
* Module Name: wowcmndg.h                                                  *
*                                                                          *
* Defines used between WOW and common dialogs.                             *
*                                                                          *
* Created: 6-July-1994                                                     *
*                                                                          *
* Copyright (c) 1994-1998 Microsoft Corporation                            *
\**************************************************************************/

#ifndef _WOWCMNDG_H_
#define _WOWCMNDG_H_

//
// Used by various common dialogs to know that a WOW app
// is calling it.
//

#define PD_WOWAPP       0x80000000
#define CD_WOWAPP       PD_WOWAPP

// Enable WOW to tell ComDlg32 which type of struct we want to thunk
// via Ssync_ANSI_UNICODE_Struct_For_WOW() export
#define WOW_CHOOSECOLOR  1
#define WOW_CHOOSEFONT   2
#define WOW_OPENFILENAME 3
#define WOW_PRINTDLG     4

//
// Used by Wx86 whcdlg32.dll to know that a Wx86 app
// is calling it.  See windows\shell\comdlg\fileopen.h for the
// reason why it is not 0x40000000.
//

#define CD_WX86APP      0x04000000

#endif      // ifndef _WOWCMNDG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wow64t.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wow64t.h

Abstract:

    32-bit structure definitions for 64-bit NT.

Author:

    Barry Bond (barrybo)   20-Jun-1998

Revision History:

--*/

#ifndef _WOW64T_
#define _WOW64T_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Page size on x86 NT
//

#define PAGE_SIZE_X86NT    0x1000
#define PAGE_SHIFT_X86NT   12L

//
// Convert the number of native pages to sub x86-pages
//

#define Wow64GetNumberOfX86Pages(NativePages)    \
        (NativePages * (PAGE_SIZE >> PAGE_SHIFT_X86NT))
        
//
// Macro to round to the nearest page size
//

#define WOW64_ROUND_TO_PAGES(Size)  \
        (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
        
//
// Get number of native pages
//

#define WOW64_BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PAGE_SHIFT) + \
                                     (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//
// The name of the 32-bit system directory, which is a child of %SystemRoot%
//

#define WOW64_SYSTEM_DIRECTORY      "syswow64"
#define WOW64_SYSTEM_DIRECTORY_U   L"syswow64"

// Length in bytes of the new system directory, not counting a
// null terminator
//

#define WOW64_SYSTEM_DIRECTORY_SIZE (sizeof(WOW64_SYSTEM_DIRECTORY)-sizeof(CHAR))
#define WOW64_SYSTEM_DIRECTORY_U_SIZE (sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof(WCHAR))

//
// Wow64 Registry Configuration 
//

#define WOW64_REGISTRY_CONFIG_ROOT              L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64"
#define WOW64_REGISTRY_CONFIG_EXECUTE_OPTIONS   L"ExecuteOptions"


#define WOW64_X86_TAG               " (x86)"
#define WOW64_X86_TAG_U            L" (x86)"

//
// File system redirection values
//

#define WOW64_FILE_SYSTEM_ENABLE_REDIRECT          (UlongToPtr(0x00))   // enable file-system redirection for the currently executing thread
#define WOW64_FILE_SYSTEM_DISABLE_REDIRECT         (UlongToPtr(0x01))   // disable file-system redirection for the currently executing thread
#define WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY  ((PVOID)L"[<__wow64_disable_redirect_all__]>")


#define TYPE32(x)   ULONG
#define TYPE64(x)   ULONGLONG


#if !_WIN64
__inline
void *
ULonglongToPtr(
    const ULONGLONG ull
    )
{
#pragma warning (push)
#pragma warning (disable : 4305)
    return((void *) ull );
#pragma warning (pop)
}
#endif

//
// Wow64Info structure is shared between 32-bit and 64-bit modules inside a Wow64 process.
// NOTE : This structure shouldn't contain any pointer-dependent data, as 
// it is viewed from 32-bit and 64-bit code.
//
typedef struct _WOW64INFO {

    ULONG NativeSystemPageSize;         // Page size of the native system the emulator is running on.
    
    ULONG CpuFlags;

} WOW64INFO, *PWOW64INFO;


typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    TYPE32(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    TYPE32(PVOID) EntryInProgress;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _GDI_TEB_BATCH32 {
    ULONG    Offset;
    TYPE32(ULONG_PTR) HDC;
    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32,*PGDI_TEB_BATCH32;


typedef struct _GDI_TEB_BATCH64 {
    ULONG    Offset;
    TYPE64(ULONG_PTR) HDC;
    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH64,*PGDI_TEB_BATCH64;


typedef struct _Wx86ThreadState32 {
    TYPE32(PULONG)  CallBx86Eip;
    TYPE32(PVOID)   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD32, *PWX86THREAD32;

typedef struct _Wx86ThreadState64 {
    TYPE64(PULONG)  CallBx86Eip;
    TYPE64(PVOID)   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD64, *PWX86THREAD64;

typedef struct _CLIENT_ID32 {
    TYPE32(HANDLE)  UniqueProcess;
    TYPE32(HANDLE)  UniqueThread;
} CLIENT_ID32;

typedef CLIENT_ID32 *PCLIENT_ID32;

#if !defined(CLIENT_ID64_DEFINED)

typedef struct _CLIENT_ID64 {
    TYPE64(HANDLE)  UniqueProcess;
    TYPE64(HANDLE)  UniqueThread;
} CLIENT_ID64;

typedef CLIENT_ID64 *PCLIENT_ID64;

#define CLIENT_ID64_DEFINED

#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

#define PEBTEB_BITS 32
#include "pebteb.h"
#undef PEBTEB_BITS

#define PEBTEB_BITS 64
#include "pebteb.h"
#undef PEBTEB_BITS

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;


typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    TYPE32(HANDLE) Handle;
} CURDIR32, *PCURDIR32;



typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    TYPE32(HANDLE) ConsoleHandle;
    ULONG  ConsoleFlags;
    TYPE32(HANDLE) StandardInput;
    TYPE32(HANDLE) StandardOutput;
    TYPE32(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;        // ProcessParameters
    UNICODE_STRING32 DllPath;         // ProcessParameters
    UNICODE_STRING32 ImagePathName;   // ProcessParameters
    UNICODE_STRING32 CommandLine;     // ProcessParameters
    TYPE32(PVOID) Environment;              // NtAllocateVirtualMemory

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;     // ProcessParameters
    UNICODE_STRING32 DesktopInfo;     // ProcessParameters
    UNICODE_STRING32 ShellInfo;       // ProcessParameters
    UNICODE_STRING32 RuntimeData;     // ProcessParameters
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[ RTL_MAX_DRIVE_LETTERS ];
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

#if !defined(BUILD_WOW6432)

//
// Get the 32-bit TEB without doing a memory reference.
//

#define WOW64_GET_TEB32_SAFE(teb64) \
        ((PTEB32) ((ULONGLONG)teb64 + WOW64_ROUND_TO_PAGES (sizeof (TEB))))
        
#define WOW64_GET_TEB32(teb64) \
        WOW64_GET_TEB32_SAFE(teb64)

//
// Update the first qword in the 64-bit TEB.  The 32-bit rdteb instruction
// reads the TEB32 pointer value directly from this field.
//
#define WOW64_SET_TEB32(teb64, teb32) \
   (teb64)->NtTib.ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)(teb32);


#define WOW64_TEB32_POINTER_ADDRESS(teb64) \
        (PVOID)&((teb64)->NtTib.ExceptionList)


#endif

//
// Thunk macros

#define UStr32ToUStr(dst, src) { (dst)->Length = (src)->Length; \
                                 (dst)->MaximumLength = (src)->MaximumLength; \
                                 (dst)->Buffer = (PWSTR) ((src)->Buffer); }

#define UStrToUStr32(dst, src) { (dst)->Length = (src)->Length; \
                                 (dst)->MaximumLength = (src)->MaximumLength; \
                                 (dst)->Buffer = (ULONG) ((src)->Buffer); }

#define NtCurrentTeb32()  ((PTEB32) WOW64_GET_TEB32_SAFE (NtCurrentTeb ()))
#define NtCurrentPeb32()  ((PPEB32) UlongToPtr ((NtCurrentTeb32()->ProcessEnvironmentBlock)) )


// This is currently defined in windows\core\w32inc\w32wow64.h:
#define NtCurrentTeb64()   ((PTEB64)((PTEB32)NtCurrentTeb())->GdiBatchCount)

// This is currently defined in base\wow64\inc\wow64.h:
#define WOW64_TLS_FILESYSREDIR      8   // Used to enable/disable the filesystem
#define WOW64_TLS_WOW64INFO        10   // Used to access native system information for wow64 processes.
#define WOW64_TLS_INITIAL_TEB32    11   // A pointer to the 32-bit initial TEB
#define WOW64_TLS_MAX_NUMBER       12   // Maximum number of TLS slot entries to allocate.

// These should only be called from Win32 code known to be running on Win64.
#if !_WIN64
#define Wow64EnableFilesystemRedirector()   \
    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = 0;
    
#define Wow64DisableFilesystemRedirector(filename)  \
    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = (ULONGLONG)PtrToUlong(filename);


__inline 
PVOID 
Wow64SetFilesystemRedirectorEx (
    PVOID NewValue
    )
/*++

Routine Description:

    This routine allows a thread running inside Wow64 to disable file-system 
    redirection for all calls happening in the context of this thread.
    
    
    NOTE: This routine should only called from a wow64 process, and is only available 
          when running on .NET server platforms and beyond. If you component will 
          run on downlevel platforms (XP 2600 for example), you shouldn't use WOW64_FILE_SYSTEM_DISABLE_REDIRECT (see below).

Example (Enumerating files under c:\windows\system32):
    
    {
        HANDLE File;
        WIN32_FIND_DATA FindData;
#ifndef _WIN64        
        BOOL bWow64Process = FALSE;
        PVOID Wow64RedirectionOld;
#endif        

        //
        // Disable Wow64 file system redirection
        //
#ifndef _WIN64        
        IsWow64Process (GetCurrentProcess (), &bWow64Process);
        if (bWow64Process == TRUE) {
            Wow64RedirectionOld = Wow64SetFilesystemRedirectorEx (WOW64_FILE_SYSTEM_DISABLE_REDIRECT);
        }
#endif        
        File = FindFirstFileA ("c:\\windows\\system32\\*.*", &FindData);
        
        do {
        .
        .
        } while (FindNextFileA (File, &FindData) != 0);
        
        FindClose (File);
        
        //
        // Enable Wow64 file-system redirection
        //
#ifndef _WIN64        
        if (bWow64Process == TRUE) {
            Wow64SetFilesystemRedirectorEx (Wow64RedirectionOld);
        }
#endif        
    }


Arguments:

    NewValue - New Wow64 file-system redirection value. This can either be:
               a- pointer to a unicode string with a fully-qualified path name (e.g. L"c:\\windows\\notepad.exe").
               b- any of the following predefined values :
                  * WOW64_FILE_SYSTEM_ENABLE_REDIRECT : Enables file-system redirection (default)
                  * WOW64_FILE_SYSTEM_DISABLE_REDIRECT : Disables file-system redirection on all
                    file I/O operations happening within the context of the current thread.
                  * WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY: Use this only if you want to run on 
                    download level platforms (for example XP 2600), as it will have no effect
                    and prevents your program from malfunctioning.
    
Return:

    Old Wow64 file-system redirection value

--*/
{
    NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = (ULONGLONG)PtrToUlong(NewValue);
    return UlongToPtr ((ULONG)NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR]);
}

//
// Wow64Info is accessed only from compiled code for x86 on win64.
// NOTE: Only Wow64 processes are allowed to call these macros.
//

#define Wow64GetSharedInfo()    ((PWOW64INFO)NtCurrentTeb64()->TlsSlots[WOW64_TLS_WOW64INFO])

#define Wow64GetSystemNativePageSize() \
    ((PWOW64INFO)ULonglongToPtr((NtCurrentTeb64()->TlsSlots[WOW64_TLS_WOW64INFO])))->NativeSystemPageSize
    
#else

#define Wow64GetSharedInfo()    ((PWOW64INFO)NtCurrentTeb()->TlsSlots[WOW64_TLS_WOW64INFO])
#define Wow64GetInitialTeb32()  ((PINITIAL_TEB)NtCurrentTeb()->TlsSlots[WOW64_TLS_INITIAL_TEB32])

#endif

typedef ULONGLONG SIZE_T64, *PSIZE_T64;

#if defined(BUILD_WOW6432)

typedef VOID * __ptr64 NATIVE_PVOID;
typedef ULONG64 NATIVE_ULONG_PTR;
typedef SIZE_T64 NATIVE_SIZE_T;
typedef PSIZE_T64 PNATIVE_SIZE_T;
typedef struct _PEB64 NATIVE_PEB;
typedef struct _PROCESS_BASIC_INFORMATION64 NATIVE_PROCESS_BASIC_INFORMATION;
typedef struct _MEMORY_BASIC_INFORMATION64 NATIVE_MEMORY_BASIC_INFORMATION;

#else

typedef ULONG_PTR NATIVE_ULONG_PTR;
typedef SIZE_T NATIVE_SIZE_T;
typedef PSIZE_T PNATIVE_SIZE_T;
typedef PVOID NATIVE_PVOID;
typedef struct _PEB NATIVE_PEB;
typedef struct _PROCESS_BASIC_INFORMATION NATIVE_PROCESS_BASIC_INFORMATION;
typedef struct _MEMORY_BASIC_INFORMATION NATIVE_MEMORY_BASIC_INFORMATION;

#endif

#endif  // _WOW64T_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wow64thk.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wow64thk.h

Abstract:

    Declarations shared between wow64.dll and the Win32 thunks in wow64win.dll

Author:

    29-Oct-1999 BarryBo

Revision History:

--*/

#ifndef _WOW64THK_INCLUDE
#define _WOW64THK_INCLUDE

#include <setjmp.h>

//
// Make wow64.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64DLLAPI_)
#define WOW64DLLAPI DECLSPEC_IMPORT
#else
#define WOW64DLLAPI
#endif

typedef enum _WOW64_API_ERROR_ACTION {
    ApiErrorNTSTATUS,           //Return exception code as return value
    ApiErrorNTSTATUSTebCode,    //Some as above with SetLastError on exception code
    ApiErrorRetval,             //Return a constant parameter
    ApiErrorRetvalTebCode       //Some as above with SetLastError on exception code
} WOW64_API_ERROR_ACTION, *PWOW64_API_ERROR_ACTION;

//
// This structure describes what action should occure when
// thunks hit an unhandled exception.
//
typedef struct _WOW64_SERVICE_ERROR_CASE {
    WOW64_API_ERROR_ACTION ErrorAction;
    LONG ErrorActionParam;
} WOW64_SERVICE_ERROR_CASE, *PWOW64_SERVICE_ERROR_CASE;

// This is an extension of KSERVICE_TABLE_DESCRIPTOR
typedef struct _WOW64SERVICE_TABLE_DESCRIPTOR {
    PULONG_PTR Base;
    PULONG Count;
    ULONG Limit;
#if defined(_IA64_)
    LONG TableBaseGpOffset;
#endif
    PUCHAR Number;
    WOW64_API_ERROR_ACTION DefaultErrorAction;  //Action if ErrorCases is NULL.
    LONG DefaultErrorActionParam;               //Action parameter if ErrorCases is NULL.
    PWOW64_SERVICE_ERROR_CASE ErrorCases;
} WOW64SERVICE_TABLE_DESCRIPTOR, *PWOW64SERVICE_TABLE_DESCRIPTOR;

// Used to log hit counts for APIs.
typedef struct _WOW64SERVICE_PROFILE_TABLE WOW64SERVICE_PROFILE_TABLE;
typedef struct _WOW64SERVICE_PROFILE_TABLE *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64SERVICE_PROFILE_TABLE_ELEMENT {
    PWSTR ApiName;
    SIZE_T HitCount;
    PWOW64SERVICE_PROFILE_TABLE SubTable;
    BOOLEAN ApiEnabled;
} WOW64SERVICE_PROFILE_TABLE_ELEMENT, *PWOW64SERVICE_PROFILE_TABLE_ELEMENT;

typedef struct _WOW64SERVICE_PROFILE_TABLE {
    PWSTR TableName;           //OPTIONAL
    PWSTR FriendlyTableName;   //OPTIONAL
    CONST PWOW64SERVICE_PROFILE_TABLE_ELEMENT ProfileTableElements;
    SIZE_T NumberProfileTableElements;
} WOW64SERVICE_PROFILE_TABLE, *PWOW64SERVICE_PROFILE_TABLE;

typedef struct UserCallbackData {
    jmp_buf JumpBuffer;
    PVOID   PreviousUserCallbackData;
    PVOID   OutputBuffer;
    ULONG   OutputLength;
    NTSTATUS Status;
    PVOID   UserBuffer;
} USERCALLBACKDATA, *PUSERCALLBACKDATA;

ULONG
WOW64DLLAPI
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    );

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    );

WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    );

WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    );

//
// Logging mechanism.  Usage:
//  LOGPRINT((verbosity, format, ...))
//
#define LOGPRINT(args)  Wow64LogPrint args
#define ERRORLOG    LF_ERROR    // Always output to debugger.  Use for *unexpected*
                                // errors only
#define TRACELOG    LF_TRACE    // application trace information
#define INFOLOG     LF_TRACE    // misc. informational log
#define VERBOSELOG  LF_NONE     // practically never output to debugger

#if defined DBG
#define WOW64DOPROFILE
#endif

void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   );

//
// WOW64 Assertion Mechanism.  Usage:
//  - put an ASSERTNAME macro at the top of each .C file
//  - WOW64ASSERT(expression)
//  - WOW64ASSERTMSG(expression, message)
//
//

VOID
WOW64DLLAPI
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG LINE
    );

#if DBG

#undef ASSERTNAME
#define ASSERTNAME static CONST PSZ szModule = __FILE__;

#define WOWASSERT(exp)                                  \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, NULL, szModule, __LINE__);   \
    }

#define WOWASSERTMSG(exp, msg)                          \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, msg, szModule, __LINE__);    \
    }

#else   // !DBG

#define WOWASSERT(exp)
#define WOWASSERTMSG(exp, msg)

#endif  // !DBG

#define WOWASSERT_PTR32(ptr) WOWASSERT((ULONGLONG)ptr < 0xFFFFFFFF)



// Defines the argsize of the emulated machine
#define ARGSIZE 4

// Determines if a pointer points to a item or is a special value.
// If it is a special value it should be copied without dereferencing.
#define WOW64_ISPTR(a) ((void *)a != NULL)

//
//  Helper thunk functions called by all the thunks to thunk common types.
//

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
     OUT NT32SIZE_T *dst,
     IN PSIZE_T src
     );

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
     OUT PSIZE_T dst,
     IN NT32SIZE_T *src
     );

#define Wow64ThunkSIZE_T32TO64(src) \
     (SIZE_T)(src)

#define Wow64ThunkSIZE_T64TO32(src) \
     (NT32SIZE_T)min((src), 0xFFFFFFFF)

#define Wow64ShallowThunkUnicodeString32TO64(dst, src) \
     ((PUNICODE_STRING)(dst))->Length = ((NT32UNICODE_STRING *)(src))->Length; \
     ((PUNICODE_STRING)(dst))->MaximumLength = ((NT32UNICODE_STRING *)(src))->MaximumLength; \
     ((PUNICODE_STRING)(dst))->Buffer = (PWSTR)((NT32UNICODE_STRING *)(src))->Buffer;

#define Wow64ShallowThunkUnicodeString64TO32(dst, src) \
     ((NT32UNICODE_STRING *)(dst))->Length = ((PUNICODE_STRING)(src))->Length; \
     ((NT32UNICODE_STRING *)(dst))->MaximumLength = ((PUNICODE_STRING)(src))->MaximumLength; \
     ((NT32UNICODE_STRING *)(dst))->Buffer = (NT32PWSTR)((PUNICODE_STRING)(src))->Buffer;

#define Wow64ShallowThunkAllocUnicodeString32TO64(src) \
     Wow64ShallowThunkAllocUnicodeString32TO64_FNC((NT32UNICODE_STRING *)(src))

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    );

#define Wow64ShallowThunkAllocSecurityDescriptor32TO64(src) \
    Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC((NT32SECURITY_DESCRIPTOR *)(src))

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    );

#define Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(src) \
    Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC((NT32SECURITY_TOKEN_PROXY_DATA *)(src))

PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    );

#define Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src, dst) \
    Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC((NT32SECURITY_QUALITY_OF_SERVICE *)(src), dst)

NTSTATUS
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src,
    IN OUT PSECURITY_QUALITY_OF_SERVICE *dst
    );

#define Wow64ShallowThunkAllocObjectAttributes32TO64(src, dst) \
    Wow64ShallowThunkAllocObjectAttributes32TO64_FNC((NT32OBJECT_ATTRIBUTES *)(src), dst)

NTSTATUS
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src,
    IN OUT POBJECT_ATTRIBUTES *dst
    );

ULONG
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    );

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    );

VOID WriteReturnLengthSilent(PULONG ReturnLength, ULONG Length);
VOID WriteReturnLengthStatus(PULONG ReturnLength, NTSTATUS *pStatus, ULONG Length);


//
// Log flags
//
#define LF_NONE                0x00000000
#define LF_ERROR               0x00000001
#define LF_TRACE               0x00000002
#define LF_NTBASE_NAME         0x00000004
#define LF_NTBASE_FULL         0x00000008
#define LF_WIN32_NAME          0x00000010
#define LF_WIN32_FULL          0x00000020
#define LF_NTCON_NAME          0x00000040
#define LF_NTCON_FULL          0x00000080
#define LF_ExCEPTION           0x80000000

//
// Supported data types for logging
//
#define TypeHex                0x00UI64
#define TypePULongPtrInOut     0x01UI64
#define TypePULongOut          0x02UI64
#define TypePHandleOut         0x03UI64
#define TypeUnicodeStringIn    0x04UI64
#define TypeObjectAttributesIn 0x05UI64
#define TypeIoStatusBlockOut   0x06UI64
#define TypePwstrIn            0x07UI64
#define TypePRectIn            0x08UI64
#define TypePLargeIntegerIn    0x09UI64


#undef WOW64DLLAPI

#endif	// _WOW64THK_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wowshlp.h ===
/******************************Module*Header*******************************\
* Module Name: wowshlp.h                                                   *
*                                                                          *
* Declarations of Shell services provided to WOW.                          *
*                                                                          *
* Created: 9-June-1993                                                     *
*                                                                          *
* Copyright (c) 1993-1998 Microsoft Corporation                            *
\**************************************************************************/

typedef DWORD (APIENTRY *LPFNWOWSHELLEXECCB) (LPSZ, WORD, LPSZ);
typedef DWORD (APIENTRY *LPFNWOWSHELLEXECCB_NT4) (LPSZ, WORD);


UINT APIENTRY DragQueryFileAorW(
   HDROP hDrop,
   UINT wFile,
   PVOID lpFile,
   UINT cb,
   BOOL fNeedAnsi,
   BOOL fShorten);

HINSTANCE APIENTRY WOWShellExecute(
   HWND hwnd,
   LPCSTR lpOperation,
   LPCSTR lpFile,
   LPSTR lpParameters,
   LPCSTR lpDirectory,
   INT nShowCmd,
   LPVOID lpfnWowShellExecCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wsclus.h ===
/*
 *   wsclus.h
 *
 *   Microsoft Windows
 *   Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *   Windows Sockets include file for the Microsoft Cluster Network
 *   Protocol suite. Include this header file after winsock.h.
 *
 *   To open a Cluster Datagram Protocol socket, call socket() with an
 *   address family of AF_CLUSTER, a socket type of SOCK_DGRAM, and
 *   protocol CLUSPROTO_CDP.
 *
 *   The Cluster Network Protocol suite uses little endian byte
 *   ordering in its address components.
 */

#ifndef _WSCLUS_INCLUDED
#define _WSCLUS_INCLUDED

/*
 *   This is the structure of the SOCKADDR structure for the Microsoft
 *   Cluster Network Protocol.
 */

typedef struct sockaddr_cluster {
    u_short sac_family;
    u_short sac_port;
    u_long  sac_node;
    u_long  sac_zero;
} SOCKADDR_CLUSTER, *PSOCKADDR_CLUSTER, FAR *LPSOCKADDR_CLUSTER;

/*
 *  Node address constants
 */
#define CLUSADDR_ANY   0


/*
 *   Protocol families used in the "protocol" parameter of the socket() API.
 */

#define CLUSPROTO_CDP  2


/*
 *   Protocol-specific IOCTLs
 *
 */

#define WSVENDOR_MSFT    0x00010000

#define WSCLUS_IOCTL(_code)    (_WSAIO(IOC_VENDOR, (_code)) | WSVENDOR_MSFT)

#define SIO_CLUS_IGNORE_NODE_STATE   WSCLUS_IOCTL(1)



#endif // ifndef _WSCLUS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\wx86pri.h ===
#ifndef _WX86PRI_H_
#define _WX86PRI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Flags used to communicate with Ole32 via Wx86Tib->Flags

#define WX86FLAG_CALLTHUNKED    0x80
#define WX86FLAG_QIFROMX86      0x40
#define WX86FLAG_QIFROMXNATIVE  0x20

//
typedef PVOID *(*PFNWX86GETOLEFUNCTIONTABLE)(void);
#define WX86GETOLEFUNCTIONTABLENAME "Wx86GetOleFunctionTable"

//
typedef PVOID *(*PFNWX86INITIALIZEOLE)(void);
#define WX86INITIALIZEOLENAME "Wx86InitializeOle"

//
typedef void (*PFNWX86DEINITIALIZEOLE)(void);
#define WX86DEINITIALIZEOLENAME "Wx86DeinitializeOle"

// apvWholeFunctions is a data export that is a pointer to a table of function
// pointers with entrypoints into whole32. Below are friendly names, corresponding
// indicies within the table, prototypes and useful macros. It is assumed 
// that apvWholeFuncs points to the array of function pointers returned.

#define WholeMapIFacePtrIdx                 1
#define WholeCheckFreeTempProxyIdx          3
#define WholeIID2IIDIDXIdx                  4
#define WholeDllGetClassObjectThunkIdx      5
#define WholeInitializeIdx                  6
#define WholeDeinitializeIdx                7
#define WholeNeedX86PSFactoryIdx            8
#define WholeIsN2XProxyIdx                  9
#define WholeThunkDllGetClassObjectIdx      10	    
#define WholeThunkDllCanUnloadNowIdx        11
#define WholeModuleLogFlagsIdx              12
#define WholeUnmarshalledInSameApt          13  
#define WholeAggregateProxyIdx              14
#define WholeIUnknownAddRefInternalIdx      15
#define Wx86LoadX86DllIdx                   16
#define Wx86FreeX86DllIdx                   17
#define WholeResolveProxyIdx                18
#define WholePatchOuterUnknownIdx           19

#define WHOLEFUNCTIONTABLESIZE              19

//
// types of interface proxy
typedef enum _proxytype
{
    X86toNative = 0,        // proxy for x86 calling native interface
    NativetoX86 = 1,         // proxy for native calling x86 interface
    ProxyAvail = 2         // proxy is not currently in use
} PROXYTYPE;

typedef enum {
    ResolvedToProxy,             // interface mapping resolved with proxy
    ResolvedToActual,            // iface mapping resolved with actual iface
} IFACERESOLVETYPE;


typedef struct _cifaceproxy *PCIP;


typedef HRESULT (*PFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);
typedef HRESULT (*PFNDLLCANUNLOADNOW)(void);

typedef void* (*WHOLEMAPIFACEPTR)(IUnknown*, IUnknown*, PROXYTYPE, int, BOOL, BOOL, HRESULT*, BOOL, PCIP);
typedef void (*WHOLECHECKFREETEMPPROXY)(void*);
typedef int (*WHOLEIID2IIDIDX)(const IID*);
typedef HRESULT (*WHOLELDLLGETCLASSOBJECTTHUNK)(IID *piid, LPVOID *ppv, HRESULT hr, BOOL fNativetoX86);
typedef BOOL (*WHOLEINITIALIZE)(void);
typedef void (*WHOLEDEINITIALIZE)(void);
typedef BOOL (*WHOLENEEDX86PSFACTORY)(IUnknown*, REFIID);
typedef BOOL (*WHOLEISN2XPROXY)(IUnknown *punk);
typedef PFNDLLGETCLASSOBJECT (*WHOLETHUNKDLLGETCLASSOBJECT)(PFNDLLGETCLASSOBJECT pv);
typedef PFNDLLCANUNLOADNOW (*WHOLETHUNKDLLCANUNLOADNOW)(PFNDLLCANUNLOADNOW pv);
typedef PVOID (*WHOLEUNMARSHALLEDINSAMEAPT)(PVOID, REFIID);
typedef void (*WHOLEAGGREGATEPROXY)(IUnknown *, IUnknown *);
typedef DWORD (*WHOLEIUNKNOWNADDREFINTERNAL)(IUnknown *, IUnknown *, BOOL, IFACERESOLVETYPE);
typedef HMODULE (*PFNWX86LOADX86DLL)(LPCWSTR, DWORD);
typedef BOOL (*PFNWX86FREEX86DLL)(HMODULE);
typedef IUnknown* (*WHOLERESOLVEPROXY)(IUnknown*, PROXYTYPE);
typedef void (*WHOLEPATCHOUTERUNKNOWN)(IUnknown*);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\x86mboot.h ===
#define X86PC98BOOTCODE_SIZE 2048


unsigned char x86PC98BootCode[] = {
235,10,144,144,73,80,76,49,0,0,0,30,160,132,5,180,
142,205,27,168,32,116,34,50,219,180,20,205,27,114,26,128,
251,132,117,21,232,150,0,115,3,235,107,144,180,36,187,0,
4,185,48,18,186,64,1,205,27,187,0,1,180,132,205,27,
180,6,51,201,51,210,80,140,200,45,192,3,142,192,88,51,
237,205,27,114,65,180,6,186,1,0,129,197,0,8,205,27,
114,52,186,4,0,247,195,0,170,116,3,186,2,0,180,6,
187,0,28,129,197,0,8,205,27,114,27,80,139,197,177,4,
211,232,140,193,3,193,139,240,88,232,21,0,46,137,54,10,
0,46,255,30,8,0,232,8,0,180,14,205,27,185,1,0,
203,86,160,132,5,50,219,180,20,205,27,114,14,128,251,132,
117,9,46,198,6,212,0,0,232,2,0,94,195,180,176,190,
208,0,186,6,0,30,14,31,205,27,180,176,205,27,31,195,
30,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,0,85,170
};
#define X86PC98BOOTMENU_SIZE 8192


unsigned char x86PC98BootMenu[] = {
233,209,2,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,78,69,67,32,202,223,176,191,197,217,186,221,203,
223,173,176,192,140,197,146,232,131,102,131,66,131,88,131,78,
139,78,147,174,131,129,131,106,131,133,129,91,131,118,131,141,
131,79,131,137,131,128,32,202,222,176,188,222,174,221,32,50,
46,55,48,32,67,111,112,121,114,105,103,104,116,32,40,67,
41,32,78,69,67,32,67,111,114,112,111,114,97,116,105,111,
110,32,49,57,56,53,44,49,57,57,53,143,136,32,32,151,
157,129,70,151,204,136,230,130,204,145,73,145,240,129,105,139,
78,147,174,129,106,145,149,146,117,130,204,145,73,145,240,140,
197,146,232,131,102,131,66,131,88,131,78,83,67,83,73,140,
197,146,232,131,102,131,66,131,88,131,78,140,245,131,102,131,
66,131,88,131,78,129,148,131,129,129,64,131,106,129,64,131,
133,129,64,129,91,129,64,143,73,129,64,151,185,149,87,143,
128,131,116,131,72,129,91,131,125,131,98,131,103,150,162,131,
116,131,72,129,91,131,125,131,98,131,103,144,224,150,190,129,
70,129,170,129,69,129,171,131,76,129,91,129,129,151,204,136,
230,130,204,145,73,145,240,129,64,129,169,131,76,129,91,129,
129,145,149,146,117,130,204,145,73,145,240,129,64,131,138,131,
94,129,91,131,147,131,76,129,91,129,129,139,78,147,174,139,
78,147,174,137,194,148,92,130,200,151,204,136,230,130,170,130,
160,130,232,130,220,130,185,130,241,144,224,150,190,129,70,129,
170,129,69,129,171,131,76,129,91,129,129,145,149,146,117,130,
204,145,73,145,240,129,64,129,168,131,76,129,91,129,129,151,
204,136,230,130,204,145,73,145,240,129,94,139,78,147,174,129,
64,129,64,129,64,129,64,129,64,129,64,129,64,129,64,129,
64,129,64,129,64,129,64,129,64,129,64,129,64,129,64,131,
138,131,94,129,91,131,147,131,76,129,91,129,129,151,204,136,
230,130,204,149,92,142,166,131,71,131,137,129,91,129,70,131,
102,131,66,131,88,131,78,147,199,130,221,142,230,130,232,130,
201,142,184,148,115,130,181,130,220,130,181,130,189,131,71,131,
137,129,91,129,70,131,102,131,67,131,88,131,78,143,145,130,
171,141,158,130,221,130,201,142,184,148,115,130,181,130,220,130,
181,130,189,130,199,130,234,130,169,131,76,129,91,130,240,137,
159,130,181,130,196,130,173,130,190,130,179,130,162,129,150,144,
224,150,190,129,70,129,150,130,205,142,169,147,174,139,78,147,
174,130,201,144,221,146,232,130,179,130,234,130,189,151,204,136,
230,130,197,130,183,32,32,130,134,129,69,130,80,131,76,129,
91,129,129,142,169,147,174,139,78,147,174,130,204,144,221,146,
232,32,32,130,134,129,69,130,80,131,76,129,91,129,129,142,
169,147,174,139,78,147,174,130,204,137,240,143,156,30,0,0,
0,0,0,0,232,212,6,131,249,1,117,6,46,198,6,211,
2,1,246,6,1,5,8,117,3,235,123,144,246,6,2,4,
31,117,3,235,113,144,160,132,5,180,132,205,27,115,3,233,
109,4,185,8,0,129,251,0,1,116,3,185,16,0,6,232,
120,18,140,199,7,190,0,8,209,227,38,139,4,37,128,128,
61,128,128,117,57,38,138,4,138,38,2,4,37,31,31,58,
224,117,43,160,132,5,180,6,38,139,84,4,38,139,76,6,
232,94,18,142,199,51,237,205,27,115,3,233,33,4,209,235,
129,238,0,8,3,243,6,85,12,128,232,132,16,203,131,198,
32,226,183,233,9,4,187,0,1,160,132,5,180,132,205,27,
115,6,232,108,16,233,71,14,156,80,6,184,232,248,142,192,
38,129,62,0,0,152,33,117,38,38,246,6,5,0,64,116,
30,7,88,157,176,128,232,245,2,115,3,233,33,14,233,229,
18,144,144,144,144,144,144,144,144,144,144,144,144,144,144,7,
88,157,246,6,1,5,8,116,3,233,13,3,6,184,0,160,
142,192,38,246,6,242,63,240,7,116,3,235,28,144,83,180,
1,205,24,128,255,0,91,116,16,61,27,0,117,3,233,232,
2,61,9,15,117,3,233,224,2,232,57,0,10,192,117,3,
233,214,2,232,187,15,38,139,84,4,38,139,76,6,232,121,
15,162,132,5,232,131,17,129,238,0,8,3,243,209,227,160,
132,5,232,140,17,51,237,180,6,205,27,114,2,6,85,12,
128,232,189,15,203,6,184,0,160,142,192,38,160,242,63,7,
36,240,60,0,117,27,232,67,0,10,192,117,62,232,135,0,
10,192,117,55,232,214,0,10,192,117,48,232,234,1,235,43,
144,60,160,117,6,232,36,0,235,33,144,60,176,117,6,232,
101,0,235,23,144,60,192,117,6,232,177,0,235,13,144,60,
96,117,6,232,194,1,235,3,144,50,192,195,180,1,176,128,
132,38,93,5,116,38,232,5,2,114,33,38,139,87,250,128,
250,128,116,3,235,22,144,138,214,80,232,169,14,131,238,16,
38,139,4,232,200,14,88,117,3,235,27,144,144,144,144,144,
144,144,144,246,196,1,116,6,208,228,176,129,235,194,160,132,
5,232,202,1,50,192,195,180,2,176,129,144,144,144,144,144,
144,144,180,4,176,130,132,38,93,5,116,38,232,175,1,114,
33,38,139,87,250,128,250,128,116,3,235,22,144,138,214,80,
232,83,14,131,238,16,38,139,4,232,114,14,88,117,3,235,
27,144,144,144,144,144,144,144,144,246,196,4,116,6,208,228,
176,131,235,194,160,132,5,232,116,1,50,192,195,180,1,176,
160,128,62,124,4,0,116,3,233,207,0,246,6,130,4,128,
116,3,233,197,0,131,62,126,4,0,117,3,233,187,0,30,
14,31,46,132,38,65,22,31,116,38,232,65,1,114,33,38,
139,87,250,128,250,128,116,3,235,22,144,138,214,80,232,229,
13,131,238,16,38,139,4,232,4,14,88,117,3,233,137,0,
208,228,254,192,246,196,128,116,198,176,160,180,1,132,38,130,
4,116,44,132,38,125,4,117,38,232,2,1,114,33,38,139,
87,250,128,250,128,116,3,235,22,144,138,214,80,232,166,13,
131,238,16,38,139,4,232,197,13,88,117,3,235,75,144,208,
228,254,192,246,196,128,116,197,176,168,180,1,132,38,127,4,
116,38,232,201,0,114,33,38,139,87,250,128,250,128,116,3,
235,22,144,138,214,80,232,109,13,131,238,16,38,139,4,232,
140,13,88,117,3,235,18,144,208,228,254,192,246,196,128,116,
203,160,132,5,232,151,0,50,192,195,132,38,130,4,116,38,
232,139,0,114,33,38,139,87,250,128,250,128,116,3,235,22,
144,138,214,80,232,47,13,131,238,16,38,139,4,232,78,13,
88,117,3,235,18,144,208,228,254,192,246,196,128,116,203,160,
132,5,232,89,0,50,192,195,176,160,51,219,138,216,128,227,
15,208,227,208,227,129,195,96,4,128,63,0,116,53,180,20,
50,219,205,27,128,251,132,117,42,232,50,0,115,5,232,45,
0,114,32,38,139,87,250,128,250,128,116,2,235,21,138,214,
80,232,210,12,131,238,16,38,139,4,232,241,12,88,117,3,
235,11,144,254,192,60,167,116,2,235,175,50,192,195,80,81,
82,187,0,1,180,132,205,27,36,127,51,201,51,210,51,237,
180,6,205,27,114,11,180,6,185,1,0,129,197,0,8,205,
27,90,89,88,195,80,187,0,1,180,132,205,27,51,201,51,
210,51,237,180,5,205,27,88,195,232,169,0,10,192,117,3,
233,156,0,46,246,6,211,2,1,116,17,128,253,1,117,12,
46,198,6,211,2,0,232,140,0,233,7,253,46,198,6,211,
2,0,232,188,12,252,184,0,10,205,24,180,22,186,32,225,
205,24,180,12,205,24,180,18,205,24,30,14,31,190,100,0,
191,14,0,185,48,0,232,42,11,190,148,0,191,174,0,185,
39,0,232,30,11,190,187,0,191,238,1,185,8,0,232,18,
11,190,195,0,191,254,1,185,18,0,232,6,11,31,232,52,
0,81,82,232,24,3,90,254,202,232,232,12,185,16,0,232,
193,11,89,82,81,232,197,3,89,138,209,138,226,232,177,12,
185,22,0,232,191,11,232,75,13,90,182,1,233,228,8,12,
128,232,109,12,203,51,201,180,1,176,128,132,38,93,5,116,
21,254,193,232,8,255,114,14,81,232,43,1,89,10,210,116,
5,2,234,233,30,1,246,196,8,117,6,208,228,254,192,235,
218,180,1,176,160,128,62,124,4,0,116,3,233,156,0,246,
6,130,4,128,116,3,233,146,0,131,62,126,4,0,117,3,
233,136,0,30,14,31,46,132,38,65,22,31,116,21,254,193,
232,187,254,114,14,81,232,222,0,89,10,210,116,5,2,234,
233,209,0,208,228,254,192,246,196,128,117,2,235,213,180,1,
176,160,132,38,130,4,116,27,132,38,125,4,117,21,254,193,
232,139,254,114,14,81,232,174,0,89,10,210,116,5,2,234,
233,161,0,208,228,254,192,246,196,128,117,2,235,212,180,1,
176,168,132,38,127,4,116,21,254,193,232,97,254,114,14,81,
232,132,0,89,10,210,116,5,2,234,235,120,144,208,228,254,
192,246,196,128,117,2,235,218,235,39,144,132,38,130,4,116,
21,254,193,232,56,254,114,14,81,232,91,0,89,10,210,116,
5,2,234,235,79,144,208,228,254,192,246,196,128,117,2,235,
218,176,160,83,51,219,138,216,128,227,15,208,227,208,227,129,
195,96,4,128,63,0,116,33,180,20,50,219,205,27,128,251,
132,117,22,254,193,232,246,253,114,15,81,232,25,0,89,10,
210,116,6,91,2,234,233,176,13,91,254,192,60,167,116,2,
235,193,50,192,254,201,195,80,38,129,127,254,85,170,117,47,
190,0,8,185,8,0,50,210,129,251,0,1,116,3,185,16,
0,38,139,4,131,198,32,232,148,10,116,6,233,128,13,235,
14,144,254,194,46,246,6,211,2,1,116,3,73,117,226,131,
238,32,88,195,80,30,51,192,142,216,180,1,51,201,132,38,
93,5,116,1,65,246,196,8,117,4,208,228,235,240,31,88,
195,80,30,51,192,142,216,180,1,51,201,128,62,124,4,0,
116,3,235,61,144,246,6,130,4,128,116,3,235,51,144,131,
62,126,4,0,117,3,235,41,144,30,14,31,46,132,38,65,
22,31,116,1,65,246,196,64,117,4,208,228,235,235,184,1,
0,133,6,126,4,116,1,65,169,0,64,117,20,233,148,15,
144,132,38,130,4,116,1,65,246,196,64,117,4,208,228,235,
240,31,88,195,80,83,30,51,192,142,216,176,160,51,201,51,
219,138,216,128,227,15,208,227,208,227,129,195,96,4,128,63,
0,116,12,180,20,50,219,205,27,128,251,132,117,1,65,60,
166,116,4,254,192,235,216,31,91,88,195,80,30,51,201,51,
192,142,216,180,1,176,128,132,38,93,5,116,7,80,180,142,
205,27,88,65,246,196,8,117,6,208,228,254,192,235,232,31,
83,30,51,192,142,216,176,160,51,219,138,216,128,227,15,208,
227,208,227,129,195,96,4,128,63,0,116,36,180,20,50,219,
205,27,128,251,132,116,9,128,251,0,117,20,65,235,17,144,
65,81,180,36,187,0,4,185,48,18,186,64,1,205,27,89,
60,166,116,4,254,192,235,192,128,62,124,4,0,116,3,235,
57,144,246,6,130,4,128,116,3,235,47,144,131,62,126,4,
0,117,3,235,37,144,83,138,30,130,4,34,30,125,4,30,
14,31,136,30,65,22,31,91,180,1,132,38,127,4,116,10,
65,246,196,64,117,4,208,228,235,240,31,91,88,195,38,129,
127,254,85,170,117,114,80,50,210,232,218,8,131,239,6,6,
86,51,246,190,0,160,246,6,1,5,8,116,3,190,0,224,
142,198,50,228,128,250,9,114,21,176,49,128,234,10,171,50,
228,138,194,4,48,254,192,171,128,194,10,235,13,144,50,228,
176,32,171,138,194,4,48,254,192,171,176,58,171,94,7,30,
6,31,232,142,7,31,254,194,129,251,0,1,117,7,128,250,
7,119,9,235,164,128,250,15,119,2,235,157,232,172,10,117,
3,232,215,7,88,50,228,195,51,201,186,2,0,51,237,180,
6,205,27,114,37,38,129,62,0,0,86,79,117,28,38,129,
62,2,0,76,49,117,19,180,1,190,29,1,191,124,3,185,
16,0,30,14,31,232,59,7,31,195,180,2,190,45,1,185,
14,0,191,124,3,30,14,31,232,40,7,31,195,80,83,51,
219,232,208,253,3,217,232,232,253,3,217,232,70,254,233,76,
11,144,81,232,26,1,30,14,31,232,7,7,80,190,5,1,
191,82,3,128,251,8,118,8,191,178,2,176,80,235,3,144,
176,160,246,226,209,224,3,248,88,185,2,0,232,228,6,80,
134,224,128,228,15,30,80,51,192,142,216,88,128,62,124,4,
0,117,64,246,6,130,4,128,117,57,131,62,126,4,0,117,
3,235,48,144,246,196,8,116,8,128,236,8,176,255,235,35,
144,81,181,1,138,204,210,229,132,46,125,4,89,117,20,176,
1,81,50,201,132,6,125,4,116,6,254,193,208,224,235,244,
42,225,89,31,254,196,60,255,116,10,50,192,128,252,10,114,
70,235,6,144,50,192,128,196,10,80,184,49,0,6,51,246,
142,198,190,0,160,38,246,6,1,5,8,116,3,190,0,224,
142,198,171,7,88,128,236,10,128,196,48,134,224,6,51,246,
142,198,190,0,160,38,246,6,1,5,8,116,3,190,0,224,
142,198,171,7,235,31,144,5,3,48,6,51,246,142,198,190,
0,160,38,246,6,1,5,8,116,3,190,0,224,142,198,171,
128,204,128,171,7,254,194,88,31,89,73,131,249,0,116,3,
233,255,254,6,51,246,142,198,38,246,6,1,5,8,117,12,
7,6,232,11,0,30,14,31,232,248,5,31,7,91,88,195,
83,51,219,232,158,252,3,217,232,182,252,3,217,232,20,253,
3,217,58,211,118,15,246,6,1,5,8,117,2,254,195,58,
211,118,2,50,210,180,1,176,128,51,201,132,38,93,5,116,
8,58,209,117,3,233,245,0,65,246,196,8,117,6,254,192,
208,228,235,231,176,160,180,1,128,62,124,4,0,116,3,235,
112,144,246,6,130,4,128,116,3,235,102,144,131,62,126,4,
0,117,3,235,92,144,30,14,31,46,132,38,65,22,31,116,
8,58,209,117,3,233,181,0,65,246,196,64,117,6,254,192,
208,228,235,226,180,1,176,160,132,38,130,4,116,14,132,38,
125,4,117,8,58,209,117,3,233,146,0,65,246,196,64,117,
6,254,192,208,228,235,225,180,1,176,168,132,38,127,4,116,
5,58,209,116,120,65,246,196,64,117,28,254,192,208,228,235,
234,132,38,130,4,116,5,58,209,116,98,65,246,196,64,117,
6,254,192,208,228,235,234,176,160,83,51,219,138,216,128,227,
15,208,227,208,227,129,195,96,4,128,63,0,91,116,18,83,
180,20,50,219,205,27,128,251,132,91,117,5,58,209,116,45,
65,60,166,116,6,254,192,208,228,235,206,190,7,1,191,46,
3,128,251,8,118,8,191,142,2,176,80,235,3,144,176,160,
246,226,209,224,3,248,185,22,0,91,50,192,195,168,32,116,
118,128,62,124,4,0,117,55,246,6,130,4,128,117,48,131,
62,126,4,0,117,3,235,39,144,83,51,219,138,62,125,4,
246,199,1,116,6,254,195,208,239,235,245,128,195,160,58,195,
91,115,3,235,10,144,190,47,22,185,18,0,235,63,144,83,
51,219,138,216,128,227,15,208,227,208,227,129,195,96,4,128,
63,0,91,117,3,233,121,255,83,180,20,50,219,205,27,128,
251,132,91,117,9,190,251,0,185,10,0,235,16,144,190,235,
0,185,16,0,235,7,144,190,223,0,185,12,0,80,191,46,
3,128,251,8,118,8,191,142,2,176,80,235,3,144,176,160,
246,226,209,224,3,248,88,91,195,128,254,0,117,3,233,50,
2,232,16,6,185,16,0,232,242,4,232,66,6,30,14,31,
190,3,0,191,254,1,185,18,0,232,7,4,190,213,0,191,
254,1,185,10,0,232,251,3,232,186,6,232,85,6,232,192,
5,185,22,0,232,188,4,182,0,138,212,82,80,232,226,7,
88,80,232,124,5,88,90,31,233,232,1,128,254,0,116,3,
233,224,1,232,5,7,116,3,235,11,144,232,203,5,58,202,
117,3,233,206,1,82,80,232,229,5,232,195,253,232,33,5,
232,251,247,138,208,88,138,194,90,115,15,232,74,6,232,150,
6,232,255,5,232,58,5,233,169,1,80,83,82,232,174,251,
90,91,138,204,88,128,249,2,116,8,128,249,1,116,18,235,
38,144,232,35,6,232,90,6,232,216,5,232,19,5,233,130,
1,144,246,6,1,5,8,117,233,191,124,3,185,16,0,232,
49,4,178,0,235,48,144,80,83,82,232,202,249,138,202,90,
91,88,128,249,0,116,3,235,16,144,232,235,5,232,34,6,
232,160,5,232,219,4,233,74,1,138,209,254,202,232,36,5,
185,16,0,232,253,3,30,14,31,190,3,0,191,254,1,185,
10,0,232,30,3,190,195,0,191,254,1,185,18,0,232,18,
3,232,180,5,232,125,5,232,215,4,185,22,0,232,229,3,
182,1,31,233,13,1,128,254,1,116,3,235,80,144,38,129,
62,0,0,86,79,117,12,38,129,62,2,0,76,49,117,3,
233,240,0,232,159,5,232,75,5,138,202,128,249,0,116,5,
254,201,235,11,144,177,7,129,251,0,1,116,2,177,15,232,
219,4,117,231,232,173,4,81,185,16,0,232,142,3,89,138,
209,232,160,4,185,16,0,232,121,3,233,182,0,232,169,4,
232,216,5,117,2,254,193,128,250,0,116,5,254,202,235,5,
144,138,209,254,202,232,89,4,185,22,0,232,94,3,138,226,
232,78,4,185,22,0,232,74,3,232,163,4,233,132,0,128,
254,1,116,3,235,81,144,38,129,62,0,0,86,79,117,12,
38,129,62,2,0,76,49,117,3,235,104,144,232,22,5,232,
194,4,138,202,181,7,129,251,0,1,116,2,181,15,58,205,
116,5,254,193,235,3,144,177,0,232,81,4,117,240,232,35,
4,81,185,16,0,232,4,3,89,138,209,232,22,4,185,16,
0,232,239,2,235,45,144,232,31,4,232,78,5,117,2,254,
193,254,194,58,209,117,2,178,0,232,213,3,185,22,0,232,
218,2,138,226,232,202,3,185,22,0,232,198,2,232,31,4,
235,1,144,80,180,0,205,24,139,200,88,129,249,0,58,117,
3,233,226,254,129,249,0,59,117,3,233,172,253,129,249,0,
60,117,3,233,245,253,129,249,0,61,117,3,233,80,255,129,
249,13,28,116,46,129,249,0,98,116,2,235,198,128,254,1,
117,193,38,129,62,0,0,86,79,117,11,38,129,62,2,0,
76,49,117,2,235,173,232,210,4,117,168,232,42,1,232,3,
4,235,160,128,254,0,116,3,235,94,144,232,189,4,116,3,
235,25,144,232,131,3,58,202,117,17,180,22,186,32,225,205,
24,232,122,5,144,117,2,205,31,205,30,138,226,82,80,232,
141,3,232,107,251,232,166,245,138,208,88,138,194,90,115,28,
82,80,232,91,251,232,150,245,138,208,88,138,194,90,115,12,
232,229,3,232,49,4,232,154,3,233,71,255,80,83,82,232,
76,249,90,91,88,233,59,255,38,129,62,0,0,86,79,117,
85,38,129,62,2,0,76,49,117,76,12,128,162,132,5,80,
82,6,184,192,31,246,6,1,5,8,116,3,184,192,63,142,
192,160,132,5,209,227,51,210,51,201,51,237,180,6,205,27,
115,17,7,90,88,232,173,3,232,220,3,232,86,3,209,235,
233,240,254,80,184,0,10,205,24,180,22,186,32,225,205,24,
88,139,215,6,85,203,80,232,204,1,88,80,82,6,131,238,
16,38,139,84,4,139,250,38,139,76,6,232,236,1,139,250,
12,128,162,132,5,232,242,3,129,238,0,8,3,243,209,227,
160,132,5,51,237,232,249,3,180,6,205,27,115,17,7,90,
88,232,81,3,232,128,3,232,250,2,209,235,233,148,254,12,
128,232,29,2,90,80,184,0,10,205,24,180,22,186,32,225,
205,24,88,139,215,6,85,203,80,82,38,128,127,250,0,116,
11,38,198,71,250,0,232,1,4,235,9,144,233,166,6,144,
144,144,144,144,82,51,201,51,210,51,237,180,5,205,27,90,
115,31,82,51,210,180,5,205,27,90,115,21,38,128,119,250,
128,30,14,31,232,117,0,232,50,3,232,151,2,31,235,27,
144,38,128,127,250,128,117,19,30,14,31,232,94,0,232,131,
2,144,144,144,144,144,144,144,144,144,31,232,109,0,90,88,
233,16,254,80,6,51,192,142,192,184,0,160,38,246,6,1,
5,8,116,3,184,0,224,142,192,173,232,114,0,115,13,50,
228,168,224,117,2,176,32,171,78,235,28,144,44,32,60,9,
116,11,60,10,116,7,60,11,116,3,235,5,144,171,235,7,
144,171,128,204,128,171,73,226,208,7,88,195,80,30,14,31,
190,3,0,191,104,14,185,80,0,232,167,255,190,3,0,191,
8,15,185,80,0,232,155,255,31,88,195,82,38,139,87,250,
134,214,232,145,0,131,199,36,185,2,0,190,3,0,128,254,
0,116,3,190,109,2,90,30,14,31,232,118,255,31,195,60,
128,114,11,60,160,114,9,60,224,114,3,235,3,144,249,195,
134,196,128,252,128,116,40,128,252,160,115,6,128,236,112,235,
9,144,128,252,240,115,24,128,236,176,10,192,121,2,254,200,
2,228,60,158,114,5,44,94,235,3,144,254,204,44,31,134,
196,248,195,80,184,229,0,232,20,0,88,195,80,184,225,0,
232,11,0,88,195,80,184,233,0,232,2,0,88,195,6,80,
184,0,160,232,69,2,116,3,184,0,224,142,192,88,129,199,
0,32,243,171,7,195,138,194,180,32,246,228,190,0,8,131,
198,16,3,240,191,124,3,129,251,0,1,116,5,176,80,235,
3,144,176,160,246,226,209,224,3,248,185,16,0,195,37,176,
128,61,144,128,116,3,61,160,128,195,83,82,81,51,219,180,
132,205,27,129,251,0,8,116,9,129,251,0,4,117,3,187,
0,2,89,90,11,219,117,23,128,252,3,117,18,246,6,1,
5,8,117,11,247,193,1,0,116,3,128,198,4,209,233,91,
195,86,80,83,82,12,128,50,219,180,20,205,27,114,29,128,
251,132,117,24,46,198,6,209,2,1,180,176,190,205,2,186,
6,0,30,14,31,205,27,180,176,205,27,31,90,91,88,94,
195,86,80,83,82,12,128,50,219,180,20,205,27,114,29,128,
251,132,117,24,46,198,6,209,2,0,180,176,190,205,2,186,
6,0,30,14,31,205,27,180,176,205,27,31,90,91,88,94,
195,80,138,196,177,160,246,225,232,46,0,131,249,8,119,2,
209,224,131,249,8,119,6,5,46,3,235,4,144,5,142,2,
139,248,88,195,80,176,160,246,226,129,251,0,1,117,2,209,
224,139,248,88,129,199,124,3,195,80,232,167,244,139,249,232,
191,244,3,249,83,232,28,245,91,3,207,88,195,80,176,32,
246,225,190,0,8,3,240,38,139,4,232,1,255,88,195,185,
8,0,129,251,0,1,116,3,185,16,0,191,118,3,81,190,
3,0,185,23,0,30,14,31,87,232,183,253,95,31,129,251,
0,1,116,7,129,199,160,0,235,5,144,129,199,64,1,89,
226,220,195,30,14,31,190,153,1,191,104,14,185,110,0,232,
145,253,31,195,30,14,31,190,59,1,191,104,14,185,68,0,
232,128,253,38,129,127,254,85,170,117,27,232,173,0,117,22,
190,149,2,38,246,71,250,128,116,3,233,1,1,191,20,15,
185,28,0,232,93,253,31,195,30,14,31,190,3,0,191,104,
14,185,56,0,232,76,253,190,3,0,191,20,15,185,24,0,
232,64,253,31,195,30,14,31,190,3,0,191,104,14,185,68,
0,232,47,253,190,3,0,191,20,15,185,62,0,232,35,253,
31,195,30,14,31,190,127,1,191,104,14,185,26,0,232,18,
253,191,160,14,235,40,144,30,14,31,190,7,2,191,104,14,
185,38,0,232,253,252,191,184,14,235,19,144,30,14,31,190,
45,2,191,104,14,185,38,0,232,232,252,191,184,14,190,83,
2,185,26,0,232,220,252,80,180,0,205,24,88,190,3,0,
191,96,14,185,80,0,232,202,252,31,195,6,81,51,201,142,
193,38,246,6,1,5,8,89,7,195,80,83,140,200,5,192,
1,5,0,1,209,235,209,235,209,235,43,195,142,192,91,88,
195,83,80,168,32,116,52,180,20,50,219,205,27,128,251,132,
117,41,82,81,180,132,205,27,139,218,50,228,138,198,89,247,
225,89,81,138,205,50,237,3,193,50,255,247,227,89,50,237,
3,193,131,210,0,139,200,88,36,127,80,88,91,195,190,241,
21,191,20,15,185,62,0,233,249,254,232,159,252,232,196,254,
195,32,32,130,134,129,69,130,80,131,76,129,91,129,129,142,
169,147,174,139,78,147,174,130,204,137,240,143,156,32,32,129,
150,130,205,142,169,147,174,139,78,147,174,130,201,144,221,146,
232,130,179,130,234,130,189,151,204,136,230,130,197,130,183,131,
102,131,66,131,88,131,78,131,65,131,140,131,67,32,32,32,
32,0,30,80,51,192,142,216,88,232,4,246,31,195,199,6,
120,0,0,0,228,49,168,1,195,187,0,4,233,85,242,46,
246,6,211,2,1,116,9,73,117,3,233,114,242,233,97,242,
254,194,73,117,5,50,210,233,101,242,233,84,242,3,217,139,
203,50,210,233,172,244,186,0,0,80,232,185,252,131,238,16,
38,139,4,232,216,252,88,116,3,235,4,144,233,84,237,228,
160,168,32,116,250,176,1,230,164,184,0,10,205,24,180,22,
186,32,65,205,24,180,18,205,24,180,12,205,24,252,184,0,
160,142,192,191,108,5,232,89,0,191,12,6,232,150,0,191,
172,6,232,199,0,191,76,7,232,248,0,191,236,7,232,47,
1,191,140,8,232,89,1,51,192,142,192,38,246,6,1,5,
128,186,223,63,176,118,238,116,6,184,230,3,235,4,144,184,
205,4,186,219,63,238,138,196,238,176,6,230,55,185,8,0,
81,185,255,255,230,95,226,252,89,226,245,176,7,230,55,244,
235,253,184,5,79,232,56,1,184,1,60,232,50,1,184,5,
73,232,44,1,184,5,71,232,38,1,184,5,35,232,32,1,
184,5,57,232,26,1,184,5,47,232,20,1,184,21,47,232,
14,1,184,38,48,232,8,1,184,27,126,232,2,1,184,4,
75,232,252,0,195,184,30,99,232,245,0,184,19,50,232,239,
0,184,4,44,232,233,0,184,40,47,232,227,0,184,32,56,
232,221,0,184,4,55,232,215,0,184,4,94,232,209,0,184,
4,55,232,203,0,184,4,63,232,197,0,195,184,5,102,232,
190,0,184,1,60,232,184,0,184,5,54,232,178,0,184,1,
60,232,172,0,184,5,58,232,166,0,184,5,44,232,160,0,
184,5,36,232,154,0,184,5,73,232,148,0,184,4,114,232,
142,0,195,184,27,50,232,135,0,184,30,72,232,129,0,184,
4,55,232,123,0,184,1,34,232,117,0,184,37,44,232,111,
0,184,32,90,232,105,0,184,4,74,232,99,0,184,34,80,
232,93,0,184,26,118,232,87,0,184,4,114,232,81,0,195,
184,28,66,232,74,0,184,27,92,232,68,0,184,4,55,232,
62,0,184,4,70,232,56,0,184,4,47,232,50,0,184,4,
64,232,44,0,184,4,53,232,38,0,184,4,36,232,32,0,
195,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,
144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,
171,12,128,171,195,145,73,145,240,130,181,130,189,151,204,136,
230,130,240,142,169,147,174,139,78,147,174,130,201,144,221,146,
232,130,181,130,220,130,183,130,169,129,105,130,120,129,94,130,
109,129,106,129,72,80,83,81,82,30,232,239,249,14,31,190,
101,24,191,126,14,185,48,0,232,152,249,180,0,205,24,139,
200,129,249,121,21,116,6,129,249,89,21,117,22,232,204,249,
232,241,251,31,90,89,91,88,177,128,138,234,38,137,79,250,
233,33,249,129,249,110,46,116,6,129,249,78,46,117,14,232,
170,249,232,207,251,31,90,89,91,88,233,78,249,31,90,89,
91,88,235,161,169,64,0,116,2,209,224,209,224,233,81,240,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\x86new.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86new.h

Abstract:

    This module contains the public header file that describes the
    HAL interfaces to the 386/486 BIOS emulation.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _X86NEW_
#define _X86NEW_

//
// PCI Bios function code defintitions.
//
// AH:
//

#define PCI_FUNCTION_ID         0xb1

//
// AL:
//

#define PCI_BIOS_PRESENT        0x01
#define PCI_FIND_DEVICE         0x02
#define PCI_FIND_CLASS_CODE     0x03
#define PCI_GENERATE_CYCLE      0x06
#define PCI_READ_CONFIG_BYTE    0x08
#define PCI_READ_CONFIG_WORD    0x09
#define PCI_READ_CONFIG_DWORD   0x0a
#define PCI_WRITE_CONFIG_BYTE   0x0b
#define PCI_WRITE_CONFIG_WORD   0x0c
#define PCI_WRITE_CONFIG_DWORD  0x0d
#define PCI_GET_IRQ_ROUTING     0x0e
#define PCI_SET_IRQ             0x0f

//
// PCI Bios function return code values.
//

#define PCI_SUCCESS             0x00
#define PCI_NOT_SUPPORTED       0x81
#define PCI_BAD_VENDOR_ID       0x83
#define PCI_DEVICE_NOT_FOUND    0x86
#define PCI_BAD_REGISTER        0x87
#define PCI_SET_FAILED          0x88
#define PCI_BUFFER_TOO_SMALL    0x89

//
// Miscellaneous PCI codes.
//

#define PCI_CONFIG_MECHANISM_2  0x02
#define PCI_ILLEGAL_VENDOR_ID   0xffff

//
// Define PCI get/set function type.
//

typedef
ULONG
(*PGETSETPCIBUSDATA)(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define BIOS emulation interfaces.
//

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    );

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    );

VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    );

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosInitializeAdapter (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

#endif // _X86NEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\xactsrv.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xactsrv.h

Abstract:

    Header file for XACTSRV.  Defines structures common to the server and
    XACTSRV.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#ifndef _XACTSRV_
#define _XACTSRV_

//
// Structures for messages that are passed across the LPC port between
// the server and XACTSRV.
//
// *** The PORT_MESSAGE structure *must* be the first element of these
//     structures!

typedef struct _XACTSRV_REQUEST_MESSAGE {
    PORT_MESSAGE PortMessage;
    PTRANSACTION Transaction;
    WCHAR ClientMachineName[CNLEN + 1];
} XACTSRV_REQUEST_MESSAGE, *PXACTSRV_REQUEST_MESSAGE;

typedef struct _XACTSRV_REPLY_MESSAGE {
    PORT_MESSAGE PortMessage;
    NTSTATUS Status;
} XACTSRV_REPLY_MESSAGE, *PXACTSRV_REPLY_MESSAGE;

#endif // ndef _XACTSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\xactsrv2.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xactsrv.h

Abstract:

    Header file for XACTSRV.  Defines structures common to the server and
    XACTSRV.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#ifndef _XACTSRV_
#define _XACTSRV_

//
// Structures for messages that are passed across the LPC port between
// the server and XACTSRV.
//
// *** The PORT_MESSAGE structure *must* be the first element of these
//     structures!

typedef struct _XACTSRV_REQUEST_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG MessageType;

    union {

        struct {
            struct _TRANSACTION *Transaction;
            WCHAR ClientMachineName[CNLEN + 1];
            UCHAR ServerName[ NETBIOS_NAME_LEN ];
            ULONG TransportNameLength;
            PWSTR TransportName;
            UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
            ULONG Flags;
        } DownLevelApi;

        struct {
            PSZ PrinterName;
        } OpenPrinter;

        struct {
            HANDLE hPrinter;
            PVOID Buffer;
            ULONG BufferLength;
            WCHAR ClientMachineName[CNLEN + 1];
        } AddPrintJob;

        struct {
            HANDLE hPrinter;
            ULONG JobId;
        } SchedulePrintJob;

        struct {
            HANDLE hPrinter;
        } ClosePrinter;

        struct {
            PSZ Receipient;
            PVOID Buffer;
            USHORT BufferLength;
        } MessageBufferSend;

        struct {
            PWSTR UserName;
            BOOL  IsAdmin;
        } LSRequest;

        struct {
            HANDLE hLicense;
        } LSRelease;

        struct {
            BOOLEAN Bind;
            UNICODE_STRING TransportName;
        } Pnp;
    
    } Message;


} XACTSRV_REQUEST_MESSAGE, *PXACTSRV_REQUEST_MESSAGE;

typedef struct _XACTSRV_REPLY_MESSAGE {

    PORT_MESSAGE PortMessage;

    union {

        struct {
            NTSTATUS Status;
        } DownLevelApi;

        struct {
            ULONG Error;
            HANDLE hPrinter;
        } OpenPrinter;

        struct {
            ULONG Error;
            USHORT BufferLength;
            ULONG JobId;
        } AddPrintJob;

        struct {
            ULONG Error;
        } SchedulePrintJob;

        struct {
            ULONG Error;
        } ClosePrinter;

        struct {
            ULONG Error;
        } MessageBufferSend;

        struct {
            NTSTATUS Status;
            HANDLE   hLicense;
        } LSRequest;

    } Message;

} XACTSRV_REPLY_MESSAGE, *PXACTSRV_REPLY_MESSAGE;

//
// Message types that can be sent to XACTSRV.
//

#define XACTSRV_MESSAGE_DOWN_LEVEL_API       0
#define XACTSRV_MESSAGE_OPEN_PRINTER         1
#define XACTSRV_MESSAGE_ADD_JOB_PRINTER      2
#define XACTSRV_MESSAGE_SCHD_JOB_PRINTER     4
#define XACTSRV_MESSAGE_CLOSE_PRINTER        5
#define XACTSRV_MESSAGE_MESSAGE_SEND         6
#define XACTSRV_MESSAGE_WAKEUP               7
#define XACTSRV_MESSAGE_LSREQUEST            8
#define XACTSRV_MESSAGE_LSRELEASE            9
#define XACTSRV_MESSAGE_PNP                 10

//
// Request Flags definitions
//

#define XS_FLAGS_NT_CLIENT                  0x00000001

#endif // ndef _XACTSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\xm86.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    xm86.h

Abstract:

    This module contains the public header file that describes the
    interfaces to the 386/486 real mode emulator.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _XM86_
#define _XM86_

//
// Define internal error codes.
//

typedef enum _XM_STATUS {
    XM_SUCCESS = 1,
    XM_DIVIDE_BY_ZERO,
    XM_DIVIDE_QUOTIENT_OVERFLOW,
    XM_EMULATOR_NOT_INITIALIZED,
    XM_HALT_INSTRUCTION,
    XM_ILLEGAL_CODE_SEGMENT,
    XM_ILLEGAL_INDEX_SPECIFIER,
    XM_ILLEGAL_LEVEL_NUMBER,
    XM_ILLEGAL_PORT_NUMBER,
    XM_ILLEGAL_GENERAL_SPECIFIER,
    XM_ILLEGAL_REGISTER_SPECIFIER,
    XM_ILLEGAL_INSTRUCTION_OPCODE,
    XM_INDEX_OUT_OF_BOUNDS,
    XM_SEGMENT_LIMIT_VIOLATION,
    XM_STACK_OVERFLOW,
    XM_STACK_UNDERFLOW,
    XM_MAXIMUM_INTERNAL_CODE
} XM_STATUS;

//
// Define operand data types.
//

typedef enum _XM_OPERATION_DATATYPE {
    BYTE_DATA = 0,
    WORD_DATA = 1,
    LONG_DATA = 3
} XM_OPERATION_DATATYPE;

//
// Define emulator context structure.
//

typedef struct _XM86_CONTEXT {
    ULONG Eax;
    ULONG Ecx;
    ULONG Edx;
    ULONG Ebx;
    ULONG Ebp;
    ULONG Esi;
    ULONG Edi;
    USHORT SegDs;
    USHORT SegEs;
} XM86_CONTEXT, *PXM86_CONTEXT;

//
// Define address translation callback function type.
//

typedef
PVOID
(*PXM_TRANSLATE_ADDRESS) (
    IN USHORT Segment,
    IN USHORT Offset
    );

//
// Define read and write I/O space callback function types.
//

typedef
ULONG
(*PXM_READ_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

typedef
VOID
(*PXM_WRITE_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

//
// Define emulator public interface function prototypes.
//

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    );

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    );

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    );

#endif // _XM86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\zwapi.h ===
NTSYSAPI
NTSTATUS
NTAPI
ZwDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry (
    IN ULONG Id
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry (
    IN ULONG Id
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE EventHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority (
    IN HANDLE EventHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN ResumeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
    OUT PLUID Luid
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetUuidSeed (
    IN PCHAR Seed
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwStartProfile (
    IN HANDLE ProfileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwStopProfile (
    IN HANDLE ProfileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
    IN SHUTDOWN_ACTION Action
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
    IN PUNICODE_STRING String
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAddAtom(
    IN PWSTR AtomName OPTIONAL,
    IN ULONG Length OPTIONAL,
    OUT PRTL_ATOM Atom OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFindAtom(
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteAtom(
    IN RTL_ATOM Atom
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN PLARGE_INTEGER DefaultTimeout OPTIONAL
     );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID SidList OPTIONAL,
    IN ULONG SidListLength,
    IN PSID StartSid OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile64(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID64 *Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile64(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID64 *Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Count OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER Timeout
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwW32Call (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN PSID RequiredServerSid,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN HANDLE PortHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection(
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
    IN HANDLE ProcessHandle,
    OUT PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
    IN PVOID VirtualAddress,
    IN OUT ULONG_PTR NumberOfPages,
    IN OUT PULONG_PTR UserPfnArray OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
    IN PVOID *VirtualAddresses,
    IN OUT ULONG_PTR NumberOfPages,
    IN OUT PULONG_PTR UserPfnArray OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    IN OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    IN SIZE_T Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer (
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetPlugPlayEvent(
    IN  HANDLE EventHandle,
    IN  PVOID Context OPTIONAL,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    IN LATENCY_TIME latency
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags                  // POWER_ACTION_xxx flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
    IN HANDLE Device,
    OUT DEVICE_POWER_STATE *State
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
    IN HANDLE Device
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
    IN HANDLE Device
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextProcess (
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextThread (
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewThreadHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateThread(
    IN HANDLE ThreadHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendProcess (
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeProcess (
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetContextThread(
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetContextThread(
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertThread(
    IN HANDLE ThreadHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTestAlert(
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
    IN HANDLE PortHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1High
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueueApcThread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
    IN USHORT BootCondition
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,  		
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
    IN POBJECT_ATTRIBUTES   TargetKey,
    IN POBJECT_ATTRIBUTES   SourceFile,
    IN ULONG                Flags,
    IN HANDLE               TrustClassKey OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRenameKey(
    IN HANDLE           KeyHandle,
    IN PUNICODE_STRING  NewName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompressKey(
    IN HANDLE Key
            );
NTSYSAPI
NTSTATUS
NTAPI
ZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
    IN POBJECT_ATTRIBUTES   TargetKey,
    IN ULONG                Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN HANDLE Event OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES   TargetKey,
    OUT PULONG              HandleCount
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
    IN POBJECT_ATTRIBUTES   TargetKey,
    IN ULONG                BufferLength,
    OUT PVOID               Buffer,
    OUT PULONG              RequiredSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
    IN HANDLE           KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    ULONG   *pPrivateVer,
    ULONG   *pIsSafeMode
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN PTOKEN_OWNER Owner OPTIONAL,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN PTOKEN_DEFAULT_DACL DefaultDacl OPTIONAL,
    IN PTOKEN_SOURCE TokenSource
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObjectToken(
    IN HANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
    IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
    IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
    OUT PHANDLE NewTokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_GROUPS PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId OPTIONAL,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTraceEvent(
    IN HANDLE TraceHandle,
    IN ULONG  Flags,
    IN ULONG  FieldSize,
    IN PVOID  Fields
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

#if _MSC_VER > 1000
#pragma once
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\zlib_d3dx.h ===
#define z_errmsg d3dx_z_errmsg
#define zlibVersion d3dx_zlibVersion
#define zError d3dx_zError
#define zcalloc d3dx_zcalloc
#define zcfree d3dx_zcfree
#define uncompress d3dx_uncompress
#define _length_code d3dx__length_code
#define _dist_code d3dx__dist_code
#define _tr_tally d3dx__tr_tally
#define _tr_init d3dx__tr_init
#define _tr_stored_block d3dx__tr_stored_block
#define _tr_align d3dx__tr_align
#define _tr_flush_block d3dx__tr_flush_block
#define inflate_mask d3dx_inflate_mask
#define inflate_flush d3dx_inflate_flush
#define inflate_copyright d3dx_inflate_copyright
#define inflate_trees_bits d3dx_inflate_trees_bits
#define inflate_trees_dynamic d3dx_inflate_trees_dynamic
#define inflate_trees_fixed d3dx_inflate_trees_fixed
#define inflateReset d3dx_inflateReset
#define inflateEnd d3dx_inflateEnd
#define inflateInit2_ d3dx_inflateInit2_
#define inflateInit_ d3dx_inflateInit_
#define inflate d3dx_inflate
#define inflateSetDictionary d3dx_inflateSetDictionary
#define inflateSync d3dx_inflateSync
#define inflateSyncPoint d3dx_inflateSyncPoint
#define inflate_fast d3dx_inflate_fast
#define inflate_codes_new d3dx_inflate_codes_new
#define inflate_codes d3dx_inflate_codes
#define inflate_codes_free d3dx_inflate_codes_free
#define inflate_blocks_reset d3dx_inflate_blocks_reset
#define inflate_blocks_new d3dx_inflate_blocks_new
#define inflate_blocks d3dx_inflate_blocks
#define inflate_blocks_free d3dx_inflate_blocks_free
#define inflate_set_dictionary d3dx_inflate_set_dictionary
#define inflate_blocks_sync_point d3dx_inflate_blocks_sync_point
#define gzsetparams d3dx_gzsetparams
#define gzwrite d3dx_gzwrite
#define gzprintf d3dx_gzprintf
#define gzputc d3dx_gzputc
#define gzputs d3dx_gzputs
#define gzflush d3dx_gzflush
#define gzrewind d3dx_gzrewind
#define gzeof d3dx_gzeof
#define gzclose d3dx_gzclose
#define gzerror d3dx_gzerror
#define gzopen d3dx_gzopen
#define gzdopen d3dx_gzdopen
#define gzread d3dx_gzread
#define gzgetc d3dx_gzgetc
#define gzgets d3dx_gzgets
#define gzseek d3dx_gzseek
#define gztell d3dx_gztell
#define deflate_copyright d3dx_deflate_copyright
#define deflateSetDictionary d3dx_deflateSetDictionary
#define deflate d3dx_deflate
#define deflateEnd d3dx_deflateEnd
#define deflateCopy d3dx_deflateCopy
#define deflateReset d3dx_deflateReset
#define deflateParams d3dx_deflateParams
#define deflateInit2_ d3dx_deflateInit2_
#define deflateInit_ d3dx_deflateInit_
#define get_crc_table d3dx_get_crc_table
#define crc32 d3dx_crc32
#define compress2 d3dx_compress2
#define compress d3dx_compress
#define adler32 d3dx_adler32
#define ZEXPORT __stdcall
#define ZEXPORTVA __cdecl
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\_qsort.h ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To implement the qsort() routine for sorting arrays.
*
*Revision History:
*       06-22-84  RN    author
*       03-25-85  RN    added pre-check for elements already in order to
*                       eliminate worst-case behavior.
*       05-18-86  TC    changed to recurse on the smallest piece to avoid
*                       piece. unneccesary stack usage, and to iterate on
*                       largest
*       01-09-87  BCM   fixed huge-array case where (num-1) * wid computation
*                       was overflowing (large/compact models only)
*       06-13-89  PHG   made more efficient, many more comments, removed
*                       recursion
*       10-30-89  JCR   Added _cdecl to prototypes
*       03-15-90  GJF   Replaced _cdecl with _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, fixed the copyright.
*       04-05-90  GJF   Made shortsort() and swap() _CALLTYPE4. Also, added
*                       #include <search.h>.
*       10-04-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragmas
*       01-24-91  SRW   Added missing close comment in swap procedure
*       11-19-91  GJF   Do the swap one character at a time to avoid alignment
*                       woes.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-27-98  RKP   Add 64 bit support.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-10-00  PML   Performance improvements - middle-of-3 pivot choice,
*                       widen middle range equal to pivot, don't swap pivot to
*                       beginning (vs7#99674).
*       08-08-00  PML   Avoid calling comp(p,p), since some existing code
*                       doesn't expect that (vs7#123134).
*
*******************************************************************************/

#include <stdlib.h>
#include <search.h>
#ifdef NEW_QSORT_NAME
#define qsort NEW_QSORT_NAME
#endif

/* Always compile this module for speed, not size */
#pragma optimize("t", on)

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, size_t width,
                int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, size_t width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */

/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*       maximum array size is number of elements times size of elements,
*       but is limited by the virtual address space of the processor
*
*Entry:
*       char *base = pointer to base of array
*       size_t num  = number of elements in the array
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

#define STKSIZ (8*sizeof(void*) - 2)

void __cdecl qsort (
    void *base,
    size_t num,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    /* Note: the number of stack entries required is no more than
       1 + log2(num), so 30 is sufficient for any array */
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    size_t size;                /* size of the sub-array */
    char *lostk[STKSIZ], *histk[STKSIZ];
    int stkptr;                 /* stack for saving sub-array to be processed */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       preserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
        shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partitioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the median
           of the values, but also that we select one fast.  We choose the
           median of the first, middle, and last elements, to avoid bad
           performance in the face of already sorted data, or data that is made
           up of multiple sorted runs appended together.  Testing shows that a
           median-of-three algorithm provides better performance than simply
           picking the middle element for the latter case. */

        mid = lo + (size / 2) * width;      /* find middle element */

        /* Sort the first, middle, last elements into order */
        if (comp(lo, mid) > 0) {
            swap(lo, mid, width);
        }
        if (comp(lo, hi) > 0) {
            swap(lo, hi, width);
        }
        if (comp(mid, hi) > 0) {
            swap(mid, hi, width);
        }

        /* We now wish to partition the array into three pieces, one consisting
           of elements <= partition element, one of elements equal to the
           partition element, and one of elements > than it.  This is done
           below; comments indicate conditions established at every step. */

        loguy = lo;
        higuy = hi;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi,
               A[i] <= A[mid] for lo <= i <= loguy,
               A[i] > A[mid] for higuy <= i < hi,
               A[hi] >= A[mid] */

            /* The doubled loop is to avoid calling comp(mid,mid), since some
               existing comparison funcs don't work when passed the same
               value for both pointers. */

            if (mid > loguy) {
                do  {
                    loguy += width;
                } while (loguy < mid && comp(loguy, mid) <= 0);
            }
            if (mid <= loguy) {
                do  {
                    loguy += width;
                } while (loguy <= hi && comp(loguy, mid) <= 0);
            }

            /* lo < loguy <= hi+1, A[i] <= A[mid] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[mid] */

            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) > 0);

            /* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
               either higuy == lo or A[higuy] <= A[mid] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy == lo, then we would have exited, so
               A[loguy] > A[mid], A[higuy] <= A[mid],
               loguy <= hi, higuy > lo */

            swap(loguy, higuy, width);

            /* If the partition element was moved, follow it.  Only need
               to check for mid == higuy, since before the swap,
               A[loguy] > A[mid] implies loguy != mid. */

            if (mid == higuy)
                mid = loguy;

            /* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition at top
               of loop is re-established */
        }

        /*     A[i] <= A[mid] for lo <= i < loguy,
               A[i] > A[mid] for higuy < i < hi,
               A[hi] >= A[mid]
               higuy < loguy
           implying:
               higuy == loguy-1
               or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */

        /* Find adjacent elements equal to the partition element.  The
           doubled loop is to avoid calling comp(mid,mid), since some
           existing comparison funcs don't work when passed the same value
           for both pointers. */

        higuy += width;
        if (mid < higuy) {
            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) == 0);
        }
        if (mid >= higuy) {
            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, mid) == 0);
        }

        /* OK, now we have the following:
              higuy < loguy
              lo <= higuy <= hi
              A[i]  <= A[mid] for lo <= i <= higuy
              A[i]  == A[mid] for higuy < i < loguy
              A[i]  >  A[mid] for loguy <= i < hi
              A[hi] >= A[mid] */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - lo >= hi - loguy ) {
            if (lo < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo < higuy) {
                hi = higuy;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       size_t width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    size_t width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\base\inc\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\activate.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for activate.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activate_h__
#define __activate_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISystemActivator_FWD_DEFINED__
#define __ISystemActivator_FWD_DEFINED__
typedef interface ISystemActivator ISystemActivator;
#endif 	/* __ISystemActivator_FWD_DEFINED__ */


#ifndef __IInitActivationPropertiesIn_FWD_DEFINED__
#define __IInitActivationPropertiesIn_FWD_DEFINED__
typedef interface IInitActivationPropertiesIn IInitActivationPropertiesIn;
#endif 	/* __IInitActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IActivationPropertiesIn_FWD_DEFINED__
#define __IActivationPropertiesIn_FWD_DEFINED__
typedef interface IActivationPropertiesIn IActivationPropertiesIn;
#endif 	/* __IActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IActivationPropertiesOut_FWD_DEFINED__
#define __IActivationPropertiesOut_FWD_DEFINED__
typedef interface IActivationPropertiesOut IActivationPropertiesOut;
#endif 	/* __IActivationPropertiesOut_FWD_DEFINED__ */


#ifndef __IActivationStageInfo_FWD_DEFINED__
#define __IActivationStageInfo_FWD_DEFINED__
typedef interface IActivationStageInfo IActivationStageInfo;
#endif 	/* __IActivationStageInfo_FWD_DEFINED__ */


#ifndef __IServerLocationInfo_FWD_DEFINED__
#define __IServerLocationInfo_FWD_DEFINED__
typedef interface IServerLocationInfo IServerLocationInfo;
#endif 	/* __IServerLocationInfo_FWD_DEFINED__ */


#ifndef __IActivationContextInfo_FWD_DEFINED__
#define __IActivationContextInfo_FWD_DEFINED__
typedef interface IActivationContextInfo IActivationContextInfo;
#endif 	/* __IActivationContextInfo_FWD_DEFINED__ */


#ifndef __IOverrideTargetContext_FWD_DEFINED__
#define __IOverrideTargetContext_FWD_DEFINED__
typedef interface IOverrideTargetContext IOverrideTargetContext;
#endif 	/* __IOverrideTargetContext_FWD_DEFINED__ */


#ifndef __IActivationSecurityInfo_FWD_DEFINED__
#define __IActivationSecurityInfo_FWD_DEFINED__
typedef interface IActivationSecurityInfo IActivationSecurityInfo;
#endif 	/* __IActivationSecurityInfo_FWD_DEFINED__ */


#ifndef __IEnumSCMProcessInfo_FWD_DEFINED__
#define __IEnumSCMProcessInfo_FWD_DEFINED__
typedef interface IEnumSCMProcessInfo IEnumSCMProcessInfo;
#endif 	/* __IEnumSCMProcessInfo_FWD_DEFINED__ */


#ifndef __ISCMProcessControl_FWD_DEFINED__
#define __ISCMProcessControl_FWD_DEFINED__
typedef interface ISCMProcessControl ISCMProcessControl;
#endif 	/* __ISCMProcessControl_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"
#include "contxt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_activate_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_activate_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0000_ServerIfHandle;

#ifndef __ISystemActivator_INTERFACE_DEFINED__
#define __ISystemActivator_INTERFACE_DEFINED__

/* interface ISystemActivator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISystemActivator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A0-0000-0000-C000-000000000046")
    ISystemActivator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassObject( 
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemActivatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISystemActivator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISystemActivator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISystemActivator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassObject )( 
            ISystemActivator * This,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            ISystemActivator * This,
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [unique][in] */ IActivationPropertiesIn *pActProperties,
            /* [out] */ IActivationPropertiesOut **ppActProperties);
        
        END_INTERFACE
    } ISystemActivatorVtbl;

    interface ISystemActivator
    {
        CONST_VTBL struct ISystemActivatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemActivator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISystemActivator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISystemActivator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISystemActivator_GetClassObject(This,pActProperties,ppActProperties)	\
    (This)->lpVtbl -> GetClassObject(This,pActProperties,ppActProperties)

#define ISystemActivator_CreateInstance(This,pUnkOuter,pActProperties,ppActProperties)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,pActProperties,ppActProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISystemActivator_GetClassObject_Proxy( 
    ISystemActivator * This,
    /* [unique][in] */ IActivationPropertiesIn *pActProperties,
    /* [out] */ IActivationPropertiesOut **ppActProperties);


void __RPC_STUB ISystemActivator_GetClassObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISystemActivator_CreateInstance_Proxy( 
    ISystemActivator * This,
    /* [unique][in] */ IUnknown *pUnkOuter,
    /* [unique][in] */ IActivationPropertiesIn *pActProperties,
    /* [out] */ IActivationPropertiesOut **ppActProperties);


void __RPC_STUB ISystemActivator_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISystemActivator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0118 */
/* [local] */ 

typedef 
enum tagACTIVATION_FLAGS
    {	ACTVFLAGS_NONE	= 0,
	ACTVFLAGS_WX86_CALLER	= 1,
	ACTVFLAGS_DISABLE_AAA	= 2
    } 	ACTIVATION_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_activate_0118_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0118_ServerIfHandle;

#ifndef __IInitActivationPropertiesIn_INTERFACE_DEFINED__
#define __IInitActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IInitActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IInitActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A1-0000-0000-C000-000000000046")
    IInitActivationPropertiesIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClsctx( 
            /* [in] */ DWORD clsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivationFlags( 
            /* [in] */ DWORD actvflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassInfo( 
            /* [unique][in] */ IUnknown *pUnkClassInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextInfo( 
            /* [unique][in] */ IContext *pClientContext,
            /* [in] */ IContext *pPrototypeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConstructFromStorage( 
            /* [unique][in] */ IStorage *pStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConstructFromFile( 
            /* [in] */ WCHAR *wszFileName,
            /* [in] */ DWORD dwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClsctx )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ DWORD clsctx);
        
        HRESULT ( STDMETHODCALLTYPE *SetActivationFlags )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ DWORD actvflags);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassInfo )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IUnknown *pUnkClassInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextInfo )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IContext *pClientContext,
            /* [in] */ IContext *pPrototypeContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetConstructFromStorage )( 
            IInitActivationPropertiesIn * This,
            /* [unique][in] */ IStorage *pStorage);
        
        HRESULT ( STDMETHODCALLTYPE *SetConstructFromFile )( 
            IInitActivationPropertiesIn * This,
            /* [in] */ WCHAR *wszFileName,
            /* [in] */ DWORD dwMode);
        
        END_INTERFACE
    } IInitActivationPropertiesInVtbl;

    interface IInitActivationPropertiesIn
    {
        CONST_VTBL struct IInitActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitActivationPropertiesIn_SetClsctx(This,clsctx)	\
    (This)->lpVtbl -> SetClsctx(This,clsctx)

#define IInitActivationPropertiesIn_SetActivationFlags(This,actvflags)	\
    (This)->lpVtbl -> SetActivationFlags(This,actvflags)

#define IInitActivationPropertiesIn_SetClassInfo(This,pUnkClassInfo)	\
    (This)->lpVtbl -> SetClassInfo(This,pUnkClassInfo)

#define IInitActivationPropertiesIn_SetContextInfo(This,pClientContext,pPrototypeContext)	\
    (This)->lpVtbl -> SetContextInfo(This,pClientContext,pPrototypeContext)

#define IInitActivationPropertiesIn_SetConstructFromStorage(This,pStorage)	\
    (This)->lpVtbl -> SetConstructFromStorage(This,pStorage)

#define IInitActivationPropertiesIn_SetConstructFromFile(This,wszFileName,dwMode)	\
    (This)->lpVtbl -> SetConstructFromFile(This,wszFileName,dwMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetClsctx_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ DWORD clsctx);


void __RPC_STUB IInitActivationPropertiesIn_SetClsctx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetActivationFlags_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ DWORD actvflags);


void __RPC_STUB IInitActivationPropertiesIn_SetActivationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetClassInfo_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IUnknown *pUnkClassInfo);


void __RPC_STUB IInitActivationPropertiesIn_SetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetContextInfo_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IContext *pClientContext,
    /* [in] */ IContext *pPrototypeContext);


void __RPC_STUB IInitActivationPropertiesIn_SetContextInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetConstructFromStorage_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [unique][in] */ IStorage *pStorage);


void __RPC_STUB IInitActivationPropertiesIn_SetConstructFromStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitActivationPropertiesIn_SetConstructFromFile_Proxy( 
    IInitActivationPropertiesIn * This,
    /* [in] */ WCHAR *wszFileName,
    /* [in] */ DWORD dwMode);


void __RPC_STUB IInitActivationPropertiesIn_SetConstructFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitActivationPropertiesIn_INTERFACE_DEFINED__ */


#ifndef __IActivationPropertiesIn_INTERFACE_DEFINED__
#define __IActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A2-0000-0000-C000-000000000046")
    IActivationPropertiesIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivationID( 
            /* [out] */ GUID *pActivationID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClsctx( 
            /* [out] */ DWORD *pclsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationFlags( 
            /* [out] */ DWORD *pactvflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRequestedIIDs( 
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestedIIDs( 
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateGetClassObject( 
            /* [out] */ IActivationPropertiesOut **pActPropsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateCreateInstance( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelegateCIAndGetCF( 
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReturnActivationProperties( 
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IActivationPropertiesIn * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsctx )( 
            IActivationPropertiesIn * This,
            /* [out] */ DWORD *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationFlags )( 
            IActivationPropertiesIn * This,
            /* [out] */ DWORD *pactvflags);
        
        HRESULT ( STDMETHODCALLTYPE *AddRequestedIIDs )( 
            IActivationPropertiesIn * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedIIDs )( 
            IActivationPropertiesIn * This,
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateGetClassObject )( 
            IActivationPropertiesIn * This,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCreateInstance )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCIAndGetCF )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnActivationProperties )( 
            IActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut);
        
        END_INTERFACE
    } IActivationPropertiesInVtbl;

    interface IActivationPropertiesIn
    {
        CONST_VTBL struct IActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationPropertiesIn_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IActivationPropertiesIn_GetClassInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,riid,ppv)

#define IActivationPropertiesIn_GetClsctx(This,pclsctx)	\
    (This)->lpVtbl -> GetClsctx(This,pclsctx)

#define IActivationPropertiesIn_GetActivationFlags(This,pactvflags)	\
    (This)->lpVtbl -> GetActivationFlags(This,pactvflags)

#define IActivationPropertiesIn_AddRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> AddRequestedIIDs(This,cIfs,rgIID)

#define IActivationPropertiesIn_GetRequestedIIDs(This,pulCount,prgIID)	\
    (This)->lpVtbl -> GetRequestedIIDs(This,pulCount,prgIID)

#define IActivationPropertiesIn_DelegateGetClassObject(This,pActPropsOut)	\
    (This)->lpVtbl -> DelegateGetClassObject(This,pActPropsOut)

#define IActivationPropertiesIn_DelegateCreateInstance(This,pUnkOuter,pActPropsOut)	\
    (This)->lpVtbl -> DelegateCreateInstance(This,pUnkOuter,pActPropsOut)

#define IActivationPropertiesIn_DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)	\
    (This)->lpVtbl -> DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)

#define IActivationPropertiesIn_GetReturnActivationProperties(This,pUnk,ppActOut)	\
    (This)->lpVtbl -> GetReturnActivationProperties(This,pUnk,ppActOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetActivationID_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ GUID *pActivationID);


void __RPC_STUB IActivationPropertiesIn_GetActivationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetClassInfo_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IActivationPropertiesIn_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetClsctx_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ DWORD *pclsctx);


void __RPC_STUB IActivationPropertiesIn_GetClsctx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetActivationFlags_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ DWORD *pactvflags);


void __RPC_STUB IActivationPropertiesIn_GetActivationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_AddRequestedIIDs_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ DWORD cIfs,
    /* [size_is][in] */ IID *rgIID);


void __RPC_STUB IActivationPropertiesIn_AddRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetRequestedIIDs_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ ULONG *pulCount,
    /* [out] */ IID **prgIID);


void __RPC_STUB IActivationPropertiesIn_GetRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateGetClassObject_Proxy( 
    IActivationPropertiesIn * This,
    /* [out] */ IActivationPropertiesOut **pActPropsOut);


void __RPC_STUB IActivationPropertiesIn_DelegateGetClassObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateCreateInstance_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [out] */ IActivationPropertiesOut **pActPropsOut);


void __RPC_STUB IActivationPropertiesIn_DelegateCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_DelegateCIAndGetCF_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [out] */ IActivationPropertiesOut **pActPropsOut,
    /* [out] */ IClassFactory **ppCf);


void __RPC_STUB IActivationPropertiesIn_DelegateCIAndGetCF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesIn_GetReturnActivationProperties_Proxy( 
    IActivationPropertiesIn * This,
    /* [in] */ IUnknown *pUnk,
    /* [out] */ IActivationPropertiesOut **ppActOut);


void __RPC_STUB IActivationPropertiesIn_GetReturnActivationProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationPropertiesIn_INTERFACE_DEFINED__ */


#ifndef __IActivationPropertiesOut_INTERFACE_DEFINED__
#define __IActivationPropertiesOut_INTERFACE_DEFINED__

/* interface IActivationPropertiesOut */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationPropertiesOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A3-0000-0000-C000-000000000046")
    IActivationPropertiesOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActivationID( 
            /* [out] */ GUID *pActivationID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectInterface( 
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectInterfaces( 
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRequestedIIDs( 
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationPropertiesOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationPropertiesOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IActivationPropertiesOut * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterface )( 
            IActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterfaces )( 
            IActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRequestedIIDs )( 
            IActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        END_INTERFACE
    } IActivationPropertiesOutVtbl;

    interface IActivationPropertiesOut
    {
        CONST_VTBL struct IActivationPropertiesOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationPropertiesOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationPropertiesOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationPropertiesOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationPropertiesOut_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IActivationPropertiesOut_GetObjectInterface(This,riid,actvflags,ppv)	\
    (This)->lpVtbl -> GetObjectInterface(This,riid,actvflags,ppv)

#define IActivationPropertiesOut_GetObjectInterfaces(This,cIfs,actvflags,multiQi)	\
    (This)->lpVtbl -> GetObjectInterfaces(This,cIfs,actvflags,multiQi)

#define IActivationPropertiesOut_RemoveRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> RemoveRequestedIIDs(This,cIfs,rgIID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetActivationID_Proxy( 
    IActivationPropertiesOut * This,
    /* [out] */ GUID *pActivationID);


void __RPC_STUB IActivationPropertiesOut_GetActivationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetObjectInterface_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ REFIID riid,
    /* [in] */ DWORD actvflags,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IActivationPropertiesOut_GetObjectInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_GetObjectInterfaces_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ DWORD actvflags,
    /* [size_is][in] */ MULTI_QI *multiQi);


void __RPC_STUB IActivationPropertiesOut_GetObjectInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationPropertiesOut_RemoveRequestedIIDs_Proxy( 
    IActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [size_is][in] */ IID *rgIID);


void __RPC_STUB IActivationPropertiesOut_RemoveRequestedIIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationPropertiesOut_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0121 */
/* [local] */ 

typedef 
enum tagACTIVATION_STAGE
    {	CLIENT_CONTEXT_STAGE	= 1,
	CLIENT_MACHINE_STAGE	= 2,
	SERVER_MACHINE_STAGE	= 3,
	SERVER_PROCESS_STAGE	= 4,
	SERVER_CONTEXT_STAGE	= 5
    } 	ACTIVATION_STAGE;



extern RPC_IF_HANDLE __MIDL_itf_activate_0121_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0121_ServerIfHandle;

#ifndef __IActivationStageInfo_INTERFACE_DEFINED__
#define __IActivationStageInfo_INTERFACE_DEFINED__

/* interface IActivationStageInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActivationStageInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A8-0000-0000-C000-000000000046")
    IActivationStageInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStageAndIndex( 
            /* [in] */ ACTIVATION_STAGE stage,
            /* [in] */ int index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStage( 
            /* [out] */ ACTIVATION_STAGE *pstage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [out] */ int *pindex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationStageInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationStageInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationStageInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationStageInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStageAndIndex )( 
            IActivationStageInfo * This,
            /* [in] */ ACTIVATION_STAGE stage,
            /* [in] */ int index);
        
        HRESULT ( STDMETHODCALLTYPE *GetStage )( 
            IActivationStageInfo * This,
            /* [out] */ ACTIVATION_STAGE *pstage);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IActivationStageInfo * This,
            /* [out] */ int *pindex);
        
        END_INTERFACE
    } IActivationStageInfoVtbl;

    interface IActivationStageInfo
    {
        CONST_VTBL struct IActivationStageInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationStageInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationStageInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationStageInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationStageInfo_SetStageAndIndex(This,stage,index)	\
    (This)->lpVtbl -> SetStageAndIndex(This,stage,index)

#define IActivationStageInfo_GetStage(This,pstage)	\
    (This)->lpVtbl -> GetStage(This,pstage)

#define IActivationStageInfo_GetIndex(This,pindex)	\
    (This)->lpVtbl -> GetIndex(This,pindex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationStageInfo_SetStageAndIndex_Proxy( 
    IActivationStageInfo * This,
    /* [in] */ ACTIVATION_STAGE stage,
    /* [in] */ int index);


void __RPC_STUB IActivationStageInfo_SetStageAndIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationStageInfo_GetStage_Proxy( 
    IActivationStageInfo * This,
    /* [out] */ ACTIVATION_STAGE *pstage);


void __RPC_STUB IActivationStageInfo_GetStage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationStageInfo_GetIndex_Proxy( 
    IActivationStageInfo * This,
    /* [out] */ int *pindex);


void __RPC_STUB IActivationStageInfo_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationStageInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0122 */
/* [local] */ 

typedef 
enum _PRT
    {	PRT_IGNORE	= 0,
	PRT_CREATE_NEW	= 1,
	PRT_USE_THIS	= 2,
	PRT_USE_THIS_ONLY	= 3
    } 	PROCESS_REQUEST_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_activate_0122_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0122_ServerIfHandle;

#ifndef __IServerLocationInfo_INTERFACE_DEFINED__
#define __IServerLocationInfo_INTERFACE_DEFINED__

/* interface IServerLocationInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IServerLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A4-0000-0000-C000-000000000046")
    IServerLocationInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRemoteServerName( 
            /* [unique][string][in] */ WCHAR *pswzMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [string][out] */ WCHAR **pswzMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProcess( 
            /* [in] */ DWORD pid,
            DWORD dwPRT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ DWORD *ppid,
            DWORD *pdwPRT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetApartment( 
            /* [in] */ APTID apartmentId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApartment( 
            /* [out] */ APTID *pApartmentId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ IObjContext *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ IObjContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServerLocationInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServerLocationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServerLocationInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteServerName )( 
            IServerLocationInfo * This,
            /* [unique][string][in] */ WCHAR *pswzMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IServerLocationInfo * This,
            /* [string][out] */ WCHAR **pswzMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcess )( 
            IServerLocationInfo * This,
            /* [in] */ DWORD pid,
            DWORD dwPRT);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IServerLocationInfo * This,
            /* [out] */ DWORD *ppid,
            DWORD *pdwPRT);
        
        HRESULT ( STDMETHODCALLTYPE *SetApartment )( 
            IServerLocationInfo * This,
            /* [in] */ APTID apartmentId);
        
        HRESULT ( STDMETHODCALLTYPE *GetApartment )( 
            IServerLocationInfo * This,
            /* [out] */ APTID *pApartmentId);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IServerLocationInfo * This,
            /* [in] */ IObjContext *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IServerLocationInfo * This,
            /* [out] */ IObjContext **ppContext);
        
        END_INTERFACE
    } IServerLocationInfoVtbl;

    interface IServerLocationInfo
    {
        CONST_VTBL struct IServerLocationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerLocationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerLocationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerLocationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerLocationInfo_SetRemoteServerName(This,pswzMachineName)	\
    (This)->lpVtbl -> SetRemoteServerName(This,pswzMachineName)

#define IServerLocationInfo_GetRemoteServerName(This,pswzMachineName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pswzMachineName)

#define IServerLocationInfo_SetProcess(This,pid,dwPRT)	\
    (This)->lpVtbl -> SetProcess(This,pid,dwPRT)

#define IServerLocationInfo_GetProcess(This,ppid,pdwPRT)	\
    (This)->lpVtbl -> GetProcess(This,ppid,pdwPRT)

#define IServerLocationInfo_SetApartment(This,apartmentId)	\
    (This)->lpVtbl -> SetApartment(This,apartmentId)

#define IServerLocationInfo_GetApartment(This,pApartmentId)	\
    (This)->lpVtbl -> GetApartment(This,pApartmentId)

#define IServerLocationInfo_SetContext(This,pContext)	\
    (This)->lpVtbl -> SetContext(This,pContext)

#define IServerLocationInfo_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetRemoteServerName_Proxy( 
    IServerLocationInfo * This,
    /* [unique][string][in] */ WCHAR *pswzMachineName);


void __RPC_STUB IServerLocationInfo_SetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetRemoteServerName_Proxy( 
    IServerLocationInfo * This,
    /* [string][out] */ WCHAR **pswzMachineName);


void __RPC_STUB IServerLocationInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetProcess_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ DWORD pid,
    DWORD dwPRT);


void __RPC_STUB IServerLocationInfo_SetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetProcess_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ DWORD *ppid,
    DWORD *pdwPRT);


void __RPC_STUB IServerLocationInfo_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetApartment_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ APTID apartmentId);


void __RPC_STUB IServerLocationInfo_SetApartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetApartment_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ APTID *pApartmentId);


void __RPC_STUB IServerLocationInfo_GetApartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_SetContext_Proxy( 
    IServerLocationInfo * This,
    /* [in] */ IObjContext *pContext);


void __RPC_STUB IServerLocationInfo_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerLocationInfo_GetContext_Proxy( 
    IServerLocationInfo * This,
    /* [out] */ IObjContext **ppContext);


void __RPC_STUB IServerLocationInfo_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IActivationContextInfo_INTERFACE_DEFINED__
#define __IActivationContextInfo_INTERFACE_DEFINED__

/* interface IActivationContextInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A5-0000-0000-C000-000000000046")
    IActivationContextInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientContext( 
            /* [out] */ IContext **ppClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrototypeContext( 
            /* [out] */ IContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClientContextOK( 
            /* [out] */ BOOL *fYes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientContextNotOK( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationContextInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientContext )( 
            IActivationContextInfo * This,
            /* [out] */ IContext **ppClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrototypeContext )( 
            IActivationContextInfo * This,
            /* [out] */ IContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsClientContextOK )( 
            IActivationContextInfo * This,
            /* [out] */ BOOL *fYes);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContextNotOK )( 
            IActivationContextInfo * This);
        
        END_INTERFACE
    } IActivationContextInfoVtbl;

    interface IActivationContextInfo
    {
        CONST_VTBL struct IActivationContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationContextInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationContextInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationContextInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationContextInfo_GetClientContext(This,ppClientContext)	\
    (This)->lpVtbl -> GetClientContext(This,ppClientContext)

#define IActivationContextInfo_GetPrototypeContext(This,ppContext)	\
    (This)->lpVtbl -> GetPrototypeContext(This,ppContext)

#define IActivationContextInfo_IsClientContextOK(This,fYes)	\
    (This)->lpVtbl -> IsClientContextOK(This,fYes)

#define IActivationContextInfo_SetClientContextNotOK(This)	\
    (This)->lpVtbl -> SetClientContextNotOK(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationContextInfo_GetClientContext_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ IContext **ppClientContext);


void __RPC_STUB IActivationContextInfo_GetClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_GetPrototypeContext_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ IContext **ppContext);


void __RPC_STUB IActivationContextInfo_GetPrototypeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_IsClientContextOK_Proxy( 
    IActivationContextInfo * This,
    /* [out] */ BOOL *fYes);


void __RPC_STUB IActivationContextInfo_IsClientContextOK_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationContextInfo_SetClientContextNotOK_Proxy( 
    IActivationContextInfo * This);


void __RPC_STUB IActivationContextInfo_SetClientContextNotOK_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationContextInfo_INTERFACE_DEFINED__ */


#ifndef __IOverrideTargetContext_INTERFACE_DEFINED__
#define __IOverrideTargetContext_INTERFACE_DEFINED__

/* interface IOverrideTargetContext */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IOverrideTargetContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001BA-0000-0000-C000-000000000046")
    IOverrideTargetContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OverrideTargetContext( 
            /* [in] */ REFGUID guidTargetCtxtId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOverrideTargetContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IOverrideTargetContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IOverrideTargetContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IOverrideTargetContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *OverrideTargetContext )( 
            IOverrideTargetContext * This,
            /* [in] */ REFGUID guidTargetCtxtId);
        
        END_INTERFACE
    } IOverrideTargetContextVtbl;

    interface IOverrideTargetContext
    {
        CONST_VTBL struct IOverrideTargetContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOverrideTargetContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOverrideTargetContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOverrideTargetContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOverrideTargetContext_OverrideTargetContext(This,guidTargetCtxtId)	\
    (This)->lpVtbl -> OverrideTargetContext(This,guidTargetCtxtId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOverrideTargetContext_OverrideTargetContext_Proxy( 
    IOverrideTargetContext * This,
    /* [in] */ REFGUID guidTargetCtxtId);


void __RPC_STUB IOverrideTargetContext_OverrideTargetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOverrideTargetContext_INTERFACE_DEFINED__ */


#ifndef __IActivationSecurityInfo_INTERFACE_DEFINED__
#define __IActivationSecurityInfo_INTERFACE_DEFINED__

/* interface IActivationSecurityInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001A6-0000-0000-C000-000000000046")
    IActivationSecurityInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAuthnFlags( 
            /* [in] */ DWORD dwAuthnFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnFlags( 
            /* [out] */ DWORD *pdwAuthnFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthnSvc( 
            /* [in] */ DWORD dwAuthnSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnSvc( 
            /* [out] */ DWORD *pdwAuthnSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthzSvc( 
            /* [in] */ DWORD dwAuthzSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthzSvc( 
            /* [out] */ DWORD *pdwAuthzSvc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthnLevel( 
            /* [in] */ DWORD dwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthnLevel( 
            /* [out] */ DWORD *pdwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImpLevel( 
            /* [in] */ DWORD dwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImpLevel( 
            /* [out] */ DWORD *pdwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCapabilities( 
            /* [in] */ DWORD dwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthIdentity( 
            /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthIdentity( 
            /* [out] */ COAUTHIDENTITY **pAuthIdentityData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServerPrincipalName( 
            /* [unique][in] */ WCHAR *pwszServerPrincName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerPrincipalName( 
            /* [out] */ WCHAR **pwszServerPrincName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationSecurityInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationSecurityInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationSecurityInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnFlags )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnFlags )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnSvc )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnSvc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnSvc )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnSvc);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthzSvc )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthzSvc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthzSvc )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthzSvc);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthnLevel )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthnLevel )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetImpLevel )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpLevel )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetCapabilities )( 
            IActivationSecurityInfo * This,
            /* [in] */ DWORD dwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IActivationSecurityInfo * This,
            /* [out] */ DWORD *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuthIdentity )( 
            IActivationSecurityInfo * This,
            /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthIdentity )( 
            IActivationSecurityInfo * This,
            /* [out] */ COAUTHIDENTITY **pAuthIdentityData);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerPrincipalName )( 
            IActivationSecurityInfo * This,
            /* [unique][in] */ WCHAR *pwszServerPrincName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerPrincipalName )( 
            IActivationSecurityInfo * This,
            /* [out] */ WCHAR **pwszServerPrincName);
        
        END_INTERFACE
    } IActivationSecurityInfoVtbl;

    interface IActivationSecurityInfo
    {
        CONST_VTBL struct IActivationSecurityInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationSecurityInfo_SetAuthnFlags(This,dwAuthnFlags)	\
    (This)->lpVtbl -> SetAuthnFlags(This,dwAuthnFlags)

#define IActivationSecurityInfo_GetAuthnFlags(This,pdwAuthnFlags)	\
    (This)->lpVtbl -> GetAuthnFlags(This,pdwAuthnFlags)

#define IActivationSecurityInfo_SetAuthnSvc(This,dwAuthnSvc)	\
    (This)->lpVtbl -> SetAuthnSvc(This,dwAuthnSvc)

#define IActivationSecurityInfo_GetAuthnSvc(This,pdwAuthnSvc)	\
    (This)->lpVtbl -> GetAuthnSvc(This,pdwAuthnSvc)

#define IActivationSecurityInfo_SetAuthzSvc(This,dwAuthzSvc)	\
    (This)->lpVtbl -> SetAuthzSvc(This,dwAuthzSvc)

#define IActivationSecurityInfo_GetAuthzSvc(This,pdwAuthzSvc)	\
    (This)->lpVtbl -> GetAuthzSvc(This,pdwAuthzSvc)

#define IActivationSecurityInfo_SetAuthnLevel(This,dwAuthnLevel)	\
    (This)->lpVtbl -> SetAuthnLevel(This,dwAuthnLevel)

#define IActivationSecurityInfo_GetAuthnLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthnLevel(This,pdwAuthnLevel)

#define IActivationSecurityInfo_SetImpLevel(This,dwImpLevel)	\
    (This)->lpVtbl -> SetImpLevel(This,dwImpLevel)

#define IActivationSecurityInfo_GetImpLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpLevel(This,pdwImpLevel)

#define IActivationSecurityInfo_SetCapabilities(This,dwCapabilities)	\
    (This)->lpVtbl -> SetCapabilities(This,dwCapabilities)

#define IActivationSecurityInfo_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IActivationSecurityInfo_SetAuthIdentity(This,pAuthIdentityData)	\
    (This)->lpVtbl -> SetAuthIdentity(This,pAuthIdentityData)

#define IActivationSecurityInfo_GetAuthIdentity(This,pAuthIdentityData)	\
    (This)->lpVtbl -> GetAuthIdentity(This,pAuthIdentityData)

#define IActivationSecurityInfo_SetServerPrincipalName(This,pwszServerPrincName)	\
    (This)->lpVtbl -> SetServerPrincipalName(This,pwszServerPrincName)

#define IActivationSecurityInfo_GetServerPrincipalName(This,pwszServerPrincName)	\
    (This)->lpVtbl -> GetServerPrincipalName(This,pwszServerPrincName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnFlags_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnFlags);


void __RPC_STUB IActivationSecurityInfo_SetAuthnFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnFlags_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnFlags);


void __RPC_STUB IActivationSecurityInfo_GetAuthnFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnSvc);


void __RPC_STUB IActivationSecurityInfo_SetAuthnSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnSvc);


void __RPC_STUB IActivationSecurityInfo_GetAuthnSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthzSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthzSvc);


void __RPC_STUB IActivationSecurityInfo_SetAuthzSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthzSvc_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthzSvc);


void __RPC_STUB IActivationSecurityInfo_GetAuthzSvc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthnLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwAuthnLevel);


void __RPC_STUB IActivationSecurityInfo_SetAuthnLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthnLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwAuthnLevel);


void __RPC_STUB IActivationSecurityInfo_GetAuthnLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetImpLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwImpLevel);


void __RPC_STUB IActivationSecurityInfo_SetImpLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetImpLevel_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwImpLevel);


void __RPC_STUB IActivationSecurityInfo_GetImpLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetCapabilities_Proxy( 
    IActivationSecurityInfo * This,
    /* [in] */ DWORD dwCapabilities);


void __RPC_STUB IActivationSecurityInfo_SetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetCapabilities_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ DWORD *pdwCapabilities);


void __RPC_STUB IActivationSecurityInfo_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetAuthIdentity_Proxy( 
    IActivationSecurityInfo * This,
    /* [unique][in] */ COAUTHIDENTITY *pAuthIdentityData);


void __RPC_STUB IActivationSecurityInfo_SetAuthIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetAuthIdentity_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ COAUTHIDENTITY **pAuthIdentityData);


void __RPC_STUB IActivationSecurityInfo_GetAuthIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_SetServerPrincipalName_Proxy( 
    IActivationSecurityInfo * This,
    /* [unique][in] */ WCHAR *pwszServerPrincName);


void __RPC_STUB IActivationSecurityInfo_SetServerPrincipalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationSecurityInfo_GetServerPrincipalName_Proxy( 
    IActivationSecurityInfo * This,
    /* [out] */ WCHAR **pwszServerPrincName);


void __RPC_STUB IActivationSecurityInfo_GetServerPrincipalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationSecurityInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0126 */
/* [local] */ 

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_activate_0126_0001
    {	ST_SERVER	= 1,
	ST_OLDSURROGATE	= ST_SERVER + 1,
	ST_COMPLUSAPP	= ST_OLDSURROGATE + 1,
	ST_SERVICE	= ST_COMPLUSAPP + 1
    } 	ServerType;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_activate_0126_0002
    {	SIT_RUNAS_SPECIFIC_USER	= 1,
	SIT_RUNAS_INTERACTIVE	= SIT_RUNAS_SPECIFIC_USER + 1
    } 	ServerIDType;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_activate_0126_0003
    {	SPIF_COMPLUS	= 1,
	SPIF_SUSPENDED	= 2,
	SPIF_RETIRED	= 4,
	SPIF_READY	= 8,
	SPIF_PAUSED	= 16
    } 	SCMProcessInfoFlags;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_activate_0126_0004
    {
    ULONG ulNumClasses;
    GUID *pCLSIDs;
    DWORD pidProcess;
    HANDLE hProcess;
    HANDLE hImpersonationToken;
    WCHAR *pwszWinstaDesktop;
    DWORD dwState;
    GUID AppId;
    ServerType ServerType;
    ServerIDType ServerID;
    FILETIME ftCreated;
    } 	SCMProcessInfo;

typedef struct __MIDL___MIDL_itf_activate_0126_0004 *PSCMProcessInfo;



extern RPC_IF_HANDLE __MIDL_itf_activate_0126_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0126_ServerIfHandle;

#ifndef __IEnumSCMProcessInfo_INTERFACE_DEFINED__
#define __IEnumSCMProcessInfo_INTERFACE_DEFINED__

/* interface IEnumSCMProcessInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumSCMProcessInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8bbbd026-de4d-46b7-8a90-72c66eb64ad6")
    IEnumSCMProcessInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElems,
            /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSCMProcessInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSCMProcessInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSCMProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ ULONG cElems,
            /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ ULONG cElems);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSCMProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSCMProcessInfo * This,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        END_INTERFACE
    } IEnumSCMProcessInfoVtbl;

    interface IEnumSCMProcessInfo
    {
        CONST_VTBL struct IEnumSCMProcessInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSCMProcessInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSCMProcessInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSCMProcessInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSCMProcessInfo_Next(This,cElems,ppSCMProcessInfo,pcFetched)	\
    (This)->lpVtbl -> Next(This,cElems,ppSCMProcessInfo,pcFetched)

#define IEnumSCMProcessInfo_Skip(This,cElems)	\
    (This)->lpVtbl -> Skip(This,cElems)

#define IEnumSCMProcessInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSCMProcessInfo_Clone(This,ppESPI)	\
    (This)->lpVtbl -> Clone(This,ppESPI)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Next_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [in] */ ULONG cElems,
    /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumSCMProcessInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Skip_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [in] */ ULONG cElems);


void __RPC_STUB IEnumSCMProcessInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Reset_Proxy( 
    IEnumSCMProcessInfo * This);


void __RPC_STUB IEnumSCMProcessInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Clone_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB IEnumSCMProcessInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSCMProcessInfo_INTERFACE_DEFINED__ */


#ifndef __ISCMProcessControl_INTERFACE_DEFINED__
#define __ISCMProcessControl_INTERFACE_DEFINED__

/* interface ISCMProcessControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISCMProcessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7629798c-f1e6-4ef0-b521-dc466fded209")
    ISCMProcessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindApplication( 
            /* [in] */ REFGUID rappid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindProcess( 
            /* [in] */ DWORD pid,
            /* [out] */ SCMProcessInfo **pSCMProcessInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendProcess( 
            /* [in] */ DWORD ppid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess( 
            /* [in] */ DWORD pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireProcess( 
            /* [in] */ DWORD pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeSCMProcessInfo( 
            SCMProcessInfo **ppSCMProcessInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCMProcessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISCMProcessControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISCMProcessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISCMProcessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        HRESULT ( STDMETHODCALLTYPE *FindClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        HRESULT ( STDMETHODCALLTYPE *FindProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid,
            /* [out] */ SCMProcessInfo **pSCMProcessInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD ppid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid);
        
        HRESULT ( STDMETHODCALLTYPE *FreeSCMProcessInfo )( 
            ISCMProcessControl * This,
            SCMProcessInfo **ppSCMProcessInfo);
        
        END_INTERFACE
    } ISCMProcessControlVtbl;

    interface ISCMProcessControl
    {
        CONST_VTBL struct ISCMProcessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCMProcessControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCMProcessControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCMProcessControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCMProcessControl_FindApplication(This,rappid,ppESPI)	\
    (This)->lpVtbl -> FindApplication(This,rappid,ppESPI)

#define ISCMProcessControl_FindClass(This,rclsid,ppESPI)	\
    (This)->lpVtbl -> FindClass(This,rclsid,ppESPI)

#define ISCMProcessControl_FindProcess(This,pid,pSCMProcessInfo)	\
    (This)->lpVtbl -> FindProcess(This,pid,pSCMProcessInfo)

#define ISCMProcessControl_SuspendApplication(This,rappid)	\
    (This)->lpVtbl -> SuspendApplication(This,rappid)

#define ISCMProcessControl_SuspendClass(This,rclsid)	\
    (This)->lpVtbl -> SuspendClass(This,rclsid)

#define ISCMProcessControl_SuspendProcess(This,ppid)	\
    (This)->lpVtbl -> SuspendProcess(This,ppid)

#define ISCMProcessControl_ResumeApplication(This,rappid)	\
    (This)->lpVtbl -> ResumeApplication(This,rappid)

#define ISCMProcessControl_ResumeClass(This,rclsid)	\
    (This)->lpVtbl -> ResumeClass(This,rclsid)

#define ISCMProcessControl_ResumeProcess(This,pid)	\
    (This)->lpVtbl -> ResumeProcess(This,pid)

#define ISCMProcessControl_RetireApplication(This,rappid)	\
    (This)->lpVtbl -> RetireApplication(This,rappid)

#define ISCMProcessControl_RetireClass(This,rclsid)	\
    (This)->lpVtbl -> RetireClass(This,rclsid)

#define ISCMProcessControl_RetireProcess(This,pid)	\
    (This)->lpVtbl -> RetireProcess(This,pid)

#define ISCMProcessControl_FreeSCMProcessInfo(This,ppSCMProcessInfo)	\
    (This)->lpVtbl -> FreeSCMProcessInfo(This,ppSCMProcessInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB ISCMProcessControl_FindApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB ISCMProcessControl_FindClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid,
    /* [out] */ SCMProcessInfo **pSCMProcessInfo);


void __RPC_STUB ISCMProcessControl_FindProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_SuspendApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_SuspendClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD ppid);


void __RPC_STUB ISCMProcessControl_SuspendProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_ResumeClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid);


void __RPC_STUB ISCMProcessControl_ResumeProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_RetireApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_RetireClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid);


void __RPC_STUB ISCMProcessControl_RetireProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FreeSCMProcessInfo_Proxy( 
    ISCMProcessControl * This,
    SCMProcessInfo **ppSCMProcessInfo);


void __RPC_STUB ISCMProcessControl_FreeSCMProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCMProcessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0128 */
/* [local] */ 


EXTERN_C const CLSID CLSID_RPCSSInfo;


////////////////////////////////////////////////////////////////////////
//
// API for accessing SCM's objects (exported from rpcss.dll)
//
typedef HRESULT (__stdcall *PFNGETRPCSSINFO)(REFCLSID, REFIID, void**);
//
////////////////////////////////////////////////////////////////////////



extern RPC_IF_HANDLE __MIDL_itf_activate_0128_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0128_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\contxt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for contxt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contxt_h__
#define __contxt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IContextMarshaler_FWD_DEFINED__
#define __IContextMarshaler_FWD_DEFINED__
typedef interface IContextMarshaler IContextMarshaler;
#endif 	/* __IContextMarshaler_FWD_DEFINED__ */


#ifndef __IObjContext_FWD_DEFINED__
#define __IObjContext_FWD_DEFINED__
typedef interface IObjContext IObjContext;
#endif 	/* __IObjContext_FWD_DEFINED__ */


#ifndef __IGetContextId_FWD_DEFINED__
#define __IGetContextId_FWD_DEFINED__
typedef interface IGetContextId IGetContextId;
#endif 	/* __IGetContextId_FWD_DEFINED__ */


#ifndef __IAggregator_FWD_DEFINED__
#define __IAggregator_FWD_DEFINED__
typedef interface IAggregator IAggregator;
#endif 	/* __IAggregator_FWD_DEFINED__ */


#ifndef __ICall_FWD_DEFINED__
#define __ICall_FWD_DEFINED__
typedef interface ICall ICall;
#endif 	/* __ICall_FWD_DEFINED__ */


#ifndef __IRpcCall_FWD_DEFINED__
#define __IRpcCall_FWD_DEFINED__
typedef interface IRpcCall IRpcCall;
#endif 	/* __IRpcCall_FWD_DEFINED__ */


#ifndef __ICallInfo_FWD_DEFINED__
#define __ICallInfo_FWD_DEFINED__
typedef interface ICallInfo ICallInfo;
#endif 	/* __ICallInfo_FWD_DEFINED__ */


#ifndef __IPolicy_FWD_DEFINED__
#define __IPolicy_FWD_DEFINED__
typedef interface IPolicy IPolicy;
#endif 	/* __IPolicy_FWD_DEFINED__ */


#ifndef __IPolicyAsync_FWD_DEFINED__
#define __IPolicyAsync_FWD_DEFINED__
typedef interface IPolicyAsync IPolicyAsync;
#endif 	/* __IPolicyAsync_FWD_DEFINED__ */


#ifndef __IPolicySet_FWD_DEFINED__
#define __IPolicySet_FWD_DEFINED__
typedef interface IPolicySet IPolicySet;
#endif 	/* __IPolicySet_FWD_DEFINED__ */


#ifndef __IComObjIdentity_FWD_DEFINED__
#define __IComObjIdentity_FWD_DEFINED__
typedef interface IComObjIdentity IComObjIdentity;
#endif 	/* __IComObjIdentity_FWD_DEFINED__ */


#ifndef __IPolicyMaker_FWD_DEFINED__
#define __IPolicyMaker_FWD_DEFINED__
typedef interface IPolicyMaker IPolicyMaker;
#endif 	/* __IPolicyMaker_FWD_DEFINED__ */


#ifndef __IExceptionNotification_FWD_DEFINED__
#define __IExceptionNotification_FWD_DEFINED__
typedef interface IExceptionNotification IExceptionNotification;
#endif 	/* __IExceptionNotification_FWD_DEFINED__ */


#ifndef __IAbandonmentNotification_FWD_DEFINED__
#define __IAbandonmentNotification_FWD_DEFINED__
typedef interface IAbandonmentNotification IAbandonmentNotification;
#endif 	/* __IAbandonmentNotification_FWD_DEFINED__ */


#ifndef __IMarshalEnvoy_FWD_DEFINED__
#define __IMarshalEnvoy_FWD_DEFINED__
typedef interface IMarshalEnvoy IMarshalEnvoy;
#endif 	/* __IMarshalEnvoy_FWD_DEFINED__ */


#ifndef __IWrapperInfo_FWD_DEFINED__
#define __IWrapperInfo_FWD_DEFINED__
typedef interface IWrapperInfo IWrapperInfo;
#endif 	/* __IWrapperInfo_FWD_DEFINED__ */


#ifndef __IComDispatchInfo_FWD_DEFINED__
#define __IComDispatchInfo_FWD_DEFINED__
typedef interface IComDispatchInfo IComDispatchInfo;
#endif 	/* __IComDispatchInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_contxt_0000 */
/* [local] */ 

//+-----------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//------------------------------------------------------------------

enum tagCONTEXTEVENT
    {	CONTEXTEVENT_NONE	= 0,
	CONTEXTEVENT_CALL	= 0x1,
	CONTEXTEVENT_ENTER	= 0x2,
	CONTEXTEVENT_LEAVE	= 0x4,
	CONTEXTEVENT_RETURN	= 0x8,
	CONTEXTEVENT_CALLFILLBUFFER	= 0x10,
	CONTEXTEVENT_ENTERWITHBUFFER	= 0x20,
	CONTEXTEVENT_LEAVEFILLBUFFER	= 0x40,
	CONTEXTEVENT_RETURNWITHBUFFER	= 0x80,
	CONTEXTEVENT_BEGINCALL	= 0x100,
	CONTEXTEVENT_BEGINENTER	= 0x200,
	CONTEXTEVENT_BEGINLEAVE	= 0x400,
	CONTEXTEVENT_BEGINRETURN	= 0x800,
	CONTEXTEVENT_FINISHCALL	= 0x1000,
	CONTEXTEVENT_FINISHENTER	= 0x2000,
	CONTEXTEVENT_FINISHLEAVE	= 0x4000,
	CONTEXTEVENT_FINISHRETURN	= 0x8000,
	CONTEXTEVENT_BEGINCALLFILLBUFFER	= 0x10000,
	CONTEXTEVENT_BEGINENTERWITHBUFFER	= 0x20000,
	CONTEXTEVENT_FINISHLEAVEFILLBUFFER	= 0x40000,
	CONTEXTEVENT_FINISHRETURNWITHBUFFER	= 0x80000,
	CONTEXTEVENT_LEAVEEXCEPTION	= 0x100000,
	CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER	= 0x200000,
	CONTEXTEVENT_RETURNEXCEPTION	= 0x400000,
	CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER	= 0x800000,
	CONTEXTEVENT_ADDREFPOLICY	= 0x10000000,
	CONTEXTEVENT_RELEASEPOLICY	= 0x20000000
    } ;
typedef DWORD ContextEvent;


enum tagCPFLAGS
    {	CPFLAG_NONE	= 0,
	CPFLAG_PROPAGATE	= 0x1,
	CPFLAG_EXPOSE	= 0x2,
	CPFLAG_ENVOY	= 0x4,
	CPFLAG_MONITORSTUB	= 0x8,
	CPFLAG_MONITORPROXY	= 0x10,
	CPFLAG_DONTCOMPARE	= 0x20
    } ;




extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_ServerIfHandle;

#ifndef __IContextMarshaler_INTERFACE_DEFINED__
#define __IContextMarshaler_INTERFACE_DEFINED__

/* interface IContextMarshaler */
/* [uuid][object][local] */ 

typedef /* [unique] */ IContextMarshaler *LPCTXMARSHALER;


EXTERN_C const IID IID_IContextMarshaler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001D8-0000-0000-C000-000000000046")
    IContextMarshaler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalInterface( 
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMarshalerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMarshaler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMarshaler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMarshaler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalSizeMax )( 
            IContextMarshaler * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalInterface )( 
            IContextMarshaler * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        END_INTERFACE
    } IContextMarshalerVtbl;

    interface IContextMarshaler
    {
        CONST_VTBL struct IContextMarshalerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMarshaler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMarshaler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMarshaler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMarshaler_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IContextMarshaler_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextMarshaler_GetMarshalSizeMax_Proxy( 
    IContextMarshaler * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD *pSize);


void __RPC_STUB IContextMarshaler_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextMarshaler_MarshalInterface_Proxy( 
    IContextMarshaler * This,
    /* [unique][in] */ IStream *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IContextMarshaler_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMarshaler_INTERFACE_DEFINED__ */


#ifndef __IObjContext_INTERFACE_DEFINED__
#define __IObjContext_INTERFACE_DEFINED__

/* interface IObjContext */
/* [unique][uuid][object][local] */ 

typedef /* [ref] */ HRESULT ( __stdcall *PFNCTXCALLBACK )( 
    void *pParam);


EXTERN_C const IID IID_IObjContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c6-0000-0000-C000-000000000046")
    IObjContext : public IContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Freeze( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoCallback( 
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextMarshaler( 
            /* [in] */ IContextMarshaler *pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextMarshaler( 
            /* [out] */ IContextMarshaler **pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rPolicyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS *pFlags,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContextProps )( 
            IObjContext * This,
            /* [out] */ IEnumContextProps **ppEnumContextProps);
        
        HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IObjContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoCallback )( 
            IObjContext * This,
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextMarshaler )( 
            IObjContext * This,
            /* [in] */ IContextMarshaler *pICM);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextMarshaler )( 
            IObjContext * This,
            /* [out] */ IContextMarshaler **pICM);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextFlags )( 
            IObjContext * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ClearContextFlags )( 
            IObjContext * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextFlags )( 
            IObjContext * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IObjContextVtbl;

    interface IObjContext
    {
        CONST_VTBL struct IObjContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IObjContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IObjContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IObjContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)


#define IObjContext_Freeze(This)	\
    (This)->lpVtbl -> Freeze(This)

#define IObjContext_DoCallback(This,pfnCallback,pParam,riid,iMethod)	\
    (This)->lpVtbl -> DoCallback(This,pfnCallback,pParam,riid,iMethod)

#define IObjContext_SetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> SetContextMarshaler(This,pICM)

#define IObjContext_GetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> GetContextMarshaler(This,pICM)

#define IObjContext_SetContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetContextFlags(This,dwFlags)

#define IObjContext_ClearContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> ClearContextFlags(This,dwFlags)

#define IObjContext_GetContextFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetContextFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjContext_Freeze_Proxy( 
    IObjContext * This);


void __RPC_STUB IObjContext_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_DoCallback_Proxy( 
    IObjContext * This,
    /* [in] */ PFNCTXCALLBACK pfnCallback,
    /* [in] */ void *pParam,
    /* [in] */ REFIID riid,
    /* [in] */ unsigned int iMethod);


void __RPC_STUB IObjContext_DoCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextMarshaler_Proxy( 
    IObjContext * This,
    /* [in] */ IContextMarshaler *pICM);


void __RPC_STUB IObjContext_SetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextMarshaler_Proxy( 
    IObjContext * This,
    /* [out] */ IContextMarshaler **pICM);


void __RPC_STUB IObjContext_GetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextFlags_Proxy( 
    IObjContext * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_SetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_ClearContextFlags_Proxy( 
    IObjContext * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_ClearContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextFlags_Proxy( 
    IObjContext * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IObjContext_GetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjContext_INTERFACE_DEFINED__ */


#ifndef __IGetContextId_INTERFACE_DEFINED__
#define __IGetContextId_INTERFACE_DEFINED__

/* interface IGetContextId */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGetContextId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dd-0000-0000-C000-000000000046")
    IGetContextId : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContextId( 
            /* [out] */ GUID *pguidCtxtId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetContextId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetContextId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetContextId * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            IGetContextId * This,
            /* [out] */ GUID *pguidCtxtId);
        
        END_INTERFACE
    } IGetContextIdVtbl;

    interface IGetContextId
    {
        CONST_VTBL struct IGetContextIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetContextId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetContextId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetContextId_GetContextId(This,pguidCtxtId)	\
    (This)->lpVtbl -> GetContextId(This,pguidCtxtId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetContextId_GetContextId_Proxy( 
    IGetContextId * This,
    /* [out] */ GUID *pguidCtxtId);


void __RPC_STUB IGetContextId_GetContextId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetContextId_INTERFACE_DEFINED__ */


#ifndef __IAggregator_INTERFACE_DEFINED__
#define __IAggregator_INTERFACE_DEFINED__

/* interface IAggregator */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAggregator *IAGGREGATOR;


EXTERN_C const IID IID_IAggregator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d8-0000-0000-C000-000000000046")
    IAggregator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Aggregate( 
            /* [in] */ IUnknown *pInnerUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAggregatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAggregator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAggregator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAggregator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Aggregate )( 
            IAggregator * This,
            /* [in] */ IUnknown *pInnerUnk);
        
        END_INTERFACE
    } IAggregatorVtbl;

    interface IAggregator
    {
        CONST_VTBL struct IAggregatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAggregator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAggregator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAggregator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAggregator_Aggregate(This,pInnerUnk)	\
    (This)->lpVtbl -> Aggregate(This,pInnerUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAggregator_Aggregate_Proxy( 
    IAggregator * This,
    /* [in] */ IUnknown *pInnerUnk);


void __RPC_STUB IAggregator_Aggregate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAggregator_INTERFACE_DEFINED__ */


#ifndef __ICall_INTERFACE_DEFINED__
#define __ICall_INTERFACE_DEFINED__

/* interface ICall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICall *LPCALL;


EXTERN_C const IID IID_ICall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d6-0000-0000-C000-000000000046")
    ICall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallInfo( 
            /* [out] */ const void **ppIdentity,
            /* [out] */ IID *piid,
            /* [out] */ DWORD *pdwMethod,
            /* [out] */ HRESULT *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Nullify( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerHR( 
            /* [out] */ HRESULT *phr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallInfo )( 
            ICall * This,
            /* [out] */ const void **ppIdentity,
            /* [out] */ IID *piid,
            /* [out] */ DWORD *pdwMethod,
            /* [out] */ HRESULT *phr);
        
        HRESULT ( STDMETHODCALLTYPE *Nullify )( 
            ICall * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerHR )( 
            ICall * This,
            /* [out] */ HRESULT *phr);
        
        END_INTERFACE
    } ICallVtbl;

    interface ICall
    {
        CONST_VTBL struct ICallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICall_GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)	\
    (This)->lpVtbl -> GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)

#define ICall_Nullify(This,hr)	\
    (This)->lpVtbl -> Nullify(This,hr)

#define ICall_GetServerHR(This,phr)	\
    (This)->lpVtbl -> GetServerHR(This,phr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICall_GetCallInfo_Proxy( 
    ICall * This,
    /* [out] */ const void **ppIdentity,
    /* [out] */ IID *piid,
    /* [out] */ DWORD *pdwMethod,
    /* [out] */ HRESULT *phr);


void __RPC_STUB ICall_GetCallInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_Nullify_Proxy( 
    ICall * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB ICall_Nullify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_GetServerHR_Proxy( 
    ICall * This,
    /* [out] */ HRESULT *phr);


void __RPC_STUB ICall_GetServerHR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICall_INTERFACE_DEFINED__ */


#ifndef __IRpcCall_INTERFACE_DEFINED__
#define __IRpcCall_INTERFACE_DEFINED__

/* interface IRpcCall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IRpcCall *LPRPCCALL;


EXTERN_C const IID IID_IRpcCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c5-0000-0000-C000-000000000046")
    IRpcCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRpcOleMessage( 
            /* [out] */ RPCOLEMESSAGE **ppMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRpcCall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRpcCall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRpcCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRpcOleMessage )( 
            IRpcCall * This,
            /* [out] */ RPCOLEMESSAGE **ppMessage);
        
        END_INTERFACE
    } IRpcCallVtbl;

    interface IRpcCall
    {
        CONST_VTBL struct IRpcCallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcCall_GetRpcOleMessage(This,ppMessage)	\
    (This)->lpVtbl -> GetRpcOleMessage(This,ppMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRpcCall_GetRpcOleMessage_Proxy( 
    IRpcCall * This,
    /* [out] */ RPCOLEMESSAGE **ppMessage);


void __RPC_STUB IRpcCall_GetRpcOleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcCall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0100 */
/* [local] */ 

typedef 
enum _CALLSOURCE
    {	CALLSOURCE_CROSSAPT	= 0,
	CALLSOURCE_CROSSCTX	= 1
    } 	CALLSOURCE;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0100_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0100_ServerIfHandle;

#ifndef __ICallInfo_INTERFACE_DEFINED__
#define __ICallInfo_INTERFACE_DEFINED__

/* interface ICallInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ICallInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dc-0000-0000-C000-000000000046")
    ICallInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallSource( 
            /* [out] */ CALLSOURCE *pCallSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICallInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICallInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICallInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallSource )( 
            ICallInfo * This,
            /* [out] */ CALLSOURCE *pCallSource);
        
        END_INTERFACE
    } ICallInfoVtbl;

    interface ICallInfo
    {
        CONST_VTBL struct ICallInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICallInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICallInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICallInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICallInfo_GetCallSource(This,pCallSource)	\
    (This)->lpVtbl -> GetCallSource(This,pCallSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICallInfo_GetCallSource_Proxy( 
    ICallInfo * This,
    /* [out] */ CALLSOURCE *pCallSource);


void __RPC_STUB ICallInfo_GetCallSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICallInfo_INTERFACE_DEFINED__ */


#ifndef __IPolicy_INTERFACE_DEFINED__
#define __IPolicy_INTERFACE_DEFINED__

/* interface IPolicy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c2-0000-0000-C000-000000000046")
    IPolicy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Call( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Return( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRefPolicy( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleasePolicy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Call )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Enter )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Leave )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Return )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *CallGetSize )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *CallFillBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *EnterWithBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveGetSize )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFillBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *ReturnWithBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        ULONG ( STDMETHODCALLTYPE *AddRefPolicy )( 
            IPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *ReleasePolicy )( 
            IPolicy * This);
        
        END_INTERFACE
    } IPolicyVtbl;

    interface IPolicy
    {
        CONST_VTBL struct IPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicy_Call(This,pCall)	\
    (This)->lpVtbl -> Call(This,pCall)

#define IPolicy_Enter(This,pCall)	\
    (This)->lpVtbl -> Enter(This,pCall)

#define IPolicy_Leave(This,pCall)	\
    (This)->lpVtbl -> Leave(This,pCall)

#define IPolicy_Return(This,pCall)	\
    (This)->lpVtbl -> Return(This,pCall)

#define IPolicy_CallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> CallGetSize(This,pCall,pcb)

#define IPolicy_CallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> CallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_EnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> EnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_LeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> LeaveGetSize(This,pCall,pcb)

#define IPolicy_LeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> LeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_ReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> ReturnWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_AddRefPolicy(This)	\
    (This)->lpVtbl -> AddRefPolicy(This)

#define IPolicy_ReleasePolicy(This)	\
    (This)->lpVtbl -> ReleasePolicy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicy_Call_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Enter_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Enter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Leave_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Return_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Return_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallGetSize_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_CallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallFillBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_CallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_EnterWithBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_EnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveGetSize_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_LeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveFillBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_LeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_ReturnWithBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_ReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_AddRefPolicy_Proxy( 
    IPolicy * This);


void __RPC_STUB IPolicy_AddRefPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_ReleasePolicy_Proxy( 
    IPolicy * This);


void __RPC_STUB IPolicy_ReleasePolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicy_INTERFACE_DEFINED__ */


#ifndef __IPolicyAsync_INTERFACE_DEFINED__
#define __IPolicyAsync_INTERFACE_DEFINED__

/* interface IPolicyAsync */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001cd-0000-0000-C000-000000000046")
    IPolicyAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginCallGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCall( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCallFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnterWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginLeave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginReturn( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishCall( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishEnter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturn( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturnWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicyAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicyAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicyAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCallGetSize )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCall )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCallFillBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnter )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnterWithBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginLeave )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginReturn )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishCall )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishEnter )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeaveGetSize )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeave )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeaveFillBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *FinishReturn )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishReturnWithBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IPolicyAsyncVtbl;

    interface IPolicyAsync
    {
        CONST_VTBL struct IPolicyAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyAsync_BeginCallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> BeginCallGetSize(This,pCall,pcb)

#define IPolicyAsync_BeginCall(This,pCall)	\
    (This)->lpVtbl -> BeginCall(This,pCall)

#define IPolicyAsync_BeginCallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> BeginCallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_BeginEnter(This,pCall)	\
    (This)->lpVtbl -> BeginEnter(This,pCall)

#define IPolicyAsync_BeginEnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> BeginEnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicyAsync_BeginLeave(This,pCall)	\
    (This)->lpVtbl -> BeginLeave(This,pCall)

#define IPolicyAsync_BeginReturn(This,pCall)	\
    (This)->lpVtbl -> BeginReturn(This,pCall)

#define IPolicyAsync_FinishCall(This,pCall)	\
    (This)->lpVtbl -> FinishCall(This,pCall)

#define IPolicyAsync_FinishEnter(This,pCall)	\
    (This)->lpVtbl -> FinishEnter(This,pCall)

#define IPolicyAsync_FinishLeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> FinishLeaveGetSize(This,pCall,pcb)

#define IPolicyAsync_FinishLeave(This,pCall)	\
    (This)->lpVtbl -> FinishLeave(This,pCall)

#define IPolicyAsync_FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_FinishReturn(This,pCall)	\
    (This)->lpVtbl -> FinishReturn(This,pCall)

#define IPolicyAsync_FinishReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> FinishReturnWithBuffer(This,pCall,pvBuf,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallGetSize_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_BeginCallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCall_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallFillBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_BeginCallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnter_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnterWithBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_BeginEnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginLeave_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginReturn_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishCall_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishEnter_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveGetSize_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeave_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveFillBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturn_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturnWithBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_FinishReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyAsync_INTERFACE_DEFINED__ */


#ifndef __IPolicySet_INTERFACE_DEFINED__
#define __IPolicySet_INTERFACE_DEFINED__

/* interface IPolicySet */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c3-0000-0000-C000-000000000046")
    IPolicySet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPolicy( 
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy *pPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicySet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicySet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicySet * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPolicy )( 
            IPolicySet * This,
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy *pPolicy);
        
        END_INTERFACE
    } IPolicySetVtbl;

    interface IPolicySet
    {
        CONST_VTBL struct IPolicySetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicySet_AddPolicy(This,ctxEvent,rguid,pPolicy)	\
    (This)->lpVtbl -> AddPolicy(This,ctxEvent,rguid,pPolicy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicySet_AddPolicy_Proxy( 
    IPolicySet * This,
    /* [in] */ ContextEvent ctxEvent,
    /* [in] */ REFGUID rguid,
    /* [in] */ IPolicy *pPolicy);


void __RPC_STUB IPolicySet_AddPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicySet_INTERFACE_DEFINED__ */


#ifndef __IComObjIdentity_INTERFACE_DEFINED__
#define __IComObjIdentity_INTERFACE_DEFINED__

/* interface IComObjIdentity */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComObjIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d7-0000-0000-C000-000000000046")
    IComObjIdentity : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsServer( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDeactivated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjIdentity * This);
        
        BOOL ( STDMETHODCALLTYPE *IsServer )( 
            IComObjIdentity * This);
        
        BOOL ( STDMETHODCALLTYPE *IsDeactivated )( 
            IComObjIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentity )( 
            IComObjIdentity * This,
            /* [out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IComObjIdentityVtbl;

    interface IComObjIdentity
    {
        CONST_VTBL struct IComObjIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComObjIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComObjIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComObjIdentity_IsServer(This)	\
    (This)->lpVtbl -> IsServer(This)

#define IComObjIdentity_IsDeactivated(This)	\
    (This)->lpVtbl -> IsDeactivated(This)

#define IComObjIdentity_GetIdentity(This,ppUnk)	\
    (This)->lpVtbl -> GetIdentity(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



BOOL STDMETHODCALLTYPE IComObjIdentity_IsServer_Proxy( 
    IComObjIdentity * This);


void __RPC_STUB IComObjIdentity_IsServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IComObjIdentity_IsDeactivated_Proxy( 
    IComObjIdentity * This);


void __RPC_STUB IComObjIdentity_IsDeactivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComObjIdentity_GetIdentity_Proxy( 
    IComObjIdentity * This,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IComObjIdentity_GetIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComObjIdentity_INTERFACE_DEFINED__ */


#ifndef __IPolicyMaker_INTERFACE_DEFINED__
#define __IPolicyMaker_INTERFACE_DEFINED__

/* interface IPolicyMaker */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyMaker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c4-0000-0000-C000-000000000046")
    IPolicyMaker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddClientPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvoyPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddServerPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Freeze( 
            /* [in] */ IObjContext *pObjContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStub( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyStub( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProxy( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyProxy( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyMakerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicyMaker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicyMaker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicyMaker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddClientPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnvoyPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddServerPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IPolicyMaker * This,
            /* [in] */ IObjContext *pObjContext);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStub )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyStub )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProxy )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyProxy )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        END_INTERFACE
    } IPolicyMakerVtbl;

    interface IPolicyMaker
    {
        CONST_VTBL struct IPolicyMakerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyMaker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyMaker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyMaker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyMaker_AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_Freeze(This,pObjContext)	\
    (This)->lpVtbl -> Freeze(This,pObjContext)

#define IPolicyMaker_CreateStub(This,pID)	\
    (This)->lpVtbl -> CreateStub(This,pID)

#define IPolicyMaker_DestroyStub(This,pID)	\
    (This)->lpVtbl -> DestroyStub(This,pID)

#define IPolicyMaker_CreateProxy(This,pID)	\
    (This)->lpVtbl -> CreateProxy(This,pID)

#define IPolicyMaker_DestroyProxy(This,pID)	\
    (This)->lpVtbl -> DestroyProxy(This,pID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyMaker_AddClientPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddClientPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddEnvoyPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddEnvoyPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddServerPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddServerPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_Freeze_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IObjContext *pObjContext);


void __RPC_STUB IPolicyMaker_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateStub_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_CreateStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyStub_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_DestroyStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateProxy_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_CreateProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyProxy_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_DestroyProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyMaker_INTERFACE_DEFINED__ */


#ifndef __IExceptionNotification_INTERFACE_DEFINED__
#define __IExceptionNotification_INTERFACE_DEFINED__

/* interface IExceptionNotification */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IExceptionNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001db-0000-0000-C000-000000000046")
    IExceptionNotification : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE ServerException( 
            /* [in] */ void *pExcepPtrs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExceptionNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExceptionNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExceptionNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExceptionNotification * This);
        
        void ( STDMETHODCALLTYPE *ServerException )( 
            IExceptionNotification * This,
            /* [in] */ void *pExcepPtrs);
        
        END_INTERFACE
    } IExceptionNotificationVtbl;

    interface IExceptionNotification
    {
        CONST_VTBL struct IExceptionNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExceptionNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExceptionNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExceptionNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExceptionNotification_ServerException(This,pExcepPtrs)	\
    (This)->lpVtbl -> ServerException(This,pExcepPtrs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IExceptionNotification_ServerException_Proxy( 
    IExceptionNotification * This,
    /* [in] */ void *pExcepPtrs);


void __RPC_STUB IExceptionNotification_ServerException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExceptionNotification_INTERFACE_DEFINED__ */


#ifndef __IAbandonmentNotification_INTERFACE_DEFINED__
#define __IAbandonmentNotification_INTERFACE_DEFINED__

/* interface IAbandonmentNotification */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAbandonmentNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001de-0000-0000-C000-000000000046")
    IAbandonmentNotification : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE Abandoned( 
            IObjContext *pObjContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAbandonmentNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAbandonmentNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAbandonmentNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAbandonmentNotification * This);
        
        void ( STDMETHODCALLTYPE *Abandoned )( 
            IAbandonmentNotification * This,
            IObjContext *pObjContext);
        
        END_INTERFACE
    } IAbandonmentNotificationVtbl;

    interface IAbandonmentNotification
    {
        CONST_VTBL struct IAbandonmentNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAbandonmentNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAbandonmentNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAbandonmentNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAbandonmentNotification_Abandoned(This,pObjContext)	\
    (This)->lpVtbl -> Abandoned(This,pObjContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IAbandonmentNotification_Abandoned_Proxy( 
    IAbandonmentNotification * This,
    IObjContext *pObjContext);


void __RPC_STUB IAbandonmentNotification_Abandoned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAbandonmentNotification_INTERFACE_DEFINED__ */


#ifndef __IMarshalEnvoy_INTERFACE_DEFINED__
#define __IMarshalEnvoy_INTERFACE_DEFINED__

/* interface IMarshalEnvoy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMarshalEnvoy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c8-0000-0000-C000-000000000046")
    IMarshalEnvoy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnvoyUnmarshalClass( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID *pClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnvoySizeMax( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalEnvoy( 
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwDestContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalEnvoy( 
            /* [in] */ IStream *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalEnvoyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarshalEnvoy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarshalEnvoy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarshalEnvoy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnvoyUnmarshalClass )( 
            IMarshalEnvoy * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID *pClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnvoySizeMax )( 
            IMarshalEnvoy * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalEnvoy )( 
            IMarshalEnvoy * This,
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwDestContext);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalEnvoy )( 
            IMarshalEnvoy * This,
            /* [in] */ IStream *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk);
        
        END_INTERFACE
    } IMarshalEnvoyVtbl;

    interface IMarshalEnvoy
    {
        CONST_VTBL struct IMarshalEnvoyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshalEnvoy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshalEnvoy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshalEnvoy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshalEnvoy_GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)	\
    (This)->lpVtbl -> GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)

#define IMarshalEnvoy_GetEnvoySizeMax(This,dwDestContext,pcb)	\
    (This)->lpVtbl -> GetEnvoySizeMax(This,dwDestContext,pcb)

#define IMarshalEnvoy_MarshalEnvoy(This,pStream,dwDestContext)	\
    (This)->lpVtbl -> MarshalEnvoy(This,pStream,dwDestContext)

#define IMarshalEnvoy_UnmarshalEnvoy(This,pStream,riid,ppunk)	\
    (This)->lpVtbl -> UnmarshalEnvoy(This,pStream,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoyUnmarshalClass_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ CLSID *pClsid);


void __RPC_STUB IMarshalEnvoy_GetEnvoyUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoySizeMax_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ DWORD *pcb);


void __RPC_STUB IMarshalEnvoy_GetEnvoySizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_MarshalEnvoy_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ IStream *pStream,
    /* [in] */ DWORD dwDestContext);


void __RPC_STUB IMarshalEnvoy_MarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_UnmarshalEnvoy_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ IStream *pStream,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppunk);


void __RPC_STUB IMarshalEnvoy_UnmarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshalEnvoy_INTERFACE_DEFINED__ */


#ifndef __IWrapperInfo_INTERFACE_DEFINED__
#define __IWrapperInfo_INTERFACE_DEFINED__

/* interface IWrapperInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IWrapperInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5052f924-7ab8-11d3-b93f-00c04f990176")
    IWrapperInfo : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE SetMapping( 
            void *pv) = 0;
        
        virtual void *STDMETHODCALLTYPE GetMapping( void) = 0;
        
        virtual IObjContext *STDMETHODCALLTYPE GetServerObjectContext( void) = 0;
        
        virtual IUnknown *STDMETHODCALLTYPE GetServerObject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapperInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrapperInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrapperInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrapperInfo * This);
        
        void ( STDMETHODCALLTYPE *SetMapping )( 
            IWrapperInfo * This,
            void *pv);
        
        void *( STDMETHODCALLTYPE *GetMapping )( 
            IWrapperInfo * This);
        
        IObjContext *( STDMETHODCALLTYPE *GetServerObjectContext )( 
            IWrapperInfo * This);
        
        IUnknown *( STDMETHODCALLTYPE *GetServerObject )( 
            IWrapperInfo * This);
        
        END_INTERFACE
    } IWrapperInfoVtbl;

    interface IWrapperInfo
    {
        CONST_VTBL struct IWrapperInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapperInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapperInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapperInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapperInfo_SetMapping(This,pv)	\
    (This)->lpVtbl -> SetMapping(This,pv)

#define IWrapperInfo_GetMapping(This)	\
    (This)->lpVtbl -> GetMapping(This)

#define IWrapperInfo_GetServerObjectContext(This)	\
    (This)->lpVtbl -> GetServerObjectContext(This)

#define IWrapperInfo_GetServerObject(This)	\
    (This)->lpVtbl -> GetServerObject(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWrapperInfo_SetMapping_Proxy( 
    IWrapperInfo * This,
    void *pv);


void __RPC_STUB IWrapperInfo_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void *STDMETHODCALLTYPE IWrapperInfo_GetMapping_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IObjContext *STDMETHODCALLTYPE IWrapperInfo_GetServerObjectContext_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetServerObjectContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IUnknown *STDMETHODCALLTYPE IWrapperInfo_GetServerObject_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetServerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapperInfo_INTERFACE_DEFINED__ */


#ifndef __IComDispatchInfo_INTERFACE_DEFINED__
#define __IComDispatchInfo_INTERFACE_DEFINED__

/* interface IComDispatchInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComDispatchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d9-0000-0000-C000-000000000046")
    IComDispatchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableComInits( 
            /* [out] */ void **ppvCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableComInits( 
            /* [in] */ void *pvCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComDispatchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComDispatchInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComDispatchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComDispatchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableComInits )( 
            IComDispatchInfo * This,
            /* [out] */ void **ppvCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DisableComInits )( 
            IComDispatchInfo * This,
            /* [in] */ void *pvCookie);
        
        END_INTERFACE
    } IComDispatchInfoVtbl;

    interface IComDispatchInfo
    {
        CONST_VTBL struct IComDispatchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComDispatchInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComDispatchInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComDispatchInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComDispatchInfo_EnableComInits(This,ppvCookie)	\
    (This)->lpVtbl -> EnableComInits(This,ppvCookie)

#define IComDispatchInfo_DisableComInits(This,pvCookie)	\
    (This)->lpVtbl -> DisableComInits(This,pvCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComDispatchInfo_EnableComInits_Proxy( 
    IComDispatchInfo * This,
    /* [out] */ void **ppvCookie);


void __RPC_STUB IComDispatchInfo_EnableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComDispatchInfo_DisableComInits_Proxy( 
    IComDispatchInfo * This,
    /* [in] */ void *pvCookie);


void __RPC_STUB IComDispatchInfo_DisableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComDispatchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0111 */
/* [local] */ 

typedef DWORD HActivator;

STDAPI CoCreateObjectInContext(IUnknown *pUnk, IObjContext *pObjectCtx, REFIID riid, void **ppv);
STDAPI CoGetApartmentID(APTTYPE dAptType, HActivator* pAptID);
STDAPI CoGetProcessIdentifier(GUID* pguidProcessIdentifier);
STDAPI CoDeactivateObject(IUnknown *pUnk, IUnknown **ppCookie);
STDAPI CoReactivateObject(IUnknown *pUnk, IUnknown *pCookie);
#define MSHLFLAGS_NO_IEC      0x8  // don't use IExternalConnextion
#define MSHLFLAGS_NO_IMARSHAL 0x10 // don't use IMarshal
#define CONTEXTFLAGS_FROZEN         0x01 // Frozen context
#define CONTEXTFLAGS_ALLOWUNAUTH    0x02 // Allow unauthenticated calls
#define CONTEXTFLAGS_ENVOYCONTEXT   0x04 // Envoy context
#define CONTEXTFLAGS_DEFAULTCONTEXT 0x08 // Default context
#define CONTEXTFLAGS_STATICCONTEXT  0x10 // Static context
#define CONTEXTFLAGS_INPROPTABLE    0x20 // Is in property table
#define CONTEXTFLAGS_INDESTRUCTOR   0x40 // Is in destructor
#define CONTEXTFLAGS_URTPROPPRESENT 0x80 // URT property added
typedef 
enum tagCoModuleType
    {	CO_MODULE_UNKNOWN	= 0,
	CO_MODULE_32BIT	= 0x1,
	CO_MODULE_64BIT	= 0x2
    } 	CoModuleType;

STDAPI CoGetModuleType (LPCWSTR pwszModule, CoModuleType* pModType); 
STDAPI CoPushServiceDomain (IObjContext* pObjContext);  
STDAPI CoPopServiceDomain (IObjContext** ppObjContext);	


extern RPC_IF_HANDLE __MIDL_itf_contxt_0111_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0111_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\cor.h ===
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 ** Copyright (c) Microsoft Corporation. All rights reserved.               **
 **                                                                         **
 *****************************************************************************/


#ifndef _COR_H_
#define _COR_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.    
//*****************************************************************************

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY LIBID_ComPlusRuntime = 
{ 0xbed7f4ea, 0x1a96, 0x11d2, { 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ExportedFromComPlus = 
{ 0x90883f05, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {0F21F359-AB84-41e8-9A78-36D110E6D2F9}
extern const GUID DECLSPEC_SELECT_ANY GUID_ManagedName = 
{ 0xf21f359, 0xab84, 0x41e8, { 0x9a, 0x78, 0x36, 0xd1, 0x10, 0xe6, 0xd2, 0xf9 } };


// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind  
//  to CLSID_MetaDataDispenser. 
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserRuntime = 
{ 0x1ec2de53, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataRuntime: {005023CA-72B1-11D3-9FC4-00C04F79A0A3}
//  For COM+ 2.0 Meta Data, managed program meta data.  
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime = 
{ 0x005023ca, 0x72b1, 0x11d3, { 0x9f, 0xc4, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {90883F06-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ImportedToComPlus = 
{ 0x90883f06, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
extern const char DECLSPEC_SELECT_ANY szGUID_ImportedToComPlus[] = "{90883F06-3D28-11D2-8F17-00A0C9A6186D}";
extern const WCHAR DECLSPEC_SELECT_ANY wzGUID_ImportedToComPlus[] = L"{90883F06-3D28-11D2-8F17-00A0C9A6186D}";

// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataCheckDuplicatesFor =
{ 0x30fe7be8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRefToDefCheck =
{ 0xde3856f8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataNotificationForTokenMovement = 
{ 0xe5d71a4c, 0xd7da, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataSetUpdate = 
{ 0x2eee315c, 0xd7db, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over 
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
extern const GUID DECLSPEC_SELECT_ANY MetaDataImportOption = 
{ 0x79700f36, 0x4aac, 0x11d3, { 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1 } };


// Use this guid in the SetOption if compiler wants to have MetaData API to take reader/writer lock
// {F7559806-F266-42ea-8C63-0ADB45E8B234}
extern const GUID DECLSPEC_SELECT_ANY MetaDataThreadSafetyOptions = 
{ 0xf7559806, 0xf266, 0x42ea, { 0x8c, 0x63, 0xa, 0xdb, 0x45, 0xe8, 0xb2, 0x34 } };


// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY MetaDataErrorIfEmitOutOfOrder = 
{ 0x1547872d, 0xdc03, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataGenerateTCEAdapters = 
{ 0xdcc9de90, 0x4151, 0x11d3, { 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a } };


// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataTypeLibImportNamespace = 
{ 0xf17ff889, 0x5a63, 0x11d3, { 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


interface IMetaDataImport;
interface IMetaDataAssemblyEmit;
interface IMetaDataAssemblyImport;
interface IMetaDataEmit;
interface ICeeGen;


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************

#ifdef UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst,
                                   DWORD dwReason,  
                                   LPVOID lpReserved,   
                                   LPVOID pDllBase, 
                                   DWORD dwRva14,   
                                   DWORD dwSize14); 

__int32 STDMETHODCALLTYPE _CorExeMain(HINSTANCE hInst,
                                      HINSTANCE hPrevInst,  
                                      LPWSTR lpCmdLine, 
                                      int nCmdShow, 
                                      LPVOID pExeBase,  
                                      DWORD dwRva14,    
                                      DWORD dwSize14);  

#else //!UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine);                  // -> Command Line

STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName);
STDAPI_(VOID) _CorImageUnloading(PVOID ImageBase);

#endif // UNDER_CE
__int32 STDMETHODCALLTYPE _CorClassMain(LPWSTR entryClassName);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  

//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1           // Initialization mode for loading DLL. 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.
#ifndef _WINDOWS_UDPATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI          CoInitializeCor(DWORD fFlags);
STDAPI_(void)   CoUninitializeCor(void);

typedef void (* TDestructorCallback)(EXCEPTION_RECORD*);
STDAPI_(void) AddDestructorCallback(int code, TDestructorCallback callback);


#include <pshpack1.h>

#include <poppack.h>

//
//*****************************************************************************
//*****************************************************************************

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//  This is the "Master Dispenser", always guaranteed to be the most recent
//  dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//  Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//  to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ 1.0 Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {02D601BB-C5B9-11d1-93F9-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x2d601bb, 0xc5b9, 0x11d1, {0x93, 0xf9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef  INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
    STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef  INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
    STDMETHOD(Map)(mdToken tkImp, mdToken tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(DefineScope)(                 // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------

// {671ED8EF-4531-4c0c-8F84-5C618F8DF000}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmit =
{ 0x671ed8ef, 0x4531, 0x4c0c, { 0x8f, 0x84, 0x5c, 0x61, 0x8f, 0x8d, 0xf0, 0x0 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName) PURE;           // [IN] If not NULL, the GUID to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        CLASSVERSION *pVer,                 // [IN] Optional version
        DWORD       dwTypeDefFlags,         // [IN] CustomValue flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(DefineNestedType)(            // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        CLASSVERSION *pVer,                 // [IN] Optional version
        DWORD       dwTypeDefFlags,         // [IN] CustomValue flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.

    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here     

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body - MethodDef or MethodRef
        mdToken     tkDecl) PURE;           // [IN] Method declaration - MethodDef or MethodRef

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(        // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in import scope.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkParent,               // [IN] Classref or classdef in emit scope.    
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout) (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(DeleteClassLayout) (
        mdTypeDef   td) PURE;               // [IN] typedef whose layout is to be deleted.

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DeleteFieldMarshal) (
        mdToken     tk) PURE;               // [IN] given a fieldDef or paramDef token

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetRVA)(                      // S_OK or error.   
        mdMethodDef md,                     // [IN] Method for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // @todo:  This should go away once everyone starts using SetMemberRefProps.
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(SetSymbolBindingPath)(        // S_OK or error.
        REFGUID     FormatID,               // [IN] Symbol data format ID.
        LPCWSTR     szSymbolDataPath) PURE; // [IN] URL for the symbols of this module.

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DeleteToken)(                 // Return code.
        mdToken     tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] Impl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        CLASSVERSION *pVer,                 // [IN] Class version.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]) PURE;  // [IN] Implemented interfaces.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(DeletePinvokeMap)(            // Return code.
        mdToken     tk) PURE;               // [IN] FieldDef or MethodDef.

    // New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomValue (TypeRef/TypeDef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(     // Return code.
        mdCustomValue pcv,                  // [IN] The custom value token whose value to replace.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefineProperty)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdFieldDef  fdBackingField,         // [IN] optional field   
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[],      // [IN] Array of other methods.
        mdFieldDef  fdBackingField) PURE;   // [IN] Backing field.

    STDMETHOD(SetParamProps)(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized CustomAttribute for security.
    STDMETHOD(DefineSecurityAttribute)(     // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdMemberRef tkCtor,                 // [IN] The security attribute constructor.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;     // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(MergeEx)(                     // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEndEx)() PURE;           // S_OK or error.

// Methods placed at end for easier removal from vtable.    
    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pIMap) PURE;           // [IN] An object to receive token remap notices.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.

};      // IMetaDataEmit


//-------------------------------------
//--- IMetaDataImport
//-------------------------------------

// {D7666763-C171-42cc-B947-0EDFA17F3B59}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImport = 
{ 0xd7666763, 0xc171, 0x42cc, { 0xb9, 0x47, 0xe, 0xdf, 0xa1, 0x7f, 0x3b, 0x59 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        CLASSVERSION *pver,                 // [OUT] Put version here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.              

    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // S_OK or error.
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(GetSymbolBindingPath)(        // S_OK or error.
        GUID        *pFormatID,             // [OUT] Symbol data format ID.
        LPWSTR      szSymbolDataPath,       // [OUT] Path of symbols.
        ULONG       cchSymbolDataPath,      // [IN] Max characters for output buffer.
        ULONG       *pcbSymbolDataPath) PURE;// [OUT] Number of chars in actual name.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    // New Custom Value functions.
    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomValue rCustomValues[],      // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomValues.
        ULONG       *pcCustomValues) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomValue cv,                   // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcbDefaultValue,       // [OUT] size of constant value
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod,         // [OUT] total number of other method of this property  
        mdFieldDef  *pmdBackingField) PURE;  // [OUT] backing field 

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcbValue) PURE;        //[OUT] size of constant value

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

};      // IMetaDataImport


//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------

// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataFilter = 
{0xd0e80dd1, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------

// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IHostFilter = 
{0xd0e80dd3, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//-------------------------------------
//--- IMetaDataCFC
//-------------------------------------

// Obsolete Interface ID.  Respond to QI, but assert.

// {BB779E43-0D36-11d3-8C4E-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataCFC = 
{ 0xbb779e43, 0xd36, 0x11d3, { 0x8c, 0x4e, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataCFC
DECLARE_INTERFACE_(IMetaDataCFC, IUnknown)
{
    // obsolete:
    STDMETHOD(GetMethodCode)(               // return hresult   
        mdMethodDef  mb,                    // [IN] Member definition   
        void         **ppBytes,             // [OUT] Pointer to bytes goes here 
        ULONG        *piSize) PURE;         // [IN] Size of code    

    STDMETHOD(GetMaxIndex)( 
        USHORT      *index) PURE;           // [OUT] Put max constantpool index here    

    STDMETHOD(GetTokenFromIndex)(   
        USHORT      index,                  // [IN] Index into ConstantPool 
        mdCPToken   *pcp) PURE;             // [OUT] Put ConstantPool token here    

    STDMETHOD(GetTokenValue)(   
        mdCPToken   cp,                     // [IN] ConstantPool token  
        VARIANT     *pValue) PURE;          // [OUT] Put token value here   
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataConverter = 
{ 0xd9debd79, 0x2992, 0x11d3, { 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;


typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usRevisionNumber;       // Revision Number.
    USHORT      usBuildNumber;          // Build Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
    LPWSTR      szConfiguration;        // Configuration.
    ULONG       cbConfiguration;        // [IN/OUT]Size of the configuration buffer in wide chars/Actual size of configuration.
} ASSEMBLYMETADATA;


// {D9B7F7D6-0976-4360-8A70-9B6685290A40}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyEmit = 
{ 0xd9b7f7d6, 0x0976, 0x4360, { 0x8a, 0x70, 0x9b, 0x66, 0x85, 0x29, 0x0a, 0x40} };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        LPCWSTR     szTitle,                // [IN] Title of the assembly.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szDefaultAlias,         // [IN] Default alias for the Assembly.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags,     // [IN] Token for Execution Location.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineComType)(               // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdComType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags,         // [IN] Flags.
        mdComType   *pmdct) PURE;           // [OUT] Returned ComType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        LPCWSTR     szDescription,          // [IN] Description.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        LPCWSTR     szMIMEType,             // [IN] MIMEType of the resource.
        LPCWSTR     szLocale,               // [IN] Locale of the resource.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(DefineExecutionLocation)(     // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Execution Location.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szLocation,             // [IN] Location.
        DWORD       dwExecutionLocationFlags, // [IN] Flags.
        mdExecutionLocation *pmdel) PURE;   // [OUT] Returned Execution Location token.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetComTypeProps)(             // S_OK or error.
        mdComType   ct,                     // [IN] ComType token.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdComType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        LPCWSTR     szDescription,          // [IN] Description.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        LPCWSTR     szMIMEType,             // [IN] MIMEType of the resource.
        LPCWSTR     szLocale,               // [IN] Locale of the resource.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {b2f161d2-3d07-413d-8752-689dc0744085}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyImport = 
{ 0xb2f161d2, 0x3d07, 0x413d, { 0x87, 0x52, 0x68, 0x9d, 0xc0, 0x74, 0x40, 0x85} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        LPWSTR      szTitle,                // [OUT] Title of the Assembly.
        ULONG       cchTitle,               // [IN] Size of buffer in wide chars.
        ULONG       *pchTitle,              // [OUT] Actual # of wide chars.
        LPWSTR      szDescription,          // [OUT] Description for the Assembly.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Acutal # of wide chars in buffer.
        LPWSTR      szDefaultAlias,         // [OUT] Default alias for the Assembly.
        ULONG       cchDefaultAlias,        // [IN] Size of buffer in wide chars.
        ULONG       *pchDefaultAlias,       // [OUT] Acutal # of wide chars in buffer.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] Token for Execution Location.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetComTypeProps)(             // S_OK or error.
        mdComType   mdct,                   // [IN] The ComType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdComType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] The token for Execution Location.
        DWORD       *pdwComTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        LPWSTR      szMIMEType,             // [OUT] Buffer to fill with MIMEType.
        ULONG       cchMIMEType,            // [IN] Size of buffer in wide chars.
        ULONG       *pchMIMEType,           // [OUT] Actual # of wide chars in name.
        LPWSTR      szLocale,               // [OUT] Buffer to fill with Locale.
        ULONG       cchLocale,              // [IN] Size of buffer in wide chars.
        ULONG       *pchLocale,             // [OUT] Actual # of wide chars in Locale.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(GetExecutionLocationProps)(   // S_OK or error.
        mdExecutionLocation mdel,           // [IN] The Execution Location for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        LPWSTR      szLocation,             // [OUT] Buffer to fill with Location.
        ULONG       cchLocation,            // [IN] Size of buffer in wide chars.
        ULONG       *pchLocation,           // [OUT] Buffer to fill with Location.
        DWORD       *pdwExecutionLocationFlags) PURE;   // [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumComTypes)(                // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdComType   rComTypes[],            // [OUT] Put ComTypes here.
        ULONG       cMax,                   // [IN] Max ComTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExecutionLocations)(      // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExecutionLocation rExecutionLocations[],  // [OUT] Put ExecutionLocations here.
        ULONG       cMax,                   // [IN] Max ExecutionLocations to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindComTypeByName)(           // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ComType.
        mdToken     mdtComType,             // [IN] ComType for the enclosing class.
        mdComType   *ptkComType) PURE;      // [OUT] Put the ComType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport

//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataValidate = 
{ 0x4709c9c6, 0x81ff, 0x11d3, { 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenserEx =
{ 0x31bcfce2, 0xdafb, 0x11d2, { 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory COM+ files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,
    // generate a .reloc for the top 16-bits of a 32 bit number
    srRelocHigh,
    // generate a .reloc for the bottom 16-bits of a 32 bit number
    srRelocLow,
    // generate a .reloc for a 32 bit number
    srRelocHighLow,
    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,
    // legal enums which include the Ptr flag
    srRelocAbsolutePtr = srRelocAbsolute + srRelocPtr,
    srRelocHighLowPtr = srRelocHighLow + srRelocPtr,
    srRelocRelativePtr = srRelocRelative + srRelocPtr,


/*
    // these are for compatibility and should not be used by new code

    // address should be added to the .reloc section
    srRelocNone = srRelocHighLow,
    // address should be not go into .reloc section
    srRelocRVA = srRelocAbsolute
*/
} CeeSectionRelocType;

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICeeGen = 
{ 0x7ed1bdff, 0x8e36, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
        LPWSTR lpString,                    // [IN] String to emit  
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
        LPWSTR *lpString) PURE;             // [OUT] Returned string    

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorModule = 
{ 0x2629f8e1, 0x95e5, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (    
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with  
    
    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator  

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// {CE43C120-E856-11d2-8C21-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataTables = 
{ 0xce43c120, 0xe856, 0x11d2, { 0x8c, 0x21, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

};
//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
//**********************************************************************

//**********************************************************************
//
// Predefined CustomValue and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone     = 1,    // none of the keywords are specified   
    nltAnsi     = 2,    // ansi keyword specified   
    nltUnicode  = 3,    // unicode keyword specified    
    nltAuto     = 4,    // auto keyword specified   
    nltOle      = 5,    // ole keyword specified    
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if defined( UNDER_CE ) || _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF || elementtype == ELEMENT_TYPE_COPYCTOR)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
//@future: BIGENDIAN work here.
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;  

    // 1 byte data is handled in CorSigUncompressData   
//  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = 0;    
        ((BYTE *) &res)[1] = *pData++ & 0x3f;   
        ((BYTE *) &res)[0] = *pData++;  
    }   
    else // 110? ???? @todo: Should this be 11?? ????   
    {   
        ((BYTE *) &res)[3] = *pData++ & 0x1f;   
        ((BYTE *) &res)[2] = *pData++;  
        ((BYTE *) &res)[1] = *pData++;  
        ((BYTE *) &res)[0] = *pData++;  
    }   
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}
//@todo: remove this
inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   
    ULONG       cb = -1;    
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        *pDataOut = *pBytes;    
        cb = 1; 
    }   
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        *pDataOut = ((*pBytes & 0x3f) << 8 | *(pBytes+1));  
        cb = 2; 
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        *pDataOut = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));  
        cb = 4; 
    }   
    return cb;  

}

const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}

//@todo: remove
inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == -1) return cb;    
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}
//@todo: remove
inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen);  
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE(iLen >> 16);  
        *(pBytes+2) = BYTE(iLen >> 8);  
        *(pBytes+3) = BYTE(iLen);  
        return 4;   
    }   
    return -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return -1;  
    }   
    iData = iData << 1 | isSigned;  
    return CorSigCompressData(iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\eeinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for EEInfo.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#include "midles.h"

#ifndef __EEInfo_h__
#define __EEInfo_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ExtendedError_INTERFACE_DEFINED__
#define __ExtendedError_INTERFACE_DEFINED__

/* interface ExtendedError */
/* [explicit_handle][unique][version][uuid] */ 

typedef struct tagEEAString
    {
    short nLength;
    /* [size_is] */ byte *pString;
    } 	EEAString;

typedef struct tagEEUString
    {
    short nLength;
    /* [size_is] */ unsigned short *pString;
    } 	EEUString;

typedef struct tagBinaryEEInfo
    {
    short nSize;
    /* [size_is] */ unsigned char *pBlob;
    } 	BinaryEEInfo;

typedef 
enum tagExtendedErrorParamTypesInternal
    {	eeptiAnsiString	= 1,
	eeptiUnicodeString	= eeptiAnsiString + 1,
	eeptiLongVal	= eeptiUnicodeString + 1,
	eeptiShortVal	= eeptiLongVal + 1,
	eeptiPointerVal	= eeptiShortVal + 1,
	eeptiNone	= eeptiPointerVal + 1,
	eeptiBinary	= eeptiNone + 1
    } 	ExtendedErrorParamTypesInternal;

typedef struct tagParam
    {
    ExtendedErrorParamTypesInternal Type;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ EEAString AnsiString;
        /* [case()] */ EEUString UnicodeString;
        /* [case()] */ long LVal;
        /* [case()] */ short IVal;
        /* [case()] */ __int64 PVal;
        /* [case()] */  /* Empty union arm */ 
        /* [case()] */ BinaryEEInfo Blob;
        } 	;
    } 	ExtendedErrorParam;

typedef 
enum tagEEComputerNamePresent
    {	eecnpPresent	= 1,
	eecnpNotPresent	= eecnpPresent + 1
    } 	EEComputerNamePresent;

typedef struct tagEEComputerName
    {
    EEComputerNamePresent Type;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ EEUString Name;
        /* [case()] */  /* Empty union arm */ 
        } 	;
    } 	EEComputerName;

typedef struct tagExtendedErrorInfo
    {
    struct tagExtendedErrorInfo *Next;
    EEComputerName ComputerName;
    unsigned long ProcessID;
    __int64 TimeStamp;
    unsigned long GeneratingComponent;
    unsigned long Status;
    unsigned short DetectionLocation;
    unsigned short Flags;
    short nLen;
    /* [size_is] */ ExtendedErrorParam Params[ 1 ];
    } 	ExtendedErrorInfo;

typedef /* [decode][encode] */ ExtendedErrorInfo *ExtendedErrorInfoPtr;



extern RPC_IF_HANDLE ExtendedError_ClientIfHandle;
extern RPC_IF_HANDLE ExtendedError_ServerIfHandle;
#endif /* __ExtendedError_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */


size_t
ExtendedErrorInfoPtr_AlignSize(
    handle_t _MidlEsHandle,
    ExtendedErrorInfoPtr * _pType);


void
ExtendedErrorInfoPtr_Encode(
    handle_t _MidlEsHandle,
    ExtendedErrorInfoPtr * _pType);


void
ExtendedErrorInfoPtr_Decode(
    handle_t _MidlEsHandle,
    ExtendedErrorInfoPtr * _pType);


void
ExtendedErrorInfoPtr_Free(
    handle_t _MidlEsHandle,
    ExtendedErrorInfoPtr * _pType);

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\catalog.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for catalog.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __catalog_h__
#define __catalog_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IComCatalog_FWD_DEFINED__
#define __IComCatalog_FWD_DEFINED__
typedef interface IComCatalog IComCatalog;
#endif 	/* __IComCatalog_FWD_DEFINED__ */


#ifndef __IComCatalog2_FWD_DEFINED__
#define __IComCatalog2_FWD_DEFINED__
typedef interface IComCatalog2 IComCatalog2;
#endif 	/* __IComCatalog2_FWD_DEFINED__ */


#ifndef __IComCatalogSCM_FWD_DEFINED__
#define __IComCatalogSCM_FWD_DEFINED__
typedef interface IComCatalogSCM IComCatalogSCM;
#endif 	/* __IComCatalogSCM_FWD_DEFINED__ */


#ifndef __IComClassInfo_FWD_DEFINED__
#define __IComClassInfo_FWD_DEFINED__
typedef interface IComClassInfo IComClassInfo;
#endif 	/* __IComClassInfo_FWD_DEFINED__ */


#ifndef __IComClassInfo2_FWD_DEFINED__
#define __IComClassInfo2_FWD_DEFINED__
typedef interface IComClassInfo2 IComClassInfo2;
#endif 	/* __IComClassInfo2_FWD_DEFINED__ */


#ifndef __IClassClassicInfo_FWD_DEFINED__
#define __IClassClassicInfo_FWD_DEFINED__
typedef interface IClassClassicInfo IClassClassicInfo;
#endif 	/* __IClassClassicInfo_FWD_DEFINED__ */


#ifndef __IClassClassicInfo2_FWD_DEFINED__
#define __IClassClassicInfo2_FWD_DEFINED__
typedef interface IClassClassicInfo2 IClassClassicInfo2;
#endif 	/* __IClassClassicInfo2_FWD_DEFINED__ */


#ifndef __IComServices_FWD_DEFINED__
#define __IComServices_FWD_DEFINED__
typedef interface IComServices IComServices;
#endif 	/* __IComServices_FWD_DEFINED__ */


#ifndef __IComServices2_FWD_DEFINED__
#define __IComServices2_FWD_DEFINED__
typedef interface IComServices2 IComServices2;
#endif 	/* __IComServices2_FWD_DEFINED__ */


#ifndef __IComProcessInfo_FWD_DEFINED__
#define __IComProcessInfo_FWD_DEFINED__
typedef interface IComProcessInfo IComProcessInfo;
#endif 	/* __IComProcessInfo_FWD_DEFINED__ */


#ifndef __IComProcessInfo2_FWD_DEFINED__
#define __IComProcessInfo2_FWD_DEFINED__
typedef interface IComProcessInfo2 IComProcessInfo2;
#endif 	/* __IComProcessInfo2_FWD_DEFINED__ */


#ifndef __IResourceGates_FWD_DEFINED__
#define __IResourceGates_FWD_DEFINED__
typedef interface IResourceGates IResourceGates;
#endif 	/* __IResourceGates_FWD_DEFINED__ */


#ifndef __IProcessServerInfo_FWD_DEFINED__
#define __IProcessServerInfo_FWD_DEFINED__
typedef interface IProcessServerInfo IProcessServerInfo;
#endif 	/* __IProcessServerInfo_FWD_DEFINED__ */


#ifndef __IInterfaceInfo_FWD_DEFINED__
#define __IInterfaceInfo_FWD_DEFINED__
typedef interface IInterfaceInfo IInterfaceInfo;
#endif 	/* __IInterfaceInfo_FWD_DEFINED__ */


#ifndef __IComCatalogSettings_FWD_DEFINED__
#define __IComCatalogSettings_FWD_DEFINED__
typedef interface IComCatalogSettings IComCatalogSettings;
#endif 	/* __IComCatalogSettings_FWD_DEFINED__ */


/* header files for imported files */
#include "activate.h"
#include "partitions.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IComCatalog_INTERFACE_DEFINED__
#define __IComCatalog_INTERFACE_DEFINED__

/* interface IComCatalog */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E0-0000-0000-C000-000000000046")
    IComCatalog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalog * This,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalog * This,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalog * This,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalog * This,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IComCatalogVtbl;

    interface IComCatalog
    {
        CONST_VTBL struct IComCatalogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog_GetClassInfo(This,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,guidConfiguredClsid,riid,ppv)

#define IComCatalog_GetApplicationInfo(This,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfo(This,guidApplId,riid,ppv)

#define IComCatalog_GetProcessInfo(This,guidProcess,riid,ppv)	\
    (This)->lpVtbl -> GetProcessInfo(This,guidProcess,riid,ppv)

#define IComCatalog_GetServerGroupInfo(This,guidServerGroup,riid,ppv)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,guidServerGroup,riid,ppv)

#define IComCatalog_GetRetQueueInfo(This,wszFormatName,riid,ppv)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,wszFormatName,riid,ppv)

#define IComCatalog_GetApplicationInfoForExe(This,pwszExeName,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pwszExeName,riid,ppv)

#define IComCatalog_GetTypeLibrary(This,guidTypeLib,riid,ppv)	\
    (This)->lpVtbl -> GetTypeLibrary(This,guidTypeLib,riid,ppv)

#define IComCatalog_GetInterfaceInfo(This,iidInterface,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,iidInterface,riid,ppv)

#define IComCatalog_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalog_GetClassInfoFromProgId(This,pwszProgID,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pwszProgID,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog_GetClassInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetApplicationInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetProcessInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetServerGroupInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetRetQueueInfo_Proxy( 
    IComCatalog * This,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetApplicationInfoForExe_Proxy( 
    IComCatalog * This,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetTypeLibrary_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetInterfaceInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_FlushCache_Proxy( 
    IComCatalog * This);


void __RPC_STUB IComCatalog_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetClassInfoFromProgId_Proxy( 
    IComCatalog * This,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog_INTERFACE_DEFINED__ */


#ifndef __IComCatalog2_INTERFACE_DEFINED__
#define __IComCatalog2_INTERFACE_DEFINED__

/* interface IComCatalog2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FA-0000-0000-C000-000000000046")
    IComCatalog2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByPartition( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByApplication( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeRegistryCatalog( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNonNativeRegistryCatalog( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByPartition )( 
            IComCatalog2 * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByApplication )( 
            IComCatalog2 * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeRegistryCatalog )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetNonNativeRegistryCatalog )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IComCatalog2Vtbl;

    interface IComCatalog2
    {
        CONST_VTBL struct IComCatalog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog2_GetClassInfoByPartition(This,guidConfiguredClsid,guidPartitionId,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoByPartition(This,guidConfiguredClsid,guidPartitionId,riid,ppv)

#define IComCatalog2_GetClassInfoByApplication(This,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoByApplication(This,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv)

#define IComCatalog2_GetNativeRegistryCatalog(This,riid,ppv)	\
    (This)->lpVtbl -> GetNativeRegistryCatalog(This,riid,ppv)

#define IComCatalog2_GetNonNativeRegistryCatalog(This,riid,ppv)	\
    (This)->lpVtbl -> GetNonNativeRegistryCatalog(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog2_GetClassInfoByPartition_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetClassInfoByPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetClassInfoByApplication_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetClassInfoByApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetNativeRegistryCatalog_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetNativeRegistryCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetNonNativeRegistryCatalog_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetNonNativeRegistryCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0142 */
/* [local] */ 

/* These constants are used in the SCM catalog interfaces */
#define CAT_REG64_ONLY  (0x10000000)
#define CAT_REG32_ONLY  (0x20000000)
#define CAT_REG_MASK    (0x30000000)


extern RPC_IF_HANDLE __MIDL_itf_catalog_0142_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0142_ServerIfHandle;

#ifndef __IComCatalogSCM_INTERFACE_DEFINED__
#define __IComCatalogSCM_INTERFACE_DEFINED__

/* interface IComCatalogSCM */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogSCM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FD-0000-0000-C000-000000000046")
    IComCatalogSCM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushIdleEntries( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogSCMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogSCM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogSCM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogSCM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalogSCM * This,
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalogSCM * This,
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalogSCM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushIdleEntries )( 
            IComCatalogSCM * This);
        
        END_INTERFACE
    } IComCatalogSCMVtbl;

    interface IComCatalogSCM
    {
        CONST_VTBL struct IComCatalogSCMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogSCM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogSCM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogSCM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogSCM_GetClassInfo(This,flags,pToken,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,flags,pToken,guidConfiguredClsid,riid,ppv)

#define IComCatalogSCM_GetApplicationInfo(This,pToken,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfo(This,pToken,guidApplId,riid,ppv)

#define IComCatalogSCM_GetProcessInfo(This,flags,pToken,guidProcess,riid,ppv)	\
    (This)->lpVtbl -> GetProcessInfo(This,flags,pToken,guidProcess,riid,ppv)

#define IComCatalogSCM_GetServerGroupInfo(This,pToken,guidServerGroup,riid,ppv)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,pToken,guidServerGroup,riid,ppv)

#define IComCatalogSCM_GetRetQueueInfo(This,pToken,wszFormatName,riid,ppv)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,pToken,wszFormatName,riid,ppv)

#define IComCatalogSCM_GetApplicationInfoForExe(This,pToken,pwszExeName,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pToken,pwszExeName,riid,ppv)

#define IComCatalogSCM_GetTypeLibrary(This,pToken,guidTypeLib,riid,ppv)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pToken,guidTypeLib,riid,ppv)

#define IComCatalogSCM_GetInterfaceInfo(This,pToken,iidInterface,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,pToken,iidInterface,riid,ppv)

#define IComCatalogSCM_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalogSCM_GetClassInfoFromProgId(This,pToken,pwszProgID,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pToken,pwszProgID,riid,ppv)

#define IComCatalogSCM_FlushIdleEntries(This)	\
    (This)->lpVtbl -> FlushIdleEntries(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetClassInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ DWORD flags,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetApplicationInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetProcessInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ DWORD flags,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetServerGroupInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetRetQueueInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetApplicationInfoForExe_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetTypeLibrary_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetInterfaceInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_FlushCache_Proxy( 
    IComCatalogSCM * This);


void __RPC_STUB IComCatalogSCM_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetClassInfoFromProgId_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_FlushIdleEntries_Proxy( 
    IComCatalogSCM * This);


void __RPC_STUB IComCatalogSCM_FlushIdleEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogSCM_INTERFACE_DEFINED__ */


#ifndef __IComClassInfo_INTERFACE_DEFINED__
#define __IComClassInfo_INTERFACE_DEFINED__

/* interface IComClassInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E1-0000-0000-C000-000000000046")
    IComClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConfiguredClsid( 
            /* [out] */ GUID **ppguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgId( 
            /* [out] */ WCHAR **pwszProgid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out] */ WCHAR **pwszClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassContext( 
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivatorCount( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivatorClsids( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivators( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsComPlusConfiguredClass( 
            /* [out] */ BOOL *pfComPlusConfiguredClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MustRunInClientContext( 
            /* [out] */ BOOL *pbMustRunInClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguredClsid )( 
            IComClassInfo * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgId )( 
            IComClassInfo * This,
            /* [out] */ WCHAR **pwszProgid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IComClassInfo * This,
            /* [out] */ WCHAR **pwszClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassContext )( 
            IComClassInfo * This,
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorCount )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorClsids )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivators )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *IsComPlusConfiguredClass )( 
            IComClassInfo * This,
            /* [out] */ BOOL *pfComPlusConfiguredClass);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInClientContext )( 
            IComClassInfo * This,
            /* [out] */ BOOL *pbMustRunInClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IComClassInfo * This,
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IComClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IComClassInfo * This);
        
        END_INTERFACE
    } IComClassInfoVtbl;

    interface IComClassInfo
    {
        CONST_VTBL struct IComClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComClassInfo_GetConfiguredClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetConfiguredClsid(This,ppguidClsid)

#define IComClassInfo_GetProgId(This,pwszProgid)	\
    (This)->lpVtbl -> GetProgId(This,pwszProgid)

#define IComClassInfo_GetClassName(This,pwszClassName)	\
    (This)->lpVtbl -> GetClassName(This,pwszClassName)

#define IComClassInfo_GetApplication(This,riid,ppv)	\
    (This)->lpVtbl -> GetApplication(This,riid,ppv)

#define IComClassInfo_GetClassContext(This,clsctxFilter,pclsctx)	\
    (This)->lpVtbl -> GetClassContext(This,clsctxFilter,pclsctx)

#define IComClassInfo_GetCustomActivatorCount(This,activationStage,pulCount)	\
    (This)->lpVtbl -> GetCustomActivatorCount(This,activationStage,pulCount)

#define IComClassInfo_GetCustomActivatorClsids(This,activationStage,prgguidClsid)	\
    (This)->lpVtbl -> GetCustomActivatorClsids(This,activationStage,prgguidClsid)

#define IComClassInfo_GetCustomActivators(This,activationStage,prgpActivator)	\
    (This)->lpVtbl -> GetCustomActivators(This,activationStage,prgpActivator)

#define IComClassInfo_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#define IComClassInfo_IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)	\
    (This)->lpVtbl -> IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)

#define IComClassInfo_MustRunInClientContext(This,pbMustRunInClientContext)	\
    (This)->lpVtbl -> MustRunInClientContext(This,pbMustRunInClientContext)

#define IComClassInfo_GetVersionNumber(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersionNumber(This,pdwVersionMS,pdwVersionLS)

#define IComClassInfo_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IComClassInfo_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComClassInfo_GetConfiguredClsid_Proxy( 
    IComClassInfo * This,
    /* [out] */ GUID **ppguidClsid);


void __RPC_STUB IComClassInfo_GetConfiguredClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetProgId_Proxy( 
    IComClassInfo * This,
    /* [out] */ WCHAR **pwszProgid);


void __RPC_STUB IComClassInfo_GetProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetClassName_Proxy( 
    IComClassInfo * This,
    /* [out] */ WCHAR **pwszClassName);


void __RPC_STUB IComClassInfo_GetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetApplication_Proxy( 
    IComClassInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComClassInfo_GetApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetClassContext_Proxy( 
    IComClassInfo * This,
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX *pclsctx);


void __RPC_STUB IComClassInfo_GetClassContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivatorCount_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long *pulCount);


void __RPC_STUB IComClassInfo_GetCustomActivatorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivatorClsids_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID **prgguidClsid);


void __RPC_STUB IComClassInfo_GetCustomActivatorClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivators_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator ***prgpActivator);


void __RPC_STUB IComClassInfo_GetCustomActivators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetTypeInfo_Proxy( 
    IComClassInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComClassInfo_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_IsComPlusConfiguredClass_Proxy( 
    IComClassInfo * This,
    /* [out] */ BOOL *pfComPlusConfiguredClass);


void __RPC_STUB IComClassInfo_IsComPlusConfiguredClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_MustRunInClientContext_Proxy( 
    IComClassInfo * This,
    /* [out] */ BOOL *pbMustRunInClientContext);


void __RPC_STUB IComClassInfo_MustRunInClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetVersionNumber_Proxy( 
    IComClassInfo * This,
    /* [out] */ DWORD *pdwVersionMS,
    /* [out] */ DWORD *pdwVersionLS);


void __RPC_STUB IComClassInfo_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_Lock_Proxy( 
    IComClassInfo * This);


void __RPC_STUB IComClassInfo_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_Unlock_Proxy( 
    IComClassInfo * This);


void __RPC_STUB IComClassInfo_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComClassInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0144 */
/* [local] */ 

typedef struct tagSOAP_ACTIVATION_INFO
    {
    BOOL bSoapActivated;
    LONG lMode;
    BSTR bstrVRoot;
    BSTR bstrMailTo;
    BSTR bstrAssemblyName;
    BSTR bstrTypeName;
    BSTR bstrBaseUrl;
    } 	SOAP_ACTIVATION_INFO;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0144_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0144_ServerIfHandle;

#ifndef __IComClassInfo2_INTERFACE_DEFINED__
#define __IComClassInfo2_INTERFACE_DEFINED__

/* interface IComClassInfo2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComClassInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E4-0000-0000-C000-000000000046")
    IComClassInfo2 : public IComClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [out] */ BOOL *bEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalClsid( 
            /* [out] */ GUID **ppguidInternalClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationPartitionId( 
            /* [out] */ GUID **ppguidAppPartitionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MustRunInDefaultContext( 
            /* [out] */ BOOL *pbMustRunInDefaultContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPrivateComponent( 
            /* [out] */ BOOL *pbIsPrivateComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VBDebugInProgress( 
            /* [out] */ BOOL *pbVBDebugInProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoapInfo( 
            /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabledRemote( 
            /* [out] */ BOOL *bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComClassInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComClassInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguredClsid )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgId )( 
            IComClassInfo2 * This,
            /* [out] */ WCHAR **pwszProgid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IComClassInfo2 * This,
            /* [out] */ WCHAR **pwszClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassContext )( 
            IComClassInfo2 * This,
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorCount )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorClsids )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivators )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *IsComPlusConfiguredClass )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pfComPlusConfiguredClass);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInClientContext )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbMustRunInClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IComClassInfo2 * This,
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *bEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetInternalClsid )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidInternalClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationPartitionId )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidAppPartitionId);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInDefaultContext )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbMustRunInDefaultContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsPrivateComponent )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbIsPrivateComponent);
        
        HRESULT ( STDMETHODCALLTYPE *VBDebugInProgress )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbVBDebugInProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoapInfo )( 
            IComClassInfo2 * This,
            /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabledRemote )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *bEnabled);
        
        END_INTERFACE
    } IComClassInfo2Vtbl;

    interface IComClassInfo2
    {
        CONST_VTBL struct IComClassInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComClassInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComClassInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComClassInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComClassInfo2_GetConfiguredClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetConfiguredClsid(This,ppguidClsid)

#define IComClassInfo2_GetProgId(This,pwszProgid)	\
    (This)->lpVtbl -> GetProgId(This,pwszProgid)

#define IComClassInfo2_GetClassName(This,pwszClassName)	\
    (This)->lpVtbl -> GetClassName(This,pwszClassName)

#define IComClassInfo2_GetApplication(This,riid,ppv)	\
    (This)->lpVtbl -> GetApplication(This,riid,ppv)

#define IComClassInfo2_GetClassContext(This,clsctxFilter,pclsctx)	\
    (This)->lpVtbl -> GetClassContext(This,clsctxFilter,pclsctx)

#define IComClassInfo2_GetCustomActivatorCount(This,activationStage,pulCount)	\
    (This)->lpVtbl -> GetCustomActivatorCount(This,activationStage,pulCount)

#define IComClassInfo2_GetCustomActivatorClsids(This,activationStage,prgguidClsid)	\
    (This)->lpVtbl -> GetCustomActivatorClsids(This,activationStage,prgguidClsid)

#define IComClassInfo2_GetCustomActivators(This,activationStage,prgpActivator)	\
    (This)->lpVtbl -> GetCustomActivators(This,activationStage,prgpActivator)

#define IComClassInfo2_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#define IComClassInfo2_IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)	\
    (This)->lpVtbl -> IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)

#define IComClassInfo2_MustRunInClientContext(This,pbMustRunInClientContext)	\
    (This)->lpVtbl -> MustRunInClientContext(This,pbMustRunInClientContext)

#define IComClassInfo2_GetVersionNumber(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersionNumber(This,pdwVersionMS,pdwVersionLS)

#define IComClassInfo2_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IComClassInfo2_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)


#define IComClassInfo2_IsEnabled(This,bEnabled)	\
    (This)->lpVtbl -> IsEnabled(This,bEnabled)

#define IComClassInfo2_GetInternalClsid(This,ppguidInternalClsid)	\
    (This)->lpVtbl -> GetInternalClsid(This,ppguidInternalClsid)

#define IComClassInfo2_GetApplicationPartitionId(This,ppguidAppPartitionId)	\
    (This)->lpVtbl -> GetApplicationPartitionId(This,ppguidAppPartitionId)

#define IComClassInfo2_MustRunInDefaultContext(This,pbMustRunInDefaultContext)	\
    (This)->lpVtbl -> MustRunInDefaultContext(This,pbMustRunInDefaultContext)

#define IComClassInfo2_IsPrivateComponent(This,pbIsPrivateComponent)	\
    (This)->lpVtbl -> IsPrivateComponent(This,pbIsPrivateComponent)

#define IComClassInfo2_VBDebugInProgress(This,pbVBDebugInProgress)	\
    (This)->lpVtbl -> VBDebugInProgress(This,pbVBDebugInProgress)

#define IComClassInfo2_GetSoapInfo(This,psoapActInfo)	\
    (This)->lpVtbl -> GetSoapInfo(This,psoapActInfo)

#define IComClassInfo2_IsEnabledRemote(This,bEnabled)	\
    (This)->lpVtbl -> IsEnabledRemote(This,bEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComClassInfo2_IsEnabled_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *bEnabled);


void __RPC_STUB IComClassInfo2_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetInternalClsid_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ GUID **ppguidInternalClsid);


void __RPC_STUB IComClassInfo2_GetInternalClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetApplicationPartitionId_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ GUID **ppguidAppPartitionId);


void __RPC_STUB IComClassInfo2_GetApplicationPartitionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_MustRunInDefaultContext_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbMustRunInDefaultContext);


void __RPC_STUB IComClassInfo2_MustRunInDefaultContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_IsPrivateComponent_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbIsPrivateComponent);


void __RPC_STUB IComClassInfo2_IsPrivateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_VBDebugInProgress_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbVBDebugInProgress);


void __RPC_STUB IComClassInfo2_VBDebugInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetSoapInfo_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo);


void __RPC_STUB IComClassInfo2_GetSoapInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_IsEnabledRemote_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *bEnabled);


void __RPC_STUB IComClassInfo2_IsEnabledRemote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComClassInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0145 */
/* [local] */ 

typedef 
enum tagThreadingModel
    {	ApartmentThreaded	= 0,
	FreeThreaded	= ApartmentThreaded + 1,
	SingleThreaded	= FreeThreaded + 1,
	BothThreaded	= SingleThreaded + 1,
	NeutralThreaded	= BothThreaded + 1
    } 	ThreadingModel;

typedef 
enum tagLocalServerType
    {	LocalServerType16	= 0,
	LocalServerType32	= LocalServerType16 + 1
    } 	LocalServerType;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0145_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0145_ServerIfHandle;

#ifndef __IClassClassicInfo_INTERFACE_DEFINED__
#define __IClassClassicInfo_INTERFACE_DEFINED__

/* interface IClassClassicInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IClassClassicInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E2-0000-0000-C000-000000000046")
    IClassClassicInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThreadingModel( 
            /* [out] */ ThreadingModel *pthreadmodel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulePath( 
            /* [in] */ CLSCTX clsctx,
            /* [string][out] */ WCHAR **pwszDllName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImplementedClsid( 
            /* [out] */ GUID **ppguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [out] */ WCHAR **pwszServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalServerType( 
            /* [out] */ LocalServerType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurrogateCommandLine( 
            /* [out] */ WCHAR **pwszSurrogateCommandLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassClassicInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassClassicInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassClassicInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassClassicInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadingModel )( 
            IClassClassicInfo * This,
            /* [out] */ ThreadingModel *pthreadmodel);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulePath )( 
            IClassClassicInfo * This,
            /* [in] */ CLSCTX clsctx,
            /* [string][out] */ WCHAR **pwszDllName);
        
        HRESULT ( STDMETHODCALLTYPE *GetImplementedClsid )( 
            IClassClassicInfo * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IClassClassicInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IClassClassicInfo * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalServerType )( 
            IClassClassicInfo * This,
            /* [out] */ LocalServerType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogateCommandLine )( 
            IClassClassicInfo * This,
            /* [out] */ WCHAR **pwszSurrogateCommandLine);
        
        END_INTERFACE
    } IClassClassicInfoVtbl;

    interface IClassClassicInfo
    {
        CONST_VTBL struct IClassClassicInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassClassicInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassClassicInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassClassicInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassClassicInfo_GetThreadingModel(This,pthreadmodel)	\
    (This)->lpVtbl -> GetThreadingModel(This,pthreadmodel)

#define IClassClassicInfo_GetModulePath(This,clsctx,pwszDllName)	\
    (This)->lpVtbl -> GetModulePath(This,clsctx,pwszDllName)

#define IClassClassicInfo_GetImplementedClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetImplementedClsid(This,ppguidClsid)

#define IClassClassicInfo_GetProcess(This,riid,ppv)	\
    (This)->lpVtbl -> GetProcess(This,riid,ppv)

#define IClassClassicInfo_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IClassClassicInfo_GetLocalServerType(This,pType)	\
    (This)->lpVtbl -> GetLocalServerType(This,pType)

#define IClassClassicInfo_GetSurrogateCommandLine(This,pwszSurrogateCommandLine)	\
    (This)->lpVtbl -> GetSurrogateCommandLine(This,pwszSurrogateCommandLine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetThreadingModel_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ ThreadingModel *pthreadmodel);


void __RPC_STUB IClassClassicInfo_GetThreadingModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetModulePath_Proxy( 
    IClassClassicInfo * This,
    /* [in] */ CLSCTX clsctx,
    /* [string][out] */ WCHAR **pwszDllName);


void __RPC_STUB IClassClassicInfo_GetModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetImplementedClsid_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ GUID **ppguidClsid);


void __RPC_STUB IClassClassicInfo_GetImplementedClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetProcess_Proxy( 
    IClassClassicInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IClassClassicInfo_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetRemoteServerName_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ WCHAR **pwszServerName);


void __RPC_STUB IClassClassicInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetLocalServerType_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ LocalServerType *pType);


void __RPC_STUB IClassClassicInfo_GetLocalServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetSurrogateCommandLine_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ WCHAR **pwszSurrogateCommandLine);


void __RPC_STUB IClassClassicInfo_GetSurrogateCommandLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassClassicInfo_INTERFACE_DEFINED__ */


#ifndef __IClassClassicInfo2_INTERFACE_DEFINED__
#define __IClassClassicInfo2_INTERFACE_DEFINED__

/* interface IClassClassicInfo2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IClassClassicInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001df-0000-0000-C000-000000000046")
    IClassClassicInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServerExecutable( 
            /* [out] */ WCHAR **pwszServerExecutable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassClassicInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassClassicInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassClassicInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassClassicInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerExecutable )( 
            IClassClassicInfo2 * This,
            /* [out] */ WCHAR **pwszServerExecutable);
        
        END_INTERFACE
    } IClassClassicInfo2Vtbl;

    interface IClassClassicInfo2
    {
        CONST_VTBL struct IClassClassicInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassClassicInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassClassicInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassClassicInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassClassicInfo2_GetServerExecutable(This,pwszServerExecutable)	\
    (This)->lpVtbl -> GetServerExecutable(This,pwszServerExecutable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassClassicInfo2_GetServerExecutable_Proxy( 
    IClassClassicInfo2 * This,
    /* [out] */ WCHAR **pwszServerExecutable);


void __RPC_STUB IClassClassicInfo2_GetServerExecutable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassClassicInfo2_INTERFACE_DEFINED__ */


#ifndef __IComServices_INTERFACE_DEFINED__
#define __IComServices_INTERFACE_DEFINED__

/* interface IComServices */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F5-0000-0000-C000-000000000046")
    IComServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServicesCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServicesClsids( 
            /* [out] */ GUID **pprgguidClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetServicesCount )( 
            IComServices * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetServicesClsids )( 
            IComServices * This,
            /* [out] */ GUID **pprgguidClsid);
        
        END_INTERFACE
    } IComServicesVtbl;

    interface IComServices
    {
        CONST_VTBL struct IComServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComServices_GetServicesCount(This,pulCount)	\
    (This)->lpVtbl -> GetServicesCount(This,pulCount)

#define IComServices_GetServicesClsids(This,pprgguidClsid)	\
    (This)->lpVtbl -> GetServicesClsids(This,pprgguidClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComServices_GetServicesCount_Proxy( 
    IComServices * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IComServices_GetServicesCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComServices_GetServicesClsids_Proxy( 
    IComServices * This,
    /* [out] */ GUID **pprgguidClsid);


void __RPC_STUB IComServices_GetServicesClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComServices_INTERFACE_DEFINED__ */


#ifndef __IComServices2_INTERFACE_DEFINED__
#define __IComServices2_INTERFACE_DEFINED__

/* interface IComServices2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComServices2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61a7d610-42eb-43d2-a55f-1904d3294daa")
    IComServices2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInitializerCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInitializerClsids( 
            /* [out] */ GUID **pprgguidClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComServices2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComServices2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComServices2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComServices2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitializerCount )( 
            IComServices2 * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitializerClsids )( 
            IComServices2 * This,
            /* [out] */ GUID **pprgguidClsid);
        
        END_INTERFACE
    } IComServices2Vtbl;

    interface IComServices2
    {
        CONST_VTBL struct IComServices2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComServices2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComServices2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComServices2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComServices2_GetInitializerCount(This,pulCount)	\
    (This)->lpVtbl -> GetInitializerCount(This,pulCount)

#define IComServices2_GetInitializerClsids(This,pprgguidClsid)	\
    (This)->lpVtbl -> GetInitializerClsids(This,pprgguidClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComServices2_GetInitializerCount_Proxy( 
    IComServices2 * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IComServices2_GetInitializerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComServices2_GetInitializerClsids_Proxy( 
    IComServices2 * This,
    /* [out] */ GUID **pprgguidClsid);


void __RPC_STUB IComServices2_GetInitializerClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComServices2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0149 */
/* [local] */ 

typedef 
enum tagProcessType
    {	ProcessTypeNormal	= 0,
	ProcessTypeService	= ProcessTypeNormal + 1,
	ProcessTypeComPlus	= ProcessTypeService + 1,
	ProcessTypeLegacySurrogate	= ProcessTypeComPlus + 1,
	ProcessTypeComPlusService	= ProcessTypeLegacySurrogate + 1
    } 	ProcessType;

typedef 
enum tagRunAsType
    {	RunAsSpecifiedUser	= 0,
	RunAsInteractiveUser	= RunAsSpecifiedUser + 1,
	RunAsLaunchingUser	= RunAsInteractiveUser + 1
    } 	RunAsType;


enum DCOM_ENDPOINT_FLAGS
    {	fUseInternetPorts	= 0x1
    } ;
typedef struct tagDCOM_ENDPOINT
    {
    WCHAR *wszProtSeq;
    WCHAR *wszPorts;
    DWORD dwFlags;
    } 	DCOM_ENDPOINT;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0149_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0149_ServerIfHandle;

#ifndef __IComProcessInfo_INTERFACE_DEFINED__
#define __IComProcessInfo_INTERFACE_DEFINED__

/* interface IComProcessInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComProcessInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001ED-0000-0000-C000-000000000046")
    IComProcessInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcessId( 
            /* [out] */ GUID **ppguidProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessName( 
            /* [out] */ WCHAR **pwszProcessName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessType( 
            /* [out] */ ProcessType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurrogatePath( 
            /* [out] */ WCHAR **pwszSurrogatePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceName( 
            /* [out] */ WCHAR **pwszServiceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceParameters( 
            /* [out] */ WCHAR **pwszServiceParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivateAtStorage( 
            /* [out] */ BOOL *pfActivateAtStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunAsType( 
            /* [out] */ RunAsType *pRunAsType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunAsUser( 
            /* [out] */ WCHAR **pwszUserName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLaunchPermission( 
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessPermission( 
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthenticationLevel( 
            /* [out] */ DWORD *pdwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImpersonationLevel( 
            /* [out] */ DWORD *pdwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthenticationCapabilities( 
            /* [out] */ DWORD *pdwAuthenticationCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndpoints( 
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [out] */ WCHAR **pwszServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendsProcessEvents( 
            /* [out] */ BOOL *pbSendsEvents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComProcessInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComProcessInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComProcessInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessId )( 
            IComProcessInfo * This,
            /* [out] */ GUID **ppguidProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszProcessName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessType )( 
            IComProcessInfo * This,
            /* [out] */ ProcessType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogatePath )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszSurrogatePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServiceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceParameters )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServiceParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivateAtStorage )( 
            IComProcessInfo * This,
            /* [out] */ BOOL *pfActivateAtStorage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsType )( 
            IComProcessInfo * This,
            /* [out] */ RunAsType *pRunAsType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsUser )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszUserName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLaunchPermission )( 
            IComProcessInfo * This,
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessPermission )( 
            IComProcessInfo * This,
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationLevel )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationLevel )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationCapabilities )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwAuthenticationCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpoints )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *SendsProcessEvents )( 
            IComProcessInfo * This,
            /* [out] */ BOOL *pbSendsEvents);
        
        END_INTERFACE
    } IComProcessInfoVtbl;

    interface IComProcessInfo
    {
        CONST_VTBL struct IComProcessInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComProcessInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComProcessInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComProcessInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComProcessInfo_GetProcessId(This,ppguidProcessId)	\
    (This)->lpVtbl -> GetProcessId(This,ppguidProcessId)

#define IComProcessInfo_GetProcessName(This,pwszProcessName)	\
    (This)->lpVtbl -> GetProcessName(This,pwszProcessName)

#define IComProcessInfo_GetProcessType(This,pType)	\
    (This)->lpVtbl -> GetProcessType(This,pType)

#define IComProcessInfo_GetSurrogatePath(This,pwszSurrogatePath)	\
    (This)->lpVtbl -> GetSurrogatePath(This,pwszSurrogatePath)

#define IComProcessInfo_GetServiceName(This,pwszServiceName)	\
    (This)->lpVtbl -> GetServiceName(This,pwszServiceName)

#define IComProcessInfo_GetServiceParameters(This,pwszServiceParameters)	\
    (This)->lpVtbl -> GetServiceParameters(This,pwszServiceParameters)

#define IComProcessInfo_GetActivateAtStorage(This,pfActivateAtStorage)	\
    (This)->lpVtbl -> GetActivateAtStorage(This,pfActivateAtStorage)

#define IComProcessInfo_GetRunAsType(This,pRunAsType)	\
    (This)->lpVtbl -> GetRunAsType(This,pRunAsType)

#define IComProcessInfo_GetRunAsUser(This,pwszUserName)	\
    (This)->lpVtbl -> GetRunAsUser(This,pwszUserName)

#define IComProcessInfo_GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)

#define IComProcessInfo_GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)

#define IComProcessInfo_GetAuthenticationLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthenticationLevel(This,pdwAuthnLevel)

#define IComProcessInfo_GetImpersonationLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpersonationLevel(This,pdwImpLevel)

#define IComProcessInfo_GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)	\
    (This)->lpVtbl -> GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)

#define IComProcessInfo_GetEndpoints(This,pdwNumEndpoints,ppEndPoints)	\
    (This)->lpVtbl -> GetEndpoints(This,pdwNumEndpoints,ppEndPoints)

#define IComProcessInfo_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IComProcessInfo_SendsProcessEvents(This,pbSendsEvents)	\
    (This)->lpVtbl -> SendsProcessEvents(This,pbSendsEvents)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessId_Proxy( 
    IComProcessInfo * This,
    /* [out] */ GUID **ppguidProcessId);


void __RPC_STUB IComProcessInfo_GetProcessId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszProcessName);


void __RPC_STUB IComProcessInfo_GetProcessName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessType_Proxy( 
    IComProcessInfo * This,
    /* [out] */ ProcessType *pType);


void __RPC_STUB IComProcessInfo_GetProcessType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetSurrogatePath_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszSurrogatePath);


void __RPC_STUB IComProcessInfo_GetSurrogatePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetServiceName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServiceName);


void __RPC_STUB IComProcessInfo_GetServiceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetServiceParameters_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServiceParameters);


void __RPC_STUB IComProcessInfo_GetServiceParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetActivateAtStorage_Proxy( 
    IComProcessInfo * This,
    /* [out] */ BOOL *pfActivateAtStorage);


void __RPC_STUB IComProcessInfo_GetActivateAtStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRunAsType_Proxy( 
    IComProcessInfo * This,
    /* [out] */ RunAsType *pRunAsType);


void __RPC_STUB IComProcessInfo_GetRunAsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRunAsUser_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszUserName);


void __RPC_STUB IComProcessInfo_GetRunAsUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetLaunchPermission_Proxy( 
    IComProcessInfo * This,
    /* [out] */ void **ppsdLaunch,
    /* [out] */ DWORD *pdwDescriptorLength);


void __RPC_STUB IComProcessInfo_GetLaunchPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAccessPermission_Proxy( 
    IComProcessInfo * This,
    /* [out] */ void **ppsdAccess,
    /* [out] */ DWORD *pdwDescriptorLength);


void __RPC_STUB IComProcessInfo_GetAccessPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAuthenticationLevel_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwAuthnLevel);


void __RPC_STUB IComProcessInfo_GetAuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetImpersonationLevel_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwImpLevel);


void __RPC_STUB IComProcessInfo_GetImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAuthenticationCapabilities_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwAuthenticationCapabilities);


void __RPC_STUB IComProcessInfo_GetAuthenticationCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetEndpoints_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwNumEndpoints,
    /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);


void __RPC_STUB IComProcessInfo_GetEndpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRemoteServerName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServerName);


void __RPC_STUB IComProcessInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_SendsProcessEvents_Proxy( 
    IComProcessInfo * This,
    /* [out] */ BOOL *pbSendsEvents);


void __RPC_STUB IComProcessInfo_SendsProcessEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComProcessInfo_INTERFACE_DEFINED__ */


#ifndef __IComProcessInfo2_INTERFACE_DEFINED__
#define __IComProcessInfo2_INTERFACE_DEFINED__

/* interface IComProcessInfo2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComProcessInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6acfc1bf-3882-45b1-96a3-ab948a267d38")
    IComProcessInfo2 : public IComProcessInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetManifestLocation( 
            /* [out] */ WCHAR **wszManifestLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaferTrustLevel( 
            /* [out] */ DWORD *pdwSaferTrustLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComProcessInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComProcessInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComProcessInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComProcessInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessId )( 
            IComProcessInfo2 * This,
            /* [out] */ GUID **ppguidProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszProcessName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessType )( 
            IComProcessInfo2 * This,
            /* [out] */ ProcessType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogatePath )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszSurrogatePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServiceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceParameters )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServiceParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivateAtStorage )( 
            IComProcessInfo2 * This,
            /* [out] */ BOOL *pfActivateAtStorage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsType )( 
            IComProcessInfo2 * This,
            /* [out] */ RunAsType *pRunAsType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsUser )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszUserName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLaunchPermission )( 
            IComProcessInfo2 * This,
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessPermission )( 
            IComProcessInfo2 * This,
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationCapabilities )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwAuthenticationCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpoints )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *SendsProcessEvents )( 
            IComProcessInfo2 * This,
            /* [out] */ BOOL *pbSendsEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestLocation )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **wszManifestLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaferTrustLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwSaferTrustLevel);
        
        END_INTERFACE
    } IComProcessInfo2Vtbl;

    interface IComProcessInfo2
    {
        CONST_VTBL struct IComProcessInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComProcessInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComProcessInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComProcessInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComProcessInfo2_GetProcessId(This,ppguidProcessId)	\
    (This)->lpVtbl -> GetProcessId(This,ppguidProcessId)

#define IComProcessInfo2_GetProcessName(This,pwszProcessName)	\
    (This)->lpVtbl -> GetProcessName(This,pwszProcessName)

#define IComProcessInfo2_GetProcessType(This,pType)	\
    (This)->lpVtbl -> GetProcessType(This,pType)

#define IComProcessInfo2_GetSurrogatePath(This,pwszSurrogatePath)	\
    (This)->lpVtbl -> GetSurrogatePath(This,pwszSurrogatePath)

#define IComProcessInfo2_GetServiceName(This,pwszServiceName)	\
    (This)->lpVtbl -> GetServiceName(This,pwszServiceName)

#define IComProcessInfo2_GetServiceParameters(This,pwszServiceParameters)	\
    (This)->lpVtbl -> GetServiceParameters(This,pwszServiceParameters)

#define IComProcessInfo2_GetActivateAtStorage(This,pfActivateAtStorage)	\
    (This)->lpVtbl -> GetActivateAtStorage(This,pfActivateAtStorage)

#define IComProcessInfo2_GetRunAsType(This,pRunAsType)	\
    (This)->lpVtbl -> GetRunAsType(This,pRunAsType)

#define IComProcessInfo2_GetRunAsUser(This,pwszUserName)	\
    (This)->lpVtbl -> GetRunAsUser(This,pwszUserName)

#define IComProcessInfo2_GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)

#define IComProcessInfo2_GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)

#define IComProcessInfo2_GetAuthenticationLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthenticationLevel(This,pdwAuthnLevel)

#define IComProcessInfo2_GetImpersonationLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpersonationLevel(This,pdwImpLevel)

#define IComProcessInfo2_GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)	\
    (This)->lpVtbl -> GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)

#define IComProcessInfo2_GetEndpoints(This,pdwNumEndpoints,ppEndPoints)	\
    (This)->lpVtbl -> GetEndpoints(This,pdwNumEndpoints,ppEndPoints)

#define IComProcessInfo2_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IComProcessInfo2_SendsProcessEvents(This,pbSendsEvents)	\
    (This)->lpVtbl -> SendsProcessEvents(This,pbSendsEvents)


#define IComProcessInfo2_GetManifestLocation(This,wszManifestLocation)	\
    (This)->lpVtbl -> GetManifestLocation(This,wszManifestLocation)

#define IComProcessInfo2_GetSaferTrustLevel(This,pdwSaferTrustLevel)	\
    (This)->lpVtbl -> GetSaferTrustLevel(This,pdwSaferTrustLevel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComProcessInfo2_GetManifestLocation_Proxy( 
    IComProcessInfo2 * This,
    /* [out] */ WCHAR **wszManifestLocation);


void __RPC_STUB IComProcessInfo2_GetManifestLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo2_GetSaferTrustLevel_Proxy( 
    IComProcessInfo2 * This,
    /* [out] */ DWORD *pdwSaferTrustLevel);


void __RPC_STUB IComProcessInfo2_GetSaferTrustLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComProcessInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0151 */
/* [local] */ 

typedef 
enum tagResourceGateId
    {	CreateProcessMemoryGate	= 0,
	CreateObjectMemoryGate	= CreateProcessMemoryGate + 1
    } 	ResourceGateId;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0151_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0151_ServerIfHandle;

#ifndef __IResourceGates_INTERFACE_DEFINED__
#define __IResourceGates_INTERFACE_DEFINED__

/* interface IResourceGates */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IResourceGates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a0ddd93-7198-4e15-bbd7-427c77b6907a")
    IResourceGates : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Test( 
            /* [in] */ ResourceGateId id,
            /* [out] */ BOOL *pbResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceGatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceGates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceGates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceGates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Test )( 
            IResourceGates * This,
            /* [in] */ ResourceGateId id,
            /* [out] */ BOOL *pbResult);
        
        END_INTERFACE
    } IResourceGatesVtbl;

    interface IResourceGates
    {
        CONST_VTBL struct IResourceGatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceGates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResourceGates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResourceGates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResourceGates_Test(This,id,pbResult)	\
    (This)->lpVtbl -> Test(This,id,pbResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResourceGates_Test_Proxy( 
    IResourceGates * This,
    /* [in] */ ResourceGateId id,
    /* [out] */ BOOL *pbResult);


void __RPC_STUB IResourceGates_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResourceGates_INTERFACE_DEFINED__ */


#ifndef __IProcessServerInfo_INTERFACE_DEFINED__
#define __IProcessServerInfo_INTERFACE_DEFINED__

/* interface IProcessServerInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IProcessServerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001EE-0000-0000-C000-000000000046")
    IProcessServerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetShutdownIdleTime( 
            /* [out] */ unsigned long *pulTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCrmLogFileName( 
            /* [out] */ WCHAR **pwszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ IEnumUnknown **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRetQueues( 
            /* [out] */ IEnumUnknown **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessServerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessServerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessServerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessServerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetShutdownIdleTime )( 
            IProcessServerInfo * This,
            /* [out] */ unsigned long *pulTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCrmLogFileName )( 
            IProcessServerInfo * This,
            /* [out] */ WCHAR **pwszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplications )( 
            IProcessServerInfo * This,
            /* [out] */ IEnumUnknown **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRetQueues )( 
            IProcessServerInfo * This,
            /* [out] */ IEnumUnknown **ppEnum);
        
        END_INTERFACE
    } IProcessServerInfoVtbl;

    interface IProcessServerInfo
    {
        CONST_VTBL struct IProcessServerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessServerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessServerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProcessServerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProcessServerInfo_GetShutdownIdleTime(This,pulTime)	\
    (This)->lpVtbl -> GetShutdownIdleTime(This,pulTime)

#define IProcessServerInfo_GetCrmLogFileName(This,pwszFileName)	\
    (This)->lpVtbl -> GetCrmLogFileName(This,pwszFileName)

#define IProcessServerInfo_EnumApplications(This,ppEnum)	\
    (This)->lpVtbl -> EnumApplications(This,ppEnum)

#define IProcessServerInfo_EnumRetQueues(This,ppEnum)	\
    (This)->lpVtbl -> EnumRetQueues(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProcessServerInfo_GetShutdownIdleTime_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ unsigned long *pulTime);


void __RPC_STUB IProcessServerInfo_GetShutdownIdleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_GetCrmLogFileName_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ WCHAR **pwszFileName);


void __RPC_STUB IProcessServerInfo_GetCrmLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_EnumApplications_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ IEnumUnknown **ppEnum);


void __RPC_STUB IProcessServerInfo_EnumApplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_EnumRetQueues_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ IEnumUnknown **ppEnum);


void __RPC_STUB IProcessServerInfo_EnumRetQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProcessServerInfo_INTERFACE_DEFINED__ */


#ifndef __IInterfaceInfo_INTERFACE_DEFINED__
#define __IInterfaceInfo_INTERFACE_DEFINED__

/* interface IInterfaceInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IInterfaceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F7-0000-0000-C000-000000000046")
    IInterfaceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProxyStubCLSID( 
            /* [out] */ GUID **psclsid,
            /* [out] */ BOOL *pfIs16BitPS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [out] */ GUID **pLibID,
            /* [out] */ unsigned short *psVersionMajor,
            /* [out] */ unsigned short *psVersionMinor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncIID( 
            /* [out] */ GUID **syncriid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncIID( 
            /* [out] */ GUID **asyncriid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInterfaceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterfaceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterfaceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterfaceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyStubCLSID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **psclsid,
            /* [out] */ BOOL *pfIs16BitPS);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **pLibID,
            /* [out] */ unsigned short *psVersionMajor,
            /* [out] */ unsigned short *psVersionMinor);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncIID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **syncriid);
        
        HRESULT ( STDMETHODCALLTYPE *GetAsyncIID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **asyncriid);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInterfaceInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IInterfaceInfoVtbl;

    interface IInterfaceInfo
    {
        CONST_VTBL struct IInterfaceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterfaceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInterfaceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInterfaceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInterfaceInfo_GetProxyStubCLSID(This,psclsid,pfIs16BitPS)	\
    (This)->lpVtbl -> GetProxyStubCLSID(This,psclsid,pfIs16BitPS)

#define IInterfaceInfo_GetTypeLibrary(This,pLibID,psVersionMajor,psVersionMinor)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pLibID,psVersionMajor,psVersionMinor)

#define IInterfaceInfo_GetSyncIID(This,syncriid)	\
    (This)->lpVtbl -> GetSyncIID(This,syncriid)

#define IInterfaceInfo_GetAsyncIID(This,asyncriid)	\
    (This)->lpVtbl -> GetAsyncIID(This,asyncriid)

#define IInterfaceInfo_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetProxyStubCLSID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **psclsid,
    /* [out] */ BOOL *pfIs16BitPS);


void __RPC_STUB IInterfaceInfo_GetProxyStubCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetTypeLibrary_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **pLibID,
    /* [out] */ unsigned short *psVersionMajor,
    /* [out] */ unsigned short *psVersionMinor);


void __RPC_STUB IInterfaceInfo_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetSyncIID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **syncriid);


void __RPC_STUB IInterfaceInfo_GetSyncIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetAsyncIID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **asyncriid);


void __RPC_STUB IInterfaceInfo_GetAsyncIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetTypeInfo_Proxy( 
    IInterfaceInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IInterfaceInfo_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInterfaceInfo_INTERFACE_DEFINED__ */


#ifndef __IComCatalogSettings_INTERFACE_DEFINED__
#define __IComCatalogSettings_INTERFACE_DEFINED__

/* interface IComCatalogSettings */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FF-0000-0000-C000-000000000046")
    IComCatalogSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshComPlusEnabled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshComPlusEnabled )( 
            IComCatalogSettings * This);
        
        END_INTERFACE
    } IComCatalogSettingsVtbl;

    interface IComCatalogSettings
    {
        CONST_VTBL struct IComCatalogSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogSettings_RefreshComPlusEnabled(This)	\
    (This)->lpVtbl -> RefreshComPlusEnabled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogSettings_RefreshComPlusEnabled_Proxy( 
    IComCatalogSettings * This);


void __RPC_STUB IComCatalogSettings_RefreshComPlusEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0155 */
/* [local] */ 

STDAPI GetCatalogObject (REFIID riid, void **ppv );
STDAPI GetCatalogObject2 (REFIID riid, void **ppv );


extern RPC_IF_HANDLE __MIDL_itf_catalog_0155_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0155_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\globalopt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for globalopt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __globalopt_h__
#define __globalopt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGlobalOptions_FWD_DEFINED__
#define __IGlobalOptions_FWD_DEFINED__
typedef interface IGlobalOptions IGlobalOptions;
#endif 	/* __IGlobalOptions_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IGlobalOptions_INTERFACE_DEFINED__
#define __IGlobalOptions_INTERFACE_DEFINED__

/* interface IGlobalOptions */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IGlobalOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000015B-0000-0000-C000-000000000046")
    IGlobalOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ ULONG_PTR dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ DWORD dwProperty,
            /* [out] */ ULONG_PTR *pdwValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGlobalOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGlobalOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGlobalOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IGlobalOptions * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ ULONG_PTR dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            IGlobalOptions * This,
            /* [in] */ DWORD dwProperty,
            /* [out] */ ULONG_PTR *pdwValue);
        
        END_INTERFACE
    } IGlobalOptionsVtbl;

    interface IGlobalOptions
    {
        CONST_VTBL struct IGlobalOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGlobalOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalOptions_Set(This,dwProperty,dwValue)	\
    (This)->lpVtbl -> Set(This,dwProperty,dwValue)

#define IGlobalOptions_Query(This,dwProperty,pdwValue)	\
    (This)->lpVtbl -> Query(This,dwProperty,pdwValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGlobalOptions_Set_Proxy( 
    IGlobalOptions * This,
    /* [in] */ DWORD dwProperty,
    /* [in] */ ULONG_PTR dwValue);


void __RPC_STUB IGlobalOptions_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGlobalOptions_Query_Proxy( 
    IGlobalOptions * This,
    /* [in] */ DWORD dwProperty,
    /* [out] */ ULONG_PTR *pdwValue);


void __RPC_STUB IGlobalOptions_Query_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGlobalOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_globalopt_0097 */
/* [local] */ 


enum __MIDL___MIDL_itf_globalopt_0097_0001
    {	COMGLB_EXCEPTION_HANDLING	= 0x1
    } ;

enum __MIDL___MIDL_itf_globalopt_0097_0002
    {	COMGLB_EXCEPTION_HANDLE	= 0,
	COMGLB_EXCEPTION_DONOT_HANDLE	= 1
    } ;

EXTERN_C const CLSID CLSID_GlobalOptions;



extern RPC_IF_HANDLE __MIDL_itf_globalopt_0097_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_globalopt_0097_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\corhdr.h ===
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 ** Copyright (c) Microsoft Corporation. All rights reserved.               **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__


#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
typedef ULONG32 mdScope;                // Why is this still needed?
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope  
typedef mdToken mdMethodDef;            // Method in this scope 
typedef mdToken mdParamDef;             // param token  
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)  
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdCustomAttribute mdCustomValue;// attribute token
typedef mdToken mdPermission;           // DeclSecurity 

typedef mdToken mdSignature;            // Signature object 
typedef mdToken mdEvent;                // event token  
typedef mdToken mdProperty;             // property token   

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)  

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdComType;              // ComType token.
typedef mdToken mdManifestResource;     // ManifestResource token.
typedef mdToken mdLocalizedResource;    // LocalizedManifestResource token.
typedef mdToken mdExecutionLocation;    // Execution location token.

typedef mdToken mdTypeSpec;             // TypeSpec object 

// Debugger support tokens - deprecated.
typedef mdToken mdSourceFile;           // source file token    
typedef mdToken mdLocalVarScope;        // local variable scope token   
typedef mdToken mdLocalVar;             // local variable token 

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token   

#ifndef MACROS_NOT_SUPPORTED
typedef unsigned long RID;              //@todo: this goes away with 9/29 integration when complib is nuked.
#else
typedef unsigned RID;
#endif


typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for COM+ data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix 
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ComType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdLayoutSequential      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000060,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    tdValueType             =   0x00000040,     // Type is a managed value type.
    tdUnmanagedValueType    =   0x00000060,     // DEPRECATED Don't use TODO; remove on next breaking change
    tdNotInGCHeapValueType  =   0x00000060,     // It is a value type that can not live in the GC heap.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdEnum                  =   0x00000200,     // Class is an enum; static final values only
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,     
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    // end string format mask

    tdLateInit              =   0x00080000,     // Initialize the class lazily.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdLayoutSequential(x)             (((x) & tdLayoutMask) == tdLayoutSequential)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)
#define IsTdUnmanagedValueType(x)           IsTdNotInGCHeapValueType(x)  		// DEPRECATED: TODO remove on next breaking change
#define IsTdNotInGCHeapValueType(x)         (((x) & tdClassSemanticsMask) == tdNotInGCHeapValueType)
#define IsTdValueType(x)                    ((x) & tdValueType)  // This can be either tdManagedValueType or tdNotInGCHeapValueType

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdEnum(x)                         ((x) & tdEnum)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)

#define IsTdLateInit(x)                     ((x) &tdLateInit)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.
    
    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.
    
    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0xd500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasSecurity               =   0x4000,     // Field has a security associate.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasSecurity(x)                  ((x) & fdHasSecurity)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

// Param attr bits, used by DefineParam. 
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]    
    pdOut                       =   0x0002,     // Param is [out]   
    pdLcid                      =   0x0004,     // Param is [lcid]  
    pdRetval                    =   0x0008,     // Param is [Retval]    
    pdOptional                  =   0x0010,     // Param is optional    

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.
    pdReserved3                 =   0x4000,     // reserved bit
    pdReserved4                 =   0x8000      // reserved bit 
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdLcid(x)                         ((x) & pdLcid)
#define IsPdRetval(x)                       ((x) & pdRetval)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default 
    prReserved2             =   0x2000,     // reserved bit
    prReserved3             =   0x4000,     // reserved bit 
    prReserved4             =   0x8000      // reserved bit 
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property  
    msGetter    =   0x0002,     // Getter for property  
    msOther     =   0x0004,     // other method for property or event   
    msAddOn     =   0x0008,     // AddOn method for event   
    msRemoveOn  =   0x0010,     // RemoveOn method for event    
    msFire      =   0x0020,     // Fire method for event    
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask       =   0x000f,     // Mask allows growth of enum.
    dclActionNil        =   0x0000, 
    dclRequest          =   0x0001,     //  
    dclDemand           =   0x0002,     //  
    dclAssert           =   0x0003,     //  
    dclDeny             =   0x0004,     //  
    dclPermitOnly       =   0x0005,     //  
    dclLinktimeCheck    =   0x0006,     //  
    dclInheritanceCheck =   0x0007,     //  
    dclRequestMinimum   =   0x0008,     //
    dclRequestOptional  =   0x0009,     //
    dclRequestRefuse    =   0x000a,     //
    dclPrejitGrant      =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied     =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand     =   0x000d,     //
    dclNonCasLinkDemand =   0x000e,
    dclNonCasInheritance=   0x000f,
    dclMaximumValue     =   0x000f,     // Maximum legal value  
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
#define IsDclRequest(x)                     (((x) & dclActionMask) == dclRequest)
#define IsDclDemand(x)                      (((x) & dclActionMask) == dclDemand)
#define IsDclAssert(x)                      (((x) & dclActionMask) == dclAssert)
#define IsDclDeny(x)                        (((x) & dclActionMask) == dclDeny)
#define IsDclPermitOnly(x)                  (((x) & dclActionMask) == dclPermit)
#define IsDclLinktimeCheck(x)               (((x) & dclActionMask) == dclLinktimeCheck)
#define IsDclInheritanceCheck(x)            (((x) & dclActionMask) == dclInheritanceCheck)
#define IsDclMaximumValue(x)                (((x) & dclActionMask) == dclMaximumValue)


// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.   
    miIL                =   0x0000,   // Method impl is IL.   
    miNative            =   0x0001,   // Method impl is native.     
    miOPTIL             =   0x0002,   // Method impl is OPTIL 
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miOLE               =   0x0080,   // Indicates method sig is mangled to return HRESULT, with retval as param 

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.                                      
    miMaxMethodImplVal  =   0xffff,   // Range check value    
} CorMethodImpl; 

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiOLE(x)                          ((x) & miOLE)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{ 
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002, 
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,

    pmPinvokeOLE        = 0x0020,   // Heuristic: pinvoke will return hresult, with return value becoming the retval param. Not relevant for fields. 
    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmPinvokeOLE(x)                   ((x) & pmPinvokeOLE)
#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)


// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afImplicitComTypes      =   0x0001,     // ComType definitions are implicit within the files.
    afImplicitResources     =   0x0002,     // Resource definitions are implicit within the files.

    afCompatibilityMask     =   0x0070,
    afSideBySideCompatible  =   0x0000,      // The assembly is side by side compatible.
    afNonSideBySideAppDomain=   0x0010,     // The assembly cannot execute with other versions if
                                            // they are executing in the same application domain.
    afNonSideBySideProcess  =   0x0020,     // The assembly cannot execute with other versions if
                                            // they are executing in the same process.
    afNonSideBySideMachine  =   0x0030,     // The assembly cannot execute with other versions if
                                            // they are executing on the same machine.
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfImplicitComTypes(x)             ((x) & afImplicitComTypes)
#define IsAfImplicitResources(x)            ((x) & afImplicitResources)
#define IsAfSideBySideCompatible(x)         (((x) & afCompatibilityMask) == afSideBySideCompatible)
#define IsAfNonSideBySideAppDomain(x)       (((x) & afCompatibilityMask) == afNonSideBySideAppDomain)
#define IsAfNonSideBySideProcess(x)         (((x) & afCompatibilityMask) == afNonSideBySideProcess)
#define IsAfNonSideBySideMachine(x)         (((x) & afCompatibilityMask) == afNonSideBySideMachine)


// AssemblyRef attr bits, used by DefineAssemblyRef.
typedef enum CorAssemblyRefFlags
{
    arFullOriginator        =   0x0001,     // The assembly ref holds the full (unhashed) originator.
} CorAssemblyRefFlags;

// Macros for accessing the members of CorAssemblyRefFlags.
#define IsArFullOriginator(x)               ((x) & arFullOriginator)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
    ffWriteable             =   0x0002,     // The file is writeable post-build.
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)
#define IsFfWriteable(x)                    ((x) & ffWriteable)


// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that 
                                            // the bytes can be incremented easily  
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,  
    ELEMENT_TYPE_VOID           = 0x1,  
    ELEMENT_TYPE_BOOLEAN        = 0x2,  
    ELEMENT_TYPE_CHAR           = 0x3,  
    ELEMENT_TYPE_I1             = 0x4,  
    ELEMENT_TYPE_U1             = 0x5, 
    ELEMENT_TYPE_I2             = 0x6,  
    ELEMENT_TYPE_U2             = 0x7,  
    ELEMENT_TYPE_I4             = 0x8,  
    ELEMENT_TYPE_U4             = 0x9,  
    ELEMENT_TYPE_I8             = 0xa,  
    ELEMENT_TYPE_U8             = 0xb,  
    ELEMENT_TYPE_R4             = 0xc,  
    ELEMENT_TYPE_R8             = 0xd,  
    ELEMENT_TYPE_STRING         = 0xe,  

    // every type above PTR will be simple type 
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>   
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type> 

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token> 
    ELEMENT_TYPE_VALUECLASS     = ELEMENT_TYPE_VALUETYPE, 
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>  

    ELEMENT_TYPE_UNUSED1        = 0x13,
    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

    ELEMENT_TYPE_COPYCTOR       = 0x15,     // COPYCTOR <type>      // copy construct the argument
    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // This is a simple type.   

    ELEMENT_TYPE_VALUEARRAY     = 0x17,     // VALUEARRAY <type> <bound>    
    ELEMENT_TYPE_I              = 0x18,     // native integer size  
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size 
    ELEMENT_TYPE_R              = 0x1A,     // native real size 
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>
    ELEMENT_TYPE_GENERICARRAY   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // Note that this is the max of base type excluding modifiers   
    ELEMENT_TYPE_MAX            = 0x21,     // first invalid element type   

    // These are experimental for internal use only
    ELEMENT_TYPE_VAR            = ELEMENT_TYPE_MAX + 1,     // a type variable VAR <U1> 
    ELEMENT_TYPE_NAME           = ELEMENT_TYPE_MAX + 2,     // class by name NAME <count> <chars>
                                                            // should remove after 9/27/99

    ELEMENT_TYPE_MODIFIER       = 0x40, 
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1, 
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1, 
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,  
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,  
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,  
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,  
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8, 
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,  
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,  
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,  
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING, 
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array 
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_VARIANT      = 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55    
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  

    IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9,
    IMAGE_CEE_CS_CALLCONV_MAX       = 0x10,  // first invalid calling convention    


        // The high bits of the calling convention convey additional info   
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits 
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter    
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
} CorCallingConvention;


typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,  
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,  
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,  
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,  

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,  
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,  
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,  
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,  

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,  
    NATIVE_TYPE_U1          = 0x4,  
    NATIVE_TYPE_I2          = 0x5,  
    NATIVE_TYPE_U2          = 0x6,  
    NATIVE_TYPE_I4          = 0x7,  
    NATIVE_TYPE_U4          = 0x8,  
    NATIVE_TYPE_I8          = 0x9,  
    NATIVE_TYPE_U8          = 0xa,  
    NATIVE_TYPE_R4          = 0xb,  
    NATIVE_TYPE_R8          = 0xc,  
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED 
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,    //DEPRECATED
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED  

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13, 
    NATIVE_TYPE_LPSTR       = 0x14, 
    NATIVE_TYPE_LPWSTR      = 0x15, 
    NATIVE_TYPE_LPTSTR      = 0x16, 
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17, 
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,
    NATIVE_TYPE_IDISPATCH   = 0x1a,
    NATIVE_TYPE_STRUCT      = 0x1b, 
    NATIVE_TYPE_INTF        = 0x1c, 
    NATIVE_TYPE_SAFEARRAY   = 0x1d, 
    NATIVE_TYPE_FIXEDARRAY  = 0x1e, 
    NATIVE_TYPE_INT         = 0x1f, 
    NATIVE_TYPE_UINT        = 0x20, 

    //@todo: sync up the spec   
    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)   

    NATIVE_TYPE_BYVALSTR    = 0x22,
                              
    NATIVE_TYPE_ANSIBSTR    = 0x23,

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform


    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    NATIVE_TYPE_FUNC        = 0x26,
    NATIVE_TYPE_LPVOID      = 0x27, // blind pointer (no deep marshaling)

    NATIVE_TYPE_ASANY       = 0x28,
    NATIVE_TYPE_R           = 0x29, // agnostic floating point

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed 
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type   
} CorNativeType;


enum 
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs   
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls  
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.  

typedef enum CorILMethodSect                             // codes that identify attributes   
{
    CorILMethod_Sect_Reserved    = 0,   
    CorILMethod_Sect_EHTable     = 1,   
    CorILMethod_Sect_OptILTable  = 2,   

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code  
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format   
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one    
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL 
{
    BYTE Kind;  
    BYTE DataSize;  
} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT 
{
    unsigned Kind : 8;  
    unsigned DataSize : 24; 
} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)  
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter    
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause  
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE 
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree 
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;  
    DWORD               TryOffset;    
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers    
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16; 
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset; 
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;   
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;   
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{ 
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars   
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one    

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis  

        // Indicates the format for the COR_ILMETHOD header 
    CorILMethod_FormatShift     = 3,    
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1), 
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even 
    CorILMethod_SmallFormat     = 0x0000,           
    CorILMethod_FatFormat       = 0x0003,   
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;    
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags    
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack   
    DWORD   CodeSize;           // size of the code 
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  
} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;   
    IMAGE_COR_ILMETHOD_FAT        Fat;    
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo; 
    DWORD       EHInfo; 
} IMAGE_COR_NATIVE_DESCRIPTOR;

//@Todo:  this structure is obsoleted by the pdata version right behind it.
// This needs to get deleted as soon as VC/COR are sync'd up.
typedef struct COR_IPMAP_ENTRY
{
    ULONG MethodRVA;    
    ULONG MIHRVA;   
} COR_IPMAP_ENTRY;

typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY 
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;  
    ULONG   MethodRVA;  
    mdToken Token;  
    BYTE    Flags;  
    BYTE    CodeManager;    
    BYTE    MIHData[0]; 
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by 
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the COM+ Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.    
    USHORT      Count;                  // How many entries at location.    
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.  
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S 
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                = 0xffffffff,
    MDDupENC                = MDDupAll,
    MDNoDupChecks           = 0x00000000,
    MDDupTypeDef            = 0x00000001,
    MDDupInterfaceImpl      = 0x00000002,
    MDDupMethodDef          = 0x00000004,
    MDDupTypeRef            = 0x00000008,
    MDDupMemberRef          = 0x00000010,
    MDDupCustomValue        = 0x00000020,
    MDDupCustomAttribute    = 0x00000020,   // Alias for custom value.
    MDDupParamDef           = 0x00000040,
    MDDupPermission         = 0x00000080,
    MDDupProperty           = 0x00000100,
    MDDupEvent              = 0x00000200,
    MDDupFieldDef           = 0x00000400,
    MDDupSignature          = 0x00000800,
    MDDupModuleRef          = 0x00001000,
    MDDupTypeSpec           = 0x00002000,
    MDDupImplMap            = 0x00004000,
    MDDupAssemblyRef        = 0x00008000,
    MDDupFile               = 0x00010000,
    MDDupComType            = 0x00020000,
    MDDupManifestResource   = 0x00040000,
    MDDupExecutionLocation  = 0x00080000,
    // gap for debug junk
    MDDupAssembly           = 0x10000000,

    // @todo: These will go away once the MetaData debug tables are gone.
    MDDupSourceFile         = 0x01000000,
    MDDupBlock              = 0x02000000,
    MDDupLocalVarScope      = 0x04000000,
    MDDupLocalVar           = 0x08000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, and TypeSpec
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault       = 0x00000003,
    MDRefToDefAll           = 0xffffffff,
    MDRefToDefNone          = 0x00000000,
    MDTypeRefToDef          = 0x00000001,
    MDMemberRefToDef        = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault         = 0x0000000f,
    MDNotifyAll             = 0xffffffff,
    MDNotifyNone            = 0x00000000,
    MDNotifyMethodDef       = 0x00000001,
    MDNotifyMemberRef       = 0x00000002,
    MDNotifyFieldDef        = 0x00000004,
    MDNotifyTypeRef         = 0x00000008,

    MDNotifyTypeDef         = 0x00000010,
    MDNotifyParamDef        = 0x00000020,
    MDNotifyInterfaceImpl   = 0x00000040,
    MDNotifyProperty        = 0x00000080,
    MDNotifyEvent           = 0x00000100,
    MDNotifySignature       = 0x00000200,
    MDNotifyTypeSpec        = 0x00000400,
    MDNotifyCustomValue     = 0x00000800,
    MDNotifyCustomAttribute = 0x00001000,   // Alias for custom value
    MDNotifySecurityValue   = 0x00002000,
    MDNotifyPermission      = 0x00004000,
    MDNotifyModuleRef       = 0x00008000,
    
    MDNotifyNameSpace       = 0x00010000,
    MDNotifyDebugTokens     = 0x00800000,   // This covers all Debug tokens, bits are expensive :-)

    MDNotifyAssemblyRef     = 0x01000000,
    MDNotifyFile            = 0x02000000,
    MDNotifyComType         = 0x04000000,
    MDNotifyResource        = 0x08000000,
    MDNotifyExecutionLocation = 0x10000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn              = 0x00000001,   // Deprecated name.
    MDSetENCOff             = 0x00000002,   // Deprecated name.

    MDUpdateENC             = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull            = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension       = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental     = 0x00000004,   // Incremental compilation
    MDUpdateMask            = 0x00000007,

    MDUpdateDelta           = 0x00000008,   // If ENC on, save only deltas.

} CorSetENC;


// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault = 0x00000000,  // default not to generate any error
    MDErrorOutOfOrderNone   = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll    = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder      = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder       = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder       = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder    = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder       = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomValues = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllComTypes   = 0x00000040,   // all of the ComTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault   = 0x00000000,
    MDThreadSafetyOff       = 0x00000000,
    MDThreadSafetyOn        = 0x00000001,
} CorThreadSafetyOptions;


// 
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//
typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField; 
    ULONG       ulOffset;   
} COR_FIELD_OFFSET;

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;    
    ULONG Count;    
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //          
    mdtTypeRef              = 0x01000000,       //          
    mdtTypeDef              = 0x02000000,       //          
    mdtFieldDef             = 0x04000000,       //           
    mdtMethodDef            = 0x06000000,       //       
    mdtParamDef             = 0x08000000,       //           
    mdtInterfaceImpl        = 0x09000000,       //  
    mdtMemberRef            = 0x0a000000,       //       
    mdtCustomAttribute      = 0x0c000000,       //      
    mdtCustomValue          = mdtCustomAttribute,       //      
    mdtPermission           = 0x0e000000,       //       
    mdtSignature            = 0x11000000,       //       
    mdtEvent                = 0x14000000,       //           
    mdtProperty             = 0x17000000,       //           
    mdtModuleRef            = 0x1a000000,       //       
    mdtTypeSpec             = 0x1b000000,       //           
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtComType              = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //
    mdtExecutionLocation    = 0x29000000,       //

    mdtSourceFile           = 0x2a000000,       //       
    mdtLocalVarScope        = 0x2c000000,       //   
    mdtLocalVar             = 0x2d000000,       //           

    mdtString               = 0x70000000,       //          
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)               
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)             
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)             
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)           
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)         
#define mdParamDefNil               ((mdParamDef)mdtParamDef)           
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)     
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)         
#define mdCustomAttributeNil        ((mdCustomValue)mdtCustomAttribute)         
#define mdCustomValueNil            ((mdCustomAttribute)mdtCustomAttribute)         
#define mdPermissionNil             ((mdPermission)mdtPermission)           
#define mdSignatureNil              ((mdSignature)mdtSignature)         
#define mdEventNil                  ((mdEvent)mdtEvent)             
#define mdPropertyNil               ((mdProperty)mdtProperty)           
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)         
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)           
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdComTypeNil                ((mdComType)mdtComType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)
#define mdExecutionLocationNil      ((mdExecutionLocation)mdtExecutionLocation)

#define mdSourceFileNil             ((mdSourceFile)mdtSourceFile)           
#define mdLocalVarScopeNil          ((mdLocalVarScope)mdtLocalVarScope)     
#define mdLocalVarNil               ((mdLocalVar)mdtLocalVar)           

#define mdStringNil                 ((mdString)mdtString)               

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead      =   0x00000000,     // Open scope for read
    ofWrite     =   0x00000001,     // Open scope for write.
    ofCopyMemory =  0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.
    ofCacheImage =  0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib =   0x00000080,     // Don't OpenScope on a typelib.
} CorOpenFlags;


typedef enum CorBaseType    // TokenFromRid(X,Y) replaced with (X | Y)
{
    mdtBaseType_BOOLEAN        = ( ELEMENT_TYPE_BOOLEAN | mdtBaseType ),  
    mdtBaseType_CHAR           = ( ELEMENT_TYPE_CHAR    | mdtBaseType ),
    mdtBaseType_I1             = ( ELEMENT_TYPE_I1      | mdtBaseType ), 
    mdtBaseType_U1             = ( ELEMENT_TYPE_U1      | mdtBaseType ),
    mdtBaseType_I2             = ( ELEMENT_TYPE_I2      | mdtBaseType ),  
    mdtBaseType_U2             = ( ELEMENT_TYPE_U2      | mdtBaseType ),  
    mdtBaseType_I4             = ( ELEMENT_TYPE_I4      | mdtBaseType ),  
    mdtBaseType_U4             = ( ELEMENT_TYPE_U4      | mdtBaseType ),  
    mdtBaseType_I8             = ( ELEMENT_TYPE_I8      | mdtBaseType ),  
    mdtBaseType_U8             = ( ELEMENT_TYPE_U8      | mdtBaseType ),  
    mdtBaseType_R4             = ( ELEMENT_TYPE_R4      | mdtBaseType ),  
    mdtBaseType_R8             = ( ELEMENT_TYPE_R8      | mdtBaseType ),  
    mdtBaseType_STRING         = ( ELEMENT_TYPE_STRING  | mdtBaseType ),
    mdtBaseType_I              = ( ELEMENT_TYPE_I       | mdtBaseType ),    
    mdtBaseType_U              = ( ELEMENT_TYPE_U       | mdtBaseType ),    
    mdtBaseType_R              = ( ELEMENT_TYPE_R       | mdtBaseType ),    
} CorBaseType;


typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor | 
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,
    
} CorAttributeTargets;

//
// Some well-known custom attributes 
//
#ifndef MACROS_NOT_SUPPORTED

 #ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
 #endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_HASDEFAULTIFACE_TYPE_W          L"System.Runtime.InteropServices.HasDefaultInterfaceAttribute"
#define INTEROP_HASDEFAULTIFACE_TYPE            "System.Runtime.InteropServices.HasDefaultInterfaceAttribute"
#define INTEROP_HASDEFAULTIFACE_SIG             {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_NOCOMREGISTRATION_TYPE_W        L"System.Runtime.InteropServices.NoComRegistrationAttribute"
#define INTEROP_NOCOMREGISTRATION_TYPE          "System.Runtime.InteropServices.NoComRegistrationAttribute"
#define INTEROP_NOCOMREGISTRATION_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}
#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_NOIDISPATCH_TYPE_W              L"System.Runtime.InteropServices.NoIDispatchAttribute"
#define INTEROP_NOIDISPATCH_TYPE                "System.Runtime.InteropServices.NoIDispatchAttribute"
#define INTEROP_NOIDISPATCH_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

//@todo: remove this definition, also from BCL
#define INTEROP_GLOBALOBJECT_TYPE_W             L"System.Runtime.InteropServices.GlobalObjectAttribute"
#define INTEROP_GLOBALOBJECT_TYPE               "System.Runtime.InteropServices.GlobalObjectAttribute"
#define INTEROP_GLOBALOBJECT_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

//@todo: remove this definition, also from BCL
#define INTEROP_PREDECLARED_TYPE_W              L"System.Runtime.InteropServices.PredeclaredAttribute"
#define INTEROP_PREDECLARED_TYPE                "System.Runtime.InteropServices.PredeclaredAttribute"
#define INTEROP_PREDECLARED_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_EXPOSEHRESULT_TYPE_W            L"System.Runtime.InteropServices.ExposeHResultAttribute"
#define INTEROP_EXPOSEHRESULT_TYPE              "System.Runtime.InteropServices.ExposeHResultAttribute"
#define INTEROP_EXPOSEHRESULT_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"                                
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"                                 
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"                                
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"                                 
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
      
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}

#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

typedef unsigned __int64 CLASSVERSION;

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))   
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))    
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))   
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged)) 
#define COR_IS_METHOD_IAT(flags)                (flags & miIAT) 


//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomValue;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomValue;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\iface.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for iface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iface_h__
#define __iface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "obase.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __XmitDefs_INTERFACE_DEFINED__
#define __XmitDefs_INTERFACE_DEFINED__

/* interface XmitDefs */
/* [auto_handle][unique][version][uuid] */ 

#define	ORPCF_INPUT_SYNC	( ORPCF_RESERVED1 )

#define	ORPCF_ASYNC	( ORPCF_RESERVED2 )

#define	ORPCF_DYNAMIC_CLOAKING	( ORPCF_RESERVED3 )

#define	ORPCF_REJECTED	( ORPCF_RESERVED1 )

#define	ORPCF_RETRY_LATER	( ORPCF_RESERVED2 )

typedef /* [public] */ struct __MIDL_XmitDefs_0001
    {
    DWORD dwFlags;
    DWORD dwClientThread;
    } 	LOCALTHIS;

typedef 
enum tagLOCALFLAG
    {	LOCALF_NONE	= 0,
	LOCALF_NONNDR	= 0x800
    } 	LOCALFLAG;

typedef 
enum tagCALLCATEGORY
    {	CALLCAT_NOCALL	= 0,
	CALLCAT_SYNCHRONOUS	= 1,
	CALLCAT_ASYNC	= 2,
	CALLCAT_INPUTSYNC	= 3,
	CALLCAT_INTERNALSYNC	= 4,
	CALLCAT_INTERNALINPUTSYNC	= 5,
	CALLCAT_SCMCALL	= 6
    } 	CALLCATEGORY;

typedef struct tagInterfaceData
    {
    ULONG ulCntData;
    /* [length_is] */ BYTE abData[ 1024 ];
    } 	InterfaceData;

typedef /* [unique] */ InterfaceData *PInterfaceData;

#define IFD_SIZE(pIFD) (sizeof(InterfaceData) + pIFD->ulCntData - 1024)


extern RPC_IF_HANDLE XmitDefs_ClientIfHandle;
extern RPC_IF_HANDLE XmitDefs_ServerIfHandle;
#endif /* __XmitDefs_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilgcrea.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILogCreateStorage.H | Header for interface <i ILogCreateStorage>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGCREA_H
#	define _ILGCREA_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#include "logconst.h"

// ===============================
// INTERFACE: ILogCreateStorage
// ===============================

#define ILogCreateStorage			ILogCreateStorage2A
#ifdef _UNICODE
#define ILogCreateStorage2			ILogCreateStorage2W
#else
#define ILogCreateStorage2			ILogCreateStorage2A
#endif


// -----------------------------------------------------------------------
// @interface ILogCreateStorage | See also <c CILogCreateStorage>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogCreateStorage2A, IUnknown)
{
	// @comm IUnknown methods: See <c CILogCreateStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogCreateStorage methods: See <c CILogCreateStorage>.
	
 	STDMETHOD  (CreateStorage)		(LPSTR ptstrFullFileSpec,ULONG ulLogSize, ULONG ulInitSig, BOOL fOverWrite, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval)				 	PURE;
	STDMETHOD  (CreateStream)		(LPSTR lpszStreamName)				 	PURE;

};

// ===============================
// INTERFACE: ILogCreateStorageW
// ===============================

// -----------------------------------------------------------------------
// @interface ILogCreateStorageW | See also <c CILogCreateStorage>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogCreateStorage2W, IUnknown)
{
	// @comm IUnknown methods: See <c CILogCreateStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogCreateStorage methods: See <c CILogCreateStorage>.
	
 	STDMETHOD  (CreateStorage)		(LPWSTR ptstrFullFileSpec,ULONG ulLogSize, ULONG ulInitSig, BOOL fOverWrite, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval)				 	PURE;
	STDMETHOD  (CreateStream)		(LPWSTR lpszStreamName)				 	PURE;

};
#endif _ILGCREA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilginit.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILogInit.H | Header for interface <i ILogInit>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGINIT_H
#	define _ILGINIT_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#define		ILogInit				ILogInit2A
#ifdef _UNICODE
#define		ILogInit2				ILogInit2W
#else
#define		ILogInit2				ILogInit2A
#endif



// ===============================
// INTERFACE: ILogInit
// ===============================

// TODO: In the interface comments, update the description.
// TODO: In the interface comments, update the usage.

// -----------------------------------------------------------------------
// @interface ILogInit | See also <c CILogInit>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogInit2A, IUnknown)
{
	// @comm IUnknown methods: See <c CILogInit>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogInit methods: See <c CILogInit>.
	
 	STDMETHOD  (Init)		(ULONG *pulStorageCapacity,ULONG *pulLogSpaceAvailable,LPSTR ptstrFullFileSpec,ULONG ulInitSig, BOOL fFixedSize, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval,UINT uiLogBuffers)				 	PURE;
};

// -----------------------------------------------------------------------
// @interface ILogInitW | See also <c CILogInit>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogInit2W, IUnknown)
{
	// @comm IUnknown methods: See <c CILogInit>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogInit methods: See <c CILogInit>.
	
 	STDMETHOD  (Init)		(ULONG *pulStorageCapacity,ULONG *pulLogSpaceAvailable,LPWSTR ptstrFullFileSpec,ULONG ulInitSig, BOOL fFixedSize, UINT uiTimerInterval,UINT uiFlushInterval,UINT uiChkPtInterval,UINT uiLogBuffers)				 	PURE;
};

#endif _ILGINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilgread.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILogRead.H | Header for interface <i ILogRead>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGREAD_H
#	define _ILGREAD_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogRead
// ===============================

//#define DUMPBUFFERSIZE 0x5230 (((RECORDSPACE /BYTESPERLINE)+1)*CHARSPERLINE) +  (8 * CHARSPERLINE) // data plus header space

#define BYTESPERLINE 16
#define CHARSPERLINE 80
#define DUMPBUFFERSIZE 0xA230 

typedef enum _DUMP_TYPE
	{
	 HEX_DUMP = 0,
	 SUMMARY_DUMP = 1,
	 RECORD_DUMP = 2
	} DUMP_TYPE;
 

typedef enum _LRP_SEEK
	{
	 LRP_START = -1,
	 LRP_END = -2,
	 LRP_CUR = 0
	} LRP_SEEK;

// -----------------------------------------------------------------------
// @interface ILogRead | See also <c CILogRead>.<nl><nl>
// Description:<nl>
//   Provide read functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogRead, IUnknown)
{
	// @comm IUnknown methods: See <c CILogRead>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogRead methods: See <c CILogRead>.
	
 	STDMETHOD  (ReadInit)	(void)				 	PURE;
 	STDMETHOD  (ReadLRP )	(LRP lrpLRPStart, ULONG * ulByteLength, USHORT* usUserType)	PURE;
 	STDMETHOD  (ReadNext )	(LRP *plrpLRP, ULONG * ulByteLength, USHORT* usUserType)				 	PURE;
 	STDMETHOD  (GetCurrentLogRecord )	(char *pchBuffer)	PURE;
	STDMETHOD  (SetPosition)(LRP lrpLRPPosition)PURE;
	STDMETHOD  (Seek) 		(LRP_SEEK llrpOrigin, LONG cbLogRecs, LRP* plrpNewLRP) PURE;
	STDMETHOD  (GetCheckpoint)   (DWORD cbNumCheckpoint, LRP* plrpLRP) PURE;
	STDMETHOD  (DumpLog)  (ULONG ulStartPage, ULONG ulEndPage, DUMP_TYPE ulDumpType, CHAR *szFileName) PURE;
    STDMETHOD  (DumpPage) (CHAR * pchOutBuffer, ULONG ulPageNumber, DUMP_TYPE ulDumpType, ULONG *pulLength) PURE;

	virtual CHAR * DumpLRP (LRP lrpTarget,CHAR *szFormat,DUMP_TYPE ulDumpType, ULONG *pulLength) PURE;
			

};

#endif _ILGREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilgwrite.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILOGWRITE.H | Header for interface <i ILogWrite>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGWRITE_H
#	define _ILGWRITE_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogWrite
// ===============================


// -----------------------------------------------------------------------
// @interface ILogWrite | See also <c CILogWrite>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogWrite, IUnknown)
{
	// @comm IUnknown methods: See <c CILogWrite>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogWrite methods: See <c CILogWrite>.
	
 	STDMETHOD  (Append)	(LOGREC* rgLogRecords, ULONG cbNumRecs, LRP *rgLRP,ULONG* pcbNumRecs,LRP* pLRPLastPerm, BOOL fFlushNow,ULONG* pulAvailableSpace)				 	PURE;
	STDMETHOD  (SetCheckpoint) (LRP lrpLatestCheckpoint)				 	PURE;
};

#endif _ILGWRITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilgwrta.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILOGWRTA.H | Header for interface <i ILogWriteAsynch>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 06/02/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGWRTA_H
#	define _ILGWRTA_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#include "logrec.h"  // logmgr general types

class CAsynchSupport; //forward class declaration

// ===============================
// INTERFACE: ILogWriteAsynch
// ===============================

// TODO: In the interface comments, update the description.
// TODO: In the interface comments, update the usage.

// -----------------------------------------------------------------------
// @interface ILogWriteAsynch | See also <c CILogWriteAsynch>.<nl><nl>
// Description:<nl>
//   Provide append functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogWriteAsynch, IUnknown)
{
	// @comm IUnknown methods: See <c CILogWriteAsynch>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogWriteAsynch methods: See <c CILogWriteAsynch>.
	
 	STDMETHOD  (Init)	(ULONG cbMaxOutstandingWrites)				 	PURE;
 	STDMETHOD  (AppendAsynch)	(LOGREC* lgrLogRecord, LRP* plrpLRP, CAsynchSupport* pCAsynchSupport,BOOL fFlushHint,ULONG* pulAvailableSpace)				 	PURE;
	STDMETHOD  (SetCheckpoint) (LRP lrpLatestCheckpoint,CAsynchSupport* pCAsynchSupport, LRP* plrpCheckpointLogged)				 	PURE;

};

#endif _ILGWRTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilgstor.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILGSTOR.H | Header for interface <i ILogStorage>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 10/18/94 | rcraig | Created: For WPGEP COM lab.
// @rev 1 | 04/04/95 | rcraig | Updated: For Viper COM DLL templates.
// @rev 2 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILGSTOR_H
#	define _ILGSTOR_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

typedef enum _tagSTREAMMODE
{
    STRMMODEREAD        = 0x00000001, //@emem READ mode
    STRMMODEWRITE       = 0x00000002  //@emem WRITE mode
} STRMMODE;




// ===============================
// INTERFACE: ILogStorage
// ===============================


// -----------------------------------------------------------------------
// @interface ILogStorage | See also <c CILogStorage>.<nl><nl>
// Description:<nl>
//   Provide the physical log storage abstraction<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------
DECLARE_INTERFACE_ (ILogStorage, IUnknown)
{
	// @comm IUnknown methods: See <c CILogStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogStorage methods: See <c CILogStorage>.
	
 	STDMETHOD  (OpenLogStream)				(LPSTR lpszStreamName, DWORD grfMode, LPVOID FAR* ppvStream)				 	PURE;
 	STDMETHOD  (OpenLogStreamByClassID)		(CLSID clsClassID, DWORD grfMode, LPVOID FAR* ppvStream)				 	PURE;
 	STDMETHOD  (LogFlush)				(void)				 	PURE;
    virtual ULONG	   (GetLogSpaceNeeded)	(ULONG ulRecSize)		    PURE;
};

DECLARE_INTERFACE_ (ILogStorageInfo, IUnknown)
{
	// @comm IUnknown methods: See <c CILogStorage>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	virtual ULONG (GetLogGenerationNum) () PURE;
	virtual ULONGLONG (GetTimeTakenToWrap) () PURE;
};

#endif _ILGSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ilrp.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// @doc
// @module ILRP.H | Header for interface <i ILogRecordPointer>.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 05/09/95 | rbarnes | Cloned: For LOGMGR.DLL
// -----------------------------------------------------------------------


#ifndef _ILRP_H
#	define _ILRP_H

// ===============================
// INCLUDES:
// ===============================


#include <objbase.h>                                         

#include "logrec.h"  // logmgr general types

// ===============================
// INTERFACE: ILogRecordPointer
// ===============================


// -----------------------------------------------------------------------
// @interface ILogRecordPointer | See also <c CILogRecordPointer>.<nl><nl>
// Description:<nl>
//   Provide LRP functionality<nl><nl>
// Usage:<nl>
//   Useless, but for an example.
// -----------------------------------------------------------------------



DECLARE_INTERFACE_ (ILogRecordPointer, IUnknown)
{
	// @comm IUnknown methods: See <c CILogRecordPointer>.
	STDMETHOD  (QueryInterface)				(THIS_ REFIID i_riid, LPVOID FAR* o_ppv) 					PURE;
 	STDMETHOD_ (ULONG, AddRef)				(THIS) 														PURE;
 	STDMETHOD_ (ULONG, Release)				(THIS) 														PURE;

	// @comm ILogRecordPointer methods: See <c CILogRecordPointer>.
	
 	virtual DWORD  (CompareLRP)		(LRP lrpLRP1, LRP lrpLRP2)				 	PURE;
 	STDMETHOD  (LastPermLRP)	(LRP* plrpLRP)    PURE;
 	STDMETHOD  (GetLRPSize)	(LRP  lrpLRP, DWORD *pcbSize)    PURE;

};

#endif _ILRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\isltrack.h ===
#ifndef _ISLTRACK_H_
#define _ISLTRACK_H_

#if defined(ENABLE_TRACK)

//===========================================================================
//
// Interface: IShellLinkTracker
//
//  The IShellLinkTracker interface is used to access the ShellLink's
// CTracker object.  For example, Monikers call this interface to set
// the creation flags in the CTracker.
//
//
// [Member functions]
//
//    Initialize
//          This function is called to set the Creation Flags on
//          a ShellLinkTracker object
//
//          Parameters: [DWORD] dwCreationFlags
//
//    GetTrackFlags
//          This function is used to get the creation flags (known externally
//          as "track flags").
//  
//          Parameters: [DWORD *] pdwTrackFlags
//
//    Resolve
//          This function resolves the shell link, searching for the
//          link if necessary.
//
//          Parameters: [HWND] hwnd
//                          -   The window of the caller (can be GetDesktopWindow()).
//                      [DWORD] fFlags
//                          -   Flags to control the Resolve, from the SLR_ enumeration.
//                      [DWORD] dwRestricted
//                          -   Track Flags to be OR-ed with the ShellLink object's
//                              internal Track Flags (a.k.a. Creation Flags).
//                      [DWORD] dwTickCountDeadline
//                          -   The maximum amount of time, in milliseconds, for
//                              which a search should execute (if a search is necessary).
//                      
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellLinkTracker

DECLARE_INTERFACE_(IShellLinkTracker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IShellLinkTracker methods ***
    STDMETHOD(Initialize)(THIS_
                          DWORD dwTrackFlags) PURE;
    STDMETHOD(GetTrackFlags)(THIS_
                             DWORD * pdwTrackFlags) PURE;
    STDMETHOD(Resolve)(THIS_
                       HWND        hwnd,
                       DWORD       fFlags,
                       DWORD       dwRestriction,
                       DWORD       dwTickCountDeadline,
                       DWORD       dwReserved ) PURE;


};


typedef IShellLinkTracker * LPSHELLLINKTRACKER;

DEFINE_GUID(IID_IShellLinkTracker, 0x5E35D200L, 0xF3BB, 0x11CE, 0x9B, 0xDB, 0x00, 0xAA, 0x00, 0x4C, 0xD0, 0x1A);

#endif  // _CAIRO_
#endif  // _ISLTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\logmgrgu.h ===
// -----------------------------------------------------------------------
// Microsoft Distributed Transaction Coordinator (Microsoft Confidential)
// Copyright 1994 - 1995 Microsoft Corporation.  All Rights Reserved.
// @doc
// @module COMT_GU.H | Header for all project guids.<nl><nl>
// Description:<nl>
//   All project guids are declared here.<nl><nl>
// Usage:<nl>
//   Clients of this DLL require this file.
// @rev 0 | 5/09/95 | rbarnes | Created - note that the following are
//                             reserved
//                             d959f1b9-9e42-11ce-8bca-0080c7a01d7f
// -----------------------------------------------------------------------


#ifndef _LGMGRGU_H
#	define _LGMGRGU_H

// ===============================
// INCLUDES:
// ===============================

// TODO: KEEP: For each set of <n> guids added to this project:
// 		 - Run command-line utility "UUIDGEN -s -n<n> -o<path and file>.tmp".
//       - Copy the tmp file contents; paste them to the end of the guids below.
//		 - Assign each guid a name with a prefix of "CLSID_", "IID_", or "GUID_".
//       - Convert each INTERFACENAME struct to the illustrated DEFINE_GUID format.


// CLSID_CLgMgr: {d959f1b0-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (CLSID_CLogMgr, 0xd959f1b0, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);


// IID_ILogStorage: {d959f1b1-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogStorage, 0xd959f1b1, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogStorageInfo:{E3D46FD4-7265-4140-8387-2B897E1CB298}
DEFINE_GUID(IID_ILogStorageInfo, 0xe3d46fd4, 0x7265, 0x4140, 0x83, 0x87, 0x2b, 0x89, 0x7e, 0x1c, 0xb2, 0x98);


// IID_ILogRead: {d959f1b2-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogRead, 0xd959f1b2, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogWrite: {d959f1b3-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogWrite, 0xd959f1b3, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogRecordPointer: {d959f1b4-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogRecordPointer,0xd959f1b4, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogInit: {d959f1b5-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogInit, 0xd959f1b5, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

#define IID_ILogInit2A		IID_ILogInit

// IID_ILogInit2W: {22CA6409-7693-11d2-8C0F-00805F0DF75A}
DEFINE_GUID(IID_ILogInit2W, 0x22ca6409, 0x7693, 0x11d2, 0x8c, 0xf, 0x0, 0x80, 0x5f, 0xd, 0xf7, 0x5a);

// IID_ILogWriteAsynch: {d959f1b6-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogWriteAsynch, 0xd959f1b6, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogCreateStorage2A: {d959f1b7-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogCreateStorage2A, 0xd959f1b7, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

// IID_ILogCreateStorage2W: {C6856001-7695-11d2-8C0F-00805F0DF75A}
DEFINE_GUID(IID_ILogCreateStorage2W, 0xc6856001, 0x7695, 0x11d2, 0x8c, 0xf, 0x0, 0x80, 0x5f, 0xd, 0xf7, 0x5a);

#define IID_ILogCreateStorage IID_ILogCreateStorage2A

#ifdef _UNICODE
#define IID_ILogCreateStorage2 IID_ILogCreateStorage2W
#else
#define IID_ILogCreateStorage2 IID_ILogCreateStorage2A
#endif

// IID_ILogUISConnect: {d959f1b8-9e42-11ce-8b97-0080c7a01d7f}
DEFINE_GUID (IID_ILogUISConnect, 0xd959f1b8, 0x9e42, 0x11ce, 0x8b, 0x97, 0x00, 0x80, 0xc7, 0xa0, 0x1d, 0x7f);

#endif _LGMGRGU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\machnames.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for machnames.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __machnames_h__
#define __machnames_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILocalMachineNames_FWD_DEFINED__
#define __ILocalMachineNames_FWD_DEFINED__
typedef interface ILocalMachineNames ILocalMachineNames;
#endif 	/* __ILocalMachineNames_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ILocalMachineNames_INTERFACE_DEFINED__
#define __ILocalMachineNames_INTERFACE_DEFINED__

/* interface ILocalMachineNames */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_ILocalMachineNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000015A-0000-0000-C000-000000000046")
    ILocalMachineNames : public IEnumString
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshNames( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocalMachineNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocalMachineNames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocalMachineNames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocalMachineNames * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            ILocalMachineNames * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPOLESTR *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ILocalMachineNames * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ILocalMachineNames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ILocalMachineNames * This,
            /* [out] */ IEnumString **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshNames )( 
            ILocalMachineNames * This);
        
        END_INTERFACE
    } ILocalMachineNamesVtbl;

    interface ILocalMachineNames
    {
        CONST_VTBL struct ILocalMachineNamesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocalMachineNames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILocalMachineNames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILocalMachineNames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILocalMachineNames_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define ILocalMachineNames_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ILocalMachineNames_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ILocalMachineNames_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)


#define ILocalMachineNames_RefreshNames(This)	\
    (This)->lpVtbl -> RefreshNames(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILocalMachineNames_RefreshNames_Proxy( 
    ILocalMachineNames * This);


void __RPC_STUB ILocalMachineNames_RefreshNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILocalMachineNames_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_machnames_0097 */
/* [local] */ 


EXTERN_C const CLSID CLSID_LocalMachineNames;



extern RPC_IF_HANDLE __MIDL_itf_machnames_0097_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_machnames_0097_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\ntrpcp.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    ntrpcp.h

Abstract:

    This file contains prototypes for commonly used RPC functionality.
    This includes: bind/unbind functions, MIDL user alloc/free functions,
    and server start/stop functions.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    03-July-1991    JimK
        Commonly used aspects copied from LM specific file.

--*/
#ifndef _NTRPCP_
#define _NTRPCP_

#include <nt.h>
#include <ntrtl.h>          // needed for nturtl.h
#include <nturtl.h>
#include <windows.h>        // win32 typedefs
#include <rpc.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// DEFINES
//



//
// Function Prototypes - routines called by MIDL-generated code:
//

void *
MIDL_user_allocate(
    IN size_t NumBytes
    );

void
MIDL_user_free(
    IN void *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

//
// client side functions
//


NTSTATUS
RpcpBindRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

NTSTATUS
RpcpUnbindRpc(
    IN  RPC_BINDING_HANDLE BindingHandle
    );



//
// server side functions
//

NTSTATUS
RpcpInitRpcServer(
    VOID
    );

NTSTATUS
RpcpAddInterface(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

NTSTATUS
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

NTSTATUS
RpcpDeleteInterface(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

NTSTATUS
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

NTSTATUS
RpcpStopRpcServerEx(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

#ifdef __cplusplus
}
#endif

#endif // _NTRPCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\olechar.h ===
//+======================================================
//
//  File:       olechar.h
//
//  Purpose:    Provide wrappers for string-related
//              functions so that the Ansi or Unicode function
//              is called, whichever is appropriate for the
//              current OLECHAR definition.
//
//              This file is similar to "tchar.h", except
//              that it covers OLECHARs rather than TCHARs.
//
//+======================================================


#ifndef _OLECHAR_H_
#define _OLECHAR_H_

//#include <objbase.h>

#ifdef OLE2ANSI

#   ifdef _MAC
#       define ocslen      strlen
#       define ocscpy      strcpy
#       define ocscmp      strcmp
#       define ocscat      strcat
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   else
#       define ocslen      lstrlenA
#       define ocscpy      lstrcpyA
#       define ocscmp      lpstrcmpA
#       define ocscat      lpstrcatA
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultoa( (value), (string), (radix) )

#else // !OLE2ANSI

#   ifdef IPROPERTY_DLL
#       define ocslen      lstrlenW
#       define ocscpy      wcscpy
#       define ocscmp      wcscmp
#       define ocscat      wcscat
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   else
#       define ocslen      lstrlenW
#       define ocscpy      lstrcpyW
#       define ocscmp      lstrcmpW
#       define ocscat      lstrcatW
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultow( (value), (string), (radix) )

#endif // !OLE2ANSI

#endif // !_OLECHAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\logrec.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __LOGREC_H__
  #define __LOGREC_H__


#define DUMMYNDX 	1


//+---------------------------------------------------------------------------
//  Structure: LRP           (lrp)
//
//  The following type is used to identify a log record by a Log
//  Record Pointer.
//
//----------------------------------------------------------------------------

typedef ULARGE_INTEGER 	LRP;		// lrp

typedef ULARGE_INTEGER 	LSN;		// lsn

/*
 * @struct LOGREC|
 *      LogRec for ILogWrite::Append.  This interface 
 *      takes a pointer to a LogRec along with a count of how
 *      many other LogRec pointers to expect to describe pieces of the caller's buffer
 *      which are supposed to be copied in sequence to the log file.
 *
 *  hungarian lrec
 */

typedef struct _LOGREC		//lrec
{    
	CHAR	*pchBuffer; 	//@field pointer to the buffer
    ULONG  	ulByteLength; 	//@field the length
	USHORT  usUserType; 	//@field The client specified log record type
    USHORT  usSysRecType; 	//@field The log manager defined log record types
} LOGREC;


/*
 * @struct WRITELISTELEMENT |
 * 		Write Entry for RecOMLogWriteList.  The interface to these
 * 		routines takes a pointer to a Write Entry List Element.  These elements can
 * 		be chained together.  The caller is required to put a value of NULL in the
 * 		last element of the chain.
 *
 * hungarian wle
 */

typedef struct _WRITELISTELEMENT 	  		// wle
{    
    struct 	_WRITELISTELEMENT *pwleNext;	//@field The next pointer
    ULONG 	ulByteLength;                 	//@field The length
    CHAR 	ab[DUMMYNDX];                  	//@field Start of data
} WRITELISTELEMENT;

// Declaration for asynch completion callback

class CAsynchSupport
{
//@access Public Members
public:
	//@cmember 	Destructor
    virtual ~CAsynchSupport() { ; }

  	//@cmember 	This operation is called after an asynch write completes
    virtual VOID  AppendCallback(HRESULT hr, LRP lrpAppendLRP) = 0;

  	//@cmember 	This operation is called after a SetCheckpoint completes
    virtual VOID  ChkPtCallback(HRESULT hr, LRP lrpAppendLRP) = 0;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\logconst.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Logconst.h
//
// Log manager global constants
//

#ifndef __LOGCONST__H__

#define __LOGCONST__H__

// ===============================
// CONSTANTS:
// ===============================

#define MIN_LOG_TIMER_INTERVAL 		 5 				//milliseconds

#define DEFAULT_LOG_TIMER_INTERVAL	 10 			//milliseconds

#define MAX_LOG_TIMER_INTERVAL		((ULONG) -1)	//milliseconds

#define MIN_LOG_FLUSH_INTERVAL 		 5 				//milliseconds

#define DEFAULT_LOG_FLUSH_INTERVAL	 50 			//milliseconds

#define MAX_LOG_FLUSH_INTERVAL		1000			//milliseconds

#define MIN_LOG_CHKPT_INTERVAL 		 100 			//milliseconds

#define DEFAULT_LOG_CHKPT_INTERVAL	 50000 	//milliseconds

#define MAX_LOG_CHKPT_INTERVAL		((ULONG) -1)	//milliseconds

#define MAX_OUTSTANDING_CHKPT		25

#define MIN_LOG_BUFFERS					50

#define MAX_LOG_BUFFERS					500

#define DEFAULT_LOG_BUFFERS				200

#define INIT_GENERATION_NO		1

#define MIN_GENERATION_NO       2

#define MINFORCEFLUSH 20 //percentage of outstanding asynch writes threshold for forcing flush

#define MINFLUSHCOUNT 3  // minimum number of writes outstanding to force flush

#define LOGMGRSAVEDSPACE 4 //number of pages to "save" for the logmgr 

#define DLLGETDTCLOGFN2_STR "DllGetDTCLOG2"
typedef HRESULT (* DLLGETDTCLOG2_FN) (REFCLSID clsid, REFIID riid, void ** ppv);

STDMETHODIMP InitLog
					(
						LPWSTR pwszLogPath,
						DWORD dwTimer,
						DWORD dwCheckpoint,
						DWORD dwFlush,
						DWORD dwSize,
						BOOL fFailIfThere,
						BOOL fUpdateFilesNotToBackupKey
					);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\partitions.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for partitions.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __partitions_h__
#define __partitions_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUserToken_FWD_DEFINED__
#define __IUserToken_FWD_DEFINED__
typedef interface IUserToken IUserToken;
#endif 	/* __IUserToken_FWD_DEFINED__ */


#ifndef __IPartitionProperty_FWD_DEFINED__
#define __IPartitionProperty_FWD_DEFINED__
typedef interface IPartitionProperty IPartitionProperty;
#endif 	/* __IPartitionProperty_FWD_DEFINED__ */


#ifndef __IPartitionLookup_FWD_DEFINED__
#define __IPartitionLookup_FWD_DEFINED__
typedef interface IPartitionLookup IPartitionLookup;
#endif 	/* __IPartitionLookup_FWD_DEFINED__ */


#ifndef __IReplaceClassInfo_FWD_DEFINED__
#define __IReplaceClassInfo_FWD_DEFINED__
typedef interface IReplaceClassInfo IReplaceClassInfo;
#endif 	/* __IReplaceClassInfo_FWD_DEFINED__ */


#ifndef __IGetCatalogObject_FWD_DEFINED__
#define __IGetCatalogObject_FWD_DEFINED__
typedef interface IGetCatalogObject IGetCatalogObject;
#endif 	/* __IGetCatalogObject_FWD_DEFINED__ */


#ifndef __IComCatalogInternal_FWD_DEFINED__
#define __IComCatalogInternal_FWD_DEFINED__
typedef interface IComCatalogInternal IComCatalogInternal;
#endif 	/* __IComCatalogInternal_FWD_DEFINED__ */


#ifndef __IComCatalog2Internal_FWD_DEFINED__
#define __IComCatalog2Internal_FWD_DEFINED__
typedef interface IComCatalog2Internal IComCatalog2Internal;
#endif 	/* __IComCatalog2Internal_FWD_DEFINED__ */


#ifndef __IComCatalogLocation_FWD_DEFINED__
#define __IComCatalogLocation_FWD_DEFINED__
typedef interface IComCatalogLocation IComCatalogLocation;
#endif 	/* __IComCatalogLocation_FWD_DEFINED__ */


#ifndef __ICacheControl_FWD_DEFINED__
#define __ICacheControl_FWD_DEFINED__
typedef interface ICacheControl ICacheControl;
#endif 	/* __ICacheControl_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IUserToken_INTERFACE_DEFINED__
#define __IUserToken_INTERFACE_DEFINED__

/* interface IUserToken */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IUserToken;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FC-0000-0000-C000-000000000046")
    IUserToken : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUserClassesRootKey( 
            /* [out] */ HKEY *phKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseUserClassesRootKey( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserSid( 
            /* [out] */ BYTE **ppSid,
            /* [out] */ USHORT *pcbSid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserToken( 
            /* [out] */ HANDLE *phToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserTokenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserToken * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserToken * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserClassesRootKey )( 
            IUserToken * This,
            /* [out] */ HKEY *phKey);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseUserClassesRootKey )( 
            IUserToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserSid )( 
            IUserToken * This,
            /* [out] */ BYTE **ppSid,
            /* [out] */ USHORT *pcbSid);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserToken )( 
            IUserToken * This,
            /* [out] */ HANDLE *phToken);
        
        END_INTERFACE
    } IUserTokenVtbl;

    interface IUserToken
    {
        CONST_VTBL struct IUserTokenVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserToken_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserToken_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserToken_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserToken_GetUserClassesRootKey(This,phKey)	\
    (This)->lpVtbl -> GetUserClassesRootKey(This,phKey)

#define IUserToken_ReleaseUserClassesRootKey(This)	\
    (This)->lpVtbl -> ReleaseUserClassesRootKey(This)

#define IUserToken_GetUserSid(This,ppSid,pcbSid)	\
    (This)->lpVtbl -> GetUserSid(This,ppSid,pcbSid)

#define IUserToken_GetUserToken(This,phToken)	\
    (This)->lpVtbl -> GetUserToken(This,phToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserToken_GetUserClassesRootKey_Proxy( 
    IUserToken * This,
    /* [out] */ HKEY *phKey);


void __RPC_STUB IUserToken_GetUserClassesRootKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserToken_ReleaseUserClassesRootKey_Proxy( 
    IUserToken * This);


void __RPC_STUB IUserToken_ReleaseUserClassesRootKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserToken_GetUserSid_Proxy( 
    IUserToken * This,
    /* [out] */ BYTE **ppSid,
    /* [out] */ USHORT *pcbSid);


void __RPC_STUB IUserToken_GetUserSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserToken_GetUserToken_Proxy( 
    IUserToken * This,
    /* [out] */ HANDLE *phToken);


void __RPC_STUB IUserToken_GetUserToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserToken_INTERFACE_DEFINED__ */


#ifndef __IPartitionProperty_INTERFACE_DEFINED__
#define __IPartitionProperty_INTERFACE_DEFINED__

/* interface IPartitionProperty */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IPartitionProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F2-0000-0000-C000-000000000046")
    IPartitionProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPartitionID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPartitionID( 
            /* [in] */ GUID *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartitionPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartitionProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartitionProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartitionProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartitionID )( 
            IPartitionProperty * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartitionID )( 
            IPartitionProperty * This,
            /* [in] */ GUID *pGuid);
        
        END_INTERFACE
    } IPartitionPropertyVtbl;

    interface IPartitionProperty
    {
        CONST_VTBL struct IPartitionPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartitionProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPartitionProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPartitionProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPartitionProperty_GetPartitionID(This,pGuid)	\
    (This)->lpVtbl -> GetPartitionID(This,pGuid)

#define IPartitionProperty_SetPartitionID(This,pGuid)	\
    (This)->lpVtbl -> SetPartitionID(This,pGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPartitionProperty_GetPartitionID_Proxy( 
    IPartitionProperty * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB IPartitionProperty_GetPartitionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionProperty_SetPartitionID_Proxy( 
    IPartitionProperty * This,
    /* [in] */ GUID *pGuid);


void __RPC_STUB IPartitionProperty_SetPartitionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPartitionProperty_INTERFACE_DEFINED__ */


#ifndef __IPartitionLookup_INTERFACE_DEFINED__
#define __IPartitionLookup_INTERFACE_DEFINED__

/* interface IPartitionLookup */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IPartitionLookup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F8-0000-0000-C000-000000000046")
    IPartitionLookup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultPartitionForUser( 
            /* [out] */ IPartitionProperty **ppPartitionProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPartitionValidForUser( 
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultPartitionForUserByToken( 
            /* [in] */ IUserToken *pUserToken,
            /* [out] */ IPartitionProperty **ppPartitionProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPartitionValidForUserByToken( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLocalStoreEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDSLookupEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartitionLookupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartitionLookup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartitionLookup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartitionLookup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultPartitionForUser )( 
            IPartitionLookup * This,
            /* [out] */ IPartitionProperty **ppPartitionProperty);
        
        HRESULT ( STDMETHODCALLTYPE *IsPartitionValidForUser )( 
            IPartitionLookup * This,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultPartitionForUserByToken )( 
            IPartitionLookup * This,
            /* [in] */ IUserToken *pUserToken,
            /* [out] */ IPartitionProperty **ppPartitionProperty);
        
        HRESULT ( STDMETHODCALLTYPE *IsPartitionValidForUserByToken )( 
            IPartitionLookup * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid);
        
        HRESULT ( STDMETHODCALLTYPE *IsLocalStoreEnabled )( 
            IPartitionLookup * This,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *IsDSLookupEnabled )( 
            IPartitionLookup * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } IPartitionLookupVtbl;

    interface IPartitionLookup
    {
        CONST_VTBL struct IPartitionLookupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartitionLookup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPartitionLookup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPartitionLookup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPartitionLookup_GetDefaultPartitionForUser(This,ppPartitionProperty)	\
    (This)->lpVtbl -> GetDefaultPartitionForUser(This,ppPartitionProperty)

#define IPartitionLookup_IsPartitionValidForUser(This,pguidPartitionId,pfIsPartitionValid)	\
    (This)->lpVtbl -> IsPartitionValidForUser(This,pguidPartitionId,pfIsPartitionValid)

#define IPartitionLookup_GetDefaultPartitionForUserByToken(This,pUserToken,ppPartitionProperty)	\
    (This)->lpVtbl -> GetDefaultPartitionForUserByToken(This,pUserToken,ppPartitionProperty)

#define IPartitionLookup_IsPartitionValidForUserByToken(This,pUserToken,pguidPartitionId,pfIsPartitionValid)	\
    (This)->lpVtbl -> IsPartitionValidForUserByToken(This,pUserToken,pguidPartitionId,pfIsPartitionValid)

#define IPartitionLookup_IsLocalStoreEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsLocalStoreEnabled(This,pfEnabled)

#define IPartitionLookup_IsDSLookupEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsDSLookupEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPartitionLookup_GetDefaultPartitionForUser_Proxy( 
    IPartitionLookup * This,
    /* [out] */ IPartitionProperty **ppPartitionProperty);


void __RPC_STUB IPartitionLookup_GetDefaultPartitionForUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsPartitionValidForUser_Proxy( 
    IPartitionLookup * This,
    /* [in] */ GUID *pguidPartitionId,
    /* [out] */ BOOL *pfIsPartitionValid);


void __RPC_STUB IPartitionLookup_IsPartitionValidForUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_GetDefaultPartitionForUserByToken_Proxy( 
    IPartitionLookup * This,
    /* [in] */ IUserToken *pUserToken,
    /* [out] */ IPartitionProperty **ppPartitionProperty);


void __RPC_STUB IPartitionLookup_GetDefaultPartitionForUserByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsPartitionValidForUserByToken_Proxy( 
    IPartitionLookup * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ GUID *pguidPartitionId,
    /* [out] */ BOOL *pfIsPartitionValid);


void __RPC_STUB IPartitionLookup_IsPartitionValidForUserByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsLocalStoreEnabled_Proxy( 
    IPartitionLookup * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IPartitionLookup_IsLocalStoreEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsDSLookupEnabled_Proxy( 
    IPartitionLookup * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IPartitionLookup_IsDSLookupEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPartitionLookup_INTERFACE_DEFINED__ */


#ifndef __IReplaceClassInfo_INTERFACE_DEFINED__
#define __IReplaceClassInfo_INTERFACE_DEFINED__

/* interface IReplaceClassInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IReplaceClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FB-0000-0000-C000-000000000046")
    IReplaceClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplaceClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReplaceClassInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReplaceClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReplaceClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IReplaceClassInfo * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IReplaceClassInfoVtbl;

    interface IReplaceClassInfo
    {
        CONST_VTBL struct IReplaceClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplaceClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplaceClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplaceClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplaceClassInfo_GetClassInfo(This,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,guidConfiguredClsid,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReplaceClassInfo_GetClassInfo_Proxy( 
    IReplaceClassInfo * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IReplaceClassInfo_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplaceClassInfo_INTERFACE_DEFINED__ */


#ifndef __IGetCatalogObject_INTERFACE_DEFINED__
#define __IGetCatalogObject_INTERFACE_DEFINED__

/* interface IGetCatalogObject */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IGetCatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FE-0000-0000-C000-000000000046")
    IGetCatalogObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogObject( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetCatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetCatalogObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetCatalogObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetCatalogObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogObject )( 
            IGetCatalogObject * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IGetCatalogObjectVtbl;

    interface IGetCatalogObject
    {
        CONST_VTBL struct IGetCatalogObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetCatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetCatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetCatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetCatalogObject_GetCatalogObject(This,riid,ppv)	\
    (This)->lpVtbl -> GetCatalogObject(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetCatalogObject_GetCatalogObject_Proxy( 
    IGetCatalogObject * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IGetCatalogObject_GetCatalogObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetCatalogObject_INTERFACE_DEFINED__ */


#ifndef __IComCatalogInternal_INTERFACE_DEFINED__
#define __IComCatalogInternal_INTERFACE_DEFINED__

/* interface IComCatalogInternal */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6304910-4115-11d2-8133-0060089f5fed")
    IComCatalogInternal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalogInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        END_INTERFACE
    } IComCatalogInternalVtbl;

    interface IComCatalogInternal
    {
        CONST_VTBL struct IComCatalogInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogInternal_GetClassInfo(This,pUserToken,guidConfiguredClsid,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetClassInfo(This,pUserToken,guidConfiguredClsid,riid,ppv,pvReserved)

#define IComCatalogInternal_GetApplicationInfo(This,pUserToken,guidApplId,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetApplicationInfo(This,pUserToken,guidApplId,riid,ppv,pvReserved)

#define IComCatalogInternal_GetProcessInfo(This,pUserToken,guidProcess,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetProcessInfo(This,pUserToken,guidProcess,riid,ppv,pvReserved)

#define IComCatalogInternal_GetServerGroupInfo(This,pUserToken,guidServerGroup,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,pUserToken,guidServerGroup,riid,ppv,pvReserved)

#define IComCatalogInternal_GetRetQueueInfo(This,pUserToken,wszFormatName,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,pUserToken,wszFormatName,riid,ppv,pvReserved)

#define IComCatalogInternal_GetApplicationInfoForExe(This,pUserToken,pwszExeName,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pUserToken,pwszExeName,riid,ppv,pvReserved)

#define IComCatalogInternal_GetTypeLibrary(This,pUserToken,guidTypeLib,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pUserToken,guidTypeLib,riid,ppv,pvReserved)

#define IComCatalogInternal_GetInterfaceInfo(This,pUserToken,iidInterface,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,pUserToken,iidInterface,riid,ppv,pComCatalog)

#define IComCatalogInternal_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalogInternal_GetClassInfoFromProgId(This,pUserToken,pwszProgID,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pUserToken,pwszProgID,riid,ppv,pComCatalog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetClassInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetApplicationInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetProcessInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetServerGroupInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetRetQueueInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetApplicationInfoForExe_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetTypeLibrary_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetInterfaceInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalogInternal_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_FlushCache_Proxy( 
    IComCatalogInternal * This);


void __RPC_STUB IComCatalogInternal_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetClassInfoFromProgId_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalogInternal_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogInternal_INTERFACE_DEFINED__ */


#ifndef __IComCatalog2Internal_INTERFACE_DEFINED__
#define __IComCatalog2Internal_INTERFACE_DEFINED__

/* interface IComCatalog2Internal */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog2Internal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3310dab4-edc0-4ce9-8a9c-8fea2980fd89")
    IComCatalog2Internal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByPartition( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByApplication( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalog2InternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog2Internal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog2Internal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog2Internal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByPartition )( 
            IComCatalog2Internal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByApplication )( 
            IComCatalog2Internal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        END_INTERFACE
    } IComCatalog2InternalVtbl;

    interface IComCatalog2Internal
    {
        CONST_VTBL struct IComCatalog2InternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog2Internal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog2Internal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog2Internal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog2Internal_GetClassInfoByPartition(This,pUserToken,guidConfiguredClsid,guidPartitionId,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoByPartition(This,pUserToken,guidConfiguredClsid,guidPartitionId,riid,ppv,pComCatalog)

#define IComCatalog2Internal_GetClassInfoByApplication(This,pUserToken,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoByApplication(This,pUserToken,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv,pComCatalog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog2Internal_GetClassInfoByPartition_Proxy( 
    IComCatalog2Internal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalog2Internal_GetClassInfoByPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2Internal_GetClassInfoByApplication_Proxy( 
    IComCatalog2Internal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalog2Internal_GetClassInfoByApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog2Internal_INTERFACE_DEFINED__ */


#ifndef __IComCatalogLocation_INTERFACE_DEFINED__
#define __IComCatalogLocation_INTERFACE_DEFINED__

/* interface IComCatalogLocation */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fae51051-9887-47f2-af44-7392bf90039b")
    IComCatalogLocation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCatalogLocation( 
            /* [in] */ BOOL bInSCM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogLocation( 
            /* [out] */ BOOL *pbInSCM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogLocation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogLocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogLocation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCatalogLocation )( 
            IComCatalogLocation * This,
            /* [in] */ BOOL bInSCM);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogLocation )( 
            IComCatalogLocation * This,
            /* [out] */ BOOL *pbInSCM);
        
        END_INTERFACE
    } IComCatalogLocationVtbl;

    interface IComCatalogLocation
    {
        CONST_VTBL struct IComCatalogLocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogLocation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogLocation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogLocation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogLocation_SetCatalogLocation(This,bInSCM)	\
    (This)->lpVtbl -> SetCatalogLocation(This,bInSCM)

#define IComCatalogLocation_GetCatalogLocation(This,pbInSCM)	\
    (This)->lpVtbl -> GetCatalogLocation(This,pbInSCM)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogLocation_SetCatalogLocation_Proxy( 
    IComCatalogLocation * This,
    /* [in] */ BOOL bInSCM);


void __RPC_STUB IComCatalogLocation_SetCatalogLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogLocation_GetCatalogLocation_Proxy( 
    IComCatalogLocation * This,
    /* [out] */ BOOL *pbInSCM);


void __RPC_STUB IComCatalogLocation_GetCatalogLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogLocation_INTERFACE_DEFINED__ */


#ifndef __ICacheControl_INTERFACE_DEFINED__
#define __ICacheControl_INTERFACE_DEFINED__

/* interface ICacheControl */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_ICacheControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59a47420-0094-11d2-bbf7-0060089f5fed")
    ICacheControl : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE CacheAddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE CacheRelease( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICacheControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICacheControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *CacheAddRef )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *CacheRelease )( 
            ICacheControl * This);
        
        END_INTERFACE
    } ICacheControlVtbl;

    interface ICacheControl
    {
        CONST_VTBL struct ICacheControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICacheControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICacheControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICacheControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICacheControl_CacheAddRef(This)	\
    (This)->lpVtbl -> CacheAddRef(This)

#define ICacheControl_CacheRelease(This)	\
    (This)->lpVtbl -> CacheRelease(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE ICacheControl_CacheAddRef_Proxy( 
    ICacheControl * This);


void __RPC_STUB ICacheControl_CacheAddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE ICacheControl_CacheRelease_Proxy( 
    ICacheControl * This);


void __RPC_STUB ICacheControl_CacheRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICacheControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\privact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for privact.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __privact_h__
#define __privact_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IScmRequestInfo_FWD_DEFINED__
#define __IScmRequestInfo_FWD_DEFINED__
typedef interface IScmRequestInfo IScmRequestInfo;
#endif 	/* __IScmRequestInfo_FWD_DEFINED__ */


#ifndef __IScmReplyInfo_FWD_DEFINED__
#define __IScmReplyInfo_FWD_DEFINED__
typedef interface IScmReplyInfo IScmReplyInfo;
#endif 	/* __IScmReplyInfo_FWD_DEFINED__ */


#ifndef __IInstantiationInfo_FWD_DEFINED__
#define __IInstantiationInfo_FWD_DEFINED__
typedef interface IInstantiationInfo IInstantiationInfo;
#endif 	/* __IInstantiationInfo_FWD_DEFINED__ */


#ifndef __ILegacyInfo_FWD_DEFINED__
#define __ILegacyInfo_FWD_DEFINED__
typedef interface ILegacyInfo ILegacyInfo;
#endif 	/* __ILegacyInfo_FWD_DEFINED__ */


#ifndef __IInstanceInfo_FWD_DEFINED__
#define __IInstanceInfo_FWD_DEFINED__
typedef interface IInstanceInfo IInstanceInfo;
#endif 	/* __IInstanceInfo_FWD_DEFINED__ */


#ifndef __IPrivActivationContextInfo_FWD_DEFINED__
#define __IPrivActivationContextInfo_FWD_DEFINED__
typedef interface IPrivActivationContextInfo IPrivActivationContextInfo;
#endif 	/* __IPrivActivationContextInfo_FWD_DEFINED__ */


#ifndef __IActivationProperties_FWD_DEFINED__
#define __IActivationProperties_FWD_DEFINED__
typedef interface IActivationProperties IActivationProperties;
#endif 	/* __IActivationProperties_FWD_DEFINED__ */


#ifndef __IPrivActivationPropertiesOut_FWD_DEFINED__
#define __IPrivActivationPropertiesOut_FWD_DEFINED__
typedef interface IPrivActivationPropertiesOut IPrivActivationPropertiesOut;
#endif 	/* __IPrivActivationPropertiesOut_FWD_DEFINED__ */


#ifndef __IPrivActivationPropertiesIn_FWD_DEFINED__
#define __IPrivActivationPropertiesIn_FWD_DEFINED__
typedef interface IPrivActivationPropertiesIn IPrivActivationPropertiesIn;
#endif 	/* __IPrivActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IMarshalOptions_FWD_DEFINED__
#define __IMarshalOptions_FWD_DEFINED__
typedef interface IMarshalOptions IMarshalOptions;
#endif 	/* __IMarshalOptions_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"
#include "activate.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_privact_0000 */
/* [local] */ 

typedef struct _PRIV_SCM_INFO
    {
    long Apartment;
    /* [string] */ WCHAR *pwszWinstaDesktop;
    ULONG64 ProcessSignature;
    /* [size_is] */ WCHAR *pEnvBlock;
    DWORD EnvBlockLength;
    } 	PRIV_SCM_INFO;

typedef struct _PRIV_RESOLVER_INFO
    {
    OXID OxidServer;
    DUALSTRINGARRAY *pServerORBindings;
    OXID_INFO OxidInfo;
    MID LocalMidOfRemote;
    DWORD DllServerModel;
    /* [string] */ WCHAR *pwszDllServer;
    BOOL FoundInROT;
    } 	PRIV_RESOLVER_INFO;

typedef struct _REMOTE_REQUEST_SCM_INFO
    {
    DWORD ClientImpLevel;
    unsigned short cRequestedProtseqs;
    /* [size_is] */ unsigned short *pRequestedProtseqs;
    } 	REMOTE_REQUEST_SCM_INFO;

typedef struct _REMOTE_REPLY_SCM_INFO
    {
    OXID Oxid;
    DUALSTRINGARRAY *pdsaOxidBindings;
    IPID ipidRemUnknown;
    DWORD authnHint;
    COMVERSION serverVersion;
    } 	REMOTE_REPLY_SCM_INFO;



extern RPC_IF_HANDLE __MIDL_itf_privact_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_privact_0000_ServerIfHandle;

#ifndef __IScmRequestInfo_INTERFACE_DEFINED__
#define __IScmRequestInfo_INTERFACE_DEFINED__

/* interface IScmRequestInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IScmRequestInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AA-0000-0000-C000-000000000046")
    IScmRequestInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScmInfo( 
            /* [in] */ PRIV_SCM_INFO *pScmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScmInfo( 
            /* [out] */ PRIV_SCM_INFO **ppScmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemoteRequestInfo( 
            /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteRequestInfo( 
            /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScmRequestInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScmRequestInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScmRequestInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScmRequestInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetScmInfo )( 
            IScmRequestInfo * This,
            /* [in] */ PRIV_SCM_INFO *pScmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetScmInfo )( 
            IScmRequestInfo * This,
            /* [out] */ PRIV_SCM_INFO **ppScmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteRequestInfo )( 
            IScmRequestInfo * This,
            /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteRequestInfo )( 
            IScmRequestInfo * This,
            /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq);
        
        END_INTERFACE
    } IScmRequestInfoVtbl;

    interface IScmRequestInfo
    {
        CONST_VTBL struct IScmRequestInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScmRequestInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScmRequestInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScmRequestInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScmRequestInfo_SetScmInfo(This,pScmInfo)	\
    (This)->lpVtbl -> SetScmInfo(This,pScmInfo)

#define IScmRequestInfo_GetScmInfo(This,ppScmInfo)	\
    (This)->lpVtbl -> GetScmInfo(This,ppScmInfo)

#define IScmRequestInfo_SetRemoteRequestInfo(This,pRemoteReq)	\
    (This)->lpVtbl -> SetRemoteRequestInfo(This,pRemoteReq)

#define IScmRequestInfo_GetRemoteRequestInfo(This,ppRemoteReq)	\
    (This)->lpVtbl -> GetRemoteRequestInfo(This,ppRemoteReq)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScmRequestInfo_SetScmInfo_Proxy( 
    IScmRequestInfo * This,
    /* [in] */ PRIV_SCM_INFO *pScmInfo);


void __RPC_STUB IScmRequestInfo_SetScmInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_GetScmInfo_Proxy( 
    IScmRequestInfo * This,
    /* [out] */ PRIV_SCM_INFO **ppScmInfo);


void __RPC_STUB IScmRequestInfo_GetScmInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_SetRemoteRequestInfo_Proxy( 
    IScmRequestInfo * This,
    /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq);


void __RPC_STUB IScmRequestInfo_SetRemoteRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_GetRemoteRequestInfo_Proxy( 
    IScmRequestInfo * This,
    /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq);


void __RPC_STUB IScmRequestInfo_GetRemoteRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScmRequestInfo_INTERFACE_DEFINED__ */


#ifndef __IScmReplyInfo_INTERFACE_DEFINED__
#define __IScmReplyInfo_INTERFACE_DEFINED__

/* interface IScmReplyInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IScmReplyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B6-0000-0000-C000-000000000046")
    IScmReplyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResolverInfo( 
            /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolverInfo( 
            /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemoteReplyInfo( 
            /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteReplyInfo( 
            /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScmReplyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScmReplyInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScmReplyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScmReplyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolverInfo )( 
            IScmReplyInfo * This,
            /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolverInfo )( 
            IScmReplyInfo * This,
            /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteReplyInfo )( 
            IScmReplyInfo * This,
            /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteReplyInfo )( 
            IScmReplyInfo * This,
            /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply);
        
        END_INTERFACE
    } IScmReplyInfoVtbl;

    interface IScmReplyInfo
    {
        CONST_VTBL struct IScmReplyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScmReplyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScmReplyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScmReplyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScmReplyInfo_SetResolverInfo(This,pResolverInfo)	\
    (This)->lpVtbl -> SetResolverInfo(This,pResolverInfo)

#define IScmReplyInfo_GetResolverInfo(This,ppResolverInfo)	\
    (This)->lpVtbl -> GetResolverInfo(This,ppResolverInfo)

#define IScmReplyInfo_SetRemoteReplyInfo(This,pRemoteReply)	\
    (This)->lpVtbl -> SetRemoteReplyInfo(This,pRemoteReply)

#define IScmReplyInfo_GetRemoteReplyInfo(This,ppRemoteReply)	\
    (This)->lpVtbl -> GetRemoteReplyInfo(This,ppRemoteReply)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScmReplyInfo_SetResolverInfo_Proxy( 
    IScmReplyInfo * This,
    /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo);


void __RPC_STUB IScmReplyInfo_SetResolverInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_GetResolverInfo_Proxy( 
    IScmReplyInfo * This,
    /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo);


void __RPC_STUB IScmReplyInfo_GetResolverInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_SetRemoteReplyInfo_Proxy( 
    IScmReplyInfo * This,
    /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply);


void __RPC_STUB IScmReplyInfo_SetRemoteReplyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_GetRemoteReplyInfo_Proxy( 
    IScmReplyInfo * This,
    /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply);


void __RPC_STUB IScmReplyInfo_GetRemoteReplyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScmReplyInfo_INTERFACE_DEFINED__ */


#ifndef __IInstantiationInfo_INTERFACE_DEFINED__
#define __IInstantiationInfo_INTERFACE_DEFINED__

/* interface IInstantiationInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInstantiationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AB-0000-0000-C000-000000000046")
    IInstantiationInfo : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInstantiationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstantiationInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstantiationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstantiationInfo * This);
        
        END_INTERFACE
    } IInstantiationInfoVtbl;

    interface IInstantiationInfo
    {
        CONST_VTBL struct IInstantiationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstantiationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstantiationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstantiationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstantiationInfo_INTERFACE_DEFINED__ */


#ifndef __ILegacyInfo_INTERFACE_DEFINED__
#define __ILegacyInfo_INTERFACE_DEFINED__

/* interface ILegacyInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ILegacyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AC-0000-0000-C000-000000000046")
    ILegacyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCOSERVERINFO( 
            /* [in] */ COSERVERINFO *pServerInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOSERVERINFO( 
            /* [out] */ COSERVERINFO **ppServerInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILegacyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILegacyInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILegacyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILegacyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCOSERVERINFO )( 
            ILegacyInfo * This,
            /* [in] */ COSERVERINFO *pServerInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOSERVERINFO )( 
            ILegacyInfo * This,
            /* [out] */ COSERVERINFO **ppServerInfo);
        
        END_INTERFACE
    } ILegacyInfoVtbl;

    interface ILegacyInfo
    {
        CONST_VTBL struct ILegacyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILegacyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILegacyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILegacyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILegacyInfo_SetCOSERVERINFO(This,pServerInfo)	\
    (This)->lpVtbl -> SetCOSERVERINFO(This,pServerInfo)

#define ILegacyInfo_GetCOSERVERINFO(This,ppServerInfo)	\
    (This)->lpVtbl -> GetCOSERVERINFO(This,ppServerInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILegacyInfo_SetCOSERVERINFO_Proxy( 
    ILegacyInfo * This,
    /* [in] */ COSERVERINFO *pServerInfo);


void __RPC_STUB ILegacyInfo_SetCOSERVERINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILegacyInfo_GetCOSERVERINFO_Proxy( 
    ILegacyInfo * This,
    /* [out] */ COSERVERINFO **ppServerInfo);


void __RPC_STUB ILegacyInfo_GetCOSERVERINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILegacyInfo_INTERFACE_DEFINED__ */


#ifndef __IInstanceInfo_INTERFACE_DEFINED__
#define __IInstanceInfo_INTERFACE_DEFINED__

/* interface IInstanceInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IInstanceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AD-0000-0000-C000-000000000046")
    IInstanceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStorage( 
            /* [unique][in] */ IStorage *pStg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [out] */ IStorage **ppStg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStorageIFD( 
            /* [in] */ MInterfacePointer *pStgIFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageIFD( 
            /* [out] */ MInterfacePointer **ppStgIFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFile( 
            /* [unique][string][in] */ WCHAR *pwszFileName,
            /* [in] */ DWORD dwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [string][out] */ WCHAR **ppwszFileName,
            /* [out] */ DWORD *pdwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIfdROT( 
            MInterfacePointer *pIfdROT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIfdROT( 
            MInterfacePointer **ppIfdROT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstanceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstanceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstanceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstanceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStorage )( 
            IInstanceInfo * This,
            /* [unique][in] */ IStorage *pStg);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorage )( 
            IInstanceInfo * This,
            /* [out] */ IStorage **ppStg);
        
        HRESULT ( STDMETHODCALLTYPE *SetStorageIFD )( 
            IInstanceInfo * This,
            /* [in] */ MInterfacePointer *pStgIFD);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorageIFD )( 
            IInstanceInfo * This,
            /* [out] */ MInterfacePointer **ppStgIFD);
        
        HRESULT ( STDMETHODCALLTYPE *SetFile )( 
            IInstanceInfo * This,
            /* [unique][string][in] */ WCHAR *pwszFileName,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            IInstanceInfo * This,
            /* [string][out] */ WCHAR **ppwszFileName,
            /* [out] */ DWORD *pdwMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetIfdROT )( 
            IInstanceInfo * This,
            MInterfacePointer *pIfdROT);
        
        HRESULT ( STDMETHODCALLTYPE *GetIfdROT )( 
            IInstanceInfo * This,
            MInterfacePointer **ppIfdROT);
        
        END_INTERFACE
    } IInstanceInfoVtbl;

    interface IInstanceInfo
    {
        CONST_VTBL struct IInstanceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstanceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstanceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstanceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstanceInfo_SetStorage(This,pStg)	\
    (This)->lpVtbl -> SetStorage(This,pStg)

#define IInstanceInfo_GetStorage(This,ppStg)	\
    (This)->lpVtbl -> GetStorage(This,ppStg)

#define IInstanceInfo_SetStorageIFD(This,pStgIFD)	\
    (This)->lpVtbl -> SetStorageIFD(This,pStgIFD)

#define IInstanceInfo_GetStorageIFD(This,ppStgIFD)	\
    (This)->lpVtbl -> GetStorageIFD(This,ppStgIFD)

#define IInstanceInfo_SetFile(This,pwszFileName,dwMode)	\
    (This)->lpVtbl -> SetFile(This,pwszFileName,dwMode)

#define IInstanceInfo_GetFile(This,ppwszFileName,pdwMode)	\
    (This)->lpVtbl -> GetFile(This,ppwszFileName,pdwMode)

#define IInstanceInfo_SetIfdROT(This,pIfdROT)	\
    (This)->lpVtbl -> SetIfdROT(This,pIfdROT)

#define IInstanceInfo_GetIfdROT(This,ppIfdROT)	\
    (This)->lpVtbl -> GetIfdROT(This,ppIfdROT)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstanceInfo_SetStorage_Proxy( 
    IInstanceInfo * This,
    /* [unique][in] */ IStorage *pStg);


void __RPC_STUB IInstanceInfo_SetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetStorage_Proxy( 
    IInstanceInfo * This,
    /* [out] */ IStorage **ppStg);


void __RPC_STUB IInstanceInfo_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetStorageIFD_Proxy( 
    IInstanceInfo * This,
    /* [in] */ MInterfacePointer *pStgIFD);


void __RPC_STUB IInstanceInfo_SetStorageIFD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetStorageIFD_Proxy( 
    IInstanceInfo * This,
    /* [out] */ MInterfacePointer **ppStgIFD);


void __RPC_STUB IInstanceInfo_GetStorageIFD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetFile_Proxy( 
    IInstanceInfo * This,
    /* [unique][string][in] */ WCHAR *pwszFileName,
    /* [in] */ DWORD dwMode);


void __RPC_STUB IInstanceInfo_SetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetFile_Proxy( 
    IInstanceInfo * This,
    /* [string][out] */ WCHAR **ppwszFileName,
    /* [out] */ DWORD *pdwMode);


void __RPC_STUB IInstanceInfo_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetIfdROT_Proxy( 
    IInstanceInfo * This,
    MInterfacePointer *pIfdROT);


void __RPC_STUB IInstanceInfo_SetIfdROT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetIfdROT_Proxy( 
    IInstanceInfo * This,
    MInterfacePointer **ppIfdROT);


void __RPC_STUB IInstanceInfo_GetIfdROT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstanceInfo_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationContextInfo_INTERFACE_DEFINED__
#define __IPrivActivationContextInfo_INTERFACE_DEFINED__

/* interface IPrivActivationContextInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AE-0000-0000-C000-000000000046")
    IPrivActivationContextInfo : public IActivationContextInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClientContext( 
            /* [in] */ IContext *pClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrototypeContext( 
            /* [in] */ IContext *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrototypeExists( 
            /* [out] */ BOOL *pBExists) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationContextInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientContext )( 
            IPrivActivationContextInfo * This,
            /* [out] */ IContext **ppClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrototypeContext )( 
            IPrivActivationContextInfo * This,
            /* [out] */ IContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsClientContextOK )( 
            IPrivActivationContextInfo * This,
            /* [out] */ BOOL *fYes);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContextNotOK )( 
            IPrivActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContext )( 
            IPrivActivationContextInfo * This,
            /* [in] */ IContext *pClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrototypeContext )( 
            IPrivActivationContextInfo * This,
            /* [in] */ IContext *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *PrototypeExists )( 
            IPrivActivationContextInfo * This,
            /* [out] */ BOOL *pBExists);
        
        END_INTERFACE
    } IPrivActivationContextInfoVtbl;

    interface IPrivActivationContextInfo
    {
        CONST_VTBL struct IPrivActivationContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationContextInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationContextInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationContextInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationContextInfo_GetClientContext(This,ppClientContext)	\
    (This)->lpVtbl -> GetClientContext(This,ppClientContext)

#define IPrivActivationContextInfo_GetPrototypeContext(This,ppContext)	\
    (This)->lpVtbl -> GetPrototypeContext(This,ppContext)

#define IPrivActivationContextInfo_IsClientContextOK(This,fYes)	\
    (This)->lpVtbl -> IsClientContextOK(This,fYes)

#define IPrivActivationContextInfo_SetClientContextNotOK(This)	\
    (This)->lpVtbl -> SetClientContextNotOK(This)


#define IPrivActivationContextInfo_SetClientContext(This,pClientContext)	\
    (This)->lpVtbl -> SetClientContext(This,pClientContext)

#define IPrivActivationContextInfo_SetPrototypeContext(This,pContext)	\
    (This)->lpVtbl -> SetPrototypeContext(This,pContext)

#define IPrivActivationContextInfo_PrototypeExists(This,pBExists)	\
    (This)->lpVtbl -> PrototypeExists(This,pBExists)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_SetClientContext_Proxy( 
    IPrivActivationContextInfo * This,
    /* [in] */ IContext *pClientContext);


void __RPC_STUB IPrivActivationContextInfo_SetClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_SetPrototypeContext_Proxy( 
    IPrivActivationContextInfo * This,
    /* [in] */ IContext *pContext);


void __RPC_STUB IPrivActivationContextInfo_SetPrototypeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_PrototypeExists_Proxy( 
    IPrivActivationContextInfo * This,
    /* [out] */ BOOL *pBExists);


void __RPC_STUB IPrivActivationContextInfo_PrototypeExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationContextInfo_INTERFACE_DEFINED__ */


#ifndef __IActivationProperties_INTERFACE_DEFINED__
#define __IActivationProperties_INTERFACE_DEFINED__

/* interface IActivationProperties */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AF-0000-0000-C000-000000000046")
    IActivationProperties : public IMarshal2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestCtx( 
            /* [in] */ DWORD dwDestCtx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMarshalFlags( 
            /* [in] */ DWORD dwMarshalFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalBlob( 
            /* [in] */ void *blob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalBlob( 
            /* [out] */ void **blob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnmarshalClass )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalSizeMax )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalInterface )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalInterface )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseMarshalData )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectObject )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestCtx )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwDestCtx);
        
        HRESULT ( STDMETHODCALLTYPE *SetMarshalFlags )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwMarshalFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalBlob )( 
            IActivationProperties * This,
            /* [in] */ void *blob);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalBlob )( 
            IActivationProperties * This,
            /* [out] */ void **blob);
        
        END_INTERFACE
    } IActivationPropertiesVtbl;

    interface IActivationProperties
    {
        CONST_VTBL struct IActivationPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationProperties_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IActivationProperties_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IActivationProperties_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IActivationProperties_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IActivationProperties_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IActivationProperties_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)



#define IActivationProperties_SetDestCtx(This,dwDestCtx)	\
    (This)->lpVtbl -> SetDestCtx(This,dwDestCtx)

#define IActivationProperties_SetMarshalFlags(This,dwMarshalFlags)	\
    (This)->lpVtbl -> SetMarshalFlags(This,dwMarshalFlags)

#define IActivationProperties_SetLocalBlob(This,blob)	\
    (This)->lpVtbl -> SetLocalBlob(This,blob)

#define IActivationProperties_GetLocalBlob(This,blob)	\
    (This)->lpVtbl -> GetLocalBlob(This,blob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationProperties_SetDestCtx_Proxy( 
    IActivationProperties * This,
    /* [in] */ DWORD dwDestCtx);


void __RPC_STUB IActivationProperties_SetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_SetMarshalFlags_Proxy( 
    IActivationProperties * This,
    /* [in] */ DWORD dwMarshalFlags);


void __RPC_STUB IActivationProperties_SetMarshalFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_SetLocalBlob_Proxy( 
    IActivationProperties * This,
    /* [in] */ void *blob);


void __RPC_STUB IActivationProperties_SetLocalBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_GetLocalBlob_Proxy( 
    IActivationProperties * This,
    /* [out] */ void **blob);


void __RPC_STUB IActivationProperties_GetLocalBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationProperties_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationPropertiesOut_INTERFACE_DEFINED__
#define __IPrivActivationPropertiesOut_INTERFACE_DEFINED__

/* interface IPrivActivationPropertiesOut */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationPropertiesOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B0-0000-0000-C000-000000000046")
    IPrivActivationPropertiesOut : public IActivationPropertiesOut
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObjectInterfaces( 
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMarshalledResults( 
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ HRESULT *pHr,
            /* [in] */ MInterfacePointer **pIntfData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarshalledResults( 
            /* [out] */ DWORD *pcIfs,
            /* [out] */ IID **pIID,
            /* [out] */ HRESULT **pHr,
            /* [out] */ MInterfacePointer ***pIntfData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationPropertiesOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationPropertiesOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationPropertiesOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IPrivActivationPropertiesOut * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterface )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterfaces )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRequestedIIDs )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectInterfaces )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetMarshalledResults )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ HRESULT *pHr,
            /* [in] */ MInterfacePointer **pIntfData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalledResults )( 
            IPrivActivationPropertiesOut * This,
            /* [out] */ DWORD *pcIfs,
            /* [out] */ IID **pIID,
            /* [out] */ HRESULT **pHr,
            /* [out] */ MInterfacePointer ***pIntfData);
        
        END_INTERFACE
    } IPrivActivationPropertiesOutVtbl;

    interface IPrivActivationPropertiesOut
    {
        CONST_VTBL struct IPrivActivationPropertiesOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationPropertiesOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationPropertiesOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationPropertiesOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationPropertiesOut_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IPrivActivationPropertiesOut_GetObjectInterface(This,riid,actvflags,ppv)	\
    (This)->lpVtbl -> GetObjectInterface(This,riid,actvflags,ppv)

#define IPrivActivationPropertiesOut_GetObjectInterfaces(This,cIfs,actvflags,multiQi)	\
    (This)->lpVtbl -> GetObjectInterfaces(This,cIfs,actvflags,multiQi)

#define IPrivActivationPropertiesOut_RemoveRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> RemoveRequestedIIDs(This,cIfs,rgIID)


#define IPrivActivationPropertiesOut_SetObjectInterfaces(This,cIfs,pIID,pUnk)	\
    (This)->lpVtbl -> SetObjectInterfaces(This,cIfs,pIID,pUnk)

#define IPrivActivationPropertiesOut_SetMarshalledResults(This,cIfs,pIID,pHr,pIntfData)	\
    (This)->lpVtbl -> SetMarshalledResults(This,cIfs,pIID,pHr,pIntfData)

#define IPrivActivationPropertiesOut_GetMarshalledResults(This,pcIfs,pIID,pHr,pIntfData)	\
    (This)->lpVtbl -> GetMarshalledResults(This,pcIfs,pIID,pHr,pIntfData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_SetObjectInterfaces_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ IID *pIID,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IPrivActivationPropertiesOut_SetObjectInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_SetMarshalledResults_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ IID *pIID,
    /* [in] */ HRESULT *pHr,
    /* [in] */ MInterfacePointer **pIntfData);


void __RPC_STUB IPrivActivationPropertiesOut_SetMarshalledResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_GetMarshalledResults_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [out] */ DWORD *pcIfs,
    /* [out] */ IID **pIID,
    /* [out] */ HRESULT **pHr,
    /* [out] */ MInterfacePointer ***pIntfData);


void __RPC_STUB IPrivActivationPropertiesOut_GetMarshalledResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationPropertiesOut_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationPropertiesIn_INTERFACE_DEFINED__
#define __IPrivActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IPrivActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B5-0000-0000-C000-000000000046")
    IPrivActivationPropertiesIn : public IActivationPropertiesIn
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrivGetReturnActivationProperties( 
            /* [out] */ IPrivActivationPropertiesOut **ppActOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOMVersion( 
            /* [out] */ COMVERSION *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClsid( 
            /* [out] */ CLSID *pClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientToken( 
            /* [out] */ HANDLE *pHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestCtx( 
            /* [out] */ DWORD *pdwDestCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsctx )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationFlags )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pactvflags);
        
        HRESULT ( STDMETHODCALLTYPE *AddRequestedIIDs )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedIIDs )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateGetClassObject )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCreateInstance )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCIAndGetCF )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnActivationProperties )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut);
        
        HRESULT ( STDMETHODCALLTYPE *PrivGetReturnActivationProperties )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ IPrivActivationPropertiesOut **ppActOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOMVersion )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ COMVERSION *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsid )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ CLSID *pClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientToken )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ HANDLE *pHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestCtx )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pdwDestCtx);
        
        END_INTERFACE
    } IPrivActivationPropertiesInVtbl;

    interface IPrivActivationPropertiesIn
    {
        CONST_VTBL struct IPrivActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationPropertiesIn_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IPrivActivationPropertiesIn_GetClassInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,riid,ppv)

#define IPrivActivationPropertiesIn_GetClsctx(This,pclsctx)	\
    (This)->lpVtbl -> GetClsctx(This,pclsctx)

#define IPrivActivationPropertiesIn_GetActivationFlags(This,pactvflags)	\
    (This)->lpVtbl -> GetActivationFlags(This,pactvflags)

#define IPrivActivationPropertiesIn_AddRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> AddRequestedIIDs(This,cIfs,rgIID)

#define IPrivActivationPropertiesIn_GetRequestedIIDs(This,pulCount,prgIID)	\
    (This)->lpVtbl -> GetRequestedIIDs(This,pulCount,prgIID)

#define IPrivActivationPropertiesIn_DelegateGetClassObject(This,pActPropsOut)	\
    (This)->lpVtbl -> DelegateGetClassObject(This,pActPropsOut)

#define IPrivActivationPropertiesIn_DelegateCreateInstance(This,pUnkOuter,pActPropsOut)	\
    (This)->lpVtbl -> DelegateCreateInstance(This,pUnkOuter,pActPropsOut)

#define IPrivActivationPropertiesIn_DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)	\
    (This)->lpVtbl -> DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)

#define IPrivActivationPropertiesIn_GetReturnActivationProperties(This,pUnk,ppActOut)	\
    (This)->lpVtbl -> GetReturnActivationProperties(This,pUnk,ppActOut)


#define IPrivActivationPropertiesIn_PrivGetReturnActivationProperties(This,ppActOut)	\
    (This)->lpVtbl -> PrivGetReturnActivationProperties(This,ppActOut)

#define IPrivActivationPropertiesIn_GetCOMVersion(This,pVersion)	\
    (This)->lpVtbl -> GetCOMVersion(This,pVersion)

#define IPrivActivationPropertiesIn_GetClsid(This,pClsid)	\
    (This)->lpVtbl -> GetClsid(This,pClsid)

#define IPrivActivationPropertiesIn_GetClientToken(This,pHandle)	\
    (This)->lpVtbl -> GetClientToken(This,pHandle)

#define IPrivActivationPropertiesIn_GetDestCtx(This,pdwDestCtx)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_PrivGetReturnActivationProperties_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ IPrivActivationPropertiesOut **ppActOut);


void __RPC_STUB IPrivActivationPropertiesIn_PrivGetReturnActivationProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetCOMVersion_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ COMVERSION *pVersion);


void __RPC_STUB IPrivActivationPropertiesIn_GetCOMVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetClsid_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ CLSID *pClsid);


void __RPC_STUB IPrivActivationPropertiesIn_GetClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetClientToken_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ HANDLE *pHandle);


void __RPC_STUB IPrivActivationPropertiesIn_GetClientToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetDestCtx_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ DWORD *pdwDestCtx);


void __RPC_STUB IPrivActivationPropertiesIn_GetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationPropertiesIn_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_privact_0141 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_privact_0141_0001
    {	MARSHOPT_NO_OID_REGISTER	= 1
    } 	MARSHAL_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_privact_0141_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_privact_0141_ServerIfHandle;

#ifndef __IMarshalOptions_INTERFACE_DEFINED__
#define __IMarshalOptions_INTERFACE_DEFINED__

/* interface IMarshalOptions */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IMarshalOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4c1e39e1-e3e3-4296-aa86-ec938d896e92")
    IMarshalOptions : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE GetStubMarshalFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarshalOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarshalOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarshalOptions * This);
        
        void ( STDMETHODCALLTYPE *GetStubMarshalFlags )( 
            IMarshalOptions * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IMarshalOptionsVtbl;

    interface IMarshalOptions
    {
        CONST_VTBL struct IMarshalOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshalOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshalOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshalOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshalOptions_GetStubMarshalFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetStubMarshalFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IMarshalOptions_GetStubMarshalFlags_Proxy( 
    IMarshalOptions * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IMarshalOptions_GetStubMarshalFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshalOptions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\sensapip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapip.h

Abstract:

    This header file is used by components external to System Event
    Notification Service (SENS). These components will call SENS to
    notify it of events related to themselves.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/


#ifndef __SENSAPIP_H__
#define __SENSAPIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Includes
//


#if !defined(__midl)
#include <netcon.h>
#else
import "netcon.idl";
#endif // __midl

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#define SENS_NOTIFY_RAS_STARTED                 0x00000001
#define SENS_NOTIFY_RAS_STOPPED                 0x00000002
#define SENS_NOTIFY_RAS_CONNECT                 0x00000004
#define SENS_NOTIFY_RAS_DISCONNECT              0x00000008
#define SENS_NOTIFY_RAS_DISCONNECT_PENDING      0x00000010
#define SENS_NOTIFY_LAN_CONNECT                 0x00000020
#define SENS_NOTIFY_LAN_DISCONNECT              0x00000040

#define SENS_NOTIFY_WINLOGON_LOGON              0x00001000
#define SENS_NOTIFY_WINLOGON_LOGOFF             0x00002000
#define SENS_NOTIFY_WINLOGON_STARTUP            0x00004000
#define SENS_NOTIFY_WINLOGON_STARTSHELL         0x00008000
#define SENS_NOTIFY_WINLOGON_SHUTDOWN           0x00010000
#define SENS_NOTIFY_WINLOGON_LOCK               0x00020000
#define SENS_NOTIFY_WINLOGON_UNLOCK             0x00040000
#define SENS_NOTIFY_WINLOGON_STARTSCREENSAVER   0x00080000
#define SENS_NOTIFY_WINLOGON_STOPSCREENSAVER    0x00100000
#define SENS_NOTIFY_WINLOGON_POSTSHELL          0x00200000
#define SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT 0x00400000
#define SENS_NOTIFY_WINLOGON_SESSION_RECONNECT  0x00800000

//
// Typedefs
//

typedef DWORD SENS_HRASCONN;

typedef struct _WINLOGON_INFO
{
    ULONG Size;
    ULONG Flags;
    LPWSTR UserName;
    LPWSTR Domain;
    LPWSTR WindowStation;
    DWORD hToken;   // Originally HANDLE
    DWORD hDesktop; // Originally HDESK
    DWORD dwSessionId;
} WINLOGON_INFO, *PWINLOGON_INFO;

typedef struct _SENS_NOTIFY_WINLOGON
{
    DWORD eType;
    WINLOGON_INFO Info;
} SENS_NOTIFY_WINLOGON, *PSENS_NOTIFY_WINLOGON;

typedef struct _SENS_NOTIFY_RAS
{
    DWORD eType;
    SENS_HRASCONN hConnection;
} SENS_NOTIFY_RAS, *PSENS_NOTIFY_RAS;

typedef struct _SENS_NOTIFY_NETCON
{
    DWORD eType;
    INetConnection *pINetConnection;
} SENS_NOTIFY_NETCON, *PSENS_NOTIFY_NETCON;

typedef struct _SENS_NOTIFY_NETCON_P // _P stands for Private
{
    DWORD eType;
#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR Name;
    NETCON_STATUS Status;
    NETCON_MEDIATYPE Type;
} SENS_NOTIFY_NETCON_P, *PSENS_NOTIFY_NETCON_P;

//
// Function prototypes
//

#if !defined(__midl)

DWORD APIENTRY
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    );

DWORD APIENTRY
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    );

DWORD APIENTRY
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\syncrasp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       SyncRasp.h
//
//  Contents:   Private Exports used by Ras and SyncMgr for 
//		doing Pending Disconnect
//
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _SYNCMGRRAS_
#define _SYNCMGRRAS_

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam);  

// structures used in messages

typedef struct _tagSYNCMGRQUERYSHOWSYNCUI
{
    /* [in]  */ DWORD cbSize;
    /* [in]  */ GUID GuidConnection;
    /* [in]  */ LPCWSTR pszConnectionName;
    /* [out] */ BOOL fShowCheckBox;
    /* [out] */ UINT nCheckState;  // values taken from the BST_ #defines
} SYNCMGRQUERYSHOWSYNCUI;

typedef struct _tagSYNCMGRSYNCDISCONNECT
{
    /* [in] */ DWORD cbSize;
    /* [in] */ GUID  GuidConnection;
    /* [in] */ LPCWSTR pszConnectionName;
 } SYNCMGRSYNCDISCONNECT;

// Messages to SyncMgrRasProc
#define SYNCMGRRASPROC_QUERYSHOWSYNCUI 	WM_USER + 1

// wParam = 0
// lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI

#define SYNCMGRRASPROC_SYNCDISCONNECT        	WM_USER + 2

// wParam = 0
// lParam = Pointer to SYNCMGRSYNCDISCONNECT

#endif // _SYNCMGRRAS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\stackwalk.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for stackwalk.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __stackwalk_h__
#define __stackwalk_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IStackWalkerSymbol_FWD_DEFINED__
#define __IStackWalkerSymbol_FWD_DEFINED__
typedef interface IStackWalkerSymbol IStackWalkerSymbol;
#endif 	/* __IStackWalkerSymbol_FWD_DEFINED__ */


#ifndef __IStackWalkerStack_FWD_DEFINED__
#define __IStackWalkerStack_FWD_DEFINED__
typedef interface IStackWalkerStack IStackWalkerStack;
#endif 	/* __IStackWalkerStack_FWD_DEFINED__ */


#ifndef __IStackWalker_FWD_DEFINED__
#define __IStackWalker_FWD_DEFINED__
typedef interface IStackWalker IStackWalker;
#endif 	/* __IStackWalker_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_stackwalk_0000 */
/* [local] */ 


enum CreateStackTraceFlags
    {	CREATESTACKTRACE_ONLYADDRESSES	= 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_stackwalk_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_stackwalk_0000_ServerIfHandle;

#ifndef __IStackWalkerSymbol_INTERFACE_DEFINED__
#define __IStackWalkerSymbol_INTERFACE_DEFINED__

/* interface IStackWalkerSymbol */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IStackWalkerSymbol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000157-0000-0000-C000-000000000046")
    IStackWalkerSymbol : public IUnknown
    {
    public:
        virtual LPCWSTR STDMETHODCALLTYPE ModuleName( void) = 0;
        
        virtual LPCWSTR STDMETHODCALLTYPE SymbolName( void) = 0;
        
        virtual DWORD64 STDMETHODCALLTYPE Address( void) = 0;
        
        virtual DWORD64 STDMETHODCALLTYPE Displacement( void) = 0;
        
        virtual IStackWalkerSymbol *STDMETHODCALLTYPE Next( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStackWalkerSymbolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStackWalkerSymbol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStackWalkerSymbol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStackWalkerSymbol * This);
        
        LPCWSTR ( STDMETHODCALLTYPE *ModuleName )( 
            IStackWalkerSymbol * This);
        
        LPCWSTR ( STDMETHODCALLTYPE *SymbolName )( 
            IStackWalkerSymbol * This);
        
        DWORD64 ( STDMETHODCALLTYPE *Address )( 
            IStackWalkerSymbol * This);
        
        DWORD64 ( STDMETHODCALLTYPE *Displacement )( 
            IStackWalkerSymbol * This);
        
        IStackWalkerSymbol *( STDMETHODCALLTYPE *Next )( 
            IStackWalkerSymbol * This);
        
        END_INTERFACE
    } IStackWalkerSymbolVtbl;

    interface IStackWalkerSymbol
    {
        CONST_VTBL struct IStackWalkerSymbolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStackWalkerSymbol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStackWalkerSymbol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStackWalkerSymbol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStackWalkerSymbol_ModuleName(This)	\
    (This)->lpVtbl -> ModuleName(This)

#define IStackWalkerSymbol_SymbolName(This)	\
    (This)->lpVtbl -> SymbolName(This)

#define IStackWalkerSymbol_Address(This)	\
    (This)->lpVtbl -> Address(This)

#define IStackWalkerSymbol_Displacement(This)	\
    (This)->lpVtbl -> Displacement(This)

#define IStackWalkerSymbol_Next(This)	\
    (This)->lpVtbl -> Next(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



LPCWSTR STDMETHODCALLTYPE IStackWalkerSymbol_ModuleName_Proxy( 
    IStackWalkerSymbol * This);


void __RPC_STUB IStackWalkerSymbol_ModuleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCWSTR STDMETHODCALLTYPE IStackWalkerSymbol_SymbolName_Proxy( 
    IStackWalkerSymbol * This);


void __RPC_STUB IStackWalkerSymbol_SymbolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD64 STDMETHODCALLTYPE IStackWalkerSymbol_Address_Proxy( 
    IStackWalkerSymbol * This);


void __RPC_STUB IStackWalkerSymbol_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD64 STDMETHODCALLTYPE IStackWalkerSymbol_Displacement_Proxy( 
    IStackWalkerSymbol * This);


void __RPC_STUB IStackWalkerSymbol_Displacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IStackWalkerSymbol *STDMETHODCALLTYPE IStackWalkerSymbol_Next_Proxy( 
    IStackWalkerSymbol * This);


void __RPC_STUB IStackWalkerSymbol_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStackWalkerSymbol_INTERFACE_DEFINED__ */


#ifndef __IStackWalkerStack_INTERFACE_DEFINED__
#define __IStackWalkerStack_INTERFACE_DEFINED__

/* interface IStackWalkerStack */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IStackWalkerStack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000158-0000-0000-C000-000000000046")
    IStackWalkerStack : public IUnknown
    {
    public:
        virtual IStackWalkerSymbol *STDMETHODCALLTYPE TopSymbol( void) = 0;
        
        virtual SIZE_T STDMETHODCALLTYPE Size( 
            /* [in] */ LONG lMaxNumLines) = 0;
        
        virtual BOOL STDMETHODCALLTYPE GetStack( 
            /* [in] */ SIZE_T nChars,
            /* [string][in] */ LPWSTR wsz,
            /* [in] */ LONG lMaxNumLines) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStackWalkerStackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStackWalkerStack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStackWalkerStack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStackWalkerStack * This);
        
        IStackWalkerSymbol *( STDMETHODCALLTYPE *TopSymbol )( 
            IStackWalkerStack * This);
        
        SIZE_T ( STDMETHODCALLTYPE *Size )( 
            IStackWalkerStack * This,
            /* [in] */ LONG lMaxNumLines);
        
        BOOL ( STDMETHODCALLTYPE *GetStack )( 
            IStackWalkerStack * This,
            /* [in] */ SIZE_T nChars,
            /* [string][in] */ LPWSTR wsz,
            /* [in] */ LONG lMaxNumLines);
        
        END_INTERFACE
    } IStackWalkerStackVtbl;

    interface IStackWalkerStack
    {
        CONST_VTBL struct IStackWalkerStackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStackWalkerStack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStackWalkerStack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStackWalkerStack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStackWalkerStack_TopSymbol(This)	\
    (This)->lpVtbl -> TopSymbol(This)

#define IStackWalkerStack_Size(This,lMaxNumLines)	\
    (This)->lpVtbl -> Size(This,lMaxNumLines)

#define IStackWalkerStack_GetStack(This,nChars,wsz,lMaxNumLines)	\
    (This)->lpVtbl -> GetStack(This,nChars,wsz,lMaxNumLines)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IStackWalkerSymbol *STDMETHODCALLTYPE IStackWalkerStack_TopSymbol_Proxy( 
    IStackWalkerStack * This);


void __RPC_STUB IStackWalkerStack_TopSymbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SIZE_T STDMETHODCALLTYPE IStackWalkerStack_Size_Proxy( 
    IStackWalkerStack * This,
    /* [in] */ LONG lMaxNumLines);


void __RPC_STUB IStackWalkerStack_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IStackWalkerStack_GetStack_Proxy( 
    IStackWalkerStack * This,
    /* [in] */ SIZE_T nChars,
    /* [string][in] */ LPWSTR wsz,
    /* [in] */ LONG lMaxNumLines);


void __RPC_STUB IStackWalkerStack_GetStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStackWalkerStack_INTERFACE_DEFINED__ */


#ifndef __IStackWalker_INTERFACE_DEFINED__
#define __IStackWalker_INTERFACE_DEFINED__

/* interface IStackWalker */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IStackWalker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000159-0000-0000-C000-000000000046")
    IStackWalker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ HANDLE hProcess) = 0;
        
        virtual IStackWalkerStack *STDMETHODCALLTYPE CreateStackTrace( 
            /* [in] */ LPVOID pContext,
            /* [in] */ HANDLE hThread,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual IStackWalkerSymbol *STDMETHODCALLTYPE ResolveAddress( 
            /* [in] */ DWORD64 dw64Addr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStackWalkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStackWalker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStackWalker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStackWalker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IStackWalker * This,
            /* [in] */ HANDLE hProcess);
        
        IStackWalkerStack *( STDMETHODCALLTYPE *CreateStackTrace )( 
            IStackWalker * This,
            /* [in] */ LPVOID pContext,
            /* [in] */ HANDLE hThread,
            /* [in] */ DWORD dwFlags);
        
        IStackWalkerSymbol *( STDMETHODCALLTYPE *ResolveAddress )( 
            IStackWalker * This,
            /* [in] */ DWORD64 dw64Addr);
        
        END_INTERFACE
    } IStackWalkerVtbl;

    interface IStackWalker
    {
        CONST_VTBL struct IStackWalkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStackWalker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStackWalker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStackWalker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStackWalker_Attach(This,hProcess)	\
    (This)->lpVtbl -> Attach(This,hProcess)

#define IStackWalker_CreateStackTrace(This,pContext,hThread,dwFlags)	\
    (This)->lpVtbl -> CreateStackTrace(This,pContext,hThread,dwFlags)

#define IStackWalker_ResolveAddress(This,dw64Addr)	\
    (This)->lpVtbl -> ResolveAddress(This,dw64Addr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStackWalker_Attach_Proxy( 
    IStackWalker * This,
    /* [in] */ HANDLE hProcess);


void __RPC_STUB IStackWalker_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IStackWalkerStack *STDMETHODCALLTYPE IStackWalker_CreateStackTrace_Proxy( 
    IStackWalker * This,
    /* [in] */ LPVOID pContext,
    /* [in] */ HANDLE hThread,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IStackWalker_CreateStackTrace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IStackWalkerSymbol *STDMETHODCALLTYPE IStackWalker_ResolveAddress_Proxy( 
    IStackWalker * This,
    /* [in] */ DWORD64 dw64Addr);


void __RPC_STUB IStackWalker_ResolveAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStackWalker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_stackwalk_0095 */
/* [local] */ 


EXTERN_C const CLSID CLSID_StackWalker;



extern RPC_IF_HANDLE __MIDL_itf_stackwalk_0095_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_stackwalk_0095_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\trkstub.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:



Abstract:

   Prototypes for the RPC stubs that services uses to 
   call over to trkwks, now that it is in svchost.


Author:



Revisions:


--*/


extern "C" {
NTSTATUS
WINAPI
StartTrkWksServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    );

NTSTATUS
WINAPI
StopTrkWksServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\trksvr_c.c ===
/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   641                               
#define PROC_FORMAT_STRING_SIZE   77                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;
handle_t notused;


extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_CLIENT_INTERFACE trksvr___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE trksvr_v1_0_c_ifspec = (RPC_IF_HANDLE)& trksvr___RpcClientInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

static RPC_BINDING_HANDLE trksvr__MIDL_AutoBindHandle;


HRESULT LnkSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Parameter pMsg */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 40 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 56 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 58 */	NdrFcShort( 0xb ),	/* 11 */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 64 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 66 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 68 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 72 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x268 ),	/* Offset= 616 (620) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x92 ),	/* Offset= 146 (170) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (230) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0x10a ),	/* Offset= 266 (302) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x178 ),	/* Offset= 376 (418) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x198 ),	/* Offset= 408 (456) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x1b6 ),	/* Offset= 438 (492) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x21e ),	/* Offset= 542 (602) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x11c ),	/* Offset= 284 (350) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffff ),	/* Offset= -1 (73) */
/* 76 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 78 */	NdrFcLong( 0x1 ),	/* 1 */
/* 82 */	NdrFcLong( 0x1 ),	/* 1 */
/* 86 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 88 */	NdrFcShort( 0x202 ),	/* 514 */
/* 90 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 92 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 98 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 100 */	NdrFcShort( 0x10 ),	/* 16 */
/* 102 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 104 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 106 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (92) */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x10 ),	/* 16 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xffee ),	/* Offset= -18 (98) */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x20 ),	/* 32 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (110) */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffec ),	/* Offset= -20 (110) */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 136 */	NdrFcShort( 0x248 ),	/* 584 */
/* 138 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0xffca ),	/* Offset= -54 (86) */
/* 142 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 144 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (120) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 148 */	0x0,		/* 0 */
			NdrFcShort( 0xffe3 ),	/* Offset= -29 (120) */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x248 ),	/* 584 */
/* 158 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 166 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (134) */
/* 168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 170 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x8 ),	/* Offset= 8 (184) */
/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (76) */
/* 182 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 184 */	
			0x12, 0x0,	/* FC_UP */
/* 186 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (154) */
/* 188 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 194 */	NdrFcLong( 0x40 ),	/* 64 */
/* 198 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x10 ),	/* 16 */
/* 202 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 210 */	NdrFcShort( 0xff9c ),	/* Offset= -100 (110) */
/* 212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 214 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 216 */	NdrFcShort( 0x20 ),	/* 32 */
/* 218 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 224 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0xff96 ),	/* Offset= -106 (120) */
/* 228 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 230 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x20 ),	/* 32 */
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0xe ),	/* Offset= 14 (250) */
/* 238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 240 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (188) */
/* 242 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 246 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 250 */	
			0x12, 0x0,	/* FC_UP */
/* 252 */	NdrFcShort( 0xff72 ),	/* Offset= -142 (110) */
/* 254 */	
			0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (198) */
/* 258 */	
			0x12, 0x0,	/* FC_UP */
/* 260 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (214) */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffce ),	/* Offset= -50 (214) */
/* 266 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	NdrFcLong( 0x80 ),	/* 128 */
/* 276 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcLong( 0x1a ),	/* 26 */
/* 286 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 288 */	NdrFcShort( 0x10 ),	/* 16 */
/* 290 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 296 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 298 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (110) */
/* 300 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 302 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 304 */	NdrFcShort( 0x10 ),	/* 16 */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0xe ),	/* Offset= 14 (322) */
/* 310 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (266) */
/* 314 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 316 */	0x0,		/* 0 */
			NdrFcShort( 0xffd7 ),	/* Offset= -41 (276) */
			0x36,		/* FC_POINTER */
/* 320 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 322 */	
			0x12, 0x0,	/* FC_UP */
/* 324 */	NdrFcShort( 0xff92 ),	/* Offset= -110 (214) */
/* 326 */	
			0x12, 0x0,	/* FC_UP */
/* 328 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (286) */
/* 330 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcLong( 0x1a ),	/* 26 */
/* 340 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0xff02 ),	/* Offset= -254 (92) */
/* 348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 350 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 354 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 356 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 358 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
/* 362 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 364 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 366 */	NdrFcShort( 0x10 ),	/* 16 */
/* 368 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 370 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (358) */
/* 372 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 374 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 376 */	NdrFcShort( 0x44 ),	/* 68 */
/* 378 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 380 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 382 */	NdrFcShort( 0xfef0 ),	/* Offset= -272 (110) */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (340) */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffce ),	/* Offset= -50 (340) */
/* 392 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 394 */	0x0,		/* 0 */
			NdrFcShort( 0xffd3 ),	/* Offset= -45 (350) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 398 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (364) */
			0x5b,		/* FC_END */
/* 402 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 404 */	NdrFcShort( 0x44 ),	/* 68 */
/* 406 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 412 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 414 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (374) */
/* 416 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 418 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x8 ),	/* Offset= 8 (432) */
/* 426 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 428 */	NdrFcShort( 0xff9e ),	/* Offset= -98 (330) */
/* 430 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 432 */	
			0x12, 0x0,	/* FC_UP */
/* 434 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (402) */
/* 436 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcLong( 0x20 ),	/* 32 */
/* 446 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcLong( 0x1a ),	/* 26 */
/* 456 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 458 */	NdrFcShort( 0x10 ),	/* 16 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0xe ),	/* Offset= 14 (476) */
/* 464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 466 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (436) */
/* 468 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (446) */
			0x36,		/* FC_POINTER */
/* 474 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 476 */	
			0x12, 0x0,	/* FC_UP */
/* 478 */	NdrFcShort( 0xfef8 ),	/* Offset= -264 (214) */
/* 480 */	
			0x12, 0x0,	/* FC_UP */
/* 482 */	NdrFcShort( 0xff3c ),	/* Offset= -196 (286) */
/* 484 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0xc ),	/* 12 */
/* 488 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 490 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 492 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 500 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 502 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 508 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 510 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 512 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 514 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 516 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 518 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 520 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 522 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 524 */	NdrFcShort( 0xff52 ),	/* Offset= -174 (350) */
/* 526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 530 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 532 */	0x0,		/* 0 */
			NdrFcShort( 0xff49 ),	/* Offset= -183 (350) */
			0x8,		/* FC_LONG */
/* 536 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 538 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (350) */
/* 540 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 542 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (350) */
/* 544 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 546 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 548 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 550 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 552 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 554 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (484) */
			0x5b,		/* FC_END */
/* 558 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 560 */	NdrFcLong( 0x1 ),	/* 1 */
/* 564 */	NdrFcLong( 0x1 ),	/* 1 */
/* 568 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 570 */	NdrFcShort( 0x54 ),	/* 84 */
/* 572 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 574 */	NdrFcShort( 0xfe3a ),	/* Offset= -454 (120) */
/* 576 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 578 */	NdrFcShort( 0xfe36 ),	/* Offset= -458 (120) */
/* 580 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 582 */	NdrFcShort( 0xff26 ),	/* Offset= -218 (364) */
/* 584 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 586 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x54 ),	/* 84 */
/* 590 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 594 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 596 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 598 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (568) */
/* 600 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 602 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 604 */	NdrFcShort( 0x8 ),	/* 8 */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	NdrFcShort( 0x8 ),	/* Offset= 8 (616) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xffca ),	/* Offset= -54 (558) */
/* 614 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x0,	/* FC_UP */
/* 618 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (586) */
/* 620 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0xa ),	/* Offset= 10 (636) */
/* 628 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 630 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 632 */	NdrFcShort( 0xfd8e ),	/* Offset= -626 (6) */
/* 634 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 636 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 638 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    40
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &notused,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessageCallback
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    _callbacktrksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   651                               
#define PROC_FORMAT_STRING_SIZE   81                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;
handle_t notused;


extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_CLIENT_INTERFACE trksvr___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE trksvr_v1_0_c_ifspec = (RPC_IF_HANDLE)& trksvr___RpcClientInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

static RPC_BINDING_HANDLE trksvr__MIDL_AutoBindHandle;


HRESULT LnkSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Parameter pMsg */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 42 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 58 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0xb ),	/* 11 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 68 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 70 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 72 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Return value */

/* 74 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 78 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x272 ),	/* Offset= 626 (630) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x92 ),	/* Offset= 146 (170) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xca ),	/* Offset= 202 (232) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0x10c ),	/* Offset= 268 (304) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x17c ),	/* Offset= 380 (422) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x19e ),	/* Offset= 414 (462) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x1be ),	/* Offset= 446 (500) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x226 ),	/* Offset= 550 (610) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x120 ),	/* Offset= 288 (354) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffff ),	/* Offset= -1 (73) */
/* 76 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 78 */	NdrFcLong( 0x1 ),	/* 1 */
/* 82 */	NdrFcLong( 0x1 ),	/* 1 */
/* 86 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 88 */	NdrFcShort( 0x202 ),	/* 514 */
/* 90 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 92 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 98 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 100 */	NdrFcShort( 0x10 ),	/* 16 */
/* 102 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 104 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 106 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (92) */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x10 ),	/* 16 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xffee ),	/* Offset= -18 (98) */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x20 ),	/* 32 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (110) */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffec ),	/* Offset= -20 (110) */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 136 */	NdrFcShort( 0x248 ),	/* 584 */
/* 138 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0xffca ),	/* Offset= -54 (86) */
/* 142 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 144 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (120) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 148 */	0x0,		/* 0 */
			NdrFcShort( 0xffe3 ),	/* Offset= -29 (120) */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x248 ),	/* 584 */
/* 158 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 166 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (134) */
/* 168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 170 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 172 */	NdrFcShort( 0x10 ),	/* 16 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0xa ),	/* Offset= 10 (186) */
/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (76) */
/* 182 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffde ),	/* Offset= -34 (154) */
/* 190 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcLong( 0x40 ),	/* 64 */
/* 200 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 212 */	NdrFcShort( 0xff9a ),	/* Offset= -102 (110) */
/* 214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 216 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 218 */	NdrFcShort( 0x20 ),	/* 32 */
/* 220 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 226 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 228 */	NdrFcShort( 0xff94 ),	/* Offset= -108 (120) */
/* 230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 232 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 234 */	NdrFcShort( 0x30 ),	/* 48 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0xe ),	/* Offset= 14 (252) */
/* 240 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 242 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (190) */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 252 */	
			0x12, 0x0,	/* FC_UP */
/* 254 */	NdrFcShort( 0xff70 ),	/* Offset= -144 (110) */
/* 256 */	
			0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (200) */
/* 260 */	
			0x12, 0x0,	/* FC_UP */
/* 262 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (216) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0xffce ),	/* Offset= -50 (216) */
/* 268 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcLong( 0x80 ),	/* 128 */
/* 278 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 284 */	NdrFcLong( 0x1a ),	/* 26 */
/* 288 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x10 ),	/* 16 */
/* 292 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 294 */	NdrFcShort( 0x10 ),	/* 16 */
/* 296 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 298 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 300 */	NdrFcShort( 0xff42 ),	/* Offset= -190 (110) */
/* 302 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 306 */	NdrFcShort( 0x20 ),	/* 32 */
/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x10 ),	/* Offset= 16 (326) */
/* 312 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 314 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (268) */
/* 316 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 318 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 320 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (278) */
/* 322 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 324 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 326 */	
			0x12, 0x0,	/* FC_UP */
/* 328 */	NdrFcShort( 0xff90 ),	/* Offset= -112 (216) */
/* 330 */	
			0x12, 0x0,	/* FC_UP */
/* 332 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (288) */
/* 334 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 340 */	NdrFcLong( 0x1a ),	/* 26 */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (92) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 358 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 360 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 362 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x10 ),	/* 16 */
/* 366 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 368 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 370 */	NdrFcShort( 0x10 ),	/* 16 */
/* 372 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 374 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (362) */
/* 376 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 378 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 380 */	NdrFcShort( 0x44 ),	/* 68 */
/* 382 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xfeec ),	/* Offset= -276 (110) */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (344) */
/* 392 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 394 */	NdrFcShort( 0xffce ),	/* Offset= -50 (344) */
/* 396 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 398 */	0x0,		/* 0 */
			NdrFcShort( 0xffd3 ),	/* Offset= -45 (354) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 402 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (368) */
			0x5b,		/* FC_END */
/* 406 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 408 */	NdrFcShort( 0x44 ),	/* 68 */
/* 410 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (378) */
/* 420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 422 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0x10 ),	/* 16 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0xa ),	/* Offset= 10 (438) */
/* 430 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 432 */	NdrFcShort( 0xff9e ),	/* Offset= -98 (334) */
/* 434 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 436 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 438 */	
			0x12, 0x0,	/* FC_UP */
/* 440 */	NdrFcShort( 0xffde ),	/* Offset= -34 (406) */
/* 442 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 448 */	NdrFcLong( 0x20 ),	/* 32 */
/* 452 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 458 */	NdrFcLong( 0x1a ),	/* 26 */
/* 462 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 464 */	NdrFcShort( 0x20 ),	/* 32 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x10 ),	/* Offset= 16 (484) */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (442) */
/* 474 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 476 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 478 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (452) */
/* 480 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 482 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 484 */	
			0x12, 0x0,	/* FC_UP */
/* 486 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (216) */
/* 488 */	
			0x12, 0x0,	/* FC_UP */
/* 490 */	NdrFcShort( 0xff36 ),	/* Offset= -202 (288) */
/* 492 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xc ),	/* 12 */
/* 496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 498 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 500 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 502 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 508 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 510 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 512 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 514 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 516 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 518 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 520 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 522 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 524 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0xff4e ),	/* Offset= -178 (354) */
/* 534 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 536 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 538 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 540 */	0x0,		/* 0 */
			NdrFcShort( 0xff45 ),	/* Offset= -187 (354) */
			0x8,		/* FC_LONG */
/* 544 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 546 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (354) */
/* 548 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 550 */	NdrFcShort( 0xff3c ),	/* Offset= -196 (354) */
/* 552 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 554 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 556 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 558 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 560 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 562 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (492) */
			0x5b,		/* FC_END */
/* 566 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 568 */	NdrFcLong( 0x1 ),	/* 1 */
/* 572 */	NdrFcLong( 0x1 ),	/* 1 */
/* 576 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 578 */	NdrFcShort( 0x54 ),	/* 84 */
/* 580 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 582 */	NdrFcShort( 0xfe32 ),	/* Offset= -462 (120) */
/* 584 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 586 */	NdrFcShort( 0xfe2e ),	/* Offset= -466 (120) */
/* 588 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 590 */	NdrFcShort( 0xff22 ),	/* Offset= -222 (368) */
/* 592 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 594 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 596 */	NdrFcShort( 0x54 ),	/* 84 */
/* 598 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 604 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 606 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (576) */
/* 608 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 610 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0xa ),	/* Offset= 10 (626) */
/* 618 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 620 */	NdrFcShort( 0xffca ),	/* Offset= -54 (566) */
/* 622 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 626 */	
			0x12, 0x0,	/* FC_UP */
/* 628 */	NdrFcShort( 0xffde ),	/* Offset= -34 (594) */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0xa ),	/* Offset= 10 (646) */
/* 638 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 640 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0xfd84 ),	/* Offset= -636 (6) */
/* 644 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 646 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 648 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    42
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &notused,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessageCallback
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    _callbacktrksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\trksvr_s.c ===
/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   641                               
#define PROC_FORMAT_STRING_SIZE   77                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;

extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE trksvr___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE Stubtrksvr_v1_0_s_ifspec = (RPC_IF_HANDLE)& trksvr___RpcServerInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

 extern const MIDL_STUBLESS_PROXY_INFO trksvr_ProxyInfo;

/* [callback] */ HRESULT LnkSvrMessageCallback( 
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[40],
                  ( unsigned char * )&pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Parameter pMsg */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 40 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 56 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 58 */	NdrFcShort( 0xb ),	/* 11 */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 64 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 66 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 68 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 72 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x268 ),	/* Offset= 616 (620) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x92 ),	/* Offset= 146 (170) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (230) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0x10a ),	/* Offset= 266 (302) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x178 ),	/* Offset= 376 (418) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x198 ),	/* Offset= 408 (456) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x1b6 ),	/* Offset= 438 (492) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x21e ),	/* Offset= 542 (602) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x11c ),	/* Offset= 284 (350) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffff ),	/* Offset= -1 (73) */
/* 76 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 78 */	NdrFcLong( 0x1 ),	/* 1 */
/* 82 */	NdrFcLong( 0x1 ),	/* 1 */
/* 86 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 88 */	NdrFcShort( 0x202 ),	/* 514 */
/* 90 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 92 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 98 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 100 */	NdrFcShort( 0x10 ),	/* 16 */
/* 102 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 104 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 106 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (92) */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x10 ),	/* 16 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xffee ),	/* Offset= -18 (98) */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x20 ),	/* 32 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (110) */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffec ),	/* Offset= -20 (110) */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 136 */	NdrFcShort( 0x248 ),	/* 584 */
/* 138 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0xffca ),	/* Offset= -54 (86) */
/* 142 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 144 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (120) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 148 */	0x0,		/* 0 */
			NdrFcShort( 0xffe3 ),	/* Offset= -29 (120) */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x248 ),	/* 584 */
/* 158 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 166 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (134) */
/* 168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 170 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x8 ),	/* Offset= 8 (184) */
/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (76) */
/* 182 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 184 */	
			0x12, 0x0,	/* FC_UP */
/* 186 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (154) */
/* 188 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 194 */	NdrFcLong( 0x40 ),	/* 64 */
/* 198 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x10 ),	/* 16 */
/* 202 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 210 */	NdrFcShort( 0xff9c ),	/* Offset= -100 (110) */
/* 212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 214 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 216 */	NdrFcShort( 0x20 ),	/* 32 */
/* 218 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 224 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0xff96 ),	/* Offset= -106 (120) */
/* 228 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 230 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 232 */	NdrFcShort( 0x20 ),	/* 32 */
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0xe ),	/* Offset= 14 (250) */
/* 238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 240 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (188) */
/* 242 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 246 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 250 */	
			0x12, 0x0,	/* FC_UP */
/* 252 */	NdrFcShort( 0xff72 ),	/* Offset= -142 (110) */
/* 254 */	
			0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (198) */
/* 258 */	
			0x12, 0x0,	/* FC_UP */
/* 260 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (214) */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffce ),	/* Offset= -50 (214) */
/* 266 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	NdrFcLong( 0x80 ),	/* 128 */
/* 276 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcLong( 0x1a ),	/* 26 */
/* 286 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 288 */	NdrFcShort( 0x10 ),	/* 16 */
/* 290 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 296 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 298 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (110) */
/* 300 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 302 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 304 */	NdrFcShort( 0x10 ),	/* 16 */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0xe ),	/* Offset= 14 (322) */
/* 310 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (266) */
/* 314 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 316 */	0x0,		/* 0 */
			NdrFcShort( 0xffd7 ),	/* Offset= -41 (276) */
			0x36,		/* FC_POINTER */
/* 320 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 322 */	
			0x12, 0x0,	/* FC_UP */
/* 324 */	NdrFcShort( 0xff92 ),	/* Offset= -110 (214) */
/* 326 */	
			0x12, 0x0,	/* FC_UP */
/* 328 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (286) */
/* 330 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcLong( 0x1a ),	/* 26 */
/* 340 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0xff02 ),	/* Offset= -254 (92) */
/* 348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 350 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 354 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 356 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 358 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
/* 362 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 364 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 366 */	NdrFcShort( 0x10 ),	/* 16 */
/* 368 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 370 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (358) */
/* 372 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 374 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 376 */	NdrFcShort( 0x44 ),	/* 68 */
/* 378 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 380 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 382 */	NdrFcShort( 0xfef0 ),	/* Offset= -272 (110) */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (340) */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffce ),	/* Offset= -50 (340) */
/* 392 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 394 */	0x0,		/* 0 */
			NdrFcShort( 0xffd3 ),	/* Offset= -45 (350) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 398 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (364) */
			0x5b,		/* FC_END */
/* 402 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 404 */	NdrFcShort( 0x44 ),	/* 68 */
/* 406 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 412 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 414 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (374) */
/* 416 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 418 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x8 ),	/* Offset= 8 (432) */
/* 426 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 428 */	NdrFcShort( 0xff9e ),	/* Offset= -98 (330) */
/* 430 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 432 */	
			0x12, 0x0,	/* FC_UP */
/* 434 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (402) */
/* 436 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcLong( 0x20 ),	/* 32 */
/* 446 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcLong( 0x1a ),	/* 26 */
/* 456 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 458 */	NdrFcShort( 0x10 ),	/* 16 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0xe ),	/* Offset= 14 (476) */
/* 464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 466 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (436) */
/* 468 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (446) */
			0x36,		/* FC_POINTER */
/* 474 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 476 */	
			0x12, 0x0,	/* FC_UP */
/* 478 */	NdrFcShort( 0xfef8 ),	/* Offset= -264 (214) */
/* 480 */	
			0x12, 0x0,	/* FC_UP */
/* 482 */	NdrFcShort( 0xff3c ),	/* Offset= -196 (286) */
/* 484 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0xc ),	/* 12 */
/* 488 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 490 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 492 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 500 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 502 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 508 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 510 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 512 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 514 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 516 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 518 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 520 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 522 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 524 */	NdrFcShort( 0xff52 ),	/* Offset= -174 (350) */
/* 526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 530 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 532 */	0x0,		/* 0 */
			NdrFcShort( 0xff49 ),	/* Offset= -183 (350) */
			0x8,		/* FC_LONG */
/* 536 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 538 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (350) */
/* 540 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 542 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (350) */
/* 544 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 546 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 548 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 550 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 552 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 554 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (484) */
			0x5b,		/* FC_END */
/* 558 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 560 */	NdrFcLong( 0x1 ),	/* 1 */
/* 564 */	NdrFcLong( 0x1 ),	/* 1 */
/* 568 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 570 */	NdrFcShort( 0x54 ),	/* 84 */
/* 572 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 574 */	NdrFcShort( 0xfe3a ),	/* Offset= -454 (120) */
/* 576 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 578 */	NdrFcShort( 0xfe36 ),	/* Offset= -458 (120) */
/* 580 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 582 */	NdrFcShort( 0xff26 ),	/* Offset= -218 (364) */
/* 584 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 586 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x54 ),	/* 84 */
/* 590 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 594 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 596 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 598 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (568) */
/* 600 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 602 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 604 */	NdrFcShort( 0x8 ),	/* 8 */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	NdrFcShort( 0x8 ),	/* Offset= 8 (616) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xffca ),	/* Offset= -54 (558) */
/* 614 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x0,	/* FC_UP */
/* 618 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (586) */
/* 620 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0xa ),	/* Offset= 10 (636) */
/* 628 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 630 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 632 */	NdrFcShort( 0xfd8e ),	/* Offset= -626 (6) */
/* 634 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 636 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 638 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    40
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessage,
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   651                               
#define PROC_FORMAT_STRING_SIZE   81                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;

extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE trksvr___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE Stubtrksvr_v1_0_s_ifspec = (RPC_IF_HANDLE)& trksvr___RpcServerInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

 extern const MIDL_STUBLESS_PROXY_INFO trksvr_ProxyInfo;

/* [callback] */ HRESULT LnkSvrMessageCallback( 
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[42],
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Parameter pMsg */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 42 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 58 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0xb ),	/* 11 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 68 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 70 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 72 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Return value */

/* 74 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 78 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x272 ),	/* Offset= 626 (630) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x92 ),	/* Offset= 146 (170) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xca ),	/* Offset= 202 (232) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0x10c ),	/* Offset= 268 (304) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x17c ),	/* Offset= 380 (422) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x19e ),	/* Offset= 414 (462) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x1be ),	/* Offset= 446 (500) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x226 ),	/* Offset= 550 (610) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x120 ),	/* Offset= 288 (354) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffff ),	/* Offset= -1 (73) */
/* 76 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 78 */	NdrFcLong( 0x1 ),	/* 1 */
/* 82 */	NdrFcLong( 0x1 ),	/* 1 */
/* 86 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 88 */	NdrFcShort( 0x202 ),	/* 514 */
/* 90 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 92 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 94 */	NdrFcShort( 0x8 ),	/* 8 */
/* 96 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 98 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 100 */	NdrFcShort( 0x10 ),	/* 16 */
/* 102 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 104 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 106 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (92) */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x10 ),	/* 16 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xffee ),	/* Offset= -18 (98) */
/* 118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 120 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x20 ),	/* 32 */
/* 124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 126 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (110) */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffec ),	/* Offset= -20 (110) */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 136 */	NdrFcShort( 0x248 ),	/* 584 */
/* 138 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0xffca ),	/* Offset= -54 (86) */
/* 142 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 144 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (120) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 148 */	0x0,		/* 0 */
			NdrFcShort( 0xffe3 ),	/* Offset= -29 (120) */
			0x8,		/* FC_LONG */
/* 152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 154 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x248 ),	/* 584 */
/* 158 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 166 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (134) */
/* 168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 170 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 172 */	NdrFcShort( 0x10 ),	/* 16 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0xa ),	/* Offset= 10 (186) */
/* 178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (76) */
/* 182 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffde ),	/* Offset= -34 (154) */
/* 190 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcLong( 0x40 ),	/* 64 */
/* 200 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 212 */	NdrFcShort( 0xff9a ),	/* Offset= -102 (110) */
/* 214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 216 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 218 */	NdrFcShort( 0x20 ),	/* 32 */
/* 220 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 226 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 228 */	NdrFcShort( 0xff94 ),	/* Offset= -108 (120) */
/* 230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 232 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 234 */	NdrFcShort( 0x30 ),	/* 48 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0xe ),	/* Offset= 14 (252) */
/* 240 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 242 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (190) */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 252 */	
			0x12, 0x0,	/* FC_UP */
/* 254 */	NdrFcShort( 0xff70 ),	/* Offset= -144 (110) */
/* 256 */	
			0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (200) */
/* 260 */	
			0x12, 0x0,	/* FC_UP */
/* 262 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (216) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0xffce ),	/* Offset= -50 (216) */
/* 268 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcLong( 0x80 ),	/* 128 */
/* 278 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 284 */	NdrFcLong( 0x1a ),	/* 26 */
/* 288 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x10 ),	/* 16 */
/* 292 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 294 */	NdrFcShort( 0x10 ),	/* 16 */
/* 296 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 298 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 300 */	NdrFcShort( 0xff42 ),	/* Offset= -190 (110) */
/* 302 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 306 */	NdrFcShort( 0x20 ),	/* 32 */
/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x10 ),	/* Offset= 16 (326) */
/* 312 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 314 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (268) */
/* 316 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 318 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 320 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (278) */
/* 322 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 324 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 326 */	
			0x12, 0x0,	/* FC_UP */
/* 328 */	NdrFcShort( 0xff90 ),	/* Offset= -112 (216) */
/* 330 */	
			0x12, 0x0,	/* FC_UP */
/* 332 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (288) */
/* 334 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 340 */	NdrFcLong( 0x1a ),	/* 26 */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (92) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 358 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 360 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 362 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x10 ),	/* 16 */
/* 366 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 368 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 370 */	NdrFcShort( 0x10 ),	/* 16 */
/* 372 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 374 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (362) */
/* 376 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 378 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 380 */	NdrFcShort( 0x44 ),	/* 68 */
/* 382 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xfeec ),	/* Offset= -276 (110) */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (344) */
/* 392 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 394 */	NdrFcShort( 0xffce ),	/* Offset= -50 (344) */
/* 396 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 398 */	0x0,		/* 0 */
			NdrFcShort( 0xffd3 ),	/* Offset= -45 (354) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 402 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (368) */
			0x5b,		/* FC_END */
/* 406 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 408 */	NdrFcShort( 0x44 ),	/* 68 */
/* 410 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (378) */
/* 420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 422 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0x10 ),	/* 16 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0xa ),	/* Offset= 10 (438) */
/* 430 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 432 */	NdrFcShort( 0xff9e ),	/* Offset= -98 (334) */
/* 434 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 436 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 438 */	
			0x12, 0x0,	/* FC_UP */
/* 440 */	NdrFcShort( 0xffde ),	/* Offset= -34 (406) */
/* 442 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 448 */	NdrFcLong( 0x20 ),	/* 32 */
/* 452 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 458 */	NdrFcLong( 0x1a ),	/* 26 */
/* 462 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 464 */	NdrFcShort( 0x20 ),	/* 32 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x10 ),	/* Offset= 16 (484) */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (442) */
/* 474 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 476 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 478 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (452) */
/* 480 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 482 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 484 */	
			0x12, 0x0,	/* FC_UP */
/* 486 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (216) */
/* 488 */	
			0x12, 0x0,	/* FC_UP */
/* 490 */	NdrFcShort( 0xff36 ),	/* Offset= -202 (288) */
/* 492 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xc ),	/* 12 */
/* 496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 498 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 500 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 502 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 508 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 510 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 512 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 514 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 516 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 518 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 520 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 522 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 524 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 526 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0xff4e ),	/* Offset= -178 (354) */
/* 534 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 536 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 538 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 540 */	0x0,		/* 0 */
			NdrFcShort( 0xff45 ),	/* Offset= -187 (354) */
			0x8,		/* FC_LONG */
/* 544 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 546 */	NdrFcShort( 0xff40 ),	/* Offset= -192 (354) */
/* 548 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 550 */	NdrFcShort( 0xff3c ),	/* Offset= -196 (354) */
/* 552 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 554 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 556 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 558 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 560 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 562 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (492) */
			0x5b,		/* FC_END */
/* 566 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 568 */	NdrFcLong( 0x1 ),	/* 1 */
/* 572 */	NdrFcLong( 0x1 ),	/* 1 */
/* 576 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 578 */	NdrFcShort( 0x54 ),	/* 84 */
/* 580 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 582 */	NdrFcShort( 0xfe32 ),	/* Offset= -462 (120) */
/* 584 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 586 */	NdrFcShort( 0xfe2e ),	/* Offset= -466 (120) */
/* 588 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 590 */	NdrFcShort( 0xff22 ),	/* Offset= -222 (368) */
/* 592 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 594 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 596 */	NdrFcShort( 0x54 ),	/* 84 */
/* 598 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 604 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 606 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (576) */
/* 608 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 610 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0xa ),	/* Offset= 10 (626) */
/* 618 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 620 */	NdrFcShort( 0xffca ),	/* Offset= -54 (566) */
/* 622 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 626 */	
			0x12, 0x0,	/* FC_UP */
/* 628 */	NdrFcShort( 0xffde ),	/* Offset= -34 (594) */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0xa ),	/* Offset= 10 (646) */
/* 638 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 640 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0xfd84 ),	/* Offset= -636 (6) */
/* 644 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 646 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 648 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    42
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessage,
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\unisrgt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for unisrgt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unisrgt_h__
#define __unisrgt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISurrogateService2_FWD_DEFINED__
#define __ISurrogateService2_FWD_DEFINED__
typedef interface ISurrogateService2 ISurrogateService2;
#endif 	/* __ISurrogateService2_FWD_DEFINED__ */


#ifndef __IPAControl_FWD_DEFINED__
#define __IPAControl_FWD_DEFINED__
typedef interface IPAControl IPAControl;
#endif 	/* __IPAControl_FWD_DEFINED__ */


#ifndef __IServicesSink_FWD_DEFINED__
#define __IServicesSink_FWD_DEFINED__
typedef interface IServicesSink IServicesSink;
#endif 	/* __IServicesSink_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_unisrgt_0000 */
/* [local] */ 

//+-----------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0000_ServerIfHandle;

#ifndef __ISurrogateService2_INTERFACE_DEFINED__
#define __ISurrogateService2_INTERFACE_DEFINED__

/* interface ISurrogateService2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISurrogateService2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001da-0000-0000-C000-000000000046")
    ISurrogateService2 : public ISurrogateService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PauseProcess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISurrogateService2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISurrogateService2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISurrogateService2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISurrogateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidProcessID,
            /* [in] */ IProcessLock *pProcessLock,
            /* [out] */ BOOL *pfApplicationAware);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationLaunch )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationFree )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *CatalogRefresh )( 
            ISurrogateService2 * This,
            /* [in] */ ULONG ulReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessShutdown )( 
            ISurrogateService2 * This,
            /* [in] */ ShutdownType shutdownType);
        
        HRESULT ( STDMETHODCALLTYPE *PauseProcess )( 
            ISurrogateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeProcess )( 
            ISurrogateService2 * This);
        
        END_INTERFACE
    } ISurrogateService2Vtbl;

    interface ISurrogateService2
    {
        CONST_VTBL struct ISurrogateService2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISurrogateService2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISurrogateService2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISurrogateService2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISurrogateService2_Init(This,rguidProcessID,pProcessLock,pfApplicationAware)	\
    (This)->lpVtbl -> Init(This,rguidProcessID,pProcessLock,pfApplicationAware)

#define ISurrogateService2_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define ISurrogateService2_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define ISurrogateService2_CatalogRefresh(This,ulReserved)	\
    (This)->lpVtbl -> CatalogRefresh(This,ulReserved)

#define ISurrogateService2_ProcessShutdown(This,shutdownType)	\
    (This)->lpVtbl -> ProcessShutdown(This,shutdownType)


#define ISurrogateService2_PauseProcess(This)	\
    (This)->lpVtbl -> PauseProcess(This)

#define ISurrogateService2_ResumeProcess(This)	\
    (This)->lpVtbl -> ResumeProcess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISurrogateService2_PauseProcess_Proxy( 
    ISurrogateService2 * This);


void __RPC_STUB ISurrogateService2_PauseProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService2_ResumeProcess_Proxy( 
    ISurrogateService2 * This);


void __RPC_STUB ISurrogateService2_ResumeProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISurrogateService2_INTERFACE_DEFINED__ */


#ifndef __IPAControl_INTERFACE_DEFINED__
#define __IPAControl_INTERFACE_DEFINED__

/* interface IPAControl */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPAControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d2-0000-0000-C000-000000000046")
    IPAControl : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE AddRefOnProcess( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleaseRefOnProcess( void) = 0;
        
        virtual void STDMETHODCALLTYPE PendingInit( void) = 0;
        
        virtual void STDMETHODCALLTYPE ServicesReady( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PendingApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForcedShutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdleTimeoutToZero( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectCountAtIdleTime( 
            /* [in] */ DWORD dwOIDCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPAControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPAControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *AddRefOnProcess )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *ReleaseRefOnProcess )( 
            IPAControl * This);
        
        void ( STDMETHODCALLTYPE *PendingInit )( 
            IPAControl * This);
        
        void ( STDMETHODCALLTYPE *ServicesReady )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *PendingApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendAll )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeAll )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ForcedShutdown )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIdleTimeoutToZero )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectCountAtIdleTime )( 
            IPAControl * This,
            /* [in] */ DWORD dwOIDCount);
        
        END_INTERFACE
    } IPAControlVtbl;

    interface IPAControl
    {
        CONST_VTBL struct IPAControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPAControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPAControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPAControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPAControl_AddRefOnProcess(This)	\
    (This)->lpVtbl -> AddRefOnProcess(This)

#define IPAControl_ReleaseRefOnProcess(This)	\
    (This)->lpVtbl -> ReleaseRefOnProcess(This)

#define IPAControl_PendingInit(This)	\
    (This)->lpVtbl -> PendingInit(This)

#define IPAControl_ServicesReady(This)	\
    (This)->lpVtbl -> ServicesReady(This)

#define IPAControl_SuspendApplication(This,rguidApplID)	\
    (This)->lpVtbl -> SuspendApplication(This,rguidApplID)

#define IPAControl_PendingApplication(This,rguidApplID)	\
    (This)->lpVtbl -> PendingApplication(This,rguidApplID)

#define IPAControl_ResumeApplication(This,rguidApplID)	\
    (This)->lpVtbl -> ResumeApplication(This,rguidApplID)

#define IPAControl_SuspendAll(This)	\
    (This)->lpVtbl -> SuspendAll(This)

#define IPAControl_ResumeAll(This)	\
    (This)->lpVtbl -> ResumeAll(This)

#define IPAControl_ForcedShutdown(This)	\
    (This)->lpVtbl -> ForcedShutdown(This)

#define IPAControl_SetIdleTimeoutToZero(This)	\
    (This)->lpVtbl -> SetIdleTimeoutToZero(This)

#define IPAControl_SetObjectCountAtIdleTime(This,dwOIDCount)	\
    (This)->lpVtbl -> SetObjectCountAtIdleTime(This,dwOIDCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE IPAControl_AddRefOnProcess_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_AddRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPAControl_ReleaseRefOnProcess_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ReleaseRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IPAControl_PendingInit_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_PendingInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IPAControl_ServicesReady_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ServicesReady_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SuspendApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_SuspendApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_PendingApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_PendingApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ResumeApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SuspendAll_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_SuspendAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ResumeAll_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ResumeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ForcedShutdown_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ForcedShutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SetIdleTimeoutToZero_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_SetIdleTimeoutToZero_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SetObjectCountAtIdleTime_Proxy( 
    IPAControl * This,
    /* [in] */ DWORD dwOIDCount);


void __RPC_STUB IPAControl_SetObjectCountAtIdleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPAControl_INTERFACE_DEFINED__ */


#ifndef __IServicesSink_INTERFACE_DEFINED__
#define __IServicesSink_INTERFACE_DEFINED__

/* interface IServicesSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IServicesSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d3-0000-0000-C000-000000000046")
    IServicesSink : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE ApplicationLaunch( 
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType) = 0;
        
        virtual void STDMETHODCALLTYPE ApplicationFree( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual void STDMETHODCALLTYPE ProcessFree( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseApplication( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServicesSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServicesSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServicesSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServicesSink * This);
        
        void ( STDMETHODCALLTYPE *ApplicationLaunch )( 
            IServicesSink * This,
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType);
        
        void ( STDMETHODCALLTYPE *ApplicationFree )( 
            IServicesSink * This,
            /* [in] */ REFGUID rguidApplID);
        
        void ( STDMETHODCALLTYPE *ProcessFree )( 
            IServicesSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseApplication )( 
            IServicesSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            IServicesSink * This);
        
        END_INTERFACE
    } IServicesSinkVtbl;

    interface IServicesSink
    {
        CONST_VTBL struct IServicesSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServicesSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServicesSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServicesSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServicesSink_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define IServicesSink_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define IServicesSink_ProcessFree(This)	\
    (This)->lpVtbl -> ProcessFree(This)

#define IServicesSink_PauseApplication(This)	\
    (This)->lpVtbl -> PauseApplication(This)

#define IServicesSink_ResumeApplication(This)	\
    (This)->lpVtbl -> ResumeApplication(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IServicesSink_ApplicationLaunch_Proxy( 
    IServicesSink * This,
    /* [in] */ REFGUID rguidApplID,
    /* [in] */ ApplicationType appType);


void __RPC_STUB IServicesSink_ApplicationLaunch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IServicesSink_ApplicationFree_Proxy( 
    IServicesSink * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IServicesSink_ApplicationFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IServicesSink_ProcessFree_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_ProcessFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServicesSink_PauseApplication_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_PauseApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServicesSink_ResumeApplication_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServicesSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_unisrgt_0097 */
/* [local] */ 

STDAPI CoRegisterSurrogateEx (REFGUID rguidProcessID,		
							  ISurrogate* pSrgt);			
STDAPI CoLoadServices (REFGUID rguidProcessID,				
					   IPAControl* pPAControl,				
					   REFIID riid, void **ppv );			
typedef HRESULT (STDAPICALLTYPE *FN_CoLoadServices)			
								(REFGUID rguidProcessID,	
								 IPAControl* pPAControl,	
								 REFIID riid, void **ppv );	


extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0097_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0097_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\agp.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//


#ifndef __AGP_INCLUDED__
#define __AGP_INCLUDED__

DEFINE_GUID(GUID_AGP_INTERFACE, 0xd6c9df40, 0xa1a2, 0x11d1, 0x81, 0x15, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

#ifndef GUID_DEFS_ONLY

//
// Temporary Hack...
//

#ifndef IsEqualGUID
#ifdef __cplusplus
    inline int IsEqualGUID(REFGUID guid1, REFGUID guid2)
        {
            return !memcmp(&guid1, &guid2, sizeof(GUID));
        }
#else // !__cplusplus
    #define IsEqualGUID(guid1, guid2) \
        (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif // !__cplusplus
#endif

#define AGP_INTERFACE_VERSION 1

typedef struct _AGP_INTERFACE
{
    USHORT           Size;
    USHORT           Version;
    PVOID            Context;
    PVOID            InterfaceReference;
    PVOID            InterfaceDereference;

    VIDEO_PORT_AGP_SERVICES AgpServices;

} AGP_INTERFACE, *PAGP_INTERFACE;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\trkwks_c.c ===
/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   843                               
#define PROC_FORMAT_STRING_SIZE   701                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */



static const RPC_CLIENT_INTERFACE trkwks___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000001
    };
RPC_IF_HANDLE trkwks_v1_2_c_ifspec = (RPC_IF_HANDLE)& trkwks___RpcClientInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;

static RPC_BINDING_HANDLE trkwks__MIDL_AutoBindHandle;


HRESULT old_LnkMendLink( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [string][out] */ WCHAR wsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidReferral,
    /* [string][out] */ TCHAR tsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[70],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[128],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSetVolumeId( 
    /* [in] */ handle_t IDL_handle,
    ULONG volumeIndex,
    const CVolumeId VolId)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkRestartDcSynchronization( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[214],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetVolumeTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CVolumeId volid,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[248],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetFileTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CDomainRelativeObjId droidCurrent,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[300],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT TriggerVolumeClaims( 
    /* [in] */ handle_t IDL_handle,
    /* [range][in] */ ULONG cVolumes,
    /* [size_is][in] */ const CVolumeId *rgvolid)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[352],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkOnRestore( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[398],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


/* [async] */ void  LnkMendLink( 
    /* [in] */ PRPC_ASYNC_STATE LnkMendLink_AsyncHandle,
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [in] */ const CMachineId *pmcidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [out] */ CMachineId *pmcidCurrent,
    /* [out][in] */ CBPATH *pcbPath,
    /* [string][size_is][out] */ WCHAR *pwszPath)
{

    NdrAsyncClientCall(
                      ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                      (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                      ( unsigned char * )&LnkMendLink_AsyncHandle);
    
}


HRESULT old2_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[520],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[584],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirthLast,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidBirthNext,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[624],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   [async] attribute, /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 34 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 40 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 42 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 44 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 46 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 50 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 52 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 54 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 56 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 58 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 60 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 62 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 64 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 66 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 70 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 72 */	NdrFcLong( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x1 ),	/* 1 */
/* 78 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 80 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 84 */	NdrFcShort( 0xac ),	/* 172 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 90 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 98 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 104 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 106 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 108 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 110 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 114 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 116 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 118 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 120 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 124 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 128 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x2 ),	/* 2 */
/* 136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 146 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 148 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xb ),	/* 11 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 156 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 160 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter pMsg */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 178 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 182 */	NdrFcShort( 0x48 ),	/* 72 */
/* 184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 186 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 188 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 202 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 206 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 210 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 214 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x4 ),	/* 4 */
/* 222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 224 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 232 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 234 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 248 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x5 ),	/* 5 */
/* 256 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 262 */	NdrFcShort( 0x48 ),	/* 72 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 268 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 276 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 286 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 288 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 290 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 292 */	NdrFcShort( 0x23a ),	/* Type Offset=570 */

	/* Parameter pipeVolInfo */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 300 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	NdrFcShort( 0x6 ),	/* 6 */
/* 308 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 310 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 314 */	NdrFcShort( 0x98 ),	/* 152 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 320 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 328 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 332 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 336 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 338 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 340 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 342 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 344 */	NdrFcShort( 0x242 ),	/* Type Offset=578 */

	/* Parameter pipeFileInfo */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 352 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x7 ),	/* 7 */
/* 360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 362 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 370 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 372 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* 1 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 380 */	NdrFcShort( 0x88 ),	/* Flags:  in, by val, */
/* 382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 384 */	NdrFcShort( 0x24a ),	/* 586 */

	/* Parameter cVolumes */

/* 386 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 388 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 390 */	NdrFcShort( 0x258 ),	/* Type Offset=600 */

	/* Parameter rgvolid */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 398 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x8 ),	/* 8 */
/* 406 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 408 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 418 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x9 ),	/* 9 */
/* 440 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 442 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 446 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 448 */	NdrFcShort( 0x10c ),	/* 268 */
/* 450 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 452 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 460 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 472 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 476 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 478 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 480 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 482 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 484 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 486 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 488 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidLast */

/* 490 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 492 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 494 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 496 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 498 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 500 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidCurrent */

/* 502 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 504 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 506 */	NdrFcShort( 0x274 ),	/* Type Offset=628 */

	/* Parameter pcbPath */

/* 508 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 510 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 512 */	NdrFcShort( 0x282 ),	/* Type Offset=642 */

	/* Parameter pwszPath */

/* 514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 516 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 520 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0xa ),	/* 10 */
/* 528 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 530 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 534 */	NdrFcShort( 0xac ),	/* 172 */
/* 536 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 538 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 540 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 542 */	NdrFcShort( 0x1 ),	/* 1 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 554 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 558 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 560 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 564 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 566 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 570 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidNext */

/* 572 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 576 */	NdrFcShort( 0x28e ),	/* Type Offset=654 */

	/* Parameter ptszPath */

/* 578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 580 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 584 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0xb ),	/* 11 */
/* 592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 594 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 602 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 604 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 606 */	NdrFcShort( 0xb ),	/* 11 */
/* 608 */	NdrFcShort( 0xb ),	/* 11 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 612 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 614 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 616 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Parameter pMsg */

/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 620 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 624 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* 12 */
/* 632 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 634 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 638 */	NdrFcShort( 0x150 ),	/* 336 */
/* 640 */	NdrFcShort( 0x194 ),	/* 404 */
/* 642 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 644 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 646 */	NdrFcShort( 0x1 ),	/* 1 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 658 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 662 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 664 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 668 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 670 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 674 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 676 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 678 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 680 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 682 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 684 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 686 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidNext */

/* 688 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 690 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 692 */	NdrFcShort( 0x342 ),	/* Type Offset=834 */

	/* Parameter ptszPath */

/* 694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 696 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x1da ),	/* Offset= 474 (540) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x20 ),	/* 32 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x56 ),	/* Offset= 86 (172) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x8c ),	/* Offset= 140 (232) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xce ),	/* Offset= 206 (304) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x134 ),	/* Offset= 308 (412) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x154 ),	/* Offset= 340 (450) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x196 ),	/* Offset= 406 (522) */
/* 118 */	NdrFcShort( 0xffff ),	/* Offset= -1 (117) */
/* 120 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 122 */	NdrFcLong( 0x1 ),	/* 1 */
/* 126 */	NdrFcLong( 0x1 ),	/* 1 */
/* 130 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 132 */	NdrFcShort( 0x202 ),	/* 514 */
/* 134 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 136 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0x248 ),	/* 584 */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (130) */
/* 144 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 146 */	0x0,		/* 0 */
			NdrFcShort( 0xff97 ),	/* Offset= -105 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 150 */	0x0,		/* 0 */
			NdrFcShort( 0xff93 ),	/* Offset= -109 (42) */
			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x248 ),	/* 584 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x8 ),	/* Offset= 8 (186) */
/* 180 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 182 */	NdrFcShort( 0xffc2 ),	/* Offset= -62 (120) */
/* 184 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (156) */
/* 190 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcLong( 0x40 ),	/* 64 */
/* 200 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 212 */	NdrFcShort( 0xff4c ),	/* Offset= -180 (32) */
/* 214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 216 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 218 */	NdrFcShort( 0x20 ),	/* 32 */
/* 220 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 226 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 228 */	NdrFcShort( 0xff46 ),	/* Offset= -186 (42) */
/* 230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 232 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 234 */	NdrFcShort( 0x20 ),	/* 32 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0xe ),	/* Offset= 14 (252) */
/* 240 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 242 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (190) */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 252 */	
			0x12, 0x0,	/* FC_UP */
/* 254 */	NdrFcShort( 0xff22 ),	/* Offset= -222 (32) */
/* 256 */	
			0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (200) */
/* 260 */	
			0x12, 0x0,	/* FC_UP */
/* 262 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (216) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0xffce ),	/* Offset= -50 (216) */
/* 268 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcLong( 0x80 ),	/* 128 */
/* 278 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 284 */	NdrFcLong( 0x1a ),	/* 26 */
/* 288 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x10 ),	/* 16 */
/* 292 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 298 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 300 */	NdrFcShort( 0xfef4 ),	/* Offset= -268 (32) */
/* 302 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 306 */	NdrFcShort( 0x10 ),	/* 16 */
/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0xe ),	/* Offset= 14 (324) */
/* 312 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 314 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (268) */
/* 316 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 318 */	0x0,		/* 0 */
			NdrFcShort( 0xffd7 ),	/* Offset= -41 (278) */
			0x36,		/* FC_POINTER */
/* 322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 324 */	
			0x12, 0x0,	/* FC_UP */
/* 326 */	NdrFcShort( 0xff92 ),	/* Offset= -110 (216) */
/* 328 */	
			0x12, 0x0,	/* FC_UP */
/* 330 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (288) */
/* 332 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 338 */	NdrFcLong( 0x1a ),	/* 26 */
/* 342 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 344 */	NdrFcShort( 0x8 ),	/* 8 */
/* 346 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 348 */	NdrFcShort( 0xfeb2 ),	/* Offset= -334 (14) */
/* 350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 352 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 356 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 358 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
/* 362 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (352) */
/* 366 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 368 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 370 */	NdrFcShort( 0x44 ),	/* 68 */
/* 372 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 374 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 376 */	NdrFcShort( 0xfea8 ),	/* Offset= -344 (32) */
/* 378 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 380 */	NdrFcShort( 0xffda ),	/* Offset= -38 (342) */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (342) */
/* 386 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xfe7d ),	/* Offset= -387 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 392 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (358) */
			0x5b,		/* FC_END */
/* 396 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 398 */	NdrFcShort( 0x44 ),	/* 68 */
/* 400 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 402 */	NdrFcShort( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 406 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 408 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (368) */
/* 410 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 412 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x8 ),	/* Offset= 8 (426) */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xffa6 ),	/* Offset= -90 (332) */
/* 424 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 426 */	
			0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (396) */
/* 430 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 436 */	NdrFcLong( 0x20 ),	/* 32 */
/* 440 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 442 */	NdrFcLong( 0x0 ),	/* 0 */
/* 446 */	NdrFcLong( 0x1a ),	/* 26 */
/* 450 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 452 */	NdrFcShort( 0x10 ),	/* 16 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0xe ),	/* Offset= 14 (470) */
/* 458 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 460 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (430) */
/* 462 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 464 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (440) */
			0x36,		/* FC_POINTER */
/* 468 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 470 */	
			0x12, 0x0,	/* FC_UP */
/* 472 */	NdrFcShort( 0xff00 ),	/* Offset= -256 (216) */
/* 474 */	
			0x12, 0x0,	/* FC_UP */
/* 476 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (288) */
/* 478 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 480 */	NdrFcLong( 0x1 ),	/* 1 */
/* 484 */	NdrFcLong( 0x1 ),	/* 1 */
/* 488 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x54 ),	/* 84 */
/* 492 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 494 */	NdrFcShort( 0xfe3c ),	/* Offset= -452 (42) */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xfe38 ),	/* Offset= -456 (42) */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xff70 ),	/* Offset= -144 (358) */
/* 504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x54 ),	/* 84 */
/* 510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 516 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 518 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (488) */
/* 520 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 522 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x8 ),	/* Offset= 8 (536) */
/* 530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0xffca ),	/* Offset= -54 (478) */
/* 534 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 536 */	
			0x12, 0x0,	/* FC_UP */
/* 538 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (506) */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x28 ),	/* 40 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* Offset= 10 (556) */
/* 548 */	0xe,		/* FC_ENUM32 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 550 */	0x0,		/* 0 */
			NdrFcShort( 0xfe1d ),	/* Offset= -483 (68) */
			0x36,		/* FC_POINTER */
/* 554 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 556 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 558 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 560 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 562 */	NdrFcShort( 0x14 ),	/* 20 */
/* 564 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 566 */	0x0,		/* 0 */
			NdrFcShort( 0xfde9 ),	/* Offset= -535 (32) */
			0x5b,		/* FC_END */
/* 570 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (560) */
/* 574 */	NdrFcShort( 0x14 ),	/* 20 */
/* 576 */	NdrFcShort( 0x14 ),	/* 20 */
/* 578 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (488) */
/* 582 */	NdrFcShort( 0x54 ),	/* 84 */
/* 584 */	NdrFcShort( 0x54 ),	/* 84 */
/* 586 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 588 */	NdrFcLong( 0x1 ),	/* 1 */
/* 592 */	NdrFcLong( 0x1a ),	/* 26 */
/* 596 */	
			0x11, 0x0,	/* FC_RP */
/* 598 */	NdrFcShort( 0x2 ),	/* Offset= 2 (600) */
/* 600 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 602 */	NdrFcShort( 0x10 ),	/* 16 */
/* 604 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 606 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 608 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfdbc ),	/* Offset= -580 (32) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x11, 0x0,	/* FC_RP */
/* 618 */	NdrFcShort( 0xfefc ),	/* Offset= -260 (358) */
/* 620 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 622 */	NdrFcShort( 0xfef8 ),	/* Offset= -264 (358) */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x2 ),	/* Offset= 2 (628) */
/* 628 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 630 */	NdrFcLong( 0x1 ),	/* 1 */
/* 634 */	NdrFcLong( 0x20a ),	/* 522 */
/* 638 */	
			0x11, 0x0,	/* FC_RP */
/* 640 */	NdrFcShort( 0x2 ),	/* Offset= 2 (642) */
/* 642 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 644 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 646 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 648 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 650 */	
			0x11, 0x0,	/* FC_RP */
/* 652 */	NdrFcShort( 0x2 ),	/* Offset= 2 (654) */
/* 654 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 656 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 658 */	NdrFcShort( 0x106 ),	/* 262 */
/* 660 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 662 */	
			0x11, 0x0,	/* FC_RP */
/* 664 */	NdrFcShort( 0x92 ),	/* Offset= 146 (810) */
/* 666 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 668 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 670 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 672 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 674 */	NdrFcShort( 0x2 ),	/* Offset= 2 (676) */
/* 676 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 678 */	NdrFcShort( 0x9 ),	/* 9 */
/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 684 */	NdrFcShort( 0xfe00 ),	/* Offset= -512 (172) */
/* 686 */	NdrFcLong( 0x1 ),	/* 1 */
/* 690 */	NdrFcShort( 0xfe36 ),	/* Offset= -458 (232) */
/* 692 */	NdrFcLong( 0x2 ),	/* 2 */
/* 696 */	NdrFcShort( 0xfe78 ),	/* Offset= -392 (304) */
/* 698 */	NdrFcLong( 0x3 ),	/* 3 */
/* 702 */	NdrFcShort( 0xfede ),	/* Offset= -290 (412) */
/* 704 */	NdrFcLong( 0x4 ),	/* 4 */
/* 708 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (450) */
/* 710 */	NdrFcLong( 0x5 ),	/* 5 */
/* 714 */	NdrFcShort( 0x1e ),	/* Offset= 30 (744) */
/* 716 */	NdrFcLong( 0x6 ),	/* 6 */
/* 720 */	NdrFcShort( 0xff3a ),	/* Offset= -198 (522) */
/* 722 */	NdrFcLong( 0x7 ),	/* 7 */
/* 726 */	NdrFcShort( 0xfd2c ),	/* Offset= -724 (2) */
/* 728 */	NdrFcLong( 0x8 ),	/* 8 */
/* 732 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 734 */	NdrFcShort( 0xffff ),	/* Offset= -1 (733) */
/* 736 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 738 */	NdrFcShort( 0xc ),	/* 12 */
/* 740 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 742 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 744 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 746 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 748 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 750 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 752 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 754 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 756 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 758 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 760 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 774 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 776 */	NdrFcShort( 0xfcfa ),	/* Offset= -774 (2) */
/* 778 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 780 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 782 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 784 */	0x0,		/* 0 */
			NdrFcShort( 0xfcf1 ),	/* Offset= -783 (2) */
			0x8,		/* FC_LONG */
/* 788 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 790 */	NdrFcShort( 0xfcec ),	/* Offset= -788 (2) */
/* 792 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 794 */	NdrFcShort( 0xfce8 ),	/* Offset= -792 (2) */
/* 796 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 802 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 804 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (736) */
			0x5b,		/* FC_END */
/* 810 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 812 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 816 */	NdrFcShort( 0xa ),	/* Offset= 10 (826) */
/* 818 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 820 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 822 */	NdrFcShort( 0xff64 ),	/* Offset= -156 (666) */
/* 824 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 826 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 828 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 830 */	
			0x11, 0x0,	/* FC_RP */
/* 832 */	NdrFcShort( 0x2 ),	/* Offset= 2 (834) */
/* 834 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 836 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 838 */	NdrFcShort( 0x106 ),	/* 262 */
/* 840 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    70,
    128,
    168,
    214,
    248,
    300,
    352,
    398,
    432,
    520,
    584,
    624
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &trkwks__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>

#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   853                               
#define PROC_FORMAT_STRING_SIZE   727                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */



static const RPC_CLIENT_INTERFACE trkwks___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000001
    };
RPC_IF_HANDLE trkwks_v1_2_c_ifspec = (RPC_IF_HANDLE)& trkwks___RpcClientInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;

static RPC_BINDING_HANDLE trkwks__MIDL_AutoBindHandle;


HRESULT old_LnkMendLink( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [string][out] */ WCHAR wsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  IDL_handle,
                  ftLimit,
                  Restrictions,
                  pdroidBirth,
                  pdroidLast,
                  pdroidCurrent,
                  wsz);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidReferral,
    /* [string][out] */ TCHAR tsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[72],
                  IDL_handle,
                  Restrictions,
                  pdroidLast,
                  pdroidReferral,
                  tsz);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[132],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSetVolumeId( 
    /* [in] */ handle_t IDL_handle,
    ULONG volumeIndex,
    const CVolumeId VolId)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[174],
                  IDL_handle,
                  volumeIndex,
                  VolId);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkRestartDcSynchronization( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[222],
                  IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetVolumeTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CVolumeId volid,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[258],
                  IDL_handle,
                  volid,
                  scope,
                  pipeVolInfo);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetFileTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CDomainRelativeObjId droidCurrent,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[312],
                  IDL_handle,
                  droidCurrent,
                  scope,
                  pipeFileInfo);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT TriggerVolumeClaims( 
    /* [in] */ handle_t IDL_handle,
    /* [range][in] */ ULONG cVolumes,
    /* [size_is][in] */ const CVolumeId *rgvolid)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[366],
                  IDL_handle,
                  cVolumes,
                  rgvolid);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkOnRestore( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[414],
                  IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


/* [async] */ void  LnkMendLink( 
    /* [in] */ PRPC_ASYNC_STATE LnkMendLink_AsyncHandle,
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [in] */ const CMachineId *pmcidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [out] */ CMachineId *pmcidCurrent,
    /* [out][in] */ CBPATH *pcbPath,
    /* [string][size_is][out] */ WCHAR *pwszPath)
{

    NdrAsyncClientCall(
                      ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                      (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[450],
                      LnkMendLink_AsyncHandle,
                      IDL_handle,
                      ftLimit,
                      Restrictions,
                      pdroidBirth,
                      pdroidLast,
                      pmcidLast,
                      pdroidCurrent,
                      pmcidCurrent,
                      pcbPath,
                      pwszPath);
    
}


HRESULT old2_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  IDL_handle,
                  Restrictions,
                  pdroidLast,
                  pdroidNext,
                  pmcidNext,
                  ptszPath);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[606],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirthLast,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidBirthNext,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  IDL_handle,
                  Restrictions,
                  pdroidBirthLast,
                  pdroidLast,
                  pdroidBirthNext,
                  pdroidNext,
                  pmcidNext,
                  ptszPath);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 42 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 44 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 48 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 50 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 52 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 54 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 56 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 58 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 60 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 62 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 64 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 72 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x1 ),	/* 1 */
/* 80 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 82 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	NdrFcShort( 0xac ),	/* 172 */
/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 92 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 112 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 114 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 116 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 118 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 122 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 124 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 128 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 132 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 144 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 152 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 154 */	NdrFcShort( 0xb ),	/* 11 */
/* 156 */	NdrFcShort( 0xb ),	/* 11 */
/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 162 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 164 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 166 */	NdrFcShort( 0x226 ),	/* Type Offset=550 */

	/* Parameter pMsg */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 170 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 174 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x3 ),	/* 3 */
/* 182 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 184 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 186 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 188 */	NdrFcShort( 0x48 ),	/* 72 */
/* 190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 192 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 206 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 210 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 212 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 214 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 218 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 222 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 224 */	NdrFcLong( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 232 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 242 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 258 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 270 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 272 */	NdrFcShort( 0x48 ),	/* 72 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 278 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 288 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 290 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 292 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 298 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 300 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 302 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 304 */	NdrFcShort( 0x244 ),	/* Type Offset=580 */

	/* Parameter pipeVolInfo */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 312 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 322 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 326 */	NdrFcShort( 0x98 ),	/* 152 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 332 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 342 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 346 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 352 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 354 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 356 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 358 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter pipeFileInfo */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 366 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 376 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 384 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 386 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 396 */	NdrFcShort( 0x88 ),	/* Flags:  in, by val, */
/* 398 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 400 */	NdrFcShort( 0x254 ),	/* 596 */

	/* Parameter cVolumes */

/* 402 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 404 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 406 */	NdrFcShort( 0x262 ),	/* Type Offset=610 */

	/* Parameter rgvolid */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 414 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 424 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 432 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 434 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 450 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 460 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 466 */	NdrFcShort( 0x10c ),	/* 268 */
/* 468 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 470 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 472 */	NdrFcShort( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 480 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 482 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 484 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 488 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 492 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 494 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 496 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 498 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 500 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 504 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 506 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 508 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidLast */

/* 510 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 512 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 514 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 516 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 518 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 520 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidCurrent */

/* 522 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 524 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 526 */	NdrFcShort( 0x27e ),	/* Type Offset=638 */

	/* Parameter pcbPath */

/* 528 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 530 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 532 */	NdrFcShort( 0x28c ),	/* Type Offset=652 */

	/* Parameter pwszPath */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* 10 */
/* 548 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 550 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 552 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 554 */	NdrFcShort( 0xac ),	/* 172 */
/* 556 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 558 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 560 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 562 */	NdrFcShort( 0x1 ),	/* 1 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 570 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 572 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 576 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 578 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 580 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 582 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 584 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 586 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 588 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 590 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 592 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidNext */

/* 594 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 596 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 598 */	NdrFcShort( 0x298 ),	/* Type Offset=664 */

	/* Parameter ptszPath */

/* 600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 602 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 606 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 608 */	NdrFcLong( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0xb ),	/* 11 */
/* 614 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 616 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 618 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 624 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 626 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 628 */	NdrFcShort( 0xb ),	/* 11 */
/* 630 */	NdrFcShort( 0xb ),	/* 11 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 636 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 638 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 640 */	NdrFcShort( 0x334 ),	/* Type Offset=820 */

	/* Parameter pMsg */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xc ),	/* 12 */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 662 */	NdrFcShort( 0x150 ),	/* 336 */
/* 664 */	NdrFcShort( 0x194 ),	/* 404 */
/* 666 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 668 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 670 */	NdrFcShort( 0x1 ),	/* 1 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 678 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 680 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 684 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 686 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 688 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 690 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 692 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 694 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 696 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 698 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 700 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 702 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 704 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 706 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 708 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 710 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 712 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidNext */

/* 714 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 716 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 718 */	NdrFcShort( 0x34c ),	/* Type Offset=844 */

	/* Parameter ptszPath */

/* 720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 722 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (550) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x30 ),	/* 48 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x56 ),	/* Offset= 86 (172) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x8e ),	/* Offset= 142 (234) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (306) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x138 ),	/* Offset= 312 (416) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x15a ),	/* Offset= 346 (456) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x19e ),	/* Offset= 414 (530) */
/* 118 */	NdrFcShort( 0xffff ),	/* Offset= -1 (117) */
/* 120 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 122 */	NdrFcLong( 0x1 ),	/* 1 */
/* 126 */	NdrFcLong( 0x1 ),	/* 1 */
/* 130 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 132 */	NdrFcShort( 0x202 ),	/* 514 */
/* 134 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 136 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0x248 ),	/* 584 */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (130) */
/* 144 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 146 */	0x0,		/* 0 */
			NdrFcShort( 0xff97 ),	/* Offset= -105 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 150 */	0x0,		/* 0 */
			NdrFcShort( 0xff93 ),	/* Offset= -109 (42) */
			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x248 ),	/* 584 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x10 ),	/* 16 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0xa ),	/* Offset= 10 (188) */
/* 180 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 182 */	NdrFcShort( 0xffc2 ),	/* Offset= -62 (120) */
/* 184 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 186 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 188 */	
			0x12, 0x0,	/* FC_UP */
/* 190 */	NdrFcShort( 0xffde ),	/* Offset= -34 (156) */
/* 192 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 194 */	NdrFcLong( 0x0 ),	/* 0 */
/* 198 */	NdrFcLong( 0x40 ),	/* 64 */
/* 202 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 204 */	NdrFcShort( 0x10 ),	/* 16 */
/* 206 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 210 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 212 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 214 */	NdrFcShort( 0xff4a ),	/* Offset= -182 (32) */
/* 216 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 218 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 220 */	NdrFcShort( 0x20 ),	/* 32 */
/* 222 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 228 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 230 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (42) */
/* 232 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 234 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 236 */	NdrFcShort( 0x30 ),	/* 48 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0xe ),	/* Offset= 14 (254) */
/* 242 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 244 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (192) */
/* 246 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 248 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 252 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xff20 ),	/* Offset= -224 (32) */
/* 258 */	
			0x12, 0x0,	/* FC_UP */
/* 260 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (202) */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (218) */
/* 266 */	
			0x12, 0x0,	/* FC_UP */
/* 268 */	NdrFcShort( 0xffce ),	/* Offset= -50 (218) */
/* 270 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 272 */	NdrFcLong( 0x0 ),	/* 0 */
/* 276 */	NdrFcLong( 0x80 ),	/* 128 */
/* 280 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcLong( 0x1a ),	/* 26 */
/* 290 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x10 ),	/* 16 */
/* 294 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (32) */
/* 304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 306 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 308 */	NdrFcShort( 0x20 ),	/* 32 */
/* 310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 312 */	NdrFcShort( 0x10 ),	/* Offset= 16 (328) */
/* 314 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 316 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (270) */
/* 318 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (280) */
/* 324 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 328 */	
			0x12, 0x0,	/* FC_UP */
/* 330 */	NdrFcShort( 0xff90 ),	/* Offset= -112 (218) */
/* 332 */	
			0x12, 0x0,	/* FC_UP */
/* 334 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (290) */
/* 336 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcLong( 0x1a ),	/* 26 */
/* 346 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
/* 350 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 352 */	NdrFcShort( 0xfeae ),	/* Offset= -338 (14) */
/* 354 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 356 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 358 */	NdrFcShort( 0x10 ),	/* 16 */
/* 360 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 362 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x10 ),	/* 16 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (356) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x44 ),	/* 68 */
/* 376 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 378 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 380 */	NdrFcShort( 0xfea4 ),	/* Offset= -348 (32) */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffda ),	/* Offset= -38 (346) */
/* 386 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 388 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (346) */
/* 390 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 392 */	0x0,		/* 0 */
			NdrFcShort( 0xfe79 ),	/* Offset= -391 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 396 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (362) */
			0x5b,		/* FC_END */
/* 400 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 402 */	NdrFcShort( 0x44 ),	/* 68 */
/* 404 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 410 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 412 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (372) */
/* 414 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 416 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 418 */	NdrFcShort( 0x10 ),	/* 16 */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0xa ),	/* Offset= 10 (432) */
/* 424 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0xffa6 ),	/* Offset= -90 (336) */
/* 428 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 430 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 432 */	
			0x12, 0x0,	/* FC_UP */
/* 434 */	NdrFcShort( 0xffde ),	/* Offset= -34 (400) */
/* 436 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcLong( 0x20 ),	/* 32 */
/* 446 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcLong( 0x1a ),	/* 26 */
/* 456 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 458 */	NdrFcShort( 0x20 ),	/* 32 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x10 ),	/* Offset= 16 (478) */
/* 464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 466 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (436) */
/* 468 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (446) */
/* 474 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x12, 0x0,	/* FC_UP */
/* 480 */	NdrFcShort( 0xfefa ),	/* Offset= -262 (218) */
/* 482 */	
			0x12, 0x0,	/* FC_UP */
/* 484 */	NdrFcShort( 0xff3e ),	/* Offset= -194 (290) */
/* 486 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 488 */	NdrFcLong( 0x1 ),	/* 1 */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 498 */	NdrFcShort( 0x54 ),	/* 84 */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xfe34 ),	/* Offset= -460 (42) */
/* 504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 506 */	NdrFcShort( 0xfe30 ),	/* Offset= -464 (42) */
/* 508 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 510 */	NdrFcShort( 0xff6c ),	/* Offset= -148 (362) */
/* 512 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 514 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 516 */	NdrFcShort( 0x54 ),	/* 84 */
/* 518 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 524 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 526 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (496) */
/* 528 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 530 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 532 */	NdrFcShort( 0x10 ),	/* 16 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0xa ),	/* Offset= 10 (546) */
/* 538 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 540 */	NdrFcShort( 0xffca ),	/* Offset= -54 (486) */
/* 542 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 546 */	
			0x12, 0x0,	/* FC_UP */
/* 548 */	NdrFcShort( 0xffde ),	/* Offset= -34 (514) */
/* 550 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x40 ),	/* 64 */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0xa ),	/* Offset= 10 (566) */
/* 558 */	0xe,		/* FC_ENUM32 */
			0x40,		/* FC_STRUCTPAD4 */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xfe12 ),	/* Offset= -494 (68) */
/* 564 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 566 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 568 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 570 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x14 ),	/* 20 */
/* 574 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 576 */	0x0,		/* 0 */
			NdrFcShort( 0xfddf ),	/* Offset= -545 (32) */
			0x5b,		/* FC_END */
/* 580 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 582 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (570) */
/* 584 */	NdrFcShort( 0x14 ),	/* 20 */
/* 586 */	NdrFcShort( 0x14 ),	/* 20 */
/* 588 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 590 */	NdrFcShort( 0xffa2 ),	/* Offset= -94 (496) */
/* 592 */	NdrFcShort( 0x54 ),	/* 84 */
/* 594 */	NdrFcShort( 0x54 ),	/* 84 */
/* 596 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 598 */	NdrFcLong( 0x1 ),	/* 1 */
/* 602 */	NdrFcLong( 0x1a ),	/* 26 */
/* 606 */	
			0x11, 0x0,	/* FC_RP */
/* 608 */	NdrFcShort( 0x2 ),	/* Offset= 2 (610) */
/* 610 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 616 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 618 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 620 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 622 */	NdrFcShort( 0xfdb2 ),	/* Offset= -590 (32) */
/* 624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 626 */	
			0x11, 0x0,	/* FC_RP */
/* 628 */	NdrFcShort( 0xfef6 ),	/* Offset= -266 (362) */
/* 630 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 632 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (362) */
/* 634 */	
			0x11, 0x0,	/* FC_RP */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 640 */	NdrFcLong( 0x1 ),	/* 1 */
/* 644 */	NdrFcLong( 0x20a ),	/* 522 */
/* 648 */	
			0x11, 0x0,	/* FC_RP */
/* 650 */	NdrFcShort( 0x2 ),	/* Offset= 2 (652) */
/* 652 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 654 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 660 */	
			0x11, 0x0,	/* FC_RP */
/* 662 */	NdrFcShort( 0x2 ),	/* Offset= 2 (664) */
/* 664 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 666 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 668 */	NdrFcShort( 0x106 ),	/* 262 */
/* 670 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 672 */	
			0x11, 0x0,	/* FC_RP */
/* 674 */	NdrFcShort( 0x92 ),	/* Offset= 146 (820) */
/* 676 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 678 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 680 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 682 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 684 */	NdrFcShort( 0x2 ),	/* Offset= 2 (686) */
/* 686 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 688 */	NdrFcShort( 0x9 ),	/* 9 */
/* 690 */	NdrFcLong( 0x0 ),	/* 0 */
/* 694 */	NdrFcShort( 0xfdf6 ),	/* Offset= -522 (172) */
/* 696 */	NdrFcLong( 0x1 ),	/* 1 */
/* 700 */	NdrFcShort( 0xfe2e ),	/* Offset= -466 (234) */
/* 702 */	NdrFcLong( 0x2 ),	/* 2 */
/* 706 */	NdrFcShort( 0xfe70 ),	/* Offset= -400 (306) */
/* 708 */	NdrFcLong( 0x3 ),	/* 3 */
/* 712 */	NdrFcShort( 0xfed8 ),	/* Offset= -296 (416) */
/* 714 */	NdrFcLong( 0x4 ),	/* 4 */
/* 718 */	NdrFcShort( 0xfefa ),	/* Offset= -262 (456) */
/* 720 */	NdrFcLong( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x1e ),	/* Offset= 30 (754) */
/* 726 */	NdrFcLong( 0x6 ),	/* 6 */
/* 730 */	NdrFcShort( 0xff38 ),	/* Offset= -200 (530) */
/* 732 */	NdrFcLong( 0x7 ),	/* 7 */
/* 736 */	NdrFcShort( 0xfd22 ),	/* Offset= -734 (2) */
/* 738 */	NdrFcLong( 0x8 ),	/* 8 */
/* 742 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 744 */	NdrFcShort( 0xffff ),	/* Offset= -1 (743) */
/* 746 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 748 */	NdrFcShort( 0xc ),	/* 12 */
/* 750 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 752 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 754 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 756 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 758 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 760 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 774 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 776 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 778 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 780 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 782 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xfcf0 ),	/* Offset= -784 (2) */
/* 788 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 790 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 792 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 794 */	0x0,		/* 0 */
			NdrFcShort( 0xfce7 ),	/* Offset= -793 (2) */
			0x8,		/* FC_LONG */
/* 798 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 800 */	NdrFcShort( 0xfce2 ),	/* Offset= -798 (2) */
/* 802 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 804 */	NdrFcShort( 0xfcde ),	/* Offset= -802 (2) */
/* 806 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 808 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 810 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 812 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 814 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 816 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (746) */
			0x5b,		/* FC_END */
/* 820 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 822 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0xa ),	/* Offset= 10 (836) */
/* 828 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 830 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 832 */	NdrFcShort( 0xff64 ),	/* Offset= -156 (676) */
/* 834 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 836 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 838 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x11, 0x0,	/* FC_RP */
/* 842 */	NdrFcShort( 0x2 ),	/* Offset= 2 (844) */
/* 844 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 846 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 848 */	NdrFcShort( 0x106 ),	/* 262 */
/* 850 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    72,
    132,
    174,
    222,
    258,
    312,
    366,
    414,
    450,
    540,
    606,
    648
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &trkwks__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\com\inc\trkwks_s.c ===
/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   843                               
#define PROC_FORMAT_STRING_SIZE   701                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */


extern const MIDL_SERVER_INFO trkwks_ServerInfo;

extern RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable;

static const RPC_SERVER_INTERFACE trkwks___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trkwks_v1_2_DispatchTable,
    0,
    0,
    0,
    &trkwks_ServerInfo,
    0x04000001
    };
RPC_IF_HANDLE Stubtrkwks_v1_2_s_ifspec = (RPC_IF_HANDLE)& trkwks___RpcServerInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   [async] attribute, /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 34 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 40 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 42 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 44 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 46 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 50 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 52 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 54 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 56 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 58 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 60 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 62 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 64 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 66 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 70 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 72 */	NdrFcLong( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x1 ),	/* 1 */
/* 78 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 80 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 84 */	NdrFcShort( 0xac ),	/* 172 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 90 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 98 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 104 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 106 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 108 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 110 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 114 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 116 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 118 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 120 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 124 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 128 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x2 ),	/* 2 */
/* 136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 146 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 148 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xb ),	/* 11 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 156 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 160 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter pMsg */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 178 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 182 */	NdrFcShort( 0x48 ),	/* 72 */
/* 184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 186 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 188 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 202 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 206 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 210 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 214 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x4 ),	/* 4 */
/* 222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 224 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 232 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 234 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 248 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x5 ),	/* 5 */
/* 256 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 262 */	NdrFcShort( 0x48 ),	/* 72 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 268 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 276 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 286 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 288 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 290 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 292 */	NdrFcShort( 0x23a ),	/* Type Offset=570 */

	/* Parameter pipeVolInfo */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 300 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	NdrFcShort( 0x6 ),	/* 6 */
/* 308 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 310 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 314 */	NdrFcShort( 0x98 ),	/* 152 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 320 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 328 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 332 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 336 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 338 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 340 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 342 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 344 */	NdrFcShort( 0x242 ),	/* Type Offset=578 */

	/* Parameter pipeFileInfo */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 352 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x7 ),	/* 7 */
/* 360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 362 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 370 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 372 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* 1 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 380 */	NdrFcShort( 0x88 ),	/* Flags:  in, by val, */
/* 382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 384 */	NdrFcShort( 0x24a ),	/* 586 */

	/* Parameter cVolumes */

/* 386 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 388 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 390 */	NdrFcShort( 0x258 ),	/* Type Offset=600 */

	/* Parameter rgvolid */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 398 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x8 ),	/* 8 */
/* 406 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 408 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 418 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x9 ),	/* 9 */
/* 440 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 442 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 446 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 448 */	NdrFcShort( 0x10c ),	/* 268 */
/* 450 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 452 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 460 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 472 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 476 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 478 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 480 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 482 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 484 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 486 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 488 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidLast */

/* 490 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 492 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 494 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 496 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 498 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 500 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidCurrent */

/* 502 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 504 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 506 */	NdrFcShort( 0x274 ),	/* Type Offset=628 */

	/* Parameter pcbPath */

/* 508 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 510 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 512 */	NdrFcShort( 0x282 ),	/* Type Offset=642 */

	/* Parameter pwszPath */

/* 514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 516 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 520 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0xa ),	/* 10 */
/* 528 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 530 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 534 */	NdrFcShort( 0xac ),	/* 172 */
/* 536 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 538 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 540 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 542 */	NdrFcShort( 0x1 ),	/* 1 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 554 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 558 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 560 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 564 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 566 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 570 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidNext */

/* 572 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 576 */	NdrFcShort( 0x28e ),	/* Type Offset=654 */

	/* Parameter ptszPath */

/* 578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 580 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 584 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0xb ),	/* 11 */
/* 592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 594 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 602 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 604 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 606 */	NdrFcShort( 0xb ),	/* 11 */
/* 608 */	NdrFcShort( 0xb ),	/* 11 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 612 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 614 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 616 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Parameter pMsg */

/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 620 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 624 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* 12 */
/* 632 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 634 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 638 */	NdrFcShort( 0x150 ),	/* 336 */
/* 640 */	NdrFcShort( 0x194 ),	/* 404 */
/* 642 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 644 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 646 */	NdrFcShort( 0x1 ),	/* 1 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 658 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 662 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 664 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 668 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 670 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 674 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 676 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 678 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 680 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 682 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 684 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 686 */	NdrFcShort( 0x166 ),	/* Type Offset=358 */

	/* Parameter pmcidNext */

/* 688 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 690 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 692 */	NdrFcShort( 0x342 ),	/* Type Offset=834 */

	/* Parameter ptszPath */

/* 694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 696 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x1da ),	/* Offset= 474 (540) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x20 ),	/* 32 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x56 ),	/* Offset= 86 (172) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x8c ),	/* Offset= 140 (232) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xce ),	/* Offset= 206 (304) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x134 ),	/* Offset= 308 (412) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x154 ),	/* Offset= 340 (450) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x196 ),	/* Offset= 406 (522) */
/* 118 */	NdrFcShort( 0xffff ),	/* Offset= -1 (117) */
/* 120 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 122 */	NdrFcLong( 0x1 ),	/* 1 */
/* 126 */	NdrFcLong( 0x1 ),	/* 1 */
/* 130 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 132 */	NdrFcShort( 0x202 ),	/* 514 */
/* 134 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 136 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0x248 ),	/* 584 */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (130) */
/* 144 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 146 */	0x0,		/* 0 */
			NdrFcShort( 0xff97 ),	/* Offset= -105 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 150 */	0x0,		/* 0 */
			NdrFcShort( 0xff93 ),	/* Offset= -109 (42) */
			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x248 ),	/* 584 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x8 ),	/* Offset= 8 (186) */
/* 180 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 182 */	NdrFcShort( 0xffc2 ),	/* Offset= -62 (120) */
/* 184 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (156) */
/* 190 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcLong( 0x40 ),	/* 64 */
/* 200 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 212 */	NdrFcShort( 0xff4c ),	/* Offset= -180 (32) */
/* 214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 216 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 218 */	NdrFcShort( 0x20 ),	/* 32 */
/* 220 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 226 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 228 */	NdrFcShort( 0xff46 ),	/* Offset= -186 (42) */
/* 230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 232 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 234 */	NdrFcShort( 0x20 ),	/* 32 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0xe ),	/* Offset= 14 (252) */
/* 240 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 242 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (190) */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 248 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 252 */	
			0x12, 0x0,	/* FC_UP */
/* 254 */	NdrFcShort( 0xff22 ),	/* Offset= -222 (32) */
/* 256 */	
			0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (200) */
/* 260 */	
			0x12, 0x0,	/* FC_UP */
/* 262 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (216) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0xffce ),	/* Offset= -50 (216) */
/* 268 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcLong( 0x80 ),	/* 128 */
/* 278 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 284 */	NdrFcLong( 0x1a ),	/* 26 */
/* 288 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x10 ),	/* 16 */
/* 292 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 298 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 300 */	NdrFcShort( 0xfef4 ),	/* Offset= -268 (32) */
/* 302 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 306 */	NdrFcShort( 0x10 ),	/* 16 */
/* 308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0xe ),	/* Offset= 14 (324) */
/* 312 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 314 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (268) */
/* 316 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 318 */	0x0,		/* 0 */
			NdrFcShort( 0xffd7 ),	/* Offset= -41 (278) */
			0x36,		/* FC_POINTER */
/* 322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 324 */	
			0x12, 0x0,	/* FC_UP */
/* 326 */	NdrFcShort( 0xff92 ),	/* Offset= -110 (216) */
/* 328 */	
			0x12, 0x0,	/* FC_UP */
/* 330 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (288) */
/* 332 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 338 */	NdrFcLong( 0x1a ),	/* 26 */
/* 342 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 344 */	NdrFcShort( 0x8 ),	/* 8 */
/* 346 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 348 */	NdrFcShort( 0xfeb2 ),	/* Offset= -334 (14) */
/* 350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 352 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 356 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 358 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0x10 ),	/* 16 */
/* 362 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (352) */
/* 366 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 368 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 370 */	NdrFcShort( 0x44 ),	/* 68 */
/* 372 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 374 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 376 */	NdrFcShort( 0xfea8 ),	/* Offset= -344 (32) */
/* 378 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 380 */	NdrFcShort( 0xffda ),	/* Offset= -38 (342) */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (342) */
/* 386 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xfe7d ),	/* Offset= -387 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 392 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (358) */
			0x5b,		/* FC_END */
/* 396 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 398 */	NdrFcShort( 0x44 ),	/* 68 */
/* 400 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 402 */	NdrFcShort( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 406 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 408 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (368) */
/* 410 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 412 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x8 ),	/* Offset= 8 (426) */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xffa6 ),	/* Offset= -90 (332) */
/* 424 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 426 */	
			0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (396) */
/* 430 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 436 */	NdrFcLong( 0x20 ),	/* 32 */
/* 440 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 442 */	NdrFcLong( 0x0 ),	/* 0 */
/* 446 */	NdrFcLong( 0x1a ),	/* 26 */
/* 450 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 452 */	NdrFcShort( 0x10 ),	/* 16 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0xe ),	/* Offset= 14 (470) */
/* 458 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 460 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (430) */
/* 462 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 464 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (440) */
			0x36,		/* FC_POINTER */
/* 468 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 470 */	
			0x12, 0x0,	/* FC_UP */
/* 472 */	NdrFcShort( 0xff00 ),	/* Offset= -256 (216) */
/* 474 */	
			0x12, 0x0,	/* FC_UP */
/* 476 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (288) */
/* 478 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 480 */	NdrFcLong( 0x1 ),	/* 1 */
/* 484 */	NdrFcLong( 0x1 ),	/* 1 */
/* 488 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x54 ),	/* 84 */
/* 492 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 494 */	NdrFcShort( 0xfe3c ),	/* Offset= -452 (42) */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xfe38 ),	/* Offset= -456 (42) */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xff70 ),	/* Offset= -144 (358) */
/* 504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x54 ),	/* 84 */
/* 510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 516 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 518 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (488) */
/* 520 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 522 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x8 ),	/* Offset= 8 (536) */
/* 530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0xffca ),	/* Offset= -54 (478) */
/* 534 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 536 */	
			0x12, 0x0,	/* FC_UP */
/* 538 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (506) */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x28 ),	/* 40 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* Offset= 10 (556) */
/* 548 */	0xe,		/* FC_ENUM32 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 550 */	0x0,		/* 0 */
			NdrFcShort( 0xfe1d ),	/* Offset= -483 (68) */
			0x36,		/* FC_POINTER */
/* 554 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 556 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 558 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 560 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 562 */	NdrFcShort( 0x14 ),	/* 20 */
/* 564 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 566 */	0x0,		/* 0 */
			NdrFcShort( 0xfde9 ),	/* Offset= -535 (32) */
			0x5b,		/* FC_END */
/* 570 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (560) */
/* 574 */	NdrFcShort( 0x14 ),	/* 20 */
/* 576 */	NdrFcShort( 0x14 ),	/* 20 */
/* 578 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0xffa4 ),	/* Offset= -92 (488) */
/* 582 */	NdrFcShort( 0x54 ),	/* 84 */
/* 584 */	NdrFcShort( 0x54 ),	/* 84 */
/* 586 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 588 */	NdrFcLong( 0x1 ),	/* 1 */
/* 592 */	NdrFcLong( 0x1a ),	/* 26 */
/* 596 */	
			0x11, 0x0,	/* FC_RP */
/* 598 */	NdrFcShort( 0x2 ),	/* Offset= 2 (600) */
/* 600 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 602 */	NdrFcShort( 0x10 ),	/* 16 */
/* 604 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 606 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 608 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfdbc ),	/* Offset= -580 (32) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x11, 0x0,	/* FC_RP */
/* 618 */	NdrFcShort( 0xfefc ),	/* Offset= -260 (358) */
/* 620 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 622 */	NdrFcShort( 0xfef8 ),	/* Offset= -264 (358) */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x2 ),	/* Offset= 2 (628) */
/* 628 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 630 */	NdrFcLong( 0x1 ),	/* 1 */
/* 634 */	NdrFcLong( 0x20a ),	/* 522 */
/* 638 */	
			0x11, 0x0,	/* FC_RP */
/* 640 */	NdrFcShort( 0x2 ),	/* Offset= 2 (642) */
/* 642 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 644 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 646 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 648 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 650 */	
			0x11, 0x0,	/* FC_RP */
/* 652 */	NdrFcShort( 0x2 ),	/* Offset= 2 (654) */
/* 654 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 656 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 658 */	NdrFcShort( 0x106 ),	/* 262 */
/* 660 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 662 */	
			0x11, 0x0,	/* FC_RP */
/* 664 */	NdrFcShort( 0x92 ),	/* Offset= 146 (810) */
/* 666 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 668 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 670 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 672 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 674 */	NdrFcShort( 0x2 ),	/* Offset= 2 (676) */
/* 676 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 678 */	NdrFcShort( 0x9 ),	/* 9 */
/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 684 */	NdrFcShort( 0xfe00 ),	/* Offset= -512 (172) */
/* 686 */	NdrFcLong( 0x1 ),	/* 1 */
/* 690 */	NdrFcShort( 0xfe36 ),	/* Offset= -458 (232) */
/* 692 */	NdrFcLong( 0x2 ),	/* 2 */
/* 696 */	NdrFcShort( 0xfe78 ),	/* Offset= -392 (304) */
/* 698 */	NdrFcLong( 0x3 ),	/* 3 */
/* 702 */	NdrFcShort( 0xfede ),	/* Offset= -290 (412) */
/* 704 */	NdrFcLong( 0x4 ),	/* 4 */
/* 708 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (450) */
/* 710 */	NdrFcLong( 0x5 ),	/* 5 */
/* 714 */	NdrFcShort( 0x1e ),	/* Offset= 30 (744) */
/* 716 */	NdrFcLong( 0x6 ),	/* 6 */
/* 720 */	NdrFcShort( 0xff3a ),	/* Offset= -198 (522) */
/* 722 */	NdrFcLong( 0x7 ),	/* 7 */
/* 726 */	NdrFcShort( 0xfd2c ),	/* Offset= -724 (2) */
/* 728 */	NdrFcLong( 0x8 ),	/* 8 */
/* 732 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 734 */	NdrFcShort( 0xffff ),	/* Offset= -1 (733) */
/* 736 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 738 */	NdrFcShort( 0xc ),	/* 12 */
/* 740 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 742 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 744 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 746 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 748 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 750 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 752 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 754 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 756 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 758 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 760 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 774 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 776 */	NdrFcShort( 0xfcfa ),	/* Offset= -774 (2) */
/* 778 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 780 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 782 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 784 */	0x0,		/* 0 */
			NdrFcShort( 0xfcf1 ),	/* Offset= -783 (2) */
			0x8,		/* FC_LONG */
/* 788 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 790 */	NdrFcShort( 0xfcec ),	/* Offset= -788 (2) */
/* 792 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 794 */	NdrFcShort( 0xfce8 ),	/* Offset= -792 (2) */
/* 796 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 802 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 804 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (736) */
			0x5b,		/* FC_END */
/* 810 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 812 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 816 */	NdrFcShort( 0xa ),	/* Offset= 10 (826) */
/* 818 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 820 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 822 */	NdrFcShort( 0xff64 ),	/* Offset= -156 (666) */
/* 824 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 826 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 828 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 830 */	
			0x11, 0x0,	/* FC_RP */
/* 832 */	NdrFcShort( 0x2 ),	/* Offset= 2 (834) */
/* 834 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 836 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 838 */	NdrFcShort( 0x106 ),	/* 262 */
/* 840 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    70,
    128,
    168,
    214,
    248,
    300,
    352,
    398,
    432,
    520,
    584,
    624
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trkwks_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrAsyncServerCall,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable = 
    {
    13,
    trkwks_table
    };

static const SERVER_ROUTINE trkwks_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)Stubold_LnkMendLink,
    (SERVER_ROUTINE)Stubold_LnkSearchMachine,
    (SERVER_ROUTINE)Stubold_LnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSetVolumeId,
    (SERVER_ROUTINE)StubLnkRestartDcSynchronization,
    (SERVER_ROUTINE)StubGetVolumeTrackingInformation,
    (SERVER_ROUTINE)StubGetFileTrackingInformation,
    (SERVER_ROUTINE)StubTriggerVolumeClaims,
    (SERVER_ROUTINE)StubLnkOnRestore,
    (SERVER_ROUTINE)StubLnkMendLink,
    (SERVER_ROUTINE)Stubold2_LnkSearchMachine,
    (SERVER_ROUTINE)StubLnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSearchMachine
    };

static const MIDL_SERVER_INFO trkwks_ServerInfo = 
    {
    &trkwks_StubDesc,
    trkwks_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trkwks_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#include <string.h>
#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   853                               
#define PROC_FORMAT_STRING_SIZE   727                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */


extern const MIDL_SERVER_INFO trkwks_ServerInfo;

extern RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable;

static const RPC_SERVER_INTERFACE trkwks___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trkwks_v1_2_DispatchTable,
    0,
    0,
    0,
    &trkwks_ServerInfo,
    0x04000001
    };
RPC_IF_HANDLE Stubtrkwks_v1_2_s_ifspec = (RPC_IF_HANDLE)& trkwks___RpcServerInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 42 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 44 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 48 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 50 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 52 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 54 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 56 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 58 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 60 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 62 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 64 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 72 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x1 ),	/* 1 */
/* 80 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 82 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	NdrFcShort( 0xac ),	/* 172 */
/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 92 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 112 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 114 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 116 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 118 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 122 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 124 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 128 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 132 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 144 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 152 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 154 */	NdrFcShort( 0xb ),	/* 11 */
/* 156 */	NdrFcShort( 0xb ),	/* 11 */
/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 162 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 164 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 166 */	NdrFcShort( 0x226 ),	/* Type Offset=550 */

	/* Parameter pMsg */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 170 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 174 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x3 ),	/* 3 */
/* 182 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 184 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 186 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 188 */	NdrFcShort( 0x48 ),	/* 72 */
/* 190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 192 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 206 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 210 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 212 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 214 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 218 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 222 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 224 */	NdrFcLong( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 232 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 242 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 258 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 270 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 272 */	NdrFcShort( 0x48 ),	/* 72 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 278 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 288 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 290 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 292 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 298 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 300 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 302 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 304 */	NdrFcShort( 0x244 ),	/* Type Offset=580 */

	/* Parameter pipeVolInfo */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 312 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 322 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 326 */	NdrFcShort( 0x98 ),	/* 152 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 332 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 342 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 346 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 352 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 354 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 356 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 358 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter pipeFileInfo */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 366 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 376 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 384 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 386 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 396 */	NdrFcShort( 0x88 ),	/* Flags:  in, by val, */
/* 398 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 400 */	NdrFcShort( 0x254 ),	/* 596 */

	/* Parameter cVolumes */

/* 402 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 404 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 406 */	NdrFcShort( 0x262 ),	/* Type Offset=610 */

	/* Parameter rgvolid */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 414 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 424 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 432 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 434 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 450 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 460 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 466 */	NdrFcShort( 0x10c ),	/* 268 */
/* 468 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 470 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 472 */	NdrFcShort( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 480 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 482 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 484 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 488 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 492 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 494 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 496 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 498 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 500 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 504 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 506 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 508 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidLast */

/* 510 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 512 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 514 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 516 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 518 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 520 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidCurrent */

/* 522 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 524 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 526 */	NdrFcShort( 0x27e ),	/* Type Offset=638 */

	/* Parameter pcbPath */

/* 528 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 530 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 532 */	NdrFcShort( 0x28c ),	/* Type Offset=652 */

	/* Parameter pwszPath */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* 10 */
/* 548 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 550 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 552 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 554 */	NdrFcShort( 0xac ),	/* 172 */
/* 556 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 558 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 560 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 562 */	NdrFcShort( 0x1 ),	/* 1 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 570 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 572 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 576 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 578 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 580 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 582 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 584 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 586 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 588 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 590 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 592 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidNext */

/* 594 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 596 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 598 */	NdrFcShort( 0x298 ),	/* Type Offset=664 */

	/* Parameter ptszPath */

/* 600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 602 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 606 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 608 */	NdrFcLong( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0xb ),	/* 11 */
/* 614 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 616 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 618 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 624 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 626 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 628 */	NdrFcShort( 0xb ),	/* 11 */
/* 630 */	NdrFcShort( 0xb ),	/* 11 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 636 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 638 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 640 */	NdrFcShort( 0x334 ),	/* Type Offset=820 */

	/* Parameter pMsg */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xc ),	/* 12 */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 662 */	NdrFcShort( 0x150 ),	/* 336 */
/* 664 */	NdrFcShort( 0x194 ),	/* 404 */
/* 666 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 668 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 670 */	NdrFcShort( 0x1 ),	/* 1 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 678 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 680 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 684 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 686 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 688 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 690 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 692 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 694 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 696 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 698 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 700 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 702 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 704 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 706 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 708 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 710 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 712 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pmcidNext */

/* 714 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 716 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 718 */	NdrFcShort( 0x34c ),	/* Type Offset=844 */

	/* Parameter ptszPath */

/* 720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 722 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (550) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x30 ),	/* 48 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x56 ),	/* Offset= 86 (172) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x8e ),	/* Offset= 142 (234) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (306) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x138 ),	/* Offset= 312 (416) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x15a ),	/* Offset= 346 (456) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x19e ),	/* Offset= 414 (530) */
/* 118 */	NdrFcShort( 0xffff ),	/* Offset= -1 (117) */
/* 120 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 122 */	NdrFcLong( 0x1 ),	/* 1 */
/* 126 */	NdrFcLong( 0x1 ),	/* 1 */
/* 130 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 132 */	NdrFcShort( 0x202 ),	/* 514 */
/* 134 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 136 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0x248 ),	/* 584 */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (130) */
/* 144 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 146 */	0x0,		/* 0 */
			NdrFcShort( 0xff97 ),	/* Offset= -105 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 150 */	0x0,		/* 0 */
			NdrFcShort( 0xff93 ),	/* Offset= -109 (42) */
			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x248 ),	/* 584 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 168 */	NdrFcShort( 0xffe0 ),	/* Offset= -32 (136) */
/* 170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x10 ),	/* 16 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0xa ),	/* Offset= 10 (188) */
/* 180 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 182 */	NdrFcShort( 0xffc2 ),	/* Offset= -62 (120) */
/* 184 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 186 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 188 */	
			0x12, 0x0,	/* FC_UP */
/* 190 */	NdrFcShort( 0xffde ),	/* Offset= -34 (156) */
/* 192 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 194 */	NdrFcLong( 0x0 ),	/* 0 */
/* 198 */	NdrFcLong( 0x40 ),	/* 64 */
/* 202 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 204 */	NdrFcShort( 0x10 ),	/* 16 */
/* 206 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 210 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 212 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 214 */	NdrFcShort( 0xff4a ),	/* Offset= -182 (32) */
/* 216 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 218 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 220 */	NdrFcShort( 0x20 ),	/* 32 */
/* 222 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 228 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 230 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (42) */
/* 232 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 234 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 236 */	NdrFcShort( 0x30 ),	/* 48 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0xe ),	/* Offset= 14 (254) */
/* 242 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 244 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (192) */
/* 246 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 248 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 250 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 252 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xff20 ),	/* Offset= -224 (32) */
/* 258 */	
			0x12, 0x0,	/* FC_UP */
/* 260 */	NdrFcShort( 0xffc6 ),	/* Offset= -58 (202) */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (218) */
/* 266 */	
			0x12, 0x0,	/* FC_UP */
/* 268 */	NdrFcShort( 0xffce ),	/* Offset= -50 (218) */
/* 270 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 272 */	NdrFcLong( 0x0 ),	/* 0 */
/* 276 */	NdrFcLong( 0x80 ),	/* 128 */
/* 280 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcLong( 0x1a ),	/* 26 */
/* 290 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x10 ),	/* 16 */
/* 294 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (32) */
/* 304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 306 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 308 */	NdrFcShort( 0x20 ),	/* 32 */
/* 310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 312 */	NdrFcShort( 0x10 ),	/* Offset= 16 (328) */
/* 314 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 316 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (270) */
/* 318 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (280) */
/* 324 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 328 */	
			0x12, 0x0,	/* FC_UP */
/* 330 */	NdrFcShort( 0xff90 ),	/* Offset= -112 (218) */
/* 332 */	
			0x12, 0x0,	/* FC_UP */
/* 334 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (290) */
/* 336 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcLong( 0x1a ),	/* 26 */
/* 346 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
/* 350 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 352 */	NdrFcShort( 0xfeae ),	/* Offset= -338 (14) */
/* 354 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 356 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 358 */	NdrFcShort( 0x10 ),	/* 16 */
/* 360 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 362 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x10 ),	/* 16 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (356) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x44 ),	/* 68 */
/* 376 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 378 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 380 */	NdrFcShort( 0xfea4 ),	/* Offset= -348 (32) */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffda ),	/* Offset= -38 (346) */
/* 386 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 388 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (346) */
/* 390 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 392 */	0x0,		/* 0 */
			NdrFcShort( 0xfe79 ),	/* Offset= -391 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 396 */	0x0,		/* 0 */
			NdrFcShort( 0xffdd ),	/* Offset= -35 (362) */
			0x5b,		/* FC_END */
/* 400 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 402 */	NdrFcShort( 0x44 ),	/* 68 */
/* 404 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 410 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 412 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (372) */
/* 414 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 416 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 418 */	NdrFcShort( 0x10 ),	/* 16 */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0xa ),	/* Offset= 10 (432) */
/* 424 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0xffa6 ),	/* Offset= -90 (336) */
/* 428 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 430 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 432 */	
			0x12, 0x0,	/* FC_UP */
/* 434 */	NdrFcShort( 0xffde ),	/* Offset= -34 (400) */
/* 436 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcLong( 0x20 ),	/* 32 */
/* 446 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcLong( 0x1a ),	/* 26 */
/* 456 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 458 */	NdrFcShort( 0x20 ),	/* 32 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x10 ),	/* Offset= 16 (478) */
/* 464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 466 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (436) */
/* 468 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (446) */
/* 474 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x12, 0x0,	/* FC_UP */
/* 480 */	NdrFcShort( 0xfefa ),	/* Offset= -262 (218) */
/* 482 */	
			0x12, 0x0,	/* FC_UP */
/* 484 */	NdrFcShort( 0xff3e ),	/* Offset= -194 (290) */
/* 486 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 488 */	NdrFcLong( 0x1 ),	/* 1 */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 498 */	NdrFcShort( 0x54 ),	/* 84 */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xfe34 ),	/* Offset= -460 (42) */
/* 504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 506 */	NdrFcShort( 0xfe30 ),	/* Offset= -464 (42) */
/* 508 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 510 */	NdrFcShort( 0xff6c ),	/* Offset= -148 (362) */
/* 512 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 514 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 516 */	NdrFcShort( 0x54 ),	/* 84 */
/* 518 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 524 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 526 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (496) */
/* 528 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 530 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 532 */	NdrFcShort( 0x10 ),	/* 16 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0xa ),	/* Offset= 10 (546) */
/* 538 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 540 */	NdrFcShort( 0xffca ),	/* Offset= -54 (486) */
/* 542 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 546 */	
			0x12, 0x0,	/* FC_UP */
/* 548 */	NdrFcShort( 0xffde ),	/* Offset= -34 (514) */
/* 550 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x40 ),	/* 64 */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0xa ),	/* Offset= 10 (566) */
/* 558 */	0xe,		/* FC_ENUM32 */
			0x40,		/* FC_STRUCTPAD4 */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xfe12 ),	/* Offset= -494 (68) */
/* 564 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 566 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 568 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 570 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x14 ),	/* 20 */
/* 574 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 576 */	0x0,		/* 0 */
			NdrFcShort( 0xfddf ),	/* Offset= -545 (32) */
			0x5b,		/* FC_END */
/* 580 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 582 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (570) */
/* 584 */	NdrFcShort( 0x14 ),	/* 20 */
/* 586 */	NdrFcShort( 0x14 ),	/* 20 */
/* 588 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 590 */	NdrFcShort( 0xffa2 ),	/* Offset= -94 (496) */
/* 592 */	NdrFcShort( 0x54 ),	/* 84 */
/* 594 */	NdrFcShort( 0x54 ),	/* 84 */
/* 596 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 598 */	NdrFcLong( 0x1 ),	/* 1 */
/* 602 */	NdrFcLong( 0x1a ),	/* 26 */
/* 606 */	
			0x11, 0x0,	/* FC_RP */
/* 608 */	NdrFcShort( 0x2 ),	/* Offset= 2 (610) */
/* 610 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 616 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 618 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 620 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 622 */	NdrFcShort( 0xfdb2 ),	/* Offset= -590 (32) */
/* 624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 626 */	
			0x11, 0x0,	/* FC_RP */
/* 628 */	NdrFcShort( 0xfef6 ),	/* Offset= -266 (362) */
/* 630 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 632 */	NdrFcShort( 0xfef2 ),	/* Offset= -270 (362) */
/* 634 */	
			0x11, 0x0,	/* FC_RP */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	0xb7,		/* FC_RANGE */
			0x8,		/* 8 */
/* 640 */	NdrFcLong( 0x1 ),	/* 1 */
/* 644 */	NdrFcLong( 0x20a ),	/* 522 */
/* 648 */	
			0x11, 0x0,	/* FC_RP */
/* 650 */	NdrFcShort( 0x2 ),	/* Offset= 2 (652) */
/* 652 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 654 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 660 */	
			0x11, 0x0,	/* FC_RP */
/* 662 */	NdrFcShort( 0x2 ),	/* Offset= 2 (664) */
/* 664 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 666 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 668 */	NdrFcShort( 0x106 ),	/* 262 */
/* 670 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 672 */	
			0x11, 0x0,	/* FC_RP */
/* 674 */	NdrFcShort( 0x92 ),	/* Offset= 146 (820) */
/* 676 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 678 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 680 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 682 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 684 */	NdrFcShort( 0x2 ),	/* Offset= 2 (686) */
/* 686 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 688 */	NdrFcShort( 0x9 ),	/* 9 */
/* 690 */	NdrFcLong( 0x0 ),	/* 0 */
/* 694 */	NdrFcShort( 0xfdf6 ),	/* Offset= -522 (172) */
/* 696 */	NdrFcLong( 0x1 ),	/* 1 */
/* 700 */	NdrFcShort( 0xfe2e ),	/* Offset= -466 (234) */
/* 702 */	NdrFcLong( 0x2 ),	/* 2 */
/* 706 */	NdrFcShort( 0xfe70 ),	/* Offset= -400 (306) */
/* 708 */	NdrFcLong( 0x3 ),	/* 3 */
/* 712 */	NdrFcShort( 0xfed8 ),	/* Offset= -296 (416) */
/* 714 */	NdrFcLong( 0x4 ),	/* 4 */
/* 718 */	NdrFcShort( 0xfefa ),	/* Offset= -262 (456) */
/* 720 */	NdrFcLong( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x1e ),	/* Offset= 30 (754) */
/* 726 */	NdrFcLong( 0x6 ),	/* 6 */
/* 730 */	NdrFcShort( 0xff38 ),	/* Offset= -200 (530) */
/* 732 */	NdrFcLong( 0x7 ),	/* 7 */
/* 736 */	NdrFcShort( 0xfd22 ),	/* Offset= -734 (2) */
/* 738 */	NdrFcLong( 0x8 ),	/* 8 */
/* 742 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 744 */	NdrFcShort( 0xffff ),	/* Offset= -1 (743) */
/* 746 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 748 */	NdrFcShort( 0xc ),	/* 12 */
/* 750 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 752 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 754 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 756 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 758 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 760 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 774 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 776 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 778 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 780 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 782 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xfcf0 ),	/* Offset= -784 (2) */
/* 788 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 790 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 792 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 794 */	0x0,		/* 0 */
			NdrFcShort( 0xfce7 ),	/* Offset= -793 (2) */
			0x8,		/* FC_LONG */
/* 798 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 800 */	NdrFcShort( 0xfce2 ),	/* Offset= -798 (2) */
/* 802 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 804 */	NdrFcShort( 0xfcde ),	/* Offset= -802 (2) */
/* 806 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 808 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 810 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 812 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 814 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 816 */	0x0,		/* 0 */
			NdrFcShort( 0xffb9 ),	/* Offset= -71 (746) */
			0x5b,		/* FC_END */
/* 820 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 822 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0xa ),	/* Offset= 10 (836) */
/* 828 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 830 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 832 */	NdrFcShort( 0xff64 ),	/* Offset= -156 (676) */
/* 834 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 836 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 838 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x11, 0x0,	/* FC_RP */
/* 842 */	NdrFcShort( 0x2 ),	/* Offset= 2 (844) */
/* 844 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 846 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 848 */	NdrFcShort( 0x106 ),	/* 262 */
/* 850 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    72,
    132,
    174,
    222,
    258,
    312,
    366,
    414,
    450,
    540,
    606,
    648
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000169, /* MIDL Version 6.0.361 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trkwks_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrAsyncServerCall,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable = 
    {
    13,
    trkwks_table
    };

static const SERVER_ROUTINE trkwks_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)Stubold_LnkMendLink,
    (SERVER_ROUTINE)Stubold_LnkSearchMachine,
    (SERVER_ROUTINE)Stubold_LnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSetVolumeId,
    (SERVER_ROUTINE)StubLnkRestartDcSynchronization,
    (SERVER_ROUTINE)StubGetVolumeTrackingInformation,
    (SERVER_ROUTINE)StubGetFileTrackingInformation,
    (SERVER_ROUTINE)StubTriggerVolumeClaims,
    (SERVER_ROUTINE)StubLnkOnRestore,
    (SERVER_ROUTINE)StubLnkMendLink,
    (SERVER_ROUTINE)Stubold2_LnkSearchMachine,
    (SERVER_ROUTINE)StubLnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSearchMachine
    };

static const MIDL_SERVER_INFO trkwks_ServerInfo = 
    {
    &trkwks_StubDesc,
    trkwks_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trkwks_FormatStringOffsetTable,
    0,
    0,
    0,
    0};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\bthapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for bthapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bthapi_h__
#define __bthapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISdpWalk_FWD_DEFINED__
#define __ISdpWalk_FWD_DEFINED__
typedef interface ISdpWalk ISdpWalk;
#endif 	/* __ISdpWalk_FWD_DEFINED__ */


#ifndef __ISdpNodeContainer_FWD_DEFINED__
#define __ISdpNodeContainer_FWD_DEFINED__
typedef interface ISdpNodeContainer ISdpNodeContainer;
#endif 	/* __ISdpNodeContainer_FWD_DEFINED__ */


#ifndef __ISdpSearch_FWD_DEFINED__
#define __ISdpSearch_FWD_DEFINED__
typedef interface ISdpSearch ISdpSearch;
#endif 	/* __ISdpSearch_FWD_DEFINED__ */


#ifndef __ISdpStream_FWD_DEFINED__
#define __ISdpStream_FWD_DEFINED__
typedef interface ISdpStream ISdpStream;
#endif 	/* __ISdpStream_FWD_DEFINED__ */


#ifndef __ISdpRecord_FWD_DEFINED__
#define __ISdpRecord_FWD_DEFINED__
typedef interface ISdpRecord ISdpRecord;
#endif 	/* __ISdpRecord_FWD_DEFINED__ */


#ifndef __IBluetoothDevice_FWD_DEFINED__
#define __IBluetoothDevice_FWD_DEFINED__
typedef interface IBluetoothDevice IBluetoothDevice;
#endif 	/* __IBluetoothDevice_FWD_DEFINED__ */


#ifndef __IBluetoothAuthenticate_FWD_DEFINED__
#define __IBluetoothAuthenticate_FWD_DEFINED__
typedef interface IBluetoothAuthenticate IBluetoothAuthenticate;
#endif 	/* __IBluetoothAuthenticate_FWD_DEFINED__ */


#ifndef __SdpNodeContainer_FWD_DEFINED__
#define __SdpNodeContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpNodeContainer SdpNodeContainer;
#else
typedef struct SdpNodeContainer SdpNodeContainer;
#endif /* __cplusplus */

#endif 	/* __SdpNodeContainer_FWD_DEFINED__ */


#ifndef __SdpSearch_FWD_DEFINED__
#define __SdpSearch_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpSearch SdpSearch;
#else
typedef struct SdpSearch SdpSearch;
#endif /* __cplusplus */

#endif 	/* __SdpSearch_FWD_DEFINED__ */


#ifndef __SdpWalk_FWD_DEFINED__
#define __SdpWalk_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpWalk SdpWalk;
#else
typedef struct SdpWalk SdpWalk;
#endif /* __cplusplus */

#endif 	/* __SdpWalk_FWD_DEFINED__ */


#ifndef __SdpStream_FWD_DEFINED__
#define __SdpStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpStream SdpStream;
#else
typedef struct SdpStream SdpStream;
#endif /* __cplusplus */

#endif 	/* __SdpStream_FWD_DEFINED__ */


#ifndef __SdpRecord_FWD_DEFINED__
#define __SdpRecord_FWD_DEFINED__

#ifdef __cplusplus
typedef class SdpRecord SdpRecord;
#else
typedef struct SdpRecord SdpRecord;
#endif /* __cplusplus */

#endif 	/* __SdpRecord_FWD_DEFINED__ */


#ifndef __ShellPropSheetExt_FWD_DEFINED__
#define __ShellPropSheetExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellPropSheetExt ShellPropSheetExt;
#else
typedef struct ShellPropSheetExt ShellPropSheetExt;
#endif /* __cplusplus */

#endif 	/* __ShellPropSheetExt_FWD_DEFINED__ */


#ifndef __BluetoothAuthenticate_FWD_DEFINED__
#define __BluetoothAuthenticate_FWD_DEFINED__

#ifdef __cplusplus
typedef class BluetoothAuthenticate BluetoothAuthenticate;
#else
typedef struct BluetoothAuthenticate BluetoothAuthenticate;
#endif /* __cplusplus */

#endif 	/* __BluetoothAuthenticate_FWD_DEFINED__ */


#ifndef __BluetoothDevice_FWD_DEFINED__
#define __BluetoothDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class BluetoothDevice BluetoothDevice;
#else
typedef struct BluetoothDevice BluetoothDevice;
#endif /* __cplusplus */

#endif 	/* __BluetoothDevice_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_bthapi_0000 */
/* [local] */ 

#ifndef __BTHDEF_H__
struct SDP_LARGE_INTEGER_16
    {
    ULONGLONG LowPart;
    LONGLONG HighPart;
    } ;
struct SDP_ULARGE_INTEGER_16
    {
    ULONGLONG LowPart;
    ULONGLONG HighPart;
    } ;
typedef struct SDP_ULARGE_INTEGER_16 SDP_ULARGE_INTEGER_16;

typedef struct SDP_ULARGE_INTEGER_16 *PSDP_ULARGE_INTEGER_16;

typedef struct SDP_ULARGE_INTEGER_16 *LPSDP_ULARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 SDP_LARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 *PSDP_LARGE_INTEGER_16;

typedef struct SDP_LARGE_INTEGER_16 *LPSDP_LARGE_INTEGER_16;


enum NodeContainerType
    {	NodeContainerTypeSequence	= 0,
	NodeContainerTypeAlternative	= NodeContainerTypeSequence + 1
    } ;
typedef enum NodeContainerType NodeContainerType;

typedef USHORT SDP_ERROR;

typedef USHORT *PSDP_ERROR;


enum SDP_TYPE
    {	SDP_TYPE_NIL	= 0,
	SDP_TYPE_UINT	= 0x1,
	SDP_TYPE_INT	= 0x2,
	SDP_TYPE_UUID	= 0x3,
	SDP_TYPE_STRING	= 0x4,
	SDP_TYPE_BOOLEAN	= 0x5,
	SDP_TYPE_SEQUENCE	= 0x6,
	SDP_TYPE_ALTERNATIVE	= 0x7,
	SDP_TYPE_URL	= 0x8,
	SDP_TYPE_CONTAINER	= 0x20
    } ;
typedef enum SDP_TYPE SDP_TYPE;


enum SDP_SPECIFICTYPE
    {	SDP_ST_NONE	= 0,
	SDP_ST_UINT8	= 0x10,
	SDP_ST_UINT16	= 0x110,
	SDP_ST_UINT32	= 0x210,
	SDP_ST_UINT64	= 0x310,
	SDP_ST_UINT128	= 0x410,
	SDP_ST_INT8	= 0x20,
	SDP_ST_INT16	= 0x120,
	SDP_ST_INT32	= 0x220,
	SDP_ST_INT64	= 0x320,
	SDP_ST_INT128	= 0x420,
	SDP_ST_UUID16	= 0x130,
	SDP_ST_UUID32	= 0x220,
	SDP_ST_UUID128	= 0x430
    } ;
typedef enum SDP_SPECIFICTYPE SDP_SPECIFICTYPE;

typedef struct _SdpAttributeRange
    {
    USHORT minAttribute;
    USHORT maxAttribute;
    } 	SdpAttributeRange;

typedef /* [switch_type] */ union SdpQueryUuidUnion
    {
    /* [case()] */ GUID uuid128;
    /* [case()] */ ULONG uuid32;
    /* [case()] */ USHORT uuid16;
    } 	SdpQueryUuidUnion;

typedef struct _SdpQueryUuid
    {
    /* [switch_is] */ SdpQueryUuidUnion u;
    USHORT uuidType;
    } 	SdpQueryUuid;

typedef ULONGLONG BTH_ADDR;

typedef ULONGLONG *PBTH_ADDR;

typedef ULONG BTH_COD;

typedef ULONG *PBTH_COD;

typedef ULONG BTH_LAP;

typedef ULONG *PBTH_LAP;

typedef UCHAR BTHSTATUS;

typedef UCHAR *PBTHSTATUS;

typedef struct _BTH_DEVICE_INFO
    {
    ULONG flags;
    BTH_ADDR address;
    BTH_COD classOfDevice;
    CHAR name[ 248 ];
    } 	BTH_DEVICE_INFO;

typedef struct _BTH_DEVICE_INFO *PBTH_DEVICE_INFO;

typedef struct _BTH_RADIO_IN_RANGE
    {
    BTH_DEVICE_INFO deviceInfo;
    ULONG previousDeviceFlags;
    } 	BTH_RADIO_IN_RANGE;

typedef struct _BTH_RADIO_IN_RANGE *PBTH_RADIO_IN_RANGE;

typedef struct _BTH_L2CAP_EVENT_INFO
    {
    BTH_ADDR bthAddress;
    USHORT psm;
    UCHAR connected;
    UCHAR initiated;
    } 	BTH_L2CAP_EVENT_INFO;

typedef struct _BTH_L2CAP_EVENT_INFO *PBTH_L2CAP_EVENT_INFO;

typedef struct _BTH_HCI_EVENT_INFO
    {
    BTH_ADDR bthAddress;
    UCHAR connectionType;
    UCHAR connected;
    } 	BTH_HCI_EVENT_INFO;

typedef struct _BTH_HCI_EVENT_INFO *PBTH_HCI_EVENT_INFO;

#define __BTHDEF_H__
#endif


struct SdpString
    {
    /* [size_is] */ CHAR *val;
    ULONG length;
    } ;
typedef struct SdpString SdpString;

typedef /* [switch_type] */ union NodeDataUnion
    {
    /* [case()] */ SDP_LARGE_INTEGER_16 int128;
    /* [case()] */ SDP_ULARGE_INTEGER_16 uint128;
    /* [case()] */ GUID uuid128;
    /* [case()] */ ULONG uuid32;
    /* [case()] */ USHORT uuid16;
    /* [case()] */ LONGLONG int64;
    /* [case()] */ ULONGLONG uint64;
    /* [case()] */ LONG int32;
    /* [case()] */ ULONG uint32;
    /* [case()] */ SHORT int16;
    /* [case()] */ USHORT uint16;
    /* [case()] */ CHAR int8;
    /* [case()] */ UCHAR uint8;
    /* [case()] */ UCHAR booleanVal;
    /* [case()] */ SdpString str;
    /* [case()] */ SdpString url;
    /* [case()] */ ISdpNodeContainer *container;
    /* [case()] */  /* Empty union arm */ 
    } 	NodeDataUnion;

typedef struct NodeData
    {
    USHORT type;
    USHORT specificType;
    /* [switch_is] */ NodeDataUnion u;
    } 	NodeData;


enum BthDeviceStringType
    {	BthDeviceStringTypeFriendlyName	= 0,
	BthDeviceStringTypeDeviceName	= BthDeviceStringTypeFriendlyName + 1,
	BthDeviceStringTypeDisplay	= BthDeviceStringTypeDeviceName + 1,
	BthDeviceStringTypeClass	= BthDeviceStringTypeDisplay + 1,
	BthDeviceStringTypeAddress	= BthDeviceStringTypeClass + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_bthapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bthapi_0000_v0_0_s_ifspec;

#ifndef __ISdpWalk_INTERFACE_DEFINED__
#define __ISdpWalk_INTERFACE_DEFINED__

/* interface ISdpWalk */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpWalk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57134AE6-5D3C-462D-BF2F-810361FBD7E7")
    ISdpWalk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WalkNode( 
            /* [in] */ NodeData *pData,
            /* [in] */ ULONG state) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WalkStream( 
            /* [in] */ UCHAR elementType,
            /* [in] */ ULONG elementSize,
            /* [size_is][in] */ UCHAR *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpWalkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISdpWalk * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISdpWalk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISdpWalk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WalkNode )( 
            ISdpWalk * This,
            /* [in] */ NodeData *pData,
            /* [in] */ ULONG state);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WalkStream )( 
            ISdpWalk * This,
            /* [in] */ UCHAR elementType,
            /* [in] */ ULONG elementSize,
            /* [size_is][in] */ UCHAR *pStream);
        
        END_INTERFACE
    } ISdpWalkVtbl;

    interface ISdpWalk
    {
        CONST_VTBL struct ISdpWalkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpWalk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpWalk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpWalk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpWalk_WalkNode(This,pData,state)	\
    (This)->lpVtbl -> WalkNode(This,pData,state)

#define ISdpWalk_WalkStream(This,elementType,elementSize,pStream)	\
    (This)->lpVtbl -> WalkStream(This,elementType,elementSize,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpWalk_WalkNode_Proxy( 
    ISdpWalk * This,
    /* [in] */ NodeData *pData,
    /* [in] */ ULONG state);


void __RPC_STUB ISdpWalk_WalkNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpWalk_WalkStream_Proxy( 
    ISdpWalk * This,
    /* [in] */ UCHAR elementType,
    /* [in] */ ULONG elementSize,
    /* [size_is][in] */ UCHAR *pStream);


void __RPC_STUB ISdpWalk_WalkStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpWalk_INTERFACE_DEFINED__ */


#ifndef __ISdpNodeContainer_INTERFACE_DEFINED__
#define __ISdpNodeContainer_INTERFACE_DEFINED__

/* interface ISdpNodeContainer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpNodeContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43F6ED49-6E22-4F81-A8EB-DCED40811A77")
    ISdpNodeContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteStream( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONG *pNumBytesWritten) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendNode( 
            /* [in] */ NodeData *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ NodeContainerType *pType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ NodeContainerType type) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ ISdpWalk *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ ULONG nodeIndex,
            /* [in] */ NodeData *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNode( 
            /* [in] */ ULONG nodeIndex,
            /* [out] */ NodeData *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockContainer( 
            /* [in] */ UCHAR lock) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNodeCount( 
            /* [out] */ ULONG *pNodeCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFromStream( 
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNodeStringData( 
            /* [in] */ ULONG nodeIndex,
            /* [out][in] */ NodeData *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamSize( 
            /* [out] */ ULONG *pSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpNodeContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISdpNodeContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISdpNodeContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISdpNodeContainer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            ISdpNodeContainer * This,
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WriteStream )( 
            ISdpNodeContainer * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONG *pNumBytesWritten);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppendNode )( 
            ISdpNodeContainer * This,
            /* [in] */ NodeData *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ISdpNodeContainer * This,
            /* [out] */ NodeContainerType *pType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetType )( 
            ISdpNodeContainer * This,
            /* [in] */ NodeContainerType type);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Walk )( 
            ISdpNodeContainer * This,
            /* [in] */ ISdpWalk *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetNode )( 
            ISdpNodeContainer * This,
            /* [in] */ ULONG nodeIndex,
            /* [in] */ NodeData *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNode )( 
            ISdpNodeContainer * This,
            /* [in] */ ULONG nodeIndex,
            /* [out] */ NodeData *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LockContainer )( 
            ISdpNodeContainer * This,
            /* [in] */ UCHAR lock);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNodeCount )( 
            ISdpNodeContainer * This,
            /* [out] */ ULONG *pNodeCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateFromStream )( 
            ISdpNodeContainer * This,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNodeStringData )( 
            ISdpNodeContainer * This,
            /* [in] */ ULONG nodeIndex,
            /* [out][in] */ NodeData *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStreamSize )( 
            ISdpNodeContainer * This,
            /* [out] */ ULONG *pSize);
        
        END_INTERFACE
    } ISdpNodeContainerVtbl;

    interface ISdpNodeContainer
    {
        CONST_VTBL struct ISdpNodeContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpNodeContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpNodeContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpNodeContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpNodeContainer_CreateStream(This,ppStream,pSize)	\
    (This)->lpVtbl -> CreateStream(This,ppStream,pSize)

#define ISdpNodeContainer_WriteStream(This,pStream,pNumBytesWritten)	\
    (This)->lpVtbl -> WriteStream(This,pStream,pNumBytesWritten)

#define ISdpNodeContainer_AppendNode(This,pData)	\
    (This)->lpVtbl -> AppendNode(This,pData)

#define ISdpNodeContainer_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ISdpNodeContainer_SetType(This,type)	\
    (This)->lpVtbl -> SetType(This,type)

#define ISdpNodeContainer_Walk(This,pWalk)	\
    (This)->lpVtbl -> Walk(This,pWalk)

#define ISdpNodeContainer_SetNode(This,nodeIndex,pData)	\
    (This)->lpVtbl -> SetNode(This,nodeIndex,pData)

#define ISdpNodeContainer_GetNode(This,nodeIndex,pData)	\
    (This)->lpVtbl -> GetNode(This,nodeIndex,pData)

#define ISdpNodeContainer_LockContainer(This,lock)	\
    (This)->lpVtbl -> LockContainer(This,lock)

#define ISdpNodeContainer_GetNodeCount(This,pNodeCount)	\
    (This)->lpVtbl -> GetNodeCount(This,pNodeCount)

#define ISdpNodeContainer_CreateFromStream(This,pStream,size)	\
    (This)->lpVtbl -> CreateFromStream(This,pStream,size)

#define ISdpNodeContainer_GetNodeStringData(This,nodeIndex,pData)	\
    (This)->lpVtbl -> GetNodeStringData(This,nodeIndex,pData)

#define ISdpNodeContainer_GetStreamSize(This,pSize)	\
    (This)->lpVtbl -> GetStreamSize(This,pSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_CreateStream_Proxy( 
    ISdpNodeContainer * This,
    /* [out] */ UCHAR **ppStream,
    /* [out] */ ULONG *pSize);


void __RPC_STUB ISdpNodeContainer_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_WriteStream_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ ULONG *pNumBytesWritten);


void __RPC_STUB ISdpNodeContainer_WriteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_AppendNode_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ NodeData *pData);


void __RPC_STUB ISdpNodeContainer_AppendNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetType_Proxy( 
    ISdpNodeContainer * This,
    /* [out] */ NodeContainerType *pType);


void __RPC_STUB ISdpNodeContainer_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_SetType_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ NodeContainerType type);


void __RPC_STUB ISdpNodeContainer_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_Walk_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ ISdpWalk *pWalk);


void __RPC_STUB ISdpNodeContainer_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_SetNode_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ ULONG nodeIndex,
    /* [in] */ NodeData *pData);


void __RPC_STUB ISdpNodeContainer_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNode_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ ULONG nodeIndex,
    /* [out] */ NodeData *pData);


void __RPC_STUB ISdpNodeContainer_GetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_LockContainer_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ UCHAR lock);


void __RPC_STUB ISdpNodeContainer_LockContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNodeCount_Proxy( 
    ISdpNodeContainer * This,
    /* [out] */ ULONG *pNodeCount);


void __RPC_STUB ISdpNodeContainer_GetNodeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_CreateFromStream_Proxy( 
    ISdpNodeContainer * This,
    /* [size_is][in] */ UCHAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpNodeContainer_CreateFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetNodeStringData_Proxy( 
    ISdpNodeContainer * This,
    /* [in] */ ULONG nodeIndex,
    /* [out][in] */ NodeData *pData);


void __RPC_STUB ISdpNodeContainer_GetNodeStringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpNodeContainer_GetStreamSize_Proxy( 
    ISdpNodeContainer * This,
    /* [out] */ ULONG *pSize);


void __RPC_STUB ISdpNodeContainer_GetStreamSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpNodeContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bthapi_0348 */
/* [local] */ 

//
// flags for fConnect in SdpSearch::Connect
//
#define SDP_SEARCH_CACHED   (0x00000001)


extern RPC_IF_HANDLE __MIDL_itf_bthapi_0348_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bthapi_0348_v0_0_s_ifspec;

#ifndef __ISdpSearch_INTERFACE_DEFINED__
#define __ISdpSearch_INTERFACE_DEFINED__

/* interface ISdpSearch */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D93B6B2A-5EEF-4E1E-BECF-F5A4340C65F5")
    ISdpSearch : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Begin( 
            ULONGLONG *pAddrss,
            ULONG fConnect) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceSearch( 
            /* [size_is][in] */ SdpQueryUuid *pUuidList,
            /* [in] */ ULONG listSize,
            /* [out] */ ULONG *pHandles,
            /* [out][in] */ USHORT *pNumHandles) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AttributeSearch( 
            /* [in] */ ULONG handle,
            /* [size_is][in] */ SdpAttributeRange *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord **ppSdpRecord) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceAndAttributeSearch( 
            /* [size_is][in] */ SdpQueryUuid *pUuidList,
            /* [in] */ ULONG listSize,
            /* [size_is][in] */ SdpAttributeRange *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord ***pppSdpRecord,
            /* [out] */ ULONG *pNumRecords) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISdpSearch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISdpSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISdpSearch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Begin )( 
            ISdpSearch * This,
            ULONGLONG *pAddrss,
            ULONG fConnect);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *End )( 
            ISdpSearch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceSearch )( 
            ISdpSearch * This,
            /* [size_is][in] */ SdpQueryUuid *pUuidList,
            /* [in] */ ULONG listSize,
            /* [out] */ ULONG *pHandles,
            /* [out][in] */ USHORT *pNumHandles);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AttributeSearch )( 
            ISdpSearch * This,
            /* [in] */ ULONG handle,
            /* [size_is][in] */ SdpAttributeRange *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord **ppSdpRecord);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ServiceAndAttributeSearch )( 
            ISdpSearch * This,
            /* [size_is][in] */ SdpQueryUuid *pUuidList,
            /* [in] */ ULONG listSize,
            /* [size_is][in] */ SdpAttributeRange *pRangeList,
            /* [in] */ ULONG numRanges,
            /* [out] */ ISdpRecord ***pppSdpRecord,
            /* [out] */ ULONG *pNumRecords);
        
        END_INTERFACE
    } ISdpSearchVtbl;

    interface ISdpSearch
    {
        CONST_VTBL struct ISdpSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpSearch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpSearch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpSearch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpSearch_Begin(This,pAddrss,fConnect)	\
    (This)->lpVtbl -> Begin(This,pAddrss,fConnect)

#define ISdpSearch_End(This)	\
    (This)->lpVtbl -> End(This)

#define ISdpSearch_ServiceSearch(This,pUuidList,listSize,pHandles,pNumHandles)	\
    (This)->lpVtbl -> ServiceSearch(This,pUuidList,listSize,pHandles,pNumHandles)

#define ISdpSearch_AttributeSearch(This,handle,pRangeList,numRanges,ppSdpRecord)	\
    (This)->lpVtbl -> AttributeSearch(This,handle,pRangeList,numRanges,ppSdpRecord)

#define ISdpSearch_ServiceAndAttributeSearch(This,pUuidList,listSize,pRangeList,numRanges,pppSdpRecord,pNumRecords)	\
    (This)->lpVtbl -> ServiceAndAttributeSearch(This,pUuidList,listSize,pRangeList,numRanges,pppSdpRecord,pNumRecords)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_Begin_Proxy( 
    ISdpSearch * This,
    ULONGLONG *pAddrss,
    ULONG fConnect);


void __RPC_STUB ISdpSearch_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_End_Proxy( 
    ISdpSearch * This);


void __RPC_STUB ISdpSearch_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_ServiceSearch_Proxy( 
    ISdpSearch * This,
    /* [size_is][in] */ SdpQueryUuid *pUuidList,
    /* [in] */ ULONG listSize,
    /* [out] */ ULONG *pHandles,
    /* [out][in] */ USHORT *pNumHandles);


void __RPC_STUB ISdpSearch_ServiceSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_AttributeSearch_Proxy( 
    ISdpSearch * This,
    /* [in] */ ULONG handle,
    /* [size_is][in] */ SdpAttributeRange *pRangeList,
    /* [in] */ ULONG numRanges,
    /* [out] */ ISdpRecord **ppSdpRecord);


void __RPC_STUB ISdpSearch_AttributeSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpSearch_ServiceAndAttributeSearch_Proxy( 
    ISdpSearch * This,
    /* [size_is][in] */ SdpQueryUuid *pUuidList,
    /* [in] */ ULONG listSize,
    /* [size_is][in] */ SdpAttributeRange *pRangeList,
    /* [in] */ ULONG numRanges,
    /* [out] */ ISdpRecord ***pppSdpRecord,
    /* [out] */ ULONG *pNumRecords);


void __RPC_STUB ISdpSearch_ServiceAndAttributeSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpSearch_INTERFACE_DEFINED__ */


#ifndef __ISdpStream_INTERFACE_DEFINED__
#define __ISdpStream_INTERFACE_DEFINED__

/* interface ISdpStream */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6ECD9FB-0C7A-41A3-9FF0-0B617E989357")
    ISdpStream : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Validate( 
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [out] */ ULONG_PTR *pErrorByte) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ ISdpWalk *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveRecords( 
            /* [in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [out][in] */ ISdpRecord **ppSdpRecords,
            /* [out][in] */ ULONG *pNumRecords) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUuid128( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ GUID *pUuid128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint16( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ USHORT *pUint16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint32( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONG *pUint32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint64( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONGLONG *pUint64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveUint128( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt16( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ SHORT *pInt16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt32( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ LONG *pInt32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt64( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ LONGLONG *pInt64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveInt128( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ PSDP_LARGE_INTEGER_16 pInt128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUuid128( 
            /* [in] */ GUID *pInUuid128,
            /* [out] */ GUID *pOutUuid128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint128( 
            /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint64( 
            /* [in] */ ULONGLONG inUint64,
            /* [out] */ ULONGLONG *pOutUint64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint32( 
            /* [in] */ ULONG uint32,
            /* [out] */ ULONG *pUint32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapUint16( 
            /* [in] */ USHORT uint16,
            /* [out] */ USHORT *pUint16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt128( 
            /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
            /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt64( 
            /* [in] */ LONGLONG inInt64,
            /* [out] */ LONGLONG *pOutInt64) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt32( 
            /* [in] */ LONG int32,
            /* [out] */ LONG *pInt32) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ByteSwapInt16( 
            /* [in] */ SHORT int16,
            /* [out] */ SHORT *pInt16) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NormalizeUuid( 
            /* [in] */ NodeData *pDataUuid,
            /* [out] */ GUID *pNormalizeUuid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RetrieveElementInfo( 
            /* [in] */ UCHAR *pStream,
            /* [out] */ SDP_TYPE *pElementType,
            /* [out] */ SDP_SPECIFICTYPE *pElementSpecificType,
            /* [out] */ ULONG *pElementSize,
            /* [out] */ ULONG *pStorageSize,
            /* [out] */ UCHAR **ppData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VerifySequenceOf( 
            /* [in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ SDP_TYPE ofType,
            /* [in] */ UCHAR *pSpecificSizes,
            /* [out] */ ULONG *pNumFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISdpStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISdpStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISdpStream * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            ISdpStream * This,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [out] */ ULONG_PTR *pErrorByte);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Walk )( 
            ISdpStream * This,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ ISdpWalk *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveRecords )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [out][in] */ ISdpRecord **ppSdpRecords,
            /* [out][in] */ ULONG *pNumRecords);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveUuid128 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ GUID *pUuid128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveUint16 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ USHORT *pUint16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveUint32 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONG *pUint32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveUint64 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ ULONGLONG *pUint64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveUint128 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveInt16 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ SHORT *pInt16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveInt32 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ LONG *pInt32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveInt64 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ LONGLONG *pInt64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveInt128 )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ PSDP_LARGE_INTEGER_16 pInt128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapUuid128 )( 
            ISdpStream * This,
            /* [in] */ GUID *pInUuid128,
            /* [out] */ GUID *pOutUuid128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapUint128 )( 
            ISdpStream * This,
            /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
            /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapUint64 )( 
            ISdpStream * This,
            /* [in] */ ULONGLONG inUint64,
            /* [out] */ ULONGLONG *pOutUint64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapUint32 )( 
            ISdpStream * This,
            /* [in] */ ULONG uint32,
            /* [out] */ ULONG *pUint32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapUint16 )( 
            ISdpStream * This,
            /* [in] */ USHORT uint16,
            /* [out] */ USHORT *pUint16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapInt128 )( 
            ISdpStream * This,
            /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
            /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapInt64 )( 
            ISdpStream * This,
            /* [in] */ LONGLONG inInt64,
            /* [out] */ LONGLONG *pOutInt64);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapInt32 )( 
            ISdpStream * This,
            /* [in] */ LONG int32,
            /* [out] */ LONG *pInt32);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ByteSwapInt16 )( 
            ISdpStream * This,
            /* [in] */ SHORT int16,
            /* [out] */ SHORT *pInt16);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NormalizeUuid )( 
            ISdpStream * This,
            /* [in] */ NodeData *pDataUuid,
            /* [out] */ GUID *pNormalizeUuid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RetrieveElementInfo )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [out] */ SDP_TYPE *pElementType,
            /* [out] */ SDP_SPECIFICTYPE *pElementSpecificType,
            /* [out] */ ULONG *pElementSize,
            /* [out] */ ULONG *pStorageSize,
            /* [out] */ UCHAR **ppData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VerifySequenceOf )( 
            ISdpStream * This,
            /* [in] */ UCHAR *pStream,
            /* [in] */ ULONG size,
            /* [in] */ SDP_TYPE ofType,
            /* [in] */ UCHAR *pSpecificSizes,
            /* [out] */ ULONG *pNumFound);
        
        END_INTERFACE
    } ISdpStreamVtbl;

    interface ISdpStream
    {
        CONST_VTBL struct ISdpStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpStream_Validate(This,pStream,size,pErrorByte)	\
    (This)->lpVtbl -> Validate(This,pStream,size,pErrorByte)

#define ISdpStream_Walk(This,pStream,size,pWalk)	\
    (This)->lpVtbl -> Walk(This,pStream,size,pWalk)

#define ISdpStream_RetrieveRecords(This,pStream,size,ppSdpRecords,pNumRecords)	\
    (This)->lpVtbl -> RetrieveRecords(This,pStream,size,ppSdpRecords,pNumRecords)

#define ISdpStream_RetrieveUuid128(This,pStream,pUuid128)	\
    (This)->lpVtbl -> RetrieveUuid128(This,pStream,pUuid128)

#define ISdpStream_RetrieveUint16(This,pStream,pUint16)	\
    (This)->lpVtbl -> RetrieveUint16(This,pStream,pUint16)

#define ISdpStream_RetrieveUint32(This,pStream,pUint32)	\
    (This)->lpVtbl -> RetrieveUint32(This,pStream,pUint32)

#define ISdpStream_RetrieveUint64(This,pStream,pUint64)	\
    (This)->lpVtbl -> RetrieveUint64(This,pStream,pUint64)

#define ISdpStream_RetrieveUint128(This,pStream,pUint128)	\
    (This)->lpVtbl -> RetrieveUint128(This,pStream,pUint128)

#define ISdpStream_RetrieveInt16(This,pStream,pInt16)	\
    (This)->lpVtbl -> RetrieveInt16(This,pStream,pInt16)

#define ISdpStream_RetrieveInt32(This,pStream,pInt32)	\
    (This)->lpVtbl -> RetrieveInt32(This,pStream,pInt32)

#define ISdpStream_RetrieveInt64(This,pStream,pInt64)	\
    (This)->lpVtbl -> RetrieveInt64(This,pStream,pInt64)

#define ISdpStream_RetrieveInt128(This,pStream,pInt128)	\
    (This)->lpVtbl -> RetrieveInt128(This,pStream,pInt128)

#define ISdpStream_ByteSwapUuid128(This,pInUuid128,pOutUuid128)	\
    (This)->lpVtbl -> ByteSwapUuid128(This,pInUuid128,pOutUuid128)

#define ISdpStream_ByteSwapUint128(This,pInUint128,pOutUint128)	\
    (This)->lpVtbl -> ByteSwapUint128(This,pInUint128,pOutUint128)

#define ISdpStream_ByteSwapUint64(This,inUint64,pOutUint64)	\
    (This)->lpVtbl -> ByteSwapUint64(This,inUint64,pOutUint64)

#define ISdpStream_ByteSwapUint32(This,uint32,pUint32)	\
    (This)->lpVtbl -> ByteSwapUint32(This,uint32,pUint32)

#define ISdpStream_ByteSwapUint16(This,uint16,pUint16)	\
    (This)->lpVtbl -> ByteSwapUint16(This,uint16,pUint16)

#define ISdpStream_ByteSwapInt128(This,pInInt128,pOutInt128)	\
    (This)->lpVtbl -> ByteSwapInt128(This,pInInt128,pOutInt128)

#define ISdpStream_ByteSwapInt64(This,inInt64,pOutInt64)	\
    (This)->lpVtbl -> ByteSwapInt64(This,inInt64,pOutInt64)

#define ISdpStream_ByteSwapInt32(This,int32,pInt32)	\
    (This)->lpVtbl -> ByteSwapInt32(This,int32,pInt32)

#define ISdpStream_ByteSwapInt16(This,int16,pInt16)	\
    (This)->lpVtbl -> ByteSwapInt16(This,int16,pInt16)

#define ISdpStream_NormalizeUuid(This,pDataUuid,pNormalizeUuid)	\
    (This)->lpVtbl -> NormalizeUuid(This,pDataUuid,pNormalizeUuid)

#define ISdpStream_RetrieveElementInfo(This,pStream,pElementType,pElementSpecificType,pElementSize,pStorageSize,ppData)	\
    (This)->lpVtbl -> RetrieveElementInfo(This,pStream,pElementType,pElementSpecificType,pElementSize,pStorageSize,ppData)

#define ISdpStream_VerifySequenceOf(This,pStream,size,ofType,pSpecificSizes,pNumFound)	\
    (This)->lpVtbl -> VerifySequenceOf(This,pStream,size,ofType,pSpecificSizes,pNumFound)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_Validate_Proxy( 
    ISdpStream * This,
    /* [size_is][in] */ UCHAR *pStream,
    /* [in] */ ULONG size,
    /* [out] */ ULONG_PTR *pErrorByte);


void __RPC_STUB ISdpStream_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_Walk_Proxy( 
    ISdpStream * This,
    /* [size_is][in] */ UCHAR *pStream,
    /* [in] */ ULONG size,
    /* [in] */ ISdpWalk *pWalk);


void __RPC_STUB ISdpStream_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveRecords_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [in] */ ULONG size,
    /* [out][in] */ ISdpRecord **ppSdpRecords,
    /* [out][in] */ ULONG *pNumRecords);


void __RPC_STUB ISdpStream_RetrieveRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUuid128_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ GUID *pUuid128);


void __RPC_STUB ISdpStream_RetrieveUuid128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint16_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ USHORT *pUint16);


void __RPC_STUB ISdpStream_RetrieveUint16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint32_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ ULONG *pUint32);


void __RPC_STUB ISdpStream_RetrieveUint32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint64_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ ULONGLONG *pUint64);


void __RPC_STUB ISdpStream_RetrieveUint64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveUint128_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ PSDP_ULARGE_INTEGER_16 pUint128);


void __RPC_STUB ISdpStream_RetrieveUint128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt16_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ SHORT *pInt16);


void __RPC_STUB ISdpStream_RetrieveInt16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt32_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ LONG *pInt32);


void __RPC_STUB ISdpStream_RetrieveInt32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt64_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ LONGLONG *pInt64);


void __RPC_STUB ISdpStream_RetrieveInt64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveInt128_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ PSDP_LARGE_INTEGER_16 pInt128);


void __RPC_STUB ISdpStream_RetrieveInt128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUuid128_Proxy( 
    ISdpStream * This,
    /* [in] */ GUID *pInUuid128,
    /* [out] */ GUID *pOutUuid128);


void __RPC_STUB ISdpStream_ByteSwapUuid128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint128_Proxy( 
    ISdpStream * This,
    /* [in] */ PSDP_ULARGE_INTEGER_16 pInUint128,
    /* [out] */ PSDP_ULARGE_INTEGER_16 pOutUint128);


void __RPC_STUB ISdpStream_ByteSwapUint128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint64_Proxy( 
    ISdpStream * This,
    /* [in] */ ULONGLONG inUint64,
    /* [out] */ ULONGLONG *pOutUint64);


void __RPC_STUB ISdpStream_ByteSwapUint64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint32_Proxy( 
    ISdpStream * This,
    /* [in] */ ULONG uint32,
    /* [out] */ ULONG *pUint32);


void __RPC_STUB ISdpStream_ByteSwapUint32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapUint16_Proxy( 
    ISdpStream * This,
    /* [in] */ USHORT uint16,
    /* [out] */ USHORT *pUint16);


void __RPC_STUB ISdpStream_ByteSwapUint16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt128_Proxy( 
    ISdpStream * This,
    /* [in] */ PSDP_LARGE_INTEGER_16 pInInt128,
    /* [out] */ PSDP_LARGE_INTEGER_16 pOutInt128);


void __RPC_STUB ISdpStream_ByteSwapInt128_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt64_Proxy( 
    ISdpStream * This,
    /* [in] */ LONGLONG inInt64,
    /* [out] */ LONGLONG *pOutInt64);


void __RPC_STUB ISdpStream_ByteSwapInt64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt32_Proxy( 
    ISdpStream * This,
    /* [in] */ LONG int32,
    /* [out] */ LONG *pInt32);


void __RPC_STUB ISdpStream_ByteSwapInt32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_ByteSwapInt16_Proxy( 
    ISdpStream * This,
    /* [in] */ SHORT int16,
    /* [out] */ SHORT *pInt16);


void __RPC_STUB ISdpStream_ByteSwapInt16_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_NormalizeUuid_Proxy( 
    ISdpStream * This,
    /* [in] */ NodeData *pDataUuid,
    /* [out] */ GUID *pNormalizeUuid);


void __RPC_STUB ISdpStream_NormalizeUuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_RetrieveElementInfo_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [out] */ SDP_TYPE *pElementType,
    /* [out] */ SDP_SPECIFICTYPE *pElementSpecificType,
    /* [out] */ ULONG *pElementSize,
    /* [out] */ ULONG *pStorageSize,
    /* [out] */ UCHAR **ppData);


void __RPC_STUB ISdpStream_RetrieveElementInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpStream_VerifySequenceOf_Proxy( 
    ISdpStream * This,
    /* [in] */ UCHAR *pStream,
    /* [in] */ ULONG size,
    /* [in] */ SDP_TYPE ofType,
    /* [in] */ UCHAR *pSpecificSizes,
    /* [out] */ ULONG *pNumFound);


void __RPC_STUB ISdpStream_VerifySequenceOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpStream_INTERFACE_DEFINED__ */


#ifndef __ISdpRecord_INTERFACE_DEFINED__
#define __ISdpRecord_INTERFACE_DEFINED__

/* interface ISdpRecord */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISdpRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10276714-1456-46D7-B526-8B1E83D5116E")
    ISdpRecord : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateFromStream( 
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WriteToStream( 
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pStreamSize,
            ULONG preSize,
            ULONG postSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ USHORT attribute,
            /* [in] */ NodeData *pNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAttributeFromStream( 
            /* [in] */ USHORT attribute,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ USHORT attribute,
            /* [out][in] */ NodeData *pNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributeAsStream( 
            /* [in] */ USHORT attribute,
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Walk( 
            /* [in] */ ISdpWalk *pWalk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributeList( 
            /* [out] */ USHORT **ppList,
            /* [out] */ ULONG *pListSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            USHORT offset,
            USHORT *pLangId,
            WCHAR **ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIcon( 
            int cxRes,
            int cyRes,
            HICON *phIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetServiceClass( 
            /* [out] */ LPGUID pServiceClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISdpRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISdpRecord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISdpRecord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISdpRecord * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateFromStream )( 
            ISdpRecord * This,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WriteToStream )( 
            ISdpRecord * This,
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pStreamSize,
            ULONG preSize,
            ULONG postSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            ISdpRecord * This,
            /* [in] */ USHORT attribute,
            /* [in] */ NodeData *pNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAttributeFromStream )( 
            ISdpRecord * This,
            /* [in] */ USHORT attribute,
            /* [size_is][in] */ UCHAR *pStream,
            /* [in] */ ULONG size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            ISdpRecord * This,
            /* [in] */ USHORT attribute,
            /* [out][in] */ NodeData *pNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttributeAsStream )( 
            ISdpRecord * This,
            /* [in] */ USHORT attribute,
            /* [out] */ UCHAR **ppStream,
            /* [out] */ ULONG *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Walk )( 
            ISdpRecord * This,
            /* [in] */ ISdpWalk *pWalk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttributeList )( 
            ISdpRecord * This,
            /* [out] */ USHORT **ppList,
            /* [out] */ ULONG *pListSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ISdpRecord * This,
            USHORT offset,
            USHORT *pLangId,
            WCHAR **ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            ISdpRecord * This,
            int cxRes,
            int cyRes,
            HICON *phIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetServiceClass )( 
            ISdpRecord * This,
            /* [out] */ LPGUID pServiceClass);
        
        END_INTERFACE
    } ISdpRecordVtbl;

    interface ISdpRecord
    {
        CONST_VTBL struct ISdpRecordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISdpRecord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISdpRecord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISdpRecord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISdpRecord_CreateFromStream(This,pStream,size)	\
    (This)->lpVtbl -> CreateFromStream(This,pStream,size)

#define ISdpRecord_WriteToStream(This,ppStream,pStreamSize,preSize,postSize)	\
    (This)->lpVtbl -> WriteToStream(This,ppStream,pStreamSize,preSize,postSize)

#define ISdpRecord_SetAttribute(This,attribute,pNode)	\
    (This)->lpVtbl -> SetAttribute(This,attribute,pNode)

#define ISdpRecord_SetAttributeFromStream(This,attribute,pStream,size)	\
    (This)->lpVtbl -> SetAttributeFromStream(This,attribute,pStream,size)

#define ISdpRecord_GetAttribute(This,attribute,pNode)	\
    (This)->lpVtbl -> GetAttribute(This,attribute,pNode)

#define ISdpRecord_GetAttributeAsStream(This,attribute,ppStream,pSize)	\
    (This)->lpVtbl -> GetAttributeAsStream(This,attribute,ppStream,pSize)

#define ISdpRecord_Walk(This,pWalk)	\
    (This)->lpVtbl -> Walk(This,pWalk)

#define ISdpRecord_GetAttributeList(This,ppList,pListSize)	\
    (This)->lpVtbl -> GetAttributeList(This,ppList,pListSize)

#define ISdpRecord_GetString(This,offset,pLangId,ppString)	\
    (This)->lpVtbl -> GetString(This,offset,pLangId,ppString)

#define ISdpRecord_GetIcon(This,cxRes,cyRes,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,cxRes,cyRes,phIcon)

#define ISdpRecord_GetServiceClass(This,pServiceClass)	\
    (This)->lpVtbl -> GetServiceClass(This,pServiceClass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_CreateFromStream_Proxy( 
    ISdpRecord * This,
    /* [size_is][in] */ UCHAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpRecord_CreateFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_WriteToStream_Proxy( 
    ISdpRecord * This,
    /* [out] */ UCHAR **ppStream,
    /* [out] */ ULONG *pStreamSize,
    ULONG preSize,
    ULONG postSize);


void __RPC_STUB ISdpRecord_WriteToStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_SetAttribute_Proxy( 
    ISdpRecord * This,
    /* [in] */ USHORT attribute,
    /* [in] */ NodeData *pNode);


void __RPC_STUB ISdpRecord_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_SetAttributeFromStream_Proxy( 
    ISdpRecord * This,
    /* [in] */ USHORT attribute,
    /* [size_is][in] */ UCHAR *pStream,
    /* [in] */ ULONG size);


void __RPC_STUB ISdpRecord_SetAttributeFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttribute_Proxy( 
    ISdpRecord * This,
    /* [in] */ USHORT attribute,
    /* [out][in] */ NodeData *pNode);


void __RPC_STUB ISdpRecord_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttributeAsStream_Proxy( 
    ISdpRecord * This,
    /* [in] */ USHORT attribute,
    /* [out] */ UCHAR **ppStream,
    /* [out] */ ULONG *pSize);


void __RPC_STUB ISdpRecord_GetAttributeAsStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_Walk_Proxy( 
    ISdpRecord * This,
    /* [in] */ ISdpWalk *pWalk);


void __RPC_STUB ISdpRecord_Walk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetAttributeList_Proxy( 
    ISdpRecord * This,
    /* [out] */ USHORT **ppList,
    /* [out] */ ULONG *pListSize);


void __RPC_STUB ISdpRecord_GetAttributeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetString_Proxy( 
    ISdpRecord * This,
    USHORT offset,
    USHORT *pLangId,
    WCHAR **ppString);


void __RPC_STUB ISdpRecord_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetIcon_Proxy( 
    ISdpRecord * This,
    int cxRes,
    int cyRes,
    HICON *phIcon);


void __RPC_STUB ISdpRecord_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISdpRecord_GetServiceClass_Proxy( 
    ISdpRecord * This,
    /* [out] */ LPGUID pServiceClass);


void __RPC_STUB ISdpRecord_GetServiceClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISdpRecord_INTERFACE_DEFINED__ */


#ifndef __IBluetoothDevice_INTERFACE_DEFINED__
#define __IBluetoothDevice_INTERFACE_DEFINED__

/* interface IBluetoothDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBluetoothDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5BD0418B-D705-4766-B215-183E4EADE341")
    IBluetoothDevice : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            const PBTH_DEVICE_INFO pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInfo( 
            PBTH_DEVICE_INFO pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            enum BthDeviceStringType type,
            WCHAR **ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetString( 
            enum BthDeviceStringType type,
            WCHAR *ppString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIcon( 
            int cxRes,
            int cyRes,
            HICON *phIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetApprovedServices( 
            GUID *pServices,
            ULONG *pServiceCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassKey( 
            HWND hwndParent,
            UCHAR *pPassKey,
            UCHAR *pPassKeyLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBluetoothDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBluetoothDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBluetoothDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBluetoothDevice * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IBluetoothDevice * This,
            const PBTH_DEVICE_INFO pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IBluetoothDevice * This,
            PBTH_DEVICE_INFO pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IBluetoothDevice * This,
            enum BthDeviceStringType type,
            WCHAR **ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IBluetoothDevice * This,
            enum BthDeviceStringType type,
            WCHAR *ppString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            IBluetoothDevice * This,
            int cxRes,
            int cyRes,
            HICON *phIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetApprovedServices )( 
            IBluetoothDevice * This,
            GUID *pServices,
            ULONG *pServiceCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPassKey )( 
            IBluetoothDevice * This,
            HWND hwndParent,
            UCHAR *pPassKey,
            UCHAR *pPassKeyLength);
        
        END_INTERFACE
    } IBluetoothDeviceVtbl;

    interface IBluetoothDevice
    {
        CONST_VTBL struct IBluetoothDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBluetoothDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBluetoothDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBluetoothDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBluetoothDevice_Initialize(This,pInfo)	\
    (This)->lpVtbl -> Initialize(This,pInfo)

#define IBluetoothDevice_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define IBluetoothDevice_GetString(This,type,ppString)	\
    (This)->lpVtbl -> GetString(This,type,ppString)

#define IBluetoothDevice_SetString(This,type,ppString)	\
    (This)->lpVtbl -> SetString(This,type,ppString)

#define IBluetoothDevice_GetIcon(This,cxRes,cyRes,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,cxRes,cyRes,phIcon)

#define IBluetoothDevice_GetApprovedServices(This,pServices,pServiceCount)	\
    (This)->lpVtbl -> GetApprovedServices(This,pServices,pServiceCount)

#define IBluetoothDevice_GetPassKey(This,hwndParent,pPassKey,pPassKeyLength)	\
    (This)->lpVtbl -> GetPassKey(This,hwndParent,pPassKey,pPassKeyLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_Initialize_Proxy( 
    IBluetoothDevice * This,
    const PBTH_DEVICE_INFO pInfo);


void __RPC_STUB IBluetoothDevice_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetInfo_Proxy( 
    IBluetoothDevice * This,
    PBTH_DEVICE_INFO pInfo);


void __RPC_STUB IBluetoothDevice_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetString_Proxy( 
    IBluetoothDevice * This,
    enum BthDeviceStringType type,
    WCHAR **ppString);


void __RPC_STUB IBluetoothDevice_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_SetString_Proxy( 
    IBluetoothDevice * This,
    enum BthDeviceStringType type,
    WCHAR *ppString);


void __RPC_STUB IBluetoothDevice_SetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetIcon_Proxy( 
    IBluetoothDevice * This,
    int cxRes,
    int cyRes,
    HICON *phIcon);


void __RPC_STUB IBluetoothDevice_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetApprovedServices_Proxy( 
    IBluetoothDevice * This,
    GUID *pServices,
    ULONG *pServiceCount);


void __RPC_STUB IBluetoothDevice_GetApprovedServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IBluetoothDevice_GetPassKey_Proxy( 
    IBluetoothDevice * This,
    HWND hwndParent,
    UCHAR *pPassKey,
    UCHAR *pPassKeyLength);


void __RPC_STUB IBluetoothDevice_GetPassKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBluetoothDevice_INTERFACE_DEFINED__ */


#ifndef __IBluetoothAuthenticate_INTERFACE_DEFINED__
#define __IBluetoothAuthenticate_INTERFACE_DEFINED__

/* interface IBluetoothAuthenticate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBluetoothAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F0FBA2B-8300-429D-99AD-96A2835D4901")
    IBluetoothAuthenticate : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IBluetoothAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBluetoothAuthenticate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBluetoothAuthenticate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBluetoothAuthenticate * This);
        
        END_INTERFACE
    } IBluetoothAuthenticateVtbl;

    interface IBluetoothAuthenticate
    {
        CONST_VTBL struct IBluetoothAuthenticateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBluetoothAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBluetoothAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBluetoothAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBluetoothAuthenticate_INTERFACE_DEFINED__ */



#ifndef __BTHAPILib_LIBRARY_DEFINED__
#define __BTHAPILib_LIBRARY_DEFINED__

/* library BTHAPILib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_BTHAPILib;

EXTERN_C const CLSID CLSID_SdpNodeContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("51002954-D4E4-4507-B480-1B8454347CDC")
SdpNodeContainer;
#endif

EXTERN_C const CLSID CLSID_SdpSearch;

#ifdef __cplusplus

class DECLSPEC_UUID("8330E81E-F3CB-4EDC-95FA-676BFBC0580B")
SdpSearch;
#endif

EXTERN_C const CLSID CLSID_SdpWalk;

#ifdef __cplusplus

class DECLSPEC_UUID("29A852AB-FEFB-426F-B991-9618B1B88D5B")
SdpWalk;
#endif

EXTERN_C const CLSID CLSID_SdpStream;

#ifdef __cplusplus

class DECLSPEC_UUID("D47A9493-FBBA-4E02-A532-E865CBBE0023")
SdpStream;
#endif

EXTERN_C const CLSID CLSID_SdpRecord;

#ifdef __cplusplus

class DECLSPEC_UUID("238CACDA-2346-4748-B3EE-F12782772DFC")
SdpRecord;
#endif

EXTERN_C const CLSID CLSID_ShellPropSheetExt;

#ifdef __cplusplus

class DECLSPEC_UUID("6fb95bcb-a682-4635-b07e-22435174b893")
ShellPropSheetExt;
#endif

EXTERN_C const CLSID CLSID_BluetoothAuthenticate;

#ifdef __cplusplus

class DECLSPEC_UUID("B25EDF40-5EBE-4590-A690-A42B13C9E8E1")
BluetoothAuthenticate;
#endif

EXTERN_C const CLSID CLSID_BluetoothDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("DA39B330-7F45-433A-A19D-33393017662C")
BluetoothDevice;
#endif
#endif /* __BTHAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\bthpriv.h ===
#ifndef __BTHPRIV_H__
#define __BTHPRIV_H__

#include <PSHPACK1.H>

// {AEAA934B-5219-421E-8A47-06521BFE1AC9}
DEFINE_GUID(GUID_BTHPORT_WMI_SDP_SERVER_LOG_INFO,   0xaeaa934b, 0x5219, 0x421e, 0x8a, 0x47, 0x06, 0x52, 0x1b, 0xfe, 0x1a, 0xc9);

// {29D4F12C-FAD2-4EBF-A7B5-8BD9BC2104ED}
DEFINE_GUID(GUID_BTHPORT_WMI_SDP_DATABASE_EVENT,    0x29d4f12c, 0xfad2, 0x4ebf, 0xa7, 0xb5, 0x8b, 0xd9, 0xbc, 0x21, 0x04, 0xed);

// {CEB09762-F204-44fa-8E65-C85F820F8AD5}
DEFINE_GUID(GUID_BTHPORT_WMI_HCI_PACKET_INFO,       0xceb09762, 0xf204, 0x44fa, 0x8e, 0x65, 0xc8, 0x5f, 0x82, 0xf, 0x8a, 0xd5);

typedef struct _BTH_DEVICE_INQUIRY {
    //
    // Either LAP_GIAC_VALUE or LAP_LIAC_VALUE
    //
    BTH_LAP lap;

    //
    // [IN]  ( N * 1.28 secs). Range : 1.28 s - 61.44 s.
    //
    UCHAR inquiryTimeoutMultiplier;

} BTH_DEVICE_INQUIRY, *PBTH_DEVICE_INQUIRY;

typedef struct _BTH_DEVICE_INFO_LIST {
    //
    // [IN/OUT] minimum of 1 device required
    //
    ULONG       numOfDevices;

    //
    // Open ended array of devices;
    //
    BTH_DEVICE_INFO   deviceList[1];

} BTH_DEVICE_INFO_LIST, *PBTH_DEVICE_INFO_LIST;

typedef struct _BTH_RADIO_INFO {
    //
    // Supported LMP features of the radio.  Use LMP_XXX() to extract
    // the desired bits.
    //
    ULONGLONG lmpSupportedFeatures;

    //
    // Manufacturer ID (possibly BTH_MFG_XXX)
    //
    USHORT mfg;

    //
    // LMP subversion
    //
    USHORT lmpSubversion;

    //
    // LMP version
    //
    UCHAR lmpVersion;

} BTH_RADIO_INFO, *PBTH_RADIO_INFO;

#define LOCAL_RADIO_DISCOVERABLE    (0x00000001)
#define LOCAL_RADIO_CONNECTABLE     (0x00000002)
#define LOCAL_RADIO_SCAN_MASK       (LOCAL_RADIO_DISCOVERABLE | \
                                     LOCAL_RADIO_CONNECTABLE)

typedef struct _BTH_LOCAL_RADIO_INFO {
    //
    // Local BTH_ADDR, class of defice, and radio name
    //
    BTH_DEVICE_INFO         localInfo;

    //
    // Combo of LOCAL_RADIO_XXX values
    //
    ULONG flags;

    //
    // HCI revision, see core spec
    //
    USHORT hciRevision;

    //
    // HCI version, see core spec
    //
    UCHAR hciVersion;

    //
    // More information about the local radio (LMP, MFG)
    //
    BTH_RADIO_INFO radioInfo;

} BTH_LOCAL_RADIO_INFO, *PBTH_LOCAL_RADIO_INFO;

#define SIG_UNNAMED   { 0x04, 0x0b, 0x09 }
#define SIG_UNNAMED_LEN         (3)

//
// Private IOCTL definitions
//

typedef enum _SDP_SERVER_LOG_TYPE {
    SdpServerLogTypeError = 1,
    SdpServerLogTypeServiceSearch,
    SdpServerLogTypeServiceSearchResponse,
    SdpServerLogTypeAttributeSearch,
    SdpServerLogTypeAttributeSearchResponse,
    SdpServerLogTypeServiceSearchAttribute,
    SdpServerLogTypeServiceSearchAttributeResponse,
    SdpServerLogTypeConnect,
    SdpServerLogTypeDisconnect,
} SDP_SERVER_LOG_TYPE;

typedef struct _SDP_SERVER_LOG_INFO {
    SDP_SERVER_LOG_TYPE type;

    BTH_DEVICE_INFO info;

    ULONG dataLength;

    USHORT mtu;
    USHORT _r;

    UCHAR data[1];

} SDP_SERVER_LOG_INFO, *PSDP_SERVER_LOG_INFO;

typedef enum _SDP_DATABASE_EVENT_TYPE {
    SdpDatabaseEventNewRecord = 0,
    SdpDatabaseEventUpdateRecord,
    SdpDatabaseEventRemoveRecord
} SDP_DATABASE_EVENT_TYPE, *PSDP_DATABASE_EVENT_TYPE;

typedef struct _SDP_DATABASE_EVENT {
    SDP_DATABASE_EVENT_TYPE type;
    HANDLE handle;
} SDP_DATABASE_EVENT, *PSDP_DATABASE_EVENT;

typedef enum _BTH_SECURITY_LEVEL {
    BthSecLevelNone  = 0,
    BthSecLevelSoftware,
    BthSecLevelBaseband,
    BthSecLevelMaximum
} BTH_SECURITY_LEVEL, *PBTH_SECURITY_LEVEL;

//
// Common header for all PIN related structures
//
typedef struct _BTH_PIN_INFO {
    BTH_ADDR bthAddressRemote;
    UCHAR pin[BTH_MAX_PIN_SIZE];
    UCHAR pinLength;
} BTH_PIN_INFO, *PBTH_PIN_INFO;


//
// Structure used when responding to BTH_REMOTE_AUTHENTICATE_REQUEST event
//
// NOTE:  BTH_PIN_INFO must be the first field in this structure
//
typedef struct _BTH_AUTHENTICATE_RESPONSE {
    BTH_PIN_INFO info;
    UCHAR negativeResponse;
} BTH_AUTHENTICATE_RESPONSE, *PBTH_AUTHENTICATE_RESPONSE;

//
// Structure used when initiating an authentication request
//
// NOTE:  BTH_PIN_INFO must be the first field in this structure
//
typedef struct _BTH_AUTHENTICATE_DEVICE {
    BTH_PIN_INFO info;

    HANDLE pinWrittenEvent;

} BTH_AUTHENTICATE_DEVICE, *PBTH_AUTHENTICATE_DEVICE;

#define BTH_UPDATE_ADD      (0x00000001)
#define BTH_UPDATE_REMOVE   (0x00000002)
#define BTH_UPDATE_ID       (0x00000004)

#define BTH_UPDATE_MASK     (BTH_UPDATE_REMOVE | BTH_UPDATE_ADD | BTH_UPDATE_ID)

typedef struct _BTH_DEVICE_UPDATE {
    BTH_ADDR btAddr;

    ULONG flags;

    USHORT vid;

    USHORT pid;

    USHORT vidType;

    USHORT mfg;

    GUID protocols[1];

} BTH_DEVICE_UPDATE, *PBTH_DEVICE_UPDATE;

typedef struct _BTH_DEVICE_PROTOCOLS_LIST {
    ULONG numProtocols;

    ULONG maxProtocols;

    GUID protocols[1];
} BTH_DEVICE_PROTOCOLS_LIST, *PBTH_DEVICE_PROTOCOLS_LIST;

//
// These are spec values, so they cannot be changed
//
#define BTH_SCAN_ENABLE_INQUIRY  (0X01)
#define BTH_SCAN_ENABLE_PAGE     (0x02)
#define BTH_SCAN_ENABLE_MASK    (BTH_SCAN_ENABLE_PAGE | BTH_SCAN_ENABLE_INQUIRY)
#define BTH_SCAN_ENABLE_DEFAULT (BTH_SCAN_ENABLE_PAGE | BTH_SCAN_ENABLE_INQUIRY)

#define SDP_CONNECT_CACHE           (0x00000001)
#define SDP_CONNECT_ALLOW_PIN       (0x00000002)

#define SDP_REQUEST_TO_DEFAULT      (0)
#define SDP_REQUEST_TO_MIN          (10)
#define SDP_REQUEST_TO_MAX          (45)

#define SDP_CONNECT_VALID_FLAGS     (SDP_CONNECT_CACHE | SDP_CONNECT_ALLOW_PIN)

// #define SERVICE_OPTION_PERMANENT         (0x00000001)
#define SERVICE_OPTION_DO_NOT_PUBLISH       (0x00000002)
#define SERVICE_OPTION_NO_PUBLIC_BROWSE     (0x00000004)

#define SERVICE_OPTION_VALID_MASK           (SERVICE_OPTION_NO_PUBLIC_BROWSE | \
                                             SERVICE_OPTION_DO_NOT_PUBLISH)

#define SERVICE_SECURITY_USE_DEFAULTS       (0x00000000)
#define SERVICE_SECURITY_NONE               (0x00000001)
#define SERVICE_SECURITY_AUTHORIZE          (0x00000002)
#define SERVICE_SECURITY_AUTHENTICATE       (0x00000004)
#define SERVICE_SECURITY_ENCRYPT_REQUIRED   (0x00000010)
#define SERVICE_SECURITY_ENCRYPT_OPTIONAL   (0x00000020)
#define SERVICE_SECURITY_DISABLED           (0x10000000)
#define SERVICE_SECURITY_NO_ASK             (0x20000000)

#define SERVICE_SECURITY_VALID_MASK \
    (SERVICE_SECURITY_NONE         | SERVICE_SECURITY_AUTHORIZE        | \
     SERVICE_SECURITY_AUTHENTICATE | SERVICE_SECURITY_ENCRYPT_REQUIRED | \
     SERVICE_SECURITY_ENCRYPT_OPTIONAL)


typedef PVOID HANDLE_SDP, *PHANDLE_SDP;
#define HANDLE_SDP_LOCAL    ((HANDLE_SDP) -2)

typedef struct _BTH_SDP_CONNECT {
    //
    // Address of the remote SDP server.  Cannot be the local radio.
    //
    BTH_ADDR     bthAddress;

    //
    // Combination of SDP_CONNECT_XXX flags
    //
    ULONG       fSdpConnect;

    //
    // When the connect request returns, this will specify the handle to the
    // SDP connection to the remote server
    //
    HANDLE_SDP  hConnection;

    //
    // Timeout, in seconds, for the requests on ths SDP channel.  If the request
    // times out, the SDP connection represented by the HANDLE_SDP must be
    // closed.  The values for this field are bound by SDP_REQUEST_TO_MIN and
    // SDP_REQUEST_MAX.  If SDP_REQUEST_TO_DEFAULT is specified, the timeout is
    // 30 seconds.
    //
    UCHAR       requestTimeout;

} BTH_SDP_CONNECT,  *PBTH_SDP_CONNECT;

typedef struct _BTH_SDP_DISCONNECT {
    //
    // hConnection returned by BTH_SDP_CONNECT
    //
    HANDLE_SDP hConnection;

} BTH_SDP_DISCONNECT, *PBTH_SDP_DISCONNECT;


typedef struct _BTH_SDP_RECORD {
    //
    // Combination of SERVICE_SECURITY_XXX flags
    //
    ULONG fSecurity;

    //
    // Combination of SERVICE_OPTION_XXX flags
    //
    ULONG fOptions;

    //
    // combo of COD_SERVICE_XXX flags
    //
    ULONG fCodService;

    //
    // The length of the record array, in bytes.
    //
    ULONG recordLength;

    //
    // The SDP record in its raw format
    //
    UCHAR record[1];

} BTH_SDP_RECORD, *PBTH_SDP_RECORD;

typedef struct _BTH_SDP_SERVICE_SEARCH_REQUEST {
    //
    // Handle returned by the connect request or HANDLE_SDP_LOCAL
    //
    HANDLE_SDP hConnection;

    //
    // Array of UUIDs.  Each entry can be either a 2 byte, 4 byte or 16 byte
    // UUID. SDP spec mandates that a request can have a maximum of 12 UUIDs.
    //
    SdpQueryUuid uuids[MAX_UUIDS_IN_QUERY];

} BTH_SDP_SERVICE_SEARCH_REQUEST, *PBTH_SDP_SERVICE_SEARCH_REQUEST;

//
// Do not even attempt to validate that the stream can be parsed
//
#define SDP_SEARCH_NO_PARSE_CHECK   (0x00000001)

//
// Do not check the format of the results.  This includes suppression of both
// the check for a record patten (SEQ of UINT16 + value) and the validation
// of each universal attribute's accordance to the spec.
//
#define SDP_SEARCH_NO_FORMAT_CHECK  (0x00000002)

#define SDP_SEARCH_VALID_FLAGS      \
    (SDP_SEARCH_NO_PARSE_CHECK | SDP_SEARCH_NO_FORMAT_CHECK)

typedef struct _BTH_SDP_ATTRIBUTE_SEARCH_REQUEST {
    //
    // Handle returned by the connect request or HANDLE_SDP_LOCAL
    //
    HANDLE_SDP hConnection;

    //
    // Combo of SDP_SEARCH_Xxx flags
    //
    ULONG searchFlags;

    //
    // Record handle returned by the remote SDP server, most likely from a
    // previous BTH_SDP_SERVICE_SEARCH_RESPONSE.
    //
    ULONG recordHandle;

    //
    // Array of attributes to query for.  Each SdpAttributeRange entry can
    // specify either a single attribute or a range.  To specify a single
    // attribute, minAttribute should be equal to maxAttribute.   The array must
    // be in sorted order, starting with the smallest attribute.  Furthermore,
    // if a range is specified, the minAttribute must be <= maxAttribute.
    //
    SdpAttributeRange range[1];

} BTH_SDP_ATTRIBUTE_SEARCH_REQUEST, *PBTH_SDP_ATTRIBUTE_SEARCH_REQUEST;

typedef struct _BTH_SDP_SERVICE_ATTRIBUTE_SEARCH_REQUEST {
    //
    // Handle returned by the connect request or HANDLE_SDP_LOCAL
    //
    HANDLE_SDP hConnection;

    //
    // Combo of SDP_SEARCH_Xxx flags
    //
    ULONG searchFlags;

    //
    // See comments in BTH_SDP_SERVICE_SEARCH_REQUEST
    //
    SdpQueryUuid uuids[MAX_UUIDS_IN_QUERY];

    //
    // See comments in BTH_SDP_ATTRIBUTE_SEARCH_REQUEST
    //
    SdpAttributeRange range[1];

} BTH_SDP_SERVICE_ATTRIBUTE_SEARCH_REQUEST,
  *PBTH_SDP_SERVICE_ATTRIBUTE_SEARCH_REQUEST;

typedef struct _BTH_SDP_STREAM_RESPONSE {
    //
    // The required buffer size (not including the first 2 ULONG_PTRs of this
    // data structure) needed to contain the response.
    //
    // If the buffer passed was large enough to contain the entire response,
    // requiredSize will be equal to responseSize.  Otherwise, the caller should
    // resubmit the request with a buffer size equal to
    // sizeof(BTH_SDP_STREAM_RESPONSE) + requiredSize - 1.  (The -1 is because
    // the size of this data structure already includes one byte of the
    // response.)
    //
    // A response cannot exceed 4GB in size.
    //
    ULONG requiredSize;

    //
    // The number of bytes copied into the response array of this data
    // structure.  If there is not enough room for the entire response, the
    // response will be partially copied into the response array.
    //
    ULONG responseSize;

    //
    // The raw SDP response from the serach.
    //
    UCHAR response[1];

} BTH_SDP_STREAM_RESPONSE, *PBTH_SDP_STREAM_RESPONSE;

//
// defines for IOCTL_BTH_UPDATE_SETTINGS
//
//                                                  (0x00000001)
#define UPDATE_SETTINGS_PAGE_TIMEOUT                (0x00000002)
#define UPDATE_SETTINGS_LOCAL_NAME                  (0x00000004)
#define UPDATE_SETTINGS_SECURITY_LEVEL              (0x00000008)
#define UPDATE_SETTINGS_CHANGE_LINK_KEY_ALWAYS      (0x00000010)
//                                                  (0x00000020)
//                                                  (0x00000040)
#define UPDATE_SETTINGS_PAGE_SCAN_ACTIVITY          (0x00000080)
#define UPDATE_SETTINGS_INQUIRY_SCAN_ACTIVITY       (0x00000100)

#define UPDATE_SETTINGS_MAX         (UPDATE_SETTINGS_INQUIRY_SCAN_ACTIVITY)

//
// Set all the bits by shifting over 1 and then subtracting one
// (ie, 0x1000 - 1 == 0x0FFF)
//
#define UPDATE_SETTINGS_ALL         (((UPDATE_SETTINGS_MAX) << 1)-1)

#define BTH_SET_ROLE_MASTER         (0x00)
#define BTH_SET_ROLE_SLAVE          (0x01)

typedef struct _BTH_SET_CONNECTION_ROLE {
    //
    // The remote radio address whose role to query
    //
    BTH_ADDR address;

    //
    // BTH_SET_ROLE_Xxx value
    UCHAR role;
} BTH_SET_CONNECTION_ROLE, *PBTH_SET_CONNECTION_ROLE;

//
// Data structures required for debug WMI logging
//
typedef enum _HCI_PACKET_INFO_TYPE {
   INFO_TYPE_ACL_DATA = 0,
   INFO_TYPE_SCO_DATA,
   INFO_TYPE_EVENT_DATA,
   INFO_TYPE_CMND_DATA
} HCI_PACKET_INFO_TYPE;


typedef struct _HCI_PACKET_INFO {
    ULONG BufferLen;
    HCI_PACKET_INFO_TYPE Type;
    LARGE_INTEGER Time;
    UINT32 NumPacket;
    UCHAR Buffer[1];
} HCI_PACKET_INFO, *PHCI_PACKET_INFO;

//
// Private strings
//
#define STR_PARAMETERS_KEYA             "System\\CurrentControlSet\\" \
                                        "Services\\BTHPORT\\Parameters"
#define STR_PARAMETERS_KEYW             L"System\\CurrentControlSet\\" \
                                        L"Services\\BTHPORT\\Parameters"

#define STR_SYM_LINK_NAMEA              "SymbolicLinkName"
#define STR_SYM_LINK_NAMEW              L"SymbolicLinkName"

#define STR_SERVICESA                   "Services"
#define STR_SERVICESW                   L"Services"

#define STR_DEVICESA                    "Devices"
#define STR_DEVICESW                    L"Devices"

#define STR_PERSONAL_DEVICESA           "PerDevices"
#define STR_PERSONAL_DEVICESW           L"PerDevices"

#define STR_LOCAL_SERVICESA             "LocalServices"
#define STR_LOCAL_SERVICESW             L"LocalServices"

#define STR_DEVICE_SERVICESA            "DeviceServices"
#define STR_DEVICE_SERVICESW            L"DeviceServices"

#define STR_CACHED_SERVICESA            "CachedServices"
#define STR_CACHED_SERVICESW            L"CachedServices"

#define STR_NOTIFICATIONSA              "Notifications"
#define STR_NOTIFICATIONSW              L"Notifications"

#define STR_ICONA                       "Icon"
#define STR_ICONW                       L"Icon"

// BINARY

#define STR_NAMEA                       "Name"
#define STR_NAMEW                       L"Name"

#define STR_LOCAL_NAMEA                 "Local Name"
#define STR_LOCAL_NAMEW                 L"Local Name"

#define STR_FRIENDLY_NAMEA              "Friendly Name"
#define STR_FRIENDLY_NAMEW              L"Friendly Name"

#define STR_CODA                        "COD"
#define STR_CODW                        L"COD"

#define STR_COD_TYPEA                   "COD Type"
#define STR_COD_TYPEW                   L"COD Type"

#define STR_DEVICENAMEA                 "Device Name"
#define STR_DEVICENAMEW                 L"Device Name"

// DWORD
#define STR_AUTHORIZE_OVERRIDEA         "AuthorizeOverrideFlags"
#define STR_AUTHORIZE_OVERRIDEW         L"AuthorizeOverrideFlags"

// DWORD
#define STR_SECURITY_FLAGSA             "SecurityFlags"
#define STR_SECURITY_FLAGSW             L"SecurityFlags"

// DWORD
#define STR_SECURITY_FLAGS_OVERRIDEA     "SecurityFlagsOverride"
#define STR_SECURITY_FLAGS_OVERRIDEW     L"SecurityFlagsOverride"

// DWORD
#define STR_DEFAULT_SECURITYA           "SecurityFlagsDefault"
#define STR_DEFAULT_SECURITYW           L"SecurityFlagsDefault"

// DWORD
#define STR_SECURITY_LEVELA             "SecurityLevel"
#define STR_SECURITY_LEVELW             L"SecurityLevel"

// BINARY (array of GUIDs)
#define STR_PROTOCOLSA                  "Protocols"
#define STR_PROTOCOLSW                  L"Protocols"

#define STR_VIDA                         "VID"
#define STR_VIDW                         L"VID"

#define STR_PIDA                         "PID"
#define STR_PIDW                         L"PID"

#define STR_VIDTYPEA                    "VIDType"
#define STR_VIDTYPEW                    L"VIDType"

#define STR_VERA                         "VER"
#define STR_VERW                         L"VER"

#define STR_ENABLEDA                    "Enabled"
#define STR_ENABLEDW                    L"Enabled"

// DWORD
#define STR_INQUIRY_PERIODA             "Inquiry Length"
#define STR_INQUIRY_PERIODW             L"Inquiry Length"

#define STR_AUTHENTICATEDA              "Authenticated"
#define STR_AUTHENTICATEDW              L"Authenticated"

#define STR_AUTHORIZEDA                 "Authorized"
#define STR_AUTHORIZEDW                 L"Authorized"

#define STR_PARAMETERSA                 "Parameters"
#define STR_PARAMETERSW                 L"Parameters"

// DWORD
#define STR_CMD_ALLOWANCE_OVERRIDEA     "Cmd Allowance Override"
#define STR_CMD_ALLOWANCE_OVERRIDEW     L"Cmd Allowance Override"

// BUGBUG:  remove this for final release
// DWORD
#define STR_CHANGE_LINK_KEY_ALWAYSA     "Change Link Key Always"
#define STR_CHANGE_LINK_KEY_ALWAYSW     L"Change Link Key Always"

#define STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTSA "MaxUnknownAddrConnectRequests"
#define STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTSW L"MaxUnknownAddrConnectRequests"


//DWORD
#define STR_PAGE_TIMEOUTA               "Page Timeout"
#define STR_PAGE_TIMEOUTW               L"Page Timeout"

//DWORD
#define STR_SCAN_ENABLEA                "Write Scan Enable"
#define STR_SCAN_ENABLEW                L"Write Scan Enable"

//DWORD
#define STR_PAGE_SCAN_INTERVALA         "Page Scan Interval"
#define STR_PAGE_SCAN_INTERVALW         L"Page Scan Interval"

//DWORD
#define STR_PAGE_SCAN_WINDOWA           "Page Scan Window"
#define STR_PAGE_SCAN_WINDOWW           L"Page Scan Window"

//DWORD
#define STR_INQUIRY_SCAN_INTERVALA     "Inquiry Scan Interval"
#define STR_INQUIRY_SCAN_INTERVALW     L"Inquiry Scan Interval"

//DWORD
#define STR_INQUIRY_SCAN_WINDOWA       "Inquiry Scan Window"
#define STR_INQUIRY_SCAN_WINDOWW       L"Inquiry Scan Window"

//MULTISZ
#define STR_UNSUPPORTED_HCI_CMDSA       "Unsupported HCI commands"
#define STR_UNSUPPORTED_HCI_CMDSW       L"Unsupported HCI commands"

//DWORD
#define STR_SUPPORTED_HCI_PKTSA         "Supported HCI Packet Types"
#define STR_SUPPORTED_HCI_PKTSW         L"Supported HCI Packet Types"

//DWORD
#define STR_POLL_TIMERA                 "Poll Timer Sec"
#define STR_POLL_TIMERW                 L"Poll Timer Sec"

//DWORD
#define STR_SELECTIVE_SUSPEND_ENABLEDW  L"SelectiveSuspendEnabled"
#define STR_SELECTIVE_SUSPEND_ENABLEDA  "SelectiveSuspendEnabled"



#if defined(UNICODE) || defined(BTH_KERN)
#define STR_PARAMETERS_KEY              STR_PARAMETERS_KEYW
#define STR_SYM_LINK_NAME               STR_SYM_LINK_NAMEW
#define STR_SERVICES                    STR_SERVICESW
#define STR_PROTOCOLS                   STR_PROTOCOLSW
#define STR_VIDTYPE                     STR_VIDTYPEW
#define STR_VID                         STR_VIDW
#define STR_PID                         STR_PIDW
#define STR_VER                         STR_VERW
#define STR_DEVICES                     STR_DEVICESW
#define STR_PERSONAL_DEVICES            STR_PERSONAL_DEVICESW
#define STR_NOTIFICATIONS               STR_NOTIFICATIONSW
#define STR_LOCAL_SERVICES              STR_LOCAL_SERVICESW
#define STR_DEVICE_SERVICES             STR_DEVICE_SERVICESW
#define STR_CACHED_SERVICES             STR_CACHED_SERVICESW
#define STR_PROTOCOLS                   STR_PROTOCOLSW
#define STR_ENABLED                     STR_ENABLEDW
#define STR_ICON                        STR_ICONW
#define STR_NAME                        STR_NAMEW
#define STR_LOCAL_NAME                  STR_LOCAL_NAMEW
#define STR_DEVICENAME                  STR_DEVICENAMEW
#define STR_FRIENDLY_NAME               STR_FRIENDLY_NAMEW
#define STR_COD                         STR_CODW
#define STR_COD_TYPE                    STR_COD_TYPEW
#define STR_AUTHORIZE_OVERRIDE          STR_AUTHORIZE_OVERRIDEW
#define STR_SECURITY_FLAGS              STR_SECURITY_FLAGSW
#define STR_SECURITY_FLAGS_OVERRIDE     STR_SECURITY_FLAGS_OVERRIDEW
#define STR_SECURITY_OVERRIDE           STR_SECURITY_FLAGS_OVERRIDEW
#define STR_DEFAULT_SECURITY            STR_DEFAULT_SECURITYW
#define STR_SECUIRTY_LEVEL              STR_SECURITY_LEVELW
#define STR_INQUIRY_PERIOD              STR_INQUIRY_PERIODW
#define STR_PAGE_SCANINTERVAL           STR_PAGE_SCANINTERVALW
#define STR_PAGE_SCANWINDOW             STR_PAGE_SCANWINDOWW
#define STR_UNSUPPORTED_HCI_CMDS        STR_UNSUPPORTED_HCI_CMDSW
#define STR_SUPPORTED_HCI_PKTS          STR_SUPPORTED_HCI_PKTSW

#define STR_AUTHORIZED                  STR_AUTHORIZEDW
#define STR_AUTHENTICATED               STR_AUTHENTICATEDW

#define STR_PARAMETERS                  STR_PARAMETERSW

#define STR_CHANGE_LINK_KEY_ALWAYS      STR_CHANGE_LINK_KEY_ALWAYSW
#define STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTS \
                                        STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTSW
#define STR_CMD_ALLOWANCE_OVERRIDE      STR_CMD_ALLOWANCE_OVERRIDEW
#define STR_PAGE_TIMEOUT                STR_PAGE_TIMEOUTW
#define STR_SCAN_ENABLE                 STR_SCAN_ENABLEW

#define STR_POLL_TIMER                  STR_POLL_TIMERW

#define STR_SELECTIVE_SUSPEND_ENABLED   STR_SELECTIVE_SUSPEND_ENABLEDW

#else // UNICODE

#define STR_PARAMETERS_KEY              STR_PARAMETERS_KEYA
#define STR_SYM_LINK_NAME               STR_SYM_LINK_NAMEA
#define STR_SERVICES                    STR_SERVICESA
#define STR_PROTOCOLS                   STR_PROTOCOLSA
#define STR_VIDTYPE                     STR_VIDTYPEA
#define STR_VID                         STR_VIDA
#define STR_PID                         STR_PIDA
#define STR_VER                         STR_VERA
#define STR_DEVICES                     STR_DEVICESA
#define STR_PERSONAL_DEVICES            STR_PERSONAL_DEVICESA
#define STR_NOTIFICATIONS               STR_NOTIFICATIONSA
#define STR_LOCAL_SERVICES              STR_LOCAL_SERVICESA
#define STR_DEVICE_SERVICES             STR_DEVICE_SERVICESA
#define STR_CACHED_SERVICES             STR_CACHED_SERVICESA
#define STR_PROTOCOLS                   STR_PROTOCOLSA
#define STR_ENABLED                     STR_ENABLEDA
#define STR_ICON                        STR_ICONA
#define STR_NAME                        STR_NAMEA
#define STR_LOCAL_NAME                  STR_LOCAL_NAMEA
#define STR_DEVICENAME                  STR_DEVICENAMEA
#define STR_FRIENDLY_NAME               STR_FRIENDLY_NAMEA
#define STR_COD                         STR_CODA
#define STR_COD_TYPE                    STR_COD_TYPEA
#define STR_AUTHORIZE_OVERRIDE          STR_AUTHORIZE_OVERRIDEA
#define STR_SECURITY_FLAGS              STR_SECURITY_FLAGSA
#define STR_SECURITY_OVERRIDE           STR_SECURITY_FLAGS_OVERRIDEA
#define STR_DEFAULT_SECURITY            STR_DEFAULT_SECURITYA
#define STR_SECUIRTY_LEVEL              STR_SECURITY_LEVELA
#define STR_INQUIRY_PERIOD              STR_INQUIRY_PERIODA
#define STR_CHANGE_LINK_KEY_ALWAYS      STR_CHANGE_LINK_KEY_ALWAYSA
#define STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTS \
                                        STR_MAX_UNKNOWN_ADDR_CONNECT_REQUESTSA
#define STR_CMD_ALLOWANCE_OVERRIDE      STR_CMD_ALLOWANCE_OVERRIDEA
#define STR_PAGE_TIMEOUT                STR_PAGE_TIMEOUTA
#define STR_SCAN_ENABLE                 STR_SCAN_ENABLEA
#define STR_PAGE_SCANINTERVAL           STR_PAGE_SCANINTERVALA
#define STR_PAGE_SCANWINDOW             STR_PAGE_SCANWINDOWA
#define STR_UNSUPPORTED_HCI_CMDS        STR_UNSUPPORTED_HCI_CMDSA
#define STR_SUPPORTED_HCI_PKTS          STR_SUPPORTED_HCI_PKTSA

#define STR_AUTHORIZED                  STR_AUTHORIZEDA
#define STR_AUTHENTICATED               STR_AUTHENTICATEDA

#define STR_PARAMETERS                  STR_PARAMETERSA

#define STR_POLL_TIMER                  STR_POLL_TIMERA

#define STR_SELECTIVE_SUSPEND_ENABLED   STR_SELECTIVE_SUSPEND_ENABLEDA

#endif // UNICODE

#include <POPPACK.H>

#endif // __BTHPRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\bthserv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for bthserv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __bthserv_h__
#define __bthserv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __BthServRPCService_INTERFACE_DEFINED__
#define __BthServRPCService_INTERFACE_DEFINED__

/* interface BthServRPCService */
/* [strict_context_handle][explicit_handle][unique][version][uuid] */ 

typedef ULONGLONG BTH_ADDR;

#if !defined( BLUETOOTH_ADDRESS )
typedef BTH_ADDR BLUETOOTH_ADDRESS;

#endif
typedef ULONG BTH_COD;

typedef struct _BTHSERV_DEVICE_INFO
    {
    ULONG flags;
    BTH_ADDR address;
    BTH_COD classOfDevice;
    CHAR name[ 248 ];
    SYSTEMTIME lastSeen;
    SYSTEMTIME lastUsed;
    } 	BTHSERV_DEVICE_INFO;

typedef struct _BTHSERV_DEVICE_INFO *PBTHSERV_DEVICE_INFO;

#if !defined( BLUETOOTH_DEVICE_INFO )
typedef struct _BLUETOOTH_DEVICE_INFO
    {
    DWORD dwSize;
    BLUETOOTH_ADDRESS Address;
    ULONG ulClassofDevice;
    BOOL fConnected;
    BOOL fRemembered;
    BOOL fAuthenticated;
    SYSTEMTIME stLastSeen;
    SYSTEMTIME stLastUsed;
    WCHAR szName[ 248 ];
    } 	BLUETOOTH_DEVICE_INFO;

#endif
typedef BLUETOOTH_DEVICE_INFO *PBLUETOOTH_DEVICE_INFO;

typedef struct _BTHSERV_DEVICE_INFO_LIST
    {
    ULONG numOfDevices;
    BTHSERV_DEVICE_INFO deviceList[ 1 ];
    } 	BTHSERV_DEVICE_INFO_LIST;

typedef struct _BTHSERV_DEVICE_INFO_LIST *PBTHSERV_DEVICE_INFO_LIST;

typedef struct _AttributeRange
    {
    USHORT minAttribute;
    USHORT maxAttribute;
    } 	AttributeRange;

typedef struct _RPC_CLIENT_ID
    {
    ULONG UniqueProcess;
    ULONG UniqueThread;
    } 	RPC_CLIENT_ID;

typedef struct _RPC_CLIENT_ID *PRPC_CLIENT_ID;

typedef struct _RPC_PIN_INFO
    {
    BTH_ADDR BthAddr;
    DWORD_PTR PinCookie;
    } 	RPC_PIN_INFO;

typedef struct _RPC_PIN_INFO *PRPC_PIN_INFO;

typedef /* [public][public] */ 
enum __MIDL_BthServRPCService_0001
    {	L2CapSdpRecord	= 0,
	PnPSdpRecord	= L2CapSdpRecord + 1
    } 	BTHSERV_SDP_TYPE;

typedef enum __MIDL_BthServRPCService_0001 *PBTHSERV_SDP_TYPE;

typedef /* [public][public][public] */ 
enum __MIDL_BthServRPCService_0002
    {	FromCache	= 0,
	FromDevice	= FromCache + 1,
	FromCacheOrDevice	= FromDevice + 1
    } 	BTHSERV_QUERY_TYPE;

typedef enum __MIDL_BthServRPCService_0002 *PBTHSERV_QUERY_TYPE;

typedef /* [context_handle] */ void *PCONTEXT_HANDLE_TYPE;

typedef /* [ref] */ PCONTEXT_HANDLE_TYPE *PPCONTEXT_HANDLE_TYPE;

/* [fault_status][comm_status] */ error_status_t BthServOpen( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ PPCONTEXT_HANDLE_TYPE PPHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ RPC_CLIENT_ID ClientId);

/* [fault_status][comm_status] */ error_status_t BthServClose( 
    /* [out][in] */ PPCONTEXT_HANDLE_TYPE PPHContext,
    /* [out] */ HRESULT *PResult);

/* [fault_status][comm_status] */ error_status_t BthServRegisterPinEvent( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [in] */ DWORD_PTR EventHandle);

/* [fault_status][comm_status] */ error_status_t BthServDeregisterPinEvent( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr);

error_status_t BthServGetPinAddrs( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [out][in] */ DWORD *PPinAddrSize,
    /* [size_is][out][in] */ BTH_ADDR PPinAddrs[  ],
    /* [out] */ DWORD *PPinAddrCount);

/* [fault_status][comm_status] */ error_status_t BthServGetDeviceInfo( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTHSERV_QUERY_TYPE QueryType,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [out][in] */ BLUETOOTH_DEVICE_INFO *PDevInfo);

/* [fault_status][comm_status] */ error_status_t BthServSetDeviceName( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [in] */ WCHAR DevName[ 248 ]);

/* [fault_status][comm_status] */ error_status_t BthServGetDeviceList( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BOOL DoInquiry,
    /* [in] */ UCHAR TimeoutMultiplier,
    /* [in] */ DWORD cbSize,
    /* [size_is][out] */ UCHAR PDevInfo[  ],
    /* [out] */ DWORD *PBytesTransferred);

/* [fault_status][comm_status] */ error_status_t BthServActivateService( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [in] */ DWORD BufferSize,
    /* [size_is][in] */ UCHAR PBuffer[  ]);

/* [fault_status][comm_status] */ error_status_t BthServUpdateService( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ DWORD BufferSize,
    /* [size_is][in] */ UCHAR PDevUpdate[  ]);

/* [fault_status][comm_status] */ error_status_t BthServGetSdpRecord( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [in] */ BTHSERV_SDP_TYPE Type,
    /* [in] */ BTHSERV_QUERY_TYPE QueryType,
    /* [in] */ DWORD BufferSize,
    /* [size_is][out] */ UCHAR PBuffer[  ],
    /* [out] */ DWORD *PBytesTransferred);

/* [fault_status][comm_status] */ error_status_t BthServSetSdpRecord( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ DWORD BufferSize,
    /* [size_is][in] */ UCHAR PBuffer[  ],
    /* [out] */ DWORD_PTR *PCookie);

/* [fault_status][comm_status] */ error_status_t BthServSetSdpRecordWithInfo( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ ULONG FSecurity,
    /* [in] */ ULONG FOptions,
    /* [in] */ ULONG FCodService,
    /* [in] */ ULONG RecordLength,
    /* [size_is][in] */ UCHAR PRecord[  ],
    /* [out] */ DWORD_PTR *PCookie);

/* [fault_status][comm_status] */ error_status_t BthServRemoveSdpRecord( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ DWORD_PTR Cookie);

/* [fault_status][comm_status] */ error_status_t BthServTestRegisterPinEvent( 
    /* [in] */ PCONTEXT_HANDLE_TYPE PHContext,
    /* [out] */ HRESULT *PResult,
    /* [in] */ BTH_ADDR *PRemoteAddr,
    /* [in] */ DWORD_PTR Cookie);



extern RPC_IF_HANDLE BthServRPCService_v1_0_c_ifspec;
extern RPC_IF_HANDLE BthServRPCService_v1_0_s_ifspec;
#endif /* __BthServRPCService_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

void __RPC_USER PCONTEXT_HANDLE_TYPE_rundown( PCONTEXT_HANDLE_TYPE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\bthservi.h ===
#if !defined(BTHSERVI_H)
#define BTHSERVI_H

#define BTHSERV_PROT_SEQ   TEXT("ncalrpc")
#define BTHSERV_ENDPOINT   TEXT("BthServEp")

#define BTHSERV_ALL_ADDRS  BTH_ADDR_NULL

#define SERVICE_OPTION_DO_NOT_PUBLISH       (0x00000002)
#define SERVICE_OPTION_NO_PUBLIC_BROWSE     (0x00000004)

#define SERVICE_OPTION_VALID_MASK           (SERVICE_OPTION_NO_PUBLIC_BROWSE | \
                                             SERVICE_OPTION_DO_NOT_PUBLISH)
#endif // !defined(BTHSERVI_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\bthioctl.h ===
/****************************************************************************

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bthioctl.h

Abstract:

    defines the IOCTL codes for the kernel/user calls

Environment:

    Kernel & user mode

Revision History:

    4-4-00 : created by Husni Roukbi

****************************************************************************/
#ifndef __BTHIOCTL_H__
#define __BTHIOCTL_H__

#ifndef CTL_CODE
    #pragma message("CTL_CODE undefined. Include winioctl.h or wdm.h")
#endif

// IOCTL defines
//
#define BTH_IOCTL_BASE  1000
#define FILE_DEVICE_BLUETOOTH FILE_DEVICE_UNKNOWN

#define BTH_CTL(id)  CTL_CODE(FILE_DEVICE_BLUETOOTH,  \
                              (id), \
                              METHOD_BUFFERED,  \
                              FILE_ANY_ACCESS)

#define BTH_KERNEL_CTL(id)  CTL_CODE(FILE_DEVICE_BLUETOOTH,  \
                                     (id), \
                                     METHOD_NEITHER,  \
                                     FILE_ANY_ACCESS)

//
// kernel-level IOCTLs
//
#define IOCTL_INTERNAL_BTH_SUBMIT_BRB       BTH_KERNEL_CTL(BTH_IOCTL_BASE+0)

//
// Input:  none
// Output:  BTH_ENUMERATOR_INFO
//
#define IOCTL_INTERNAL_BTHENUM_GET_ENUMINFO BTH_KERNEL_CTL(BTH_IOCTL_BASE+1)

//
// Input:  none
// Output:  BTH_DEVICE_INFO
//
#define IOCTL_INTERNAL_BTHENUM_GET_DEVINFO  BTH_KERNEL_CTL(BTH_IOCTL_BASE+2)

//
// user-level IOCTLs
//

//
// use this ioctl to get a list of cached discovered devices in the port driver.
//
#define IOCTL_BTH_GET_DEVICE_INFO   BTH_CTL(BTH_IOCTL_BASE+1)

//
// use this ioctl to start a new device discovery.
//
#define IOCTL_BTH_INQUIRY_DEVICE    BTH_CTL(BTH_IOCTL_BASE+2)

//
// Input:  HANDLE_SDP
// Output:  SDP_ERROR
//
#define IOCTL_BTH_SDP_GET_LAST_ERROR  \
                                    BTH_CTL(BTH_IOCTL_BASE+3)

//
// Input:  BTH_SDP_CONNECT
// Output:  BTH_SDP_CONNECT
//
//
#define IOCTL_BTH_SDP_CONNECT       BTH_CTL(BTH_IOCTL_BASE+4)

//
// Input:  HANDLE_SDP
// Output:  none
//
#define IOCTL_BTH_SDP_DISCONNECT    BTH_CTL(BTH_IOCTL_BASE+5)

//
// Input:  BTH_SDP_SERVICE_SEARCH_REQUEST
// Output:  ULONG * number of handles wanted
//
#define IOCTL_BTH_SDP_SERVICE_SEARCH  \
                                    BTH_CTL(BTH_IOCTL_BASE+6)

//
// Input:  BTH_SDP_ATTRIBUTE_SEARCH_REQUEST
// Output:  BTH_SDP_STREAM_RESPONSE or bigger
//
#define IOCTL_BTH_SDP_ATTRIBUTE_SEARCH \
                                    BTH_CTL(BTH_IOCTL_BASE+7)

//
// Input:  BTH_SDP_SERVICE_ATTRIBUTE_SEARCH_REQUEST
// Output:  BTH_SDP_STREAM_RESPONSE or bigger
//
#define IOCTL_BTH_SDP_SERVICE_ATTRIBUTE_SEARCH \
                                    BTH_CTL(BTH_IOCTL_BASE+8)

//
// Input:  raw SDP stream (at least 2 bytes)
// Ouptut: HANDLE_SDP
//
#define IOCTL_BTH_SDP_SUBMIT_RECORD BTH_CTL(BTH_IOCTL_BASE+9)

//                                  BTH_CTL(BTH_IOCTL_BASE+10)

//
// Input:  HANDLE_SDP
// Output:  none
//
#define IOCTL_BTH_SDP_REMOVE_RECORD BTH_CTL(BTH_IOCTL_BASE+11)

//
// Input:  BTH_AUTHENTICATE_RESPONSE
// Output:  BTHSTATUS
//
#define IOCTL_BTH_PIN_RESPONSE      BTH_CTL(BTH_IOCTL_BASE+12)

//
// Input:  ULONG
// Output:  none
//
#define IOCTL_BTH_UPDATE_SETTINGS   BTH_CTL(BTH_IOCTL_BASE+13)

//
// Input:  none
// Output:  BTH_LOCAL_RADIO_INFO
//
#define IOCTL_BTH_GET_LOCAL_INFO    BTH_CTL(BTH_IOCTL_BASE+14)

//
// Input:  BTH_ADDR
// Output:  none
//
#define IOCTL_BTH_DISCONNECT_DEVICE BTH_CTL(BTH_IOCTL_BASE+15)

//                                  BTH_CTL(BTH_IOCTL_BASE+16)

//
// Input:  BTH_ADDR
// Output:  BTH_RADIO_INFO
//
#define IOCTL_BTH_GET_RADIO_INFO    BTH_CTL(BTH_IOCTL_BASE+17)

//
// Input:  BTH_AUTHENTICATE_DEVICE
// Output:  BTHSTATUS
//
#define IOCTL_BTH_PAIR_DEVICE       BTH_CTL(BTH_IOCTL_BASE+18)

//
// Input:  BTH_ADDR
// Ouptut:  none
//
#define IOCTL_BTH_UNPAIR_DEVICE     BTH_CTL(BTH_IOCTL_BASE+19)

//
// Input:  1 or 2 ULONGs
// Ouptut:  1 or 2 ULONGs
//
#define IOCTL_BTH_DEBUG_LEVEL       BTH_CTL(BTH_IOCTL_BASE+20)

//
// Input:  BTH_SDP_RECORD + raw SDP record
// Output:  HANDLE_SDP
//
#define IOCTL_BTH_SDP_SUBMIT_RECORD_WITH_INFO BTH_CTL(BTH_IOCTL_BASE+21)

//
// Input:  UCHAR
// Output:  none
//
#define IOCTL_BTH_SCAN_ENABLE       BTH_CTL(BTH_IOCTL_BASE+22)

//
// Input:  none
// Output:  BTH_PERF_STATS
//
#define IOCTL_BTH_GET_PERF          BTH_CTL(BTH_IOCTL_BASE+23)

//
// Input:  none
// Output:  none
//
#define IOCTL_BTH_RESET_PERF        BTH_CTL(BTH_IOCTL_BASE+24)

//
// Input:  BTH_DEVICE_UPDATE
// Output:
//
#define IOCTL_BTH_UPDATE_DEVICE     BTH_CTL(BTH_IOCTL_BASE+25)

//
// Input:   BTH_ADDR
// Output:  BTH_DEVICE_PROTOCOLS_LIST + n * GUID
//
#define IOCTL_BTH_GET_DEVICE_PROTOCOLS \
                                    BTH_CTL(BTH_IOCTL_BASE+26)

//                                  BTH_CTL(BTH_IOCTL_BASE+27)

//
// Input:   BTH_ADDR
// Output:  none
//
#define IOCTL_BTH_PERSONALIZE_DEVICE \
                                    BTH_CTL(BTH_IOCTL_BASE+28)

//
// UPF ONLY
// Input:   BTH_ADDR
// Output:  UCHAR
//
#define IOCTL_BTH_GET_CONNECTION_ROLE \
                                    BTH_CTL(BTH_IOCTL_BASE+29)

//
// UPF ONLY
// Input:   BTH_SET_CONNECTION_ROLE
// Output:  none
//
#define IOCTL_BTH_SET_CONNECTION_ROLE \
                                    BTH_CTL(BTH_IOCTL_BASE+30)

#endif // __BTHIOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\dx9xver.h ===
/*++
Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dx9xver.h

Abstract:

 This file define the version of binaries for DX win9x redistribution.
 It is intended to be included after ntverp.h to modify the file version.

 We define the version that's grater than millen OS version for ks ring0
 and ring3 components. dba might want to use this version too.


Author:


--*/
#undef VER_PRODUCTMAJORVERSION
#undef VER_PRODUCTMINORVERSION
#undef VER_PRODUCTBUILD

//
// make this greater than millennium release 2525 ?
//
#define VER_PRODUCTMAJORVERSION 4
#define VER_PRODUCTMINORVERSION 90
#define VER_PRODUCTBUILD 2526

//
// make the version
//
#undef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE


//
// product name
//

#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR "Microsoft(R) Windows(R) Operating System"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\jetwriter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ijetwriter.h

Abstract:

    Definition of CVssIJetWriter class

	Brian Berkowitz  [brianb]  3/17/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/17/2000  Created
    mikejohn    04/03/2000  Added extra methods for OnIdentify()
    mikejohn    05/10/2000  Updated VS_FLUSH_TYPE to VSS_FLUSH_TYPE
    mikejohn	09/20/2000  176860: Added calling convention methods where missing

--*/

class CVssJetWriter;
class CVssIJetWriter;

class IVssCreateWriterMetadata;
class IVssWriterComponents;

typedef CVssJetWriter *PVSSJETWRITER;

// actual writer class
class CVssJetWriter
	{
	// Constructors and destructors
public:
	__declspec(dllexport)
	STDMETHODCALLTYPE CVssJetWriter() :
		m_pWriter(NULL)
		{
		}

	__declspec(dllexport)
	virtual STDMETHODCALLTYPE ~CVssJetWriter();

	__declspec(dllexport)
	HRESULT STDMETHODCALLTYPE Initialize(IN GUID idWriter,
					     IN LPCWSTR wszWriterName,
					     IN bool bSystemService,
					     IN bool bBootableSystemState,
					     IN LPCWSTR wszFilesToInclude,
					     IN LPCWSTR wszFilesToExclude);

	__declspec(dllexport)
	void STDMETHODCALLTYPE Uninitialize();


	// callback for identify event
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// called at Prepare to backup
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareBackupBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareBackupEnd(IN IVssWriterComponents *pIVssWriterComponents,
							  IN bool fJetPrepareSucceeded);


	// called at Prepare for snasphot
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshotBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshotEnd(IN bool fJetPrepareSucceeded);

	// called at freeze
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnFreezeBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnFreezeEnd(IN bool fJetFreezeSucceeded);

	// called at thaw
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnThawBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnThawEnd(IN bool fJetThawSucceeded);

	// called at OnPostSnapshot
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pIVssWriterComponents);

	// called when abort occurs
	__declspec(dllexport)
	virtual void STDMETHODCALLTYPE OnAbortBegin();

	__declspec(dllexport)
	virtual void STDMETHODCALLTYPE OnAbortEnd();

	// callback on backup complete event
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnBackupCompleteBegin(IN IVssWriterComponents *pComponent);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							   IN bool fJetBackupCompleteSucceeded);

	// called when restore begins
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPreRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPreRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						    IN bool fJetRestoreSucceeded);


	// called when restore begins
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						    IN bool fJetRestoreSucceeded);



private:
	// internal writer object
	VOID *m_pWriter;

	// result of initialization
	HRESULT m_hrInitialized;

	// internal thread func function
	static DWORD InitializeThreadFunc(void *pv);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\ksdrmhlp.h ===
#ifndef _KS_DRM_HELP_H_
#define _KS_DRM_HELP_H_

#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>

typedef
NTSTATUS
(*PFNKSHANDLERDRMSETCONTENTID)(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
);

NTSTATUS KsPropertyHandleDrmSetContentId(
    IN PIRP Irp,
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\hbaapi.h ===
//***************************************************************************
//
//  hbaapi.h
// 
//  Module: Windows HBA API implmentation
//
//      This header is consistent with HBA_API_Rev_2-14_2001NOV13.doc
//      version of the HBAAPI 2.0 spec.
//
//  Purpose: Contains HBA api header
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#ifndef HBAAPI_H
#define HBAAPI_H

#include <time.h>

#ifdef _HBAAPIP_
#define HBA_API __cdecl
#else
#define HBA_API DECLSPEC_IMPORT __cdecl
#endif

#define HBA_VERSION 2

typedef ULONGLONG HBA_UINT64;
typedef LONGLONG  HBA_INT64;
typedef ULONG     HBA_UINT32;
typedef USHORT    HBA_UINT16;
typedef UCHAR     HBA_UINT8;
typedef SCHAR     HBA_INT8;

typedef HBA_UINT32 HBA_HANDLE;

typedef HBA_UINT32 HBA_STATUS;

#define HBA_STATUS_OK                        0
#define HBA_STATUS_ERROR                     1   /* Error */
#define HBA_STATUS_ERROR_NOT_SUPPORTED       2   /* Function not supported.*/
#define HBA_STATUS_ERROR_INVALID_HANDLE      3   /* invalid handle */
#define HBA_STATUS_ERROR_ARG                 4   /* Bad argument */
#define HBA_STATUS_ERROR_ILLEGAL_WWN         5   /* WWN not recognized */
#define HBA_STATUS_ERROR_ILLEGAL_INDEX       6   /* Index not recognized */
#define HBA_STATUS_ERROR_MORE_DATA           7   /* Larger buffer required */
#define HBA_STATUS_ERROR_STALE_DATA 	     8   /* Information has changed since the last call to HBA_RefreshInformation */
#define HBA_STATUS_SCSI_CHECK_CONDITION      9   /* SCSI Check Condition reported*/
#define HBA_STATUS_ERROR_BUSY               10   /* Adapter busy or reserved, retry may be effective*/
#define HBA_STATUS_ERROR_TRY_AGAIN          11   /* Request timed out, retry may be effective */
#define HBA_STATUS_ERROR_UNAVAILABLE        12   /* Referenced HBA has been removed or deactivated */
#define HBA_STATUS_ERROR_ELS_REJECT         13   /* The requested ELS was rejected */
                                                 /* by the local adapter */
#define HBA_STATUS_ERROR_INVALID_LUN        14   /* The specified LUN is not provided */
                                                 /* by the specified adapter */
#define HBA_STATUS_ERROR_INCOMPATIBLE       15   /* An incompatibility has been detected*/
                                                 /* among the library and driver modules invoked */
                                                 /* which will cause one or more functions in the highest version that all support */
                                                 /* to operate incorrectly.  */
                                                 /* The differing function sets of software modules implementing different versions */
                                                 /* of the HBA API specification does not in itself constitute an incompatibility. */
                                                 /* Known interoperability bugs among supposedly compatible versions */
                                                 /*  should be reported as incompatibilities, */
                                                 /* but not all such interoperability bugs may be known. */
                                                 /* This value may be returned by any function which calls a Vendor Specific Library, */
                                                 /* and by HBA_LoadLibrary and HBA_GetAdapterName. */
#define HBA_STATUS_ERROR_AMBIGUOUS_WWN      16   /* Multiple adapters have */
                                                 /* a matching WWN.
                                                  * This could occur if the NodeWWN of multiple adapters is identical. */

#define HBA_STATUS_ERROR_LOCAL_BUS          17   /* A persistent binding request included a bad local SCSI bus number */

#define HBA_STATUS_ERROR_LOCAL_TARGET       18   /* A persistent binding request included a bad local SCSI target number */

#define HBA_STATUS_ERROR_LOCAL_LUN          19   /* A persistent binding request included a bad local SCSI logical unit number */


#define HBA_STATUS_ERROR_LOCAL_SCSIID_BOUND 20   /* A persistent binding set request included */
                                                 /* a local SCSI ID that was already bound */

#define HBA_STATUS_ERROR_TARGET_FCID        21   /* A persistent binding request included a bad or unlocatable FCP Target FCID */

#define HBA_STATUS_ERROR_TARGET_NODE_WWN    22   /* A persistent binding request included a bad FCP Target Node WWN */

#define HBA_STATUS_ERROR_TARGET_PORT_WWN    23   /* A persistent binding request included a bad FCP Target Port WWN */

#define HBA_STATUS_ERROR_TARGET_LUN         24   /* A persistent binding request included */
                                                 /* an FCP Logical Unit Number not defined by the identified Target*/

#define HBA_STATUS_ERROR_TARGET_LUID        25   /* A persistent binding request included */
                                                 /* an undefined or otherwise inaccessible Logical Unit Unique Identifier */

#define HBA_STATUS_ERROR_NO_SUCH_BINDING    26   /* A persistent binding remove request included */
                                                 /* a binding which did not match a binding established by the specified port */

#define HBA_STATUS_ERROR_NOT_A_TARGET       27   /* A SCSI command was requested to an Nx_Port that was not a SCSI Target Port */

#define HBA_STATUS_ERROR_UNSUPPORTED_FC4    28   /* A request was made concerning an unsupported FC-4 protocol */

#define HBA_STATUS_ERROR_INCAPABLE          29   /* A request was made to enable unimplemented capabilities for a port */




typedef	HBA_UINT8  HBA_BOOLEAN;	/* Use this for a single true/false flag */

typedef HBA_UINT32 HBA_PORTTYPE;

#define HBA_PORTTYPE_UNKNOWN    1 /* Unknown */
#define HBA_PORTTYPE_OTHER      2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT 3 /* Not present */
#define HBA_PORTTYPE_NPORT      5 /* Fabric */
#define HBA_PORTTYPE_NLPORT     6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT     7 /* Fabric on a Loop */
#define HBA_PORTTYPE_FPORT      8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT      9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT     10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT     20 /* Private Loop */
#define HBA_PORTTYPE_PTP       21 /* Point to Point */

typedef HBA_UINT32 HBA_PORTSTATE;
#define HBA_PORTSTATE_UNKNOWN     1 /* Unknown */
#define HBA_PORTSTATE_ONLINE      2 /* Operational */
#define HBA_PORTSTATE_OFFLINE     3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED    4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS 5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN    6 /* Link Down */
#define HBA_PORTSTATE_ERROR       7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK    8 /* Loopback */

typedef HBA_UINT32 HBA_PORTSPEED;
#define HBA_PORTSPEED_UNKNOWN        0         /* Unknown - transceiver incapable of reporting */
#define HBA_PORTSPEED_1GBIT          1         /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT          2         /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT         4         /* 10 GBit/sec */
#define HBA_PORTSPEED_4GBIT          8         /* 4 GBit/sec */
#define HBA_PORTSPEED_NOT_NEGOTIATED (1 << 15) /* Speed not established */

typedef HBA_UINT32 HBA_COS;

typedef struct HBA_fc4types {
	HBA_UINT8 bits[32]; /* 32 bytes of FC-4 per GS-2 */
} HBA_FC4TYPES, *PHBA_FC4TYPES;

typedef struct HBA_wwn {
	HBA_UINT8 wwn[8];
} HBA_WWN, *PHBA_WWN;

typedef struct HBA_ipaddress {
	int ipversion; // see enumerations in RNID
	union
	{
		unsigned char ipv4address[4];
		unsigned char ipv6address[16];
	} ipaddress;
} HBA_IPADDRESS, *PHBA_IPADDRESS;

typedef struct HBA_AdapterAttributes {
	char       Manufacturer[64];      /*Emulex */
	char       SerialNumber[64];      /* A12345 */
	char       Model[256];            /* QLA2200 */
	char       ModelDescription[256]; /* Agilent TachLite */
	HBA_WWN    NodeWWN;
	char       NodeSymbolicName[256]; /* From GS-2 */
	char       HardwareVersion[256];  /* Vendor use */
	char       DriverVersion[256];    /* Vendor use */
	char       OptionROMVersion[256]; /* Vendor use - i.e. hardware boot ROM*/
	char       FirmwareVersion[256];  /* Vendor use */
	HBA_UINT32 VendorSpecificID;      /* Vendor specific */
	HBA_UINT32 NumberOfPorts;
	char       DriverName[256];       /* Binary path and/or name of driver file. */
} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;

typedef struct HBA_PortAttributes {
	HBA_WWN       NodeWWN;
	HBA_WWN       PortWWN;
	HBA_UINT32    PortFcId;
	HBA_PORTTYPE  PortType;            /*PTP, Fabric, etc. */
	HBA_PORTSTATE PortState;
	HBA_COS       PortSupportedClassofService;
	HBA_FC4TYPES  PortSupportedFc4Types;
	HBA_FC4TYPES  PortActiveFc4Types;
	char          PortSymbolicName[256];
	char          OSDeviceName[256];   /* \device\ScsiPort3 */
	HBA_PORTSPEED PortSupportedSpeed;
	HBA_PORTSPEED PortSpeed;
	HBA_UINT32    PortMaxFrameSize;
	HBA_WWN       FabricName;
	HBA_UINT32    NumberofDiscoveredPorts;
} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;

typedef struct HBA_PortStatistics {
	HBA_INT64 SecondsSinceLastReset;
	HBA_INT64 TxFrames;
	HBA_INT64 TxWords;
	HBA_INT64 RxFrames;
	HBA_INT64 RxWords;
	HBA_INT64 LIPCount;
	HBA_INT64 NOSCount;
	HBA_INT64 ErrorFrames;
	HBA_INT64 DumpedFrames;
	HBA_INT64 LinkFailureCount;
	HBA_INT64 LossOfSyncCount;
	HBA_INT64 LossOfSignalCount;
	HBA_INT64 PrimitiveSeqProtocolErrCount;
	HBA_INT64 InvalidTxWordCount;
	HBA_INT64 InvalidCRCCount;
} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;

/* HBA_FCPBINDINGTYPE was used in Rev 1.0.  Add TO_OTHER for older calls to 
   indicate other binding types for HBA_GetPersistentBinding.  To support 
   multiple types a new flag has been created to allow for multiple bindings
   supported */

typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN, TO_OTHER } HBA_FCPBINDINGTYPE;


/* A bit mask of Rev 2.0 persistent binding capabilities */

typedef HBA_UINT32 HBA_BIND_CAPABILITY;   

/* The following are bit flags indicating persistent binding capabilities */

#define HBA_CAN_BIND_TO_D_ID     0x0001
#define HBA_CAN_BIND_TO_WWPN     0x0002
#define HBA_CAN_BIND_TO_WWNN     0x0004
#define HBA_CAN_BIND_TO_LUID     0x0008
#define HBA_CAN_BIND_ANY_LUNS    0x0400
#define HBA_CAN_BIND_TARGETS     0x0800
#define HBA_CAN_BIND_AUTOMAP     0x1000
#define HBA_CAN_BIND_CONFIGURED  0x2000

/* A bit mask of Rev 2.0 persistent binding setting types */

typedef HBA_UINT32 HBA_BIND_TYPE;

/* The following are bit flags indicating persistent binding setting types */

#define HBA_BIND_TO_D_ID     0x0001
#define HBA_BIND_TO_WWPN     0x0002
#define HBA_BIND_TO_WWNN     0x0004
#define HBA_BIND_TO_LUID     0x0008
#define HBA_BIND_TARGETS     0x0800

typedef struct HBA_LUID {
	char  buffer[256];
} HBA_LUID, *PHBA_LUID;

typedef struct HBA_ScsiId {
	char       OSDeviceName[256]; /* \device\ScsiPort3 */
	HBA_UINT32 ScsiBusNumber;     /* Bus on the HBA */
	HBA_UINT32 ScsiTargetNumber;  /* SCSI Target ID to OS */
	HBA_UINT32 ScsiOSLun;
} HBA_SCSIID, *PHBA_SCSIID;

typedef struct HBA_FcpId {
	HBA_UINT32 FcId;
	HBA_WWN    NodeWWN;
	HBA_WWN    PortWWN;
	HBA_UINT64 FcpLun;
} HBA_FCPID, *PHBA_FCPID;

typedef struct HBA_FcpScsiEntry {
	HBA_SCSIID ScsiId;
	HBA_FCPID  FcpId;
} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;

typedef struct HBA_FcpScsiEntry2 {
	HBA_SCSIID ScsiId;
	HBA_FCPID  FcpId;
    HBA_LUID   Luid;
} HBA_FCPSCSIENTRY2, *PHBA_FCPSCSIENTRY2;

typedef struct HBA_FCPTargetMapping {
	HBA_UINT32       NumberOfEntries;
	HBA_FCPSCSIENTRY entry[1];  /* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;

typedef struct HBA_FCPTargetMapping2 {
	HBA_UINT32        NumberOfEntries;
	HBA_FCPSCSIENTRY2 entry[1]; /* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING2, *PHBA_FCPTARGETMAPPING2;

typedef struct HBA_FCPBindingEntry {
	HBA_FCPBINDINGTYPE type;
	HBA_SCSIID         ScsiId;
	HBA_FCPID          FcpId;
    HBA_UINT32         FcId;
} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;

typedef struct HBA_FCPBinding {
	HBA_UINT32          NumberOfEntries;
	HBA_FCPBINDINGENTRY entry[1]; /* Variable length array */
} HBA_FCPBINDING, *PHBA_FCPBINDING;

typedef struct HBA_FCPBindingEntry2 {
	HBA_BIND_TYPE  type;
	HBA_SCSIID     ScsiId;
	HBA_FCPID      FcpId;
    HBA_LUID       Luid;
    HBA_STATUS     Status;
} HBA_FCPBINDINGENTRY2, *PHBA_FCPBINDINGENTRY2;

typedef struct HBA_FCPBinding2 {
	HBA_UINT32           NumberOfEntries;
	HBA_FCPBINDINGENTRY2 entry[1]; /* Variable length array */
} HBA_FCPBINDING2, *PHBA_FCPBINDING2;


typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;

typedef struct HBA_MgmtInfo {
	HBA_WWN    wwn;
	HBA_UINT32 unittype;
	HBA_UINT32 PortId;
	HBA_UINT32 NumberOfAttachedNodes;
	HBA_UINT16 IPVersion;
	HBA_UINT16 UDPPort;
	HBA_UINT8  IPAddress[16];
	HBA_UINT16 reserved;
	HBA_UINT16 TopologyDiscoveryFlags;
} HBA_MGMTINFO, *PHBA_MGMTINFO;

#define HBA_EVENT_LIP_OCCURRED       1
#define HBA_EVENT_LINK_UP            2
#define HBA_EVENT_LINK_DOWN          3
#define HBA_EVENT_LIP_RESET_OCCURRED 4
#define HBA_EVENT_RSCN               5
#define HBA_EVENT_PROPRIETARY        0xFFFF

typedef struct HBA_Link_EventInfo {
	HBA_UINT32 PortFcId;   /* Port which this event occurred */
	HBA_UINT32 Reserved[3];
} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;

typedef struct HBA_RSCN_EventInfo {
	HBA_UINT32 PortFcId;  /* Port which this event occurred */
	HBA_UINT32 NPortPage; /* Reference FC-FS for RSCN ELS "Affected N-Port Pages"*/
	HBA_UINT32 Reserved[2];
} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;

typedef struct HBA_Pty_EventInfo {
	HBA_UINT32 PtyData[4]; /* Proprietary data */
} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;

typedef struct HBA_EventInfo {
	HBA_UINT32 EventCode;
	union {
		HBA_LINK_EVENTINFO Link_EventInfo;
		HBA_RSCN_EVENTINFO RSCN_EventInfo;
		HBA_PTY_EVENTINFO Pty_EventInfo;
	} Event;
} HBA_EVENTINFO, *PHBA_EVENTINFO;

typedef PVOID PHBA_ENTRYPOINTS;
typedef PVOID PHBA_ENTRYPOINTSV2;

HBA_STATUS HBA_API HBA_RegisterLibrary(PHBA_ENTRYPOINTS entrypoints);
HBA_STATUS HBA_API HBA_RegisterLibraryV2(PHBA_ENTRYPOINTSV2 entrypoints);

HBA_UINT32 HBA_API HBA_GetVersion();
HBA_STATUS HBA_API HBA_LoadLibrary();
HBA_STATUS HBA_API HBA_FreeLibrary();

HBA_UINT32 HBA_API HBA_GetNumberOfAdapters();

HBA_STATUS HBA_API 
HBA_GetAdapterName(
    IN  HBA_UINT32 adapterindex, 
    OUT char      *adaptername
    );


HBA_HANDLE HBA_API 
HBA_OpenAdapter(
    IN char* adaptername
);

void HBA_API HBA_CloseAdapter(
    IN HBA_HANDLE handle
);

HBA_STATUS HBA_API 
HBA_GetAdapterAttributes(
	IN  HBA_HANDLE handle,
	OUT HBA_ADAPTERATTRIBUTES *hbaattributes
);

HBA_STATUS HBA_API HBA_GetAdapterPortAttributes(
	IN  HBA_HANDLE handle,
	IN  HBA_UINT32 portindex,
	OUT HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_GetPortStatistics(
	HBA_HANDLE handle,
	HBA_UINT32 portindex,
	HBA_PORTSTATISTICS *portstatistics
);


HBA_STATUS HBA_API HBA_GetDiscoveredPortAttributes(
	HBA_HANDLE handle,
	HBA_UINT32 portindex,
	HBA_UINT32 discoveredportindex,
	HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_GetPortAttributesByWWN(
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_SendCTPassThru(
	HBA_HANDLE handle,
	void * pReqBuffer,
	HBA_UINT32 ReqBufferSize,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize
);

HBA_STATUS HBA_API HBA_GetEventBuffer(
	HBA_HANDLE handle,
	PHBA_EVENTINFO EventBuffer,
	HBA_UINT32 *EventCount);

HBA_STATUS HBA_API HBA_SetRNIDMgmtInfo(
	HBA_HANDLE handle,
	HBA_MGMTINFO *pInfo);

HBA_STATUS HBA_API HBA_GetRNIDMgmtInfo(
	HBA_HANDLE handle,
	HBA_MGMTINFO *pInfo);

HBA_STATUS HBA_API HBA_SendRNID(
	HBA_HANDLE handle,
	HBA_WWN wwn,
	HBA_WWNTYPE wnntype,
	void * pRspBuffer,
	HBA_UINT32 *RspBufferSize
);

HBA_STATUS HBA_API HBA_GetFcpTargetMapping (
    HBA_HANDLE handle,
    PHBA_FCPTARGETMAPPING mapping
);

HBA_STATUS HBA_API HBA_GetFcpPersistentBinding (
    HBA_HANDLE handle,
	PHBA_FCPBINDING binding
);

HBA_STATUS HBA_API HBA_SendScsiInquiry (
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 EVPD,
	HBA_UINT32 PageCode,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize);

HBA_STATUS HBA_API HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

HBA_STATUS HBA_API HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

void HBA_API HBA_RefreshInformation(HBA_HANDLE handle);
void HBA_API HBA_ResetStatistics(HBA_HANDLE handle, HBA_UINT32 portindex);


typedef void *HBA_CALLBACKHANDLE;

typedef HBA_CALLBACKHANDLE *PHBA_CALLBACKHANDLE;

/* Adapter Level Events */
#define HBA_EVENT_ADAPTER_UNKNOWN	0x100
#define HBA_EVENT_ADAPTER_ADD		0x101
#define HBA_EVENT_ADAPTER_REMOVE	0x102
#define HBA_EVENT_ADAPTER_CHANGE	0x103

/* Port Level Events */
#define HBA_EVENT_PORT_UNKNOWN		0x200
#define HBA_EVENT_PORT_OFFLINE		0x201
#define HBA_EVENT_PORT_ONLINE		0x202
#define HBA_EVENT_PORT_NEW_TARGETS	0x203
#define HBA_EVENT_PORT_FABRIC		0x204

/* Port Statistics Events */
#define HBA_EVENT_PORT_STAT_THRESHOLD 0x301
#define HBA_EVENT_PORT_STAT_GROWTH	  0x302

/* Target Level Events */
#define HBA_EVENT_TARGET_UNKNOWN    0x400
#define HBA_EVENT_TARGET_OFFLINE    0x401
#define HBA_EVENT_TARGET_ONLINE		0x402
#define HBA_EVENT_TARGET_REMOVED	0x403

/* Fabric Link  Events */
#define HBA_EVENT_LINK_UNKNOWN		0x500
#define HBA_EVENT_LINK_INCIDENT		0x501

HBA_STATUS HBA_API HBA_RemoveCallback(
    HBA_CALLBACKHANDLE callbackHandle
	);

HBA_STATUS HBA_API HBA_RegisterForAdapterAddEvents(
    void (*callback) (void *data, HBA_WWN PortWWN, HBA_UINT32 eventType), 
    void *userData,
    HBA_CALLBACKHANDLE *callbackHandle
    );

HBA_STATUS HBA_API HBA_RegisterForAdapterEvents(
    void (*callback) (void *data, HBA_WWN PortWWN, HBA_UINT32 eventType),
    void *userData, 
    HBA_HANDLE handle,
    HBA_CALLBACKHANDLE *callbackHandle
    );

HBA_STATUS HBA_API 	HBA_RegisterForAdapterPortEvents(
    void (*callback) (void *data, HBA_WWN PortWWN,
			          HBA_UINT32 eventType, HBA_UINT32 fabricPortID),
    void *userData,
    HBA_HANDLE handle,
    HBA_WWN PortWWN,
    HBA_CALLBACKHANDLE *callbackHandle
);

HBA_STATUS HBA_API HBA_RegisterForAdapterPortStatEvents(
    void (*callback)(void *data, HBA_WWN PortWWN, 
			         HBA_UINT32 eventType),
    void *userData,
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_PORTSTATISTICS *stats,
	HBA_UINT32 statType,
	HBA_CALLBACKHANDLE *callbackHandle
    );

HBA_STATUS HBA_API HBA_RegisterForTargetEvents(
    void (*callback)(void *data, HBA_WWN hbaPortWWN,
			         HBA_WWN discoveredPortWWN, HBA_UINT32 eventType),
	void *userData,
	HBA_HANDLE handle, 
	HBA_WWN hbaPortWWN,
    HBA_WWN discoveredPortWWN,
	HBA_CALLBACKHANDLE *callbackHandle,
	HBA_UINT32 allTargets
    );

HBA_STATUS HBA_API HBA_RegisterForLinkEvents(
    void (*callback)(void *data, HBA_WWN adapterWWN, HBA_UINT32 eventType,
                     void *pRLIRBuffer, HBA_UINT32 RLIRBufferSize),
    void *userData,
    void *pRLIRBuffer,
    HBA_UINT32 RLIRBufferSize,
    HBA_HANDLE handle, 
    HBA_CALLBACKHANDLE *callbackHandle
);

HBA_STATUS HBA_API 
HBA_OpenAdapterByWWN(
    OUT HBA_HANDLE *HbaHandle,
    IN HBA_WWN Wwn
    );

void HBA_API 
HBA_RefreshAdapterConfiguration(
    );

HBA_STATUS HBA_API HBA_SendCTPassThruV2(
    HBA_HANDLE handle,
    HBA_WWN hbaPortWWN,
    void * pReqBuffer,
    HBA_UINT32 ReqBufferSize,
    void * pRspBuffer,
    HBA_UINT32 * pRspBufferSize
);

HBA_STATUS HBA_API 
HBA_SendRNIDV2(
    HBA_HANDLE  handle,
    HBA_WWN     hbaPortWWN,
    HBA_WWN     destWWN,
    HBA_UINT32  destFCID,
    HBA_UINT32  NodeIdDataFormat,
    void       *pRspBuffer,
    HBA_UINT32 *pRspBufferSize
    );

HBA_STATUS HBA_API HBA_SendRPL(
    HBA_HANDLE handle,
    HBA_WWN hbaPortWWN,
    HBA_WWN agent_wwn,
    HBA_UINT32 agent_domain,
    HBA_UINT32 portIndex,
    void *pRspBuffer,
    HBA_UINT32 *RspBufferSize
    );


HBA_STATUS HBA_API HBA_SendRPS(
    HBA_HANDLE handle,
    HBA_WWN hbaPortWWN,
    HBA_WWN agent_wwn,
    HBA_UINT32 agent_domain,
    HBA_WWN object_wwn,
    HBA_UINT32 object_port_number,
    void *pRspBuffer,
    HBA_UINT32 *RspBufferSize
    );

HBA_STATUS HBA_API HBA_SendSRL(
    HBA_HANDLE handle,
    HBA_WWN hbaPortWWN,
    HBA_WWN wwn,
    HBA_UINT32 domain,
    void *pRspBuffer,
    HBA_UINT32 *RspBufferSize
);

HBA_STATUS HBA_API HBA_SendLIRR(
    HBA_HANDLE handle,
    HBA_WWN sourceWWN,
    HBA_WWN destWWN,
    HBA_UINT8 function,
    HBA_UINT8 type,
    void *pRspBuffer,
    HBA_UINT32 *RspBufferSize
);

typedef struct HBA_FC4Statistics {
	HBA_INT64 InputRequests;
	HBA_INT64 OutputRequests;
	HBA_INT64 ControlRequests;
	HBA_INT64 InputMegabytes;
	HBA_INT64 OutputMegabytes;
} HBA_FC4STATISTICS, *PHBA_FC4STATISTICS;

HBA_STATUS HBA_API HBA_GetFC4Statistics(
    HBA_HANDLE handle,
    HBA_WWN portWWN,
    HBA_UINT8 FC4type,
    HBA_FC4STATISTICS *statistics
    );

HBA_STATUS HBA_API HBA_GetFCPStatistics(
    HBA_HANDLE handle,
    const HBA_SCSIID *lunit,
	HBA_FC4STATISTICS *statistics
);

typedef struct HBA_LibraryAttributes {
    HBA_BOOLEAN final;
    char        LibPath[256];
    char        VName[256];
    char        VVersion[256];
    struct tm   build_date;
} HBA_LIBRARYATTRIBUTES, *PHBA_LIBRARYATTRIBUTES;


HBA_UINT32 HBA_API 
HBA_GetWrapperLibraryAttributes(
    OUT HBA_LIBRARYATTRIBUTES *attributes
);

HBA_UINT32 HBA_API HBA_GetVendorLibraryAttributes(
    IN HBA_UINT32 adapter_index,
    OUT HBA_LIBRARYATTRIBUTES *attributes
    );

HBA_STATUS HBA_API
HBA_ScsiReadCapacityV2(
	HBA_HANDLE HbaHandle,
	HBA_WWN hbaPortWWN,
	HBA_WWN discoveredPortWWN,
	HBA_UINT64 fcLUN,
	void *pRespBuffer,
	HBA_UINT32 *pRespBufferSize,
	HBA_UINT8 *pScsiStatus,
	void *pSenseBuffer,
	HBA_UINT32 *pSenseBufferSize
);

HBA_STATUS HBA_API
HBA_ScsiReportLUNsV2(
	HBA_HANDLE Hbahandle,
	HBA_WWN hbaPortWWN,
	HBA_WWN discoveredPortWWN,
	void *pRespBuffer,
	HBA_UINT32 *pRespBufferSize,
	HBA_UINT8 *pScsiStatus,
	void *pSenseBuffer,
	HBA_UINT32 *pSenseBufferSize
);

HBA_STATUS HBA_API 
HBA_ScsiInquiryV2 (
	HBA_HANDLE HbaHandle,
	HBA_WWN hbaPortWWN,
	HBA_WWN discoveredPortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 CDB_Byte1,
	HBA_UINT8 CDB_Byte2,
	void *pRespBuffer,
	HBA_UINT32 *pRespBufferSize,
	HBA_UINT8 *pScsiStatus,
	void *pSenseBuffer,
	HBA_UINT32 *pSenseBufferSize
    );


HBA_STATUS HBA_API 
HBA_GetFcpTargetMappingV2 (
    HBA_HANDLE             HbaHandle,
    HBA_WWN                hbaPortWWN,
    PHBA_FCPTARGETMAPPING2 Mapping
    );


#endif HBAAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\ntddsac.h ===
/*++

Copyright(c) 2000-2001  Microsoft Corporation

Module Name:

    sacioctl.h

Abstract:

    This module contains the public header information for communicating to and from
    the SAC via IOCTLs.

Author:

    Sean Selitrennikoff (v-seans) Oct, 2000
    Brian Guarraci (briangu), 2001

Revision History:

--*/

#ifndef _SACIOCTL_
#define _SACIOCTL_

//    
// This enables the ability to register a lock event
// which when fired indicates that the channel should lock itself.
//
#define ENABLE_CHANNEL_LOCKING 1

//
//  This is the maxium length a channel name may be, not including the NULL terminator
//
#define SAC_MAX_CHANNEL_NAME_LENGTH 64
#define SAC_MAX_CHANNEL_NAME_SIZE   ((SAC_MAX_CHANNEL_NAME_LENGTH+1)*sizeof(WCHAR))
#define SAC_MAX_CHANNEL_DESCRIPTION_LENGTH 256
#define SAC_MAX_CHANNEL_DESCRIPTION_SIZE   ((SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1)*sizeof(WCHAR))

//
// IOCTL defs
//
#define IOCTL_SAC_OPEN_CHANNEL          CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_SAC_CLOSE_CHANNEL         CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_SAC_WRITE_CHANNEL         CTL_CODE(FILE_DEVICE_UNKNOWN, 0x3, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_SAC_READ_CHANNEL          CTL_CODE(FILE_DEVICE_UNKNOWN, 0x4, METHOD_BUFFERED, FILE_READ_DATA)
#define IOCTL_SAC_POLL_CHANNEL          CTL_CODE(FILE_DEVICE_UNKNOWN, 0x5, METHOD_BUFFERED, FILE_READ_DATA)
#define IOCTL_SAC_REGISTER_CMD_EVENT    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x6, METHOD_BUFFERED, FILE_WRITE_DATA)
#define IOCTL_SAC_UNREGISTER_CMD_EVENT  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x7, METHOD_BUFFERED, FILE_WRITE_DATA)
#if 0
#define IOCTL_SAC_GET_CHANNEL_ATTRIBUTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8, METHOD_BUFFERED, FILE_READ_DATA)
#define IOCTL_SAC_SET_CHANNEL_ATTRIBUTE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9, METHOD_BUFFERED, FILE_WRITE_DATA)
#endif

//
// Structure to be use to refer to a channel when
// using the IOCTL interface.
//
typedef struct _SAC_CHANNEL_HANDLE {
    GUID    ChannelHandle;
    HANDLE  DriverHandle;
} SAC_CHANNEL_HANDLE, *PSAC_CHANNEL_HANDLE;

//
// Define the channel types that can be created
//
typedef enum _SAC_CHANNEL_TYPE {
    ChannelTypeVTUTF8,
    ChannelTypeRaw, 
    ChannelTypeCmd 
} SAC_CHANNEL_TYPE, *PSAC_CHANNEL_TYPE;

//
// IOCTL_SAC_OPEN_CHANNEL. 
//

// Flags
typedef ULONG   SAC_CHANNEL_FLAG;
typedef PULONG  PSAC_CHANNEL_FLAG;

#define SAC_CHANNEL_FLAG_PRESERVE           0x01
#define SAC_CHANNEL_FLAG_CLOSE_EVENT        0x02
#define SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT 0x04
#define SAC_CHANNEL_FLAG_LOCK_EVENT         0x08
#define SAC_CHANNEL_FLAG_REDRAW_EVENT       0x10
#define SAC_CHANNEL_FLAG_APPLICATION_TYPE   0x20

//
// Structure used by to describe
// the attributes of the channel wanting to be created
//
typedef struct _SAC_CHANNEL_OPEN_ATTRIBUTES {

    SAC_CHANNEL_TYPE        Type;
    WCHAR                   Name[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    WCHAR                   Description[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1];        
    SAC_CHANNEL_FLAG        Flags;
    HANDLE                  CloseEvent;         OPTIONAL
    HANDLE                  HasNewDataEvent;    OPTIONAL
    HANDLE                  LockEvent;          OPTIONAL
    HANDLE                  RedrawEvent;        OPTIONAL
    GUID                    ApplicationType;    OPTIONAL

} SAC_CHANNEL_OPEN_ATTRIBUTES, *PSAC_CHANNEL_OPEN_ATTRIBUTES; 

typedef struct _SAC_CMD_OPEN_CHANNEL {
    SAC_CHANNEL_OPEN_ATTRIBUTES     Attributes;
} SAC_CMD_OPEN_CHANNEL, *PSAC_CMD_OPEN_CHANNEL;

//
// This is the response struct for an IOCTL_SAC_OPEN_CHANNEL.  
//    
typedef struct _SAC_RSP_OPEN_CHANNEL {
    SAC_CHANNEL_HANDLE Handle;
} SAC_RSP_OPEN_CHANNEL, *PSAC_RSP_OPEN_CHANNEL;

//
// IOCTL_SAC_CLOSE_CHANNEL.  
// Handle is value returned by IOCTL_SAC_OPEN_CHANNEL.
//    
typedef struct _SAC_CMD_CLOSE_CHANNEL {
    SAC_CHANNEL_HANDLE Handle;
} SAC_CMD_CLOSE_CHANNEL, *PSAC_CMD_CLOSE_CHANNEL;

//
// IOCTL_SAC_WRITE_CHANNEL.  
// Handle is value returned by IOCTL_SAC_OPEN_CHANNEL.
//    
typedef struct _SAC_CMD_WRITE_CHANNEL {

    SAC_CHANNEL_HANDLE Handle; 
    
    ULONG   Size;       // The # of bytes in String to process
    UCHAR   Buffer[1];  // byte buffer
    
} SAC_CMD_WRITE_CHANNEL, *PSAC_CMD_WRITE_CHANNEL;

//
// IOCTL_SAC_READ_CHANNEL.
// Handle is value returned by IOCTL_SAC_OPEN_CHANNEL.
//
typedef struct _SAC_CMD_READ_CHANNEL {
    SAC_CHANNEL_HANDLE Handle;     
} SAC_CMD_READ_CHANNEL, *PSAC_CMD_READ_CHANNEL;

//
// Response structure fore the IOCTL_SAC_READ_CHANNEL
//
// Note: BufferSize is returned as the response size
//       in the IOCTL call.
//
typedef struct _SAC_RSP_READ_CHANNEL {
    UCHAR Buffer[1];  // A NULL terminated string.
} SAC_RSP_READ_CHANNEL, *PSAC_RSP_READ_CHANNEL;

//
// This is the struct for an IOCTL_SAC_POLL_CHANNEL.  
// Handle is value returned by IOCTL_SAC_OPEN_CHANNEL.
//
typedef struct _SAC_CMD_POLL_CHANNEL {
    SAC_CHANNEL_HANDLE Handle;     
} SAC_CMD_POLL_CHANNEL, *PSAC_CMD_POLL_CHANNEL;

//
// Reponse structure for IOCTL_SAC_POLL_CHANNEL
//
typedef struct _SAC_RSP_POLL_CHANNEL {
    BOOLEAN InputWaiting;
} SAC_RSP_POLL_CHANNEL, *PSAC_RSP_POLL_CHANNEL;

//
// Define the attributes applications may modify
//
typedef enum _SAC_CHANNEL_ATTRIBUTE {
    ChannelAttributeStatus,
    ChannelAttributeType,
    ChannelAttributeName,
    ChannelAttributeDescription,
    ChannelAttributeApplicationType,
    ChannelAttributeFlags
} SAC_CHANNEL_ATTRIBUTE, *PSAC_CHANNEL_ATTRIBUTE;

//    
// Define the possible channel states
//
typedef enum _SAC_CHANNEL_STATUS {
    ChannelStatusInactive = 0,
    ChannelStatusActive
} SAC_CHANNEL_STATUS, *PSAC_CHANNEL_STATUS;

#if 0
//                         
// Command structure for getting a channel attribute
//
typedef struct _SAC_CMD_GET_CHANNEL_ATTRIBUTE {
    SAC_CHANNEL_HANDLE      Handle;
    SAC_CHANNEL_ATTRIBUTE   Attribute;     
} SAC_CMD_GET_CHANNEL_ATTRIBUTE, *PSAC_CMD_GET_CHANNEL_ATTRIBUTE;

//
// Response structure for getting a channel attribute
//
typedef struct _SAC_RSP_GET_CHANNEL_ATTRIBUTE {
    union {
    SAC_CHANNEL_STATUS  ChannelStatus;
    SAC_CHANNEL_TYPE    ChannelType;
    WCHAR               ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    WCHAR               ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1];
    GUID                ChannelApplicationType;
    SAC_CHANNEL_FLAG    ChannelFlags;
    };    
} SAC_RSP_GET_CHANNEL_ATTRIBUTE, *PSAC_RSP_GET_CHANNEL_ATTRIBUTE;

//    
//  Command structure for setting a channel attribute
//
typedef struct _SAC_CMD_SET_CHANNEL_ATTRIBUTE {
    SAC_CHANNEL_HANDLE      Handle;
    SAC_CHANNEL_ATTRIBUTE   Attribute;     
    
    union {
    WCHAR                   ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH+1];
    WCHAR                   ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1];
    GUID                    ChannelApplicationType;
    SAC_CHANNEL_FLAG        ChannelFlags;
    };    
} SAC_CMD_SET_CHANNEL_ATTRIBUTE, *PSAC_CMD_SET_CHANNEL_ATTRIBUTE;
#endif

//    
//  IOCTL_SAC_REGISTER_CMD_EVENT
//    
//  Command structure for setting the command console event info
//
typedef struct _SAC_CMD_REGISTER_CMD_EVENT {

    //
    // Handles of events used for communication between
    // device driver and the user-mode app.
    //
    HANDLE      RequestSacCmdEvent;
    
    //
    // Handles of the events indicating the result
    // of the command console launch
    //
    HANDLE      RequestSacCmdSuccessEvent;
    HANDLE      RequestSacCmdFailureEvent;

} SAC_CMD_SETUP_CMD_EVENT, *PSAC_CMD_SETUP_CMD_EVENT;

#endif // _SACIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\efsstruc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    efsstruc.h

Abstract:

    EFS (Encrypting File System) defines, data and function prototypes.

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#ifndef _EFSSTRUC_
#define _EFSSTRUC_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif

//
// Our OID.  Remove from here once it's in the real headers.
//

#ifndef szOID_EFS_CRYPTO
#define szOID_EFS_CRYPTO	"1.3.6.1.4.1.311.10.3.4"
#endif

#ifndef szOID_EFS_RECOVERY
#define szOID_EFS_RECOVERY      "1.3.6.1.4.1.311.10.3.4.1"
#endif


//
// Context flag
//

#define CONTEXT_FOR_EXPORT      0x00000000
#define CONTEXT_FOR_IMPORT      0x00000001
#define CONTEXT_INVALID         0x00000002
#define CONTEXT_OPEN_FOR_DIR    0x00008000

//
// Context ID
//
#define EFS_CONTEXT_ID  0x00000001

//
// Signature type
//
#define SIG_LENGTH              0x00000008
#define SIG_NO_MATCH            0x00000000
#define SIG_EFS_FILE            0x00000001
#define SIG_EFS_STREAM          0x00000002
#define SIG_EFS_DATA            0x00000003

//
// Export file format stream flag information
//

#define STREAM_NOT_ENCRYPTED    0x0001

#define EFS_EXP_FORMAT_CURRENT_VERSION  0x0100
#define EFS_SIGNATURE_LENGTH    4
#define EFS_STREAM_ID    0x1910

#define FSCTL_IMPORT_INPUT_LENGTH      (4 * 1024)
#define FSCTL_EXPORT_INPUT_LENGTH      ( 128 )
#define FSCTL_OUTPUT_INITIAL_LENGTH    (68 * 1024)
#define FSCTL_OUTPUT_LESS_LENGTH       (8 * 1024)
#define FSCTL_OUTPUT_MIN_LENGTH        (20 * 1024)
#define FSCTL_OUTPUT_MISC_LENGTH       (4 * 1024)

//
// FSCTL data shared between server and driver
//

#define EFS_SET_ENCRYPT                 0
#define EFS_SET_ATTRIBUTE               1
#define EFS_DEL_ATTRIBUTE               2
#define EFS_GET_ATTRIBUTE               3
#define EFS_OVERWRITE_ATTRIBUTE         4
#define EFS_ENCRYPT_DONE                5
#define EFS_DECRYPT_BEGIN               6

//
// Mask for Set EFS Attribute
//

#define WRITE_EFS_ATTRIBUTE     0x00000001
#define SET_EFS_KEYBLOB         0x00000002

//
// Sub code of SET_ENCRYPT FSCTL
//

#define EFS_FSCTL_ON_DIR                0x80000000
#define EFS_ENCRYPT_FILE                0x00000001
#define EFS_DECRYPT_FILE                0x00000002
#define EFS_ENCRYPT_STREAM              0x00000003
#define EFS_DECRYPT_STREAM              0x00000004
#define EFS_DECRYPT_DIRFILE             0x80000002
#define EFS_ENCRYPT_DIRSTR              0x80000003
#define EFS_DECRYPT_DIRSTR              0x80000004


//
// EFS Version Information
//
// EFS_CURRENT_VERSION must always be the highest known revision
// level.  This value is placed in the EfsVersion field of the
// $EFS header.
//

#define EFS_VERSION_1                   (0x00000001)
#define EFS_VERSION_2                   (0x00000002)
#define EFS_CURRENT_VERSION             EFS_VERSION_2



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS Data structures                                                        /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//                                                                  /
// EFS_KEY Structure                                                /
//                                                                  /
/////////////////////////////////////////////////////////////////////

typedef struct _EFS_KEY {

    //
    // The length in bytes of the appended key.
    //

    ULONG KeyLength;

    //
    // The number of bits of entropy in the key.
    // For example, an 8 byte key has 56 bits of
    // entropy.
    //

    ULONG Entropy;

    //
    // The algorithm used in conjunction with this key.
    //
    // Note: this is not the algorithm used to encrypt the
    // actual key data itself.
    //

    ALG_ID Algorithm;

    //
    // This structure must be a multiple of 8 in size,
    // including the KeyData at the end.
    //

    ULONG Pad;

    //
    // KeyData is appended to the end of the structure.
    //

    // UCHAR KeyData[1];

} EFS_KEY, *PEFS_KEY;

//
// Private macros to manipulate data structures
//

#define EFS_KEY_SIZE( pKey ) (sizeof( EFS_KEY ) + (pKey)->KeyLength)

#define EFS_KEY_DATA( Key )  (PUCHAR)(((PUCHAR)(Key)) + sizeof( EFS_KEY ))

#define OFFSET_TO_POINTER( FieldName, Base )  ((PCHAR)(Base) + (Base)->FieldName)

#define POINTER_TO_OFFSET( Pointer, Base ) (((PUCHAR)(Pointer)) - ((PUCHAR)(Base)))

//
// We're going to use MD5 to hash the EFS stream.  MD5 yields a 16 byte long hash.
//

#define MD5_HASH_SIZE   16

typedef struct _EFS_DATA_STREAM_HEADER {
    ULONG Length;
    ULONG State;
    ULONG EfsVersion;
    ULONG CryptoApiVersion;
    GUID  EfsId;
    UCHAR EfsHash[MD5_HASH_SIZE];
    UCHAR DrfIntegrity[MD5_HASH_SIZE];
    ULONG DataDecryptionField;          //Offset to DDF
    ULONG DataRecoveryField;            //Offset to DRF
    ULONG Reserved;
    ULONG Reserved2;
    ULONG Reserved3;
} EFS_DATA_STREAM_HEADER, *PEFS_DATA_STREAM_HEADER;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS_PUBLIC_KEY_INFO                                                        /
//                                                                            /
// This structure is used to contain all the information necessary to decrypt /
// the FEK.                                                                   /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


typedef struct _EFS_CERT_HASH_DATA {
    ULONG   pbHash;             // offset from start of structure
    ULONG   cbHash;             // count of bytes in hash
    ULONG   ContainerName;      // hint data, offset to LPWSTR
    ULONG   ProviderName;       // hint data, offset to LPWSTR
    ULONG   lpDisplayInformation; // offset to an LPWSTR
} EFS_CERT_HASH_DATA, *PEFS_CERT_HASH_DATA;

typedef struct _EFS_PUBLIC_KEY_INFO {

    //
    // The length of this entire structure, including string data
    // appended to the end.
    //

    ULONG Length;

    //
    // Sid of owner of the public key (regardless of format).
    // This field is to be treated as a hint only.
    //

    ULONG PossibleKeyOwner;

    //
    // Contains information describing how to interpret
    // the public key information
    //

    ULONG KeySourceTag;

    union {
        struct {

            //
            // The following fields contain offsets based at the
            // beginning of the structure.  Each offset is to
            // a NULL terminated WCHAR string.
            //

            ULONG ContainerName;
            ULONG ProviderName;

            //
            // The exported public key used to encrypt the FEK.
            // This field contains an offset from the beginning of the
            // structure.
            //

            ULONG PublicKeyBlob;

            //
            // Length of the PublicKeyBlob in bytes
            //

            ULONG PublicKeyBlobLength;

        } ContainerInfo;

        struct {

            ULONG CertificateLength;       // in bytes
            ULONG Certificate;             // offset from start of structure

        } CertificateInfo;

        struct {

            ULONG ThumbprintLength;        // in bytes
            ULONG CertHashData;            // offset from start of structure

        } CertificateThumbprint;
    };



} EFS_PUBLIC_KEY_INFO, *PEFS_PUBLIC_KEY_INFO;

//
// Possible KeyTag values
//

typedef enum _PUBLIC_KEY_SOURCE_TAG {
    EfsCryptoAPIContainer = 1,
    EfsCertificate,
    EfsCertificateThumbprint
} PUBLIC_KEY_SOURCE_TAG, *PPUBLIC_KEY_SOURCE_TAG;


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//  RECOVERY_KEY Data Structure                                               /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

//
// Current format of recovery data.
//

typedef struct _RECOVERY_KEY_1_1   {
        ULONG               TotalLength;
        EFS_PUBLIC_KEY_INFO PublicKeyInfo;
} RECOVERY_KEY_1_1, *PRECOVERY_KEY_1_1;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// KEY_INTEGRITY_INFO                                                         /
//                                                                            /
// The KEY_INTEGRITY_INFO structure is used to verify that                    /
// the user's key has correctly decrypted the file's FEK.                     /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

typedef struct _KEY_INTEGRITY_INFO {

    //
    // The length of the entire structure, including the
    // variable length integrity information appended to
    // the end
    //

    ULONG Length;

    //
    // The algorithm used to hash the combined FEK and
    // public key
    //

    ALG_ID HashAlgorithm;

    //
    // The length of just the hash data.
    //

    ULONG HashDataLength;

    //
    // Integrity information goes here
    //

    // UCHAR Integrity Info[]
} KEY_INTEGRITY_INFO, *PKEY_INTEGRITY_INFO;

typedef struct _EFS_KEY_SALT {
    ULONG Length;   // total length of header plus data
    ULONG SaltType; // figure out what you want for this
    //
    // Put data here, so total length of the structure is
    // sizeof( EFS_KEY_SALT ) + length of your data
    //
} EFS_KEY_SALT, *PEFS_KEY_SALT;

//
// EFS Private DataStructures
//

typedef struct _ENCRYPTED_KEY {

    //
    // Total length of this structure and its data
    //

    ULONG Length;

    //
    // contains an offset from beginning of structure,
    // used to decrypt the EncryptedKey
    //

    ULONG PublicKeyInfo;

    //
    // Length in bytes of EncryptedFEK field
    //

    ULONG EncryptedFEKLength;

    //
    // offset from beginning of structure to encrypted
    // EFS_KEY containing the FEK
    //
    // Type is PUCHAR because data is encrypted.
    //

    ULONG EncryptedFEK;

    //
    // offset from beginning of structure to KEY_INTEGRITY_INFO
    //

    ULONG EfsKeySalt;

    //
    // FEK Data
    //
    // KEY_INTEGRITY_INFO Data
    //
    // PEFS_PUBLIC_KEY_INFO Data
    //

} ENCRYPTED_KEY, *PENCRYPTED_KEY;


//
// The Key Ring Structure.
//

typedef struct _ENCRYPTED_KEYS {
    ULONG           KeyCount;
    ENCRYPTED_KEY   EncryptedKey[1];
} ENCRYPTED_KEYS, *PENCRYPTED_KEYS;

typedef ENCRYPTED_KEYS      DDF, *PDDF;
typedef ENCRYPTED_KEYS      DRF, *PDRF;

typedef struct _EFS_STREAM_SIZE {
    ULONG       StreamFlag;
    LARGE_INTEGER   EOFSize;
    LARGE_INTEGER   AllocSize;
} EFS_STREAM_SIZE, *PEFS_STREAM_SIZE;

#define NEXT_ENCRYPTED_KEY( pEncryptedKey )  (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + *((ULONG UNALIGNED *)&((PENCRYPTED_KEY)(pEncryptedKey))->Length))


//
// Import context
//

typedef struct IMPORT_CONTEXT{

    ULONG       ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG       Flag;   // Indicate the type of context
    HANDLE      Handle; // File handle, used to create rest streams
    ULONG       Attribute;
    ULONG       CreateDisposition;
    ULONG       CreateOptions;
    ULONG       DesiredAccess;

} IMPORT_CONTEXT, *PIMPORT_CONTEXT;

//
// Export context
//

typedef struct EXPORT_CONTEXT{

    ULONG           ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG           Flag;   // Indicate the type of context
    HANDLE          Handle; // File handle, used to open rest streams
    ULONG           NumberOfStreams;
    PHANDLE         StreamHandles;
    PUNICODE_STRING StreamNames;
    PFILE_STREAM_INFORMATION StreamInfoBase;

} EXPORT_CONTEXT, *PEXPORT_CONTEXT;

//
// EFS Export/Import RPC pipe status
//

typedef struct EFS_EXIM_STATE{
    PVOID   ExImCallback;
    PVOID   CallbackContext;
    char     *WorkBuf;
    ULONG   BufLength;
    ULONG  Status;
} EFS_EXIM_STATE, *PEFS_EXIM_STATE;

//
// Export file format
//

typedef struct EFSEXP_FILE_HEADER{

    ULONG  VersionID;   // Export file version
    WCHAR  FileSignature[EFS_SIGNATURE_LENGTH]; // Signature of the file
    ULONG  Reserved[2];
    //STREAM_DADA     Streams[0];  // An array of STREAM_BLOCK

} EFSEXP_FILE_HEADER, *PEFSEXP_FILE_HEADER;

typedef struct EFSEXP_STREAM_HEADER{

    ULONG    Length; // Redundant information. The length of this block not including DataBlocks but
                     // including itself; This field is to simplify the import routine.
    WCHAR    StreamSignature[EFS_SIGNATURE_LENGTH]; // Signature of the stream
    ULONG    Flag;  // Indicating if the stream is encrypted or not and etc.
    ULONG    Reserved[2];  // For future use
    ULONG    NameLength;   // Length of the stream name
    //WCHAR    StreamName[0];   // ID of the stream, Binary value can be used.
    //DATA_BLOCK   DataBlocks[0]; // Variable number of data block

} EFSEXP_STREAM_HEADER, *PEFSEXP_STREAM_HEADER;

typedef struct EFSEXP_DATA_HEADER{

    ULONG Length;      // Length of the block including this ULONG
    WCHAR DataSignature[EFS_SIGNATURE_LENGTH]; // Signature of the data
    ULONG Flag;          // For future use.
    // BYTE  DataBlock[N];  // N = Length - 2 * sizeof (ULONG) - 4 * sizeof (WCHAR)

} EFSEXP_DATA_HEADER, *PEFSEXP_DATA_HEADER;

//
//  TotalLength - total length of the RECOVERY_KEY Datastructure.
//
//  KeyName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  AlgorithmId - CryptAPI Algorithm ID - in V1 it is always RSA.
//
//  CSPName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  CSPType     - CryptAPI type of CSP.
//
//  PublicBlobLength - Length of the public blob that is importable in CryptoAPI in bytes.
//

//
//  Recovery Policy Data Structures
//

typedef struct _RECOVERY_POLICY_HEADER {
    USHORT      MajorRevision;
    USHORT      MinorRevision;
    ULONG       RecoveryKeyCount;
} RECOVERY_POLICY_HEADER, *PRECOVERY_POLICY_HEADER;

typedef struct _RECOVERY_POLICY_1_1    {
        RECOVERY_POLICY_HEADER  RecoveryPolicyHeader;
        RECOVERY_KEY_1_1        RecoveryKeyList[1];
}   RECOVERY_POLICY_1_1, *PRECOVERY_POLICY_1_1;

#define EFS_RECOVERY_POLICY_MAJOR_REVISION_1   (1)
#define EFS_RECOVERY_POLICY_MINOR_REVISION_0   (0)

#define EFS_RECOVERY_POLICY_MINOR_REVISION_1   (1)

//
//  Major/Minor Revision - revision number of policy information.
//
//  RecoveryKeyCount - number of recovery keys configured in this policy.
//
//  RecoveryKeyList - array of recovery keys.
//

//
// Session Key Structure
//

#define SESSION_KEY_SIZE    8
#define COMMON_FSCTL_HEADER_SIZE (7 * sizeof( ULONG ) + 2 * SESSION_KEY_SIZE)

typedef struct _EFS_INIT_DATAEXG {
    UCHAR Key[SESSION_KEY_SIZE];
    HANDLE LsaProcessID; // The reason we use HANDLE is for the sake of 64 bits
} EFS_INIT_DATAEXG, *PEFS_INIT_DATAEXG;


//
// Server API, callable from kernel mode
//

NTSTATUS
EfsGenerateKey(
      PEFS_KEY * Fek,
      PEFS_DATA_STREAM_HEADER * EfsStream,
      PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
      ULONG DirectoryEfsStreamLength,
      PVOID * BufferBase,
      PULONG BufferLength
      );


NTSTATUS
GenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID * BufferBase,
    PULONG BufferLength
    );


#define EFS_OPEN_NORMAL  1
#define EFS_OPEN_RESTORE 2
#define EFS_OPEN_BACKUP  3

NTSTATUS
EfsDecryptFek(
    IN OUT PEFS_KEY * Fek,
    IN PEFS_DATA_STREAM_HEADER CurrentEfs,
    IN ULONG EfsStreamLength,
    IN ULONG OpenType,                      //Normal, Recovery or Backup
    OUT PEFS_DATA_STREAM_HEADER *NewEfs,     //In case the DDF, DRF are changed
    PVOID * BufferBase,
    PULONG BufferLength
    );

NTSTATUS
GenerateSessionKey(
    OUT EFS_INIT_DATAEXG * SessionKey
    );


//
// Private usermode server API
//

ULONG
EfsEncryptFileRPCClient(
    IN PUNICODE_STRING    FileName
    );

ULONG
EfsDecryptFileRPCClient(
    PUNICODE_STRING      FileName,
    ULONG   OpenFlag
    );

ULONG
EfsOpenFileRawRPCClient(
    IN  LPCWSTR    FileName,
    IN  ULONG   Flags,
    OUT PVOID * Context
    );

VOID
EfsCloseFileRawRPCClient(
    IN  PVOID   Context
    );

#ifdef __cplusplus
}
#endif

#endif // _EFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\ksmediap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_KS_)
#error KS.H must be included before KSMEDIA.H
#endif // !defined(_KS_)

#if !defined(_KSMEDIA_)
#define _KSMEDIA_

typedef struct {
    KSPROPERTY      Property;
    KSMULTIPLE_ITEM MultipleItem;
} KSMULTIPLE_DATA_PROP, *PKSMULTIPLE_DATA_PROP;

#define STATIC_KSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", KSMEDIUMSETID_MidiBus);
#define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)

#define STATIC_KSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", KSMEDIUMSETID_VPBus);
#define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)

#define STATIC_KSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", KSINTERFACESETID_Media);
#define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)

typedef enum {
    KSINTERFACE_MEDIA_MUSIC,
    KSINTERFACE_MEDIA_WAVE_BUFFERED,
    KSINTERFACE_MEDIA_WAVE_QUEUED
} KSINTERFACE_MEDIA;


#if !defined(INIT_USBAUDIO_MID)
// {4e1cecd2-1679-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_MID(guid, id)\
{\
    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);\
    (guid)->Data2 = 0x1679;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_MID(guid)\
    (USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)\
    0x4e1cecd2+(USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_MID(guid)\
    (((guid)->Data1 >= 0x4e1cecd2) &&\
    ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&\
    ((guid)->Data2 == 0x1679) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_MID)

#if !defined(INIT_USBAUDIO_PID)
// {abcc5a5e-c263-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_PID(guid, id)\
{\
    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);\
    (guid)->Data2 = 0xc263;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_PID(guid)\
    (USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)\
    0xabcc5a5e+(USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_PID(guid)\
    (((guid)->Data1 >= 0xabcc5a5e) &&\
    ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&\
    ((guid)->Data2 == 0xc263) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_PID)

#if !defined(INIT_USBAUDIO_PRODUCT_NAME)
// {FC575048-2E08-463B-A72F-A5BF64C86EBA}
#define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)\
{\
    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);\
    (guid)->Data2 = 0x2E08     + (USHORT)(pid);\
    (guid)->Data3 = 0x463B     + (USHORT)(strIndex);\
    (guid)->Data4[0] = 0xA7;\
    (guid)->Data4[1] = 0x2F;\
    (guid)->Data4[2] = 0xA5;\
    (guid)->Data4[3] = 0xBF;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xC8;\
    (guid)->Data4[6] = 0x6E;\
    (guid)->Data4[7] = 0xBA;\
}
#define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)\
    0xFC575048+(USHORT)(vid), 0x2E08+(USHORT)(pid), 0x463B+(USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
#endif // !defined(INIT_USBAUDIO_PRODUCT_NAME)


// USB Component ID
#define STATIC_KSCOMPONENTID_USBAUDIO \
    0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", KSCOMPONENTID_USBAUDIO);
#define KSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(KSCOMPONENTID_USBAUDIO)

// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_KSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE);
#define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)

#define STATIC_KSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_MICROPHONE);
#define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_KSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PERSONAL_MICROPHONE);
#define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE_ARRAY);
#define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#define STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR \
    0x830a44f2, 0xa32d, 0x476b,  0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_KSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKER);
#define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)

#define STATIC_KSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADPHONES);
#define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)

#define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_KSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_SPEAKER);
#define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_KSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ROOM_SPEAKER);
#define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)

#define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_COMMUNICATION_SPEAKER);
#define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_KSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HANDSET);
#define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)

#define STATIC_KSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADSET);
#define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)

#define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONE_LINE);
#define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)

#define STATIC_KSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONE);
#define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)

#define STATIC_KSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DOWN_LINE_PHONE);
#define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_KSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_CONNECTOR);
#define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_KSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LINE_CONNECTOR);
#define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)

#define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_KSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPDIF_INTERFACE);
#define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)

#define STATIC_KSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DA_STREAM);
#define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)

#define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_KSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EQUALIZATION_NOISE);
#define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_KSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CD_PLAYER);
#define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)

#define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_KSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MINIDISK);
#define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)

#define STATIC_KSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_TAPE);
#define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)

#define STATIC_KSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONOGRAPH);
#define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)

#define STATIC_KSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VCR_AUDIO);
#define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)

#define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_DISC_AUDIO);
#define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_KSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DVD_AUDIO);
#define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)

#define STATIC_KSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TV_TUNER_AUDIO);
#define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CABLE_TUNER_AUDIO);
#define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_KSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DSS_AUDIO);
#define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)

#define STATIC_KSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_RECEIVER);
#define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)

#define STATIC_KSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_TRANSMITTER);
#define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_KSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MULTITRACK_RECORDER);
#define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_KSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SYNTHESIZER);
#define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_KSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", KSNODETYPE_SWSYNTH);
#define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_KSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", KSNODETYPE_SWMIDI);
#define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)

#define STATIC_KSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", KSNODETYPE_DRM_DESCRAMBLE);
#define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)

// General categories
#define STATIC_KSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_AUDIO);
#define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)

#define STATIC_KSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_VIDEO);
#define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)

#define STATIC_KSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_TEXT);
#define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)

#define STATIC_KSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", KSCATEGORY_NETWORK);
#define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)

#define STATIC_KSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", KSCATEGORY_TOPOLOGY);
#define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)

#define STATIC_KSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", KSCATEGORY_VIRTUAL);
#define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)

#define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", KSCATEGORY_SYSAUDIO);
#define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)

#define STATIC_KSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", KSCATEGORY_WDMAUD);
#define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)

#define STATIC_KSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", KSCATEGORY_AUDIO_GFX);
#define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)

#define STATIC_KSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", KSCATEGORY_AUDIO_SPLITTER);
#define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)

#define STATIC_KSCATEGORY_SYNTHESIZER STATIC_KSNODETYPE_SYNTHESIZER
#define KSCATEGORY_SYNTHESIZER KSNODETYPE_SYNTHESIZER

#define STATIC_KSCATEGORY_DRM_DESCRAMBLE STATIC_KSNODETYPE_DRM_DESCRAMBLE
#define KSCATEGORY_DRM_DESCRAMBLE KSNODETYPE_DRM_DESCRAMBLE

#define STATIC_KSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", KSCATEGORY_AUDIO_DEVICE);
#define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

// Special pin category for wdmaud

#define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", KSCATEGORY_WDMAUD_USE_PIN_NAME);
#define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_KSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_VIDEO);
#define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_KSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_AUDIO);
#define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)

// 'txts' == MEDIATYPE_Text
#define STATIC_KSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_TEXT);
#define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)

#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}

#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)

#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", KSDATAFORMAT_SUBTYPE_ANALOG);
#define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)

#define STATIC_KSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_PCM);
#define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)

#if defined(_INC_MMREG)
#define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

#define STATIC_KSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DRM);
#define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)

#define STATIC_KSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ALAW);
#define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MULAW);
#define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ADPCM);
#define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MPEG);
#define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
#endif // defined(_INC_MMREG)

#define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", KSDATAFORMAT_SPECIFIER_VC_ID);
#define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", KSDATAFORMAT_SPECIFIER_DSOUND);
#define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    KSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} KSDATAFORMAT_WAVEFORMATEX, *PKSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC, *PKSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    KSDATAFORMAT        DataFormat;
    KSDSOUND_BUFFERDESC BufferDesc;
} KSDATAFORMAT_DSOUND, *PKSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define KSDSOUND_BUFFER_PRIMARY             0x00000001
#define KSDSOUND_BUFFER_STATIC              0x00000002
#define KSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define KSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define KSDSOUND_BUFFER_CTRL_3D             0x00000001
#define KSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define KSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define KSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} KSAUDIO_POSITION, *PKSAUDIO_POSITION;

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// KSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DListener);
#define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)

typedef enum {
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} KSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} KSDS3D_LISTENER_ALL, *PKSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} KSDS3D_LISTENER_ORIENTATION, *PKSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// KSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DBuffer);
#define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)


typedef enum {
    KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} KSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} KSDS3D_BUFFER_ALL, *PKSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} KSDS3D_BUFFER_CONE_ANGLES, *PKSDS3D_BUFFER_CONE_ANGLES;

#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define KSDSOUND_3D_MODE_NORMAL          0x00000000
#define KSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define KSDSOUND_3D_MODE_DISABLE         0x00000002

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define KSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} KSDS3D_HRTF_PARAMS_MSG, *PKSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    KSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} KSDS3D_HRTF_INIT_MSG, *PKSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    KSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_KSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
    KSPROPERTY_HRTF3D_PARAMS = 0,
    KSPROPERTY_HRTF3D_INITIALIZE,
    KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} KSDS3D_ITD_PARAMS, *PKSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    KSDS3D_ITD_PARAMS     LeftParams;
    KSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} KSDS3D_ITD_PARAMS_MSG, *PKSDS3D_ITD_PARAMS_MSG;

#define STATIC_KSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
    KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;


typedef struct {
   KSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFF);
#define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", KSPROPSETID_Bibliographic);
#define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} KSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_KSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", KSPROPSETID_TopologyNode);
#define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)

typedef enum {
    KSPROPERTY_TOPOLOGYNODE_ENABLE = 1,
    KSPROPERTY_TOPOLOGYNODE_RESET
} KSPROPERTY_TOPOLOGYNODE;

//===========================================================================

#if defined(_NTDDK_)
typedef NTSTATUS (CALLBACK *PRTAUDIOGETPOSITION)(IN PFILE_OBJECT PinFileObject,
                                                 OUT PUCHAR *ppPlayPosition,
                                                 OUT PLONG plOffset);
#endif // defined(_NTDDK_)

#define STATIC_KSPROPSETID_RtAudio\
    0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", KSPROPSETID_RtAudio);
#define KSPROPSETID_RtAudio DEFINE_GUIDNAMED(KSPROPSETID_RtAudio)

typedef enum {
    KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION
} KSPROPERTY_RTAUDIO;

//===========================================================================
#define STATIC_KSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", KSPROPSETID_DrmAudioStream);
#define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)

typedef enum {
    KSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} KSPROPERTY_DRMAUDIOSTREAM;

//===========================================================================
#define STATIC_KSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", KSPROPSETID_Audio);
#define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)

typedef enum {
    KSPROPERTY_AUDIO_LATENCY = 1,
    KSPROPERTY_AUDIO_COPY_PROTECTION,
    KSPROPERTY_AUDIO_CHANNEL_CONFIG,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_AUDIO_POSITION,
    KSPROPERTY_AUDIO_DYNAMIC_RANGE,
    KSPROPERTY_AUDIO_QUALITY,
    KSPROPERTY_AUDIO_SAMPLING_RATE,
    KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_AUDIO_BASS,
    KSPROPERTY_AUDIO_MID,
    KSPROPERTY_AUDIO_TREBLE,
    KSPROPERTY_AUDIO_BASS_BOOST,
    KSPROPERTY_AUDIO_EQ_LEVEL,
    KSPROPERTY_AUDIO_NUM_EQ_BANDS,
    KSPROPERTY_AUDIO_EQ_BANDS,
    KSPROPERTY_AUDIO_AGC,
    KSPROPERTY_AUDIO_DELAY,
    KSPROPERTY_AUDIO_LOUDNESS,
    KSPROPERTY_AUDIO_WIDE_MODE,
    KSPROPERTY_AUDIO_WIDENESS,
    KSPROPERTY_AUDIO_REVERB_LEVEL,
    KSPROPERTY_AUDIO_CHORUS_LEVEL,
    KSPROPERTY_AUDIO_DEV_SPECIFIC,
    KSPROPERTY_AUDIO_DEMUX_DEST,
    KSPROPERTY_AUDIO_STEREO_ENHANCE,
    KSPROPERTY_AUDIO_MANUFACTURE_GUID,
    KSPROPERTY_AUDIO_PRODUCT_GUID,
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    KSPROPERTY_AUDIO_SURROUND_ENCODE,
    KSPROPERTY_AUDIO_3D_INTERFACE,
    KSPROPERTY_AUDIO_PEAKMETER,
    KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
    KSPROPERTY_AUDIO_FILTER_STATE,
    KSPROPERTY_AUDIO_PREFERRED_STATUS
} KSPROPERTY_AUDIO;

// Audio quality constants
#define KSAUDIO_QUALITY_WORST               0x0
#define KSAUDIO_QUALITY_PC                  0x1
#define KSAUDIO_QUALITY_BASIC               0x2
#define KSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define KSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} KSAUDIO_COPY_PROTECTION, *PKSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} KSAUDIO_CHANNEL_CONFIG, *PKSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#define KSAUDIO_SPEAKER_DIRECTOUT       0
#define KSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define KSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define KSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define KSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

// DVD Speaker Positions
#define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define KSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define KSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define KSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} KSAUDIO_DYNAMIC_RANGE, *PKSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} KSAUDIO_MIXLEVEL, *PKSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    LONG    Reset;
} KSAUDIO_MIX_CAPS, *PKSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    KSAUDIO_MIX_CAPS    Capabilities[1];
} KSAUDIO_MIXCAP_TABLE, *PKSAUDIO_MIXCAP_TABLE;

typedef enum {
    SE_TECH_NONE,
    SE_TECH_ANALOG_DEVICES_PHAT,
    SE_TECH_CREATIVE,
    SE_TECH_NATIONAL_SEMI,
    SE_TECH_YAMAHA_YMERSION,
    SE_TECH_BBE,
    SE_TECH_CRYSTAL_SEMI,
    SE_TECH_QSOUND_QXPANDER,
    SE_TECH_SPATIALIZER,
    SE_TECH_SRS,
    SE_TECH_PLATFORM_TECH,
    SE_TECH_AKM,
    SE_TECH_AUREAL,
    SE_TECH_AZTECH,
    SE_TECH_BINAURA,
    SE_TECH_ESS_TECH,
    SE_TECH_HARMAN_VMAX,
    SE_TECH_NVIDEA,
    SE_TECH_PHILIPS_INCREDIBLE,
    SE_TECH_TEXAS_INST,
    SE_TECH_VLSI_TECH
} SE_TECHNIQUE;

typedef struct {
    SE_TECHNIQUE    Technique;
    ULONG   Center;
    ULONG   Depth;
    ULONG   Reserved;
} KSAUDIO_STEREO_ENHANCE, *PKSAUDIO_STEREO_ENHANCE;

typedef enum {              // preferred device index
    KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

typedef struct {
    BOOL                             Enable;
    KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
    ULONG                            Flags;
    ULONG                            Reserved;
} KSAUDIO_PREFERRED_STATUS, *PKSAUDIO_PREFERRED_STATUS;
//===========================================================================
// Topology Node Type GUIDs

#define STATIC_KSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DAC);
#define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)

#define STATIC_KSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_ADC);
#define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)

#define STATIC_KSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SRC);
#define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)

#define STATIC_KSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUPERMIX);
#define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)

#define STATIC_KSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUX);
#define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)

#define STATIC_KSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", KSNODETYPE_DEMUX);
#define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)

#define STATIC_KSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUM);
#define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)

#define STATIC_KSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUTE);
#define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)

#define STATIC_KSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_VOLUME);
#define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)

#define STATIC_KSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_TONE);
#define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)

#define STATIC_KSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_EQUALIZER);
#define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)

#define STATIC_KSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_AGC);
#define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)

#define STATIC_KSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", KSNODETYPE_NOISE_SUPPRESS);
#define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)

#define STATIC_KSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DELAY);
#define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)

#define STATIC_KSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_LOUDNESS);
#define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)

#define STATIC_KSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_PROLOGIC_DECODER);
#define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)

#define STATIC_KSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_STEREO_WIDE);
#define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)

#define STATIC_KSNODETYPE_STEREO_ENHANCE\
    0xAF6878ACL, 0xE83F, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3", KSNODETYPE_STEREO_ENHANCE);
#define KSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_ENHANCE)

#define STATIC_KSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_REVERB);
#define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)

#define STATIC_KSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_CHORUS);
#define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)

#define STATIC_KSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_3D_EFFECTS);
#define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)

#define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL\
    0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS\
    0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_AGC\
    0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", KSALGORITHMINSTANCE_SYSTEM_AGC);
#define KSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR\
    0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)


#define STATIC_KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#define STATIC_KSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DEV_SPECIFIC);
#define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)

#define STATIC_KSNODETYPE_PROLOGIC_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_PROLOGIC_ENCODER);
#define KSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_ENCODER)
#define KSNODETYPE_SURROUND_ENCODER KSNODETYPE_PROLOGIC_ENCODER

#define STATIC_KSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", KSNODETYPE_PEAKMETER);
#define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_KSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_BASS);
#define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)

#define STATIC_KSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_TREBLE);
#define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)

#define STATIC_KSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_3D_STEREO);
#define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)

#define STATIC_KSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_VOLUME);
#define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)

#define STATIC_KSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_MUTE);
#define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)

#define STATIC_KSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_VOLUME);
#define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_MUTE);
#define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)

#define STATIC_KSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_VOLUME);
#define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)

#define STATIC_KSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_MUTE);
#define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)

#define STATIC_KSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_VOLUME);
#define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)

#define STATIC_KSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_MUTE);
#define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)

#define STATIC_KSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_VOLUME);
#define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)

#define STATIC_KSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_MUTE);
#define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)

#define STATIC_KSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_VOLUME);
#define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)

#define STATIC_KSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_MUTE);
#define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)

#define STATIC_KSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_SOURCE);
#define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)

#define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_VOLUME);
#define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_MUTE);
#define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_KSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_IN_VOLUME);
#define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_KSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_IN_VOLUME);
#define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)

#define STATIC_KSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN_VOLUME);
#define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_KSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_IN_VOLUME);
#define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_IN_VOLUME);
#define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_KSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_VOLUME_CONTROL);
#define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)

#define STATIC_KSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI);
#define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)

#define STATIC_KSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN);
#define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)

#define STATIC_KSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_CONTROL);
#define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)

#define STATIC_KSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_AUDIO);
#define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)

#define STATIC_KSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_VOLUME);
#define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)

#define STATIC_KSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_MUTE);
#define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)

#define STATIC_KSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX);
#define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)

#define STATIC_KSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER);
#define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)

#define STATIC_KSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_OUT_MIX);
#define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT);
#define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)

#define STATIC_KSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX);
#define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)

#define STATIC_KSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX);
#define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_VOLUME);
#define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_KSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_MUTE);
#define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_VOLUME);
#define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_MUTE);
#define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_VOLUME);
#define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_MUTE);
#define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MICROPHONE_BOOST);
#define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_ALTERNATE_MICROPHONE);
#define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_KSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_DEPTH);
#define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)

#define STATIC_KSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_CENTER);
#define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)

#define STATIC_KSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_VOLUME);
#define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)

#define STATIC_KSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_MUTE);
#define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)

#define STATIC_KSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", KSAUDFNAME_VIDEO);
#define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)

#define STATIC_KSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", KSAUDFNAME_PEAKMETER);
#define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)

// Internal topology node pin definitions

#define KSNODEPIN_STANDARD_IN       1
#define KSNODEPIN_STANDARD_OUT      0

#define KSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define KSNODEPIN_SUM_MUX_OUT       0

#define KSNODEPIN_DEMUX_IN          0
#define KSNODEPIN_DEMUX_OUT         1   // can be >= 1

#define KSNODEPIN_AEC_RENDER_IN     1
#define KSNODEPIN_AEC_RENDER_OUT    0
#define KSNODEPIN_AEC_CAPTURE_IN    2
#define KSNODEPIN_AEC_CAPTURE_OUT   3

//===========================================================================
//===========================================================================

#define STATIC_KSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", KSMETHODSETID_Wavetable);
#define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)

typedef enum {
    KSMETHOD_WAVETABLE_WAVE_ALLOC,
    KSMETHOD_WAVETABLE_WAVE_FREE,
    KSMETHOD_WAVETABLE_WAVE_FIND,
    KSMETHOD_WAVETABLE_WAVE_WRITE
} KSMETHOD_WAVETABLE;

typedef struct {
    KSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    KSDATAFORMAT        Format;                         // wave format
} KSWAVETABLE_WAVE_DESC, *PKSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Acoustic_Echo_Cancel\
    0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", KSPROPSETID_Acoustic_Echo_Cancel);
#define KSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(KSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
    KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
    KSPROPERTY_AEC_STATUS,
    KSPROPERTY_AEC_MODE
} KSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED             0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED    0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED       0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED               0x8

#define AEC_MODE_PASS_THROUGH           0x0
#define AEC_MODE_HALF_DUPLEX            0x1
#define AEC_MODE_FULL_DUPLEX            0x2

//===========================================================================
//===========================================================================
// @@BEGIN_MSINTERNAL
#define STATIC_KSPROPSETID_Wave_Queued\
    0x16a15b10L, 0x16f0, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("16a15b10-16f0-11d0-a195-0020afd156e4", KSPROPSETID_Wave_Queued);
#define KSPROPSETID_Wave_Queued DEFINE_GUIDNAMED(KSPROPSETID_Wave_Queued)

#define KSPROPERTY_WAVE_QUEUED_POSITION                 0x00000001

#define STATIC_KSMETHODSETID_Wave_Queued\
    0x7432c160L, 0x8827, 0x11cf, 0xa1, 0x02, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("7432c160-8827-11cf-a102-0020afd156e4", KSMETHODSETID_Wave_Queued);
#define KSMETHODSETID_Wave_Queued DEFINE_GUIDNAMED(KSMETHODSETID_Wave_Queued)

#define KSMETHOD_WAVE_QUEUED_BREAKLOOP                  0x00000001
// @@END_MSINTERNAL

#define STATIC_KSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", KSPROPSETID_Wave);
#define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)

typedef enum {
    KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    KSPROPERTY_WAVE_INPUT_CAPABILITIES,
    KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    KSPROPERTY_WAVE_BUFFER,
    KSPROPERTY_WAVE_FREQUENCY,
    KSPROPERTY_WAVE_VOLUME,
    KSPROPERTY_WAVE_PAN
} KSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} KSWAVE_COMPATCAPS, *PKSWAVE_COMPATCAPS;

#define KSWAVE_COMPATCAPS_INPUT                 0x00000000
#define KSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} KSWAVE_INPUT_CAPABILITIES, *PKSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} KSWAVE_OUTPUT_CAPABILITIES, *PKSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} KSWAVE_VOLUME, *PKSWAVE_VOLUME;

#define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define KSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} KSWAVE_BUFFER, *PKSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_KSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_PORT);
#define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)

#define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_SQSYNTH);
#define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_FMSYNTH);
#define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_WAVETABLE);
#define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", KSMUSIC_TECHNOLOGY_SWSYNTH);
#define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)

typedef struct {
   KSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} KSDATARANGE_MUSIC, *PKSDATARANGE_MUSIC;

//===========================================================================

#define STATIC_KSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", KSEVENTSETID_Cyclic);
#define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)

typedef enum {
    KSEVENT_CYCLIC_TIME_INTERVAL,
} KSEVENT_CYCLIC_TIME;

//===========================================================================
#define STATIC_KSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", KSEVENTSETID_AudioControlChange);
#define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)

typedef enum {
    KSEVENT_CONTROL_CHANGE,
} KSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================

#define STATIC_KSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", KSEVENTSETID_LoopedStreaming);
#define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)

typedef enum {
    KSEVENT_LOOPEDSTREAMING_POSITION,
} KSEVENT_LOOPEDSTREAMING;

typedef struct {
    KSEVENTDATA KsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;

// @@BEGIN_MSINTERNAL
//===========================================================================
#define STATIC_KSEVENTSETID_Sysaudio \
    0x04800320L, 0x4491, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("04800320-4491-11D1-A050-405705C10000", KSEVENTSETID_Sysaudio);
#define KSEVENTSETID_Sysaudio DEFINE_GUIDNAMED(KSEVENTSETID_Sysaudio)

typedef enum {
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
    KSEVENT_SYSAUDIO_CHANGE_DEVICE
} KSEVENT_SYSAUDIO;
// @@END_MSINTERNAL

//===========================================================================
#define STATIC_KSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio);
#define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
// @@BEGIN_MSINTERNAL
    KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE = 8,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK = 9,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK = 10,
    KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES = 11,
    KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX = 12,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY = 13,
// @@END_MSINTERNAL
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
// @@BEGIN_MSINTERNAL
    KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE = 15,
// @@END_MSINTERNAL
    KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16,
// @@BEGIN_MSINTERNAL
    KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX = 17
// @@END_MSINTERNAL
} KSPROPERTY_SYSAUDIO;

typedef struct {
    KSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;

// @@BEGIN_MSINTERNAL
typedef struct {
    BOOL        Enable;
    HANDLE      hGfx;
    ULONG       ulOrder;                    // Order of the GFX
    ULONG       ulType;                     // Type of the GFX
    ULONG       ulFlags;
    ULONG       ulDeviceNameOffset;         // DeviceInterface on which this GFX needs to be attached
    ULONG       ulFriendlyNameOffset;       // Friendly name of the GFX
} SYSAUDIO_GFX, *PSYSAUDIO_GFX;

#define GFX_DEVICETYPE_RENDER     1
#define GFX_DEVICETYPE_CAPTURE    2
// @@END_MSINTERNAL

typedef struct {
    KSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001

// @@BEGIN_MSINTERNAL
typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG Index;            // KSPROPERTY_SYSAUDIO_DEFAULT_TYPE
} SYSAUDIO_PREFERRED_DEVICE, *PSYSAUDIO_PREFERRED_DEVICE;

#define SYSAUDIO_FLAGS_CLEAR_PREFERRED          0x00000002
// @@END_MSINTERNAL

#define STATIC_KSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio_Pin);
#define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)

typedef enum {
// @@BEGIN_MSINTERNAL
    KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX = 0,
// @@END_MSINTERNAL
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1,
// @@BEGIN_MSINTERNAL
    KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE = 2
// @@END_MSINTERNAL
} KSPROPERTY_SYSAUDIO_PIN;

typedef struct {
    KSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

//===========================================================================
typedef struct {
    KSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} KSNODEPROPERTY, *PKSNODEPROPERTY;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} KSNODEPROPERTY_AUDIO_CHANNEL, *PKSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} KSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_3D_LISTENER, *PKSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_PROPERTY, *PKSNODEPROPERTY_AUDIO_PROPERTY;

//===========================================================================
// {79A9312E-59AE-43b0-A350-8B05284CAB24}
#define STATIC_KSPROPSETID_AudioGfx\
    0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", KSPROPSETID_AudioGfx);
#define KSPROPSETID_AudioGfx DEFINE_GUIDNAMED(KSPROPSETID_AudioGfx)

typedef enum {
    KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
    KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} KSPROPERTY_AUDIOGFX;

//===========================================================================

//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_KSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", KSDATAFORMAT_TYPE_MUSIC);
#define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_KSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_MIDI);
#define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI);
#define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    KSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicKS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the KSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} KSMUSICFORMAT, *PKSMUSICFORMAT;

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new KS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with KS_MPEGVIDEOINFO2 defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with KS_MPEGAUDIOINFO defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Video);
#define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PES);
#define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_KSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", KSPROPSETID_Mpeg2Vid);
#define  KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( KSPROPSETID_Mpeg2Vid )


typedef enum {
    KSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    KSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    KSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    KSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    KSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} KSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define KSMPEGVIDMODE_PANSCAN   0x0001
#define KSMPEGVIDMODE_LTRBOX    0x0002
#define KSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _KSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} KSMPEGVID_RECT, *PKSMPEGVID_RECT;

//
// Params for pan / scan
//


//
// MPEG2 Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_KSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", KSPROPSETID_AC3);
#define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)

typedef enum {
    KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    KSPROPERTY_AC3_ALTERNATE_AUDIO,
    KSPROPERTY_AC3_DOWNMIX,
    KSPROPERTY_AC3_BIT_STREAM_MODE,
    KSPROPERTY_AC3_DIALOGUE_LEVEL,
    KSPROPERTY_AC3_LANGUAGE_CODE,
    KSPROPERTY_AC3_ROOM_TYPE
} KSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} KSAC3_ERROR_CONCEALMENT, *PKSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} KSAC3_ALTERNATE_AUDIO, *PKSAC3_ALTERNATE_AUDIO;

#define KSAC3_ALTERNATE_AUDIO_1     1
#define KSAC3_ALTERNATE_AUDIO_2     2
#define KSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} KSAC3_DOWNMIX, *PKSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} KSAC3_BIT_STREAM_MODE, *PKSAC3_BIT_STREAM_MODE;

#define KSAC3_SERVICE_MAIN_AUDIO            0
#define KSAC3_SERVICE_NO_DIALOG             1
#define KSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define KSAC3_SERVICE_HEARING_IMPAIRED      3
#define KSAC3_SERVICE_DIALOG_ONLY           4
#define KSAC3_SERVICE_COMMENTARY            5
#define KSAC3_SERVICE_EMERGENCY_FLASH       6
#define KSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} KSAC3_DIALOGUE_LEVEL, *PKSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} KSAC3_ROOM_TYPE, *PKSAC3_ROOM_TYPE;


//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)


//
// audio decoder output properties
//

#define STATIC_KSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", KSPROPSETID_AudioDecoderOut);
#define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)

typedef enum {
    KSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    KSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} KSPROPERTY_AUDDECOUT;

#define KSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define KSAUDDECOUTMODE_PCM_51          0x0002
#define KSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_KSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", KSPROPSETID_DvdSubPic);
#define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)

typedef enum {
    KSPROPERTY_DVDSUBPIC_PALETTE,
    KSPROPERTY_DVDSUBPIC_HLI,
    KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} KSPROPERTY_DVDSUBPIC;

typedef struct _KS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} KS_DVD_YCrCb, *PKS_DVD_YCrCb;

/* The KS_DVD_YUV structure is now superseded by KS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _KS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} KS_DVD_YUV, *PKS_DVD_YUV;

typedef struct _KSPROPERTY_SPPAL {
    KS_DVD_YUV sppal[16];
} KSPROPERTY_SPPAL, *PKSPROPERTY_SPPAL;

typedef struct _KS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} KS_COLCON, *PKS_COLCON;

typedef struct _KSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    KS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} KSPROPERTY_SPHLI, *PKSPROPERTY_SPHLI;

typedef BOOL KSPROPERTY_COMPOSIT_ON, *PKSPROPERTY_COMPOSIT_ON;

#define STATIC_KSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", KSPROPSETID_CopyProt);
#define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)

typedef enum {

    KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    KSPROPERTY_DVDCOPY_DVD_KEY1,
    KSPROPERTY_DVDCOPY_DEC_KEY2,
    KSPROPERTY_DVDCOPY_TITLE_KEY,
    KSPROPERTY_COPY_MACROVISION,
    KSPROPERTY_DVDCOPY_REGION,
    KSPROPERTY_DVDCOPY_SET_COPY_STATE,
    KSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} KSPROPERTY_COPYPROT;

typedef struct _KS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} KS_DVDCOPY_CHLGKEY, *PKS_DVDCOPY_CHLGKEY;

typedef struct _KS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} KS_DVDCOPY_BUSKEY, *PKS_DVDCOPY_BUSKEY;


typedef struct _KS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} KS_DVDCOPY_DISCKEY, *PKS_DVDCOPY_DISCKEY;

typedef struct _KS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} KS_DVDCOPY_REGION, *PKS_DVDCOPY_REGION;

typedef struct _KS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} KS_DVDCOPY_TITLEKEY, *PKS_DVDCOPY_TITLEKEY;

typedef struct _KS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} KS_COPY_MACROVISION, *PKS_COPY_MACROVISION;

typedef struct _KS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} KS_DVDCOPY_SET_COPY_STATE, *PKS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    KS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    KS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    KS_DVDCOPYSTATE_DONE,
} KS_DVDCOPYSTATE;

typedef enum {
    KS_MACROVISION_DISABLED,
    KS_MACROVISION_LEVEL1,
    KS_MACROVISION_LEVEL2,
    KS_MACROVISION_LEVEL3
} KS_COPY_MACROVISION_LEVEL, *PKS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define KS_DVD_CGMS_RESERVED_MASK      0x00000078

#define KS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define KS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define KS_DVD_CGMS_COPY_ONCE          0x00000010
#define KS_DVD_CGMS_NO_COPY            0x00000018

#define KS_DVD_COPYRIGHT_MASK          0x00000040
#define KS_DVD_NOT_COPYRIGHTED         0x00000000
#define KS_DVD_COPYRIGHTED             0x00000040

#define KS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define KS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define KS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_KSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVTUNER);
#define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)

#define STATIC_KSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_CROSSBAR);
#define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)

#define STATIC_KSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVAUDIO);
#define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)

#define STATIC_KSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_VPMUX);
#define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)

#define STATIC_KSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", KSCATEGORY_VBICODEC);
#define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)

// SUBTYPE_VPVideo
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVideo);
#define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)

// SUBTYPE_VPVBI
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVBI);
#define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)


// FORMAT_VideoInfo
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGVIDEO);
#define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

// FORMAT_VBI
#define STATIC_KSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VBI);
#define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_KSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_TYPE_VBI);
#define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_KSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", KSDATAFORMAT_SUBTYPE_RAW8);
#define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)

// MEDIASUBTYPE_CC
#define STATIC_KSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", KSDATAFORMAT_SUBTYPE_CC);
#define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)

// MEDIASUBTYPE_NABTS
#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_NABTS);
#define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_TELETEXT);
#define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define KS_BI_RGB        0L
#define KS_BI_RLE8       1L
#define KS_BI_RLE4       2L
#define KS_BI_BITFIELDS  3L

typedef struct tagKS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} KS_RGBQUAD, *PKS_RGBQUAD;

/* constants for palettes */
#define KS_iPALETTE_COLORS 256     // Maximum colours in palette
#define KS_iEGA_COLORS 16          // Number colours in EGA palette
#define KS_iMASK_COLORS 3          // Maximum three components
#define KS_iTRUECOLOR 16           // Minimum true colour device
#define KS_iRED 0                  // Index position for RED mask
#define KS_iGREEN 1                // Index position for GREEN mask
#define KS_iBLUE 2                 // Index position for BLUE mask
#define KS_iPALETTE 8              // Maximum colour depth using a palette
#define KS_iMAXBITS 8              // Maximum bits per colour component
#define KS_SIZE_EGA_PALETTE (KS_iEGA_COLORS * sizeof(KS_RGBQUAD))
#define KS_SIZE_PALETTE (KS_iPALETTE_COLORS * sizeof(KS_RGBQUAD))

typedef struct tagKS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} KS_BITMAPINFOHEADER, *PKS_BITMAPINFOHEADER;

// Used for true colour images that also have a palette

typedef struct tag_KS_TRUECOLORINFO {
    DWORD   dwBitMasks[KS_iMASK_COLORS];
    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
} KS_TRUECOLORINFO, *PKS_TRUECOLORINFO;


#define KS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define KS_DIBWIDTHBYTES(bi) (DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define KS__DIBSIZE(bi) (KS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define KS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagKS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

} KS_VIDEOINFOHEADER, *PKS_VIDEOINFOHEADER;

// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagKS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

    union {
        KS_RGBQUAD          bmiColors[KS_iPALETTE_COLORS];     // Colour palette
        DWORD               dwBitMasks[KS_iMASK_COLORS];       // True colour masks
        KS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} KS_VIDEOINFO, *PKS_VIDEOINFO;


#define KS_SIZE_MASKS (KS_iMASK_COLORS * sizeof(DWORD))
#define KS_SIZE_PREHEADER (FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define KS_SIZE_VIDEOHEADER (sizeof(KS_BITMAPINFOHEADER) + KS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define KS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast, WST
typedef struct tagKS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // KS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} KS_VBIINFOHEADER, *PKS_VBIINFOHEADER;

// VBI Sampling Rates
#define KS_VBIDATARATE_NABTS            (5727272L)
#define KS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define KS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER (KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagKS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} KS_ANALOGVIDEOINFO, *PKS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define KS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define KS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagKS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // KS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // KS_AnalogVideoStandard
   DWORD                    dwChannel;
} KS_TVTUNER_CHANGE_INFO, *PKS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format blocks
//===========================================================================

typedef enum {
    KS_MPEG2Level_Low,
    KS_MPEG2Level_Main,
    KS_MPEG2Level_High1440,
    KS_MPEG2Level_High
} KS_MPEG2Level;

typedef enum {
    KS_MPEG2Profile_Simple,
    KS_MPEG2Profile_Main,
    KS_MPEG2Profile_SNRScalable,
    KS_MPEG2Profile_SpatiallyScalable,
    KS_MPEG2Profile_High
} KS_MPEG2Profile;

#define KS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define KS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define KS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define KS_INTERLACE_UNUSED                  0x00000008  //
#define KS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define KS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define KS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define KS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define KS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define KS_INTERLACE_DisplayModeMask         0x000000c0
#define KS_INTERLACE_DisplayModeBobOnly      0x00000000
#define KS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define KS_INTERLACE_DisplayModeBobOrWeave   0x00000080



#define KS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define KS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define KS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define KS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define KS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define KS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define KS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define KS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define KS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

typedef struct tagKS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER2, *PKS_VIDEOINFOHEADER2;

typedef struct tagKS_MPEG1VIDEOINFO {
    KS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} KS_MPEG1VIDEOINFO, *PKS_MPEG1VIDEOINFO;

#define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define KS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(KS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagKS_MPEGVIDEOINFO2 {
    KS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} KS_MPEGVIDEOINFO2, *PKS_MPEGVIDEOINFO2;


#define KS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(KS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format blocks
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define KS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagKS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use KS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} KS_MPEGAUDIOINFO, *PKS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER      VideoInfoHeader;
} KS_DATAFORMAT_VIDEOINFOHEADER, *PKS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2 {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER2     VideoInfoHeader2;
} KS_DATAFORMAT_VIDEOINFOHEADER2, *PKS_DATAFORMAT_VIDEOINFOHEADER2;

typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFO            VideoInfo;
} KS_DATAFORMAT_VIDEOINFO_PALETTE, *PKS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagKS_DATAFORMAT_VBIINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_DATAFORMAT_VBIINFOHEADER, *PKS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _KS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} KS_VIDEO_STREAM_CONFIG_CAPS, *PKS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagKS_DATARANGE_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO, *PKS_DATARANGE_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO2 {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO2, *PKS_DATARANGE_VIDEO2;

typedef struct tagKS_DATARANGE_MPEG1_VIDEO {
    KSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // KS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // KS_VIDEO_ALLOC_*
    KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    KS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} KS_DATARANGE_MPEG1_VIDEO, *PKS_DATARANGE_MPEG1_VIDEO;

typedef struct tagKS_DATARANGE_MPEG2_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} KS_DATARANGE_MPEG2_VIDEO, *PKS_DATARANGE_MPEG2_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO_PALETTE {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFO                 VideoInfo;              // default format
} KS_DATARANGE_VIDEO_PALETTE, *PKS_DATARANGE_VIDEO_PALETTE;

typedef struct tagKS_DATARANGE_VIDEO_VBI {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VBIINFOHEADER             VBIInfoHeader;          // default format
} KS_DATARANGE_VIDEO_VBI, *PKS_DATARANGE_VIDEO_VBI;

typedef struct tagKS_DATARANGE_ANALOGVIDEO {
   KSDATARANGE                  DataRange;
   KS_ANALOGVIDEOINFO           AnalogVideoInfo;
} KS_DATARANGE_ANALOGVIDEO, *PKS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define KS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define KS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define KS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define KS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define KS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define KS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define KS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define KS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define KS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define KS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define KS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define KS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory

//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_KSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", KSPROPSETID_VBICAP_PROPERTIES);
#define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} KSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define KS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define KS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define KS_VBICAP_PROTECTION_MV_DETECTED    0x0004L


/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networks in network television data
#define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_KSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_TYPE_NABTS);
#define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_KSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", KSPROPSETID_VBICodecFiltering);
#define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)

typedef enum {
    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_STATISTICS,
} KSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see KS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

// These KS_CC_SUBSTREAM_* bitmasks are used with VBICODECFILTERING_CC_SUBSTREAMS
#define KS_CC_SUBSTREAM_ODD               0x0001L // Unfiltered Field 1 Data
#define KS_CC_SUBSTREAM_EVEN              0x0002L // Unfiltered Field 2 Data

// The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
#define KS_CC_SUBSTREAM_FIELD1_MASK    	  0x00F0L
#define KS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define KS_CC_SUBSTREAM_SERVICE_CC2       0x0020L
#define KS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define KS_CC_SUBSTREAM_SERVICE_T2        0x0080L

// The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
#define KS_CC_SUBSTREAM_FIELD2_MASK       0x1F00L
#define KS_CC_SUBSTREAM_SERVICE_CC3       0x0100L
#define KS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define KS_CC_SUBSTREAM_SERVICE_T3        0x0400L
#define KS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define KS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

// Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
// If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // KS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

//////////////////////////////////////////////////////////////
// WST Codec Teletext Media Sample Format
//////////////////////////////////////////////////////////////

#define WST_TVTUNER_CHANGE_BEGIN_TUNE    0x1000L  // Starting a tuning operation
#define WST_TVTUNER_CHANGE_END_TUNE      0x2000L  // Ending a tuning operation

#define MAX_WST_VBI_LINES_PER_FIELD   17
#define WST_BYTES_PER_LINE            42

typedef struct _WST_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE, *PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
    VBICODECFILTERING_SCANLINES        ScanlinesRequested;
    WST_BUFFER_LINE                    WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER, *PWST_BUFFER;

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received KS_TVTUNER_CHANGE_BEGIN_TUNE and KS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received KS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_TELETEXT, *PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN, *PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on KSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} KSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)

//===========================================================================
// KSSTREAM_HEADER extensions for digital video
//===========================================================================

#define KS_VIDEO_FLAG_FRAME      0x0000L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FIELD1     0x0001L
#define KS_VIDEO_FLAG_FIELD2     0x0002L

#define KS_VIDEO_FLAG_I_FRAME    0x0000L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_P_FRAME    0x0010L
#define KS_VIDEO_FLAG_B_FRAME    0x0020L

typedef struct tagKS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    // Reserved fields, never reference these
    DWORD                   Reserved1;
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} KS_FRAME_INFO, *PKS_FRAME_INFO;

//===========================================================================
// KSSTREAM_HEADER extensions for VBI
//===========================================================================

#define KS_VBI_FLAG_FIELD1               0x0001L
#define KS_VBI_FLAG_FIELD2               0x0002L

#define KS_VBI_FLAG_MV_PRESENT           0x0100L
#define KS_VBI_FLAG_MV_HARDWARE          0x0200L
#define KS_VBI_FLAG_MV_DETECTED          0x0400L

#define KS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagKS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    KS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_VBI_FRAME_INFO, *PKS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================

typedef enum
{
    KS_AnalogVideo_None     = 0x00000000,  // This is a digital sensor
    KS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    KS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    KS_AnalogVideo_NTSC_433 = 0x00000004,

    KS_AnalogVideo_PAL_B    = 0x00000010,
    KS_AnalogVideo_PAL_D    = 0x00000020,
    KS_AnalogVideo_PAL_G    = 0x00000040,
    KS_AnalogVideo_PAL_H    = 0x00000080,
    KS_AnalogVideo_PAL_I    = 0x00000100,
    KS_AnalogVideo_PAL_M    = 0x00000200,
    KS_AnalogVideo_PAL_N    = 0x00000400,

    KS_AnalogVideo_PAL_60   = 0x00000800,

    KS_AnalogVideo_SECAM_B  = 0x00001000,
    KS_AnalogVideo_SECAM_D  = 0x00002000,
    KS_AnalogVideo_SECAM_G  = 0x00004000,
    KS_AnalogVideo_SECAM_H  = 0x00008000,
    KS_AnalogVideo_SECAM_K  = 0x00010000,
    KS_AnalogVideo_SECAM_K1 = 0x00020000,
    KS_AnalogVideo_SECAM_L  = 0x00040000,
    KS_AnalogVideo_SECAM_L1 = 0x00080000,

    KS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
} KS_AnalogVideoStandard;

#define KS_AnalogVideo_NTSC_Mask  0x00000007
#define KS_AnalogVideo_PAL_Mask   0x00100FF0
#define KS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,     // R O (return 2 DWORDs specifying surface size)
    // W I (informn a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
 
    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
} KSPROPERTY_ALLOCATOR_CONTROL;

typedef struct {
    //KSPROPERTY Property;
    ULONG	CX;
	ULONG	CY;
} KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S; 
 
typedef struct {
    //KSPROPERTY Property;
    ULONG	InterleavedCapSupported;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

 
typedef struct {
    //KSPROPERTY Property;
    ULONG	InterleavedCapPossible;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,            // RW O
    KSPROPERTY_VIDEOPROCAMP_CONTRAST,              // RW O
    KSPROPERTY_VIDEOPROCAMP_HUE,                   // RW O
    KSPROPERTY_VIDEOPROCAMP_SATURATION,            // RW O
    KSPROPERTY_VIDEOPROCAMP_SHARPNESS,             // RW O
    KSPROPERTY_VIDEOPROCAMP_GAMMA,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_COLORENABLE,           // RW O
    KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,          // RW O
    KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,// RW O
    KSPROPERTY_VIDEOPROCAMP_GAIN,                  // RW O
} KSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    KSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_S, *PKSPROPERTY_VIDEOPROCAMP_S;

#define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================

#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    KSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    KSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    KSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    KSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    KSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    KSPROPERTY_TUNER_INPUT,             // RW -select an input
    KSPROPERTY_TUNER_STATUS,            // R  -tuning status
    KSPROPERTY_TUNER_IF_MEDIUM          // R O-Medium for IF or Transport Pin
} KSPROPERTY_TUNER;

typedef enum {
    KSPROPERTY_TUNER_MODE_TV            = 0X0001,
    KSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    KSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    KSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    KSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} KSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in KSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    KS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    KS_TUNER_TUNING_FINE,             // Fine grained search
    KS_TUNER_TUNING_COARSE,           // Coarse search
}KS_TUNER_TUNING_FLAGS;

typedef enum {
    KS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    KS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}KS_TUNER_STRATEGY;

typedef struct {
    KSPROPERTY Property;
    ULONG  ModesSupported;              // KS_PROPERTY_TUNER_MODES_*
    KSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_CAPS_S, *PKSPROPERTY_TUNER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_IF_MEDIUM_S, *PKSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // KS_TUNER_STRATEGY
} KSPROPERTY_TUNER_MODE_CAPS_S, *PKSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
} KSPROPERTY_TUNER_MODE_S, *PKSPROPERTY_TUNER_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // KS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} KSPROPERTY_TUNER_FREQUENCY_S, *PKSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Standard;                    // KS_AnalogVideo_*
} KSPROPERTY_TUNER_STANDARD_S, *PKSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} KSPROPERTY_TUNER_INPUT_S, *PKSPROPERTY_TUNER_INPUT_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} KSPROPERTY_TUNER_STATUS_S, *PKSPROPERTY_TUNER_STATUS_S;

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    KSEVENT_TUNER_CHANGED
} KSEVENT_TUNER;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    KSPROPERTY_VIDEOENCODER_CAPS,                       // R
    KSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    KSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    KSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} KSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} KSPROPERTY_VIDEOENCODER_S, *PKSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    KSPROPERTY_VIDEODECODER_CAPS,                       // R
    KSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    KSPROPERTY_VIDEODECODER_STATUS,                     // R
    KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    KSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
} KSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}KS_VIDEODECODER_FLAGS;

typedef struct {
    KSPROPERTY Property;
    ULONG      StandardsSupported;      // KS_AnalogVideo_*
    ULONG      Capabilities;            // KS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} KSPROPERTY_VIDEODECODER_CAPS_S, *PKSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} KSPROPERTY_VIDEODECODER_STATUS_S, *PKSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} KSPROPERTY_VIDEODECODER_S, *PKSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    KSEVENT_VIDEODECODER_CHANGED
} KSEVENT_VIDEODECODER;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    KSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    KSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    KSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    KSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    KSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    KSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    KSPROPERTY_CAMERACONTROL_FOCUS,                     // RW O
} KSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_S, *PKSPROPERTY_CAMERACONTROL_S;

#define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L

#define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    KSPROPERTY_CROSSBAR_CAPS,                     // R
    KSPROPERTY_CROSSBAR_PININFO,                  // R
    KSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    KSPROPERTY_CROSSBAR_ROUTE,                    // RW
} KSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    KSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} KSPROPERTY_CROSSBAR_CAPS_S, *PKSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_DATAFLOW Direction;     // KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // KS_PhysConn_Video_* or KS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    KSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} KSPROPERTY_CROSSBAR_PININFO_S, *PKSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} KSPROPERTY_CROSSBAR_ROUTE_S, *PKSPROPERTY_CROSSBAR_ROUTE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    KSEVENT_CROSSBAR_CHANGED
} KSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    KS_PhysConn_Video_Tuner = 1,
    KS_PhysConn_Video_Composite,
    KS_PhysConn_Video_SVideo,
    KS_PhysConn_Video_RGB,
    KS_PhysConn_Video_YRYBY,
    KS_PhysConn_Video_SerialDigital,
    KS_PhysConn_Video_ParallelDigital,
    KS_PhysConn_Video_SCSI,
    KS_PhysConn_Video_AUX,
    KS_PhysConn_Video_1394,
    KS_PhysConn_Video_USB,
    KS_PhysConn_Video_VideoDecoder,
    KS_PhysConn_Video_VideoEncoder,
    KS_PhysConn_Video_SCART,

    KS_PhysConn_Audio_Tuner = 4096,
    KS_PhysConn_Audio_Line,
    KS_PhysConn_Audio_Mic,
    KS_PhysConn_Audio_AESDigital,
    KS_PhysConn_Audio_SPDIFDigital,
    KS_PhysConn_Audio_SCSI,
    KS_PhysConn_Audio_AUX,
    KS_PhysConn_Audio_1394,
    KS_PhysConn_Audio_USB,
    KS_PhysConn_Audio_AudioDecoder,
} KS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSPROPERTY_TVAUDIO_CAPS,                            // R
    KSPROPERTY_TVAUDIO_MODE,                            // RW
    KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} KSPROPERTY_VIDCAP_TVAUDIO;

#define KS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define KS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define KS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define KS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define KS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language

typedef struct {
    KSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of KS_TVAUDIO_MODE_*
    KSPIN_MEDIUM InputMedium;
    KSPIN_MEDIUM OutputMedium;
} KSPROPERTY_TVAUDIO_CAPS_S, *PKSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Mode;                     // KS_TVAUDIO_MODE_*
} KSPROPERTY_TVAUDIO_S, *PKSPROPERTY_TVAUDIO_S;


#define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", KSEVENTSETID_VIDCAP_TVAUDIO);
#define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSEVENT_TVAUDIO_CHANGED,
} KSEVENT_TVAUDIO;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    KSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    KSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE,           // RW
} KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    KS_CompressionCaps_CanQuality = 1,
    KS_CompressionCaps_CanCrunch = 2,
    KS_CompressionCaps_CanKeyFrame = 4,
    KS_CompressionCaps_CanBFrame = 8,
    KS_CompressionCaps_CanWindow = 0x10,
} KS_CompressionCaps;

typedef struct {
    KSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // KS_CompressionCaps_*
} KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} KSPROPERTY_VIDEOCOMPRESSION_S, *PKSPROPERTY_VIDEOCOMPRESSION_S;

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_OVERLAY);
#define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_KSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", KSPROPSETID_OverlayUpdate);
#define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)

typedef enum {
    KSPROPERTY_OVERLAYUPDATE_INTERESTS,
    KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} KSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} KSDISPLAYCHANGE, *PKSDISPLAYCHANGE;

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(KSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    KSPROPERTY_VIDEOCONTROL_CAPS,               // R
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    KSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    KSPROPERTY_VIDEOCONTROL_MODE,               // RWO
} KSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    KS_VideoControlFlag_FlipHorizontal        = 0x0001,
    KS_VideoControlFlag_FlipVertical          = 0x0002,
    KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,    // ***WARNING *** Flag msimatch with DSHOW.
    KS_Obsolete_VideoControlFlag_Trigger               = 0x0020,  // ***WARNING *** Flag msimatch with DSHOW.
    KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
    KS_VideoControlFlag_Trigger                      = 0x0008,
} KS_VideoControlFlags;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_CAPS_S, *PKSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_MODE_S, *PKSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// KSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    KSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} KSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    KSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} KSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_KSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", KSPROPSETID_VPConfig);
#define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)

#define STATIC_KSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", KSPROPSETID_VPVBIConfig);
#define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    KSPROPERTY_VPCONFIG_GETCONNECTINFO,
    KSPROPERTY_VPCONFIG_SETCONNECTINFO,
    KSPROPERTY_VPCONFIG_VPDATAINFO,
    KSPROPERTY_VPCONFIG_MAXPIXELRATE,
    KSPROPERTY_VPCONFIG_INFORMVPINPUT,
    KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_INVERTPOLARITY,
    KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_DDRAWHANDLE,
    KSPROPERTY_VPCONFIG_VIDEOPORTID,
    KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    KSPROPERTY_VPCONFIG_SURFACEPARAMS
} KSPROPERTY_VPCONFIG;

//=========================
// IBasicAudio
//
#define STATIC_CLSID_KsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_KsIBasicAudioInterfaceHandler);
#define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)


#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    AMVPSIZE        Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    DWORD dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    KS_PixAspectRatio_NTSC4x3,
    KS_PixAspectRatio_NTSC16x9,
    KS_PixAspectRatio_PAL4x3,
    KS_PixAspectRatio_PAL16x9,
} KS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    KS_AMVP_DO_NOT_CARE,
    KS_AMVP_BEST_BANDWIDTH,
    KS_AMVP_INPUT_SAME_AS_OUTPUT
} KS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    KS_AMVP_MODE_WEAVE,
    KS_AMVP_MODE_BOBINTERLEAVED,
    KS_AMVP_MODE_BOBNONINTERLEAVED,
    KS_AMVP_MODE_SKIPEVEN,
    KS_AMVP_MODE_SKIPODD
} KS_AMVP_MODE ;

typedef struct tagKS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} KS_AMVPDIMINFO, *PKS_AMVPDIMINFO ;

typedef struct tagKS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    KS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} KS_AMVPDATAINFO, *PKS_AMVPDATAINFO;

typedef struct tagKS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} KS_AMVPSIZE, *PKS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    KS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    KS_AMVPSIZE     Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_KSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", KSEVENTSETID_VPNotify);
#define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)

typedef enum {
    KSEVENT_VPNOTIFY_FORMATCHANGE,
} KSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_KSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", KSEVENTSETID_VIDCAPTOSTI);
#define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    KSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
} KSEVENT_VIDCAPTOSTI;


//
//  IVPVBINotify event notification
//
#define STATIC_KSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", KSEVENTSETID_VPVBINotify);
#define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)

typedef enum {
    KSEVENT_VPVBINOTIFY_FORMATCHANGE,
} KSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", KSDATAFORMAT_TYPE_AUXLine21Data);
#define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _KSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} KSGOP_USERDATA, *PKSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define KS_AM_UseNewCSSKey    0x1


// -----------------------------------------------------------------------
// KS_AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_KSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", KSPROPSETID_TSRateChange);
#define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)
typedef enum {
    KS_AM_RATE_SimpleRateChange=1,  // rw, use KS_AM_SimpleRateChange
    KS_AM_RATE_ExactRateChange=2,   // rw, use KS_AM_ExactRateChange
    KS_AM_RATE_MaxFullDataRate=3,   // r, use KS_AM_MaxFullDataRate
    KS_AM_RATE_Step=4               // w, use KS_AM_Step
} KS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_SimpleRateChange, *PKS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_ExactRateChange, *PKS_AM_ExactRateChange;

typedef LONG KS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD KS_AM_Step; // number of frame to step

//===========================================================================
//ENCODER API DEFINITIONS
//===========================================================================

#define STATIC_KSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)

#define STATIC_KSCATEGORY_MULTIPLEXER \
    0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", KSCATEGORY_MULTIPLEXER);
#define KSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE \
    0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE \
    0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE \
    0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#endif // __ENCODER_API_GUIDS__

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__

typedef enum {

    //
    // Bit rate used for encoding is constant
    //
    ConstantBitRate = 0,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as a guaranteed average over a specified window.  The default window 
    // size is considered to be 5 minutes.
    //
    VariableBitRateAverage,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as an average with a peak not to exceed the specified peak bitrate over 
    // a specified window.  The default window size is considered to be 500ms 
    // (classically one GOP).
    //
    VariableBitRatePeak

} VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__

#endif // !defined(_KSMEDIA_)

// @@BEGIN_MSINTERNAL
#if !defined(_KSMEDIAP_)
#define _KSMEDIAP_

#define CORE_AUDIO_BUFFER_DURATION_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\AudioSrv"
#define CORE_AUDIO_BUFFER_DURATION_VALUE L"CoreAudioBufferDuration"

#define DEFAULT_CORE_AUDIO_BUFFER_DURATION 10000    // duration in usec.
#define MAX_CORE_AUDIO_BUFFER_DURATION 20000
#define MIN_CORE_AUDIO_BUFFER_DURATION 1000

#endif // !defined(_KSMEDIAP_)
// @@END_MSINTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\ksguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ksguid.c
//
//--------------------------------------------------------------------------

#include <wdm.h>
#include <windef.h>
#define NOBITMAP
#include <ksguid.h>
#include <mmreg.h>

//
// Create a separate library for the SDK which does not separate the
// guids out from the .text section.
//
#ifdef DDK_KS
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA
#endif // SDK_KS

// include swenum.h first so that a separate guid entry is made for the BUSID.
#include <swenum.h>
#include <ks.h>
#include <ksi.h>
#include <ksmediap.h>
#include <ksproxy.h>
// remove this, since basetyps.h defines it again.
#undef DEFINE_GUID
#include <unknown.h>
// set the version to less than 1100 so that guids are defined for the library.
#ifdef _MSC_VER
#undef _MSC_VER
#endif // _MSC_VER
#define _MSC_VER 0
#include <kcom.h>
#include <stdarg.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\ntddsnap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddsnap.h

Abstract:

    This header file defines the public interface for the volume snapshot
    driver.

Author:

    Norbert P. Kusters  (norbertk)  30-July-1999

Notes:

Revision History:

    Adi Oltean          (aoltean)   08-May-2001 - Added Application Info GUID for Client accessible snapshots

--*/

#ifndef _NTDDSNAP_
#define _NTDDSNAP_

#define VOLSNAPCONTROLTYPE  ((ULONG) 'S') // ntifs

//
// The following IOCTLs are intended for proper volumes.
//

#define IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES         CTL_CODE(VOLSNAPCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // ntifs
#define IOCTL_VOLSNAP_RELEASE_WRITES                CTL_CODE(VOLSNAPCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT          CTL_CODE(VOLSNAPCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT       CTL_CODE(VOLSNAPCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_COMMIT_SNAPSHOT               CTL_CODE(VOLSNAPCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT           CTL_CODE(VOLSNAPCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS      CTL_CODE(VOLSNAPCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_CLEAR_DIFF_AREA               CTL_CODE(VOLSNAPCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA       CTL_CODE(VOLSNAPCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_DIFF_AREA               CTL_CODE(VOLSNAPCONTROLTYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE        CTL_CODE(VOLSNAPCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES         CTL_CODE(VOLSNAPCONTROLTYPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT        CTL_CODE(VOLSNAPCONTROLTYPE, 12, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_AUTO_CLEANUP                  CTL_CODE(VOLSNAPCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_DELETE_SNAPSHOT               CTL_CODE(VOLSNAPCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_EPIC                    CTL_CODE(VOLSNAPCONTROLTYPE, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_QUERY_OFFLINE                 CTL_CODE(VOLSNAPCONTROLTYPE, 21, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following IOCTLs are intended for volume snapshots.
//

#define IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME    CTL_CODE(VOLSNAPCONTROLTYPE, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_QUERY_CONFIG_INFO             CTL_CODE(VOLSNAPCONTROLTYPE, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_SET_APPLICATION_INFO          CTL_CODE(VOLSNAPCONTROLTYPE, 102, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_APPLICATION_INFO        CTL_CODE(VOLSNAPCONTROLTYPE, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input buffer for IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES.
//

typedef struct _VOLSNAP_FLUSH_AND_HOLD_INPUT {
    GUID    InstanceId;
    ULONG   NumberOfVolumesToFlush;
    USHORT  SecondsToHoldFileSystemsTimeout;    // 60 seconds recommended.
    USHORT  SecondsToHoldIrpsTimeout;           // 10 seconds recommended.
} VOLSNAP_FLUSH_AND_HOLD_INPUT, *PVOLSNAP_FLUSH_AND_HOLD_INPUT;

//
// Input buffer for IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT.
//

#define VOLSNAP_ATTRIBUTE_PERSISTENT    (0x1)
#define VOLSNAP_ALL_ATTRIBUTES          (0x1)

typedef struct _VOLSNAP_PREPARE_INFO {
    ULONG       Attributes;
    ULONG       Reserved;                   // Must be 0.
    LONGLONG    InitialDiffAreaAllocation;  // 100 MB recommended.
} VOLSNAP_PREPARE_INFO, *PVOLSNAP_PREPARE_INFO;

//
// Output buffer for IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT.
// Input buffer for IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA.
// Output buffer for IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.
// Input buffer for IOCTL_VOLSNAP_DELETE_SNAPSHOT.
//

typedef struct _VOLSNAP_NAME {
    USHORT  NameLength;
    WCHAR   Name[1];
} VOLSNAP_NAME, *PVOLSNAP_NAME;

//
// Input buffer for IOCTL_VOLSNAP_SET_DIFF_AREA.
// Output buffer for IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS and
// IOCTL_VOLSNAP_QUERY_DIFF_AREA.
//

typedef struct _VOLSNAP_NAMES {
    ULONG   MultiSzLength;
    WCHAR   Names[1];
} VOLSNAP_NAMES, *PVOLSNAP_NAMES;

//
// Output buffero for IOCTL_VOLSNAP_QUERY_EPIC.
//

typedef struct _VOLSNAP_EPIC {
    LONG    EpicNumber;
} VOLSNAP_EPIC, *PVOLSNAP_EPIC;

//
// Output buffer for IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES.
// Input buffer for IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE.
//

typedef struct _VOLSNAP_DIFF_AREA_SIZES {
    LONGLONG    UsedVolumeSpace;        // This value is ignored on a SET call.
    LONGLONG    AllocatedVolumeSpace;
    LONGLONG    MaximumVolumeSpace;     // A value of 0 indicates no maximum.
} VOLSNAP_DIFF_AREA_SIZES, *PVOLSNAP_DIFF_AREA_SIZES;

//
// Output buffer for IOCTL_VOLSNAP_QUERY_CONFIG_INFO.
//

typedef struct _VOLSNAP_CONFIG_INFO {
    ULONG           Attributes;
    ULONG           Reserved;
    LARGE_INTEGER   SnapshotCreationTime;
} VOLSNAP_CONFIG_INFO, *PVOLSNAP_CONFIG_INFO;

//
// Input buffer for IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT.
// Input buffer for IOCTL_VOLSNAP_SET_APPLICATION_INFO.
// Output buffer for IOCTL_VOLSNAP_QUERY_APPLICATION_INFO.
//

typedef struct _VOLSNAP_APPLICATION_INFO {
    ULONG   InformationLength;
    UCHAR   Information[1];
    //
    // It is highly recommended that the first 16 bytes from the 
    // Application Info should be a unique GUID indentifying the 
    // unique structure layout of the subsequent Application Info.
    //
} VOLSNAP_APPLICATION_INFO, *PVOLSNAP_APPLICATION_INFO;

#ifdef DEFINE_GUID

//
// This GUID denotes the first 16 bytes from the Application 
// Info structure associated with Client accessible snapshots.  
//
// {E5DE7D45-49F2-40a4-817C-7DC82B72587F}
DEFINE_GUID(VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE, 
0xe5de7d45, 0x49f2, 0x40a4, 0x81, 0x7c, 0x7d, 0xc8, 0x2b, 0x72, 0x58, 0x7f);

//
// This GUID corresponds to the format used to store the
// Hidden (Inaccessible) Snapshot Application Info.
//
// {F12142B4-9A4B-49af-A851-700C42FDC2BE}
DEFINE_GUID(VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN,
0xf12142b4, 0x9a4b, 0x49af, 0xa8, 0x51, 0x70, 0xc, 0x42, 0xfd, 0xc2, 0xbe);

#endif // DEFINE_GUID


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\partmgrp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    partmgrp.h

Abstract:

    This file defines the public interfaces for the PARTMGR driver.

Author:

    norbertk

Revision History:

--*/

//
// Define IOCTL so that volume managers can get another crack at
// partitions that are unclaimed.
//

#define IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS    CTL_CODE('p', 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// This IOCTL is for clusters to tell the volume managers for the
// given disk to stop using it.  You can undo this operation with
// IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS.
//

#define IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS         CTL_CODE('p', 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// This IOCTL usually just returns the MBR disk signature that is contained
// on the disk but may return a 'future' version of the disk signature during
// boot.  This separate call is needed so that if the signature on the boot
// disk is not unique or 0, that it still stays as the old value long enough
// for the system to find it from the loader block.
//

#define IOCTL_PARTMGR_QUERY_DISK_SIGNATURE          CTL_CODE('p', 2, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL is to allow notification requests to be queued against PartMgr 
// which will be completed later when PartMgr spots an 'interesting' change 
// to a disk.
//

#define IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK        CTL_CODE('p', 3, METHOD_BUFFERED, FILE_READ_ACCESS)



//
// This structure is the return value for IOCTL_PARTMGR_QUERY_DISK_SIGNATURE.
//

typedef struct _PARTMGR_DISK_SIGNATURE {
    ULONG   Signature;
} PARTMGR_DISK_SIGNATURE, *PPARTMGR_DISK_SIGNATURE;


//
// This structure is used to request the list of disk numbers that have 
// become active since the specificed epoch and is the input paramter for
// IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK
//

typedef struct _PARTMGR_SIGNATURE_CHECK_EPOCH {
    ULONG   RequestEpoch;
} PARTMGR_SIGNATURE_CHECK_EPOCH, *PPARTMGR_SIGNATURE_CHECK_EPOCH;

#define PARTMGR_REQUEST_CURRENT_DISK_EPOCH (0xFFFFFFFF)


//
// This structure describes the output for IOCTL_PARTMGR_NOTIFY_SIGNATURE_CHECK
//

typedef struct _PARTMGR_SIGNATURE_CHECK_DISKS {
    ULONG   CurrentEpoch;
    ULONG   HighestDiskEpochReturned;
    ULONG   DiskNumbersReturned;
    ULONG   DiskNumber [1];
} PARTMGR_SIGNATURE_CHECK_DISKS, *PPARTMGR_SIGNATURE_CHECK_DISKS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\rt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    rt.h

Abstract:

    This is the public include file for realtime executive (rt.sys) clients.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#ifdef __cplusplus
extern "C" {
#endif


// The following values can be ORed together and the result passed as the Flags argument
// to the RtCreateThread and RtAdjustCpuLoad routines.

#define CPUCYCLES		0x10000
#define INSTRUCTIONS	0x20000

#define USESFLOAT		0x00001
#define USESMMX			0x00002


// These should be used when calculating the desired period and duration to be
// passed to RtCreateThread and RtAdjustCpuLoad.

#define WEEK 604800000000000000I64
#define DAY   86400000000000000I64
#define HOUR   3600000000000000I64
#define MIN      60000000000000I64
#define SEC       1000000000000I64
#define MSEC         1000000000I64
#define USEC            1000000I64
#define NSEC               1000I64
#define PSEC                  1I64


#define X86 1


#define INTEL 1
#define AMD 2



typedef struct {
	ULONG ProcessorCount;	// Number of CPUs in the system.
	ULONG CpuArchitecture;	// Architecture of CPU, currently always X86==1
	ULONG CpuManufacturer;	// Manufacturer ID, Intel==1, AMD==2
	ULONG CpuFamily;		// CPU Family as reported by cpuid instruction.  0x0-0xf
	ULONG CpuModel;			// CPU Model as reported by cpuid instruction.  0x0-0xf
	ULONG CpuStepping;		// CPU Stepping as reported by cpuid instruction.  0x0-0xf
	ULONGLONG CpuFeatures;	// CPU features as reported by cpuid instruction.
	ULONGLONG CpuExtendedFeatures;	// AMD extended features.  (Not implemented.)  Always 0.
	ULONGLONG ProcessorID[2];		// Processor Unique ID.  If enabled.
	ULONG CpuCyclesPerMsec;			// Number of cpu cycles per MSEC.
	ULONG SystemBusCyclesPerMsec;	// Number of system bus cycles per MSEC.
	ULONG ReservedCpuPerMsec;		// Total cpu time reserved per ms by existing rt threads. (in picoseconds)
	ULONG UsedCpuPerMsec;			// Estimate of cpu time used per ms by existing rt threads. (in picoseconds)
	ULONG AvailableCpuPerMsec;		// Cpu time available per ms for allocation to new rt threads. (in picoseconds)
	} SystemInfo;



// The following realtime thread statistics are updated just before control is
// passed by the realtime executive to the realtime thread.  Everytime a realtime
// thread is being switched in, these statistics are updated before control is transfered.
// This means the statistics will change over time, but not while a realtime
// thread is running between thread switches.

#pragma pack(push,2)

typedef struct threadstats {
	ULONGLONG Period;		// Period as passed to RtCreateThread or latest RtAdjustCpuLoad call.
	ULONGLONG Duration;		// Duration from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG Flags;			// Flags from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG StackSize;		// StackSize from RtCreateThread call.
	ULONGLONG PeriodIndex;					// Number of periods since start of thread.
	ULONGLONG TimesliceIndex;				// Number of times thread has been switched to.
	ULONGLONG TimesliceIndexThisPeriod;		// Number of times thread switch to this period.
	ULONGLONG ThisPeriodStartTime;			// Starting time for current period.
	ULONGLONG ThisTimesliceStartTime;		// Starting time for current timeslice.
	ULONGLONG DurationRunThisPeriod;		// Total time run so far this period.
	ULONGLONG DurationRunLastPeriod;		// Total time run in the last period.
	} ThreadStats;

#pragma pack(pop)


typedef VOID (*RTTHREADPROC)(PVOID Context, ThreadStats *Statistics);



NTSTATUS
RtVersion (
	OUT PULONG Version
	);

// RtVersion will return the version number of the currently running
// realtime executive.

// If the realtime executive is running, this function returns
// STATUS_SUCCESS.  If for some reason the realtime executive
// cannot run on the current machine then STATUS_NOT_SUPPORTED
// is returned.

// Currently the realtime executive will only run on PII class or newer
// machines.

// If the pointer to the version number is non NULL, then the
// version information for the currently loaded realtime executive
// is returned.  The version information will be returned regardless
// of the NTSTATUS code returned by the function.

// The version number returned is in the format xx.xx.xx.xx where each
// xx is 1 byte of the ULONG and the ordering left to right is high
// order byte - > low order byte.  ie: 0x01020304 is version 1.2.3.4

// It IS acceptable to pass in a NULL version pointer.  In that case
// no version information is returned.

// If this function is called from a real time thread, then the version
// pointer MUST either be NULL, or it MUST point to a local variable on 
// that real time thread's stack.  Otherwise this function will return 
// STATUS_INVALID_PARAMETER.

// If this function is called from Windows, then the pointer must be
// valid for writing.  Otherwise it will return STATUS_INVALID_PARAMETER.

// This function may be called from any thread.  Windows or realtime.



BOOLEAN
RtThread (
    VOID
    );

// RtThread returns TRUE if called from within a realtime thread.  Otherwise
// it returns FALSE.



NTSTATUS
RtSystemInfo (
	ULONG Processor,
	SystemInfo *pSystemInfo
	);

// RtSystemInfo copies the pertinant processor and system information into the memory 
// pointed to by pSystemInfo.  If pSystemInfo is null or invalid, then RtSystemInfo 
// returns STATUS_INVALID_PARAMETER_2.  Otherwise RtSystemInfo will return STATUS_SUCCESS.

// For uniprocessor systems, the Processor number should be zero.  For N processor
// systems, the processor numbers range from 0 to N-1.  An invalid processor number
// will cause a STATUS_INVALID_PARAMETER_1 to be returned.



NTSTATUS
RtCreateThread (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONG Flags,
	ULONG StackSize,
	RTTHREADPROC RtThread,
	IN PVOID pRtThreadContext,
	OUT PHANDLE pRtThreadHandle
	);

// RtCreateThread is used to create a realtime thread.

// Period is the used to determine the frequency at which the realtime thread must be
// run.  The current minimum period that can be specified is 1ms.

// Duration is the amount of time within the period that the realtime thread will
// need to run.  Percentage CPU load can be calculated as 100*(Duration/Period) as long
// as Duration and Period are both specified in units of time.

// Flags
// This parameter is used to indicate specific requirements of the realtime thread
// being created.  Currently supported values for Flags are USESFLOAT and USESMMX.
// A realtime thread that can use floating point instructions must specify the
// USESFLOAT flag.  A realtime thread that can use MMX instructions must specify the
// USESMMX flag.

// StackSize is the size of the stack required by the realtime thread in 4k blocks.
// Currently StackSize must be between 1 and 8 inclusive.  RtCreateThread will fail
// with STATUS_UNSUCCESSFUL for any other values of StackSize.

// pRtThreadContext is a pointer to the context that should be passed to the thread.
// It may be NULL.  It is passed to the realtime thread as the Context parameter.

// pRtThreadHandle is a pointer to an RtThreadHandle that can be output from
// RtCreateThread.  pRtThreadHandle can be NULL, in which case no RtThreadHandle is
// returned.  Storage for the HANDLE RtThreadHandle must be allocated by the code
// that calls RtCreateThread.

// RtCreateThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtDestroyThread (
	HANDLE RtThreadHandle
	);

// RtDestroyThread removes the realtime thread identified by RtThreadHandle from the
// list of running realtime threads, and releases all resources that were allocated when
// the thread was created.  RtThreadHandle must be a handle returned from RtCreateThread.

// RtDestroyThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtAdjustCpuLoad (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONGLONG Phase,
	ULONG Flags
	);

// This function allows a realtime thread to adjust the amount of CPU that is allocated
// to it.  The Flags parameter must currently match that passed in at thread creation
// time, however, the Period and Duration may be different from the Period and Duration
// passed at thread create time.  If there is sufficient CPU to meet the new request,
// the function will return STATUS_SUCCESS and the Period and Duration in the thread's
// statistics will be updated to match the values passed in to this function.  If
// there is not enough CPU available to meet the request, this function will leave
// the Period and Duration recorded in Statistics unchanged and will return
// STATUS_INSUFFICIENT_RESOURCES.

// This function MUST be called from within a realtime thread.  A realtime thread can
// only change its OWN allocation.  It cannot change the allocation of any other
// realtime thread.



VOID
RtYield (
	ULONGLONG Mark,
	ULONGLONG Delta
	);

// RtYield will yield execution to other realtime threads in the system.

// It should be called whenever a realtime thread does not require further CPU resources.

// Parameters:
//  Mark
//		This is the reference time which will be subtracted from the current
//		realtime executive scheduler time.  Note that this time is ALWAYS
//		considered by the scheduler to be in the past.  Do NOT pass a time
//		which occurs in the future to this parameter.
//	Delta
//		This is the time that will be compared to the difference between the current
//		scheduler time and the mark.  The thread will yield execution until
//		the difference between the current scheduler time and the mark is greater 
//		than delta.

//		After a thread has called RtYield it will only be run when the following
//		code evaluates TRUE.  ( (RtTime() - Mark) >= Delta )  Until that occurs
//		the thread will NOT run.  Unless it is holding a spinlock required by
//		some other realtime thread - in which case it will run until it releases
//		the spinlock at which point it will again yield.



PVOID
RtAddLogEntry (
    ULONG Size
    );

// RtAddLogEntry reserves space for a new entry in the realtime logging buffer.
// It returns a pointer to the reserved space.  Note that if an unsupported Size
// is specified, or if there is no realtime logging buffer available on the
// system, this routine will return NULL.

// Parameters:
//  Size
//      This is the size in bytes of the chunk to reserve in the log.  It MUST be
//      an integral multiple of 16.



// The following standard WDM functions are also safe to call from within a real time 
// thread:  KeAcquireSpinLock and KeReleaseSpinLock.

// They have been modified to support realtime threads in the following ways:



// KeAcquireSpinLock

// KeAcquireSpinLock will now always attempt to take the spinlock regardless of whether it
// is running on a multiproc or uniproc machine.  If the spinlock is already acquired,
// then KeAcquireSpinLock will spin in a loop that calls RtYield(THISTIMESLICE) until
// the spinlock is released.

// It will then claim the spinlock.  This means that realtime threads that attempt to 
// acquire a held spinlock will BLOCK until the spinlock is free.  If you don't HAVE to use 
// spinlocks in your realtime threads, DON'T.

// Note that other realtime threads will continue to run as scheduled, but the thread
// waiting for the spinlock will continue yielding all its timeslices until the spinlock
// is released.

// If KeAcquireSpinLock is called from a realtime thread, then it will NOT attempt to
// change any irql levels.  This is important, since the current Windows IRQL level may
// be at higher than DISPATCH_LEVEL when this function is called.  Furthermore, the OldIrql
// returned by this function when it is called from a realtime thread is always 0xff - 
// which is an INVALID irql level.

// If you call KeAcquireSpinLock from a realtime thread you MUST call KeReleaseSpinLock
// for that spinlock from a realtime thread.

// Evenutally, KeAcquireSpinLock will be modified to do an RtDirectedYield to the realtime
// thread that is holding the spinlock.

// KeAcquireSpinLock may be called from within any thread.  Realtime or windows.



// KeReleaseSpinLock

// KeReleaseSpinLock now always attempts to release a held spinlock regardless of whether
// it is running on a multiproc or uniproc machine.

// If KeReleaseSpinLock is called from a realtime thread, then it will NOT change any irql
// levels.  It will also validate that it has been called with a new irql level of 0xff
// as would have been returned by the KeAcquireSpinLock call in the realtime thread to
// acquire the spinlock.

// At some point KeReleaseSpinLock may do an RtDirectedYield back to the realtime thread
// that yielded when it attempted to acquire the spinlock.

// KeReleaseSpinLock may be called from within any thread.  Realtime or windows.


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\sdplib.h ===
#ifndef __SDPLIB_H__
#define __SDPLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "sdpnode.h"


#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

typedef UCHAR SDP_ELEMENT_HEADER;

#define SDP_TYPE_LISTHEAD          (0x0021)

#define SDP_ST_CONTAINER_STREAM    (0x2001)
#define SDP_ST_CONTAINER_INTERFACE (0x2002)

typedef struct _SDP_STREAM_ENTRY {
    LIST_ENTRY link;
    ULONG streamSize;
    UCHAR stream[1];
} SDP_STREAM_ENTRY, *PSDP_STREAM_ENTRY;

typedef struct _PSM_PROTOCOL_PAIR {
    GUID protocol;
    USHORT psm;
} PSM_PROTOCOL_PAIR, *PPSM_PROTOCOL_PAIR;

typedef struct _PSM_LIST {
    ULONG count;
    PSM_PROTOCOL_PAIR list[1];
} PSM_LIST, *PPSM_LIST;

#define TYPE_BIT_SIZE  (5)
#define TYPE_SHIFT_VAL (8 - TYPE_BIT_SIZE)
#define TYPE_MASK      ((UCHAR) 0x1F)

#define SPECIFIC_TYPE_MASK  (0x07)
#define SIZE_INDEX_MASK     (SPECIFIC_TYPE_MASK)
#define SPECIFIC_TYPE_SHIFT (8)

#define SIZE_INDEX_ZERO           (0)
#define SIZE_INDEX_NEXT_8_BITS    (5)
#define SIZE_INDEX_NEXT_16_BITS   (6)
#define SIZE_INDEX_NEXT_32_BITS   (7)

#define IS_VAR_SIZE_INDEX_INVALID(si) \
    ((si) < SIZE_INDEX_NEXT_8_BITS || (si) > SIZE_INDEX_NEXT_32_BITS)

#define FMT_TYPE(_type) ((((_type) & TYPE_MASK) << TYPE_SHIFT_VAL))
#define FMT_SIZE_INDEX_FROM_ST(_spectype)                           \
   (((_spectype) & (SPECIFIC_TYPE_MASK << SPECIFIC_TYPE_SHIFT)) >>  \
                                                           SPECIFIC_TYPE_SHIFT)

void
SdpInitializeNodeHeader(
    PSDP_NODE_HEADER Header
    );

PSDP_TREE_ROOT_NODE
SdpCreateNodeTree(
    void
    );

NTSTATUS
SdpFreeTree(
    PSDP_TREE_ROOT_NODE Tree
    );

NTSTATUS
SdpFreeTreeEx(
    PSDP_TREE_ROOT_NODE Tree,
    UCHAR FreeRoot
    );

NTSTATUS
SdpFreeOrphanedNode(
    PSDP_NODE Node
    );

void
SdpReleaseContainer(
    ISdpNodeContainer *Container
    );

PSDP_NODE
SdpCreateNode(
    VOID
    );

PSDP_NODE
SdpCreateNodeNil(
    VOID
    );

PSDP_NODE
SdpCreateNodeUInt128(
    PSDP_ULARGE_INTEGER_16 puli16Val
    );

PSDP_NODE
SdpCreateNodeUInt64(
    ULONGLONG ullVal
    );

PSDP_NODE
SdpCreateNodeUInt32(
    ULONG ulVal
    );

PSDP_NODE
SdpCreateNodeUInt16(
    USHORT usVal
    );

PSDP_NODE
SdpCreateNodeUInt8(
    UCHAR ucVal
    );

PSDP_NODE
SdpCreateNodeInt128(
    PSDP_LARGE_INTEGER_16 uil16Val
    );

PSDP_NODE
SdpCreateNodeInt64(
    LONGLONG llVal
    );

PSDP_NODE
SdpCreateNodeInt32(
    LONG lVal
    );

PSDP_NODE
SdpCreateNodeInt16(
    SHORT sVal
    );

PSDP_NODE
SdpCreateNodeInt8(
    CHAR cVal
    );

#define   SdpCreateNodeUUID SdpCreateNodeUUID128
PSDP_NODE
SdpCreateNodeUUID128(
    const GUID *uuid
    );

PSDP_NODE
SdpCreateNodeUUID32(
    ULONG uuidVal4
    );

PSDP_NODE
SdpCreateNodeUUID16(
    USHORT uuidVal2
    );

PSDP_NODE
SdpCreateNodeString(
    PCHAR string, ULONG stringLength
    );

PSDP_NODE
SdpCreateNodeBoolean(
    SDP_BOOLEAN  bVal
    );

PSDP_NODE
SdpCreateNodeSequence(
    void
    );

PSDP_NODE
SdpCreateNodeAlternative(
    void
    );

PSDP_NODE
SdpCreateNodeUrl(
    PCHAR url,
    ULONG urlLength
    );

NTSTATUS
SdpAppendNodeToContainerNode(
    PSDP_NODE Parent,
    PSDP_NODE Node
    );

NTSTATUS
SdpAddAttributeToTree(
    PSDP_TREE_ROOT_NODE Tree,
    USHORT AttribId,
    PSDP_NODE AttribValue
    );

NTSTATUS
SdpAddAttributeToHeader(
    PSDP_NODE_HEADER Header,
    USHORT AttribId,
    PSDP_NODE AttribValue,
    PULONG Replaced
    );

NTSTATUS
SdpFindAttributeInTree(
    PSDP_TREE_ROOT_NODE Tree,
    USHORT AttribId,
    PSDP_NODE *Attribute
    );

NTSTATUS
SdpFindAttributeInStream(
    PUCHAR Stream,
    ULONG Size,
    USHORT Attrib,
    PUCHAR *PPStream,
    PULONG PSize
    );

NTSTATUS
SdpFindAttributeSequenceInStream(
    PUCHAR Stream,
    ULONG Size,
    SdpAttributeRange *AttributeRange,
    ULONG AttributeRangeCount,
    PSDP_STREAM_ENTRY *ppEntry,
    PSDP_ERROR SdpError
    );

SDP_ERROR
SdpMapNtStatusToSdpError(
    NTSTATUS Status
    );

NTSTATUS
SdpStreamFromTree(
    PSDP_TREE_ROOT_NODE Root,
    PUCHAR *Stream,
    PULONG Size
    );

NTSTATUS
SdpStreamFromTreeEx(
    PSDP_TREE_ROOT_NODE Root,
    PUCHAR *Stream,
    PULONG Size,
    ULONG HeaderSize,
    ULONG TailSize,
    UCHAR PagedAllocation
    );

NTSTATUS
SdpTreeFromStream(
    PUCHAR Stream,
    ULONG Size,
    PSDP_TREE_ROOT_NODE* Node,
    UCHAR FullParse
    );

typedef NTSTATUS (*PSDP_STREAM_WALK_FUNC)(
    PVOID Context,
    UCHAR DataType,
    ULONG DataSize,
    PUCHAR Data
    );

NTSTATUS
SdpWalkStream(
    PUCHAR Stream,
    ULONG Size,
    PSDP_STREAM_WALK_FUNC WalkFunc,
    PVOID WalkContext
    );

VOID
SdpFreePool(
    PVOID Memory
    );

void
SdpByteSwapUuid128(
    GUID *uuid128From,
    GUID *uuid128To
    );

void
SdpByteSwapUint128(
    PSDP_ULARGE_INTEGER_16 pInUint128,
    PSDP_ULARGE_INTEGER_16 pOutUint128
    );

ULONGLONG
SdpByteSwapUint64(
    ULONGLONG uint64
    );

ULONG
SdpByteSwapUint32(
    ULONG uint32
    );

USHORT
SdpByteSwapUint16(
    USHORT uint16
    );

void
SdpRetrieveUuid128(
    PUCHAR Stream,
    GUID *uuidVal
    );

void
SdpRetrieveUint128(
    PUCHAR Stream,
    PSDP_ULARGE_INTEGER_16 pUint128
    );

void
SdpRetrieveUint64(
    PUCHAR Stream,
    PULONGLONG pUint64
    );

void
SdpRetrieveUint32(
    PUCHAR Stream,
    PULONG pUint32
    );

void
SdpRetrieveUint16(
    PUCHAR Stream,
    PUSHORT pUint16
    );

void
SdpRetrieveVariableSize(
    PUCHAR Stream,
    UCHAR SizeIndex,
    PULONG ElementSize,
    PULONG StorageSize
    );

void
SdpRetrieveUuidFromStream(
    PUCHAR Stream,
    ULONG DataSize,
    GUID *pUuid,
    UCHAR bigEndian
    );

void
SdpNormalizeUuid(
    PSDP_NODE pUuid,
    GUID* uuid
    );

NTSTATUS
SdpGetProtocolConnectInfo(
    IN PUCHAR Stream,
    IN ULONG StreamSize,
    IN ULONG Index,
    IN UCHAR IsPrimary,
    OUT GUID* Protocol,
    OUT PUSHORT Psm,
    OUT PUCHAR IsRfcomm
    );

ULONG
SdpGetNumProtocolStacks(
    IN PUCHAR Stream,
    IN ULONG StreamSize,
    IN UCHAR IsPrimary
    );

NTSTATUS
SdpValidateProtocolContainer(
    PSDP_NODE pContainer,
    PPSM_LIST pPsmList
    );

NTSTATUS
SdpValidateVariableSize(
    PUCHAR Stream,
    ULONG StreamSize,
    UCHAR SizeIndex,
    PULONG ElementSize,
    PULONG StorageSize
    );

#define SDP_RETRIEVE_HEADER(_stream, _type, _sizeidx)                          \
{                                                                              \
    (_type) = ((*(_stream)) & (TYPE_MASK << TYPE_SHIFT_VAL)) >> TYPE_SHIFT_VAL;\
    (_sizeidx) = *(_stream) & SIZE_INDEX_MASK;                                 \
}

NTSTATUS
SdpValidateStream(
    PUCHAR Stream,
    ULONG Size,
    PULONG NumEntries,
    PULONG ExtraPool,
    PULONG_PTR ErrorByte
    );

NTSTATUS
SdpIsStreamRecord(
    PUCHAR Stream,
    ULONG Size
    );

#define VERIFY_SINGLE_ATTRIBUTE          (0x00000001)
#define VERIFY_CHECK_MANDATORY_LOCAL     (0x00000002)
#define VERIFY_CHECK_MANDATORY_REMOTE    (0x00000004)
#define VERIFY_STREAM_IS_ATTRIBUTE_VALUE (0x00000008)

#define VERIFY_CHECK_MANDATORY_ALL      \
    (VERIFY_CHECK_MANDATORY_LOCAL | VERIFY_CHECK_MANDATORY_REMOTE)

NTSTATUS
SdpVerifyServiceRecord(
    PUCHAR Stream,
    ULONG Size,
    ULONG Flags,
    PUSHORT AttribId
    );

NTSTATUS
SdpVerifySequenceOf(
    PUCHAR Stream,
    ULONG Size,
    UCHAR OfType,
    PUCHAR SpecSizes,
    PULONG NumFound,
    PSDP_STREAM_WALK_FUNC Func,
    PVOID Context
    );

VOID
SdpGetNextElement(
    PUCHAR Stream,
    ULONG StreamSize,
    PUCHAR CurrentElement,
    PUCHAR* NextElement,
    PULONG NextElementSize
    );

typedef struct _SDP_ATTRIBUTE_INFO {
    PUCHAR AttributeStream;
    ULONG AttributeStreamSize;
    USHORT AttributeId;
} SDP_ATTRIBUTE_INFO, *PSDP_ATTRIBUTE_INFO;

VOID
Sdp_InitializeListHead(
    PLIST_ENTRY ListHead
    );

UCHAR
Sdp_IsListEmpty(
    PLIST_ENTRY ListHead
    );

PLIST_ENTRY
Sdp_RemoveHeadList(
    PLIST_ENTRY ListHead
    );

VOID
Sdp_RemoveEntryList(
    PLIST_ENTRY Entry
    );

VOID
Sdp_InsertEntryList(
    PLIST_ENTRY Previous,
    PLIST_ENTRY Entry
    );

NTSTATUS
SdpNodeToStream(
    PSDP_NODE Node,
    PUCHAR Stream
    );

NTSTATUS
SdpComputeNodeListSize(
    PSDP_NODE Node,
    PULONG Size
    );

UCHAR
SdpGetContainerHeaderSize(
    ULONG ContainerSize
    );

PUCHAR
SdpWriteVariableSizeToStream(
    UCHAR Type,
    ULONG DataSize,
    PUCHAR Stream
    );

PUCHAR
SdpWriteLeafToStream(
    PSDP_NODE Node,
    PUCHAR Stream
    );

#define IsEqualUuid(u1, u2) (RtlEqualMemory((u1), (u2), sizeof(GUID)))

#ifdef __cplusplus
};
#endif

#endif // __SDPLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\oemtypes.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    oemtypes.h

Abstract:

    This file defines the OEM partition types and provides a macro
    to recognize them.

Author:

    Cristian Teodorescu  (cristiat)  1-December-2000

Revision History:

--*/

#ifndef _OEMTYPES_H_
#define _OEMTYPES_H_

//
//  List of OEM partition types recognized by NT
//

#define PARTITION_EISA          0x12    // EISA partition
#define PARTITION_HIBERNATION   0x84	// Hibernation partition for laptops
#define PARTITION_DIAGNOSTIC    0xA0    // Diagnostic partition on some HP notebooks
#define PARTITION_DELL          0xDE	// Dell partition
#define PARTITION_IBM           0xFE    // IBM IML partition

//
// BOOLEAN
// IsOEMPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine if the given partition is an OEM
//     partition. We consider any special unrecognized partitions that 
//     are required for various machines to boot or work properly.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is an OEM partition,
//     otherwise FALSE is returned.
//

#define IsOEMPartition(PartitionType) (             \
    ((PartitionType) == PARTITION_EISA)         ||  \
    ((PartitionType) == PARTITION_HIBERNATION)  ||  \
    ((PartitionType) == PARTITION_DIAGNOSTIC)   ||  \
    ((PartitionType) == PARTITION_DELL)         ||  \
    ((PartitionType) == PARTITION_IBM))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\sacmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sacmsg.mc

Abstract:

    sac commands

Author:

    Andrew Ritz (andrewr) 15-June-2000

Revision History:

--*/

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SAC_INITIALIZED
//
// MessageText:
//
//  
//  Computer is booting, SAC started and initialized.
//  
//  Use the "ch -?" command for information about using channels.
//  Use the "?" command for general help.
//  
//
#define SAC_INITIALIZED                  ((ULONG)0x00000001L)

//
// MessageId: SAC_ENTER
//
// MessageText:
//
//  
//
#define SAC_ENTER                        ((ULONG)0x00000002L)

//
// MessageId: SAC_PROMPT
//
// MessageText:
//
//  SAC>%0
//
#define SAC_PROMPT                       ((ULONG)0x00000003L)

//
// MessageId: SAC_UNLOADED
//
// MessageText:
//
//  The SAC is unavailable, it was directly unloaded.
//
#define SAC_UNLOADED                     ((ULONG)0x00000004L)

//
// MessageId: SAC_SHUTDOWN
//
// MessageText:
//
//  The SAC will become unavailable soon.  The computer is shutting down.
//  
//
#define SAC_SHUTDOWN                     ((ULONG)0x00000005L)

//
// MessageId: SAC_INVALID_PARAMETER
//
// MessageText:
//
//  A parameter was incorrect or missing.  Try the 'help' command for more details.
//
#define SAC_INVALID_PARAMETER            ((ULONG)0x00000006L)

//
// MessageId: SAC_THREAD_ON
//
// MessageText:
//
//  Thread information is now ON.
//
#define SAC_THREAD_ON                    ((ULONG)0x00000007L)

//
// MessageId: SAC_THREAD_OFF
//
// MessageText:
//
//  Thread information is now OFF.
//
#define SAC_THREAD_OFF                   ((ULONG)0x00000008L)

//
// MessageId: SAC_PAGING_ON
//
// MessageText:
//
//  Paging is now ON.
//
#define SAC_PAGING_ON                    ((ULONG)0x00000009L)

//
// MessageId: SAC_PAGING_OFF
//
// MessageText:
//
//  Paging is now OFF.
//
#define SAC_PAGING_OFF                   ((ULONG)0x0000000AL)

//
// MessageId: SAC_NO_MEMORY
//
// MessageText:
//
//  Paging is now OFF.
//
#define SAC_NO_MEMORY                    ((ULONG)0x0000000BL)

//
// MessageId: SAC_HELP_D_CMD
//
// MessageText:
//
//  d                    Dump the current kernel log.
//
#define SAC_HELP_D_CMD                   ((ULONG)0x0000000CL)

//
// MessageId: SAC_HELP_F_CMD
//
// MessageText:
//
//  f                    Toggle detailed or abbreviated tlist info.
//
#define SAC_HELP_F_CMD                   ((ULONG)0x0000000DL)

//
// MessageId: SAC_HELP_HELP_CMD
//
// MessageText:
//
//  ? or help            Display this list.
//
#define SAC_HELP_HELP_CMD                ((ULONG)0x0000000EL)

//
// MessageId: SAC_HELP_I1_CMD
//
// MessageText:
//
//  i                    List all IP network numbers and their IP addresses.
//
#define SAC_HELP_I1_CMD                  ((ULONG)0x0000000FL)

//
// MessageId: SAC_HELP_I2_CMD
//
// MessageText:
//
//  i <#> <ip> <subnet> <gateway> Set IP addr., subnet and gateway.
//
#define SAC_HELP_I2_CMD                  ((ULONG)0x00000010L)

//
// MessageId: SAC_HELP_K_CMD
//
// MessageText:
//
//  k <pid>              Kill the given process.
//
#define SAC_HELP_K_CMD                   ((ULONG)0x00000012L)

//
// MessageId: SAC_HELP_L_CMD
//
// MessageText:
//
//  l <pid>              Lower the priority of a process to the lowest possible.
//
#define SAC_HELP_L_CMD                   ((ULONG)0x00000013L)

//
// MessageId: SAC_HELP_M_CMD
//
// MessageText:
//
//  m <pid> <MB-allow>   Limit the memory usage of a process to <MB-allow>.
//
#define SAC_HELP_M_CMD                   ((ULONG)0x00000014L)

//
// MessageId: SAC_HELP_P_CMD
//
// MessageText:
//
//  p                    Toggle paging the display.
//
#define SAC_HELP_P_CMD                   ((ULONG)0x00000015L)

//
// MessageId: SAC_HELP_R_CMD
//
// MessageText:
//
//  r <pid>              Raise the priority of a process by one.
//
#define SAC_HELP_R_CMD                   ((ULONG)0x00000016L)

//
// MessageId: SAC_HELP_S1_CMD
//
// MessageText:
//
//  s                    Display the current time and date (24 hour clock used).
//
#define SAC_HELP_S1_CMD                  ((ULONG)0x00000017L)

//
// MessageId: SAC_HELP_S2_CMD
//
// MessageText:
//
//  s mm/dd/yyyy hh:mm   Set the current time and date (24 hour clock used).
//
#define SAC_HELP_S2_CMD                  ((ULONG)0x00000018L)

//
// MessageId: SAC_HELP_T_CMD
//
// MessageText:
//
//  t                    Tlist.
//
#define SAC_HELP_T_CMD                   ((ULONG)0x00000019L)

//
// MessageId: SAC_HELP_RESTART_CMD
//
// MessageText:
//
//  restart              Restart the system immediately.
//
#define SAC_HELP_RESTART_CMD             ((ULONG)0x0000001BL)

//
// MessageId: SAC_HELP_SHUTDOWN_CMD
//
// MessageText:
//
//  shutdown             Shutdown the system immediately.
//
#define SAC_HELP_SHUTDOWN_CMD            ((ULONG)0x0000001CL)

//
// MessageId: SAC_HELP_CRASHDUMP1_CMD
//
// MessageText:
//
//  crashdump            Crash the system. You must have crash dump enabled.
//
#define SAC_HELP_CRASHDUMP1_CMD          ((ULONG)0x0000001DL)

//
// MessageId: SAC_HELP_IDENTIFICATION_CMD
//
// MessageText:
//
//  id                   Display the computer identification information.
//
#define SAC_HELP_IDENTIFICATION_CMD      ((ULONG)0x0000001FL)

//
// MessageId: SAC_HELP_LOCK_CMD
//
// MessageText:
//
//  lock                 Lock access to Command Prompt channels.
//
#define SAC_HELP_LOCK_CMD                ((ULONG)0x00000020L)

//
// MessageId: SAC_FAILURE_WITH_ERROR
//
// MessageText:
//
//  Failed with status 0x%%X.
//
#define SAC_FAILURE_WITH_ERROR           ((ULONG)0x00000030L)

//
// MessageId: SAC_DATETIME_FORMAT
//
// MessageText:
//
//  Date: %%02d/%%02d/%%02d  Time (GMT): %%02d:%%02d:%%02d:%%04d
//
#define SAC_DATETIME_FORMAT              ((ULONG)0x00000031L)

//
// MessageId: SAC_IPADDRESS_RETRIEVE_FAILURE
//
// MessageText:
//
//  SAC could not retrieve the IP Address.
//
#define SAC_IPADDRESS_RETRIEVE_FAILURE   ((ULONG)0x00000032L)

//
// MessageId: SAC_IPADDRESS_CLEAR_FAILURE
//
// MessageText:
//
//  SAC could not clear the existing IP Address.
//
#define SAC_IPADDRESS_CLEAR_FAILURE      ((ULONG)0x00000033L)

//
// MessageId: SAC_IPADDRESS_SET_FAILURE
//
// MessageText:
//
//  SAC could not set the IP Address.
//
#define SAC_IPADDRESS_SET_FAILURE        ((ULONG)0x00000034L)

//
// MessageId: SAC_IPADDRESS_SET_SUCCESS
//
// MessageText:
//
//  SAC successfully set the IP Address, subnet mask, and gateway.
//
#define SAC_IPADDRESS_SET_SUCCESS        ((ULONG)0x00000036L)

//
// MessageId: SAC_KILL_FAILURE
//
// MessageText:
//
//  SAC failed to terminate the process.
//
#define SAC_KILL_FAILURE                 ((ULONG)0x00000037L)

//
// MessageId: SAC_KILL_SUCCESS
//
// MessageText:
//
//  SAC successfully terminated the process.
//
#define SAC_KILL_SUCCESS                 ((ULONG)0x00000038L)

//
// MessageId: SAC_LOWERPRI_FAILURE
//
// MessageText:
//
//  SAC failed to lower the process priority.
//
#define SAC_LOWERPRI_FAILURE             ((ULONG)0x00000039L)

//
// MessageId: SAC_LOWERPRI_SUCCESS
//
// MessageText:
//
//  SAC successfully lowered the process priority.
//
#define SAC_LOWERPRI_SUCCESS             ((ULONG)0x0000003AL)

//
// MessageId: SAC_RAISEPRI_FAILURE
//
// MessageText:
//
//  SAC failed to raise the process priority.
//
#define SAC_RAISEPRI_FAILURE             ((ULONG)0x0000003BL)

//
// MessageId: SAC_RAISEPRI_SUCCESS
//
// MessageText:
//
//  SAC successfully raised the process priority.
//
#define SAC_RAISEPRI_SUCCESS             ((ULONG)0x0000003CL)

//
// MessageId: SAC_LOWERMEM_FAILURE
//
// MessageText:
//
//  SAC failed to limit the available process memory.
//
#define SAC_LOWERMEM_FAILURE             ((ULONG)0x0000003DL)

//
// MessageId: SAC_LOWERMEM_SUCCESS
//
// MessageText:
//
//  SAC successfully limited the available process memory.
//
#define SAC_LOWERMEM_SUCCESS             ((ULONG)0x0000003EL)

//
// MessageId: SAC_RAISEPRI_NOTLOWERED
//
// MessageText:
//
//  SAC cannot raise the priority of a process that was not previously lowered.
//
#define SAC_RAISEPRI_NOTLOWERED          ((ULONG)0x0000003FL)

//
// MessageId: SAC_RAISEPRI_MAXIMUM
//
// MessageText:
//
//  SAC cannot raise the process priority any higher.
//
#define SAC_RAISEPRI_MAXIMUM             ((ULONG)0x00000040L)

//
// MessageId: SAC_SHUTDOWN_FAILURE
//
// MessageText:
//
//  SAC failed to shutdown the system.
//
#define SAC_SHUTDOWN_FAILURE             ((ULONG)0x00000041L)

//
// MessageId: SAC_RESTART_FAILURE
//
// MessageText:
//
//  SAC failed to restart the system.
//
#define SAC_RESTART_FAILURE              ((ULONG)0x00000042L)

//
// MessageId: SAC_CRASHDUMP_FAILURE
//
// MessageText:
//
//  SAC failed to crashdump the system.
//
#define SAC_CRASHDUMP_FAILURE            ((ULONG)0x00000043L)

//
// MessageId: SAC_TLIST_FAILURE
//
// MessageText:
//
//  SAC failed to retrieve the task list.
//
#define SAC_TLIST_FAILURE                ((ULONG)0x00000044L)

//
// MessageId: SAC_TLIST_HEADER1_FORMAT
//
// MessageText:
//
//  memory: %%4ld kb  uptime:%%3ld %%2ld:%%02ld:%%02ld.%%03ld
//  
//  
//
#define SAC_TLIST_HEADER1_FORMAT         ((ULONG)0x00000045L)

//
// MessageId: SAC_TLIST_NOPAGEFILE
//
// MessageText:
//
//  No pagefile in use.
//
#define SAC_TLIST_NOPAGEFILE             ((ULONG)0x00000046L)

//
// MessageId: SAC_TLIST_PAGEFILE_NAME
//
// MessageText:
//
//  PageFile: %%wZ
//
#define SAC_TLIST_PAGEFILE_NAME          ((ULONG)0x00000047L)

//
// MessageId: SAC_TLIST_PAGEFILE_DATA
//
// MessageText:
//
//          Current Size: %%6ld kb  Total Used: %%6ld kb   Peak Used %%6ld kb
//
#define SAC_TLIST_PAGEFILE_DATA          ((ULONG)0x00000048L)

//
// MessageId: SAC_TLIST_MEMORY1_DATA
//
// MessageText:
//
//  
//   Memory:%%7ldK Avail:%%7ldK  TotalWs:%%7ldK InRam Kernel:%%5ldK P:%%5ldK
//
#define SAC_TLIST_MEMORY1_DATA           ((ULONG)0x00000049L)

//
// MessageId: SAC_TLIST_MEMORY2_DATA
//
// MessageText:
//
//   Commit:%%7ldK/%%7ldK Limit:%%7ldK Peak:%%7ldK  Pool N:%%5ldK P:%%5ldK
//
#define SAC_TLIST_MEMORY2_DATA           ((ULONG)0x0000004AL)

//
// MessageId: SAC_TLIST_PROCESS1_HEADER
//
// MessageText:
//
//      User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd  Pid Name
//
#define SAC_TLIST_PROCESS1_HEADER        ((ULONG)0x0000004BL)

//
// MessageId: SAC_TLIST_PROCESS2_HEADER
//
// MessageText:
//
//                             %%6ld %%8ld                          File Cache
//
#define SAC_TLIST_PROCESS2_HEADER        ((ULONG)0x0000004CL)

//
// MessageId: SAC_TLIST_PROCESS1_DATA
//
// MessageText:
//
//  %%3ld:%%02ld:%%02ld.%%03ld %%3ld:%%02ld:%%02ld.%%03ld%%6ld %%8ld %%7ld %%2ld %%4ld %%3ld %%4ld %%wZ
//
#define SAC_TLIST_PROCESS1_DATA          ((ULONG)0x0000004DL)

//
// MessageId: SAC_TLIST_PROCESS2_DATA
//
// MessageText:
//
//  %%3ld:%%02ld:%%02ld.%%03ld %%3ld:%%02ld:%%02ld.%%03ld
//
#define SAC_TLIST_PROCESS2_DATA          ((ULONG)0x0000004EL)

//
// MessageId: SAC_TLIST_PSTAT_HEADER
//
// MessageText:
//
//  pid:%%3lx pri:%%2ld Hnd:%%5ld Pf:%%7ld Ws:%%7ldK %%wZ
//
#define SAC_TLIST_PSTAT_HEADER           ((ULONG)0x0000004FL)

//
// MessageId: SAC_TLIST_PSTAT_THREAD_HEADER
//
// MessageText:
//
//   tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State
//
#define SAC_TLIST_PSTAT_THREAD_HEADER    ((ULONG)0x00000050L)

//
// MessageId: SAC_TLIST_PSTAT_THREAD_DATA
//
// MessageText:
//
//   %%3lx  %%2ld %%9ld %%p %%2ld:%%02ld:%%02ld.%%03ld %%2ld:%%02ld:%%02ld.%%03ld %%s%%s
//
#define SAC_TLIST_PSTAT_THREAD_DATA      ((ULONG)0x00000051L)

//
// MessageId: SAC_MORE_MESSAGE
//
// MessageText:
//
//  ----Press <Enter> for more----
//
#define SAC_MORE_MESSAGE                 ((ULONG)0x00000052L)

//
// MessageId: SAC_RETRIEVING_IPADDR
//
// MessageText:
//
//  SAC is retrieving IP Addresses...
//
#define SAC_RETRIEVING_IPADDR            ((ULONG)0x00000053L)

//
// MessageId: SAC_IPADDR_FAILED
//
// MessageText:
//
//  Could not retrieve IP Address(es).
//
#define SAC_IPADDR_FAILED                ((ULONG)0x00000054L)

//
// MessageId: SAC_IPADDR_NONE
//
// MessageText:
//
//  There are no IP Addresses available.
//
#define SAC_IPADDR_NONE                  ((ULONG)0x00000055L)

//
// MessageId: SAC_IPADDR_DATA
//
// MessageText:
//
//  Net: %%d, Ip=%%d.%%d.%%d.%%d  Subnet=%%d.%%d.%%d.%%d  Gateway=%%d.%%d.%%d.%%d
//
#define SAC_IPADDR_DATA                  ((ULONG)0x00000056L)

//
// MessageId: SAC_DATETIME_FORMAT2
//
// MessageText:
//
//  Date: %%02d/%%02d/%%02d  Time (GMT): %%02d:%%02d
//
#define SAC_DATETIME_FORMAT2             ((ULONG)0x00000057L)

//
// MessageId: SAC_DATETIME_LIMITS
//
// MessageText:
//
//  The year is restricted from 1980 to 2099.
//
#define SAC_DATETIME_LIMITS              ((ULONG)0x00000058L)

//
// MessageId: SAC_PROCESS_STALE
//
// MessageText:
//
//  That process has been killed and is being cleaned up by the system.
//
#define SAC_PROCESS_STALE                ((ULONG)0x00000059L)

//
// MessageId: SAC_DUPLICATE_PROCESS
//
// MessageText:
//
//  A duplicate process id is being cleaned up by the system.  Try the 
//  command again in a few seconds.
//
#define SAC_DUPLICATE_PROCESS            ((ULONG)0x0000005AL)

//
// MessageId: SAC_MACHINEINFO_COMPUTERNAME
//
// MessageText:
//
//             Computer Name: %%ws
//
#define SAC_MACHINEINFO_COMPUTERNAME     ((ULONG)0x0000005CL)

//
// MessageId: SAC_MACHINEINFO_GUID
//
// MessageText:
//
//             Computer GUID: %%ws
//
#define SAC_MACHINEINFO_GUID             ((ULONG)0x0000005DL)

//
// MessageId: SAC_MACHINEINFO_PROCESSOR_ARCHITECTURE
//
// MessageText:
//
//    Processor Architecture: %%ws
//
#define SAC_MACHINEINFO_PROCESSOR_ARCHITECTURE ((ULONG)0x0000005EL)

//
// MessageId: SAC_MACHINEINFO_OS_BUILD
//
// MessageText:
//
//              Build Number: %%ws
//
#define SAC_MACHINEINFO_OS_BUILD         ((ULONG)0x0000005FL)

//
// MessageId: SAC_MACHINEINFO_OS_PRODUCTTYPE
//
// MessageText:
//
//                   Product: %%ws
//
#define SAC_MACHINEINFO_OS_PRODUCTTYPE   ((ULONG)0x00000060L)

//
// MessageId: SAC_MACHINEINFO_SERVICE_PACK
//
// MessageText:
//
//      Applied Service Pack: %%ws
//
#define SAC_MACHINEINFO_SERVICE_PACK     ((ULONG)0x00000061L)

//
// MessageId: SAC_MACHINEINFO_NO_SERVICE_PACK
//
// MessageText:
//
//  None%0
//
#define SAC_MACHINEINFO_NO_SERVICE_PACK  ((ULONG)0x00000062L)

//
// MessageId: SAC_MACHINEINFO_OS_VERSION
//
// MessageText:
//
//            Version Number: %%ws
//
#define SAC_MACHINEINFO_OS_VERSION       ((ULONG)0x00000063L)

//
// MessageId: SAC_MACHINEINFO_DATACENTER
//
// MessageText:
//
//  Windows Server 2003 Datacenter Edition%0
//
#define SAC_MACHINEINFO_DATACENTER       ((ULONG)0x00000064L)

//
// MessageId: SAC_MACHINEINFO_EMBEDDED
//
// MessageText:
//
//  Windows Server 2003 Embedded%0
//
#define SAC_MACHINEINFO_EMBEDDED         ((ULONG)0x00000065L)

//
// MessageId: SAC_MACHINEINFO_ADVSERVER
//
// MessageText:
//
//  Windows Server 2003 Enterprise Edition%0
//
#define SAC_MACHINEINFO_ADVSERVER        ((ULONG)0x00000066L)

//
// MessageId: SAC_MACHINEINFO_SERVER
//
// MessageText:
//
//  Windows Server 2003%0
//
#define SAC_MACHINEINFO_SERVER           ((ULONG)0x00000067L)

//
// MessageId: SAC_IDENTIFICATION_UNAVAILABLE
//
// MessageText:
//
//  Computer identification information is unavailable.
//
#define SAC_IDENTIFICATION_UNAVAILABLE   ((ULONG)0x00000068L)

//
// MessageId: SAC_UNKNOWN_COMMAND
//
// MessageText:
//
//  Unrecognized command.  Try the 'help' command for more details.
//
#define SAC_UNKNOWN_COMMAND              ((ULONG)0x00000069L)

//
// MessageId: SAC_CANNOT_REMOVE_SAC_CHANNEL
//
// MessageText:
//
//  Error: The SAC channel cannot be closed.
//
#define SAC_CANNOT_REMOVE_SAC_CHANNEL    ((ULONG)0x0000006AL)

//
// MessageId: SAC_CHANNEL_NOT_FOUND
//
// MessageText:
//
//  Error: Could not find a channel with that name.
//
#define SAC_CHANNEL_NOT_FOUND            ((ULONG)0x0000006BL)

//
// MessageId: SAC_CHANNEL_PROMPT
//
// MessageText:
//
//  Channel List
//                         
//  (Use "ch -?" for information on using channels)
//  
//  # Status  Channel Name 
//
#define SAC_CHANNEL_PROMPT               ((ULONG)0x0000006CL)

//
// MessageId: SAC_NEW_CHANNEL_CREATED
//
// MessageText:
//
//  EVENT:   A new channel has been created.  Use "ch -?" for channel help.
//  Channel: %%s
//
#define SAC_NEW_CHANNEL_CREATED          ((ULONG)0x0000006DL)

//
// MessageId: SAC_CHANNEL_CLOSED
//
// MessageText:
//
//  EVENT:   A channel has been closed.
//  Channel: %%s
//
#define SAC_CHANNEL_CLOSED               ((ULONG)0x0000006EL)

//
// MessageId: SAC_CHANNEL_SWITCHING_HEADER
//
// MessageText:
//
//  Name:                  %%s
//  Description:           %%s
//  Type:                  %%s
//  Channel GUID:          %%08lx-%%04x-%%04x-%%02x%%02x-%%02x%%02x%%02x%%02x%%02x%%02x
//  Application Type GUID: %%08lx-%%04x-%%04x-%%02x%%02x-%%02x%%02x%%02x%%02x%%02x%%02x
//  
//  Press <esc><tab> for next channel.
//  Press <esc><tab>0 to return to the SAC channel.
//  Use any other key to view this channel.
//  
//
#define SAC_CHANNEL_SWITCHING_HEADER     ((ULONG)0x0000006FL)

//
// MessageId: SAC_HELP_CH_CMD
//
// MessageText:
//
//  ch                   Channel management commands.  Use ch -? for more help.    
//
#define SAC_HELP_CH_CMD                  ((ULONG)0x00000070L)

//
// MessageId: SAC_HEARTBEAT_FORMAT
//
// MessageText:
//
//    Time since last reboot: %%d:%%02d:%%02d
//
#define SAC_HEARTBEAT_FORMAT             ((ULONG)0x00000071L)

//
// MessageId: SAC_PREPARE_RESTART
//
// MessageText:
//
//  SAC preparing to restart the system.
//
#define SAC_PREPARE_RESTART              ((ULONG)0x00000072L)

//
// MessageId: SAC_PREPARE_SHUTDOWN
//
// MessageText:
//
//  SAC preparing to shutdown the system.
//
#define SAC_PREPARE_SHUTDOWN             ((ULONG)0x00000073L)

//
// MessageId: SAC_FAILED_TO_REMOVE_CHANNEL
//
// MessageText:
//
//  Error! Failed to remove channel! 
//  
//  Please contact your system administrator.
//  
//
#define SAC_FAILED_TO_REMOVE_CHANNEL     ((ULONG)0x00000074L)

//
// MessageId: SAC_HELP_CMD_CMD
//
// MessageText:
//
//  cmd                  Create a Command Prompt channel.
//
#define SAC_HELP_CMD_CMD                 ((ULONG)0x00000077L)

//
// MessageId: SAC_CMD_SERVICE_TIMED_OUT
//
// MessageText:
//
//  Timeout: Unable to launch a Command Prompt.  The service responsible for 
//           launching Command Prompt channels has timed out.  This may be 
//           because the service is malfunctioning or is unresponsive.  
//
#define SAC_CMD_SERVICE_TIMED_OUT        ((ULONG)0x00000078L)

//
// MessageId: SAC_CMD_SERVICE_SUCCESS
//
// MessageText:
//
//  The Command Prompt session was successfully launched.
//
#define SAC_CMD_SERVICE_SUCCESS          ((ULONG)0x00000079L)

//
// MessageId: SAC_CMD_SERVICE_FAILURE
//
// MessageText:
//
//  Error: The SAC Command Console session failed to be created.
//
#define SAC_CMD_SERVICE_FAILURE          ((ULONG)0x00000080L)

//
// MessageId: SAC_CMD_SERVICE_NOT_REGISTERED
//
// MessageText:
//
//  Error: Unable to launch a Command Prompt.  The service responsible for launching
//         Command Prompt channels has not yet registered.  This may be because the
//         service is not yet started, is disabled by the administrator, is
//         malfunctioning or is unresponsive.  
//
#define SAC_CMD_SERVICE_NOT_REGISTERED   ((ULONG)0x00000083L)

//
// MessageId: SAC_CMD_SERVICE_REGISTERED
//
// MessageText:
//
//  EVENT: The CMD command is now available.
//
#define SAC_CMD_SERVICE_REGISTERED       ((ULONG)0x00000084L)

//
// MessageId: SAC_CMD_SERVICE_UNREGISTERED
//
// MessageText:
//
//  EVENT: The CMD command is unavailable.
//
#define SAC_CMD_SERVICE_UNREGISTERED     ((ULONG)0x00000085L)

//
// MessageId: SAC_CHANNEL_FAILED_CLOSE
//
// MessageText:
//
//  EVENT:   An attempt was made to close a channel but failed.
//  Channel: %%s
//
#define SAC_CHANNEL_FAILED_CLOSE         ((ULONG)0x00000086L)

//
// MessageId: SAC_CHANNEL_ALREADY_CLOSED
//
// MessageText:
//
//  EVENT:   An attempt to close a channel failed because it is already closed.
//  Channel: %%s
//
#define SAC_CHANNEL_ALREADY_CLOSED       ((ULONG)0x00000087L)

//
// MessageId: SAC_HELP_CH_CMD_EXT
//
// MessageText:
//
//  Channel management commands:
//  
//  ch                   List all channels.
//  
//  Status Legend: (AB)
//  A: Channel operational status
//      'A' = Channel is active.
//      'I' = Channel is inactive.
//  B: Channel Type
//      'V' = VT-UTF8 emulation.
//      'R' = Raw - no emulation.
//  
//  ch -si <#>           Switch to a channel by its number.
//  ch -sn <name>        Switch to a channel by its name.
//  ch -ci <#>           Close a channel by its number.
//  ch -cn <name>        Close a channel by its name.
//  
//  Press <esc><tab> to select a channel.
//  Press <esc><tab>0 to return to the SAC channel.
//
#define SAC_HELP_CH_CMD_EXT              ((ULONG)0x00000088L)

//
// MessageId: SAC_CHANNEL_NOT_FOUND_AT_INDEX
//
// MessageText:
//
//  Error: There is no channel present at the specified index.
//
#define SAC_CHANNEL_NOT_FOUND_AT_INDEX   ((ULONG)0x00000089L)

//
// MessageId: PRIMARY_SAC_CHANNEL_NAME
//
// MessageText:
//
//  SAC%0
//
#define PRIMARY_SAC_CHANNEL_NAME         ((ULONG)0x00000090L)

//
// MessageId: PRIMARY_SAC_CHANNEL_DESCRIPTION
//
// MessageText:
//
//  Special Administration Console%0
//
#define PRIMARY_SAC_CHANNEL_DESCRIPTION  ((ULONG)0x00000091L)

//
// MessageId: CMD_CHANNEL_DESCRIPTION
//
// MessageText:
//
//  Command Prompt%0
//
#define CMD_CHANNEL_DESCRIPTION          ((ULONG)0x00000092L)

//
// MessageId: SAC_CMD_CHANNELS_LOCKED
//
// MessageText:
//
//  Locked access to all Command Prompt channels.
//
#define SAC_CMD_CHANNELS_LOCKED          ((ULONG)0x00000093L)

//
// MessageId: SAC_CMD_LAUNCHING_DISABLED
//
// MessageText:
//
//  Launching of Command Prompt channels is disabled.
//
#define SAC_CMD_LAUNCHING_DISABLED       ((ULONG)0x00000094L)

//
// MessageId: SAC_INVALID_SUBNETMASK
//
// MessageText:
//
//  The specified subnet mask is invalid.
//
#define SAC_INVALID_SUBNETMASK           ((ULONG)0x00000095L)

//
// MessageId: SAC_INVALID_NETWORK_INTERFACE_NUMBER
//
// MessageText:
//
//  Error, missing network interface number.
//
#define SAC_INVALID_NETWORK_INTERFACE_NUMBER ((ULONG)0x00000096L)

//
// MessageId: SAC_INVALID_IPADDRESS
//
// MessageText:
//
//  The specified IP address is invalid.
//
#define SAC_INVALID_IPADDRESS            ((ULONG)0x00000097L)

//
// MessageId: SAC_INVALID_GATEWAY_IPADDRESS
//
// MessageText:
//
//  The specified gateway IP address is invalid.
//
#define SAC_INVALID_GATEWAY_IPADDRESS    ((ULONG)0x00000098L)

//
// MessageId: SAC_DEFAULT_MACHINENAME
//
// MessageText:
//
//  not yet initialized%0
//
#define SAC_DEFAULT_MACHINENAME          ((ULONG)0x00000099L)

//
// MessageId: SAC_CMD_CHAN_MGR_IS_FULL
//
// MessageText:
//
//  The maximum number of channels has been reached.  
//
#define SAC_CMD_CHAN_MGR_IS_FULL         ((ULONG)0x0000009AL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\sdpnode.h ===
#ifndef _SDPNODE_H__
#define _SDPNODE_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef UCHAR SDP_BOOLEAN;

typedef struct ISdpNodeContainer ISdpNodeContainer;

typedef struct _SDP_NODE_HEADER {
    LIST_ENTRY Link;
    USHORT Type;
    USHORT SpecificType;
} SDP_NODE_HEADER, *PSDP_NODE_HEADER;

typedef union _SDP_NODE_DATA {
    // the nil type contains no data, so no storage is necessary

    // 16 byte integers
    //
    // ISSUE is there a better way to represent a 16 byte int???
    //
    SDP_LARGE_INTEGER_16 int128;
    SDP_ULARGE_INTEGER_16 uint128;

    // UUID
    GUID uuid128;
    ULONG uuid32;
    USHORT uuid16;

    // 8 byte integers
    LONGLONG int64;
    ULONGLONG uint64;

    // 4 byte integers
    LONG int32;
    ULONG uint32;

    // 2 byte integers
    SHORT int16;
    USHORT uint16;

    // 1 bytes integers
    CHAR int8;
    UCHAR uint8;

    // Boolean
    SDP_BOOLEAN boolean;

    // string
    PCHAR string;

    // URL
    PCHAR url;

    // Sequence
	SDP_NODE_HEADER sequence;

    // Alt list
    SDP_NODE_HEADER alternative;

    ISdpNodeContainer *container;

    struct {
        PUCHAR stream;
        ULONG streamLength;
    };

} SDP_NODE_DATA, *PSDP_NODE_DATA;

typedef struct _SDP_NODE {
	SDP_NODE_HEADER  hdr;

    ULONG DataSize;

	SDP_NODE_DATA u;

	PVOID Reserved;
} SDP_NODE, *PSDP_NODE;

typedef struct _SDP_TREE_ROOT_NODE {
    SDP_NODE RootNode;
} SDP_TREE_ROOT_NODE, *PSDP_TREE_ROOT_NODE;

#define SdpNode_GetType(pNode) ((pNode)->hdr.Type)
#define SdpNode_GetSpecificType(pNode) ((pNode)->hdr.SpecificType)

#define ListEntryToSdpNode(pListEntry) CONTAINING_RECORD((pListEntry), SDP_NODE, hdr.Link)

#define SdpNode_GetNextEntry(pNode) ((pNode)->hdr.Link.Flink)
#define SdpNode_GetPrevEntry(pNode) ((pNode)->hdr.Link.Blink)

#define SdpNode_SequenceGetListHead(pNode) (&(pNode)->u.sequence.Link)
#define SdpNode_SequenceGetFirstNode(pNode) ((pNode)->u.sequence.Link.Flink)

#define SdpNode_AlternativeGetListHead(pNode) (&(pNode)->u.alternative.Link)
#define SdpNode_AlternativeGetFirstNode(pNode) ((pNode)->u.alternative.Link.Flink)

#ifdef __cplusplus
}
#endif

#endif // _SDPNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\volprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       volprop.h
//
//--------------------------------------------------------------------------

#ifndef VOLPROP_H
#define VOLPROP_H

#include <setupapi.h>

// PROPERTY_PAGE_DATA is used to communicated data between this property page
// provider and Logical Disk Management.
//
#define SIZE_LENGTH     100      // make them big enough to avoid 
#define ITEM_LENGTH     100      // localization problem
#define LABEL_LENGTH    100

typedef struct _VOLUME_DATA {
    TCHAR Size[SIZE_LENGTH];
    TCHAR Label[LABEL_LENGTH];   // ISSUE: what is the max size?
    TCHAR *MountName;
} VOLUME_DATA, *PVOLUME_DATA;

typedef struct _PROPERTY_PAGE_DATA {
    TCHAR DiskName[ITEM_LENGTH];   // ISSUE: what are the max sizes? e.g "CDROM 1000".
    TCHAR DiskStatus[ITEM_LENGTH]; //        "Unknown, Online, Offline, etc"
    TCHAR DiskType[ITEM_LENGTH];   //        "Basic, Dynamic"
    TCHAR DiskPartitionStyle[ITEM_LENGTH];
    TCHAR DiskCapacity[SIZE_LENGTH]; //        "1500 GB", "1500 MB"
    TCHAR DiskFreeSpace[SIZE_LENGTH]; 
    TCHAR DiskReservedSpace[SIZE_LENGTH];
    
    HANDLE ImageList;
    int    VolumeCount;
    VOLUME_DATA VolumeArray[1];

} PROPERTY_PAGE_DATA, *PPROPERTY_PAGE_DATA;

typedef struct _VOLUME_PAGE_DATA {
    HDEVINFO DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    BOOL  bIsLocalMachine;
    BOOL  bInvokedByDiskmgr;
    TCHAR MachineName[MAX_COMPUTERNAME_LENGTH+3];
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PPROPERTY_PAGE_DATA pPropertyPageData;

} VOLUME_PAGE_DATA, *PVOLUME_PAGE_DATA;

// IsRequestPending() is exported from dmdskmgr.dll
//
typedef BOOL (WINAPI *IS_REQUEST_PENDING)();

// GetPropertyPageData() is exported from dmdskmgr.dll.
//
typedef PPROPERTY_PAGE_DATA (WINAPI *GET_PROPERTY_PAGE_DATA)(
    TCHAR *MachineName,
    TCHAR  *DeviceInstanceId
    );

// LoadPropertyPageData() is exported from dmdskmgr.dll
//
typedef PPROPERTY_PAGE_DATA (WINAPI *LOAD_PROPERTY_PAGE_DATA)(
    TCHAR *MachineName,
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData
    );

INT_PTR
VolumeDialogProc(HWND hWnd,
                 UINT Message,
                 WPARAM wParam,
                 LPARAM lParam);
BOOL
VolumeDialogCallback(
    HWND HWnd,
    UINT Message,
    LPPROPSHEETPAGE Page
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\vscoordint.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for vscoordint.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vscoordint_h__
#define __vscoordint_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssCoordinator_FWD_DEFINED__
#define __IVssCoordinator_FWD_DEFINED__
typedef interface IVssCoordinator IVssCoordinator;
#endif 	/* __IVssCoordinator_FWD_DEFINED__ */


#ifndef __IVssShim_FWD_DEFINED__
#define __IVssShim_FWD_DEFINED__
typedef interface IVssShim IVssShim;
#endif 	/* __IVssShim_FWD_DEFINED__ */


#ifndef __IVssAdmin_FWD_DEFINED__
#define __IVssAdmin_FWD_DEFINED__
typedef interface IVssAdmin IVssAdmin;
#endif 	/* __IVssAdmin_FWD_DEFINED__ */


#ifndef __VSSCoordinator_FWD_DEFINED__
#define __VSSCoordinator_FWD_DEFINED__

#ifdef __cplusplus
typedef class VSSCoordinator VSSCoordinator;
#else
typedef struct VSSCoordinator VSSCoordinator;
#endif /* __cplusplus */

#endif 	/* __VSSCoordinator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IVssCoordinator_INTERFACE_DEFINED__
#define __IVssCoordinator_INTERFACE_DEFINED__

/* interface IVssCoordinator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssCoordinator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da9f41d4-1a5d-41d0-a614-6dfd78df5d05")
    IVssCoordinator : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ LONG lContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartSnapshotSet( 
            /* [out] */ VSS_ID *pSnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddToSnapshotSet( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ VSS_ID *pSnapshotId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoSnapshotSet( 
            /* [in] */ IDispatch *pWriterCallback,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapshotProperties( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ VSS_SNAPSHOT_PROP *pProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExposeSnapshot( 
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_PWSZ wszPathFromRoot,
            /* [in] */ LONG lAttributes,
            /* [in] */ VSS_PWSZ wszExpose,
            /* [out] */ VSS_PWSZ *pwszExposed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImportSnapshots( 
            /* [in] */ BSTR bstrXMLSnapshotSet,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteSnapshots( 
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ LONG *plDeletedSnapshots,
            /* [out] */ VSS_ID *pNondeletedSnapshotID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakSnapshotSet( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RevertToSnapshot( 
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ BOOL bForceDismount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryRevertStatus( 
            /* [in] */ VSS_PWSZ pwszVolume,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSupported( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSupportedByThisProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSnapshotted( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSnapshotsPresent,
            /* [out] */ LONG *plSnapshotCompatibility) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetWriterInstances( 
            /* [in] */ LONG lWriterInstanceIdCount,
            /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssCoordinatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssCoordinator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssCoordinator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssCoordinator * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IVssCoordinator * This,
            /* [in] */ LONG lContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartSnapshotSet )( 
            IVssCoordinator * This,
            /* [out] */ VSS_ID *pSnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddToSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ VSS_ID *pSnapshotId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ IDispatch *pWriterCallback,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapshotProperties )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ VSS_SNAPSHOT_PROP *pProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExposeSnapshot )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_PWSZ wszPathFromRoot,
            /* [in] */ LONG lAttributes,
            /* [in] */ VSS_PWSZ wszExpose,
            /* [out] */ VSS_PWSZ *pwszExposed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ImportSnapshots )( 
            IVssCoordinator * This,
            /* [in] */ BSTR bstrXMLSnapshotSet,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Query )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteSnapshots )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ LONG *plDeletedSnapshots,
            /* [out] */ VSS_ID *pNondeletedSnapshotID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BreakSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RevertToSnapshot )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ BOOL bForceDismount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryRevertStatus )( 
            IVssCoordinator * This,
            /* [in] */ VSS_PWSZ pwszVolume,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSupported )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSupportedByThisProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSnapshotted )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSnapshotsPresent,
            /* [out] */ LONG *plSnapshotCompatibility);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetWriterInstances )( 
            IVssCoordinator * This,
            /* [in] */ LONG lWriterInstanceIdCount,
            /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId);
        
        END_INTERFACE
    } IVssCoordinatorVtbl;

    interface IVssCoordinator
    {
        CONST_VTBL struct IVssCoordinatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssCoordinator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssCoordinator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssCoordinator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssCoordinator_SetContext(This,lContext)	\
    (This)->lpVtbl -> SetContext(This,lContext)

#define IVssCoordinator_StartSnapshotSet(This,pSnapshotSetId)	\
    (This)->lpVtbl -> StartSnapshotSet(This,pSnapshotSetId)

#define IVssCoordinator_AddToSnapshotSet(This,pwszVolumeName,ProviderId,pSnapshotId)	\
    (This)->lpVtbl -> AddToSnapshotSet(This,pwszVolumeName,ProviderId,pSnapshotId)

#define IVssCoordinator_DoSnapshotSet(This,pWriterCallback,ppAsync)	\
    (This)->lpVtbl -> DoSnapshotSet(This,pWriterCallback,ppAsync)

#define IVssCoordinator_GetSnapshotProperties(This,SnapshotId,pProp)	\
    (This)->lpVtbl -> GetSnapshotProperties(This,SnapshotId,pProp)

#define IVssCoordinator_ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)	\
    (This)->lpVtbl -> ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)

#define IVssCoordinator_ImportSnapshots(This,bstrXMLSnapshotSet,ppAsync)	\
    (This)->lpVtbl -> ImportSnapshots(This,bstrXMLSnapshotSet,ppAsync)

#define IVssCoordinator_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)	\
    (This)->lpVtbl -> Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)

#define IVssCoordinator_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)	\
    (This)->lpVtbl -> DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)

#define IVssCoordinator_BreakSnapshotSet(This,SnapshotSetId)	\
    (This)->lpVtbl -> BreakSnapshotSet(This,SnapshotSetId)

#define IVssCoordinator_RevertToSnapshot(This,SnapshotId,bForceDismount)	\
    (This)->lpVtbl -> RevertToSnapshot(This,SnapshotId,bForceDismount)

#define IVssCoordinator_QueryRevertStatus(This,pwszVolume,ppAsync)	\
    (This)->lpVtbl -> QueryRevertStatus(This,pwszVolume,ppAsync)

#define IVssCoordinator_IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)	\
    (This)->lpVtbl -> IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)

#define IVssCoordinator_IsVolumeSnapshotted(This,ProviderId,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)	\
    (This)->lpVtbl -> IsVolumeSnapshotted(This,ProviderId,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)

#define IVssCoordinator_SetWriterInstances(This,lWriterInstanceIdCount,rgWriterInstanceId)	\
    (This)->lpVtbl -> SetWriterInstances(This,lWriterInstanceIdCount,rgWriterInstanceId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_SetContext_Proxy( 
    IVssCoordinator * This,
    /* [in] */ LONG lContext);


void __RPC_STUB IVssCoordinator_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_StartSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [out] */ VSS_ID *pSnapshotSetId);


void __RPC_STUB IVssCoordinator_StartSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_AddToSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [in] */ VSS_ID ProviderId,
    /* [out] */ VSS_ID *pSnapshotId);


void __RPC_STUB IVssCoordinator_AddToSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_DoSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ IDispatch *pWriterCallback,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_DoSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_GetSnapshotProperties_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [out] */ VSS_SNAPSHOT_PROP *pProp);


void __RPC_STUB IVssCoordinator_GetSnapshotProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_ExposeSnapshot_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [in] */ VSS_PWSZ wszPathFromRoot,
    /* [in] */ LONG lAttributes,
    /* [in] */ VSS_PWSZ wszExpose,
    /* [out] */ VSS_PWSZ *pwszExposed);


void __RPC_STUB IVssCoordinator_ExposeSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_ImportSnapshots_Proxy( 
    IVssCoordinator * This,
    /* [in] */ BSTR bstrXMLSnapshotSet,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_ImportSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_Query_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID QueriedObjectId,
    /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
    /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
    /* [out] */ IVssEnumObject **ppEnum);


void __RPC_STUB IVssCoordinator_Query_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_DeleteSnapshots_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SourceObjectId,
    /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
    /* [in] */ BOOL bForceDelete,
    /* [out] */ LONG *plDeletedSnapshots,
    /* [out] */ VSS_ID *pNondeletedSnapshotID);


void __RPC_STUB IVssCoordinator_DeleteSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_BreakSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotSetId);


void __RPC_STUB IVssCoordinator_BreakSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_RevertToSnapshot_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [in] */ BOOL bForceDismount);


void __RPC_STUB IVssCoordinator_RevertToSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_QueryRevertStatus_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_PWSZ pwszVolume,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_QueryRevertStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_IsVolumeSupported_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ BOOL *pbSupportedByThisProvider);


void __RPC_STUB IVssCoordinator_IsVolumeSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_IsVolumeSnapshotted_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ BOOL *pbSnapshotsPresent,
    /* [out] */ LONG *plSnapshotCompatibility);


void __RPC_STUB IVssCoordinator_IsVolumeSnapshotted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_SetWriterInstances_Proxy( 
    IVssCoordinator * This,
    /* [in] */ LONG lWriterInstanceIdCount,
    /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId);


void __RPC_STUB IVssCoordinator_SetWriterInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssCoordinator_INTERFACE_DEFINED__ */


#ifndef __IVssShim_INTERFACE_DEFINED__
#define __IVssShim_INTERFACE_DEFINED__

/* interface IVssShim */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssShim;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6222095-05C3-42f3-81D9-A4A0CEC05C26")
    IVssShim : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SimulateSnapshotFreeze( 
            /* [in] */ VSS_ID guidSnapshotSetId,
            /* [in] */ ULONG ulOptionFlags,
            /* [in] */ ULONG ulVolumeCount,
            /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SimulateSnapshotThaw( 
            /* [in] */ VSS_ID guidSnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForSubscribingCompletion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssShimVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssShim * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssShim * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssShim * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SimulateSnapshotFreeze )( 
            IVssShim * This,
            /* [in] */ VSS_ID guidSnapshotSetId,
            /* [in] */ ULONG ulOptionFlags,
            /* [in] */ ULONG ulVolumeCount,
            /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SimulateSnapshotThaw )( 
            IVssShim * This,
            /* [in] */ VSS_ID guidSnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForSubscribingCompletion )( 
            IVssShim * This);
        
        END_INTERFACE
    } IVssShimVtbl;

    interface IVssShim
    {
        CONST_VTBL struct IVssShimVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssShim_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssShim_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssShim_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssShim_SimulateSnapshotFreeze(This,guidSnapshotSetId,ulOptionFlags,ulVolumeCount,ppwszVolumeNamesArray,ppAsync)	\
    (This)->lpVtbl -> SimulateSnapshotFreeze(This,guidSnapshotSetId,ulOptionFlags,ulVolumeCount,ppwszVolumeNamesArray,ppAsync)

#define IVssShim_SimulateSnapshotThaw(This,guidSnapshotSetId)	\
    (This)->lpVtbl -> SimulateSnapshotThaw(This,guidSnapshotSetId)

#define IVssShim_WaitForSubscribingCompletion(This)	\
    (This)->lpVtbl -> WaitForSubscribingCompletion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_SimulateSnapshotFreeze_Proxy( 
    IVssShim * This,
    /* [in] */ VSS_ID guidSnapshotSetId,
    /* [in] */ ULONG ulOptionFlags,
    /* [in] */ ULONG ulVolumeCount,
    /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssShim_SimulateSnapshotFreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_SimulateSnapshotThaw_Proxy( 
    IVssShim * This,
    /* [in] */ VSS_ID guidSnapshotSetId);


void __RPC_STUB IVssShim_SimulateSnapshotThaw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_WaitForSubscribingCompletion_Proxy( 
    IVssShim * This);


void __RPC_STUB IVssShim_WaitForSubscribingCompletion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssShim_INTERFACE_DEFINED__ */


#ifndef __IVssAdmin_INTERFACE_DEFINED__
#define __IVssAdmin_INTERFACE_DEFINED__

/* interface IVssAdmin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77ED5996-2F63-11d3-8A39-00C04F72D8E3")
    IVssAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ VSS_ID ProviderId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [out] */ IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortAllSnapshotsInProgress( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            IVssAdmin * This,
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            IVssAdmin * This,
            /* [in] */ VSS_ID ProviderId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            IVssAdmin * This,
            /* [out] */ IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortAllSnapshotsInProgress )( 
            IVssAdmin * This);
        
        END_INTERFACE
    } IVssAdminVtbl;

    interface IVssAdmin
    {
        CONST_VTBL struct IVssAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssAdmin_RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)	\
    (This)->lpVtbl -> RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)

#define IVssAdmin_UnregisterProvider(This,ProviderId)	\
    (This)->lpVtbl -> UnregisterProvider(This,ProviderId)

#define IVssAdmin_QueryProviders(This,ppEnum)	\
    (This)->lpVtbl -> QueryProviders(This,ppEnum)

#define IVssAdmin_AbortAllSnapshotsInProgress(This)	\
    (This)->lpVtbl -> AbortAllSnapshotsInProgress(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_RegisterProvider_Proxy( 
    IVssAdmin * This,
    /* [in] */ VSS_ID pProviderId,
    /* [in] */ CLSID ClassId,
    /* [in] */ VSS_PWSZ pwszProviderName,
    /* [in] */ VSS_PROVIDER_TYPE eProviderType,
    /* [in] */ VSS_PWSZ pwszProviderVersion,
    /* [in] */ VSS_ID ProviderVersionId);


void __RPC_STUB IVssAdmin_RegisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_UnregisterProvider_Proxy( 
    IVssAdmin * This,
    /* [in] */ VSS_ID ProviderId);


void __RPC_STUB IVssAdmin_UnregisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_QueryProviders_Proxy( 
    IVssAdmin * This,
    /* [out] */ IVssEnumObject **ppEnum);


void __RPC_STUB IVssAdmin_QueryProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_AbortAllSnapshotsInProgress_Proxy( 
    IVssAdmin * This);


void __RPC_STUB IVssAdmin_AbortAllSnapshotsInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssAdmin_INTERFACE_DEFINED__ */



#ifndef __VSS_LIBRARY_DEFINED__
#define __VSS_LIBRARY_DEFINED__

/* library VSS */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSS;

EXTERN_C const CLSID CLSID_VSSCoordinator;

#ifdef __cplusplus

class DECLSPEC_UUID("E579AB5F-1CC4-44b4-BED9-DE0991FF0623")
VSSCoordinator;
#endif
#endif /* __VSS_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\vsmgmt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for vsmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vsmgmt_h__
#define __vsmgmt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssSnapshotMgmt_FWD_DEFINED__
#define __IVssSnapshotMgmt_FWD_DEFINED__
typedef interface IVssSnapshotMgmt IVssSnapshotMgmt;
#endif 	/* __IVssSnapshotMgmt_FWD_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__
typedef interface IVssDifferentialSoftwareSnapshotMgmt IVssDifferentialSoftwareSnapshotMgmt;
#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt_FWD_DEFINED__ */


#ifndef __IVssEnumMgmtObject_FWD_DEFINED__
#define __IVssEnumMgmtObject_FWD_DEFINED__
typedef interface IVssEnumMgmtObject IVssEnumMgmtObject;
#endif 	/* __IVssEnumMgmtObject_FWD_DEFINED__ */


#ifndef __VssSnapshotMgmt_FWD_DEFINED__
#define __VssSnapshotMgmt_FWD_DEFINED__

#ifdef __cplusplus
typedef class VssSnapshotMgmt VssSnapshotMgmt;
#else
typedef struct VssSnapshotMgmt VssSnapshotMgmt;
#endif /* __cplusplus */

#endif 	/* __VssSnapshotMgmt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_vsmgmt_0000 */
/* [local] */ 

typedef 
enum _VSS_MGMT_OBJECT_TYPE
    {	VSS_MGMT_OBJECT_UNKNOWN	= 0,
	VSS_MGMT_OBJECT_VOLUME	= VSS_MGMT_OBJECT_UNKNOWN + 1,
	VSS_MGMT_OBJECT_DIFF_VOLUME	= VSS_MGMT_OBJECT_VOLUME + 1,
	VSS_MGMT_OBJECT_DIFF_AREA	= VSS_MGMT_OBJECT_DIFF_VOLUME + 1
    } 	VSS_MGMT_OBJECT_TYPE;

#define	VSS_ASSOC_NO_MAX_SPACE	( -1 )

#define	VSS_ASSOC_REMOVE	( 0 )

typedef struct _VSS_VOLUME_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszVolumeDisplayName;
    } 	VSS_VOLUME_PROP;

typedef struct _VSS_VOLUME_PROP *PVSS_VOLUME_PROP;

typedef struct _VSS_DIFF_VOLUME_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszVolumeDisplayName;
    LONGLONG m_llVolumeFreeSpace;
    LONGLONG m_llVolumeTotalSpace;
    } 	VSS_DIFF_VOLUME_PROP;

typedef struct _VSS_DIFF_VOLUME_PROP *PVSS_DIFF_VOLUME_PROP;

typedef struct _VSS_DIFF_AREA_PROP
    {
    VSS_PWSZ m_pwszVolumeName;
    VSS_PWSZ m_pwszDiffAreaVolumeName;
    LONGLONG m_llMaximumDiffSpace;
    LONGLONG m_llAllocatedDiffSpace;
    LONGLONG m_llUsedDiffSpace;
    } 	VSS_DIFF_AREA_PROP;

typedef struct _VSS_DIFF_AREA_PROP *PVSS_DIFF_AREA_PROP;

typedef /* [public][public][public][public][switch_type] */ union __MIDL___MIDL_itf_vsmgmt_0000_0001
    {
    /* [case()] */ VSS_VOLUME_PROP Vol;
    /* [case()] */ VSS_DIFF_VOLUME_PROP DiffVol;
    /* [case()] */ VSS_DIFF_AREA_PROP DiffArea;
    /* [default] */  /* Empty union arm */ 
    } 	VSS_MGMT_OBJECT_UNION;

typedef struct _VSS_MGMT_OBJECT_PROP
    {
    VSS_MGMT_OBJECT_TYPE Type;
    /* [switch_is] */ VSS_MGMT_OBJECT_UNION Obj;
    } 	VSS_MGMT_OBJECT_PROP;

typedef struct _VSS_MGMT_OBJECT_PROP *PVSS_MGMT_OBJECT_PROP;






extern RPC_IF_HANDLE __MIDL_itf_vsmgmt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vsmgmt_0000_v0_0_s_ifspec;

#ifndef __IVssSnapshotMgmt_INTERFACE_DEFINED__
#define __IVssSnapshotMgmt_INTERFACE_DEFINED__

/* interface IVssSnapshotMgmt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssSnapshotMgmt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA7DF749-66E7-4986-A27F-E2F04AE53772")
    IVssSnapshotMgmt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProviderMgmtInterface( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ REFIID InterfaceId,
            /* [iid_is][out] */ IUnknown **ppItf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVolumesSupportedForSnapshots( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext,
            /* [out] */ IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySnapshotsByVolume( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ IVssEnumObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssSnapshotMgmtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssSnapshotMgmt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssSnapshotMgmt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssSnapshotMgmt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProviderMgmtInterface )( 
            IVssSnapshotMgmt * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ REFIID InterfaceId,
            /* [iid_is][out] */ IUnknown **ppItf);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForSnapshots )( 
            IVssSnapshotMgmt * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ LONG lContext,
            /* [out] */ IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySnapshotsByVolume )( 
            IVssSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ IVssEnumObject **ppEnum);
        
        END_INTERFACE
    } IVssSnapshotMgmtVtbl;

    interface IVssSnapshotMgmt
    {
        CONST_VTBL struct IVssSnapshotMgmtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssSnapshotMgmt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssSnapshotMgmt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssSnapshotMgmt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssSnapshotMgmt_GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf)	\
    (This)->lpVtbl -> GetProviderMgmtInterface(This,ProviderId,InterfaceId,ppItf)

#define IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots(This,ProviderId,lContext,ppEnum)	\
    (This)->lpVtbl -> QueryVolumesSupportedForSnapshots(This,ProviderId,lContext,ppEnum)

#define IVssSnapshotMgmt_QuerySnapshotsByVolume(This,pwszVolumeName,ProviderId,ppEnum)	\
    (This)->lpVtbl -> QuerySnapshotsByVolume(This,pwszVolumeName,ProviderId,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVssSnapshotMgmt_GetProviderMgmtInterface_Proxy( 
    IVssSnapshotMgmt * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ REFIID InterfaceId,
    /* [iid_is][out] */ IUnknown **ppItf);


void __RPC_STUB IVssSnapshotMgmt_GetProviderMgmtInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots_Proxy( 
    IVssSnapshotMgmt * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ LONG lContext,
    /* [out] */ IVssEnumMgmtObject **ppEnum);


void __RPC_STUB IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssSnapshotMgmt_QuerySnapshotsByVolume_Proxy( 
    IVssSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [in] */ VSS_ID ProviderId,
    /* [out] */ IVssEnumObject **ppEnum);


void __RPC_STUB IVssSnapshotMgmt_QuerySnapshotsByVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssSnapshotMgmt_INTERFACE_DEFINED__ */


#ifndef __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__
#define __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__

/* interface IVssDifferentialSoftwareSnapshotMgmt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssDifferentialSoftwareSnapshotMgmt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("214A0F28-B737-4026-B847-4F9E37D79529")
    IVssDifferentialSoftwareSnapshotMgmt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddDiffArea( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeDiffAreaMaximumSize( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVolumesSupportedForDiffAreas( 
            /* [in] */ VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasForVolume( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasOnVolume( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDiffAreasForSnapshot( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ IVssEnumMgmtObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssDifferentialSoftwareSnapshotMgmtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssDifferentialSoftwareSnapshotMgmt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssDifferentialSoftwareSnapshotMgmt * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddDiffArea )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDiffAreaMaximumSize )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
            /* [in] */ LONGLONG llMaximumDiffSpace);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVolumesSupportedForDiffAreas )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszOriginalVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForVolume )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasOnVolume )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ IVssEnumMgmtObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDiffAreasForSnapshot )( 
            IVssDifferentialSoftwareSnapshotMgmt * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ IVssEnumMgmtObject **ppEnum);
        
        END_INTERFACE
    } IVssDifferentialSoftwareSnapshotMgmtVtbl;

    interface IVssDifferentialSoftwareSnapshotMgmt
    {
        CONST_VTBL struct IVssDifferentialSoftwareSnapshotMgmtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssDifferentialSoftwareSnapshotMgmt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssDifferentialSoftwareSnapshotMgmt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssDifferentialSoftwareSnapshotMgmt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    (This)->lpVtbl -> AddDiffArea(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)

#define IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)	\
    (This)->lpVtbl -> ChangeDiffAreaMaximumSize(This,pwszVolumeName,pwszDiffAreaVolumeName,llMaximumDiffSpace)

#define IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)	\
    (This)->lpVtbl -> QueryVolumesSupportedForDiffAreas(This,pwszOriginalVolumeName,ppEnum)

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)	\
    (This)->lpVtbl -> QueryDiffAreasForVolume(This,pwszVolumeName,ppEnum)

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)	\
    (This)->lpVtbl -> QueryDiffAreasOnVolume(This,pwszVolumeName,ppEnum)

#define IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)	\
    (This)->lpVtbl -> QueryDiffAreasForSnapshot(This,SnapshotId,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
    /* [in] */ LONGLONG llMaximumDiffSpace);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [in] */ VSS_PWSZ pwszDiffAreaVolumeName,
    /* [in] */ LONGLONG llMaximumDiffSpace);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszOriginalVolumeName,
    /* [out] */ IVssEnumMgmtObject **ppEnum);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ IVssEnumMgmtObject **ppEnum);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ IVssEnumMgmtObject **ppEnum);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot_Proxy( 
    IVssDifferentialSoftwareSnapshotMgmt * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [out] */ IVssEnumMgmtObject **ppEnum);


void __RPC_STUB IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssDifferentialSoftwareSnapshotMgmt_INTERFACE_DEFINED__ */


#ifndef __IVssEnumMgmtObject_INTERFACE_DEFINED__
#define __IVssEnumMgmtObject_INTERFACE_DEFINED__

/* interface IVssEnumMgmtObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssEnumMgmtObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01954E6B-9254-4e6e-808C-C9E05D007696")
    IVssEnumMgmtObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ VSS_MGMT_OBJECT_PROP *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out][in] */ IVssEnumMgmtObject **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssEnumMgmtObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssEnumMgmtObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssEnumMgmtObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssEnumMgmtObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IVssEnumMgmtObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ VSS_MGMT_OBJECT_PROP *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IVssEnumMgmtObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IVssEnumMgmtObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IVssEnumMgmtObject * This,
            /* [out][in] */ IVssEnumMgmtObject **ppenum);
        
        END_INTERFACE
    } IVssEnumMgmtObjectVtbl;

    interface IVssEnumMgmtObject
    {
        CONST_VTBL struct IVssEnumMgmtObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssEnumMgmtObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssEnumMgmtObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssEnumMgmtObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssEnumMgmtObject_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IVssEnumMgmtObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IVssEnumMgmtObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IVssEnumMgmtObject_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVssEnumMgmtObject_Next_Proxy( 
    IVssEnumMgmtObject * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ VSS_MGMT_OBJECT_PROP *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IVssEnumMgmtObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssEnumMgmtObject_Skip_Proxy( 
    IVssEnumMgmtObject * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IVssEnumMgmtObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssEnumMgmtObject_Reset_Proxy( 
    IVssEnumMgmtObject * This);


void __RPC_STUB IVssEnumMgmtObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVssEnumMgmtObject_Clone_Proxy( 
    IVssEnumMgmtObject * This,
    /* [out][in] */ IVssEnumMgmtObject **ppenum);


void __RPC_STUB IVssEnumMgmtObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssEnumMgmtObject_INTERFACE_DEFINED__ */



#ifndef __VSMGMT_LIBRARY_DEFINED__
#define __VSMGMT_LIBRARY_DEFINED__

/* library VSMGMT */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSMGMT;

EXTERN_C const CLSID CLSID_VssSnapshotMgmt;

#ifdef __cplusplus

class DECLSPEC_UUID("0B5A2C52-3EB9-470a-96E2-6C6D4570E40F")
VssSnapshotMgmt;
#endif
#endif /* __VSMGMT_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\vsswprv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for vsswprv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vsswprv_h__
#define __vsswprv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __VSSoftwareProvider_FWD_DEFINED__
#define __VSSoftwareProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class VSSoftwareProvider VSSoftwareProvider;
#else
typedef struct VSSoftwareProvider VSSoftwareProvider;
#endif /* __cplusplus */

#endif 	/* __VSSoftwareProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_vsswprv_0000 */
/* [local] */ 

const GUID VSS_SWPRV_ProviderId = { 0xb5946137, 0x7b9f, 0x4925, { 0xaf, 0x80, 0x51, 0xab, 0xd6, 0xb, 0x20, 0xd5 } };


extern RPC_IF_HANDLE __MIDL_itf_vsswprv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vsswprv_0000_v0_0_s_ifspec;


#ifndef __VSSW_LIBRARY_DEFINED__
#define __VSSW_LIBRARY_DEFINED__

/* library VSSW */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSSW;

EXTERN_C const CLSID CLSID_VSSoftwareProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("65EE1DBA-8FF4-4a58-AC1C-3470EE2F376A")
VSSoftwareProvider;
#endif
#endif /* __VSSW_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\alloca.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    alloca.h

Abstract:

    This module implements a safe stack-based allocator with fallback to the heap.

Author:

    Jonathan Schwartz (JSchwart)  16-Mar-2001

Revision History:

--*/

#ifndef _SAFEALLOCA_H_
#define _SAFEALLOCA_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <align.h>    // ALIGN_WORST


//
// Type definitions
//

typedef ULONG SAFEALLOCA_HEADER;

typedef PVOID (APIENTRY *SAFEALLOC_ALLOC_PROC)(
    SIZE_T Size
    );

typedef VOID (APIENTRY *SAFEALLOC_FREE_PROC)(
    PVOID BaseAddress
    );


//
// Constant definitions
//

#ifndef SAFEALLOCA_ASSERT
#define SAFEALLOCA_ASSERT ASSERT
#endif

#define SAFEALLOCA_STACK_HEADER    ((SAFEALLOCA_HEADER) 0x6b637453)   /* "Stck" */
#define SAFEALLOCA_HEAP_HEADER     ((SAFEALLOCA_HEADER) 0x70616548)   /* "Heap" */

#define SAFEALLOCA_USE_DEFAULT     0xdeadbeef

//
// We'll be adding ALIGN_WORST bytes to the allocation size to add room for
// the SAFEALLOCA_HEADER -- make sure we'll always have enough space.
//

C_ASSERT(sizeof(SAFEALLOCA_HEADER) <= ALIGN_WORST);


//
// Per-DLL SafeAlloca globals
//

extern SIZE_T  g_ulMaxStackAllocSize;
extern SIZE_T  g_ulAdditionalProbeSize;

extern SAFEALLOC_ALLOC_PROC  g_pfnAllocate;
extern SAFEALLOC_FREE_PROC   g_pfnFree;


//
// Functions defined in alloca.lib
//

VOID
SafeAllocaInitialize(
    IN           SIZE_T                ulMaxStackAllocSize,
    IN           SIZE_T                ulAdditionalProbeSize,
    IN  OPTIONAL SAFEALLOC_ALLOC_PROC  pfnAllocate,
    IN  OPTIONAL SAFEALLOC_FREE_PROC   pfnFree
    );

BOOL
VerifyStackAvailable(
    SIZE_T Size
    );


//
// Usage:
//
//     VOID
//     SafeAllocaAllocate(
//         PVOID  PtrVar,
//         SIZE_T BlockSize
//         );
//
// (PtrVar == NULL) on failure
//

#define SafeAllocaAllocate(PtrVar, BlockSize)                                            \
                                                                                         \
    {                                                                                    \
        PVOID *ppvAvoidCast = (PVOID *) &(PtrVar);                                       \
                                                                                         \
        (PtrVar) = NULL;                                                                 \
                                                                                         \
        /* Make sure block is below the threshhold and that the probe won't overflow */  \
                                                                                         \
        if ((BlockSize) <= g_ulMaxStackAllocSize                                         \
             &&                                                                          \
            ((BlockSize) + g_ulAdditionalProbeSize + ALIGN_WORST >= (BlockSize)))        \
        {                                                                                \
            if (VerifyStackAvailable((BlockSize)                                         \
                                         + g_ulAdditionalProbeSize                       \
                                         + ALIGN_WORST))                                 \
            {                                                                            \
                /*                                                                       \
                 * Don't need to wrap with try-except since we just probed               \
                 */                                                                      \
                                                                                         \
                *ppvAvoidCast = _alloca((BlockSize) + ALIGN_WORST);                      \
            }                                                                            \
                                                                                         \
            if ((PtrVar) != NULL)                                                        \
            {                                                                            \
                *((SAFEALLOCA_HEADER *) (PtrVar)) = SAFEALLOCA_STACK_HEADER;             \
                *ppvAvoidCast = ((LPBYTE) (PtrVar) + ALIGN_WORST);                       \
            }                                                                            \
        }                                                                                \
                                                                                         \
        /*                                                                               \
         * Stack allocation failed -- try the heap                                       \
         */                                                                              \
                                                                                         \
        if ((PtrVar) == NULL)                                                            \
        {                                                                                \
            *ppvAvoidCast = g_pfnAllocate((BlockSize) + ALIGN_WORST);                    \
                                                                                         \
            if ((PtrVar) != NULL)                                                        \
            {                                                                            \
                *((SAFEALLOCA_HEADER *) (PtrVar)) = SAFEALLOCA_HEAP_HEADER;              \
                *ppvAvoidCast = ((LPBYTE) (PtrVar) + ALIGN_WORST);                       \
            }                                                                            \
        }                                                                                \
    }


//
// Usage:
//
//     VOID
//     SafeAllocaFree(
//         PVOID  PtrVar,
//         );
//

#define SafeAllocaFree(PtrVar)                                                         \
                                                                                       \
    if (PtrVar != NULL)                                                                \
    {                                                                                  \
        SAFEALLOCA_HEADER *Tag = (SAFEALLOCA_HEADER *) ((LPBYTE) (PtrVar)              \
                                      - ALIGN_WORST);                                  \
                                                                                       \
        if (*(SAFEALLOCA_HEADER *) (Tag) == SAFEALLOCA_HEAP_HEADER)                    \
        {                                                                              \
            g_pfnFree(Tag);                                                            \
        }                                                                              \
        else                                                                           \
        {                                                                              \
            SAFEALLOCA_ASSERT(*(SAFEALLOCA_HEADER *) (Tag) == SAFEALLOCA_STACK_HEADER);\
        }                                                                              \
    }

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _SAFEALLOCA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\apperr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects 

Copyright (c) 1991  Microsoft Corporation

Module Name:

    apperr.h

Abstract:

    This file contains the number and text of application error
    messages.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define APPERR_BASE     3500            /* APP errs start here */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in netcon.h for  *
 *info on the allocation of errors *
 ************************************/

/**END_INTERNAL**/

/***
 *
 *      Messages terminating multiple commands
 *
 */

#define APE_Success             (APPERR_BASE + 0) /* @I
         *
         *The command completed successfully.
         */

#define APE_InvalidSwitch               (APPERR_BASE + 1)
        /*
         *You used an invalid option.
         */

#define APE_OS2Error                    (APPERR_BASE + 2) /* @I
         *
         *System error %1 has occurred.
         */

#define APE_NumArgs             (APPERR_BASE + 3)
        /*
         *The command contains an invalid number of arguments.
         */

#define APE_CmdComplWErrors (APPERR_BASE + 4) /* @I
         *
         *The command completed with one or more errors.
         */

#define APE_InvalidSwitchArg (APPERR_BASE + 5)
        /*
         *You used an option with an invalid value.
         */

#define APE_SwUnkSw (APPERR_BASE + 6 )
        /*
         *The option %1 is unknown.
         */

#define APE_SwAmbSw (APPERR_BASE + 7 )
        /*
         *Option %1 is ambiguous.
         */

/*
 * For additional general command line switch/argument related messages,
 * see section with APE_CmdArgXXX.
 */

/***  Use the following message only for real-mode (DOS) errors.
 ***  This error is here to allow real-mode Lan Manager to share
 ***  the message file.
 ***/

#define APE_ConflictingSwitches (APPERR_BASE + 10)
        /*
         *A command was used with conflicting switches.
         */

#define APE_SubpgmNotFound (APPERR_BASE + 11)
        /*
         *Could not find subprogram %1.
         */

#define APE_GEN_OldOSVersion (APPERR_BASE + 12)
	/*
	 *The software requires a newer version of the operating
	 *system.
	 */

#define APE_MoreData (APPERR_BASE + 13)
	/*
	 *More data is available than can be returned by Windows.
	 */

#define APE_MoreHelp (APPERR_BASE + 14 ) /* @I
         *
         *More help is available by typing NET HELPMSG %1.
         */

#define APE_LanmanNTOnly (APPERR_BASE + 15)
	/*
	 *This command can be used only on a Windows Domain Controller.
	 */

#define APE_WinNTOnly (APPERR_BASE + 16)
	/*
	 *This command cannot be used on a Windows Domain Controller.
	 */

/***
 *
 *      Starting, stopping, pausing, and continuing services
 *
 */

#define APE_StartStartedList (APPERR_BASE + 20 ) /* @I
         *
         *These Windows services are started:
         */

#define APE_StartNotStarted (APPERR_BASE + 21 ) /* @I
         *
         *The %1 service is not started.
         */

#define APE_StartPending (APPERR_BASE + 22 ) /* @I
         *
         *The %1 service is starting%0
         */

#define APE_StartFailed (APPERR_BASE + 23 )  /*  @I
         *
         *The %1 service could not be started.
         */

#define APE_StartSuccess (APPERR_BASE + 24 ) /* @I
         *
         *The %1 service was started successfully.
         */

#define APE_StopSrvRunning (APPERR_BASE + 25 ) /* @I
         *
         *Stopping the Workstation service also stops the Server service.
         */

#define APE_StopRdrOpenFiles (APPERR_BASE + 26 ) /* @I
         *
         *The workstation has open files.
         */

#define APE_StopPending (APPERR_BASE + 27 ) /* @I
         *
         *The %1 service is stopping%0
         */

#define APE_StopFailed (APPERR_BASE + 28 ) /* @I
         *
         *The %1 service could not be stopped.
         */

#define APE_StopSuccess (APPERR_BASE + 29 ) /* @I
         *
         *The %1 service was stopped successfully.
         */

#define APE_StopServiceList (APPERR_BASE + 30 ) /* @I
         *
         *The following services are dependent on the %1 service.
         *Stopping the %1 service will also stop these services.
         */

#define APE_ServiceStatePending         (APPERR_BASE + 33)
        /*
         *The service is starting or stopping.  Please try again later.
         */

#define APE_NoErrorReported (APPERR_BASE + 34) /* @I
         *
         *The service did not report an error.
         */

#define APE_ContpausDevErr (APPERR_BASE + 35 ) /* @I
         *
         *An error occurred controlling the device.
         */

#define APE_ContSuccess (APPERR_BASE + 36 ) /* @I
         *
         *The %1 service was continued successfully.
         */

#define APE_PausSuccess (APPERR_BASE + 37 ) /* @I
         *
         *The %1 service was paused successfully.
         */

#define APE_ContFailed (APPERR_BASE + 38 ) /* @I
         *
         *The %1 service failed to resume.
         */

#define APE_PausFailed (APPERR_BASE + 39 ) /* @I
         *
         *The %1 service failed to pause.
         */

#define APE_ContPending (APPERR_BASE + 40 ) /* @I
         *
         *The %1 service continue is pending%0
         */

#define APE_PausPending (APPERR_BASE + 41 ) /* @I
         *
         *The %1 service pause is pending%0
         */

#define APE_DevContSuccess (APPERR_BASE + 42 ) /* @I
         *
         *%1 was continued successfully.
         */

#define APE_DevPausSuccess (APPERR_BASE + 43 ) /* @I
         *
         *%1 was paused successfully.
         */

#define APE_StartPendingOther (APPERR_BASE + 44 ) /* @I
	*
	*The %1 service has been started by another process and is pending.%0
	*/

#define APE_ServiceSpecificError (APPERR_BASE + 47 ) /* @E
	*
	*A service specific error occurred: %1.
	*/



/***
 *
 *      Information messages
 *
 */

#define APE_SessionList (APPERR_BASE + 160 ) /* @I
         *
         *These workstations have sessions on this server:
         */

#define APE_SessionOpenList (APPERR_BASE + 161 ) /* @I
         *
         *These workstations have sessions with open files on this server:
         */

#define APE_NameIsFwd (APPERR_BASE + 166 ) /* @I
         *
         *The message alias is forwarded.
         */

#define APE_KillDevList (APPERR_BASE + 170 ) /* @I
         *
         *You have these remote connections:
         */

#define APE_KillCancel (APPERR_BASE + 171 ) /* @I
         *
         *Continuing will cancel the connections.
         */

#define APE_SessionOpenFiles (APPERR_BASE + 175 ) /* @I
         *
         *The session from %1 has open files.
         */

#define APE_ConnectionsAreRemembered (APPERR_BASE + 176 ) /* @I
         *
         *New connections will be remembered.
         */

#define APE_ConnectionsAreNotRemembered (APPERR_BASE + 177 ) /* @I
         *
         *New connections will not be remembered.
         */

#define APE_ProfileWriteError (APPERR_BASE + 178 ) /* @I
         *
         *An error occurred while saving your profile. The state of your remembered connections has not changed.
         */

#define APE_ProfileReadError (APPERR_BASE + 179 ) /* @I
         *
         *An error occurred while reading your profile. 
         */

#define APE_LoadError (APPERR_BASE + 180 ) /* @E
         *
         *An error occurred while restoring the connection to %1.
         */

#define APE_NothingRunning (APPERR_BASE + 182 ) /* @I
         *
         *No network services are started.
         */

#define APE_EmptyList (APPERR_BASE + 183 ) /* @I
         *
         *There are no entries in the list.
         */

#define APE_ShareOpens  (APPERR_BASE + 188) /* @I
         *
         *Users have open files on %1.  Continuing the operation will force the files closed.
         */

#define APE_WkstaSwitchesIgnored        (APPERR_BASE + 189) /* @I
         *
         *The Workstation service is already running. Windows will ignore command options for the workstation.
         */

#define APE_OpenHandles (APPERR_BASE + 191 ) /* @I
         *
         *There are open files and/or incomplete directory searches pending on the connection to %1.
         */

#define APE_RemotingToDC (APPERR_BASE + 193 ) /* @I
         *
         *The request will be processed at a domain controller for domain %1.
         */

#define APE_ShareSpooling (APPERR_BASE + 194 ) /* @E
         *
         *The shared queue cannot be deleted while a print job is being spooled to the queue.
         */

#define APE_DeviceIsRemembered (APPERR_BASE + 195 ) /* @E
         *
         *%1 has a remembered connection to %2.
         */



/***
 *
 *      Error messages
 *
 */

#define APE_HelpFileDoesNotExist            (APPERR_BASE + 210)
        /*
         *An error occurred while opening the Help file.
         */

#define APE_HelpFileEmpty                   (APPERR_BASE + 211)
        /*
         *The Help file is empty.
         */

#define APE_HelpFileError                   (APPERR_BASE + 212)
        /*
         *The Help file is corrupted.
         */

#define APE_DCNotFound          (APPERR_BASE + 213)
        /*
         *Could not find a domain controller for domain %1.
         */

#define APE_DownlevelReqPriv    (APPERR_BASE + 214)
        /*
         *This operation is privileged on systems with earlier
         *versions of the software.
         */

#define APE_UnknDevType         (APPERR_BASE + 216)
        /*
         *The device type is unknown.
         */

#define APE_LogFileCorrupt              (APPERR_BASE + 217)
        /*
         *The log file has been corrupted.
         */

#define APE_OnlyNetRunExes      (APPERR_BASE + 218)
        /*
         *Program filenames must end with .EXE.
         */

#define APE_ShareNotFound (APPERR_BASE + 219)
        /*
         *A matching share could not be found so nothing was deleted.
         */

#define APE_UserBadUPW (APPERR_BASE + 220)
        /*
         *A bad value is in the units-per-week field of the user record.
         */

#define APE_UseBadPass (APPERR_BASE + 221 )
        /*
         *The password is invalid for %1.
         */

#define APE_SendErrSending (APPERR_BASE + 222 )
        /*
         *An error occurred while sending a message to %1.
         */

#define APE_UseBadPassOrUser (APPERR_BASE + 223 )
        /*
         *The password or user name is invalid for %1.
         */

#define APE_ShareErrDeleting (APPERR_BASE + 225 )
        /*
         *An error occurred when the share was deleted.
         */

#define APE_LogoInvalidName (APPERR_BASE + 226 )
        /*
         *The user name is invalid.
         */

#define APE_UtilInvalidPass (APPERR_BASE + 227 )
        /*
         *The password is invalid.
         */

/*  Note.  The APE_UtilNomatch error message string is used in the
 *  WINNET project, where the string is hard coded.  Therefore, if
 *  This string changes, please do also update WINNET.RC in the
 *  WINNET project (..\..\WINNET\WINNET.RC).   Thank you.
 */
#define APE_UtilNomatch (APPERR_BASE + 228 )
        /*
         *The passwords do not match.
         */

#define APE_LoadAborted (APPERR_BASE + 229 ) /* @E
         *
         *Your persistent connections were not all restored.
         */

#define APE_PassInvalidCname (APPERR_BASE + 230 )
        /*
         *This is not a valid computer name or domain name.
         */


#define APE_NoDefaultPerms  (APPERR_BASE + 232)
        /*
         *Default permissions cannot be set for that resource.
         */


/*  Note.  The APE_NoGoodPass error message string is used in the
 *  WINNET project, where the string is hard coded.  Therefore, if
 *  This string changes, please do also update WINNET.RC in the
 *  WINNET project (..\..\WINNET\WINNET.RC).   Thank you.
 */
#define APE_NoGoodPass (APPERR_BASE + 234 )
        /*
         *A valid password was not entered.
         */

#define APE_NoGoodName (APPERR_BASE + 235 )
        /*
         *A valid name was not entered.
         */

#define APE_BadResource (APPERR_BASE + 236 ) /* @E
         *
         *The resource named cannot be shared.
         */

#define APE_BadPermsString (APPERR_BASE + 237 ) /* @E
         *
         *The permissions string contains invalid permissions.
         */

#define APE_InvalidDeviceType (APPERR_BASE + 238 ) /* @E
         *
         *You can only perform this operation on printers and communication devices.
         */

#define APE_BadUGName (APPERR_BASE + 242 ) /* @E
         *
         *%1 is an invalid user or group name.
         */

#define APE_BadAdminConfig      (APPERR_BASE+243)
        /*
         *The server is not configured for remote administration.
         */

#define APE_NoUsersOfSrv                    (APPERR_BASE + 252)
        /*
         *No users have sessions with this server.
         */

#define APE_UserNotInGroup                  (APPERR_BASE + 253)
        /*
         *User %1 is not a member of group %2.
         */

#define APE_UserAlreadyInGroup              (APPERR_BASE + 254)
        /*
         *User %1 is already a member of group %2.
         */

#define APE_NoSuchUser                      (APPERR_BASE + 255)
        /*
         *There is no such user: %1.
         */

#define APE_UtilInvalidResponse     (APPERR_BASE + 256) /* @I
         *
         *This is an invalid response.
         */

#define APE_NoGoodResponse                  (APPERR_BASE + 257)
        /*
         *No valid response was provided.
         */

#define APE_ShareNoMatch                    (APPERR_BASE + 258)
        /*
         *The destination list provided does not match the destination list of the printer queue.
         */

#define APE_PassChgDate                 (APPERR_BASE + 259)
        /*
         *Your password cannot be changed until %1.
         */

/***
 *  NET USER /TIMES format messages
 *
 */

#define APE_UnrecognizedDay                 (APPERR_BASE + 260)
        /*
         *%1 is not a recognized day of the week.
         */

#define APE_ReversedTimeRange               (APPERR_BASE + 261)
        /*
         *The time range specified ends before it starts.
         */

#define APE_UnrecognizedHour                (APPERR_BASE + 262)
        /*
         *%1 is not a recognized hour.
         */

#define APE_UnrecognizedMinutes             (APPERR_BASE + 263)
        /*
         *%1 is not a valid specification for minutes.
         */

#define APE_NonzeroMinutes                  (APPERR_BASE + 264)
        /*
         *Time supplied is not exactly on the hour.
         */

#define APE_MixedTimeFormat                 (APPERR_BASE + 265)
        /*
         *12 and 24 hour time formats may not be mixed.
         */

#define APE_NeitherAmNorPm                  (APPERR_BASE + 266)
        /*
         *%1 is not a valid 12-hour suffix.
         */

#define APE_BadDateFormat                       (APPERR_BASE + 267)
        /*
         *An illegal date format has been supplied.
         */

#define APE_BadDayRange                         (APPERR_BASE + 268)
        /*
         *An illegal day range has been supplied.
         */

#define APE_BadTimeRange                        (APPERR_BASE + 269)
        /*
         *An illegal time range has been supplied.
         */


/***
 * 	Other NET USER messages
 *
 */

#define APE_UserBadArgs                      (APPERR_BASE + 270)
        /*
         *Arguments to NET USER are invalid. Check the minimum password
         *length and/or arguments supplied.
         */

#define APE_UserBadEnablescript               (APPERR_BASE + 271)
        /*
         *The value for ENABLESCRIPT must be YES.
         */

#define APE_UserBadCountryCode                (APPERR_BASE + 273)
        /*
         *An illegal country code has been supplied.
         */

#define APE_UserFailAddToUsersAlias           (APPERR_BASE + 274)
        /*
         *The user was successfully created but could not be added
	 *to the USERS local group.
         */

/***
 *
 *      Misc new messages for NT
 *
 */
#define APE_BadUserContext                (APPERR_BASE + 275)
        /*
         *The user context supplied is invalid.
         */

#define APE_ErrorInDLL                    (APPERR_BASE + 276) 
	/*
         *The dynamic-link library %1 could not be loaded, or an error
         *occurred while trying to use it.
         */

#define APE_SendFileNotSupported          (APPERR_BASE + 277)
        /*
         *Sending files is no longer supported.
         */

#define APE_CannotShareSpecial            (APPERR_BASE + 278)
        /*
         *You may not specify paths for ADMIN$ and IPC$ shares.
         */

#define APE_AccountAlreadyInLocalGroup              (APPERR_BASE + 279)
        /*
         *User or group %1 is already a member of local group %2.
         */

#define APE_NoSuchAccount                      (APPERR_BASE + 280)
        /*
         *There is no such user or group: %1.
         */

#define APE_NoSuchComputerAccount               (APPERR_BASE + 281)
        /*
         *There is no such computer: %1.
         */

#define APE_ComputerAccountExists               (APPERR_BASE + 282)
        /*
         *The computer %1 already exists.
         */

#define APE_NoSuchRegAccount                      (APPERR_BASE + 283)
        /*
         *There is no such global user or group: %1.
         */

#define APE_BadCacheType                          (APPERR_BASE + 284)
    /*
     * Only disk shares can be marked as cacheable
     */

/*
 *  Used by NETLIB
 */
#define APE_UNKNOWN_MESSAGE              (APPERR_BASE + 290) 
        /*
         *The system could not find message: %1.
         */


/***
 *
 *      AT messages
 *
 */

#define APE_AT_INVALID_SCHED_DATE           (APPERR_BASE + 302)
        /*
         *This schedule date is invalid.
         */

#define APE_AT_WKSTAGETINFO_FAILURE         (APPERR_BASE + 303)
        /*
         *The LANMAN root directory is unavailable.
         */

#define APE_AT_SCHED_FILE_FAILURE           (APPERR_BASE + 304)
        /*
         *The SCHED.LOG file could not be opened.
         */

#define APE_AT_MEM_FAILURE                  (APPERR_BASE + 305)
        /*
         *The Server service has not been started.
         */

#define APE_AT_ID_NOT_FOUND                 (APPERR_BASE + 306)
        /*
         *The AT job ID does not exist.
         */

#define APE_AT_SCHED_CORRUPT                (APPERR_BASE + 307)
        /*
         *The AT schedule file is corrupted.
         */

#define APE_AT_DELETE_FAILURE               (APPERR_BASE + 308)
        /*
         *The delete failed due to a problem with the AT schedule file.
         */

#define APE_AT_COMMAND_TOO_LONG             (APPERR_BASE + 309)
        /*
         *The command line cannot exceed 259 characters.
         */

#define APE_AT_DISKFULL                     (APPERR_BASE + 310)
        /*
         *The AT schedule file could not be updated because the disk is full.
         */

#define APE_AT_INVALIDATED_AT_FILE          (APPERR_BASE + 312)
        /*
         *The AT schedule file is invalid.  Please delete the file and create a new one.
         */

#define APE_AT_SCHED_FILE_CLEARED           (APPERR_BASE + 313)
        /*
         *The AT schedule file was deleted.
         */

#define APE_AT_USAGE			    (APPERR_BASE + 314) /* @I
         *
         *The syntax of this command is:
         *
         *AT [id] [/DELETE]
         *AT time [/EVERY:date | /NEXT:date] command
         *
         *The AT command schedules a program command to run at a
         *later date and time on a server.  It also displays the
         *list of programs and commands scheduled to be run.
         *
	 *You can specify the date as M,T,W,Th,F,Sa,Su or 1-31
         *for the day of the month.
	 *
	 *You can specify the time in the 24 hour HH:MM format.
         */

#define APE_AT_SEM_BLOCKED	    	(APPERR_BASE + 315)
	/*
	 *The AT command has timed-out.
	 *Please try again later.
	 */

/***
 *
 *      NET ACCOUNTS error messages for NT
 *
 */
#define APE_MinGreaterThanMaxAge                (APPERR_BASE + 316)
        /*
         *The minimum password age for user accounts cannot be greater
         *than the maximum password age.
         */

#define APE_NotUASCompatible                    (APPERR_BASE + 317) 
	/*
         *You have specified a value that is incompatible
         *with servers with down-level software. Please specify a lower value.
         */

/* the following 2 messages have nothing to do with any ACC utility */
#define APE_BAD_COMPNAME                    (APPERR_BASE + 370)
        /*
         *%1 is not a valid computer name.
         */

#define APE_BAD_MSGID               (APPERR_BASE + 371)
        /*
         *%1 is not a valid Windows network message number.
         */

/*
 * Messenger message headers and ends.	These messages are also bound into
 * the messenger, in case the net.msg file is not available.
 */

#define APE_MSNGR_HDR			    (APPERR_BASE + 400)
    /*
     *Message from %1 to %2 on %3
     */

#define APE_MSNGR_GOODEND		    (APPERR_BASE + 401)
    /*
     *****
     */

#define APE_MSNGR_BADEND		    (APPERR_BASE + 402)
    /*
     ***** unexpected end of message ****
     */

/*
 * Messages for the net popup service / api.
 */


#define APE_POPUP_DISMISS		    (APPERR_BASE + 405)
    /* Press ESC to exit*/

#define APE_POPUP_MOREDATA		    (APPERR_BASE + 406)
    /*...*/



/***
 *
 *  NET TIME messages
 *
 */

#define APE_TIME_TimeDisp		(APPERR_BASE + 410)    /* @I
                *
                *Current time at %1 is %2
                */

#define APE_TIME_SetTime		(APPERR_BASE + 411)    /* @P
                *
                *The current local clock is %1
                *Do you want to set the local computer's time to match the
                *time at %2? %3: %0
                */

#define APE_TIME_RtsNotFound		(APPERR_BASE + 412)    /* @I
                *
                *Could not locate a time-server.
                */

#define APE_TIME_DcNotFound		(APPERR_BASE + 413)    /* @E
                *
                *Could not find the domain controller for domain %1.
                */

#define APE_TIME_TimeDispLocal		(APPERR_BASE + 414)    /* @I
                *
                *Local time (GMT%3) at %1 is %2
                */

/***
 *
 *  NET USE messages
 *
 */

#define APE_UseHomeDirNotDetermined	(APPERR_BASE + 415)    /* @E
                *
                *The user's home directory could not be determined.
                */

#define APE_UseHomeDirNotSet		(APPERR_BASE + 416)    /* @E
		*
		*The user's home directory has not been specified.
                */

#define APE_UseHomeDirNotUNC		(APPERR_BASE + 417)    /* @E
		*
		*The name specified for the user's home directory (%1) is not a universal naming convention (UNC) name.
                */

#define APE_UseHomeDirSuccess		(APPERR_BASE + 418)    /* @I
                *
                *Drive %1 is now connected to %2. Your home directory is %3\%4.
                */

#define APE_UseWildCardSuccess		(APPERR_BASE + 419)    /* @I
                *
                *Drive %1 is now connected to %2. 
                */

#define APE_UseWildCardNoneLeft		(APPERR_BASE + 420)    /* @E
                *
                *There are no available drive letters left.
                */

#define APE_CS_InvalidDomain		(APPERR_BASE + 432)	/* @E
                *
                *%1 is not a valid domain or workgroup name.
                */

/*
 *  More NET TIME messages
 */
#define APE_TIME_SNTP           (APPERR_BASE + 435) /* @I
        *
        *The current SNTP value is: %1
        */

#define APE_TIME_SNTP_DEFAULT   (APPERR_BASE + 436) /* @I
        *
        *This computer is not currently configured to use a specific SNTP server.
        */

#define APE_TIME_SNTP_AUTO      (APPERR_BASE + 437) /* @I
        *
        *This current autoconfigured SNTP value is: %1
        */


#define APE_CmdArgTooMany		(APPERR_BASE + 451)
		/*
		 * You specified too many values for the %1 option.
		 */

#define APE_CmdArgIllegal		(APPERR_BASE + 452)
		/*
		 * You entered an invalid value for the %1 option.
		 */

#define APE_CmdArgIncorrectSyntax	(APPERR_BASE + 453)
		/*
		 *The syntax is incorrect.
		 */

/*
 * NET PRINT and NET FILE errors
 */

#define APE_FILE_BadId                 		(APPERR_BASE + 460)
        /*
         *You specified an invalid file number.
         */

#define APE_PRINT_BadId                 	(APPERR_BASE + 461)
        /*
         *You specified an invalid print job number.
         */

/*
 * ALIAS related errors
 */

#define APE_UnknownAccount			(APPERR_BASE + 463)
	/*
	 *The user or group account specified cannot be found.
	 */

/*
 * FPNW related errors
 */

#define APE_CannotEnableNW			(APPERR_BASE + 465)
	/*
	 *The user was added but could not be enabled for File and Print
     *Services for NetWare.
	 */

#define APE_FPNWNotInstalled	    (APPERR_BASE + 466)
	/*
	 *File and Print Services for NetWare is not installed.
	 */

#define APE_CannotSetNW			    (APPERR_BASE + 467)
	/*
	 *Cannot set user properties for File and Print Services for NetWare.
	 */

#define APE_RandomPassword			    (APPERR_BASE + 468)
	/*
	 *Password for %1 is: %2
	 */

#define APE_NWCompat			    (APPERR_BASE + 469)
	/*
	 *NetWare compatible logon
	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\drivers\inc\watchdog.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    watchdog.h

Abstract:

    Contains all structure and routine definitions for
    NT Watchdog services.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef _WATCHDOG_H_
#define _WATCHDOG_H_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#ifdef WATCHDOG_EXPORTS
#define WATCHDOGAPI
#else
#define WATCHDOGAPI __declspec(dllimport)
#endif  // WATCHDOG_EXPORTS

//
// Do not dereference any watchdog data types directly!!!
// They're subject to change at any time.
//

//
// Data types.
//

typedef enum _WD_OBJECT_TYPE
{
    WdStandardWatchdog = 'WSdW',        // WdSW
    WdDeferredWatchdog = 'WDdW'         // WdDW
} WD_OBJECT_TYPE, *PWD_OBJECT_TYPE;

typedef enum _WD_TIME_TYPE
{
    WdKernelTime = 1,
    WdUserTime,
    WdFullTime
} WD_TIME_TYPE, *PWD_TIME_TYPE;

typedef enum _WD_EVENT_TYPE
{
    WdNoEvent = 1,
    WdTimeoutEvent,
    WdRecoveryEvent
} WD_EVENT_TYPE, *PWD_EVENT_TYPE;

typedef enum _WD_OBJECT_STATE
{
    WdStopped = 1,
    WdStarted,
    WdRemoved
} WD_OBJECT_STATE, *PWD_OBJECT_STATE;

//
// BUGBUG:
//
// This structure is defined here, and in gre\os.cxx as WATCHDOG_DPC_CONTEXT.
// We need to drop that definition from os.cxx and use WD_GDI_DPC_CONTEXT
// instead (win32k includes watchdog.w).
//

typedef struct _LDEV LDEV, *PLDEV;
typedef struct _WD_GDI_DPC_CONTEXT
{
    PLDEV *ppldevDrivers;
    HANDLE hDriver;
    UNICODE_STRING DisplayDriverName;
} WD_GDI_DPC_CONTEXT, *PWD_GDI_DPC_CONTEXT;

typedef struct _WATCHDOG_OBJECT
{
    WD_OBJECT_TYPE ObjectType;
    LONG ReferenceCount;
    ULONG OwnerTag;
    PDEVICE_OBJECT DeviceObject;
    WD_TIME_TYPE TimeType;
    WD_EVENT_TYPE LastEvent;
    struct _KTHREAD *RESTRICTED_POINTER LastQueuedThread;
    KSPIN_LOCK SpinLock;
    PVOID Context;
} WATCHDOG_OBJECT, *PWATCHDOG_OBJECT;

typedef struct _DEFERRED_WATCHDOG
{
    WATCHDOG_OBJECT Header;
    LONG Period;
    LONG SuspendCount;
    LONG InCount;
    LONG OutCount;
    LONG LastInCount;
    LONG LastOutCount;
    ULONG LastKernelTime;
    ULONG LastUserTime;
    ULONG TimeIncrement;
    LONG Trigger;
    ULONG State;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    struct _KTIMER Timer;
    struct _KDPC TimerDpc;
    struct _KDPC *ClientDpc;
} DEFERRED_WATCHDOG, *PDEFERRED_WATCHDOG;

typedef struct _WATCHDOG
{
    WATCHDOG_OBJECT Header;
    ULONG StartCount;
    ULONG SuspendCount;
    ULONG LastKernelTime;
    ULONG LastUserTime;
    ULONG TimeIncrement;
    LARGE_INTEGER DueTime;
    LARGE_INTEGER InitialDueTime;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    struct _KTIMER Timer;
    struct _KDPC TimerDpc;
    struct _KDPC *ClientDpc;
} WATCHDOG, *PWATCHDOG;

//
// Deferred watchdog function prototypes.
//

WATCHDOGAPI
PDEFERRED_WATCHDOG
WdAllocateDeferredWatchdog(
    IN PDEVICE_OBJECT DeviceObject,
    IN WD_TIME_TYPE TimeType,
    IN ULONG Tag
    );

WATCHDOGAPI
VOID
FASTCALL
WdEnterMonitoredSection(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdExitMonitoredSection(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdFreeDeferredWatchdog(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdResetDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdResumeDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdStartDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch,
    IN PKDPC Dpc,
    IN LONG Period
    );

WATCHDOGAPI
VOID
WdStopDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdSuspendDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

//
// Watchdog function prototypes.
//

WATCHDOGAPI
PWATCHDOG
WdAllocateWatchdog(
    IN PDEVICE_OBJECT DeviceObject,
    IN WD_TIME_TYPE TimeType,
    IN ULONG Tag
    );

WATCHDOGAPI
VOID
WdFreeWatchdog(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdResetWatch(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdResumeWatch(
    IN PWATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdStartWatch(
    IN PWATCHDOG Watch,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc
    );

WATCHDOGAPI
VOID
WdStopWatch(
    IN PWATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdSuspendWatch(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdDdiWatchdogDpcCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Common function prototypes.
//

WATCHDOGAPI
PVOID
WdAttachContext(
    IN PVOID Watch,
    IN ULONG Size
    );

WATCHDOGAPI
VOID
WdCompleteEvent(
    IN PVOID Watch,
    IN PKTHREAD Thread
    );

WATCHDOGAPI
VOID
WdDereferenceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
VOID
WdDetachContext(
    IN PVOID Watch
    );

WATCHDOGAPI
PDEVICE_OBJECT
WdGetDeviceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
WD_EVENT_TYPE
WdGetLastEvent(
    IN PVOID Watch
    );

WATCHDOGAPI
PDEVICE_OBJECT
WdGetLowestDeviceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
VOID
WdReferenceObject(
    IN PVOID Watch
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
#endif  // _WATCHDOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\adsi.h ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  adsi.h
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    );

HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    );

HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    );

HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    );

HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    );

HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    );

BOOL
FreeADsMem(
   LPVOID pMem
);


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    );


HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );

HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    IN PADS_SEARCH_HANDLE phSearchHandle
    );


HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );

HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    );


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    );


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    );

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    );

HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    );

HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    );

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    );


HRESULT
ADSIModifyRdn(
    HANDLE hDSObject,
    LPWSTR pszOldRdn,
    LPWSTR pszNewRdn
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\apperr2.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    apperr2.h

Abstract:

    This file contains the number and text of NETCMD text for
    normal output, such as line-item labels and column headers.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define APPERR2_BASE    4300            /* APP2 msgs start here */

/*******************************************************************
 *
 *      Constants for use by files including these messages.
 */

/*      APE2_CONST_MAXHDRLEN -- maximum length of any "header" strings,
 *      that is, those strings appearing the the top of a list or table.
 */

#define APE2_CONST_MAXHDRLEN    80
#define APE2_GEN_MAX_MSG_LEN    20


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in netcon.h for  *
 *info on the allocation of errors *
 ************************************/

/**END_INTERNAL**/

/*
 *      GEN -- General words.  These words are used in many places.  They
 *      are *not* to be used to build sentences.  The main use is in
 *      displaying information.  For example, in displaying a user's account
 *      information, the following would appear:
 *
 *              Account Disabled                No
 *              Account Expires                 Never
 *
 *      This is the only acceptable way to use these general words.
 *
 *      Size limits:
 *
 *              All GEN words should be limited to 20 characters, except as
 *              otherwise noted.
 */

#define APE2_GEN_YES                            (APPERR2_BASE + 0)      /* @I
                        *
                        *Yes%0
                        */

#define APE2_GEN_NO                                     (APPERR2_BASE + 1)      /* @I
                        *
                        *No%0
                        */

#define APE2_GEN_ALL                            (APPERR2_BASE + 2)      /* @I
                        *
                        *All%0
                        */

#define APE2_GEN_NONE                           (APPERR2_BASE + 3)      /* @I
                        *
                        *None%0
                        */

#define APE2_GEN_ALWAYS                         (APPERR2_BASE + 4)      /* @I
                        *
                        *Always%0
                        */

#define APE2_GEN_NEVER                          (APPERR2_BASE + 5)      /* @I
                        *
                        *Never%0
                        */

#define APE2_GEN_UNLIMITED                      (APPERR2_BASE + 6)      /* @I
                        *
                        *Unlimited%0
                        */

#define APE2_GEN_SUNDAY                         (APPERR2_BASE + 7)      /* @I
                        *
                        *Sunday%0
                        */

#define APE2_GEN_MONDAY                         (APPERR2_BASE + 8)      /* @I
                        *
                        *Monday%0
                        */

#define APE2_GEN_TUESDAY                        (APPERR2_BASE + 9)      /* @I
                        *
                        *Tuesday%0
                        */

#define APE2_GEN_WEDNSDAY                       (APPERR2_BASE + 10)     /* @I
                        *
                        *Wednesday%0
                        */

#define APE2_GEN_THURSDAY                       (APPERR2_BASE + 11)     /* @I
                        *
                        *Thursday%0
                        */

#define APE2_GEN_FRIDAY                         (APPERR2_BASE + 12)     /* @I
                        *
                        *Friday%0
                        */

#define APE2_GEN_SATURDAY                       (APPERR2_BASE + 13)     /* @I
                        *
                        *Saturday%0
                        */

#define APE2_GEN_SUNDAY_ABBREV                  (APPERR2_BASE + 14)     /* @I
                        *
                        *Su%0
                        */

#define APE2_GEN_MONDAY_ABBREV                  (APPERR2_BASE + 15)     /* @I
                        *
                        *M%0
                        */

#define APE2_GEN_TUESDAY_ABBREV                 (APPERR2_BASE + 16)     /* @I
                        *
                        *T%0
                        */

#define APE2_GEN_WEDNSDAY_ABBREV                (APPERR2_BASE + 17)     /* @I
                        *
                        *W%0
                        */

#define APE2_GEN_THURSDAY_ABBREV                (APPERR2_BASE + 18)     /* @I
                        *
                        *Th%0
                        */

#define APE2_GEN_FRIDAY_ABBREV                  (APPERR2_BASE + 19)     /* @I
                        *
                        *F%0
                        */

#define APE2_GEN_SATURDAY_ABBREV                (APPERR2_BASE + 20)     /* @I
                        *
                        *S%0
                        */

#define APE2_GEN_UNKNOWN                        (APPERR2_BASE + 21)     /* @I
                        *
                        *Unknown%0
                        */

#define APE2_GEN_TIME_AM1                       (APPERR2_BASE + 22)     /* @I
                        *
                        *AM%0
                        */

#define APE2_GEN_TIME_AM2                       (APPERR2_BASE + 23)     /* @I
                        *
                        *A.M.%0
                        */

#define APE2_GEN_TIME_PM1                       (APPERR2_BASE + 24)     /* @I
                        *
                        *PM%0
                        */

#define APE2_GEN_TIME_PM2                       (APPERR2_BASE + 25)     /* @I
                        *
                        *P.M.%0
                        */

/* see APE2_GEN