fcForestSpecific | SfcEDC | SfcCrossForest,

    // External
    SfcAlwaysFilter | SfcDomainSpecific | SfcForestSpecific | SfcEDC,

    // Quarantined external
    SfcAlwaysFilter | SfcDomainSpecific | SfcForestSpecific | SfcEDC | SfcQuarantined,

    // Member
    SfcAlwaysFilter | SfcMember,
};

#if DBG

const CHAR * LsapSidFilteringBoundaries[SfbMax] =
{
    "Within Forest",                // SfbWithinForest
    "Quarantined Within Forest",    // SfbQuarantinedWithinForest
    "Cross Forest",                 // SfbCrossForest
    "External",                     // SfbExternal
    "Quarantined External",         // SfbQuarantinedExternal
    "Member",                       // SfbMember
};

const CHAR * LsapSidFilteringCategories[] =
{
    "NeverFilter ",                 // SfcNeverFilter
    "AlwaysFilter ",                // SfcAlwaysFilter   
    "ForestSpecific ",              // SfcForestSpecific
    "EDC ",                         // SfcEDC             
    "DomainSpecific ",              // SfcDomainSpecific
    "Quarantined ",                 // SfcQuarantined    
    "CrossForest ",                 // SfcCrossForest    
    "Member ",                      // SfcMember         
};

VOID
ComposeCategory(
    IN ULONG Category,
    IN CHAR * String,
    IN ULONG Length
    )
{
    ULONG Shift = 1;

    if ( Category == SfcNeverFilter ) {

        strncpy( String, LsapSidFilteringCategories[0], Length );

    } else while ( Category != 0 ) {

        if ( Category & 1 ) {

            ULONG Size = strlen( LsapSidFilteringCategories[Shift] );

            if ( Size < Length ) {

                strncat( String, LsapSidFilteringCategories[Shift], Length );
                Length -= Size;
                String += Size;

            } else {

                ASSERT( FALSE ); // Debug-only, have caller pass in a larger buffer
                break;
            }
        }

        Category >>= 1;
        Shift += 1;
    }
}

#endif

#if !DBG

#define ReportFilteredSid( Sid, Boundary, Category )

#else

VOID
ReportFilteredSid(
    IN PSID Sid,
    IN ULONG Boundary,
    IN ULONG Category
    )
{
    CHAR * Text;
    CHAR * Buffer;

    ASSERT( Sid );

    if ( !RtlValidSid( Sid )) {

        LsapDsDebugOut((
            DEB_SIDFILTER,
            "Filtered an invalid SID\n"
            ));

        return;
    }

    SafeAllocaAllocate( Text, LsapDbGetSizeTextSid( Sid ));
    SafeAllocaAllocate( Buffer, 256 );

    if ( Text == NULL || Buffer == NULL ) {

        SafeAllocaFree( Text );
        SafeAllocaFree( Buffer );
        return;
    }

    if ( !NT_SUCCESS( LsapDbSidToTextSid( Sid, Text ))) {

        SafeAllocaFree( Text );
        SafeAllocaFree( Buffer );
        return;
    }

    Buffer[0] = '\0';
    ComposeCategory( Category, Buffer, 256 );

    LsapDsDebugOut((
        DEB_SIDFILTER,
        "Filtered SID %s, Boundary \"%s\", Category %s\n",
        Text,
        LsapSidFilteringBoundaries[Boundary],
        Buffer
        ));

    SafeAllocaFree( Text );
    SafeAllocaFree( Buffer );
}

#endif

#if !DBG

#define ReportTrustBoundary( Sid, TrustType, TrustAttributes, Boundary )

#else

VOID
ReportTrustBoundary(
    IN  OPTIONAL PSID Sid,
    IN  ULONG TrustType,
    IN  ULONG TrustAttributes,
    IN  ULONG Boundary
    )
{
    CHAR * Text;

    if ( Sid ) {

        ULONG Length;
        ASSERT( RtlValidSid( Sid ));
        Length = LsapDbGetSizeTextSid( Sid );

        SafeAllocaAllocate( Text, Length );

        if ( Text == NULL ) {

            return;
        }

        if ( !NT_SUCCESS( LsapDbSidToTextSid( Sid, Text ))) {

            SafeAllocaFree( Text );
            return;
        }

    } else {

        Text = NULL;
    }

    LsapDsDebugOut((
        DEB_SIDFILTER,
        "Trust with SID %s, type 0x%x and attributes 0x%x was classified as boundary \"%s\"\n",
        Text ? Text : "NULL",
        TrustType,
        TrustAttributes,
        LsapSidFilteringBoundaries[Boundary]
        ));

    SafeAllocaFree( Text );
}
    
#endif

#if !DBG

#define ReportSidCategory( Sid, Category, Line )

#else

VOID
ReportSidCategory(
    IN const SID * Sid,
    IN ULONG Category,
    IN ULONG Line
    )
{
    CHAR * Text;
    CHAR * Buffer;

    if ( !RtlValidSid(( PSID )Sid )) {

        LsapDsDebugOut((
            DEB_SIDFILTER,
            "SID has been classified as INVALID on line %d\n",
            Line
            ));

        return;
    }

    SafeAllocaAllocate( Text, LsapDbGetSizeTextSid(( PSID )Sid ));
    SafeAllocaAllocate( Buffer, 256 );

    if ( Text == NULL || Buffer == NULL ) {

        SafeAllocaFree( Text );
        SafeAllocaFree( Buffer );
        return;
    }

    if ( !NT_SUCCESS( LsapDbSidToTextSid(( PSID )Sid, Text ))) {

        SafeAllocaFree( Text );
        SafeAllocaFree( Buffer );
        return;
    }

    Buffer[0] = '\0';
    ComposeCategory( Category, Buffer, 256 );

    LsapDsDebugOut((
        DEB_SIDFILTER,
        "SID %s has been classified as %son line %d\n",
        Text,
        Buffer,
        Line
        ));

    SafeAllocaFree( Text );
    SafeAllocaFree( Buffer );
}

#endif

NTSTATUS
FORCEINLINE
LsapDetermineTrustBoundary(
     IN  OPTIONAL PSID Sid,
     IN  ULONG TrustType,
     IN  ULONG TrustAttributes,
     OUT ULONG * Sfb
     )
/*++

Routine Description:

    Based on the attributes, type and SID of the trust, determines
    which type of trust boundary this is.

Arguments:

    Sid                 SID of the trust
    TrustType           type of the trust
    TrustAttributes     attributes of the trust
    Sfb                 used to return the type of trust boundary (Sfb*)

Returns:

    STATUS_SUCCESS      success
    STATUS_*            failure ( See LsapForestTrustFindMatch )

--*/
{
    NTSTATUS Status;
    BOOLEAN WithinForest;
    ULONG Result;

    if ( Sid == NULL && TrustType != TRUST_TYPE_MIT ) {

        //
        // Special case: revisit this code if regular trusts can have
        // NULL SIDs (we already know that MIT trusts can)
        //

        *Sfb = SfbMember;
        Status = STATUS_SUCCESS;
        goto Cleanup;

    } else if ( TrustType != TRUST_TYPE_UPLEVEL ) {

        WithinForest = FALSE;

    } else if ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {

        WithinForest = FALSE;

    } else if ( TrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) {

        WithinForest = FALSE;

    } else if ( TrustAttributes & TRUST_ATTRIBUTE_WITHIN_FOREST ) {

        WithinForest = TRUE;

    } else {

        NTSTATUS Status;

        //
        // Search local forest trust information for this trust SID
        //

        Status = LsapForestTrustFindMatch(
                     RoutingMatchDomainSid,
                     Sid,
                     TRUE,
                     NULL,
                     NULL
                     );

        if ( NT_SUCCESS( Status )) {

            WithinForest = TRUE;

        } else if ( Status == STATUS_NO_MATCH ) {

            Status = STATUS_SUCCESS;
            WithinForest = FALSE;

        } else {

            return Status;
        }
    }

    if ( TrustAttributes & TRUST_ATTRIBUTE_QUARANTINED_DOMAIN ) {

        *Sfb = WithinForest ?
                  SfbQuarantinedWithinForest :
                  SfbQuarantinedExternal;

    } else if ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {

        *Sfb = SfbCrossForest;

    } else if ( WithinForest ) {

        *Sfb = SfbWithinForest;

    } else {

        *Sfb = SfbExternal;
    }

    //
    // Bug #619734.  Cross-forest trusts with TREAT_AS_EXTERNAL attribute set
    // will be treated as external trusts for trust boundary purposes
    //

    if ( *Sfb == SfbCrossForest &&
        ( TrustAttributes & TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL )) {

        *Sfb = SfbExternal;
    }

Cleanup:

#if DBG
    ReportTrustBoundary(
        Sid,
        TrustType,
        TrustAttributes,
        *Sfb
        );
#endif

    return STATUS_SUCCESS;
}

VOID
LsapClassifySids(
    IN  ULONG Count,
    IN  const NETLOGON_SID_AND_ATTRIBUTES * Sids,
    OUT ULONG * ClassifiedSids
    )
/*++

Routine Description:

    Classifies the SIDs in a given array as belonging to one of the SID
    filtering categories (Sfc*)

Arguments:

    Count             number of entries in the Sids array
    Sids              array of SIDs to classify
    ClassifiedSids    used to return the classified SIDs

Returns:

    Nothing

--*/
{
    ULONG i;

    for ( i = 0 ; i < Count ; i++ ) {

        const SID * Sid = ( const SID * )Sids[i].Sid;
        __int64 IdentifierAuthority;

        if ( !RtlValidSid(( PSID )Sid )) {

            ClassifiedSids[i] = SfcAlwaysFilter;
            ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
            continue;
        }

        //
        // Only revision-1 SIDs can be processed
        //

        if ( Sid->Revision != 1 ) {

            ClassifiedSids[i] = SfcNeverFilter;
            ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
            continue;
        }

        IdentifierAuthority =
            (( __int64 )( Sid->IdentifierAuthority.Value[0] ) << 5*8 ) +
            (( __int64 )( Sid->IdentifierAuthority.Value[1] ) << 4*8 ) +
            (( __int64 )( Sid->IdentifierAuthority.Value[2] ) << 3*8 ) +
            (( __int64 )( Sid->IdentifierAuthority.Value[3] ) << 2*8 ) +
            (( __int64 )( Sid->IdentifierAuthority.Value[4] ) << 1*8 ) +
            (( __int64 )( Sid->IdentifierAuthority.Value[5] ) << 0*8 );

        switch ( IdentifierAuthority ) {

        case ( __int64 ) 0: // S-1-0-* SECURITY_NULL_SID_AUTHORITY
        case ( __int64 ) 1: // S-1-1-* SECURITY_WORLD_SID_AUTHORITY
        case ( __int64 ) 2: // S-1-2-* SECURITY_LOCAL_SID_AUTHORITY
        case ( __int64 ) 3: // S-1-3-* SECURITY_CREATOR_SID_AUTHORITY
        case ( __int64 ) 6: // S-1-6-* SECURITY_SITESERVER_AUTHORITY
        case ( __int64 ) 7: // S-1-7-* SECURITY_INTERNETSITE_AUTHORITY
        case ( __int64 ) 8: // S-1-8-* SECURITY_EXCHANGE_AUTHORITY
        case ( __int64 ) 9: // S-1-9-* SECURITY_RESOURCE_MANAGER_AUTHORITY

            ClassifiedSids[i] = SfcAlwaysFilter;
            ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
            break;

        case ( __int64 ) 5: // S-1-5-* SECURITY_NT_AUTHORITY

            if ( Sid->SubAuthorityCount == 0 ) {

                ClassifiedSids[i] = SfcAlwaysFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                break;
            }

            ASSERT( Sid->SubAuthorityCount > 0 );

            switch ( Sid->SubAuthority[0] ) {

            case 0: // S-1-5-0-*

                ClassifiedSids[i] = SfcAlwaysFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                break;

            case SECURITY_ENTERPRISE_CONTROLLERS_RID: // S-1-5-9-*

                //
                // S-1-5-9 is the EDC SID
                // S-1-5-9-* are meaningless and should be filtered
                //

                ClassifiedSids[i] = ( Sid->SubAuthorityCount == 1 ) ?
                                         SfcEDC :
                                         SfcAlwaysFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                break;

            case SECURITY_NT_NON_UNIQUE: // S-1-5-21-*
                {
                ULONG DomainRid;

                if ( Sid->SubAuthorityCount != SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+2 ) {

                    //
                    // S-1-5-21-X
                    // S-1-5-21-X-Y
                    // S-1-5-21-X-Y-Z
                    // S-1-5-21-X-Y-Z-R-*
                    //

                    ClassifiedSids[i] = SfcAlwaysFilter;
                    ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                    break;
                }

                //
                // All such SIDs must be screened at the member workstation boundary
                // as well as quarantined and cross-forest boundaries
                //

                ClassifiedSids[i] = ( SfcMember |
                                      SfcQuarantined |
                                      SfcCrossForest );

                DomainRid = Sid->SubAuthority[SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+1];

                if ( DomainRid <= FOREST_USER_RID_MAX ||
                     DomainRid == DOMAIN_GROUP_RID_SCHEMA_ADMINS ||
                     DomainRid == DOMAIN_GROUP_RID_ENTERPRISE_ADMINS ) {

                    ClassifiedSids[i] |= SfcForestSpecific;

                    ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );

                } else if ( DomainRid > FOREST_USER_RID_MAX &&
                            DomainRid <= DOMAIN_USER_RID_MAX ) {

                    ClassifiedSids[i] |= ( SfcDomainSpecific |
                                           SfcForestSpecific );

                    ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );

                } else {

                    ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                }
                }

                break;

            case SECURITY_OTHER_ORGANIZATION_RID: // S-1-5-1000-*

                //
                // This is handled separately because this SID must not
                // get the SfcForestSpecific bit set, regardless of what
                // the default: statement below ensures that
                //

                ClassifiedSids[i] = SfcNeverFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                break;

            case SECURITY_THIS_ORGANIZATION_RID: // S-1-5-16-*
            case SECURITY_BUILTIN_DOMAIN_RID: // S-1-5-32-*
            case SECURITY_PACKAGE_BASE_RID: // S-1-5-64-*

                ClassifiedSids[i] = SfcAlwaysFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
                break;

            default:

                ClassifiedSids[i] = ( Sid->SubAuthority[0] <= SECURITY_MAX_ALWAYS_FILTERED ) ?
                                         SfcAlwaysFilter :
                                         SfcNeverFilter;
                ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
            }

            break;

        case ( __int64 ) 4:  // S-1-4-* SECURITY_NON_UNIQUE_AUTHORITY
        case ( __int64 ) 10: // S-1-10-* SECURITY_PASSPORT_AUTHORITY
        default:

            ClassifiedSids[i] = SfcNeverFilter;
            ReportSidCategory( Sid, ClassifiedSids[i], __LINE__ );
            break;
        }
    }
}

NTSTATUS
LsapSidFilterCheck(
    IN PSID Sid,
    IN ULONG Sfb,
    IN ULONG Sfc,
    IN OPTIONAL PSID TrustedDomainSid,
    IN UNICODE_STRING * TrustedDomainName,
    OUT BOOL * Valid
    )
/*++

Routine description:

    Filters a single SID based on security boundary and filtering category

Arguments:

    Sid                 SID to filter
    Sfb                 security filtering boundary
    Sfc                 security filtering category
    TrustedDomainSid    SID of the trust this SID came over
    TrustedDomainName   Name of the trust this SID came over
    Valid               used to return the result of the check
                        TRUE means let it pass, FALSE means filter it

Returns:

    STATUS_SUCCESS if happy
    STATUS_ return code otherwise

--*/
{
    NTSTATUS Status;
    static PLSAPR_POLICY_ACCOUNT_DOM_INFO AccountDomainInfo = NULL;

    if ( AccountDomainInfo == NULL ) {

        //
        // Will need the primary domain SID going forward
        //

        Status = LsapDbQueryInformationPolicy(
                     LsapPolicyHandle,
                     PolicyAccountDomainInformation,
                     ( PLSAPR_POLICY_INFORMATION * )&AccountDomainInfo
                     );

        if ( !NT_SUCCESS( Status )) {

            return Status;
        }
    }

    //
    // Only those forest-specific SIDs not claimed by any domains in the local
    // forest are allowed to cross extra-forest and quarantined-within-forest
    // boundaries
    //

    if ( SfcForestSpecific &
         LsapSidFilteringMatrix[Sfb] &
         Sfc ) {

        Status = LsapForestTrustFindMatch(
                     RoutingMatchDomainSid,
                     Sid,
                     TRUE,
                     NULL,
                     NULL
                     );

        if ( Status == STATUS_NO_MATCH ) {

            //
            // The SID is not inside our forest, good to go
            //

            Status = STATUS_SUCCESS;
            Sfc &= ~SfcForestSpecific;

        } else if ( !NT_SUCCESS( Status )) {

            return Status;

        } else if ( Sfb == SfbQuarantinedWithinForest ) {

            //
            // The domain SID is within our forest.  One last check:
            // if the trust boundary is "quarantined-within-forest" and the
            // trusted domain SID matches the domain we're authenticating
            // from, let the SID through
            //

            BOOL Equal = FALSE;

            if ( TrustedDomainSid == NULL ||
                 !EqualDomainSid(
                      Sid,
                      TrustedDomainSid,
                      &Equal )) {

                Equal = FALSE; // something's wrong with this SID, can it
            }

            if ( Equal ) {

                Sfc &= ~SfcForestSpecific;
            }
        }
    }

    //
    // Due to the potential for replication deadlocks, which is only fixed by
    // having new child domains set TRUST_ATTRIBUTE_WITHIN_FOREST as part
    // of DCPROMO, we must postpone EDC SID filtering rules until .NET forest
    // mode is enacted
    //
    // One exception is quarantined trusts.  EDC SIDs are not allowed over
    // quarantined trusts until .NET server mode is entered, at which point
    // we'll allow the EDC SID over intra-forest quarantined trusts.
    //
    // Administrators must take care not to quarantine intra-forest trusts
    // until .NET server mode is entered.
    //

    if ( SfcEDC &
         LsapSidFilteringMatrix[Sfb] &
         Sfc ) {

        if ( Sfb != SfbCrossForest &&
             Sfb != SfbQuarantinedWithinForest &&
             Sfb != SfbQuarantinedExternal &&
             !LsapDbNoMoreWin2KForest()) {

            Sfc &= ~SfcEDC;
        }
    }

    //
    // Only SIDs that prefix-match the TDO SID are allowed to cross
    // quarantined boundaries
    //

    if ( SfcQuarantined &
         LsapSidFilteringMatrix[Sfb] &
         Sfc ) {

        BOOL Equal = FALSE;

        if ( TrustedDomainSid == NULL ||
             !EqualDomainSid(
                  Sid,
                  TrustedDomainSid,
                  &Equal )) {

            Equal = FALSE; // something's wrong with this SID, can it
        }

        if ( Equal ) {

            Sfc &= ~SfcQuarantined;
        }
    }

    //
    // Only SIDs found on the FTInfo for the trust are allowed to cross
    // cross-forest boundaries
    //

    if ( SfcCrossForest &
         LsapSidFilteringMatrix[Sfb] &
         Sfc ) {

        BOOL FoundOnFtinfo;

        ASSERT( TrustedDomainName != NULL );

        Status = LsapSidOnFtInfo( TrustedDomainName, Sid );

        if ( NT_SUCCESS( Status )) {

            FoundOnFtinfo = TRUE;

        } else if ( Status == STATUS_NO_MATCH ) {

            FoundOnFtinfo = FALSE;

        } else {

            return Status;
        }

        if ( FoundOnFtinfo ) {

            Sfc &= ~SfcCrossForest;
        }
    }

    //
    // Domain-specific SIDs must not be prefixed by the SID
    // of this domain.
    // The same applies to Member SIDs, so handle the two together
    // with one exception: on DCs, disregard the member boundary
    // since, by definition, domain controllers trust themselves
    //

    if ( Sfb == SfbMember &&
         LsapProductType == NtProductLanManNt )
    {
        Sfc &= ~SfcMember;
    }

    if (( SfcDomainSpecific | SfcMember ) &
         LsapSidFilteringMatrix[Sfb] &
         Sfc ) {

        BOOL Equal = FALSE;

        if ( !EqualDomainSid(
                  Sid,
                  AccountDomainInfo->DomainSid,
                  &Equal )) {

            Equal = TRUE; // something's wrong with this SID, can it
        }

        if ( !Equal ) {

            Sfc &= ~( SfcDomainSpecific | SfcMember );
        }
    }

    //
    // If the security boundary disallows any of the remaining
    // filtering category bits, the SID gets filtered
    //

    if ( Sfc & LsapSidFilteringMatrix[Sfb] ) {

        ReportFilteredSid(
            Sid,
            Sfb,
            Sfc & LsapSidFilteringMatrix[Sfb]
            );

        *Valid = FALSE;

    } else {

        *Valid = TRUE;
    }

    return STATUS_SUCCESS;
}

extern "C"
NTSTATUS
LsaIFilterSids(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN OPTIONAL PSID Sid,
    IN NETLOGON_VALIDATION_INFO_CLASS InfoClass,
    IN OUT PVOID SamInfo,
    IN OPTIONAL PSID ResourceGroupDomainSid,
    IN OUT OPTIONAL PULONG ResourceGroupCount,
    IN OUT OPTIONAL PGROUP_MEMBERSHIP ResourceGroupIds
    )
/*++

Routine description:

    The LsaIFilterSids function performs validation and filtering of the
    Netlogon validation SAM info structure for quarantined domains and inter
    forest trusts.

Arguments:

    TrustedDomainName   DNS name of the trusted domain.

    TrustDirection      Trust direction associated with the TDO.
                        TRUST_DIRECTION_OUTBOUND bit must be set

    TrustType           Trust type associated with the TDO

    TrustAttributes     Ttrust attributes associated with the TDO

    Sid                 SID of the TDO

    InfoClass           Identifies the format of the SamInfo structure
                        must be one of NetlogonValidationSamInfo,
                        NetlogonValidationSamInfo2, or NetlogonValidationSamInfo4

    SamInfo             Depending on the value of InfoClass, points to a
                        NETLOGON_VALIDATION_SAM_INFO, NETLOGON_VALIDATION_SAM_INFO2 or
                        NETLOGON_VALIDATION_SAM_INFO4 structure,

                        (NETLOGON_VALIDATION_SAM_INFO3 structures must be
                             camouflaged as NETLOGON_VALIDATION_SAM_INFO2)

                NOTE: SamInfo must have allocate-all-nodes semantics

    ResourceGroupDomainSid      if specifying resource groups IDs, this is
                                the domain SID they will be relative to

    ResourceGroupCount          number of resource groups

    ResourceGroupIds            array of group IDs

Return values:

    STATUS_SUCCESS

        Filtering was perfomed successfully, OK to proceed

    STATUS_INVALID_PARAMETER

        One of the following has occurred:
        TrustDirection does not include TRUST_DIRECTION_OUTBOUND bit
        InfoClass is not one of the two allowed values

    STATUS_DOMAIN_TRUST_INCONSISTENT

        LogonDomainId member of SamInfo is not of valid filtered.
        For quarantined domains, LogonDomainId must equal the SID of the TDO.
        For inter forest trust, LogonDomainId must be one of the non-filtered SIDS.

NOTE: Member workstation trust boundary is indicated by calling this routine
      in the following manner:

                Status = LsaIFilterSids(
                             NULL,
                             0,
                             0,
                             0,
                             NULL,
                             ValidationLevel,
                             *ValidationInformation,
                             NULL,
                             NULL,
                             NULL
                             );
                        
--*/
{
    NTSTATUS Status;
    NETLOGON_VALIDATION_SAM_INFO * NetlogonValidation;
    UNICODE_STRING CanonTrustedDomainName;
    ULONG Sfb;
    ULONG Sfc;
    BYTE TestSid[MAX_SID_LEN];
    NETLOGON_SID_AND_ATTRIBUTES LogonDomainId;
    ULONG LogonDomainSidLength;
    ULONG ValidGroupCount;
    ULONG i;
    BOOL Valid;
    BOOL FirstExtraSidMustBeValid = FALSE;
    BOOL FirstExtraSidIsValid = FALSE;

    ASSERT( SamInfo );

    //
    // Validate parameters first
    //

    if ( TrustType == TRUST_TYPE_MIT ) {

        //
        // Per 489747, no SIDs are allowed over MIT trusts
        //

        return STATUS_DOMAIN_TRUST_INCONSISTENT;

    } else if ( Sid != NULL ) {

        //
        // SID filtering only makes sense over outbound trusts
        //

        if ( 0 == ( TrustDirection & TRUST_DIRECTION_OUTBOUND )) {

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids called for a trust not marked 'outbound'\n" ));
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Special case of a member trust boundary
        //

        if ( TrustDirection != 0 ||
             TrustType != 0 ) {

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids called with invalid parameters (%d)\n", __LINE__ ));
            return STATUS_INVALID_PARAMETER;
        }
    }

    if ( InfoClass != NetlogonValidationSamInfo4 &&
         InfoClass != NetlogonValidationSamInfo2 &&
         InfoClass != NetlogonValidationSamInfo ) {

        LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids called with invalid parameters (%d)\n", __LINE__ ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If we are not in .NET forest mode, behave as if the forest transitive
    // bit did not exist
    //

    if ( !LsapDbNoMoreWin2KForest()) {

        TrustAttributes &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
    }

    //
    // Code is cleaner if we can assume (and we can) that
    // NETLOGON_VALIDATION_SAM_INFO2 is a superset of NETLOGON_VALIDATION_SAM_INFO
    //

    ASSERT( FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO, LogonDomainId ) ==
            FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO2, LogonDomainId ));

    ASSERT( FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO, LogonDomainId ) ==
            FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO4, LogonDomainId ));

    NetlogonValidation = (NETLOGON_VALIDATION_SAM_INFO *)SamInfo;

    ASSERT(( Sid == NULL ) || RtlValidSid( Sid ));
    ASSERT( RtlValidSid( NetlogonValidation->LogonDomainId ));

    //
    // Canonicalize the TrustedDomainName
    //

    if ( TrustedDomainName == NULL ) {

        RtlInitUnicodeString( &CanonTrustedDomainName, NULL );

    } else {

        CanonTrustedDomainName = *TrustedDomainName;
        LsapRemoveTrailingDot( &CanonTrustedDomainName, TRUE );
    }

    //
    // Determine our security boundary
    //

    Status = LsapDetermineTrustBoundary(
                 Sid,
                 TrustType,
                 TrustAttributes,
                 &Sfb
                 );

    if ( !NT_SUCCESS( Status )) {

        LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: LsapDetermineTrustBoundary failed with 0x%x\n", Status ));
        return Status;
    }

    //
    // Validate the user id, primary and "other" group IDs
    //

    LogonDomainId.Sid = ( PSID )TestSid;
    LogonDomainId.Attributes = 0L;

    //
    // The following call kills two birds with one stone:
    //  - validates that NetlogonValidation->LogonDomainID is a valid domain SID
    //  - copies its contents into TestSid
    //

    LogonDomainSidLength = sizeof( TestSid );

    if ( !GetWindowsAccountDomainSid(
              NetlogonValidation->LogonDomainId,
              ( PSID )TestSid,
              &LogonDomainSidLength )) {

        //
        // NetlogonValidation->LogonDomainID is not a valid 
        //

        LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids encountered an invalid logon domain ID\n" ));
        return STATUS_DOMAIN_TRUST_INCONSISTENT;
    }

    //
    // Iterate over the group IDs passed in, looking for SIDs to filter.
    // While at it, get UserId and PrimaryGroupId, since it's part of the
    // same deal.  The only difference is that UserId and PrimaryGroupId
    // can not be filtered out - they cause us to fail this call.
    //

    ValidGroupCount = 0;

    for ( i = 0; i < NetlogonValidation->GroupCount + 2; i++ ) {

        ULONG Id;

        if ( i < NetlogonValidation->GroupCount ) {

            Id = NetlogonValidation->GroupIds[i].RelativeId;

        } else if ( i == NetlogonValidation->GroupCount ) {

            Id = NetlogonValidation->UserId;

            if ( Id == 0 ) {

                //
                // Bug #609714
                // Skip this check - the first of the ExtraSids is the one
                // that needs to be valid in case primary user ID is 0
                //

                FirstExtraSidMustBeValid = TRUE;
                continue;
            }

        } else {

            Id = NetlogonValidation->PrimaryGroupId;
        }

        (( SID * )TestSid)->SubAuthority[(( SID * )TestSid)->SubAuthorityCount] = Id;
        (( SID * )TestSid)->SubAuthorityCount += 1;

        LsapClassifySids( 1, &LogonDomainId, &Sfc );

        Status = LsapSidFilterCheck(
                     TestSid,
                     Sfb,
                     Sfc,
                     Sid,
                     &CanonTrustedDomainName,
                     &Valid
                     );

        if ( !NT_SUCCESS( Status )) {

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: LsapSidFilterCheck failed with 0x%x (%d)\n", Status, __LINE__ ));
            return Status;
        }

        if ( !Valid ) {

            if ( i >= NetlogonValidation->GroupCount ) {

                //
                // Either a user ID or a primary group ID is bad
                //

                LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: either UserId or PrimaryGroupId is invalid\n" ));
                return STATUS_DOMAIN_TRUST_INCONSISTENT;

            } else {

                //
                // One of the group IDs is bad - skip it
                //

                NOTHING;
            }

        } else if ( i < NetlogonValidation->GroupCount ) {

            NetlogonValidation->GroupIds[ValidGroupCount++] = NetlogonValidation->GroupIds[i];
        }

        (( SID * )TestSid)->SubAuthorityCount -= 1; // get ready for next iteration
    }

    NetlogonValidation->GroupCount = ValidGroupCount;

    //
    // Finally, for NetlogonValidationSamInfo2 (and 4) filter the ExtraSids array
    //

    if (( InfoClass == NetlogonValidationSamInfo4 ||
          InfoClass == NetlogonValidationSamInfo2 ) &&
         (( NETLOGON_VALIDATION_SAM_INFO2 *) SamInfo)->SidCount > 0 ) {

        NETLOGON_VALIDATION_SAM_INFO2 * NetlogonValidation2;
        ULONG ValidSids = 0;
        ULONG * ClassifiedSids = NULL;

        NetlogonValidation2 = (NETLOGON_VALIDATION_SAM_INFO2 *)SamInfo;

        SafeAllocaAllocate(
            ClassifiedSids,
            NetlogonValidation2->SidCount * sizeof( ULONG )
            );

        if ( ClassifiedSids == NULL ) {

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: out of memory allocating ClassifiedIds 0x%x\n" ));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        LsapClassifySids(
            NetlogonValidation2->SidCount,
            NetlogonValidation2->ExtraSids,
            ClassifiedSids
            );

        for ( i = 0; i < NetlogonValidation2->SidCount; i++ ) {

            Status = LsapSidFilterCheck(
                         NetlogonValidation2->ExtraSids[i].Sid,
                         Sfb,
                         ClassifiedSids[i],
                         Sid,
                         &CanonTrustedDomainName,
                         &Valid
                         );

            if ( !NT_SUCCESS( Status )) {

                SafeAllocaFree( ClassifiedSids );
                LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: LsapSidFilterCheck failed with 0x%x (%d)\n", Status, __LINE__ ));
                return Status;
            }

            if ( !Valid ) {

                //
                // Filter out this SID
                //

                NOTHING;

            } else {

                if ( i == 0 ) {

                    FirstExtraSidIsValid = TRUE;
                }

                NetlogonValidation2->ExtraSids[ValidSids++] = NetlogonValidation2->ExtraSids[i];
            }
        }

        NetlogonValidation2->SidCount = ValidSids;

        SafeAllocaFree( ClassifiedSids );
    }

    if ( FirstExtraSidMustBeValid &&
         !FirstExtraSidIsValid ) {

        LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: UserId is 0 and first ExtraSid is not valid\n" ));
        return STATUS_DOMAIN_TRUST_INCONSISTENT;
    }

    if ( ResourceGroupDomainSid != NULL ) {

        ULONG ResourceGroupSidLength;
        NETLOGON_SID_AND_ATTRIBUTES RGroupSidAndAttributes;

        RGroupSidAndAttributes.Sid = ( PSID )TestSid;
        RGroupSidAndAttributes.Attributes = 0L;

        //
        // Validate the resource domain SID and resource group IDs
        //

        //
        // The following call kills two birds with one stone:
        //  - validates that ResourceGroupDomainSid is
        //    a valid domain SID
        //  - copies its contents into TestSid
        //

        ResourceGroupSidLength = sizeof( TestSid );

        if ( !GetWindowsAccountDomainSid(
                  ResourceGroupDomainSid,
                  ( PSID )TestSid,
                  &ResourceGroupSidLength )) {

            //
            // NetlogonValidation3->ResourceGroupSID is not a valid 
            //

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids encountered an invalid resource group SID\n" ));
            return STATUS_DOMAIN_TRUST_INCONSISTENT;
        }

        //
        // Iterate over the resource group IDs passed in, looking for SIDs to filter.
        //

        if ( ResourceGroupCount != NULL &&
             ResourceGroupIds != NULL ) {

            ValidGroupCount = 0;

            for ( i = 0; i < *ResourceGroupCount; i++ ) {

                ULONG Id = ResourceGroupIds[i].RelativeId;

                (( SID * )TestSid)->SubAuthority[(( SID * )TestSid)->SubAuthorityCount] = Id;
                (( SID * )TestSid)->SubAuthorityCount += 1;

                LsapClassifySids( 1, &RGroupSidAndAttributes, &Sfc );

                Status = LsapSidFilterCheck(
                             TestSid,
                             Sfb,
                             Sfc,
                             Sid,
                             &CanonTrustedDomainName,
                             &Valid
                             );

                if ( !NT_SUCCESS( Status )) {

                    LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterSids: LsapSidFilterCheck failed with 0x%x (%d)\n", Status, __LINE__ ));
                    return Status;
                }

                if ( !Valid ) {

                    //
                    // One of the group IDs is bad - skip it
                    //

                    NOTHING;

                } else if ( i < *ResourceGroupCount ) {

                    ResourceGroupIds[ValidGroupCount++] = ResourceGroupIds[i];
                }

                (( SID * )TestSid)->SubAuthorityCount -= 1; // get ready for next iteration
            }

            *ResourceGroupCount = ValidGroupCount;
        }
    }

    return STATUS_SUCCESS;
}



extern "C"
NTSTATUS
LsaIFilterNamespace(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PUNICODE_STRING Namespace
    )
/*++

Routine Description:

    Determines whether a namespace is allowed across a trust boundary

Arguments:

    TrustedDomainName  -+-  Attributes of the trust boundary
    TrustDirection  ----|
    TrustType  ---------|
    TrustAttributes  ---+

    Namespace               Namespace to examine

                            For cross-forest trusts, the namespace must match
                            the FTInfo TLNs on the trust

                            For other types of trust, the namespace must match
                            the name of the trust

Returns:

    STATUS_SUCESS                       The test has passed

    STATUS_INVALID_PARAMETER            Unhappy with the arguments

    STATUS_DOMAIN_TRUST_INCONSISTENT    The test has failed

    STATUS_INSUFFICIENT_RESOURCES       Out of memory

NOTE:

    Trusts within the forest are not namespace-filtered
    since forest is our trust boundary

--*/
{
    NTSTATUS Status;
    BOOL NamespaceMatched = FALSE;

    //
    // SID filtering only makes sense over outbound trusts
    //

    if ( TrustType == 0 ||
         ( TrustDirection & TRUST_DIRECTION_OUTBOUND ) == 0 ) {

        LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterNamespace: called with invalid parameters\n" ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // For cross-forest trusts, we perform a namespace match to see
    // if the namespace is claimed by this trust
    //

    if ( TrustAttributes & TRUST_ATTRIBUTE_WITHIN_FOREST ) {

        //
        // Trusts within this forest are not namespace filtered
        //

        NamespaceMatched = TRUE;

    } else if ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {

        UNICODE_STRING MatchingDomainName = {0};

        Status = LsapForestTrustFindMatch(
                     RoutingMatchNamespace,
                     Namespace,
                     FALSE, // look for non-local (other forest) matches
                     &MatchingDomainName,
                     NULL
                     );

        //
        // If the lookup was successful, also double-check that the name
        // of the matching forest is the same as TrustedDomainName passed in
        //

        if ( NT_SUCCESS( Status ) &&
             LsapCompareDomainNames(
                 TrustedDomainName,
                 &MatchingDomainName,
                 NULL )) {

            NamespaceMatched = TRUE;
        }

        if ( NT_SUCCESS( Status )) {

            LsaIFree_LSAPR_UNICODE_STRING_BUFFER(
                (PLSAPR_UNICODE_STRING)&MatchingDomainName
                );

        } else if ( Status != STATUS_NO_MATCH ) {

            //
            // Failed for reason other than no match found - fail the call
            //

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterNamespace: LsapForestTrustFindMatch failed with (0x%x) on line %d\n", Status, __LINE__ ));
            return Status;
        }

    } else {

        //
        // Not explicitly within forest, not cross-forest.  Check to see if
        // this domain is within our forest via a forest trust cache lookup
        // NOTE: in .NET forest mode, we can tell whether each individual domain
        //       is within the forest or not by domain name lookup.
        //       before .NET forest mode, we contend with namespace lookup
        //       which makes namespace filtering ineffective over trusts whose
        //       namespaces overlap
        //

        Status = LsapForestTrustFindMatch(
                     LsapDbNoMoreWin2KForest() ?
                        RoutingMatchDomainName :
                        RoutingMatchNamespace,
                     TrustedDomainName,
                     TRUE, // look for local matches
                     NULL,
                     NULL
                     );

        if ( NT_SUCCESS( Status )) {

            NamespaceMatched = TRUE;

        } else if ( Status != STATUS_NO_MATCH ) {

            //
            // Failed for reason other than no match found - fail the call
            //

            LsapDsDebugOut(( DEB_SIDFILTER, "LsaIFilterNamespace: LsapForestTrustFindMatch failed with (0x%x) on line %d\n", Status, __LINE__ ));
            return Status;
        }
    }

    //
    // Failed to match the namespace so far.  See if it matches the name of
    // the trust.
    //

    if ( !NamespaceMatched ) {

        if ( LsapCompareDomainNames(
                 Namespace,
                 TrustedDomainName,
                 NULL )) {

            NamespaceMatched = TRUE;
        }
    }

    LsapDsDebugOut((
        DEB_SIDFILTER,
        "LsaIFilterNamespace: namespace %wZ %smatch%s trust %wZ\n",
        Namespace,
        NamespaceMatched ? "" : "did not ",
        NamespaceMatched ? "ed" : "",
        TrustedDomainName ));

    return NamespaceMatched ? STATUS_SUCCESS : STATUS_DOMAIN_TRUST_INCONSISTENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\rpcnotif.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dslookup.c

Abstract:

    Implementation of server side RPC notify routines

Author:

    Mac McLain          (MacM)       May 17, 1998

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>

VOID
LsapServerRpcThreadReturnNotify(
    LPWSTR CallingFunction
    );


VOID
LsarClose_notify(
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarClose" );
}

VOID
LsarDelete_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDelete" );
}

VOID
LsarEnumeratePrivileges_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumeratePrivileges" );
}

VOID
LsarQuerySecurityObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQuerySecurityObject" );
}

VOID
LsarSetSecurityObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomainsEx" );
}

VOID
LsarChangePassword_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarChangePassword" );
}

VOID
LsarOpenPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicy" );
}

VOID
LsarQueryInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInformationPolicy" );
}

VOID
LsarSetInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationPolicy" );
}

VOID
LsarClearAuditLog_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarClearAuditLog" );
}

VOID
LsarCreateAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateAccount" );
}

VOID
LsarEnumerateAccounts_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccounts" );
}

VOID
LsarCreateTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateTrustedDomain" );
}

VOID
LsarEnumerateTrustedDomains_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomains" );
}

VOID
LsarLookupNames_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupNames" );
}

VOID
LsarLookupSids_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupSids" );
}

VOID
LsarCreateSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateSecret" );
}

VOID
LsarOpenAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenAccount" );
}

VOID
LsarEnumeratePrivilegesAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumeratePrivilegesAccount" );
}

VOID
LsarAddPrivilegesToAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarAddPrivilegesToAccount" );
}

VOID
LsarRemovePrivilegesFromAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRemovePrivilegesFromAccount" );
}

VOID
LsarGetQuotasForAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarGetQuotasForAccount" );
}

VOID
LsarSetQuotasForAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetQuotasForAccount" );
}

VOID
LsarGetSystemAccessAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarGetSystemAccessAccount" );
}

VOID
LsarSetSystemAccessAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetSystemAccessAccount" );
}

VOID
LsarOpenTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenTrustedDomain" );
}

VOID
LsarQueryInfoTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInfoTrustedDomain" );
}

VOID
LsarSetInformationTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationTrustedDomain" );
}

VOID
LsarOpenSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenSecret" );
}

VOID
LsarSetSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetSecret" );
}

VOID
LsarQuerySecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQuerySecret" );
}

VOID
LsarLookupPrivilegeValue_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeValue" );
}

VOID
LsarLookupPrivilegeName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeName" );
}

VOID
LsarLookupPrivilegeDisplayName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeDisplayName" );
}

VOID
LsarDeleteObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDeleteObject" );
}

VOID
LsarEnumerateAccountsWithUserRight_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccountsWithUserRight" );
}

VOID
LsarEnumerateAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccountRights" );
}

VOID
LsarAddAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarAddAccountRights" );
}

VOID
LsarRemoveAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRemoveAccountRights" );
}

VOID
LsarQueryTrustedDomainInfo_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryTrustedDomainInfo" );
}

VOID
LsarSetTrustedDomainInfo_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetTrustedDomainInfo" );
}

VOID
LsarDeleteTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDeleteTrustedDomain" );
}

VOID
LsarStorePrivateData_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarStorePrivateData" );
}

VOID
LsarRetrievePrivateData_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRetrievePrivateData" );
}

VOID
LsarOpenPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicy2" );
}

VOID
LsarOpenPolicySce_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicySce" );
}

VOID
LsarGetUserName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarGetUserName" );
}

VOID
LsarQueryInformationPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInformationPolicy2" );
}

VOID
LsarSetInformationPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationPolicy2" );
}

VOID
LsarQueryTrustedDomainInfoByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryTrustedDomainInfoByName" );
}

VOID
LsarSetTrustedDomainInfoByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetTrustedDomainInfoByName" );
}

VOID
LsarEnumerateTrustedDomainsEx_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomainsEx" );
}

VOID
LsarCreateTrustedDomainEx_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateTrustedDomainEx" );
}

VOID
LsarQueryDomainInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryDomainInformationPolicy" );
}

VOID
LsarSetDomainInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetDomainInformationPolicy" );
}

VOID
LsarOpenTrustedDomainByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenTrustedDomainByName" );
}

VOID
LsarSetPolicyReplicationHandle_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetPolicyReplicationHandle" );
}

VOID
LsarLookupNames3_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupNames3" );
}

VOID
LsarQueryForestTrustInformation_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryForestTrustInformation" );
}

VOID
LsarSetForestTrustInformation_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetForestTrustInformation" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\exts\berdump.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ber.h"

#define iso_member          0x2a,               // iso(1) memberbody(2)
#define us                  0x86, 0x48,         // us(840)
#define rsadsi              0x86, 0xf7, 0x0d,   // rsadsi(113549)
#define pkcs                0x01,               // pkcs(1)

#define rsa_                iso_member us rsadsi
#define rsa_len             6
#define rsa_text            "iso(2) member-body(2) us(840) rsadsi(113549) "
#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define pkcs_text           "iso(2) member-body(2) us(840) rsadsi(113549) pkcs(1) "


#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2

typedef struct _ObjectId {
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
    PSTR        Name;
} ObjectId;

ObjectId    KnownObjectIds[] = {
    { {pkcs_1 1, 1}, pkcs_len + 2, pkcs_text "RSA"},
    { {pkcs_1 1, 2}, pkcs_len + 2, pkcs_text "MD2/RSA"},
    { {pkcs_1 1, 4}, pkcs_len + 2, pkcs_text "MD5/RSA"},
    { {rsa_ 3, 4}, rsa_len + 2, rsa_text "RC4"},
    { {attributeType 3}, attrtype_len + 1, "CN="},
    { {attributeType 6}, attrtype_len + 1, "C="},
    { {attributeType 7}, attrtype_len + 1, "L="},
    { {attributeType 8}, attrtype_len + 1, "S="},
    { {attributeType 10}, attrtype_len + 1, "O="},
    { {attributeType 11}, attrtype_len + 1, "OU="},
    };

ObjectId    KnownPrefixes[] = {
    { {pkcs_1}, pkcs_len, pkcs_text},
    { {iso_member us rsadsi}, pkcs_len - 1, "iso(2) member-body(2) us(840) rsadsi(113549) "},
    { {iso_member us}, pkcs_len - 4, "iso(2) member-body(2) us(840) "},
    { {iso_member}, pkcs_len - 6, "iso(2) member-body(2) " }
    };


typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1}
                               };
BYTE        Buffer[1024];

BOOL        BerVerbose = FALSE ;

char maparray[] = "0123456789abcdef";

#define MAX_OID_VALS    32

typedef struct _OID {
    unsigned cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

typedef enum _OidResult {
    OidExact,
    OidPartial,
    OidMiss,
    OidError
} OidResult;


extern  PNTSD_EXTENSION_APIS    pExtApis;
extern  HANDLE                  hDbgThread;
extern  HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define ExitIfCtrlC()   if (pExtApis->lpCheckControlCRoutine()) return;
#define BreakIfCtrlC()  if (pExtApis->lpCheckControlCRoutine()) break;


#define LINE_SIZE   192
#define INDENT_SIZE 4

#define OID_VERBOSE 0x0002
#define OID_PARTIAL 0x0001

char * DefaultTree =
   "1 iso\n"
   "    2 memberbody\n"
   "        840 us\n"
   "            113549 rsadsi\n"
   "                1 pkcs\n"
   "                    1 RSA\n"
   "                    3 pkcs-3\n"
   "                        1 dhKeyAgreement\n"
   "                2 digestAlgorithm\n"
   "                    2 MD2\n"
   "                    4 MD4\n"
   "                    5 MD5\n"
   "            113554 mit\n"
   "                1 infosys\n"
   "                    2 gssapi\n"
   "                        1 generic\n"
   "                            1 user_name\n"
   "                            2 machine_uid_name\n"
   "                            3 string_uid_name\n"
   "            113556 microsoft\n"
   "                1 ds\n"
   "    3 org\n"
   "        6 dod\n"
   "            1 internet\n"
   "                4 private\n"
   "                    1 enterprise\n"
   "                        311 microsoft\n"
   "                            1 software\n"
   "                                1 systems\n"
   "                                2 wins\n"
   "                                3 dhcp\n"
   "                                4 apps\n"
   "                                5 mos\n"
   "                                7 InternetServer\n"
   "                                8 ipx\n"
   "                                9 ripsap\n"
   "                            2 security\n"
   "                                1 certificates\n"
   "                                2 mechanisms\n"
   "                                    9 Negotiator\n"
   "                                    10 NTLM\n"
   "                                    12 SSL\n"
   "                5 security\n"
   "                    3 integrity\n"
   "                        1 md5-DES-CBC\n"
   "                        2 sum64-DES-CBC\n"
   "                    5 mechanisms\n"
   "                        1 spkm\n"
   "                            1 spkm-1\n"
   "                            2 spkm-2\n"
   "                            10 spkmGssTokens\n"
   "                    6 nametypes\n"
   "                        2 gss-host-based-services\n"
   "                        3 gss-anonymous-name\n"
   "                        4 gss-api-exported-name\n"
   "        14 oiw\n"
   "            3 secsig\n"
   "                2 algorithm\n"
   "                    7 DES-CBC\n"
   "                    10 DES-MAC\n"
   "                    18 SHA\n"
   "                    22 id-rsa-key-transport\n"
   "2 joint-iso-ccitt\n"
   "    5 ds\n"
   "        4 attribute-type\n"
   "            3 CommonName\n"
   "            6 Country/region\n"
   "            7 Locality\n"
   "            8 State\n"
   "            10 Organization\n"
   "            11 OrgUnit\n"
    ;


typedef struct _TreeFile {
    CHAR *  Buffer;
    CHAR *  Line;
    CHAR *  CurNul;
} TreeFile, * PTreeFile ;


BOOL
TreeFileInit(
    PTreeFile   pFile,
    PSTR        pStr)
{
    int l;


    l = strlen( pStr );

    if ( (pStr[l - 1] != '\r') &&
         (pStr[l - 1] != '\n') )
    {
        l++;
    }

    pFile->Buffer = LocalAlloc( LMEM_FIXED, l );

    if ( pFile->Buffer )
    {
        strcpy( pFile->Buffer, pStr );
        pFile->Line = pFile->Buffer ;
        pFile->CurNul = NULL ;
    }

    return (pFile->Buffer != NULL);

}

VOID
TreeFileDelete(
    PTreeFile   pFile
    )
{
    LocalFree( pFile->Buffer );

}

PSTR
TreeFileGetLine(
    PTreeFile   pFile )
{
    PSTR    Scan;
    PSTR    Line;

    if ( !pFile->Line )
    {
        return( NULL );
    }

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    Scan = pFile->Line ;

    while ( *Scan && (*Scan != '\n') && (*Scan != '\r'))
    {
        Scan++;
    }

    //
    // Okay, get the line to return
    //

    Line = pFile->Line;

    //
    // If this is not the end, touch up the pointers:
    //

    if ( *Scan )
    {
        *Scan = '\0';

        pFile->CurNul = Scan;

        Scan += 1;

        while ( *Scan && ( (*Scan == '\r' ) || ( *Scan == '\n') ))
        {
            Scan++ ;
        }

        //
        // If this is the end, reset line
        //

        if ( *Scan == '\0' )
        {
            pFile->Line = NULL ;
        }
        else
        {
            pFile->Line = Scan;
        }

    }
    else
    {
        pFile->Line = NULL ;
    }

    return( Line );

}

VOID
TreeFileRewind(
    PTreeFile   pFile )
{

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    pFile->Line = pFile->Buffer ;
}

int
tohex(
    BYTE    b,
    PSTR    psz)
{
    BYTE b1, b2;

    b1 = b >> 4;
    b2 = b & 0xF;

    *psz++ = maparray[b1];
    *psz = maparray[b2];

    return(3);
}


//+---------------------------------------------------------------------------
//
//  Function:   DecodeOID
//
//  Synopsis:   Decodes an OID into a simple structure
//
//  Arguments:  [pEncoded] --
//              [len]      --
//              [pOID]     --
//
//  History:    8-07-96   RichardW   Stolen directly from DonH
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DecodeOID(unsigned char *pEncoded, int len, OID *pOID)
{
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
        return FALSE;
    }


    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;

    //DebuggerOut("Encoded value %02x turned into %d and %d\n", pEncoded[0],
    //          pOID->Val[0], pOID->Val[1] );

    cval = 2;
    i = 1;

    while (i < len) {
        j = 0;
        val = pEncoded[i] & 0x7f;
        while (pEncoded[i] & 0x80) {
            val <<= 7;
            ++i;
            if (++j > 4 || i >= len) {
                // Either this value is bigger than we can handle (we
                // don't handle values that span more than four octets)
                // -or- the last octet in the encoded string has its
                // high bit set, indicating that it's not supposed to
                // be the last octet.  In either case, we're sunk.
                return FALSE;
            }
            val |= pEncoded[i] & 0x7f;
        }
        //ASSERT(i < len);
        pOID->Val[cval] = val;
        ++cval;
        ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

PSTR
GetLineWithIndent(
    PTreeFile   ptf,
    DWORD       i)
{
    PSTR    Scan;
    DWORD   test;


    do
    {
        Scan = TreeFileGetLine( ptf );


        if ( Scan && i )
        {
            if ( i < INDENT_SIZE )
            {
                test = 0;
            }
            else
            {
                test = i - INDENT_SIZE ;
            }

            if ( Scan[ test ] != ' ' )
            {
                {
                    Scan = NULL ;
                    break;
                }
            }

        }
        else
            test = 0;

    } while ( Scan && (Scan[i] == ' ')  );

    return( Scan );
}

OidResult
scan_oid_table(
    char *  Table,
    DWORD   Flags,
    PUCHAR  ObjectId,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   MaxRep)
{
    CHAR    OidPath[ MAX_PATH ];
    OID     Oid;
    DWORD   i;
    DWORD   Indent;
    TreeFile    tf;
    PSTR    Scan;
    PSTR    Tag;
    PSTR    SubScan;
    DWORD   Index;
    DWORD   size;
    DWORD   TagSize;

    if (!DecodeOID( ObjectId, Len, &Oid ))
    {
        return( OidError );
    }


    i = 0;

    Indent = 0;

    if ( !TreeFileInit( &tf, Table ) )
    {
        DebuggerOut("Unable to load prefix table\n");
        return OidError ;
    }

    Tag = OidPath;

    size = 0;

    TagSize = 0;


    if ( (Flags & OID_VERBOSE) == 0 )
    {
        while ( i < Oid.cVal )
        {
            TagSize = _snprintf( Tag, MAX_PATH - size, "%d.",
                            Oid.Val[i] );

            size += TagSize;

            Tag += TagSize;

            i++;

        }

        strncpy( pszRep, OidPath, MaxRep );

        TreeFileDelete( &tf );

        return( OidExact );
    }

    while ( i < Oid.cVal )
    {

        do
        {

            Scan = GetLineWithIndent( &tf, Indent );


            if ( Scan )
            {
                Index = atoi(Scan);
            }
            else
            {
                Index = (DWORD) -1;
            }

            if ( Index == Oid.Val[i] )
            {
                break;
            }

        } while ( Scan );


        //
        // If Scan is NULL, we didn't get a match
        //

        if ( !Scan )
        {
            if ( i > 0 )
            {
                if ( Flags & OID_PARTIAL )
                {
                    while ( i < Oid.cVal )
                    {
                        TagSize = _snprintf( Tag, MAX_PATH - size, "%d ",
                                        Oid.Val[i] );

                        size += TagSize;

                        Tag += TagSize;

                        i++;

                    }
                    strncpy( pszRep, OidPath, MaxRep );
                }

                TreeFileDelete( &tf );

                return( OidPartial );

            }

            TreeFileDelete( &tf );

            return( OidMiss );
        }

        //
        // Got a hit:
        //

        SubScan = &Scan[Indent];

        while (*SubScan != ' ')
        {
            SubScan++;
        }

        SubScan++;

        TagSize = _snprintf( Tag, MAX_PATH - size, "%s(%d) ", SubScan, Index );

        size += TagSize;

        Tag += TagSize ;

        Indent += INDENT_SIZE ;

        i ++;


    }

    strncpy( pszRep, OidPath, MaxRep );

    TreeFileDelete( &tf );

    return( OidExact );


}

decode_to_string(
    LPBYTE  pBuffer,
    DWORD   Flags,
    DWORD   Type,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   RepLen)
{
    PSTR    pstr;
    PSTR    lineptr;
    DWORD   i;


    switch (Type)
    {
        case BER_NULL:
            strcpy(pszRep, "<empty>");
            break;

        case BER_OBJECT_ID:
            scan_oid_table( DefaultTree,
                            OID_PARTIAL | (Flags & DECODE_VERBOSE_OIDS ? OID_VERBOSE : 0 ),
                            pBuffer, Len, pszRep, RepLen );

            break;

        case BER_PRINTABLE_STRING:
        case BER_TELETEX_STRING:
        case BER_GRAPHIC_STRING:
        case BER_VISIBLE_STRING:
        case BER_GENERAL_STRING:
            CopyMemory(pszRep, pBuffer, min(Len, RepLen - 1) );
            pszRep[min(Len, RepLen - 1)] = '\0';
            break;

        default:

            pstr = &pszRep[30];
            lineptr = pszRep;
            for (i = 0; i < min(Len, 8) ; i++ )
            {
                lineptr += tohex(*pBuffer, lineptr);
                if ((*pBuffer >= ' ') && (*pBuffer <= '|'))
                {
                    *pstr++ = *pBuffer;
                }
                else
                {
                    *pstr++ = '.';
                }

                pBuffer++;

            }
            *pstr++ = '\0';
    }
    return(0);
}

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    DWORD   Flags,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth)
{
    char *  TypeName = NULL;
    char    msg[32];
    char *  pstr;
    int     i;
    int     Len;
    int     ByteCount;
    int     Accumulated;
    DWORD   Type;
    int     subsize;
    char    line[ LINE_SIZE ];
    BOOL    Nested;
    BOOL    Leaf;
    int     NewBarDepth;
    char    nonuniversal[ LINE_SIZE ];



    if ((Stop)())
    {
        return(0);
    }

    Type = *pBuffer;


    if ( (Type & 0xC0) == 0 )
    {
        switch ( Type & 0x1F )
        {
            case BER_BOOL:
                TypeName = "Bool";
                break;

            case BER_INTEGER:
                TypeName = "Integer";
                break;

            case BER_BIT_STRING:
                TypeName = "Bit String";
                break;

            case BER_OCTET_STRING:
                TypeName = "Octet String";
                if ( Flags & DECODE_NEST_OCTET_STRINGS )
                {
                    TypeName = "Octet String (Expanding)";
                    Type |= BER_CONSTRUCTED ;
                    Flags &= ~( DECODE_NEST_OCTET_STRINGS );
                }
                break;

            case BER_NULL:
                TypeName = "Null";
                break;

            case BER_OBJECT_ID:
                TypeName = "Object ID";
                break;

            case BER_OBJECT_DESC:
                TypeName = "Object Descriptor";
                break;

            case BER_SEQUENCE:
                TypeName = "Sequence";
                break;

            case BER_SET:
                TypeName = "Set";
                break;

            case BER_NUMERIC_STRING:
                TypeName = "Numeric String";
                break;

            case BER_PRINTABLE_STRING:
                TypeName = "Printable String";
                break;

            case BER_TELETEX_STRING:
                TypeName = "TeleTex String";
                break;

            case BER_VIDEOTEX_STRING:
                TypeName = "VideoTex String";
                break;

            case BER_VISIBLE_STRING:
                TypeName = "Visible String";
                break;

            case BER_GENERAL_STRING:
                TypeName = "General String";
                break;

            case BER_GRAPHIC_STRING:
                TypeName = "Graphic String";
                break;

            case BER_UTC_TIME:
                TypeName = "UTC Time";
                break;


            default:
                TypeName = "Unknown";
                break;
        }
    }
    else
    {
        //
        // Not universal
        //

        switch ( Type & 0xC0 )
        {
            case BER_UNIVERSAL:
                TypeName = "Internal Error!";
                break;

            case BER_APPLICATION:
                sprintf( nonuniversal, "[Application %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_CONTEXT_SPECIFIC:
                sprintf( nonuniversal, "[Context Specific %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_PRIVATE:
                sprintf( nonuniversal, "[Private %d]", Type & 0x1F);
                TypeName = nonuniversal ;
                break;

        }
    }


    pstr = msg;
    for (i = 0; i < Indent ; i++ )
    {
        if (i < BarDepth)
        {
            *pstr++ = '\263';
        }
        else
        {
            *pstr++ = ' ';
        }
        *pstr++ = ' ';
    }
    *pstr++ = '\0';

    pBuffer ++;
    Len = 0;

    if (*pBuffer & 0x80)
    {
        ByteCount = *pBuffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            Len <<= 8;
            Len += *pBuffer++;
        }
    }
    else
    {
        ByteCount = 0;
        Len = *pBuffer++;
    }

    if (Offset + Len + 2 + ByteCount == TotalLength)
    {
        Leaf = TRUE;
    }
    else
    {
        Leaf = FALSE;
    }
    if (Type & BER_CONSTRUCTED)
    {
        Nested = TRUE;
    }
    else
    {
        Nested = FALSE;
    }

    (Out)("%s%c\304%c[%x] %s(%d) ", msg,
                    Leaf ? 192 : 195,
                        Nested ? 194 : 196,
                        Type, TypeName, Len);

    if ( Type & BER_CONSTRUCTED )
    {
        (Out)("\n");
        Accumulated = 0;
        while (Accumulated < Len)
        {
            if (BarDepth < Indent)
            {
                NewBarDepth = BarDepth;
            }
            else
            {
                NewBarDepth = (Nested && Leaf) ? BarDepth : Indent + 1;
            }

            subsize = ber_decode(Out, Stop, pBuffer, Flags, Indent + 1,
                                    Accumulated, Len, NewBarDepth);
            Accumulated += subsize;
            pBuffer += subsize;
        }
        (Out)("%s%c\n", msg, ((Indent <= BarDepth) && !Leaf) ? 179 : 32);
    }
    else
    {
        memset(line, ' ', LINE_SIZE - 1);
        line[ LINE_SIZE - 1 ] = '\0';

        decode_to_string(pBuffer, Flags, Type, Len, line, LINE_SIZE);

        (Out)("%s\n", line);

    }

    return(Len + 2 + ByteCount);
}

BOOL
NeverStop(void)
{
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\exts\lsaexts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------


extern "C"
{
#include "lsasrvp.h"
#include "ausrvp.h"
#include "spmgr.h"
#include "sidcache.h"
}
#include <stdio.h>
#include <malloc.h>

#include <dbghelp.h>
#include <ntsdexts.h>

#include <dsysdbg.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <cryptdll.h>

#include "debugp.h"

#include "..\spmgr.h"
#include "..\sphelp.h"
#include "..\sesmgr.h"
#include "..\scavenge.hxx"
#include "..\negotiat.hxx"
#include "..\sht.hxx"
#include "..\lht.hxx"


#define DBP_TYPES_ONLY
#include "..\dspolicy\dbp.h"
#define LSAEXTS
#include "..\dspolicy\dbftrust.h"

#define FlagSize(x)     (sizeof(x) / sizeof(char *))
char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * HandleFlags[] = { "Locked", "DeletePending", "NoCallback" };
char * LhtFlags[] = { "NoSerialize", "Callback", "Unique",
                        "Child", "LimitDepth", "DeletePending", "NoFree"};
char * LhtSubFlags[] = { "SubTable" };
char * ShtFlags[] = {   "NoSerialize", "Callback", "Unique",
                        "NoFree", "DeletePending" };

char * ScavFlags[] = {  "NewThread", "One Shot", "FreeHandle", "",
                        "", "", "", "",
                        "", "", "", "", "", "", "", "",
                        "", "", "", "", "", "", "", "",
                        "", "TriggerFree", "StateChange", "Immediate",
                        "DebugBreak", "AboutToDie", "InProgress", "Seconds" };

char * ScavClasses[] = { "<Invalid>", "PackageChange" };
#define ScavClassName(x)    (x < (sizeof(ScavClasses) / sizeof(char *) ) ? \
                                ScavClasses[ x ] : "<Invalid>" )

char * QueueTypes[] = { "Shared", "Single", "ShareRead", "Zombie" };
#define QueueTypeName(x)    (x < (sizeof( QueueTypes ) / sizeof( char * ) ) ? \
                                QueueTypes[ x ] : "<Invalid>" )

char * SessFlags[] = {  "Queue", "TcbPriv", "Clone", "Impersonate",
                        "Desktop", "Untrusted", "InProc", "Autonomous",
                        "Default", "Unload", "Scavenger", "Cleanup",
                        "Kernel", "Restricted", "MaybeKernel", "EFS",
                        "Shadow", "Wow64", "", "",
                        "", "", "", "",
                        "", "", "", "",
                        "", "", "", "" };

char * PackageFlags[] = {"Invalid", "Unload", "Never Load", "Internal", "Never Call",
                         "Preferred", "Delete", "Info", "ContextThunk", "Shutdown Pending",
                         "Shutdown", "WowSupport", "", "", "", "", "AuthPkg"
                        };

char * Capabilities[] = {"Sign/Verify", "Seal/Unseal", "Token Only", "Datagram",
                         "Connection", "Multi-Required", "ClientOnly", "ExtError",
                         "Impersonation", "Win32Name", "Stream", "Negotiable",
                         "GSS Compat", "Logon", "AsciiBuffer", "Fragment",
                         "MutualAuth", "Delegation", "", "",
                         "", "", "", ""
                         };

char * APIFlags[] = {"Error", "Memory", "PrePack", "GetState",
                     "AnsiCall", "HandleChange", "CallBack", "VmAlloc",
                     "ExecNow", "Win32Error", "KMap Mem", ""
                    };

char * CallInfoFlags[] = { "Kernel", "Ansi", "Urgent", "Recursive",
                           "InProc", "Cleanup", "WowClient", ""
                         };

char * LsaCallInfoFlags[] = { "Impersonating", "InProcCall", "SupressAudits", 
                            "NoHandleCheck", "KernelPool", "KMap Used" };


char * NegCredFlags[] = { "DefaultPlaceholder","Default","Multi",
                          "UseSnego","Kernel","Explicit", "MultiPart",
                          "AllowNtlm", "NegNtlm", "NtlmLoopback" };
char * NegContextFlags[] = { "PackageCalled", "FreeEachMech",
                             "Negotiating", "Fragmenting",
                             "FragInbound", "FragOutbound",
                             "Uplevel", "MutualAuth", };

char * NegPackageFlags[] = { "Preferred", "NT4", "ExtraOID", "Inbound",
                             "Outbound", "Loopback" };

char * SDFlags[] = {"OwnerDef","GroupDef","DaclPresent","DaclDef","SaclPresent",
                    "SaclDef","SelfRelative"};

char * ImpLevels[] = {"Anonymous", "Identification", "Impersonation", "Delegation"};
#define ImpLevel(x) ((x < (sizeof(ImpLevels) / sizeof(char *))) ? ImpLevels[x] : "Illegal!")

char * SecBufferTypes[] = {"Empty", "Data", "Token", "Package", "Missing", "Extra",
                           "Trailer", "Header" };
#define SecBufferType(x) (((x & ~(SECBUFFER_ATTRMASK)) < (sizeof(SecBufferTypes) / sizeof(char *))) ? \
                            SecBufferTypes[ (x & ~(SECBUFFER_ATTRMASK)) ] : "Invalid" )

char * LogonTypes[] = {"Invalid", "Invalid",
                       "Interactive",
                       "Network",
                       "Batch",
                       "Service",
                       "Proxy",
                       "Unlock",
                       "NetworkCleartext",
                       "NewCredentials" };

#define LogonTypeName( x )  ( ( x < sizeof( LogonTypes ) / sizeof( char * )) ? \
                              LogonTypes[ x ] : "Invalid" )

char * MessageNames[] = {       "<Disconnect>",
                                "<Connect>",
                                "LsaLookupPackage",
                                "LsaLogonUser",
                                "LsaCallPackage",
                                "LsaDeregisterLogonProcess",
                                "<empty>",
                                "(I) GetBinding",
                                "(I) SetSession",
                                "(I) FindPackage",
                                "EnumeratePackages",
                                "AcquireCredentialHandle",
                                "EstablishCredentials",
                                "FreeCredentialHandle",
                                "InitializeSecurityContext",
                                "AcceptSecurityContext",
                                "ApplyControlToken",
                                "DeleteSecurityContext",
                                "QueryPackage",
                                "GetUserInfo",
                                "GetCredentials",
                                "SaveCredentials",
                                "DeleteCredentials",
                                "QueryCredAttributes",
                                "AddPackage",
                                "DeletePackage",
                                "GenerateKey",
                                "GenerateDirEfs",
                                "DecryptFek",
                                "GenerateSessionKey",
                                "Callback",
                                "QueryContextAttributes",
                                "PolicyChangeNotify",
                                "GetUserName",
                                "AddCredential",
                                "EnumLogonSession",
                                "GetLogonSessionData",
                                "SetContextAttribute",
                                "LookupAccountSid",
                                "LookupAccountName",
                                "<empty>" };
#define ApiLabel(x) (((x+2) < sizeof(MessageNames) / sizeof(char *)) ?  \
                        MessageNames[(x+2)] : "[Illegal API Number!]")

#define NAME_BASE       "lsasrv"
#define PACKAGE_LIST    NAME_BASE "!pPackageControlList"
#define PACKAGE_COUNT   NAME_BASE "!PackageControlCount"
#define DLL_COUNT       NAME_BASE "!PackageDllCount"
#define DLL_LIST        NAME_BASE "!pPackageDllList"
#define SESSION_LIST    NAME_BASE "!SessionList"
#define MEMORY_LIST     NAME_BASE "!pLastBlock"
#define TLS_SESSION     NAME_BASE "!dwSession"
#define PFASTMEM        NAME_BASE "!pFastMem"
#define CFASTMEM        NAME_BASE "!cFastMem"
#define FFASTMEM        NAME_BASE "!fFastMemStats"

#define MAXPOOLTHREADS  NAME_BASE "!MaxPoolThreads"
#define GLOBALQUEUE     NAME_BASE "!GlobalQueue"

#define SCAVLIST        NAME_BASE "!ScavList"
#define NOTIFYLIST      NAME_BASE "!NotifyList"


#define LPC_APILOG      NAME_BASE "!LpcApiLog"
#define INTERNAL_APILOG NAME_BASE "!InternalApiLog"

#define FAULTINGTID     NAME_BASE "!FaultingTid"
#define EXCEPTIONINFO   NAME_BASE "!dwExceptionInfo"
#define TLS_CALLINFO    NAME_BASE "!dwCallInfo"


WCHAR *Packages[]     = {L"Kerberos", L"NTLM", L"MSV" };

#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, x)
#define FreeHeap(x) RtlFreeHeap(RtlProcessHeap(), 0, x)
void    PrintToken(HANDLE, PNTSD_EXTENSION_APIS);
void    LocalDumpSid(PSID);

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define LsaGetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define DBG_STACK_TRACE 8

CHAR*
SidNameUseXLate(
    INT i
    )
{
    switch ( i ) {

        case SidTypeUser:
            return "User";
        case SidTypeGroup:
            return "Group";
        case SidTypeDomain:
            return "Domain";
        case SidTypeAlias:
            return "Alias";
        case SidTypeWellKnownGroup:
            return "WellKnownGroup";
        case SidTypeDeletedAccount:
            return "Deleted Account";
        case SidTypeInvalid:
            return "Invalid Sid";
        case SidTypeUnknown:
            return "Unknown Type";
        case SidTypeComputer:
            return "Computer";
        default:
            return "Really Unknown -- This is a bug";
    }

}

SECURITY_STATUS
LsaReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    SIZE_T       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());

}

SECURITY_STATUS
LsaWriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    SIZE_T       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());
}

DWORD
GetDword(PVOID  pvMemory)
{
    DWORD   dwVal;
    SIZE_T   cbActual = sizeof(DWORD);

    if (ReadProcessMemory(hDbgProcess, pvMemory, &dwVal, sizeof(DWORD), &cbActual))
    {
        if (cbActual != sizeof(DWORD))
        {
            return((DWORD) -1);
        }
        return(dwVal);
    }
    return((DWORD) -1);
}

TEB *
GetTeb(HANDLE   hThread)
{
    NTSTATUS                    Status;
    THREAD_BASIC_INFORMATION    ThreadInfo;
    ULONG                       cbReturned;
    PTEB                        Teb;

    Status = NtQueryInformationThread(  hThread,
                                        ThreadBasicInformation,
                                        &ThreadInfo,
                                        sizeof(ThreadInfo),
                                        &cbReturned);

    if (!NT_SUCCESS(Status))
    {
        DebuggerOut("Failed to read Teb, %x\n", Status);
        return(NULL);
    }

    Teb = (PTEB) AllocHeap(sizeof(TEB));

    if ( Teb )
    {
        LsaReadMemory(ThreadInfo.TebBaseAddress, sizeof(TEB), Teb);
    }


    return(Teb);

}

PVOID
GetTlsFromTeb(
            ULONG   Index,
            TEB *   Teb)
{
    return(Teb->TlsSlots[Index]);
}

SECURITY_STATUS
GetTlsEntry(ULONG       TlsValue,
            PVOID *     ppvValue)
{
    TEB *                       Teb;

    Teb = GetTeb(hDbgThread);

    if (!Teb)
    {
        DebuggerOut("Could not read teb for thread\n");
        return(STATUS_UNSUCCESSFUL);
    }

    *ppvValue = GetTlsFromTeb(TlsValue, Teb);

    FreeHeap(Teb);

    return(0);

}




void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    UCHAR *      buffer)
{
   char *         offset;
   DWORD          mask, test, i;
   DWORD          scratch;

   if (!Flags) {
      strcpy((CHAR *)buffer, "None");
      return;
   }
   buffer[0] = '0';

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ ) {
      if (Flags & test) {
         scratch = sprintf(offset, "%s", flagset[i]);
         offset += scratch;
         mask |= test;
         if (Flags & (~mask)) {
            *offset++ = ',';
         }
      }
      test <<= 1;
   }
}

#define TIMEBUF_SZ  64
char *Months[]      = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
            "Aug", "Sep", "Oct", "Nov", "Dec" };
void CTimeStamp(
    PTimeStamp      ptsTime,
    LPSTR           pszTimeBuf,
    BOOL            LocalOnly)
{
    SYSTEMTIME      stTime;
    FILETIME        tLocal;
    SYSTEMTIME      stLocal;

    if (ptsTime->HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
        return;
    }
    else if (ptsTime->HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
        return;
    }
    FileTimeToLocalFileTime((LPFILETIME) ptsTime, &tLocal);
    FileTimeToSystemTime((LPFILETIME) ptsTime, &stTime);
    FileTimeToSystemTime(&tLocal, &stLocal);
    if ( LocalOnly )
    {
        sprintf( pszTimeBuf, "%02d:%02d:%02d.%03d",
                stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds);

    }
    else
    {
        sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d %s %02d Local)", stTime.wHour,
            stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
            Months[stTime.wMonth], stTime.wDay, stTime.wYear,
            stLocal.wHour, stLocal.wMinute, Months[stLocal.wMonth], stLocal.wDay);

    }
}

void
MapString(
    PSECURITY_STRING  pClientString,
    PSECURITY_STRING  pLocalString)
{
    if (!pLocalString->Buffer)
    {
        pLocalString->Buffer = (PWSTR) AllocHeap(pClientString->Length + 2);
        pLocalString->MaximumLength = pClientString->Length + 2;
    }

    if ( !pLocalString->Buffer )
    {
        return;
    }

    RtlZeroMemory(pLocalString->Buffer, pLocalString->MaximumLength);

    if (!LsaReadMemory(pClientString->Buffer, pClientString->Length, pLocalString->Buffer))
    {
        pLocalString->Length = pClientString->Length;
    }
    else
    {
        DebuggerOut("\nWarning: could not read string @%p\n", pClientString->Buffer);
    }

}

BOOL
MapSid(
    PSID RemoteSid,
    PSID * LocalSid
    )
{
    SID Temp ;
    PSID Copy ;

    *LocalSid = NULL ;

    if ( RemoteSid == NULL )
    {
        return FALSE ;
    }

    if ( !LsaReadMemory( RemoteSid, sizeof( SID ), &Temp ) )
    {
        return FALSE ;
    }

    Copy = AllocHeap( RtlLengthSid( &Temp ) );

    if ( !Copy )
    {
        return FALSE ;
    }

    if ( !LsaReadMemory( RemoteSid, RtlLengthSid( &Temp ), Copy ) )
    {
        FreeHeap( Copy );
        return FALSE ;
    }

    *LocalSid = Copy ;

    return TRUE ;


}

WCHAR * GetPackageName(
    DWORD_PTR    dwPackageId)
{
    switch (dwPackageId)
    {
        case SPMGR_ID:
            return(L"SPMgr");

        default:
            return(L"");

    }
}


#define PACKAGE_VERBOSE 0x00000001
#define PACKAGE_NOISY   0x00000002
#define PACKAGE_TITLE   0x00000004
void
ShowPackageControl(
    PVOID           Base,
    PLSAP_SECURITY_PACKAGE     pSecPkgCtrl,
    DWORD           fVerbose)
{
    SECURITY_STRING sLocal;
    UCHAR            buffer[ MAX_PATH ];
    ULONG_PTR       Disp;
    PSECPKG_FUNCTION_TABLE  pTable;

    sLocal.Buffer = NULL;

    MapString(&pSecPkgCtrl->Name, &sLocal);

    if (fVerbose & PACKAGE_TITLE)
    {
        DebuggerOut("Security Package Control structure at %p\n", Base);
    }

    DebuggerOut("ID         \t%d\n", pSecPkgCtrl->dwPackageID);
    DebuggerOut("Name       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    if (fVerbose & PACKAGE_VERBOSE)
    {
        DisplayFlags(pSecPkgCtrl->fPackage, FlagSize(PackageFlags), PackageFlags, buffer);
        DebuggerOut("  Flags    \t%#x: %s\n", pSecPkgCtrl->fPackage, buffer);
        DisplayFlags(pSecPkgCtrl->fCapabilities, 18, Capabilities, buffer);
        DebuggerOut("  Capabilities\t%#x: %s\n", pSecPkgCtrl->fCapabilities, buffer);
        DebuggerOut("  RPC ID   \t%d\n", pSecPkgCtrl->dwRPCID);
        DebuggerOut("  Version  \t%d\n", pSecPkgCtrl->Version );
        DebuggerOut("  TokenSize\t%d\n", pSecPkgCtrl->TokenSize );
        DebuggerOut("  Thunks   \t%p\n", pSecPkgCtrl->Thunks );
    }

    sLocal.Buffer = NULL;

    if (fVerbose & PACKAGE_NOISY)
    {
        pTable = &pSecPkgCtrl->FunctionTable;
        DebuggerOut("  Function table:\n");
        LsaGetSymbol((ULONG_PTR)pTable->Initialize,   buffer, &Disp);
        DebuggerOut("   Initialize         \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetInfo, buffer, &Disp);
        DebuggerOut("   GetInfo            \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->LogonUser, buffer, &Disp);
        DebuggerOut("   LogonUser          \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcceptCredentials, buffer, &Disp);
        DebuggerOut("   AcceptCreds        \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcquireCredentialsHandle, buffer, &Disp);
        DebuggerOut("   AcquireCreds       \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->FreeCredentialsHandle, buffer, &Disp);
        DebuggerOut("   FreeCreds          \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->SaveCredentials, buffer, &Disp);
        DebuggerOut("   SaveCredentials    \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetCredentials, buffer, &Disp);
        DebuggerOut("   GetCredentials     \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->DeleteCredentials, buffer, &Disp);
        DebuggerOut("   DeleteCredentials  \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->InitLsaModeContext, buffer, &Disp);
        DebuggerOut("   InitLsaModeContext \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->LogonTerminated, buffer, &Disp);
        DebuggerOut("   LogonTerminated    \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcceptLsaModeContext, buffer, &Disp);
        DebuggerOut("   AcceptLsaModeContext\t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->DeleteContext, buffer, &Disp);
        DebuggerOut("   DeleteContext      \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->ApplyControlToken, buffer, &Disp);
        DebuggerOut("   ApplyControlToken  \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->Shutdown, buffer, &Disp);
        DebuggerOut("   Shutdown           \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetUserInfo, buffer, &Disp);
        DebuggerOut("   GetUserInfo        \t%s\n", buffer);

    }

}

void
ShowSession(
    PVOID   pvSessionStart,
    PSession    pSession)
{
    UCHAR Buffer[128];
    ULONG_PTR Disp;
    LSAP_SESSION_RUNDOWN Rundown ;
    LSAP_SHARED_SECTION Section ;
    int i;
    PUCHAR ListEnd ;
    PVOID There ;
    DWORD   Tag;
    LARGE_HANDLE_TABLE  Large ;
    SMALL_HANDLE_TABLE  Small ;
    PVOID   Table ;



    DebuggerOut("Session @%p:\n", pvSessionStart);
    DebuggerOut("  Process ID\t%x\n", pSession->dwProcessID);
    DebuggerOut("  LPC Port  \t%x\n", pSession->hPort);

    DisplayFlags(pSession->fSession,    // Flags
                 32,                    // Flag limit
                 SessFlags,             // Flag set
                 Buffer);


    DebuggerOut("  Flags     \t%x: %s\n", pSession->fSession, Buffer);

    Table = pSession->SharedData->CredTable ;
    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Large ), &Large );

        DebuggerOut("  CredTable \t%p, %d handles\n", Table, Large.Count );

    }
    else if ( Tag == SHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Small ), &Small );

        DebuggerOut("  CredTable \t%p, %d handles\n", Table, Small.Count );

    }
    else
    {
        DebuggerOut("  CredTable \t%p, not a valid table\n", Table );
    }

    Table = pSession->SharedData->ContextTable ;

    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Large ), &Large );

        DebuggerOut("  ContextTable\t%p, %d handles\n", Table, Large.Count );

    }
    else if ( Tag == SHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Small ), &Small );

        DebuggerOut("  ContextTable\t%p, %d handles\n", Table, Small.Count );

    }
    else
    {
        DebuggerOut("  ContextTable\t%p, not a valid table\n", Table );
    }
    DebuggerOut("  RefCount  \t%d\n", pSession->RefCount );

    ListEnd = (PUCHAR) pvSessionStart + FIELD_OFFSET( Session, RundownList ) ;

    if ( pSession->RundownList.Flink == (PLIST_ENTRY) ListEnd )
    {
        DebuggerOut("  No rundown functions\n" );
    }
    else
    {
        DebuggerOut("  Rundown Functions:\n" );

        There = pSession->RundownList.Flink ;

        do
        {
            LsaReadMemory( There,
                        sizeof( LSAP_SESSION_RUNDOWN ),
                        &Rundown );

            LsaGetSymbol( (ULONG_PTR) Rundown.Rundown, Buffer, &Disp );
            DebuggerOut("    %s( %p )\n", Buffer, Rundown.Parameter );

            There = Rundown.List.Flink ;

            if (pExtApis->lpCheckControlCRoutine())
            {
                break;
            }

        } while ( There != ListEnd );

    }

    ListEnd = (PUCHAR) pvSessionStart + FIELD_OFFSET( Session, SectionList ) ;

    if ( pSession->SectionList.Flink == (PLIST_ENTRY) ListEnd )
    {
        DebuggerOut("  No shared sections\n");
    }
    else
    {
        DebuggerOut("  Shared Sections\n");

        There = pSession->SectionList.Flink ;

        do
        {
            LsaReadMemory( There,
                        sizeof( LSAP_SHARED_SECTION ),
                        &Section );

            DebuggerOut("    Section %p, base at %p\n",
                            Section.Section, Section.Base );

            There = Section.List.Flink ;

            if (pExtApis->lpCheckControlCRoutine())
            {
                break;
            }

        } while ( There != ListEnd );
    }
}


void
DumpSessionList(HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{
    PVOID       pvSessionStart;
    PVOID       pvAddress;
    Session     Sess;
    NTSTATUS    Status;
    LSAP_SHARED_SESSION_DATA SharedData ;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvAddress = (PVOID) GetExpr(SESSION_LIST);
    (void) LsaReadMemory(pvAddress, sizeof(PVOID), &pvSessionStart);
    DebuggerOut("psSessionList (@%p) = %p\n", pvAddress, pvSessionStart);

    do
    {
        Status = LsaReadMemory(pvSessionStart, sizeof(Session), &Sess);
        if (Status != 0)
        {
            DebuggerOut("Failed reading memory @%p\n", pvSessionStart);
            break;
        }

        LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

        Sess.SharedData = &SharedData ;

        ShowSession(pvSessionStart, &Sess);

        pvSessionStart = Sess.List.Flink ;

    } while (pvSessionStart != pvAddress );

    return;

}

void
DumpSession(HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    PVOID       pvAddress;
    PVOID       BaseAddress ;
    Session     Sess;
    NTSTATUS    Status;
    UINT_PTR    id;
    LSAP_SHARED_SESSION_DATA SharedData ;
    BOOL Found;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvAddress = GetExpr( pszCommand );

    id = ( UINT_PTR ) pvAddress;
    if ( id < 0x00010000 )
    {
        //
        // Search by process id:
        //

        pvAddress = (PVOID) GetExpr( SESSION_LIST );
        BaseAddress = pvAddress ;
        LsaReadMemory( pvAddress, sizeof( PVOID ), &pvAddress );
        Found = FALSE ;

        do
        {
            Status = LsaReadMemory(pvAddress, sizeof(Session), &Sess);
            if (Status != 0)
            {
                DebuggerOut("Failed reading memory @%p\n", pvAddress );
                break;
            }

            if ( Sess.dwProcessID == id )
            {
                LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

                Sess.SharedData = &SharedData ;

                ShowSession( pvAddress, &Sess );
                Found = TRUE ;
            }

            pvAddress = Sess.List.Flink ;

        } while (pvAddress != BaseAddress );

        if ( !Found )
        {
            DebuggerOut( "No session found with process id == %x\n", id );
        }

    }
    else
    {
        Status = LsaReadMemory(pvAddress, sizeof(Session), &Sess);

        LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

        Sess.SharedData = &SharedData ;

        ShowSession(pvAddress, &Sess);


    }

}

NTSTATUS
ReadCallInfo(
    PLSA_CALL_INFO CallInfo
    )
{
    DWORD TlsValue ;
    PVOID pvInfo ;
    NTSTATUS Status ;

    TlsValue =  GetDword(GetExpr(TLS_CALLINFO));

    Status = GetTlsEntry(TlsValue, &pvInfo);

    if (Status != 0)
    {
        DebuggerOut("Could not get TLS %d for Thread\n", TlsValue);
        return Status ;
    }

    if ( pvInfo )
    {
        Status = LsaReadMemory( pvInfo, sizeof( LSA_CALL_INFO ), CallInfo );
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL ;
    }

    return Status ;
}

VOID
ShowCallInfo(
    PVOID pv,
    PLSA_CALL_INFO CallInfo
    )
{
    ULONG i;
    CHAR Flags[ 128 ];


    DisplayFlags(CallInfo->CallInfo.Attributes,    // Flags
                 8,                    // Flag limit
                 CallInfoFlags,             // Flag set
                 (PUCHAR) Flags );


    DebuggerOut("LSA_CALL_INFO at %p\n", pv );
    DebuggerOut("  Message              %p\n", CallInfo->Message );
    DebuggerOut("  Session              %p\n", CallInfo->Session );
    DebuggerOut("   CallInfo.ThreadId       %x\n", CallInfo->CallInfo.ThreadId );
    DebuggerOut("   CallInfo.ProcessId      %x\n", CallInfo->CallInfo.ProcessId );
    DebuggerOut("   CallInfo.Attributes     %x : %s\n", CallInfo->CallInfo.Attributes, Flags );
    DebuggerOut("  InProcToken          %x\n", CallInfo->InProcToken );
    DebuggerOut("  InProcCall           %x\n", CallInfo->InProcCall );
    DisplayFlags(CallInfo->Flags, 6, LsaCallInfoFlags, (PUCHAR) Flags );
    DebuggerOut("  Flags                %x : %s\n", CallInfo->Flags, Flags );
    DebuggerOut("  Allocs               %d\n", CallInfo->Allocs );
    for (i = 0 ; i < CallInfo->Allocs ; i++ )
    {
        DebuggerOut("     Buffers[%d]      %p\n", CallInfo->Buffers[i]);
    }
    DebuggerOut("  KMap                 %p\n", CallInfo->KMap );
}

VOID
DumpThreadCallInfo(
    HANDLE hProcess,
    HANDLE hThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExt,
    LPSTR pszCommand
    )
{
    LSA_CALL_INFO CallInfo ;
    NTSTATUS Status ;

    InitDebugHelp(hProcess, hThread, lpExt);

    Status = ReadCallInfo( &CallInfo );

    if ( Status == 0 )
    {
        ShowCallInfo( NULL, &CallInfo );
    }
}

VOID
DumpCallInfo(
    HANDLE hProcess,
    HANDLE hThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExt,
    LPSTR pszCommand
    )
{
    LSA_CALL_INFO CallInfo ;
    NTSTATUS Status ;
    PVOID pv ;

    InitDebugHelp(hProcess, hThread, lpExt);

    pv = GetExpr( pszCommand );

    if ( pv )
    {
        LsaReadMemory( pv, sizeof( LSA_CALL_INFO ), &CallInfo );

        ShowCallInfo( pv, &CallInfo );
    }
}

void
DumpThreadSession(  HANDLE                  hProcess,
                    HANDLE                  hThread,
                    DWORD                   dwCurrentPc,
                    PNTSD_EXTENSION_APIS    lpExt,
                    LPSTR                   pszCommand)
{
    PVOID       pvSessionStart;
    Session     Session;
    NTSTATUS    Status;
    DWORD       TlsValue;
    LSAP_SHARED_SESSION_DATA SharedData ;

    InitDebugHelp(hProcess, hThread, lpExt);

    TlsValue =  GetDword(GetExpr(TLS_SESSION));

    Status = GetTlsEntry(TlsValue, &pvSessionStart);

    if (Status != 0)
    {
        DebuggerOut("Could not get TLS %d for Thread\n", TlsValue);
        return;
    }

    if (pvSessionStart)
    {

        Status = LsaReadMemory(pvSessionStart, sizeof(Session), &Session);

        LsaReadMemory( Session.SharedData, sizeof( SharedData ), &SharedData );

        Session.SharedData = &SharedData ;

        ShowSession(pvSessionStart, &Session);

    }
    else
    {
        DebuggerOut("TLS entry was NULL!\n");

    }


    return;
}

void
DumpPackage(        HANDLE                  hProcess,
                    HANDLE                  hThread,
                    DWORD                   dwCurrentPc,
                    PNTSD_EXTENSION_APIS    lpExt,
                    LPSTR                   pszCommand)
{
    PVOID           pvSPC = NULL;
    PVOID           pSPC;
    PLSAP_SECURITY_PACKAGE  pControl;
    UINT_PTR        dwExpr;
    PVOID           pcPackage;
    DWORD           cPackages;
    DWORD           cb;
    DWORD           fDump;
    BOOLEAN         fDumpAll;
    BOOLEAN         fDumpSingle;
    UINT_PTR        Index;
    LSAP_SECURITY_PACKAGE   Package;
    PLSAP_SECURITY_PACKAGE * pPackageList ;

    InitDebugHelp(hProcess, hThread, lpExt);

    fDump = 0;
    dwExpr = 0;
    fDumpAll = FALSE;
    fDumpSingle = FALSE;
    pSPC = NULL;
    Index = 0;

    pcPackage = GetExpr(PACKAGE_COUNT);
    LsaReadMemory(pcPackage, sizeof(DWORD), &cPackages);
    DebuggerOut("  There are %d package in the system\n", cPackages);

    if (pszCommand && *pszCommand != '\0' )
    {
        DebuggerOut("Processing '%s'\n", pszCommand);

        while (*pszCommand)
        {
            while (*pszCommand == ' ')
            {
                pszCommand++;
            }

            if (*pszCommand == '-')
            {
                pszCommand++;
                switch (*pszCommand)
                {
                    case 'V':
                    case 'v':
                        fDump |= PACKAGE_VERBOSE;
                        break;
                    case 'B':
                    case 'b':
                        fDump |= PACKAGE_NOISY;
                        break;
                    case 'a':
                    case 'A':
                        fDumpAll = TRUE;
                        break;
                    default:
                        DebuggerOut("Invalid switch '%c'\n", *pszCommand);
                        break;
                }
                pszCommand++;
                continue;
            }

            dwExpr = (UINT_PTR) GetExpr(pszCommand);
            fDumpAll = FALSE;
            if (dwExpr < cPackages)
            {
                Index = dwExpr;
                fDumpSingle = TRUE;
            }
            else if (dwExpr < 0x00010000)
            {
                DebuggerOut("Invalid package ID (%d)\n", dwExpr);
                return;
            } else
                pSPC = (PVOID) dwExpr;

            while (*pszCommand && *pszCommand != ' ')
            {
                pszCommand++;
            }
        }

    }
    else
    {
        fDumpAll = TRUE;
    }

    if (pSPC == NULL)
    {
        pvSPC = GetExpr(PACKAGE_LIST);

        LsaReadMemory(pvSPC, sizeof(PVOID), &pSPC);

    }
    DebuggerOut("  Package table pointer is at %p, address is %p\n", pvSPC, pSPC);

    pPackageList = (PLSAP_SECURITY_PACKAGE *) AllocHeap( sizeof(PVOID) * cPackages );

    if ( pPackageList )
    {
        LsaReadMemory( pSPC, sizeof(PVOID) * cPackages, pPackageList );

    }
    else
    {
        DebuggerOut("Out of memory\n");
        return;
    }


    if (fDumpSingle)
    {

        LsaReadMemory( pPackageList[ Index ], sizeof( LSAP_SECURITY_PACKAGE ), &Package );

        ShowPackageControl( pPackageList[ Index ],
                            &Package,
                            fDump | PACKAGE_TITLE );

    }
    else
    {
       for ( Index = 0 ; Index < cPackages ; Index++ )
       {
          LsaReadMemory( pPackageList[ Index ], sizeof( LSAP_SECURITY_PACKAGE ), &Package );

          ShowPackageControl( pPackageList[ Index ], &Package, fDump );
       }
    }

    FreeHeap( pPackageList );

}


BOOL
ShowScavItem(
    PVOID Base,
    PLSAP_SCAVENGER_ITEM Item
    )
{
    ULONG_PTR Disp ;
    UCHAR Symbol[ MAX_PATH ];
    DWORD Handle ;
    PVOID HandleTable ;

    if ( (Item->ScavCheck != SCAVMAGIC_ACTIVE) &&
         (Item->ScavCheck != SCAVMAGIC_FREE) )
    {
        DebuggerOut("Invalid scavenger item (check value not matched)\n");
        return FALSE ;
    }

    DebuggerOut( "LSAP_SCAVENGER_ITEM at %#x\n", Base );

    LsaGetSymbol((ULONG_PTR)Item->Function, Symbol, &Disp);

    DebuggerOut( "  Function        \t%s\n", Symbol );
    DebuggerOut( "  Parameter       \t%p\n", Item->Parameter );

    DisplayFlags(Item->Flags, 32, ScavFlags, (PUCHAR) Symbol );
    DebuggerOut( "  Flags           \t%x:%s\n", Item->Flags, Symbol );
    DebuggerOut( "  PackageId       \t%d\n", Item->PackageId );
    if ( Item->TimerHandle )
    {
        DebuggerOut( "  TimerHandle     \t%x\n", Item->TimerHandle );
    }

    switch ( Item->Type )
    {
        case NOTIFIER_TYPE_INTERVAL:
            DebuggerOut( "  Type            \tInterval\n" );
            break;

        case NOTIFIER_TYPE_HANDLE_WAIT:
            DebuggerOut( "  Type            \tHandle Wait\n");
            break;

        case NOTIFIER_TYPE_NOTIFY_EVENT:
            DebuggerOut( "  Type            \tNotify Event\n" );
            DebuggerOut( "  Class           \t%x\n", Item->Class );
            break;

        default:
            DebuggerOut( "  Type            \tUNKNOWN\n" );
            break;

    }

    return TRUE ;
}

void
DumpScavList(   HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{
    LSAP_SCAVENGER_ITEM Item ;
    PVOID ListAddress ;
    LIST_ENTRY List ;
    PLIST_ENTRY Scan ;
    UINT_PTR index = 0 ;
    BOOL DumpAll = FALSE ;
    DWORD max = 0 ;

    InitDebugHelp(hProcess, hThread, lpExt);

    if ( _strnicmp( pszCommand, "notify", 6 ) == 0 )
    {
        ListAddress = GetExpr( NOTIFYLIST );
    }
    else
    {
        ListAddress = GetExpr( SCAVLIST );
    }

    LsaReadMemory( ListAddress, sizeof( LIST_ENTRY ), &List );

    Scan = List.Flink ;

    while ( Scan != ListAddress )
    {
        LsaReadMemory( Scan, sizeof( LSAP_SCAVENGER_ITEM ), &Item );

        if ( !ShowScavItem( Scan, &Item ) )
        {
            break;

        }

        Scan = Item.List.Flink ;

        if (pExtApis->lpCheckControlCRoutine())
        {
            break;
        }
    }


}




void
PrintSid(   HANDLE      hProcess,
            HANDLE      hThread,
            PNTSD_EXTENSION_APIS    lpExt,
            PVOID       pvSid )
{
    SID Sid;
    PSID pSid;

    if (LsaReadMemory(pvSid, sizeof(SID), &Sid))
    {
        DebuggerOut("Could not read from %p\n", pvSid);
    }

    pSid = AllocHeap(RtlLengthRequiredSid(Sid.SubAuthorityCount));

    if (pSid == NULL)
    {
        DebuggerOut("Unable to allocate memory to print SID\n");
    }
    else
    {
        if (LsaReadMemory(pvSid, RtlLengthRequiredSid(Sid.SubAuthorityCount), pSid))
        {
            DebuggerOut("Could not read from %p\n", pvSid);
        }

        LocalDumpSid(pSid);
        DebuggerOut("\n");

        FreeHeap(pSid);
    }
}

void
DumpSid(    HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    PVOID   pvSid;

    InitDebugHelp(hProcess, hThread, lpExt);
    pvSid = GetExpr(pszCommand);

    PrintSid(hProcess, hThread, lpExt, pvSid );
}


void
DumpToken(  HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    DWORD   fDump = 0;
    HANDLE  hToken;
    HANDLE  hRemoteToken;

#define DUMP_HEX    1

    InitDebugHelp(hProcess, hThread, lpExt);

    while (*pszCommand == '-')
    {
        pszCommand++;
        if (*pszCommand == 'x')
        {
            fDump |= DUMP_HEX;
        }
        if (*pszCommand == 'a')
        {
            fDump |= 0x80;  // Dump SD
        }
        pszCommand++;
    }

    hRemoteToken = GetExpr(pszCommand);

    if (DuplicateHandle(hProcess,
                        hRemoteToken,
                        GetCurrentProcess(),
                        &hToken,
                        0, FALSE,
                        DUPLICATE_SAME_ACCESS) )
    {
        PrintToken(hToken, lpExt);

        CloseHandle(hToken);
    }
    else
    {
        DebuggerOut("Error %d duplicating token handle\n", GetLastError());
    }
}

void
DumpThreadToken(  HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    DWORD   fDump = 0;
    HANDLE  hToken;
    HANDLE  hRemoteToken = NULL;
    PVOID   pad;
    NTSTATUS Status;

#define DUMP_HEX    1

    InitDebugHelp(hProcess, hThread, lpExt);

    while (*pszCommand == '-')
    {
        pszCommand++;
        if (*pszCommand == 'x')
        {
            fDump |= DUMP_HEX;
        }
        if (*pszCommand == 'a')
        {
            fDump |= 0x80;  // Dump SD
        }
        pszCommand++;
    }

    Status = NtOpenThreadToken(hThread, TOKEN_QUERY, FALSE, &hRemoteToken);

    if ((Status == STATUS_NO_TOKEN) || (hRemoteToken == NULL))
    {
        DebuggerOut("Thread is not impersonating.  Using process token.\n");

        Status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hRemoteToken);

    }

    hToken = hRemoteToken;

    if (NT_SUCCESS(Status))
    {
        PrintToken(hToken, lpExt);

        CloseHandle(hToken);
    }
    else
    {
        DebuggerOut("Error %#x getting thread token\n", Status);
    }
}




#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3

void
LocalDumpSid(PSID    pxSid)
{
    PISID   pSid = (PISID) pxSid;
    UNICODE_STRING  ucsSid;
#if 0
    if (fHex)
    {

        DebuggerOut("  S-%d-0x", pSid->Revision);
        for (i = 0;i < 6 ; i++ )
        {
            if (j)
            {
                DebuggerOut("%x", pSid->IdentifierAuthority.Value[i]);
            }
            else
            {
                if (pSid->IdentifierAuthority.Value[i])
                {
                    j = 1;
                    DebuggerOut("%x", pSid->IdentifierAuthority.Value[i]);
                }
            }
            if (i==4)
            {
                j = 1;
            }
        }
        for (i = 0; i < pSid->SubAuthorityCount ; i++ )
        {
            DebuggerOut("-0x%x", pSid->SubAuthority[i]);
        }
    }
    else
#endif // 0
    {
        RtlConvertSidToUnicodeString(&ucsSid, pxSid, TRUE);
        DebuggerOut("  %wZ", &ucsSid);
        RtlFreeUnicodeString(&ucsSid);
    }
}

void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    LocalDumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        DebuggerOut("\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            DebuggerOut("Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            DebuggerOut("Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            DebuggerOut("Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            DebuggerOut("Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            DebuggerOut("LogonId ");
        }
    }

}

WCHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        case SE_UNDOCK_PRIVILEGE:
            return(SE_UNDOCK_NAME);
        case SE_SYNC_AGENT_PRIVILEGE:
            return(SE_SYNC_AGENT_NAME);
        case SE_ENABLE_DELEGATION_PRIVILEGE:
            return(SE_ENABLE_DELEGATION_NAME);
        default:
            return(L"Unknown Privilege");
    }
}

void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{

    DebuggerOut("0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    DebuggerOut(" %-32ws", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        DebuggerOut("  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            DebuggerOut("Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            DebuggerOut("Default ");
        }
    }

}

void
PrintToken(HANDLE    hToken,
            PNTSD_EXTENSION_APIS    lpExt)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;
    DWORD               dwSessionId;

    pTUser = (PTOKEN_USER) alloca (256);
    pTGroups = (PTOKEN_GROUPS) alloca (4096);
    pTPrivs = (PTOKEN_PRIVILEGES) alloca (1024);
    pTPrimaryGroup  = (PTOKEN_PRIMARY_GROUP) alloca (128);

    if ( pTUser == NULL ||
         pTGroups == NULL ||
         pTPrivs == NULL ||
         pTPrimaryGroup == NULL ) {

        DebuggerOut( "Failed to allocate memory\n" );
        return;
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenSessionId,
                                        &dwSessionId,
                                        sizeof(dwSessionId),
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        DebuggerOut("Failed to query token:  %#x\n", status);
        return;
    }
    DebuggerOut("TS Session ID: %x\n", dwSessionId);

    status = NtQueryInformationToken(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        DebuggerOut("Failed to query token:  %#x\n", status);
        return;
    }

    DebuggerOut("User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    DebuggerOut("\nGroups");
    status = NtQueryInformationToken(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        DebuggerOut("\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    DebuggerOut("\nPrimary Group:\n  ");
    LocalDumpSid(pTPrimaryGroup->PrimaryGroup);

    DebuggerOut("\nPrivs\n");
    status = NtQueryInformationToken(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        1024,
                                        &cbRetInfo);
    if (!NT_SUCCESS(status))
    {
        printf("NtQueryInformationToken returned %#x\n", status);
        return;
    }
    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        DebuggerOut("\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    DebuggerOut("\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    DebuggerOut("Impersonation Level:  %s\n", ImpLevel(TStats.ImpersonationLevel));
    DebuggerOut("TokenType  %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
}

VOID
ElapsedTimeToString(
    PLARGE_INTEGER Time,
    CHAR * String
    )
{
    TIME_FIELDS     ElapsedTime ;


    RtlTimeToElapsedTimeFields( Time, &ElapsedTime );

    if ( ElapsedTime.Hour )
    {
        sprintf( String, "%d:%02d:%02d.%03d",
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Minute )
    {
        sprintf( String, "%02d:%02d.%03d",
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Second )
    {
        sprintf( String, "%02.%03d",
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Milliseconds )
    {
        sprintf( String, "0.%03d",
                 ElapsedTime.Milliseconds );
    }
    else
    {
        strcpy( String, "0" );
    }

}

void
DumpLpc(        HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{

    PVOID           pRemote;
    DWORD           i;
    PLSAP_API_LOG   pLog ;
    LSAP_API_LOG    LocalLog ;
    ULONG           Size ;
    FILETIME        LocalTime ;
    PLSAP_API_LOG_ENTRY Entry ;
    PVOID           Table ;
    CHAR            timebuf[ 128 ];
    CHAR            timebuf2[ 64 ];

    InitDebugHelp(hProcess, hThread, lpExt);

    if ( _stricmp( pszCommand, "internal" ) == 0 )
    {
        pRemote = GetExpr( INTERNAL_APILOG );
    }
    else
    {
        pRemote = GetExpr( LPC_APILOG );

    }

    LsaReadMemory( pRemote, sizeof( PVOID ), &Table );

    LsaReadMemory( Table, sizeof( LocalLog ), &LocalLog );

    Size = (LocalLog.TotalSize - 1) * sizeof( LSAP_API_LOG_ENTRY ) +
            sizeof( LSAP_API_LOG ) ;

    pLog = (PLSAP_API_LOG) LocalAlloc( LMEM_FIXED, Size );

    if ( !pLog )
    {
        DebuggerOut( "no memory\n" );
        return;
    }

    LsaReadMemory( Table, Size, pLog );


    DebuggerOut("MessageId\tStatus and Time\n");
    for (i = 0; i < pLog->TotalSize ; i++ )
    {
        Entry = &pLog->Entries[ i ];
        DebuggerOut("%08x%c\t", Entry->MessageId,
                        ( i == pLog->Current ? '*' : ' ') );

        if (Entry->ThreadId == 0)
        {
            CTimeStamp( (PTimeStamp) &Entry->QueueTime, timebuf, TRUE );
            DebuggerOut("Queued, Message @%p, Task @%p (%s)\n",
                            Entry->pvMessage,
                            Entry->WorkItem,
                            timebuf );

        }
        else if (Entry->ThreadId == 0xFFFFFFFF)
        {
            // CTimeStamp( (PTimeStamp) &Entry->QueueTime, timebuf, TRUE );
            timebuf[0] = '\0';

            ElapsedTimeToString( &Entry->WorkTime, timebuf2 );

            DebuggerOut("Completed, (%s, status %x), %s [%s]\n",
                            ApiLabel( (UINT_PTR) Entry->pvMessage ),
                            Entry->WorkItem,
                            timebuf,
                            timebuf2 );
        }
        else
        {
            CTimeStamp( (PTimeStamp) &Entry->WorkTime, timebuf, TRUE );
            DebuggerOut("Active, thread %x, Message @%p, %s\n",
                            Entry->ThreadId,
                            Entry->pvMessage,
                            timebuf );
        }

    }


}


VOID
ShowSecBuffer(
    PSTR    Banner,
    PSecBuffer  Buffer)
{
    DWORD   Mask;

    Mask = Buffer->BufferType & SECBUFFER_ATTRMASK ;

    DebuggerOut("%s\t", Banner);
    DebuggerOut("%s%s%s %d bytes, %p\n",
                    Mask & SECBUFFER_READONLY ? "[RO]" : "",
                    Mask & SECBUFFER_UNMAPPED ? "[!Map]" : "",
                    SecBufferType( Buffer->BufferType ),
                    Buffer->cbBuffer,
                    Buffer->pvBuffer );
}

VOID
ShowLpcMessage(
    PVOID pvMessage,
    PSPM_LPC_MESSAGE pMessage)
{
    SPMInitContextAPI * pInit;
    SPMAcceptContextAPI * pAccept;
    SPMDeleteContextAPI * pDelete ;
    SPMFreeCredHandleAPI * pFreeCred ;
    SPMAcquireCredsAPI * pAcquire;
    SPMCallbackAPI * pCallback ;
    SPMAddCredentialAPI * pAddCred ;
    SPMQueryCredAttributesAPI * pQueryCred ;
    SPMEfsGenerateKeyAPI * pGenKey ;
    SPMEfsGenerateDirEfsAPI * pGenDir ;
    SPMEfsDecryptFekAPI * pDecryptFek ;
    SPMGetBindingAPI * pGetBinding ;
    DWORD           i;
    UCHAR       Flags[ 80 ];

    DebuggerOut("SPM_LPC_MESSAGE at %p\n", pvMessage);
    DebuggerOut("  Message id   \t%x\n", pMessage->pmMessage.MessageId);
    DebuggerOut("  From         \t%x.%x\n", pMessage->pmMessage.ClientId.UniqueProcess,pMessage->pmMessage.ClientId.UniqueThread);
    DebuggerOut("  API Number   \t%d\n", pMessage->ApiMessage.dwAPI);
    DebuggerOut("  Result       \t%#x\n",pMessage->ApiMessage.scRet);
    DebuggerOut("  LSA Args     \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) ((PUCHAR) &pMessage->ApiMessage.Args) - ((PUCHAR) pMessage));
    DebuggerOut("  SPM Args     \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) ((PUCHAR) &pMessage->ApiMessage.Args.SpmArguments.API) - ((PUCHAR) pMessage));
    DebuggerOut("  Data         \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) (&pMessage->ApiMessage.bData[0]) - ((PUCHAR) pMessage));
    if ( pMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber)
    {
        Flags[0] = '\0';

        DisplayFlags( pMessage->ApiMessage.Args.SpmArguments.fAPI,
                      12,
                      APIFlags,
                      Flags );

        DebuggerOut("  Flags        \t%x: %s\n",
                    pMessage->ApiMessage.Args.SpmArguments.fAPI,
                    Flags );
        DebuggerOut("  Context      \t%p\n",
                    pMessage->ApiMessage.Args.SpmArguments.ContextPointer );
    }

    switch (pMessage->ApiMessage.dwAPI)
    {
        case LsapAuLookupPackageApi:
            DebuggerOut("  LsapAuLookupPackageApi\n");
            DebuggerOut("   (o) Number  \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.AuthenticationPackage);
            DebuggerOut("   (i) Length  \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.PackageNameLength);
            DebuggerOut("   (i) Name    \t%s\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.PackageName);
            break;

        case LsapAuLogonUserApi:
            DebuggerOut("  LsapAuLogonUserApi\n");
            DebuggerOut("   (i) Origin  \t{%d,%d,%p}\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.Length,
                                                        pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.MaximumLength,
                                                        pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.Buffer);
            DebuggerOut("   (i) LogonTyp\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonType);
            DebuggerOut("   (i) Package \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationPackage);
            DebuggerOut("   (i) AuthInfo\t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationInformation);
            DebuggerOut("   (i) AuthInfo\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationInformationLength);
            DebuggerOut("   (i) GroupCou\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LocalGroupsCount);
            DebuggerOut("   (i) Groups  \t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LocalGroups);
            DebuggerOut("   (i) Source  \t%s\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.SourceContext.SourceName);
            DebuggerOut("   (o) SubStat \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.SubStatus);
            DebuggerOut("   (o) Profile \t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.ProfileBuffer);
            DebuggerOut("   (o) ProfLen \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.ProfileBufferLength);
            DebuggerOut("   (o) LogonId \t%x:%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonId.HighPart,pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonId.LowPart);
            DebuggerOut("   (o) Token   \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.Token);
            DebuggerOut("   (o) Quota   \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.Quotas.PagedPoolLimit);
            break;

        case LsapAuCallPackageApi:
            DebuggerOut("   LsapCallPackageApi\n");
            DebuggerOut("    (i) Package\t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.AuthenticationPackage);
            DebuggerOut("    (i) Buffer \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolSubmitBuffer);
            DebuggerOut("    (i) Length \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.SubmitBufferLength);
            DebuggerOut("    (o) Status \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolStatus);
            DebuggerOut("    (o) RBuffer\t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolReturnBuffer);
            DebuggerOut("    (o) Length \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ReturnBufferLength);
            break;

        case LsapAuDeregisterLogonProcessApi:
            DebuggerOut("   LsapAuDeregisterLogonProcessApi\n");
            break;

        case SPMAPI_GetBinding:
            DebuggerOut("   GetBinding\n");
            pGetBinding = &pMessage->ApiMessage.Args.SpmArguments.API.GetBinding ;
            DebuggerOut("    (i) ulPackageId    \t%p\n", pGetBinding->ulPackageId) ;

            break;

        case SPMAPI_InitContext:
            DebuggerOut("   InitContext\n");
            pInit = &pMessage->ApiMessage.Args.SpmArguments.API.InitContext;
            DebuggerOut("    (i) hCredentials   \t%p:%p\n", pInit->hCredential.dwUpper, pInit->hCredential.dwLower);
            DebuggerOut("    (i) hContext       \t%p:%p\n", pInit->hContext.dwUpper, pInit->hContext.dwLower);
            DebuggerOut("    (i) ssTarget       \t%p\n", pInit->ssTarget.Buffer);
            DebuggerOut("    (i) fContextReq    \t%x\n", pInit->fContextReq);
            DebuggerOut("    (i) Reserved1      \t%x\n", pInit->dwReserved1);
            DebuggerOut("    (i) TargetDataRep  \t%x\n", pInit->TargetDataRep);
            DebuggerOut("    (i) sbdInput       \t%d : %p\n", pInit->sbdInput.cBuffers, pInit->sbdInput.pBuffers );
            DebuggerOut("    (i) Reserved2      \t%x\n", pInit->dwReserved2);
            DebuggerOut("    (o) hNewContext    \t%p:%p\n", pInit->hNewContext.dwUpper, pInit->hNewContext.dwLower );
            DebuggerOut("    (b) sbdOutput      \t%d : %p\n", pInit->sbdOutput.cBuffers, pInit->sbdOutput.pBuffers );
            DebuggerOut("    (o) fContextAttr   \t%x\n", pInit->fContextAttr );
            DebuggerOut("    (o) tsExpiry       \t%s\n","");
            DebuggerOut("    (o) MappedContext  \t%x\n", pInit->MappedContext );
            ShowSecBuffer("    (o) ContextData  \t", &pInit->ContextData );
            for ( i = 0 ; i < pInit->sbdInput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (i) InputBuffer\t", &pInit->sbData[i]);
            }
            for ( i = 0; i < pInit->sbdOutput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (b) OutputBuffer\t", &pInit->sbData[i + pInit->sbdInput.cBuffers]);
            }

            break;

        case SPMAPI_AcceptContext:
            DebuggerOut("   AcceptContext\n");
            pAccept = &pMessage->ApiMessage.Args.SpmArguments.API.AcceptContext;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n", pAccept->hCredential.dwUpper, pAccept->hCredential.dwLower );
            DebuggerOut("    (i) hContext       \t%p : %p\n", pAccept->hContext.dwUpper, pAccept->hContext.dwLower );
            DebuggerOut("    (i) sbdInput       \t%d : %p\n", pAccept->sbdInput.cBuffers, pAccept->sbdInput.pBuffers );
            DebuggerOut("    (i) fContextReq    \t%x\n", pAccept->fContextReq );
            DebuggerOut("    (i) TargetDataRep  \t%x\n", pAccept->TargetDataRep );
            DebuggerOut("    (o) hNewContext    \t%p : %p\n", pAccept->hNewContext.dwUpper, pAccept->hNewContext.dwLower );
            DebuggerOut("    (b) sbdOutput      \t%d : %p\n", pAccept->sbdOutput.cBuffers, pAccept->sbdOutput.pBuffers );
            DebuggerOut("    (o) fContextAttr   \t%x \n", pAccept->fContextAttr );
            DebuggerOut("    (o) MappedContext  \t%x\n", pAccept->MappedContext );
            ShowSecBuffer("    (o) ContextData  \t", &pAccept->ContextData );
            for ( i = 0 ; i < pAccept->sbdInput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (i) InputBuffer\t", &pAccept->sbData[i]);
            }
            for ( i = 0; i < pAccept->sbdOutput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (b) OutputBuffer\t", &pAccept->sbData[i + pAccept->sbdInput.cBuffers]);
            }
            break;

        case SPMAPI_FindPackage:
            DebuggerOut("  FindPackage\n");
            break;

        case SPMAPI_EnumPackages:
            DebuggerOut("  EnumPackages\n");
            break;

        case SPMAPI_AcquireCreds:
            DebuggerOut("   AcquireCreds\n");
            pAcquire = &pMessage->ApiMessage.Args.SpmArguments.API.AcquireCreds ;
            DebuggerOut("    (i) fCredentialUse \t%x\n", pAcquire->fCredentialUse );
            DebuggerOut("    (i) LogonId        \t%x : %x\n", pAcquire->LogonID.LowPart, pAcquire->LogonID.HighPart );
            DebuggerOut("    (i) pvAuthData     \t%p\n", pAcquire->pvAuthData );
            DebuggerOut("    (i) pvGetKeyFn     \t%p\n", pAcquire->pvGetKeyFn );
            DebuggerOut("    (i) ulGetKeyArgs   \t%p\n", pAcquire->ulGetKeyArgument );
            DebuggerOut("    (o) hCredentials   \t%p : %p\n", pAcquire->hCredential.dwUpper, pAcquire->hCredential.dwLower );
            break;

        case SPMAPI_EstablishCreds:
            DebuggerOut("  EstablishCreds\n");
            break;

        case SPMAPI_FreeCredHandle:
            DebuggerOut("  FreeCredHandle\n");
            pFreeCred = &pMessage->ApiMessage.Args.SpmArguments.API.FreeCredHandle ;
            DebuggerOut("    (i) hCredential    \t%p : %p\n", pFreeCred->hCredential.dwUpper, pFreeCred->hCredential.dwLower );
            break;

        case SPMAPI_ApplyToken:
            DebuggerOut("  ApplyToken\n");
            break;

        case SPMAPI_DeleteContext:
            DebuggerOut("  DeleteContext\n");
            pDelete = &pMessage->ApiMessage.Args.SpmArguments.API.DeleteContext ;
            DebuggerOut("    (i) hContext       \t%p : %p\n", pDelete->hContext.dwUpper, pDelete->hContext.dwLower );
            break;

        case SPMAPI_QueryPackage:
            DebuggerOut("  QueryPackage\n");
            break;

        case SPMAPI_GetUserInfo:
            DebuggerOut("  GetUserInfo\n");
            break;

        case SPMAPI_GetCreds:
            DebuggerOut("  GetCreds\n");
            break;

        case SPMAPI_SaveCreds:
            DebuggerOut("  SaveCreds\n");
            break;

        case SPMAPI_DeleteCreds:
            DebuggerOut("  DeleteCreds\n");
            break;

        case SPMAPI_QueryCredAttributes:
            DebuggerOut("  QueryCredAttributes\n");
            pQueryCred = &pMessage->ApiMessage.Args.SpmArguments.API.QueryCredAttributes ;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n", pQueryCred->hCredentials.dwUpper, pQueryCred->hCredentials.dwLower );
            DebuggerOut("    (i) ulAttribute    \t%d\n", pQueryCred->ulAttribute );
            DebuggerOut("    (i) pBuffer        \t%p\n", pQueryCred->pBuffer );
            DebuggerOut("    (o) Allocs         \t%d\n", pQueryCred->Allocs );
            for ( i = 0 ; i < pQueryCred->Allocs ; i++ )
            {
                DebuggerOut("    (o) Buffers[%d]    \t  %p\n", pQueryCred->Buffers[ i ] );
            }
            break;

        case SPMAPI_AddPackage:
            DebuggerOut("  AddPackage\n");
            break;

        case SPMAPI_DeletePackage:
            DebuggerOut("  DeletePackage\n");
            break;

        case SPMAPI_EfsGenerateKey:
            DebuggerOut("  EfsGenerateKey\n" );
            pGenKey = &pMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateKey ;
            DebuggerOut("    (i) EfsStream      \t%p\n", pGenKey->EfsStream );
            DebuggerOut("    (i) DirectoryEfsStream\t%p\n", pGenKey->DirectoryEfsStream);
            DebuggerOut("    (i) DirectoryStreamLen\t%#x\n", pGenKey->DirectoryEfsStreamLength );
            DebuggerOut("    (i) Fek            \t%p\n", pGenKey->Fek );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pGenKey->BufferLength );
            DebuggerOut("    (o) BufferBase     \t%p\n", pGenKey->BufferBase );
            break;

        case SPMAPI_EfsGenerateDirEfs:
            DebuggerOut("  EfsGenerateDirEfs\n" );
            pGenDir = &pMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateDirEfs ;
            DebuggerOut("    (i) DirectoryEfsStream\t%p\n", pGenDir->DirectoryEfsStream);
            DebuggerOut("    (i) DirectoryStreamLen\t%#x\n", pGenDir->DirectoryEfsStreamLength );
            DebuggerOut("    (i) EfsStream      \t%p\n", pGenDir->EfsStream );
            DebuggerOut("    (o) BufferBase     \t%p\n", pGenDir->BufferBase );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pGenDir->BufferLength );
            break;

        case SPMAPI_EfsDecryptFek:
            DebuggerOut("  EfsDecryptFek\n" );
            pDecryptFek = &pMessage->ApiMessage.Args.SpmArguments.API.EfsDecryptFek ;
            DebuggerOut("    (i) Fek            \t%p\n", pDecryptFek->Fek );
            DebuggerOut("    (i) EfsStream      \t%p\n", pDecryptFek->EfsStream );
            DebuggerOut("    (i) EfsStreamLength\t%p\n", pDecryptFek->EfsStreamLength );
            DebuggerOut("    (i) OpenType       \t%#x\n", pDecryptFek->OpenType );
            DebuggerOut("    (?) NewEfs         \t%p\n", pDecryptFek->NewEfs );
            DebuggerOut("    (o) BufferBase     \t%p\n", pDecryptFek->BufferBase );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pDecryptFek->BufferLength );
            break;

        case SPMAPI_EfsGenerateSessionKey:
            DebuggerOut("  EfsGenerateSessionKey\n" );
            break;

        case SPMAPI_Callback:
            DebuggerOut("  Callback\n" );
            pCallback = &pMessage->ApiMessage.Args.SpmArguments.API.Callback ;
            DebuggerOut("    (i) Type       \t%x\n", pCallback->Type );
            DebuggerOut("    (i) CallbackFunction\t%p\n", pCallback->CallbackFunction );
            DebuggerOut("    (i) Argument1  \t%p\n", pCallback->Argument1 );
            DebuggerOut("    (i) Argument2  \t%p\n", pCallback->Argument2 );
            ShowSecBuffer("    (i) Input      \t", &pCallback->Input );
            ShowSecBuffer("    (o) Output     \t", &pCallback->Output );

            break;

        case SPMAPI_QueryContextAttr:
            DebuggerOut("  QueryContextAttributes\n" );
            break;

        case SPMAPI_LsaPolicyChangeNotify:
            DebuggerOut("  LsaPolicyChangeNotify\n" );
            break;

        case SPMAPI_GetUserNameX:
            DebuggerOut("  GetUserName\n" );
            break;

        case SPMAPI_AddCredential:
            DebuggerOut("  AddCredential\n" );
            pAddCred = &pMessage->ApiMessage.Args.SpmArguments.API.AddCredential ;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n",
                                    pAddCred->hCredentials.dwUpper, pAddCred->hCredentials.dwLower );
            DebuggerOut("    (i) fCredentialUse \t%x\n", pAddCred->fCredentialUse );
            DebuggerOut("    (i) LogonId        \t%x : %x\n", pAddCred->LogonID.LowPart, pAddCred->LogonID.HighPart );
            DebuggerOut("    (i) pvAuthData     \t%p\n", pAddCred->pvAuthData );
            DebuggerOut("    (i) pvGetKeyFn     \t%p\n", pAddCred->pvGetKeyFn );
            DebuggerOut("    (i) ulGetKeyArgs   \t%p\n", pAddCred->ulGetKeyArgument );
            break;

        case SPMAPI_EnumLogonSession:
            DebuggerOut("  EnumLogonSession\n" );
            break;

        case SPMAPI_GetLogonSessionData:
            DebuggerOut("  GetLogonSessionData\n" );
            break;

        case SPMAPI_SetContextAttr:
            DebuggerOut("  SetContextAttr\n" );
            break;

        case SPMAPI_LookupAccountSidX:
            DebuggerOut("  LookupAccountSid\n");
            break;

        case SPMAPI_LookupAccountNameX:
            DebuggerOut("  LookupAccountName\n");
            break;

        default:
            DebuggerOut("No message parsing for this message\n");
            break;
    }
}

void
DumpLpcMessage( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    SPM_LPC_MESSAGE Message;
    PVOID           pvMessage;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvMessage = GetExpr(pszCommand);

    if (!pvMessage)
    {
        DebuggerOut("no message\n");
        return;
    }

    LsaReadMemory(pvMessage, sizeof(SPM_LPC_MESSAGE), &Message);

    ShowLpcMessage( pvMessage, &Message );

}


void
DumpThreadLpc(
        HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    SPM_LPC_MESSAGE Message;
    PVOID           pvMessage;
    NTSTATUS    Status;
    LSA_CALL_INFO CallInfo ;


    InitDebugHelp(hProcess, hThread, lpExt);

    Status = ReadCallInfo( &CallInfo );

    if (Status != 0)
    {
        return;
    }

    if ( CallInfo.Message )
    {
        Status = LsaReadMemory(CallInfo.Message, sizeof(SPM_LPC_MESSAGE), &Message);

        ShowLpcMessage(CallInfo.Message, &Message);

    }
    else
    {
        DebuggerOut("TLS entry was NULL!\n");

    }
}

extern"C"
void
GetTls( HANDLE           hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    TEB *   Teb;
    DWORD   Index;

    InitDebugHelp(hProcess, hThread, lpExt);

    Index = (DWORD)((ULONG_PTR)GetExpr(pszCommand));

    Teb = GetTeb(hThread);
    if (!Teb)
    {
        DebuggerOut("Could not read TEB\n");
    }
    else
    {
        DebuggerOut("TLS %#x is %p\n", Index, Teb->TlsSlots[Index]);

        FreeHeap(Teb);
    }

}

PVOID
ShowTask(
    PVOID       pTask)
{
    LSAP_THREAD_TASK  Task;
    UCHAR           Symbol[256];
    ULONG_PTR       Disp;

    if (pTask)
    {
        LsaReadMemory(pTask, sizeof(LSAP_THREAD_TASK), &Task);
    }
    else
    {
        return (NULL);
    }

    DebuggerOut("Task at %p:\n", pTask);
    LsaGetSymbol((ULONG_PTR)Task.pFunction, Symbol, &Disp);
    DebuggerOut("  Function     \t%s\n", Symbol);
    DebuggerOut("  Parameter    \t%p\n", Task.pvParameter);
    DebuggerOut("  Session      \t%p\n", Task.pSession);

    return(Task.Next.Flink);
}

void
DumpQueue( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    LSAP_TASK_QUEUE       Queue;
    PVOID           pTask;
    PVOID           pQueue;
    BOOL            Single = FALSE;
    UCHAR           Symbol[ MAX_PATH ];
    ULONG_PTR       Offset;

    InitDebugHelp(hProcess, hThread, lpExt);

    pQueue = GetExpr(pszCommand);

    if (!pQueue)
    {
        pQueue = (PVOID) GetExpr(GLOBALQUEUE);
    }

    LsaReadMemory(pQueue, sizeof(Queue), &Queue);

    DebuggerOut("Queue at %p\n", pQueue);
    DebuggerOut("  Type     \t%d : %s\n", Queue.Type, QueueTypeName( Queue.Type ) );
    DebuggerOut("  Semaphore\t%d\n", Queue.hSemaphore);
    DebuggerOut("  Tasks    \t%d\n", Queue.Tasks);
    DebuggerOut("  pTasks   \t%p %p\n", Queue.pTasks.Flink,
                                        Queue.pTasks.Blink);
    DebuggerOut("  pNext    \t%p\n", Queue.pNext);
    DebuggerOut("  pShared  \t%p\n", Queue.pShared);
    DebuggerOut("  TotalThd \t%d\n", Queue.TotalThreads);
    DebuggerOut("  IdleThd  \t%d\n", Queue.IdleThreads);
    if ( Queue.OwnerSession )
    {
    DebuggerOut("  Session  \t%p\n", Queue.OwnerSession );
    }
    LsaGetSymbol((ULONG_PTR) Queue.pOriginal, Symbol, &Offset );
    if ( Offset )
    {
        DebuggerOut("  Parent   \t%p\n", Queue.pOriginal );
    }
    else
    {
        DebuggerOut("  Parent   \t%s\n", Symbol );
    }
    DebuggerOut("  Tasks Queued\t%d\n", Queue.QueuedCounter);
    DebuggerOut("  Tasks Read\t%d\n", Queue.TaskCounter);
    DebuggerOut("  Tasks Missed\t%d\n", Queue.MissedTasks );
    DebuggerOut("  Tasks High Water\t%d\n", Queue.TaskHighWater );
    DebuggerOut("  StartSync\t%x\n", Queue.StartSync );
    DebuggerOut("  Req Thread\t%d\n", Queue.ReqThread );
    DebuggerOut("  Max Threads\t%d\n", Queue.MaxThreads );

    pTask = Queue.pTasks.Flink;

    while ((pTask != NULL) && (pTask != (PLSAP_THREAD_TASK) Queue.pTasks.Blink))
    {
        pTask = ShowTask(pTask);

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }
    }

}

void
DumpThreadTask( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    LSAP_THREAD_TASK      Task;
    PVOID           pTask;
    BOOL            Single = FALSE;

    InitDebugHelp(hProcess, hThread, lpExt);

    pTask = GetExpr(pszCommand);
    if (!pTask)
    {
        return;
    }
    else
    {
        Single = TRUE;
    }

    do
    {
        pTask = ShowTask( pTask );

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }

    } while ( pTask && !Single  );



}


VOID
ShowNegCreds(
    PNEG_CREDS  pCreds,
    PVOID       pOriginalAddr)
{
    DWORD   i;
    UCHAR Buffer[ MAX_PATH ];

    DebuggerOut("NEG_CREDS at %p\n", pOriginalAddr );

    DebuggerOut("  List         \t%p %p\n", pCreds->List.Flink, pCreds->List.Blink );
    DebuggerOut("  RefCount     \t%d\n", pCreds->RefCount );
    DebuggerOut("  Process      \t%x\n", pCreds->ClientProcessId );
    DebuggerOut("  LogonId      \t%x %x\n",
                    pCreds->ClientLogonId.HighPart, pCreds->ClientLogonId.LowPart );

    DisplayFlags( pCreds->Flags, 5, NegCredFlags, Buffer );
    DebuggerOut("  Flags        \t%x : %s\n", pCreds->Flags, Buffer );
    if ( pCreds->Flags & NEGCRED_MULTI )
    {
        DebuggerOut("  AdditionalCreds\t%p %p\n",
                        pCreds->AdditionalCreds.Flink, pCreds->AdditionalCreds.Blink );
    }

    DebuggerOut("  Count        \t%d\n", pCreds->Count );
    for ( i = 0 ; i < pCreds->Count ; i++ )
    {
        DebuggerOut("   Creds[%2d]   \tPackage %p, Handle %p : %p \n", i,
            pCreds->Creds[i].Package, pCreds->Creds[i].Handle.dwUpper,
            pCreds->Creds[i].Handle.dwLower );
    }
}

PVOID
ReadAndDumpNegCred(
    PVOID Address
    )
{
#define CRED_SIZE   (sizeof( NEG_CREDS ) + 16 * sizeof( NEG_CRED_HANDLE ) )

    UCHAR   Buffer[ CRED_SIZE ];
    PNEG_CREDS  pCreds ;
    DWORD   Size;



    LsaReadMemory( Address, sizeof( NEG_CREDS ), Buffer );

    pCreds = (PNEG_CREDS) Buffer ;

    Size = sizeof( NEG_CREDS ) + (pCreds->Count - 1) * sizeof( NEG_CRED_HANDLE );


    if ( Size <= CRED_SIZE )
    {
        LsaReadMemory( Address, Size, Buffer );
    }
    else
    {
        LsaReadMemory( Address, CRED_SIZE, Buffer );
        pCreds->Count = 16;
    }

    ShowNegCreds( pCreds, Address );

    return pCreds->List.Flink ;

}

VOID
DumpNegCred(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID Base ;
    PVOID Next ;
    PVOID p ;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    if ( p != 0 )
    {
        ReadAndDumpNegCred( p );
    }
    else
    {
        p = GetExpr( "lsasrv!NegCredList" );

        LsaReadMemory( p, sizeof(PVOID), &Next );

        while ( Next != p )
        {
            Next = ReadAndDumpNegCred( Next );

            if (lpExt->lpCheckControlCRoutine())
            {
                break;
            }
        }
    }

}




VOID
ShowNegContext(
    PNEG_CONTEXT    Context,
    PVOID           pOriginalAddr)
{
    UCHAR TimeBuf[ MAX_PATH ];

    if ( ( Context->CheckMark != NEGCONTEXT_CHECK ) &&
         ( Context->CheckMark != NEGCONTEXT2_CHECK ) )
    {
        DebuggerOut("****** Invalid Context Record *******\n");
        return;
    }

    DebuggerOut("NEG_CONTEXT at %p\n", pOriginalAddr);
    DebuggerOut("  Creds        \t%#x\n", Context->Creds );
    DebuggerOut("  CredIndex    \t%d\n", Context->CredIndex );
    DebuggerOut("  Handle       \t%p : %p\n", Context->Handle.dwUpper, Context->Handle.dwLower );
    DebuggerOut("  Target at    \t%p \n", Context->Target.Buffer );
    DebuggerOut("  Attributes   \t%x\n", Context->Attributes );
    ShowSecBuffer("  MappedBuffer ",&Context->MappedBuffer );
    DebuggerOut("  Mapped       \t%s\n", Context->Mapped ? "TRUE" : "FALSE");
    DebuggerOut("  CallCount    \t%d\n", Context->CallCount );
    DebuggerOut("  LastStatus   \t%x\n", Context->LastStatus );
    DebuggerOut("  Check        \t%p\n", Context->Check );
    DebuggerOut("  Buffer       \t%p\n", Context->Buffer );
    CTimeStamp( &Context->Expiry, (PCHAR)TimeBuf, FALSE );
    DebuggerOut("  Expiry       \t%s\n", TimeBuf );
    DisplayFlags( Context->Flags, 7, NegContextFlags, TimeBuf );
    DebuggerOut("  Flags        \t%x : %s\n", Context->Flags, TimeBuf );
    DebuggerOut("  Message      \t%p\n", Context->Message );
    DebuggerOut("  CurrentSize  \t%#x\n", Context->CurrentSize );
    DebuggerOut("  TotalSize    \t%#x\n", Context->TotalSize );
    DebuggerOut("  SupportedMechs\t%p\n", Context->SupportedMechs );
}

VOID
DumpNegContext(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{

    NEG_CONTEXT Context ;
    PVOID   p;


    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof( NEG_CONTEXT ), &Context );

    ShowNegContext( &Context, p );
}


VOID
DumpSecBuffer(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SecBuffer   Buf;
    PVOID       p;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof(SecBuffer), &Buf );

    ShowSecBuffer("Buffer\t", &Buf );

}

VOID
DumpSecBufferDesc(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SecBuffer   Buf[16];
    SecBufferDesc Desc;
    PVOID       p;
    ULONG   i;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof(SecBufferDesc), &Desc );

    LsaReadMemory( Desc.pBuffers, sizeof(SecBuffer) * min(Desc.cBuffers, 16), Buf);

    DebuggerOut("SecBufferDesc at %p\n", p);
    DebuggerOut(" ulVersion     \t%d\n", Desc.ulVersion );
    DebuggerOut(" pBuffers      \t%p\n", Desc.pBuffers );
    DebuggerOut(" cBuffers      \t%x\n", Desc.cBuffers );
    for (i = 0 ; i < min(Desc.cBuffers, 16) ; i++ )
    {
        ShowSecBuffer("  Buffer\t", &Buf[i] );
    }

}

VOID
DumpHandleList(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SEC_HANDLE_ENTRY List ;
    PVOID       p;
    ULONG   i;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    List.List.Flink = (PLIST_ENTRY) p;

    do
    {
        LsaReadMemory( List.List.Flink, sizeof( List ), &List );
        DebuggerOut("  Handle   %p : %p, Ref = %d, Context = %p \n",
                    List.Handle.dwLower,
                    List.Handle.dwUpper,
                    List.RefCount,
                    List.Context );

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }
    } while ( List.List.Flink != p );
}

VOID
ShowSmallTable(
    PSMALL_HANDLE_TABLE Table,
    LONG   Indent
    )
{
    UCHAR   Buffer[ 64 ];
    UCHAR   IndentString[ 80 ];
    ULONG_PTR i;

    for ( i = 0 ; i < ( DWORD )Indent; i++)
    {
        IndentString[ i ] = ' ';
    }
    IndentString[ Indent ] = '\0' ;

    DisplayFlags( Table->Flags, 3, ShtFlags, Buffer );
    DebuggerOut("%s  Flags  \t%x: %s\n", IndentString, Table->Flags, Buffer );
    DebuggerOut("%s  Count  \t%d\n", IndentString, Table->Count );
    DebuggerOut("%s  Pending\t%p\n", IndentString, Table->PendingHandle );
    DebuggerOut("%s  ListHead\t%p\n", IndentString, Table->List.Flink );

    if ( Table->DeleteCallback )
    {
        LsaGetSymbol((ULONG_PTR) Table->DeleteCallback, Buffer, &i );
        DebuggerOut( "%s  Callback\t%s\n", IndentString, Buffer );
    }

}

VOID
ShowLargeTable(
    int indent,
    PLARGE_HANDLE_TABLE Table
    )
{
    LARGE_HANDLE_TABLE  SubTable ;
    UCHAR Buffer[ 64 ];
    UCHAR Indent[ 64 ];
    ULONG_PTR i;

    for (i = 0 ; i < ( ULONG )indent ; i++ )
    {
        Indent[i] = ' ';
    }
    Indent[indent] = '\0';

    DisplayFlags( Table->Flags, 3, LhtFlags, Buffer );
    DebuggerOut("%s  Flags    \t%x: %s\n", Indent, Table->Flags, Buffer );
    DebuggerOut("%s  Depth    \t%d\n", Indent, Table->Depth );
    DebuggerOut("%s  Parent   \t%p\n", Indent, Table->Parent );
    DebuggerOut("%s  Count    \t%d\n", Indent, Table->Count );
    if ( Table->DeleteCallback )
    {
        LsaGetSymbol((ULONG_PTR) Table->DeleteCallback, Buffer, &i );
        DebuggerOut("%s  Callback \t%s\n", Indent, Buffer );
    }
    DebuggerOut("%s  Lists\n", Indent );
    for ( i = 0 ; i < HANDLE_TABLE_SIZE ; i++ )
    {
        if ( Table->Lists[i].Flags & LHT_SUB_TABLE )
        {
            if ( Table->Lists[i].Flags & (~LHT_SUB_TABLE))
            {
                DebuggerOut("%s    CORRUPT\n", Indent);
            }
            else
            {
                DebuggerOut("%s    %x : Sub Table at %p\n", Indent, i, Table->Lists[i].List.Flink );
                LsaReadMemory( Table->Lists[i].List.Flink,
                            sizeof( LARGE_HANDLE_TABLE),
                            &SubTable );

                ShowLargeTable( 4+indent, &SubTable );

            }

        }
        else
        {
            DebuggerOut("%s    List %x\n", Indent, i );
            ShowSmallTable( &Table->Lists[i], 4+indent );
        }

    }

}


VOID
DumpHandleTable(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    DWORD   Tag;
    LARGE_HANDLE_TABLE  Large ;
    SMALL_HANDLE_TABLE  Small ;
    PVOID   Table ;

    InitDebugHelp(hProcess, hThread, lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL )
    {
        return;
    }

    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        DebuggerOut("LARGE_HANDLE_TABLE at %p\n", Table );

        LsaReadMemory( Table, sizeof( Large ), &Large );

        ShowLargeTable( 0, &Large );

    }
    else if ( Tag == SHT_TAG )
    {
        DebuggerOut("SMALL_HANDLE_TABLE at %p\n", Table );

        LsaReadMemory( Table, sizeof( Small ), &Small );

        ShowSmallTable( &Small, 0 );
    }
    else
    {
        DebuggerOut("%p - not a handle table\n", Table );
    }
}


VOID
ShowLogonSession(
    PVOID Base,
    PLSAP_LOGON_SESSION LogonSession,
    BOOL Verbose
    )
{
    SECURITY_STRING LocalString = { 0 };
    PWSTR Temp ;
    SECURITY_STRING LocalCopy = { 0 };
    CHAR Buffer[ 80 ];

    DebuggerOut( "LSAP_LOGON_SESSION at %p\n", Base );

    MapString( &LogonSession->AuthorityName, &LocalString );

    Temp = LocalString.Buffer ;
    LocalString.Buffer = NULL ;

    MapString( &LogonSession->AccountName, &LocalString );

    DebuggerOut( "  LogonId %x:%x (%s)  %ws \\ %ws \n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.LowPart,
            LogonTypeName( LogonSession->LogonType),
            Temp, LocalString.Buffer );

    FreeHeap( Temp );
    FreeHeap( LocalString.Buffer );

    if ( Verbose )
    {
        DebuggerOut( "  Package %d,  caller <%x>, attr = %x\n",
                LogonSession->CreatingPackage,
                LogonSession->Process,
                LogonSession->ContextAttr );

        DebuggerOut( "  SID\t" );
        LocalDumpSid( LogonSession->UserSid );
        CTimeStamp( &LogonSession->LogonTime, Buffer, TRUE );
        DebuggerOut( "  Logon Time\t%s\n", Buffer );


    }

}

VOID
DumpLogonSession(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID p, p1;
    PVOID Actual ;
    PSTR Colon ;
    LSAP_LOGON_SESSION LogonSession ;
    LUID Luid ;
    BOOLEAN DumpAll;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Colon = strchr( pszCommand, ':' );

    if ( Colon )
    {
        if (2 != sscanf( pszCommand, "%x:%x", &Luid.HighPart, &Luid.LowPart ))
        {
            DebuggerOut( "Invalid argument: '%s'\n", pszCommand );
        }

        DumpAll = TRUE ;
        p = NULL ;
    }
    else
    {
        Luid.HighPart = Luid.LowPart = 0 ;
        p = GetExpr( pszCommand );
        DumpAll = FALSE ;
    }

    if ( p == NULL )
    {
        p1 = GetExpr( "lsasrv!logonsessionlist" );
        LsaReadMemory( p1, sizeof( PVOID ), &p );
        DumpAll = TRUE ;
    }
    else
    {
        p1 = NULL ;
    }

    if ( p == NULL )
    {
        DebuggerOut( "Unable to get value of lsasrv!logonsessionlist\n" );
        return;
    }

    while ( p != p1 )
    {
        if ( DumpAll )
        {
            Actual = CONTAINING_RECORD( p, LSAP_LOGON_SESSION, List );
        }
        else
        {
            Actual = p ;
        }

        LsaReadMemory( Actual, sizeof( LSAP_LOGON_SESSION ), &LogonSession );

        if ( RtlIsZeroLuid( &Luid) ||
             RtlEqualLuid( &Luid, &LogonSession.LogonId) ||
             (!DumpAll) )
        {
            ShowLogonSession( Actual, &LogonSession, (!DumpAll) );

        }
        p = LogonSession.List.Flink ;

        if ( (!DumpAll) || ( p1 == NULL ) )
        {
            break;
        }
    }




}


void
ShowLsaHandle(
    IN LSAP_DB_HANDLE DbHandle,
    IN BOOLEAN Index
    )
{
    SECURITY_STRING LocalString;
#ifdef DBG
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    NTSTATUS Status;
#endif


    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Next          \t0x%lp\n", DbHandle->Next );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Previous      \t0x%lp\n", DbHandle->Previous );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserHandleList Flink      \t0x%lp\n", DbHandle->UserHandleList.Flink );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserHandleList Blink      \t0x%lp\n", DbHandle->UserHandleList.Blink );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Allocated     \t%s\n", DbHandle->Allocated ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ReferenceCount\t%lu\n", DbHandle->ReferenceCount );
    DebuggerOut( "%c", Index ? '\t' : '\0' );

    LocalString.Buffer = NULL;
    MapString( ( PSECURITY_STRING )( &DbHandle->LogicalNameU ),
                &LocalString );
    DebuggerOut( "LogicalNameU  \t%ws\n", LocalString.Buffer );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    FreeHeap( LocalString.Buffer );

    LocalString.Buffer = NULL;
    MapString( ( PSECURITY_STRING )( &DbHandle->PhysicalNameU ),
                &LocalString );
    DebuggerOut( "PhysicalNameU \t%ws\n", LocalString.Buffer );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    FreeHeap( LocalString.Buffer );

    if ( DbHandle->Sid ) {

        DebuggerOut( "Sid       \t" );
        LocalDumpSid( DbHandle->Sid );
        DebuggerOut( "\n" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );

    } else {

        DebuggerOut( "Sid           \t%s\n", "<NULL>" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );
    }

    DebuggerOut( "KeyHandle     \t0x%lx\n", DbHandle->KeyHandle );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ObjectTypeId  \t0x%lu\n", DbHandle->ObjectTypeId );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ContainerHandle\t0x%lp\n", DbHandle->ContainerHandle );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "DesiredAccess \t0x%08lx\n", DbHandle->DesiredAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "GrantedAccess \t0x%08lx\n", DbHandle->GrantedAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "RequestAccess \t0x%08lx\n", DbHandle->RequestedAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "GenerateOnClose\t%s\n",DbHandle->GenerateOnClose ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Trusted       \t%s\n", DbHandle->Trusted ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "DeletedObject \t%s\n", DbHandle->DeletedObject ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "NetworkClient \t%s\n",DbHandle->NetworkClient ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Options       \t0x%08lx\n", DbHandle->Options);
    DebuggerOut( "%c", Index ? '\t' : '\0' );

    if ( DbHandle->PhysicalNameDs.Length == 0 ) {

        DebuggerOut( "PhysicalNameDs\t%s\n", "<NULL>" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );

    } else {

        LocalString.Buffer = NULL;
        MapString( ( PSECURITY_STRING )( &DbHandle->PhysicalNameDs ),
                    &LocalString );

        DebuggerOut( "PhysicalNameDs\t%ws\n", LocalString.Buffer );
        DebuggerOut( "%c", Index ? '\t' : '\0' );
        FreeHeap( LocalString.Buffer );
    }

    DebuggerOut( "fWriteDs      \t%s\n", DbHandle->fWriteDs ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ObjectOptions \t0x%08lx\n", DbHandle->ObjectOptions );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserEntry \t0x%lp\n", DbHandle->UserEntry );
#ifdef DBG

    Status = RtlSystemTimeToLocalTime( &DbHandle->HandleCreateTime, &LocalTime );
    if ( !NT_SUCCESS( Status ) ) {

        DebuggerOut( "Can't convert create time from GMT to Local time: 0x%lx\n", Status );

    } else {

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DebuggerOut( "%c", Index ? '\t' : '\0' );
        DebuggerOut( "HandleCreateTime \t%ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                     TimeFields.Month,
                     TimeFields.Day,
                     TimeFields.Year,
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     DbHandle->HandleCreateTime.LowPart,
                     DbHandle->HandleCreateTime.HighPart );
    }

    Status = RtlSystemTimeToLocalTime( &DbHandle->HandleLastAccessTime, &LocalTime );
    if ( !NT_SUCCESS( Status ) ) {

        DebuggerOut( "Can't convert LastAccess time from GMT to Local time: 0x%lx\n", Status );

    } else {

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DebuggerOut( "%c", Index ? '\t' : '\0' );
        DebuggerOut( "HandleLastAccessTime \t%ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                     TimeFields.Month,
                     TimeFields.Day,
                     TimeFields.Year,
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     DbHandle->HandleLastAccessTime.LowPart,
                     DbHandle->HandleLastAccessTime.HighPart );
    }
#endif
}

VOID
DumpLsaHandle(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    _LSAP_DB_HANDLE DbHandle;
    PVOID Handle;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Handle = GetExpr( pszCommand );

    if ( Handle == NULL ) {

        return;
    }

    LsaReadMemory( Handle,
                sizeof( _LSAP_DB_HANDLE ),
                &DbHandle );

    ShowLsaHandle( &DbHandle, FALSE );
}


void
ShowLsaHandleTable(
    IN LSAP_DB_HANDLE HandleTable
    )
{
    _LSAP_DB_HANDLE ThisHandle, *Stop;
    ULONG i = 0;

    LsaReadMemory( HandleTable->Next,
                sizeof( _LSAP_DB_HANDLE ),
                &ThisHandle );
    Stop = ThisHandle.Previous;

    while ( ThisHandle.Next != Stop ) {

        DebuggerOut( "LsaHandleTable entry %lu\n", i++ );
        ShowLsaHandle( &ThisHandle, TRUE );

        LsaReadMemory( ThisHandle.Next,
                    sizeof( _LSAP_DB_HANDLE ),
                    &ThisHandle );
    }

    return;
}

VOID
DumpLsaHandleTable(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    _LSAP_DB_HANDLE HandleTable;
    PVOID Table;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL ) {

        return;
    }

    LsaReadMemory( Table,
                sizeof( _LSAP_DB_HANDLE ),
                &HandleTable );

    ShowLsaHandleTable( &HandleTable );
}


VOID
DumpLsaSidCache(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{

    PVOID RawAddress;
    PVOID pEntry;
    LSAP_DB_SID_CACHE_ENTRY Entry;
    NTSTATUS Status;

    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;

    UNICODE_STRING Dummy;
    WCHAR NameBuffer[256];

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pEntry = GetExpr( pszCommand );

    if ( pEntry == NULL ) {
        //
        // Find the address of the sid cache
        //
        RawAddress = (VOID *) GetExpr("lsasrv!LsapSidCache");

        if ( NULL == RawAddress ) {

           DebuggerOut( "Can't locate the variable lsasrv!SidCache\nPlease get correct symbols or update this debugger extension\n" );

           return;
        }

        pEntry = RawAddress;

        (VOID) LsaReadMemory( RawAddress, sizeof(pEntry), (PVOID) &pEntry );

        if ( NULL == pEntry ) {

            DebuggerOut( "Sid cache is empty!\n" );

            return;

        }
    } else {

        RtlZeroMemory( &Entry, sizeof( Entry ) );
        (VOID) LsaReadMemory( pEntry, sizeof(Entry), (PVOID) &Entry );
        pEntry = Entry.Next;

    }

    //
    // The first is the head and as such is empty
    //
    DebuggerOut( "Head of list located at address 0x%p\n", pEntry );

    if ( !pEntry ) {
        DebuggerOut( "Sid cache is empty!\n" );

        return;
    }

    while ( pEntry ) {

        //
        // Read the entry
        //
        RtlZeroMemory( &Entry, sizeof( Entry ) );
        (VOID) LsaReadMemory( pEntry, sizeof(Entry), (PVOID) &Entry );

        //
        // Print the entry
        //
        DebuggerOut( "New entry located at address 0x%p, next entry 0x%p\n", pEntry, Entry.Next );

        if ( Entry.AccountName.Buffer ) {

            RtlZeroMemory( NameBuffer, sizeof(NameBuffer) );
            (VOID) LsaReadMemory( Entry.AccountName.Buffer,
                               Entry.AccountName.MaximumLength,
                               (PVOID) NameBuffer );

            RtlInitUnicodeString( &Dummy, NameBuffer );

            DebuggerOut( "Account Name:   %wZ\n", &Dummy );

        } else {

            DebuggerOut( "No Account Name\n" );
        }

        if ( Entry.Sid ) {

            DebuggerOut( "Account Sid:  " );

            PrintSid( hProcess,
                      hThread,
                      lpExt,
                      Entry.Sid );

        } else {

            DebuggerOut( "No Account Sid\n" );

        }

        if ( Entry.DomainName.Buffer ) {

            RtlZeroMemory( NameBuffer, sizeof(NameBuffer) );
            (VOID) LsaReadMemory( Entry.DomainName.Buffer,
                               Entry.DomainName.MaximumLength,
                               (PVOID) NameBuffer );

            RtlInitUnicodeString( &Dummy, NameBuffer );

            DebuggerOut( "Domain Name:    %wZ\n", &Dummy );

        } else {

            DebuggerOut( "No Domain Name\n" );
        }

        if ( Entry.DomainSid ) {

            DebuggerOut( "Domain Sid:   " );

            PrintSid( hProcess,
                      hThread,
                      lpExt,
                      Entry.DomainSid );

        }

            DebuggerOut( "Sid Type:       %s\n", SidNameUseXLate( Entry.SidType ) );

        Status = RtlSystemTimeToLocalTime( &Entry.CreateTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert create time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Create Time     %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.CreateTime.LowPart,
                         Entry.CreateTime.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.RefreshTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Refresh Time    %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.LastUse.LowPart,
                         Entry.LastUse.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.ExpirationTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert expiration time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Expiration Time %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.ExpirationTime.LowPart,
                         Entry.ExpirationTime.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.LastUse, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Last Used       %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.LastUse.LowPart,
                         Entry.LastUse.HighPart );
        }

        DebuggerOut( "Flags: %d\n", Entry.Flags );

        DebuggerOut( "\n" );

        //
        // Get the next entry
        //
        pEntry = Entry.Next;

    }  // while

    return;

}


void
DumpLsaHandleTypeList(
    IN PLIST_ENTRY ListEntry
    )
{
    PLIST_ENTRY Next, Read;
    _LSAP_DB_HANDLE Handle, *HandlePtr;
    ULONG i = 0;

    Next = ListEntry->Flink;

    while ( Next != ListEntry ) {

        HandlePtr = CONTAINING_RECORD( Next,
                                       struct _LSAP_DB_HANDLE,
                                       Next );

        LsaReadMemory( HandlePtr,
                    sizeof( _LSAP_DB_HANDLE ),
                    &Handle );
        DebuggerOut( "Handle entry %lu\n", i++);
        ShowLsaHandle( &Handle, TRUE );

        Next = HandlePtr->UserHandleList.Flink;
    }


}
void
ShowLsaHandleTableEx(
    IN PLSAP_DB_HANDLE_TABLE HandleTable
    )
{
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    LSAP_DB_HANDLE_TABLE_USER_ENTRY ThisUserEntry;
    ULONG i = 0;

    HandleEntry = HandleTable->UserHandleList.Flink;
    for ( i = 0; i < HandleTable->UserCount; i++ ) {

        CurrentUserEntry = CONTAINING_RECORD( HandleEntry,
                                              LSAP_DB_HANDLE_TABLE_USER_ENTRY,
                                              Next );

        LsaReadMemory( CurrentUserEntry,
                    sizeof( LSAP_DB_HANDLE_TABLE_USER_ENTRY ),
                    &ThisUserEntry );

        DebuggerOut( "HandleTable Entry #%lu\n", i );
        DebuggerOut( "User id %x:%x\n",
                     ThisUserEntry.LogonId.HighPart,
                     ThisUserEntry.LogonId.LowPart);

#if DBG
        DebuggerOut( "UserToken 0x%lx\n", ThisUserEntry.UserToken );
#endif
        DebuggerOut( "Policy Handle List:\n" );
        DumpLsaHandleTypeList( &ThisUserEntry.PolicyHandles );

        DebuggerOut( "Object Handle List:\n" );
        DumpLsaHandleTypeList( &ThisUserEntry.ObjectHandles );

        HandleEntry = &ThisUserEntry.Next;
    }

}


VOID
DumpLsaHandleTableEx(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    LSAP_DB_HANDLE_TABLE HandleTableEx;
    PVOID Table;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL ) {

        return;
    }

    LsaReadMemory( Table,
                sizeof( LSAP_DB_HANDLE_TABLE ),
                &HandleTableEx );

    ShowLsaHandleTableEx( &HandleTableEx );
}


VOID
ShowTopLevelNameEntry(
    IN FTCache::TLN_ENTRY * EntryAddr,
    IN FTCache::TLN_ENTRY * EntryData
    )
{
    FTCache::TDO_ENTRY TdoEntry;
    FTCache::TLN_KEY TlnKey;
    SECURITY_STRING sLocal;

    DebuggerOut( "TopLevelNameEntry: %p\n", EntryAddr );
    DebuggerOut( "TdoListEntry: %p %p\n", EntryData->TdoListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "AvlListEntry: %p %p\n", EntryData->AvlListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "Excluded: %s\n", ( EntryData->Excluded ? "Yes" : "No" ));
    DebuggerOut( "Flags: %d\n", EntryData->m_Flags );

    if ( EntryData->Excluded ) {

        FTCache::TLN_ENTRY TlnEntry;

        LsaReadMemory(
            EntryData->SuperiorEntry,
            sizeof( FTCache::TLN_ENTRY ),
            &TlnEntry
            );

        LsaReadMemory(
            TlnEntry.TlnKey,
            sizeof( FTCache::TLN_KEY ),
            &TlnKey
            );

        sLocal.Buffer = NULL;
        MapString( &TlnKey.TopLevelName, &sLocal );
        DebuggerOut( "SuperiorEntry: %p (%ws)\n", EntryData->SuperiorEntry, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else if ( EntryData->SubordinateEntry ) {

        FTCache::TLN_ENTRY TlnEntry;

        LsaReadMemory(
            EntryData->SubordinateEntry,
            sizeof( FTCache::TLN_ENTRY ),
            &TlnEntry
            );

        LsaReadMemory(
            TlnEntry.TlnKey,
            sizeof( FTCache::TLN_KEY ),
            &TlnKey
            );

        sLocal.Buffer = NULL;
        MapString( &TlnKey.TopLevelName, &sLocal );
        DebuggerOut( "SubordinateEntry: %p (%ws)\n", EntryData->SubordinateEntry, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else {

        DebuggerOut( "SubordinateEntry: NULL\n" );
    }

    LsaReadMemory(
        EntryData->TdoEntry,
        sizeof( FTCache::TDO_ENTRY ),
        &TdoEntry
        );

    sLocal.Buffer = NULL;
    MapString( &TdoEntry.TrustedDomainName, &sLocal );
    DebuggerOut( "TdoEntry: %p (%ws)\n", EntryData->TdoEntry, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    LsaReadMemory(
        EntryData->TlnKey,
        sizeof( FTCache::TLN_KEY ),
        &TlnKey
        );

    sLocal.Buffer = NULL;
    MapString( &TlnKey.TopLevelName, &sLocal );
    DebuggerOut( "TlnKey: %p (%ws)\n", EntryData->TlnKey, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "\n" );
}

VOID
ShowDomainInfoEntry(
    IN FTCache::DOMAIN_INFO_ENTRY * EntryAddr,
    IN FTCache::DOMAIN_INFO_ENTRY * EntryData
    )
{
    FTCache::TDO_ENTRY TdoEntry;
    FTCache::TLN_ENTRY SubordinateTo;
    FTCache::TLN_KEY TlnKey;
    FTCache::DNS_NAME_KEY DnsKey;
    FTCache::NETBIOS_NAME_KEY NetbiosKey;
    SECURITY_STRING sLocal;

    DebuggerOut( "DomainInfoEntry: %p\n", EntryAddr );
    DebuggerOut( "TdoListEntry: %p %p", EntryData->TdoListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "SidAvlListEntry: %p\n", EntryData->SidAvlListEntry.Flink, EntryData->SidAvlListEntry.Blink );
    DebuggerOut( "DnsAvlListEntry: %p\n", EntryData->DnsAvlListEntry.Flink, EntryData->DnsAvlListEntry.Blink );
    DebuggerOut( "NetbiosAvlListEntry: %p\n", EntryData->NetbiosAvlListEntry.Flink, EntryData->NetbiosAvlListEntry.Blink );
    DebuggerOut( "Flags: %d\n", EntryData->m_Flags );
    DebuggerOut( "Time: %x-%x\n", EntryData->Time.HighPart, EntryData->Time.LowPart );
    DebuggerOut( "Sid: " );
    LocalDumpSid( EntryData->Sid );
    DebuggerOut( "\n" );

    LsaReadMemory(
        EntryData->TdoEntry,
        sizeof( FTCache::TDO_ENTRY ),
        &TdoEntry
        );

    sLocal.Buffer = NULL;
    MapString( &TdoEntry.TrustedDomainName, &sLocal );
    DebuggerOut( "TdoEntry: %p (%ws)\n", EntryData->TdoEntry, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    LsaReadMemory(
        EntryData->SubordinateTo,
        sizeof( FTCache::TLN_ENTRY ),
        &SubordinateTo
        );

    LsaReadMemory(
        SubordinateTo.TlnKey,
        sizeof( FTCache::TLN_KEY ),
        &TlnKey
        );

    sLocal.Buffer = NULL;
    MapString( &TlnKey.TopLevelName, &sLocal );
    DebuggerOut( "SubordinateTo: %p (%ws)\n", EntryData->SubordinateTo, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "SidKey: %p\n", EntryData->SidKey );

    LsaReadMemory(
        EntryData->SidKey,
        sizeof( FTCache::DNS_NAME_KEY ),
        &DnsKey
        );

    sLocal.Buffer = NULL;
    MapString( &DnsKey.DnsName, &sLocal );
    DebuggerOut( "DnsKey: %p (%ws)\n", EntryData->DnsKey, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    if ( EntryData->NetbiosKey ) {

        LsaReadMemory(
            EntryData->NetbiosKey,
            sizeof( FTCache::NETBIOS_NAME_KEY ),
            &NetbiosKey
            );

        sLocal.Buffer = NULL;
        MapString( &NetbiosKey.NetbiosName, &sLocal );
        DebuggerOut( "NetbiosKey: %p (%ws)\n", EntryData->NetbiosKey, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else {

        DebuggerOut( "NetbiosKey: NULL\n" );
    }

    DebuggerOut( "\n" );
}

VOID
ShowFtcTdoEntry(
    IN PVOID TdoEntryAddr,
    IN FTCache::TDO_ENTRY * TdoEntryData
    )
{
    ULONG Displayed;
    PUCHAR ListEnd;
    SECURITY_STRING sLocal;

    DebuggerOut( "<------------------->\n" );

    sLocal.Buffer = NULL;
    MapString( &TdoEntryData->TrustedDomainName, &sLocal );
    DebuggerOut( "TrustedDomainName: %ws\n", &TdoEntryData->TrustedDomainName, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "Record count: %lu\n\n", TdoEntryData->RecordCount );

    DebuggerOut( "\n===> Top Level Name Entries <===\n\n" );
    Displayed = 0;

    ListEnd = ( PUCHAR )TdoEntryAddr + FIELD_OFFSET( FTCache::TDO_ENTRY, TlnList );
    if ( TdoEntryData->TlnList.Flink == ( PLIST_ENTRY )ListEnd ) {

        DebuggerOut( "<none>\n" );

    } else {

        FTCache::TLN_ENTRY TlnEntryData;
        FTCache::TLN_ENTRY * TlnEntryAddr;

        TlnEntryAddr = FTCache::TLN_ENTRY::EntryFromTdoEntry( TdoEntryData->TlnList.Flink );

        do {

            LsaReadMemory(
                TlnEntryAddr,
                sizeof( FTCache::TLN_ENTRY ),
                &TlnEntryData
                );

            Displayed += 1;
            DebuggerOut( "Entry #%lu\n", Displayed );
            ShowTopLevelNameEntry( TlnEntryAddr, &TlnEntryData );

            TlnEntryAddr = FTCache::TLN_ENTRY::EntryFromTdoEntry( TlnEntryData.TdoListEntry.Flink );

        } while ( TlnEntryAddr != FTCache::TLN_ENTRY::EntryFromTdoEntry(( PLIST_ENTRY )ListEnd ));
    }

    DebuggerOut( "\n===> Domain Info Entries <===\n\n" );
    Displayed = 0;

    ListEnd = ( PUCHAR )TdoEntryAddr + FIELD_OFFSET( FTCache::TDO_ENTRY, DomainInfoList );
    if ( TdoEntryData->DomainInfoList.Flink == ( PLIST_ENTRY )ListEnd ) {

        DebuggerOut( "<none>\n" );

    } else {

        FTCache::DOMAIN_INFO_ENTRY DomainInfoData;
        FTCache::DOMAIN_INFO_ENTRY * DomainInfoAddr;

        DomainInfoAddr = FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry( TdoEntryData->DomainInfoList.Flink );

        do {

            LsaReadMemory(
                DomainInfoAddr,
                sizeof( FTCache::DOMAIN_INFO_ENTRY ),
                &DomainInfoData
                );

            Displayed += 1;
            DebuggerOut( "Entry #%lu\n", Displayed );
            ShowDomainInfoEntry( DomainInfoAddr, &DomainInfoData );

            DomainInfoAddr = FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry( DomainInfoData.TdoListEntry.Flink );

        } while ( DomainInfoAddr != FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry(( PLIST_ENTRY )ListEnd ));
    }

    return;
}


VOID
ShowForestTrustCache(
    IN FTCache * Ftc
    )
{
    DebuggerOut( "Forest Trust Cache si %s\n",
                 ( Ftc->m_Initialized ? "valid" : "invalid" ));

    DebuggerOut( "Forest Trust Cache is %s\n",
                 ( Ftc->m_Valid ? "valid" : "invalid" ));

    if ( !Ftc->m_Initialized || !Ftc->m_Valid ) {

        return;
    }

    return;
}


VOID
DumpFtcTdoEntry(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID TdoEntryAddr;
    FTCache::TDO_ENTRY TdoEntryData;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    TdoEntryAddr = GetExpr( pszCommand );

    if ( TdoEntryAddr == NULL ) {

        return;
    }

    LsaReadMemory( TdoEntryAddr,
                   sizeof( FTCache::TDO_ENTRY ),
                   &TdoEntryData );

    ShowFtcTdoEntry( TdoEntryAddr, &TdoEntryData );
}


VOID
DumpForestTrustCache(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    BYTE Ftc[sizeof(FTCache)];
    PVOID Cache;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Cache = GetExpr( pszCommand );

    if ( Cache == NULL ) {

        return;
    }

    LsaReadMemory( Cache,
                   sizeof( FTCache ),
                   &Ftc );

    ShowForestTrustCache( ( FTCache * )Ftc );
}


VOID
LocalPrintGuid(
    GUID *Guid
    )
{
    if ( Guid ) {

        DebuggerOut( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0],
                     Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4],
                     Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );

    }
}

VOID
ReadAndDumpSid(
    IN PVOID SidPtr
    )
{
    UNICODE_STRING StringSid;
    SID Sid;
    PSID ReadSid;

    LsaReadMemory( SidPtr, sizeof( SID ), &Sid );

    ReadSid = AllocHeap( RtlLengthRequiredSid( Sid.SubAuthorityCount ) );

    if ( ReadSid ) {

        LsaReadMemory( SidPtr, RtlLengthRequiredSid( Sid.SubAuthorityCount ), ReadSid );
        RtlConvertSidToUnicodeString( &StringSid, ReadSid, TRUE );
        DebuggerOut( "%wZ", &StringSid );
        RtlFreeUnicodeString( &StringSid );
        FreeHeap( ReadSid );
    }

}

VOID
ShowAcl(
    IN PVOID AclPtr
    )
{
    ULONG i, SkipSize;
    PVOID AcePtr;
    ACE_HEADER Ace;
    KNOWN_ACE KnownAce;
    KNOWN_OBJECT_ACE KnownObjectAce;
    PSID SidStart = NULL, ReadSid;
    SID Sid;
    UNICODE_STRING StringSid;
    GUID *DisplayGuid;
    ACL ReadAcl;
    PACL Acl = &ReadAcl;

    LsaReadMemory( AclPtr, sizeof( ACL ), &ReadAcl );

    DebuggerOut( "AclRevision %lu\n", ReadAcl.AclRevision );
    DebuggerOut( "Sbz1 %lu\n", ReadAcl.Sbz1 );
    DebuggerOut( "AclSize %lu\n", ReadAcl.AclSize );
    DebuggerOut( "AceCount %lu\n", ReadAcl.AceCount );
    DebuggerOut( "Sbz2 %lu\n", ReadAcl.Sbz2 );

    AcePtr = ( PUCHAR )AclPtr + sizeof( ACL );
    for ( i = 0; i < ReadAcl.AceCount; i++ ) {

        //
        // First, we need to read the Size/Type of the ace
        //
        LsaReadMemory( AcePtr, sizeof( ACE_HEADER ), &Ace );

        DebuggerOut( "Ace[ %lu ]\n", i );
        DebuggerOut( "\tAceType %lu\n", Ace.AceType );
        DebuggerOut( "\tAceFlags %lu\n", Ace.AceFlags );
        DebuggerOut( "\tAceSize %lu\n", Ace.AceSize );

        switch ( Ace.AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            LsaReadMemory( AcePtr, sizeof( KNOWN_ACE ), &KnownAce );
            DebuggerOut( "\tAccessMask 0x%lx\n", KnownAce.Mask );
            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_ACE ) - sizeof( ULONG ) );
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            SkipSize = sizeof( KNOWN_OBJECT_ACE );
            LsaReadMemory( AcePtr, sizeof( KNOWN_OBJECT_ACE ) + 2 * sizeof( GUID ), &KnownObjectAce );
            DebuggerOut( "\tAccessMask 0x%lx\n", KnownObjectAce.Mask );
            DisplayGuid = RtlObjectAceObjectType( &KnownObjectAce );
            if ( DisplayGuid ) {

                DebuggerOut( "\tObjectGuid ");
                LocalPrintGuid( DisplayGuid );
                DebuggerOut( "\n");
                SkipSize += sizeof( GUID );
            }

            DisplayGuid = RtlObjectAceInheritedObjectType( &KnownObjectAce );
            if ( DisplayGuid ) {

                DebuggerOut( "\tObjectGuid ");
                LocalPrintGuid( DisplayGuid );
                DebuggerOut( "\n");
                SkipSize += sizeof( GUID );
            }

            SidStart = ( PSID )( ( PUCHAR )AcePtr + SkipSize - sizeof( ULONG ) );
            break;


        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        default:
            DebuggerOut( "Unsupported AceType %lu encountered... skipping\n", Ace.AceType );
            break;
        }


        AcePtr = ( PUCHAR )AcePtr + Ace.AceSize;

        LsaReadMemory( SidStart, sizeof( SID ), &Sid );

        ReadSid = AllocHeap( RtlLengthRequiredSid( Sid.SubAuthorityCount ) );

        if ( ReadSid ) {

            LsaReadMemory( SidStart, RtlLengthRequiredSid( Sid.SubAuthorityCount ), ReadSid );
            RtlConvertSidToUnicodeString( &StringSid, ReadSid, TRUE );
            DebuggerOut( "\t%wZ\n", &StringSid );
            RtlFreeUnicodeString( &StringSid );
            FreeHeap( ReadSid );
        }

    }

}

VOID
DumpAcl(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    ACL Acl;
    PVOID AclPtr;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    AclPtr = GetExpr( pszCommand );

    if ( AclPtr == NULL ) {

        return;
    }

    ShowAcl( AclPtr );
}

VOID
ShowSD(
    IN PVOID SDPtr
    )
{
    SECURITY_DESCRIPTOR SD;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl = NULL, Sacl = NULL;

    LsaReadMemory( SDPtr, sizeof( SECURITY_DESCRIPTOR ), &SD );

    DebuggerOut( "Revision %lu\n", SD.Revision );
    DebuggerOut( "Sbz1 %lu\n", SD.Sbz1 );
    DebuggerOut( "Control 0x%lx\n", SD.Control );

    if (  ( SD.Control & SE_SELF_RELATIVE ) == SE_SELF_RELATIVE ) {

        if ( SD.Owner != 0 ) {

            Owner = ( PSID )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Owner );
        }

        if ( SD.Group != 0 ) {

            Group = ( PSID )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Group );
        }

        if ( SD.Dacl != 0 ) {

            Dacl = ( PACL )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Dacl );
        }

        if ( SD.Sacl != 0 ) {

            Sacl = ( PACL )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Sacl );
        }

    } else {

        Owner = SD.Owner;
        Group = SD.Group;
        Dacl = SD.Dacl;
        Sacl = SD.Sacl;
    }

    DebuggerOut( "Owner: ");
    if ( Owner ) {

        ReadAndDumpSid( Owner );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

    DebuggerOut( "Group: ");
    if ( Group ) {

        ReadAndDumpSid( Group );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

    DebuggerOut( "DACL:\n");
    if ( Dacl ) {

        ShowAcl( Dacl );

    } else {

        DebuggerOut( "<NULL>" );
    }

    DebuggerOut( "SACL:\n");
    if ( Sacl ) {

        ShowAcl( Sacl );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

}

VOID
DumpSD(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID SDPtr;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    SDPtr = GetExpr( pszCommand );

    if ( SDPtr == NULL ) {

        return;
    }

    ShowSD( SDPtr );

}


VOID
setevent(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    HANDLE h ;
    HANDLE hThere ;

    InitDebugHelp( hProcess, hThread, lpExt );

    hThere = GetExpr( pszCommand );

    if ( DuplicateHandle( hProcess,
                          hThere,
                          GetCurrentProcess(),
                          &h,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS ) )
    {
        SetEvent( h );
        CloseHandle( h );
    }
}


/*
+-------------------------------------------------------------------+

    NAME:       DumpSID

    FUNCTION:   Prints out a SID, with the padding provided.

    ARGS:       pad         --  Padding to print before the SID.
                sid_to_dump --  Pointer to the SID to print.
                Flag        --  To control options.

    RETURN:     N/A

    NOTE***:    It right now, doesn't lookup the sid.
                In future, you might want ot use the Flag
                parameter to make that optional.

+-------------------------------------------------------------------+
*/


VOID    DumpSID(
    CHAR        *pad,
    PSID        sid_to_dump,
    ULONG       Flag
    )
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      us;

    if (sid_to_dump)
    {
        ntstatus = RtlConvertSidToUnicodeString(&us, sid_to_dump, TRUE);

        if (NT_SUCCESS(ntstatus))
        {
            DebuggerOut("%s%wZ\n", pad, &us);
            RtlFreeUnicodeString(&us);
        }
        else
        {
            DebuggerOut("0x%08lx: Can't Convert SID to UnicodeString\n", ntstatus);
        }
    }
    else
    {
        DebuggerOut("%s is NULL\n", pad);
    }
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpACL

    FUNCTION:   Prints out a ACL, with the padding provided.

    ARGS:       pad         --  Padding to print before the ACL.
                acl_to_dump --  Pointer to the ACL to print.
                Flag        --  To control options.

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpACL (
    IN  char     *pad,
    IN  ACL      *pacl,
    IN  ULONG    Flags
    )
{
    USHORT       x;

    if (pacl == NULL)
    {
        DebuggerOut("%s is NULL\n", pad);
        return FALSE;
    }

    DebuggerOut("%s\n", pad);
    DebuggerOut("%s->AclRevision: 0x%x\n", pad, pacl->AclRevision);
    DebuggerOut("%s->Sbz1       : 0x%x\n", pad, pacl->Sbz1);
    DebuggerOut("%s->AclSize    : 0x%x\n", pad, pacl->AclSize);
    DebuggerOut("%s->AceCount   : 0x%x\n", pad, pacl->AceCount);
    DebuggerOut("%s->Sbz2       : 0x%x\n", pad, pacl->Sbz2);

    for (x = 0; x < pacl->AceCount; x ++)
    {
        PACE_HEADER     ace;
        CHAR        temp_pad[MAX_PATH];
        NTSTATUS    result;

        sprintf(temp_pad, "%s->Ace[%u]: ", pad, x);

        result = RtlGetAce(pacl, x, (PVOID *) &ace);
        if (! NT_SUCCESS(result))
        {
            DebuggerOut("%sCan't GetAce, 0x%08lx\n", temp_pad, result);
            return FALSE;
        }

        DebuggerOut("%s->AceType: ", temp_pad);

#define BRANCH_AND_PRINT(x) case x: DebuggerOut(#x "\n"); break

        switch (ace->AceType)
        {
            BRANCH_AND_PRINT(ACCESS_ALLOWED_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_OBJECT_ACE_TYPE);

            default:
                DebuggerOut("0x%08lx <-- *** Unknown AceType\n", ace->AceType);
                continue; // With the next ace
        }

#undef BRANCH_AND_PRINT

        DebuggerOut("%s->AceFlags: 0x%x\n", temp_pad, ace->AceFlags);

#define BRANCH_AND_PRINT(x) if (ace->AceFlags & x){ DebuggerOut("%s            %s\n", temp_pad, #x); }

        BRANCH_AND_PRINT(OBJECT_INHERIT_ACE)
        BRANCH_AND_PRINT(CONTAINER_INHERIT_ACE)
        BRANCH_AND_PRINT(NO_PROPAGATE_INHERIT_ACE)
        BRANCH_AND_PRINT(INHERIT_ONLY_ACE)
        BRANCH_AND_PRINT(INHERITED_ACE)
        BRANCH_AND_PRINT(SUCCESSFUL_ACCESS_ACE_FLAG)
        BRANCH_AND_PRINT(FAILED_ACCESS_ACE_FLAG)

#undef BRANCH_AND_PRINT

        DebuggerOut("%s->AceSize: 0x%x\n", temp_pad, ace->AceSize);

        /*
            From now on it is ace specific stuff.
            Fortunately ACEs can be split into 3 groups,
            with the ACE structure being the same within the group
        */

        switch (ace->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    DebuggerOut("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    sprintf(more_pad, "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                }
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    COMPOUND_ACCESS_ALLOWED_ACE     *tace = (COMPOUND_ACCESS_ALLOWED_ACE *) ace;
                    PBYTE                           ptr;

                    DebuggerOut("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    DebuggerOut("%s->CompoundAceType : 0x%08lx\n", temp_pad, tace->CompoundAceType);
                    DebuggerOut("%s->Reserved        : 0x%08lx\n", temp_pad, tace->Reserved);

                    sprintf(more_pad, "%s->SID(1)          : ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);

                    ptr = (PBYTE)&(tace->SidStart);
                    ptr += RtlLengthSid((PSID)ptr); /* Skip this & get to next sid */

                    sprintf(more_pad, "%s->SID(2)          : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                    PBYTE                           ptr;
                    GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                    DebuggerOut("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    DebuggerOut("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                    ptr = (PBYTE)&(tace->ObjectType);

                    if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        DebuggerOut("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                        obj_guid = &(tace->ObjectType);
                        ptr = (PBYTE)&(tace->InheritedObjectType);
                    }

                    if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        DebuggerOut("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                        inh_obj_guid = &(tace->InheritedObjectType);
                        ptr = (PBYTE)&(tace->SidStart);
                    }

                    if (obj_guid)
                    {
                        DebuggerOut("%s->ObjectType      : (in HEX)", temp_pad);
                        DebuggerOut("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            obj_guid->Data1,
                            obj_guid->Data2,
                            obj_guid->Data3,
                            obj_guid->Data4[0],
                            obj_guid->Data4[1],
                            obj_guid->Data4[2],
                            obj_guid->Data4[3],
                            obj_guid->Data4[4],
                            obj_guid->Data4[5],
                            obj_guid->Data4[6],
                            obj_guid->Data4[7]
                            );
                    }

                    if (inh_obj_guid)
                    {
                        DebuggerOut("%s->InhObjTYpe      : (in HEX)", temp_pad);
                        DebuggerOut("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            inh_obj_guid->Data1,
                            inh_obj_guid->Data2,
                            inh_obj_guid->Data3,
                            inh_obj_guid->Data4[0],
                            inh_obj_guid->Data4[1],
                            inh_obj_guid->Data4[2],
                            inh_obj_guid->Data4[3],
                            inh_obj_guid->Data4[4],
                            inh_obj_guid->Data4[5],
                            inh_obj_guid->Data4[6],
                            inh_obj_guid->Data4[7]
                            );
                    }

                    sprintf(more_pad, "%s->SID             : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
        }
        DebuggerOut("\n");
    }

    return TRUE;
}

VOID
objsec(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    HANDLE h ;
    HANDLE hThere ;
    NTSTATUS Status ;
    ULONG Length ;
    PVOID SecurityDescriptor ;
    PACL Acl ;

    InitDebugHelp( hProcess, hThread, lpExt );

    hThere = GetExpr( pszCommand );

    if ( DuplicateHandle( hProcess,
                          hThere,
                          GetCurrentProcess(),
                          &h,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS ) )
    {
        Status = NtQuerySecurityObject(
                    h,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    0,
                    &Length );

        SecurityDescriptor = LocalAlloc( LMEM_FIXED, Length );

        if ( SecurityDescriptor )
        {
            Status = NtQuerySecurityObject(
                        h,
                        DACL_SECURITY_INFORMATION,
                        SecurityDescriptor,
                        Length,
                        &Length );

            if ( NT_SUCCESS( Status ) )
            {
                BOOLEAN Present, defaulted;

                RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                              &Present,
                                              &Acl,
                                              &defaulted );

                DumpACL( "", Acl, 0);

            }

            LocalFree( SecurityDescriptor );
        }


    }
}

void
Help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    DebuggerOut("SPM Debug Help\n");
    DebuggerOut("   DumpPackage [-v][-b]] [id | addr]\tDump Package Control\n");
    DebuggerOut("   DumpSessionList <addr>      \tDump Session List\n");
    DebuggerOut("   DumpThreadSession           \tDump Thread's session\n");
    DebuggerOut("   DumpLogonSession <addr>     \tDump Logon Session list\n");
    DebuggerOut("   DumpSession <addr>          \tDump Session\n");
    DebuggerOut("   DumpHandleList <addr>       \tDump a Handle List from a session\n");
    DebuggerOut("   DumpBlock <addr>            \tDump a memory block (DBGMEM only)\n");
    DebuggerOut("   DumpScavList [<addr>[+]]    \tDump the scavenger list\n");
    DebuggerOut("   DumpToken <handle>          \tDump a token\n");
    DebuggerOut("   DumpThreadToken             \tDump token of thread\n");
    DebuggerOut("   DumpActives [-p|a|t] [file] \tDump active memory to file\n");
    DebuggerOut("   DumpFastMem                 \tDump FastMem usage\n");
    DebuggerOut("   Except                      \tShow exception for thread\n");
    DebuggerOut("   DumpLpc                     \tDump Lpc Dispatch record\n");
    DebuggerOut("   DumpLpcMessage <addr>       \tDump Lpc Message at address\n");
    DebuggerOut("   DumpThreadTask <addr>       \tDump thread pool\n");
    DebuggerOut("   DumpQueue [<addr>]          \tDump Queue\n");
    DebuggerOut("   DumpSecBuffer <addr>        \tDump SecBuffer struct\n");
    DebuggerOut("   DumpSecBufferDesc <addr>    \tDump SecBufferDesc struct \n");
    DebuggerOut("   DumpThreadLpc               \tDump thread's LPC message\n");
    DebuggerOut("   DumpNegContext <addr>       \tDump NEG_CONTEXT structure\n");
    DebuggerOut("   DumpNegCred <addr>          \tDump NEG_CRED structure\n");
    DebuggerOut("   BERDecode <addr>            \tDecode BER-encoded data\n");
    DebuggerOut("   GetTls <slot>               \tGet the TLS value from slot\n");
    DebuggerOut("   DumpHandleTable <addr>      \tDump handle table at addr\n");
    DebuggerOut("   DumpLsaHandle <addr>        \tDump the Lsa policy handle at addr\n");
    DebuggerOut("   DumpLsaHandleTable <addr>   \tDump the Lsa policy handle table at addr\n");
    DebuggerOut("   DumpLsaHandleTableEx <addr> \tDump the Lsa policy handle table at addr\n");
    DebuggerOut("   DumpSD <addr>               \tDump a security descriptor\n");
    DebuggerOut("   DumpAcl <addr>              \tDump the ACL at addr\n" );
    DebuggerOut("   DumpSid <addr>              \tDump the SID at addr\n" );
    DebuggerOut("   DumpLsaSidCache [<addr>]    \tDump the LSA sid cache\n" );
    DebuggerOut("   DumpFtcTdoEntry <addr>      \tDump the LSA FTC TDO entry\n" );
    DebuggerOut("   DumpForestTrustCache <addr> \tDump the LSA forest trust cache\n");

    DebuggerOut("\n\nShortcuts\n");
    DebuggerOut("   sb              DumpSecBuffer\n");
    DebuggerOut("   sbd             DumpSecBufferDesc\n");
    DebuggerOut("   lpc             DumpLpcMessage\n");
    DebuggerOut("   sess            DumpSession\n");
    DebuggerOut("   ber             BERDecode\n");
    DebuggerOut("   q               DumpQueue\n");
    DebuggerOut("   task            DumpThreadTask\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\ber.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ber.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <crtdbg.h>

#include "ber.hxx"
#include "util.hxx"
#include "rsa.h"

BYTE Buffer[1024] = {0};

BOOL BerVerbose = FALSE ;

CHAR maparray[] = "0123456789abcdef";

#define MAX_OID_VALS    32

typedef struct _OID {
    unsigned cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

typedef enum _OidResult {
    OidExact,
    OidPartial,
    OidMiss,
    OidError
} OidResult;

#define LINE_SIZE   192
#define INDENT_SIZE 4

#define OID_VERBOSE 0x0002
#define OID_PARTIAL 0x0001

#define iso_member          0x2a,               // iso(1) memberbody(2)
#define us                  0x86, 0x48,         // us(840)
#define rsadsi              0x86, 0xf7, 0x0d,   // rsadsi(113549)
#define pkcs                0x01,               // pkcs(1)

#define rsa_                iso_member us rsadsi
#define rsa_len             6
#define rsa_text            "iso(2) member-body(2) us(840) rsadsi(113549) "
#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define pkcs_text           "iso(2) member-body(2) us(840) rsadsi(113549) pkcs(1) "

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2

typedef struct _ObjectId {
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
    PSTR        Name;
} ObjectId;

ObjectId    KnownObjectIds[] = {
    { {pkcs_1 1, 1}, pkcs_len + 2, pkcs_text "RSA"},
    { {pkcs_1 1, 2}, pkcs_len + 2, pkcs_text "MD2/RSA"},
    { {pkcs_1 1, 4}, pkcs_len + 2, pkcs_text "MD5/RSA"},
    { {iso_member us 0x82, 0xf7, 0x12, 0x01, 0x02, 0x02}, 9, "NegKerberosLegacy"},
    { {rsa_ 3, 4}, rsa_len + 2, rsa_text "RC4"},
    { {attributeType 3}, attrtype_len + 1, "CN="},
    { {attributeType 6}, attrtype_len + 1, "C="},
    { {attributeType 7}, attrtype_len + 1, "L="},
    { {attributeType 8}, attrtype_len + 1, "S="},
    { {attributeType 10}, attrtype_len + 1, "O="},
    { {attributeType 11}, attrtype_len + 1, "OU="},
    };

ObjectId    KnownPrefixes[] = {
    { {pkcs_1}, pkcs_len, pkcs_text},
    { {iso_member us rsadsi}, pkcs_len - 1, "iso(2) member-body(2) us(840) rsadsi(113549) "},
    { {iso_member us}, pkcs_len - 4, "iso(2) member-body(2) us(840) "},
    { {iso_member}, pkcs_len - 6, "iso(2) member-body(2) " }
    };

typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1}
                               };

CHAR * DefaultTree =
   "1 iso\n"
   "    2 memberbody\n"
   "        840 us\n"
   "            113549 rsadsi\n"
   "                1 pkcs\n"
   "                    1 RSA\n"
   "                    3 pkcs-3\n"
   "                        1 dhKeyAgreement\n"
   "                2 digestAlgorithm\n"
   "                    2 MD2\n"
   "                    4 MD4\n"
   "                    5 MD5\n"
   "            113554 mit\n"
   "                1 infosys\n"
   "                    2 gssapi\n"
   "                        1 generic\n"
   "                            1 user_name\n"
   "                            2 machine_uid_name\n"
   "                            3 string_uid_name\n"
   "                        2 NegKerberos\n"
   "                            3 user2user\n"
   "            113556 microsoft\n"
   "                1 ds\n"
   "    3 org\n"
   "        6 dod\n"
   "            1 internet\n"
   "                4 private\n"
   "                    1 enterprise\n"
   "                        311 microsoft\n"
   "                            1 software\n"
   "                                1 systems\n"
   "                                2 wins\n"
   "                                3 dhcp\n"
   "                                4 apps\n"
   "                                5 mos\n"
   "                                7 InternetServer\n"
   "                                8 ipx\n"
   "                                9 ripsap\n"
   "                            2 security\n"
   "                                1 certificates\n"
   "                                2 mechanisms\n"
   "                                    0 NegMS\n"
   "                                    9 Negotiator\n"
   "                                    10 NTLM\n"
   "                                    12 SSL\n"
   "                5 security\n"
   "                    3 integrity\n"
   "                        1 md5-DES-CBC\n"
   "                        2 sum64-DES-CBC\n"
   "                    5 mechanisms\n"
   "                        1 spkm\n"
   "                            1 spkm-1\n"
   "                            2 spkm-2\n"
   "                            10 spkmGssTokens\n"
   "                        2 Spnego\n"
   "                    6 nametypes\n"
   "                        2 gss-host-based-services\n"
   "                        3 gss-anonymous-name\n"
   "                        4 gss-api-exported-name\n"
   "        14 oiw\n"
   "            3 secsig\n"
   "                2 algorithm\n"
   "                    7 DES-CBC\n"
   "                    10 DES-MAC\n"
   "                    18 SHA\n"
   "                    22 id-rsa-key-transport\n"
   "2 joint-iso-ccitt\n"
   "    5 ds\n"
   "        4 attribute-type\n"
   "            3 CommonName\n"
   "            6 Country\n"
   "            7 Locality\n"
   "            8 State\n"
   "            10 Organization\n"
   "            11 OrgUnit\n"
    ;

typedef struct _TreeFile {
    CHAR*  Buffer;
    CHAR*  Line;
    CHAR*  CurNul;
    ULONG  len;
} TreeFile, * PTreeFile ;

BOOL
TreeFileInit(
    PTreeFile pFile,
    PSTR pStr)
{
    pFile->len = strlen(pStr);

    if ((pStr[pFile->len - 1] != '\r') &&
        (pStr[pFile->len - 1] != '\n')) {
        pFile->len++;
    }

    pFile->Buffer = new char[pFile->len + 2];

    if (pFile->Buffer) {
        strcpy( pFile->Buffer, pStr );
        pFile->Line = pFile->Buffer;
        pFile->CurNul = NULL;
        pFile->Buffer[pFile->len + 1] = '\0';
    }

    return (pFile->Buffer != NULL);
}

void
TreeFileDelete(
    PTreeFile   pFile
    )
{
    delete [] pFile->Buffer;
}

PSTR
TreeFileGetLine(
    PTreeFile   pFile)
{
    PSTR Scan;
    PSTR Line;

    if (!pFile->Line) {
        return(NULL);
    }

    if (pFile->CurNul) {
        _ASSERT(pFile->CurNul >= pFile->Buffer && pFile->CurNul < pFile->Buffer + pFile->len);
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    Scan = pFile->Line ;

    while (*Scan && (*Scan != '\n') && (*Scan != '\r')) {
        Scan++;
    }

    //
    // Okay, get the line to return
    //

    Line = pFile->Line;

    //
    // If this is not the end, touch up the pointers:
    //
    if (*Scan) {
        *Scan = '\0';

        _ASSERT(pFile->CurNul >= pFile->Buffer && pFile->CurNul < pFile->Buffer + pFile->len);
        pFile->CurNul = Scan;

        Scan += 1;

        while (*Scan && ((*Scan == '\r') || (*Scan == '\n'))) {
            Scan++ ;
        }

        //
        // If this is the end, reset line
        //
        if (*Scan == '\0') {
            pFile->Line = NULL ;
        } else {
            pFile->Line = Scan;
        }

    } else {
        pFile->Line = NULL ;
    }

    return(Line);
}

void
TreeFileRewind(
    PTreeFile   pFile)
{

    if (pFile->CurNul) {
        _ASSERT(pFile->CurNul >= pFile->Buffer && pFile->CurNul < pFile->Buffer + pFile->len);
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    pFile->Line = pFile->Buffer ;
}

ULONG
tohex(
    BYTE    b,
    PSTR    psz)
{
    BYTE b1, b2;

    b1 = b >> 4;
    b2 = b & 0xF;

    *psz++ = maparray[b1];
    *psz = maparray[b2];

    //
    // now return the length of display
    //
    return(3);
}


//+---------------------------------------------------------------------------
//
//  Function:   DecodeOID
//
//  Synopsis:   Decodes an OID into a simple structure
//
//  Arguments:  [pEncoded] --
//              [len]      --
//              [pOID]     --
//
//  History:    8-07-96   RichardW   Stolen directly from DonH
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DecodeOID(UCHAR *pEncoded, ULONG len, OID *pOID)
{
    unsigned cval;
    unsigned val;
    ULONG i, j;

    if (len <=2) {
        return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;

    //dprintf("Encoded value %02x turned into %d and %d\n", pEncoded[0],
    //          pOID->Val[0], pOID->Val[1] );

    cval = 2;
    i = 1;

    while (i < len) {
        j = 0;
        val = pEncoded[i] & 0x7f;
        while (pEncoded[i] & 0x80) {
            val <<= 7;
            ++i;
            if (++j > 4 || i >= len) {
                // Either this value is bigger than we can handle (we
                // don't handle values that span more than four octets)
                // -or- the last octet in the encoded string has its
                // high bit set, indicating that it's not supposed to
                // be the last octet.  In either case, we're sunk.
                return FALSE;
            }
            val |= pEncoded[i] & 0x7f;
        }
        //ASSERT(i < len);
        pOID->Val[cval] = val;
        ++cval;
        ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

PSTR
GetLineWithIndent(
    PTreeFile  ptf,
    DWORD  i)
{
    PSTR Scan;
    DWORD test;

    do {
        Scan = TreeFileGetLine(ptf);

        if (Scan && i) {
            if (i < INDENT_SIZE) {
                test = 0;
            } else {
                test = i - INDENT_SIZE;
            }

            if (Scan[test] != ' ') {
                Scan = NULL;
                break;
            }
        } else {
            test = 0;
        }

    } while (Scan && (Scan[i] == ' '));

    return(Scan);
}

OidResult
scan_oid_table(
    CHAR*  Table,
    DWORD   Flags,
    PUCHAR  ObjectId,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   MaxRep)
{
    CHAR    OidPath[MAX_PATH] = {0};
    OID     Oid;
    DWORD   i;
    DWORD   Indent;
    TreeFile tf;
    PSTR    Scan;
    PSTR    Tag;
    PSTR    SubScan;
    DWORD   Index;
    DWORD   size;
    DWORD   TagSize;

    if (!DecodeOID(ObjectId, Len, &Oid)) {
        return( OidError );
    }

    i = 0;
    Indent = 0;

    if (!TreeFileInit(&tf, Table)) {
        DBG_LOG(LSA_ERROR, ("Unable to load prefix table\n"));

        return OidError ;
    }

    Tag = OidPath;
    size = 0;
    TagSize = 0;

    if (!(Flags & OID_VERBOSE)) {
        while (i < Oid.cVal) {
            TagSize = _snprintf( Tag, MAX_PATH - size, "%d.", Oid.Val[i] );
            size += TagSize;
            Tag += TagSize;
            i++;
        }

        if (TagSize && OidPath[size - 1] == '.') {
            OidPath[size - 1] = '\0';
        }

        strncpy(pszRep, OidPath, MaxRep);

        TreeFileDelete(&tf);

        return(OidExact);
    }

    while (i < Oid.cVal) {
        do {
            Scan = GetLineWithIndent(&tf, Indent);

            if (Scan) {
                Index = atoi(Scan);
            } else {
                Index = (DWORD) -1;
            }

            if (Index == Oid.Val[i]) {
                break;
            }
        } while (Scan);

        //
        // If Scan is NULL, we didn't get a match
        //
        if (!Scan) {
            if (i > 0) {
                if (Flags & OID_PARTIAL) {
                    while (i < Oid.cVal) {
                        TagSize = _snprintf(Tag, MAX_PATH - size, "%d ", Oid.Val[i] );
                        size += TagSize;
                        Tag += TagSize;
                        i++;
                    }
                    strncpy(pszRep, OidPath, MaxRep);
                }

                TreeFileDelete(&tf);

                return(OidPartial);
            }

            TreeFileDelete(&tf);

            return(OidMiss);
        }

        //
        // Got a hit:
        //

        SubScan = &Scan[Indent];

        while (*SubScan != ' ') {
            SubScan++;
        }

        SubScan++;
        TagSize = _snprintf( Tag, MAX_PATH - size, "%s(%d) ", SubScan, Index );
        size += TagSize;
        Tag += TagSize ;
        Indent += INDENT_SIZE ;
        i ++;
    }

    strncpy(pszRep, OidPath, MaxRep);

    TreeFileDelete(&tf);

    return(OidExact);
}

bool
lookup_objid(
    PUCHAR  ObjectId,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   MaxRep)
{
    DWORD i;
    CHAR  szBuffer[256] = {0};
    DWORD indent;
    DWORD j;

    for (i = 0; i < COUNTOF(KnownObjectIds); i++) {
        if (Len == KnownObjectIds[i].SequenceLen) {
            if (memcmp(KnownObjectIds[i].Sequence, ObjectId, Len) == 0) {
                strncpy(pszRep, KnownObjectIds[i].Name, MaxRep - 2);
                pszRep[MaxRep - 1] = '\0';
                return true;
            }
        }
    }

    #if 0
    for (i = 0; i < COUNTOF(KnownPrefixes); i++) {
        if (KnownPrefixes[i].SequenceLen <= Len) {
            if (memcmp(KnownPrefixes[i].Sequence,
                       ObjectId,
                       KnownPrefixes[i].SequenceLen) == 0) {
                indent = sprintf(szBuffer, "%s", KnownPrefixes[i].Name);
                for (j = KnownPrefixes[i].SequenceLen ; j <= Len; j++) {
                    indent += tohex(ObjectId[j], &szBuffer[indent]);
                }
                strncpy(pszRep, szBuffer, MaxRep-2);
                pszRep[MaxRep - 1] = '\0';
                return true;
            }
        }
    }
    #endif

    return false;
}

decode_to_string(
    LPBYTE  pBuffer,
    DWORD   Flags,
    DWORD   Type,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   RepLen)
{
    PSTR    pstr;
    PSTR    lineptr;
    DWORD   i;

    switch (Type) {
    case BER_NULL:
        strcpy(pszRep, "<empty>");
        break;

    case BER_OBJECT_ID:
        if (!lookup_objid(pBuffer, Len, pszRep, RepLen)) {
            scan_oid_table(DefaultTree, OID_PARTIAL | (Flags & DECODE_VERBOSE_OIDS ? OID_VERBOSE : 0 ),
                pBuffer, Len, pszRep, RepLen);
        }
        break;

    case BER_PRINTABLE_STRING:
    case BER_TELETEX_STRING:
    case BER_GRAPHIC_STRING:
    case BER_VISIBLE_STRING:
    case BER_GENERAL_STRING:
    case BER_IA5_STRING:
    case BER_GENERIZED_TIME:
        CopyMemory(pszRep, pBuffer, min(Len, RepLen - 1));
        pszRep[min(Len, RepLen - 1)] = '\0';
        break;

    case BER_BOOL:
    case BER_INTEGER:
    case BER_UTC_TIME:
        lineptr = pszRep;
        for (i = 0; i < min(Len, 16); i++) {
            lineptr += tohex(*pBuffer, lineptr);
            pBuffer++;
        }
        *lineptr++ = '\0';
        break;

    default:
        pstr = &pszRep[min(Len, 16) * 3 + 2];
        lineptr = pszRep;
        for (i = 0; i < min(Len, 16); i++) {
            lineptr += tohex(*pBuffer, lineptr);
            if ((*pBuffer >= ' ') && (*pBuffer <= '|')) {
                *pstr++ = *pBuffer;
            } else {
                *pstr++ = '.';
            }

            pBuffer++;
        }
        *pstr++ = '\0';
        break;
    }

    return(0);
}

ULONG
ber_decode(
    LPBYTE  pBuffer,
    DWORD   Flags,
    ULONG   Indent,
    ULONG   Offset,
    ULONG   TotalLength,
    ULONG   BarDepth)
{
    PSTR  TypeName = NULL;
    CHAR  msg[32] = {0};
    PSTR  pstr;
    ULONG i;
    ULONG Len;
    ULONG ByteCount;
    ULONG Accumulated;
    DWORD Type;
    ULONG subsize;
    CHAR  line[LINE_SIZE + 2] = {0};
    BOOL  Nested;
    BOOL  Leaf;
    ULONG NewBarDepth;
    CHAR nonuniversal[LINE_SIZE] = {0};

    Type = *pBuffer;

    if ((Type & 0xC0) == 0) {
        switch (Type & 0x1F) {
        case BER_BOOL:
            TypeName = "Bool";
            break;

        case BER_INTEGER:
            TypeName = "Integer";
            break;

        case BER_BIT_STRING:
            TypeName = "Bit String";
            break;

        case BER_OCTET_STRING:
            TypeName = "Octet String";
            if (Flags & DECODE_NEST_OCTET_STRINGS) {
                TypeName = "Octet String (Expanding)";
                Type |= BER_CONSTRUCTED ;
                Flags &= ~( DECODE_NEST_OCTET_STRINGS );
            }
            break;

        case BER_NULL:
            TypeName = "Null";
            break;

        case BER_OBJECT_ID:
            TypeName = "Object ID";
            break;

        case BER_OBJECT_DESC:
            TypeName = "Object Descriptor";
            break;

        case BER_SEQUENCE:
            TypeName = "Sequence";
            break;

        case BER_SET:
            TypeName = "Set";
            break;

        case BER_NUMERIC_STRING:
            TypeName = "Numeric String";
            break;

        case BER_PRINTABLE_STRING:
            TypeName = "Printable String";
            break;

        case BER_TELETEX_STRING:
            TypeName = "TeleTex String";
            break;

        case BER_VIDEOTEX_STRING:
            TypeName = "VideoTex String";
            break;

        case BER_VISIBLE_STRING:
            TypeName = "Visible String";
            break;

        case BER_GENERAL_STRING:
            TypeName = "General String";
            break;

        case BER_GRAPHIC_STRING:
            TypeName = "Graphic String";
            break;

        case BER_UTC_TIME:
            TypeName = "UTC Time";
            break;

        case BER_ENUMERATED:
            TypeName = "Enumerated";
            break;

        case BER_IA5_STRING:
            TypeName = "IA5 String";
            break;
        case BER_GENERIZED_TIME:
            TypeName = "Generalized Time";
            break;

        default:
            dprintf("\nUnknown type %#x\n", Type);
            throw "Unknown type";
            break;
        }
    } else {
        //
        // Not universal
        //
        switch (Type & 0xC0) {
            case BER_UNIVERSAL:
                TypeName = "Internal Error!";
                break;

            case BER_APPLICATION:
                sprintf( nonuniversal, "[Application %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_CONTEXT_SPECIFIC:
                sprintf( nonuniversal, "[Context Specific %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_PRIVATE:
                sprintf( nonuniversal, "[Private %d]", Type & 0x1F);
                TypeName = nonuniversal ;
                break;
        }
    }

    pstr = msg;
    for (i = 0; i < Indent; i++) {
        if (i < BarDepth) {
            *pstr++ = '\263';
        } else {
            *pstr++ = ' ';
        }
        *pstr++ = ' ';
    }
    *pstr++ = '\0';

    pBuffer ++;
    Len = 0;

    if (*pBuffer & 0x80) {
        ByteCount = *pBuffer++ & 0x7f;

        for (i = 0; i < ByteCount; i++) {
            Len <<= 8;
            Len += *pBuffer++;
        }
    } else {
        ByteCount = 0;
        Len = *pBuffer++;
    }

    if (Offset + Len + 2 + ByteCount == TotalLength) {
        Leaf = TRUE;
    } else if (Offset +  Len + 2 + ByteCount > TotalLength) {
        dprintf("\nBuffer overrun\n");
        throw "Encoding format incorrect";
    } else {
        Leaf = FALSE;
    }
    if (Type & BER_CONSTRUCTED) {
        Nested = TRUE;
    } else {
        Nested = FALSE;
    }

    dprintf("%s%c\304%c[%x] %s(%d) ", msg, Leaf ? 192 : 195, Nested ? 194 : 196, Type, TypeName, Len);

    if (Type & BER_CONSTRUCTED) {
        dprintf("\n");
        Accumulated = 0;
        while (Accumulated < Len) {
            if (BarDepth < Indent) {
                NewBarDepth = BarDepth;
            } else {
                NewBarDepth = (Nested && Leaf) ? BarDepth : Indent + 1;
            }

            if (Len <= TotalLength) {

                subsize = ber_decode(pBuffer, Flags, Indent + 1,
                                        Accumulated, Len, NewBarDepth);
                Accumulated += subsize;
                pBuffer += subsize;

            } else {

                dprintf("\nInsufficient buffer\n");
                throw("Decode error\n");
            }
        }

        if (!IsEmpty(msg)) {

            dprintf("%s%c\n", msg, ((Indent <= BarDepth) && !Leaf) ? 179 : 32);
        }
    } else {
        memset(line, ' ', LINE_SIZE - 1);
        line[ LINE_SIZE - 1 ] = '\0';

        decode_to_string(pBuffer, Flags, Type, Len, line, LINE_SIZE);

        dprintf("%s\n", line);

    }

    return (Len + 2 + ByteCount);
}

static  HRESULT ProcessOptions(IN OUT PSTR pszArgs, OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |= DECODE_VERBOSE_OIDS;
                break;
            case 'n':
                *pfOptions |= DECODE_NEST_OCTET_STRINGS;
                break;
            case 'd':
                *pfOptions |= DECODE_SEC_BUF_DEC;
                break;
            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrberd);
    dprintf(kstrber);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrfsbd);
    dprintf("   -n   Decode nested octet strings\n");
    dprintf("   -v   Decode verbose OIDs\n");
}

HRESULT GetBerLength(IN LONG64 addr, OUT ULONG* pcbBer)
{
    HRESULT hRetval = addr && pcbBer ? S_OK : E_INVALIDARG;

    ULONG headerLength = 0;
    UCHAR buffer[8] = {0};

    if (SUCCEEDED(hRetval)) {

        *pcbBer = 0;

        //
        // Read the first two octets, namely the type and length field.
        //
        hRetval = ReadMemory(addr, buffer, 2, NULL) ? S_OK : E_FAIL;
    }

    if (SUCCEEDED(hRetval)) {

        if (buffer[1] & 0x80) {

           headerLength = buffer[1] & 0x7F ;

           hRetval = ReadMemory(addr, buffer, headerLength + 2, NULL) ? S_OK : E_FAIL;

           if (SUCCEEDED(hRetval)) {

               for (ULONG i = 0; i < headerLength; i++) {

                   *pcbBer = (*pcbBer << 8) + buffer[2 + i];
               }
           }

           headerLength++; // one for the Constructed type
        } else {

           headerLength = 1;   // TLV header, the length is 1 byte
           *pcbBer = buffer[1];
        }
    }

    if (SUCCEEDED(hRetval)) {

        *pcbBer += headerLength + 1; // 1 is the tag length
        hRetval = *pcbBer ? S_OK : E_INVALIDARG;
    }

    if (E_FAIL == hRetval) {

        dprintf("Unable to read the buffer length\n");
    }

    return hRetval;
}

DECLARE_API(ber)
{
    HRESULT hRetval = E_FAIL;

    CHAR szArgs[MAX_PATH] = {0};
    ULONG Flags = 0;
    ULONG cb = 0;
    ULONG64 tmp = 0;
    ULONG64 addr = 0;
    PUCHAR pbBuffer = NULL;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessOptions(szArgs, &Flags);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addr, &args) && addr ? S_OK : E_INVALIDARG;
    }

    try {

        if (SUCCEEDED(hRetval)) {

            if (Flags & DECODE_SEC_BUF_DEC) {

                dprintf("_SecBufferDesc %#I64x", addr);

                addr = TSecBufferDesc(addr).GetTokenAddrDirect(&cb);

                if (!addr || !cb) {
                    dprintf(" has no token buffer to decode");
                    hRetval = E_FAIL;
                }

                dprintf(kstrNewLine);

            } else {

                if (!IsEmpty(args)) {

                    hRetval = GetExpressionEx(args, &tmp, &args) && tmp ? S_OK : E_INVALIDARG;
                }

                if (SUCCEEDED(hRetval)) {
                    if (tmp) {
                        cb = static_cast<ULONG>(tmp);
                    } else {
                        hRetval = GetBerLength(addr, &cb);
                    }
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

            pbBuffer = new UCHAR[cb];
            hRetval = pbBuffer ? S_OK : E_OUTOFMEMORY;

            if (FAILED(hRetval)) {
                DBG_LOG(LSA_ERROR, ("Failed to alloc mem\n"));
            }
        }

        if (SUCCEEDED(hRetval)) {

            if (!ReadMemory(addr, pbBuffer, cb, NULL) ) {

                DBG_LOG(LSA_ERROR, ("Unable to read from target\n"));

                hRetval = E_FAIL;
            }
        }

        if (SUCCEEDED(hRetval)) {

            dprintf("Decoding BER %#x bytes at %#I64x...\n", cb, toPtr(addr));

            (void)ber_decode(pbBuffer, Flags, 0, 0, cb, 0);
        }

    } CATCH_LSAEXTS_EXCEPTIONS("Unable to decode buffer", NULL)


    if (pbBuffer) {

        delete [] pbBuffer;
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\breakin.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    breakin.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       June 1, 2002

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "breakin.hxx"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define STACKSIZE 32768

typedef BOOL (* LPDEBUG_BREAK_PROCESS_ROUTINE) (
    HANDLE hProcess
    );

static void DisplayUsage(
    void
    )
{
    dprintf(kstrUsage);
    dprintf("   dbgbreak <pid>                          Breakin to process by pid\n");
}

HRESULT 
ProcessDbgbreakOptions(
    IN OUT PSTR pszArgs, 
    IN OUT ULONG* pfOptions
    )
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {


            // case '1': // allow -1 pseudo handle
            //    continue;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

VOID
EnableDebugPriv(
    VOID
    )
{
    HANDLE hToken = NULL;
    UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ) ] = {0};
    PTOKEN_PRIVILEGES pPrivs = (PTOKEN_PRIVILEGES) Buf;

    if (OpenProcessToken( 
            GetCurrentProcess(),
            MAXIMUM_ALLOWED,
            &hToken 
            )) {

        pPrivs->PrivilegeCount = 1 ;
        pPrivs->Privileges[0].Luid.LowPart = SE_DEBUG_PRIVILEGE;
        pPrivs->Privileges[0].Luid.HighPart = 0;
        pPrivs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges( 
            hToken,
            FALSE, // DisableAllPrivileges
            pPrivs, // NewState
            0, // BufferLength
            NULL, // PreviousState
            NULL // ReturnLength
            ))  {

            DBG_LOG(LSA_WARN, ("EnableDebugPriv AdjustTokenPrivileges falied %#\n", GetLastError()));
        }


        CloseHandle( hToken );
    }
    else
    {
        DBG_LOG(LSA_ERROR, ("EnableDebugPriv OpenProcessToken falied %#\n", GetLastError()));
    }
}

HRESULT
BreakinByPid(
    IN ULONG ProcessId
    )
{
    HRESULT hRetval = E_FAIL;

    LPTHREAD_START_ROUTINE pFuncDbgBreakPoint = NULL;
    LPDEBUG_BREAK_PROCESS_ROUTINE pFuncDebugBreakProcessRoutine = NULL;
    HMODULE hNtdll = NULL;
    HMODULE hKernel32 = NULL;
    ULONG ThreadId = 0;
    ULONG CurrentPid = -1;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;

    hRetval = g_ExtSystem->GetCurrentProcessSystemId(&CurrentPid);

    if (SUCCEEDED(hRetval)) {
        dprintf("CurrentPid is %#x(%d), trying to breakin %#x(%d)\n", CurrentPid, CurrentPid, ProcessId, ProcessId);
    } else {
        dprintf("GetCurrentProcessSystemId failed with %#x\n", hRetval);
        return hRetval;
    }

    if (ProcessId == 0 || ProcessId == -1) {
        return E_INVALIDARG;
    }

    if (ProcessId == CurrentPid) {
        dprintf("Breakin to current process, no-op\n");
        return S_OK;
    }

    EnableDebugPriv();

    hProcess = OpenProcess(
        PROCESS_ALL_ACCESS,
        FALSE,
        ProcessId
        );
    if (hProcess) {

        hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

        if (hKernel32) {

            DBG_LOG(LSA_LOG, ("BreakinByPid trying kernel32!DebugBreakProcess\n"));

            pFuncDebugBreakProcessRoutine = (LPDEBUG_BREAK_PROCESS_ROUTINE)
                GetProcAddress(hKernel32, "DebugBreakProcess");

            if (pFuncDebugBreakProcessRoutine) {

                if (!(*pFuncDebugBreakProcessRoutine)(hProcess)) {

                    dprintf("DebugBreakProcess failed %#x\n", GetLastError());
                }

                CloseHandle(hProcess);

                return S_OK;
            }
        }
        
        hNtdll = GetModuleHandle(TEXT("ntdll.dll"));

        if (hNtdll) {

            DBG_LOG(LSA_LOG, ("BreakinByPid trying ntdll!DbgBreakPoint\n"));

            pFuncDbgBreakPoint = (LPTHREAD_START_ROUTINE)
                GetProcAddress(hNtdll, "DbgBreakPoint");

            if (pFuncDbgBreakPoint) {

                hThread = CreateRemoteThread(
                    hProcess,
                    NULL,
                    STACKSIZE,
                    pFuncDbgBreakPoint,
                    NULL,
                    0,
                    &ThreadId
                    );
                if (hThread) {
                    hRetval = S_OK;
                    DBG_LOG(LSA_LOG, ("BreakinByPid CreateRemoteThread ntdll!DbgBreakPoint, thread id %#x\n", ThreadId));
                    CloseHandle(hThread);
                } else {
                    hRetval = GetLastErrorAsHResult();
                    DBG_LOG(LSA_ERROR, ("BreakinByPid CreateRemoteThread ntdll!DbgBreakPoint, failed with %#x\n", HRESULT_CODE(hRetval)));
                }
            }
        }

        CloseHandle(hProcess);

    } else {

        hRetval = GetLastErrorAsHResult();
        dprintf("BreakinByPid OpenProcess failed %#x\n", HRESULT_CODE(hRetval));
    }

    return hRetval;
}

DECLARE_API(dbgbreak)
{
    HRESULT hRetval = S_OK;
    
    ULONG SessionType = DEBUG_CLASS_UNINITIALIZED;
    ULONG SessionQual = 0;
    ULONG64 Pid = -1;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    if (args && *args) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessDbgbreakOptions(szArgs, &fOptions);

        if (SUCCEEDED(hRetval) && !IsEmpty(szArgs)) {

            hRetval = GetExpressionEx(szArgs, &Pid, &args) && Pid ? S_OK : E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = ExtQuery(Client);
    }
    if (SUCCEEDED(hRetval)) {

       hRetval = g_ExtControl->GetDebuggeeType(&SessionType, &SessionQual);
    }

    if (SUCCEEDED(hRetval)) {

        if ( SessionType == DEBUG_CLASS_USER_WINDOWS &&
             SessionQual == DEBUG_USER_WINDOWS_PROCESS ) {

            hRetval = BreakinByPid((ULONG)Pid);

            if (FAILED(hRetval)) {

                dprintf("Unable to break into %d(%#x)\n", (ULONG) Pid, (ULONG) Pid);
            }
         } else if (DEBUG_CLASS_KERNEL == SessionType) {

            dprintf("Lsaexts.dbgbreak is user mode only\n");

         }  else {

            dprintf("lsaexts.dbgbreak debugger type not supported: SessionType %#x, SessionQual %#x\n", SessionType, SessionQual);

            hRetval = DEBUG_EXTENSION_CONTINUE_SEARCH;
         }
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    (void)ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\acl.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    acl.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "acl.hxx"
#include "util.hxx"
#include "sid.hxx"

BOOL DumpAceType(IN PCSTR pszPad, IN UCHAR AceType)
{

#define BRANCH_AND_PRINT(x) case x: dprintf("%s%s\n", pszPad, #x); break

    switch (AceType)
    {
        BRANCH_AND_PRINT(ACCESS_ALLOWED_ACE_TYPE);
        BRANCH_AND_PRINT(ACCESS_DENIED_ACE_TYPE);
        BRANCH_AND_PRINT(SYSTEM_AUDIT_ACE_TYPE);
        BRANCH_AND_PRINT(SYSTEM_ALARM_ACE_TYPE);
        BRANCH_AND_PRINT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
        BRANCH_AND_PRINT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
        BRANCH_AND_PRINT(ACCESS_DENIED_OBJECT_ACE_TYPE);
        BRANCH_AND_PRINT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
        BRANCH_AND_PRINT(SYSTEM_ALARM_OBJECT_ACE_TYPE);

        default:
            dprintf("%sUnknown AceType\n", pszPad);
            return FALSE;
    }

#undef BRANCH_AND_PRINT

    return TRUE;
}

void DumpAceFlags(IN PCSTR pszPad, IN UCHAR AceFlags)
{

#define BRANCH_AND_PRINT(x) if (AceFlags & x) { dprintf("%s%s\n", pszPad, #x); }

    BRANCH_AND_PRINT(OBJECT_INHERIT_ACE)
    BRANCH_AND_PRINT(CONTAINER_INHERIT_ACE)
    BRANCH_AND_PRINT(NO_PROPAGATE_INHERIT_ACE)
    BRANCH_AND_PRINT(INHERIT_ONLY_ACE)
    BRANCH_AND_PRINT(INHERITED_ACE)
    BRANCH_AND_PRINT(SUCCESSFUL_ACCESS_ACE_FLAG)
    BRANCH_AND_PRINT(FAILED_ACCESS_ACE_FLAG)

#undef BRANCH_AND_PRINT

}

void DumpObjectAceFlags(IN PCSTR pszPad, IN ULONG AceFlags)
{

#define BRANCH_AND_PRINT(x) if (AceFlags & x){ dprintf("%s%s\n", pszPad, #x); }

    BRANCH_AND_PRINT(ACE_OBJECT_TYPE_PRESENT)
    BRANCH_AND_PRINT(ACE_INHERITED_OBJECT_TYPE_PRESENT)

#undef BRANCH_AND_PRINT

}

void ShowAcl(IN PCSTR pszPad, IN ULONG64 addrAcl, IN ULONG fOptions)
{
    ULONG i = 0;
    ULONG SkipSize = 0;
    ULONG64 addrAce = 0;
    ACE_HEADER Ace = {0};
    KNOWN_ACE KnownAce = {0};

    //
    // KNOWN_OBJECT_ACE can have two optional GUIDs
    //
    CHAR BufKnownObjectAce[sizeof(KNOWN_OBJECT_ACE) + 2 * sizeof(GUID)] = {0};
    KNOWN_OBJECT_ACE* pKnownObjectAce = reinterpret_cast<KNOWN_OBJECT_ACE*>(BufKnownObjectAce);

    COMPOUND_ACCESS_ALLOWED_ACE cAce = {0};
    ULONG64 addrSidStart = 0;
    GUID* DisplayGuid = NULL;
    ACL ReadAcl = {0};
    PACL Acl = &ReadAcl;
    CHAR szMorePad[MAX_PATH] = {0};
    CHAR szEvenMorePad[MAX_PATH] = {0};

    _snprintf(szMorePad, sizeof(szMorePad) -1, "%s    ", pszPad);
    _snprintf(szEvenMorePad, sizeof(szEvenMorePad) -1, "%s        ", pszPad);

    LsaReadMemory(addrAcl, sizeof(ACL), &ReadAcl);

    dprintf("%sAclRevision %lu\n", pszPad, ReadAcl.AclRevision);
    dprintf("%sSbz1 %lu\n", pszPad, ReadAcl.Sbz1);
    dprintf("%sAclSize %lu\n", pszPad, ReadAcl.AclSize);
    dprintf("%sAceCount %lu\n", pszPad, ReadAcl.AceCount);
    dprintf("%sSbz2 %lu\n", pszPad, ReadAcl.Sbz2);

    addrAce = addrAcl + sizeof(ACL);

    for (i = 0; i < ReadAcl.AceCount; i++) {

        //
        // First, we need to read the Size/Type of the ace
        //
        LsaReadMemory(addrAce, sizeof(ACE_HEADER), &Ace );

        dprintf("%sAce[%lu]\n", pszPad, i);
        dprintf("%s    AceType %#x: ", pszPad, Ace.AceType);

        DumpAceType("", Ace.AceType);

        dprintf("%s    AceFlags %#x\n", pszPad, Ace.AceFlags);

        DumpAceFlags(szEvenMorePad, Ace.AceFlags);

        dprintf("%s    AceSize %lu\n", pszPad, Ace.AceSize);

        switch (Ace.AceType) {

        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:

            LsaReadMemory(addrAce, sizeof(KNOWN_ACE), &KnownAce );
            dprintf( "%s    AccessMask %#x\n", pszPad, KnownAce.Mask );
            addrSidStart = addrAce + sizeof(KNOWN_ACE) - sizeof(ULONG);
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            SkipSize = sizeof(KNOWN_OBJECT_ACE);
            LsaReadMemory(addrAce, SkipSize, pKnownObjectAce);
            dprintf("%s    AccessMask %#x\n", pszPad, pKnownObjectAce->Mask);
            dprintf("%s    Flags %#x\n", pszPad, pKnownObjectAce->Flags);
            DumpObjectAceFlags(szEvenMorePad, pKnownObjectAce->Flags);

            #if 0
            
            LsaReadMemory(
                addrAce, 
                sizeof(*pKnownObjectAce) 
                  + (RtlObjectAceObjectTypePresent(pKnownObjectAce) ? 1 : 0 ) * sizeof(GUID)
                  + (RtlObjectAceInheritedObjectTypePresent(pKnownObjectAce) ? 1 : 0) * sizeof(GUID), 
                pKnownObjectAce
                );

            #endif
            
            DisplayGuid = RtlObjectAceObjectType(pKnownObjectAce);

            if (DisplayGuid) {

                SkipSize += sizeof(GUID);

                LsaReadMemory(addrAce, SkipSize, pKnownObjectAce);

                dprintf("%s    ObjectGuid ", pszPad);
                LocalPrintGuid(DisplayGuid);
                dprintf(kstrNewLine);
            }
      
            DisplayGuid = RtlObjectAceInheritedObjectType(pKnownObjectAce);

            if (DisplayGuid) {

                SkipSize += sizeof(GUID);

                LsaReadMemory(addrAce, SkipSize, pKnownObjectAce);

                dprintf("%s    InheritedObjectGuid ", pszPad);
                LocalPrintGuid(DisplayGuid);
                dprintf(kstrNewLine);
            }

            addrSidStart = addrAce + SkipSize - sizeof(ULONG);
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            SkipSize = sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
            LsaReadMemory(addrAce, sizeof(COMPOUND_ACCESS_ALLOWED_ACE), &cAce);

            dprintf("%s    Mask %#x\n", pszPad, cAce.Mask);
            dprintf("%s    CompoundAceType %#x\n", pszPad, cAce.CompoundAceType);
            dprintf("%s    Reserved %#x\n", pszPad, cAce.Reserved);

            addrSidStart = addrAce + SkipSize - sizeof(ULONG);
            ShowSid(szMorePad, addrSidStart, fOptions);

            SkipSize = TSID(addrSidStart).GetSizeDirect();

            addrSidStart +=SkipSize;

            ShowSid(szMorePad, addrSidStart, fOptions);
            break;

        default:
            dprintf("%sUnsupported AceType %#x encountered... skipping\n", pszPad, Ace.AceType);
            break;
        }

        addrAce = addrAce + Ace.AceSize;

        ShowSid(szMorePad, addrSidStart, fOptions);
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdacl);
    dprintf(kstracl);
    dprintf(kstrOptions);
    dprintf(kstrhelp);
    dprintf(kstrSidName);
}

HRESULT ProcessAclOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(acl)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrAcl = 0;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessAclOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrAcl, &args) && addrAcl ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        try {

            dprintf("_ACL %#I64x\n", toPtr(addrAcl));

            (void)ShowAcl(kstrEmptyA, addrAcl, fOptions);

        } CATCH_LSAEXTS_EXCEPTIONS("Unable to display ACL", NULL)
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\cipher.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cipher.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       October 10, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "cipher.hxx"

#include <crypt.h>
#include <modes.h>
#include <rc4.h>
#include <des.h>

const ULONG kcbRandomKey = 256;
const ULONG kcbCredLockedMemorySize = sizeof(DESXTable) + kcbRandomKey;

#define CIPHER_ENCRYPT 0x10000000
#define CIPHER_DECRYPT 0x20000000
#define CIPHER_WEAK    0x40000000

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf("   Cipher [-ew] <addr> <cbCipher>  Decipher lsa protected memory\n");
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf("   -e   Encrypt (default to decrypt)\n");
    dprintf("   -w   Do weak unicode string encode/decode (default to LsaEncryptMemory)\n");
}

VOID
LsaEncryptMemory(
    IN DESXTable* pdesxTable,
    IN BYTE* pRandomKey,
    IN ULONG64* pfeedback,
    IN ULONG cbData,
    IN OUT BYTE* pData,
    int Operation
    )
{
    C_ASSERT(((DESX_BLOCKLEN % 8) == 0));

    if (pData == NULL || cbData == 0)
    {
        return;
    }

    if ((cbData & (DESX_BLOCKLEN - 1)) == 0)
    {
        ULONG BlockCount;

        BlockCount = cbData / DESX_BLOCKLEN;

        while (BlockCount--)
        {
            CBC(
                desx,                       // desx is the cipher routine
                DESX_BLOCKLEN,
                pData,                      // result buffer.
                pData,                      // input buffer.
                pdesxTable,
                Operation,
                (UCHAR*) pfeedback
                );

            pData += DESX_BLOCKLEN;
        }
    }
    else
    {
        RC4_KEYSTRUCT rc4key;

        rc4_key(&rc4key, kcbRandomKey, pRandomKey);
        rc4(&rc4key, cbData, pData);

        RtlZeroMemory(&rc4key, sizeof(rc4key));
    }
}

HRESULT ProcessCiperOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++)
    {
        if (*pszArgs == '-' || *pszArgs == '/')
        {
            switch (*++pszArgs)
            {
            case 'e':
                *pfOptions |=  CIPHER_ENCRYPT;
                break;

            case 'd':
               *pfOptions |=  CIPHER_DECRYPT;
               break;

            case 'w':
                *pfOptions |= CIPHER_WEAK;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(cipher)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 addrCipher = 0;
    ULONG64 temp = 0;
    ULONG64 feedback = 0;
    ULONG cbCipher = 0;
    ULONG fOptions = 0;

    CHAR pCredLockedMemory[kcbCredLockedMemorySize] = {0};
    CHAR pCipher[2048] = {0};
    CHAR szArgs[MAX_PATH] = {0};
    UNICODE_STRING Secret = {0};

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) -1);

    hRetval = args && *args ? ProcessCiperOptions(szArgs, &fOptions) : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetExpressionEx(szArgs, &addrCipher, &args) && addrCipher ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = GetExpressionEx(args, &temp, &args) && temp ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval))
    {
        cbCipher = (ULONG) temp;

        try
        {
            if (fOptions & CIPHER_WEAK)
            {
                UCHAR Seed = 0;
                SECURITY_SEED_AND_LENGTH* pSeedAndLength;
                pSeedAndLength = (SECURITY_SEED_AND_LENGTH*) &cbCipher;
                Seed = pSeedAndLength->Seed;

                if (cbCipher >= 0xFFFF)
                {
                    hRetval = E_INVALIDARG;
                }

                if (SUCCEEDED(hRetval))
                {
                    pSeedAndLength->Seed = 0;
                    cbCipher = pSeedAndLength->Length;

                    Secret.Length = Secret.MaximumLength = pSeedAndLength->Length;
                    Secret.Buffer = (WCHAR*) pCipher;

                    if (cbCipher > sizeof(pCipher))
                    {
                        dprintf("cbCipher is %#x, but lasexts can handle no more than %#x\n", cbCipher, sizeof(pCipher));
                        hRetval = E_FAIL;
                    }
                }

                if (SUCCEEDED(hRetval))
                {
                    LsaReadMemory(addrCipher, cbCipher, pCipher);

                    if (!(fOptions & CIPHER_ENCRYPT))
                    {
                        dprintf("Seed %#x, cbCipher %#x, pCipher %#I64x\n", Seed, cbCipher, addrCipher);

                        RtlRunDecodeUnicodeString(Seed, &Secret);
                    }
                    else
                    {
                        RtlRunEncodeUnicodeString(&Seed, &Secret);
                        dprintf("seed %#x\n", Seed);
                    }
                }
            }
            else
            {
                ULONG64 addrAddrCredLockedMemory = 0;
                ULONG64 addrFeedback = 0;
                ULONG64 addrCredLockedMemory = 0;

                DBG_LOG(LSA_LOG, ("ciper %#I64x, cbCipher %#I64x, hRetval %#x\n", addrCipher, temp, hRetval));

                if (cbCipher > sizeof(pCipher))
                {
                    dprintf("cbCipher is %d, but lasexts can handle no more than %d\n", cbCipher, sizeof(pCipher));
                    hRetval = E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    hRetval = GetExpressionEx("lsasrv!g_pDESXKey", &addrAddrCredLockedMemory, &args) ? S_OK : E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    hRetval = GetExpressionEx("LSASRV!g_Feedback", &addrFeedback, &args) ? S_OK : E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    if (!addrAddrCredLockedMemory || !addrFeedback)
                    {
                        DBG_LOG(LSA_ERROR, ("addrAddrCredLockedMemory %#I64, addrFeedback %#I64\n", addrAddrCredLockedMemory, addrFeedback));
                        dprintf("unable to read lsasrv!g_pDESXKey or Lsasrv!g_pFeedback\n");
                        hRetval = E_FAIL;
                    }
                }
                else
                {
                    dprintf("unable to read lsasrv!g_pDESXKey or Lsasrv!g_Feedback\n");
                }

                if (SUCCEEDED(hRetval))
                {
                    DBG_LOG(LSA_LOG, ("addrAddrCredLockedMemory %#I64\n", addrAddrCredLockedMemory));

                    addrCredLockedMemory = ReadPtrVar(addrAddrCredLockedMemory);

                    LsaReadMemory(addrCipher, cbCipher, pCipher);

                    LsaReadMemory(addrCredLockedMemory, kcbCredLockedMemorySize, pCredLockedMemory);
                    LsaReadMemory(addrFeedback, sizeof(feedback), &feedback);

                    dprintf("CBC desx lsasrv!g_pDESXKey %#I64x, Lsasrv!g_Feedback %#I64x\n", addrCredLockedMemory, feedback);

                    LsaEncryptMemory(
                        (DESXTable*) pCredLockedMemory,
                        (BYTE*) pCredLockedMemory + kcbCredLockedMemorySize - kcbRandomKey,
                        &feedback,
                        cbCipher,
                        (BYTE*) pCipher,
                        !(fOptions & CIPHER_ENCRYPT) ? DECRYPT : ENCRYPT
                        );
                }
            }

            if (SUCCEEDED(hRetval))
            {
                debugPrintHex(pCipher, cbCipher);
            }
        }
        CATCH_LSAEXTS_EXCEPTIONS("Unable to decrypt/encrypt cipher", NULL)
    }

    if (E_INVALIDARG == hRetval)
    {
        (void)DisplayUsage();
    }
    else if (FAILED(hRetval))
    {
        dprintf("failed to decode protected memory\n");
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\callinfo.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    callinfo.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "callinfo.hxx"
#include "util.hxx"
#include "token.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrclnf);
}

#if 0
#define SECPKG_CALL_KERNEL_MODE     0x00000001  // Call originated in kernel mode
#define SECPKG_CALL_ANSI            0x00000002  // Call came from ANSI stub
#define SECPKG_CALL_URGENT          0x00000004  // Call designated urgent
#define SECPKG_CALL_RECURSIVE       0x00000008  // Call is recursing
#define SECPKG_CALL_IN_PROC         0x00000010  // Call originated in process
#define SECPKG_CALL_CLEANUP         0x00000020  // Call is cleanup from a client
#define SECPKG_CALL_WOWCLIENT       0x00000040  // Call is from a WOW client process
#define SECPKG_CALL_THREAD_TERM     0x00000080  // Call is from a thread that has term'd
#define SECPKG_CALL_PROCESS_TERM    0x00000100  // Call is from a process that has term'd
#define SECPKG_CALL_IS_TCB          0x00000200  // Call is from TCB
#endif

PCSTR g_cszCallInfoFlags[] = {
    "Kernel", "Ansi", "Urgent", "Recursive",
    "InProc", "Cleanup", "WowClient", "ThreadTerm",
    "ProcessTerm", "TcbPriv", kstrEmptyA};

#if 0
#define CALL_FLAG_IMPERSONATING 0x00000001
#define CALL_FLAG_IN_PROC_CALL  0x00000002
#define CALL_FLAG_SUPRESS_AUDIT 0x00000004
#define CALL_FLAG_NO_HANDLE_CHK 0x00000008
#define CALL_FLAG_KERNEL_POOL   0x00000010  // Kernel mode call, using pool
#define CALL_FLAG_KMAP_USED     0x00000020  // KMap is valid
#endif

PCSTR g_cszLsaCallInfoFlags[] = {
    "Impersonating", "InProcCall", "SupressAudits",
    "NoHandleCheck", "KernelPool", "KMap"};

void ShowCallInfo(IN ULONG64 addrCallInfo)
{
    CHAR szFlags[128] = {0};

    ULONG Attributes = 0;
    ULONG Flags = 0;
    ULONG Allocs = 0;
    ULONG fieldOffset = 0;

    ULONG PtrSize = 0;

    if (!addrCallInfo) {

        throw "addrCallInfo is null";
    }

    LsaInitTypeRead(addrCallInfo, _LSA_CALL_INFO);

    Attributes = LsaReadULONGField(CallInfo.Attributes);

    DisplayFlags(Attributes, COUNTOF(g_cszCallInfoFlags), g_cszCallInfoFlags, sizeof(szFlags), szFlags);

    dprintf(kstrTypeAddrLn, kstrCallInfo, addrCallInfo);
    dprintf("  Message              %s\n", PtrToStr(LsaReadPtrField(Message)));
    dprintf("  Session              %s\n", PtrToStr(LsaReadPtrField(Session)));
    dprintf("  CallInfo             _SECPKG_CALL_INFO %s\n", PtrToStr(addrCallInfo + ReadFieldOffset(kstrCallInfo, "CallInfo")));
    dprintf("    ThreadId           %#x\n", LsaReadULONGField(CallInfo.ThreadId));
    dprintf("    ProcessId          %#x\n", LsaReadULONGField(CallInfo.ProcessId));
    dprintf("    Attribs            %#x : %s\n", Attributes, szFlags);
    dprintf("  Impersonating        %s\n", LsaReadUCHARField(Impersonating) ? "true" : "false");
    dprintf("  ImpersonateLevel     %s\n", ImpLevel(LsaReadULONGField(ImpersonationLevel)));
    dprintf("  CachedTokenInfo      %s\n", LsaReadUCHARField(CachedTokenInfo) ? "true" : "false");
    dprintf("  Restricted           %s\n", LsaReadUCHARField(Restricted) ? "true" : "false");
    dprintf("  LogonId              %#x:%#x\n", LsaReadULONGField(LogonId.HighPart), LsaReadULONGField(LogonId.LowPart));
    dprintf("  InProcToken          %s\n", PtrToStr(LsaReadPtrField(InProcToken)));
    dprintf("  InProcCall           %x\n", LsaReadUCHARField(InProcCall));

    Flags = LsaReadULONGField(Flags);

    DisplayFlags(Flags, COUNTOF(g_cszCallInfoFlags), g_cszLsaCallInfoFlags, sizeof(szFlags), szFlags);

    dprintf("  Flags                %#x : %s\n", Flags, szFlags );

    Allocs = LsaReadULONGField(Allocs);
    dprintf("  Allocs               %d\n", Allocs);

    fieldOffset = ReadFieldOffset(kstrCallInfo, "Buffers");
    PtrSize = ReadPtrSize();

    for (ULONG i = 0 ; i < Allocs ; i++ )
    {
        dprintf("    Buffers[%d]         %#I64x\n", i, ReadPtrVar(addrCallInfo + fieldOffset + i * PtrSize));
    }

    dprintf("  KMap                 %s\n", PtrToStr(LsaReadPtrField(KMap)));
}

DECLARE_API(dumpcallinfo)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrCallInfo = 0;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    try {

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(args, &addrCallInfo, &args) && addrCallInfo ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval)) {

            ShowCallInfo(addrCallInfo);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display call info", kstrCallInfo);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dbgmask.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dbgmask.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       June 1, 2002

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dbgmask.hxx"

static void DisplayUsage(
    void
    )
{
    dprintf(kstrUsage);
    dprintf("   dbgmask [<mask>]                        Change debug mask\n");
}

HRESULT 
ProcessDbgMaskOptions(
    IN OUT PSTR pszArgs, 
    IN OUT ULONG* pfOptions
    )
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {


            // case '1': // allow -1 pseudo handle
            //    continue;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dbgmask)
{
    HRESULT hRetval = S_OK;
    
    ULONG64 Mask = -1;
    BOOLEAN bShowMaskOnly = TRUE;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    if (args && *args) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessDbgMaskOptions(szArgs, &fOptions);

        if (SUCCEEDED(hRetval)) {
            
            if (!IsEmpty(szArgs)) {

                bShowMaskOnly = FALSE;
                hRetval = GetExpressionEx(szArgs, &Mask, &args) ? S_OK : E_INVALIDARG;
            }         
        }
    }

    if (SUCCEEDED(hRetval)) {

#if defined(DBG)

        dprintf("g_Globals.uDebugMask %#x", g_Globals.uDebugMask); 

        if (!bShowMaskOnly) {
            g_Globals.uDebugMask = (ULONG) Mask;
            dprintf(" is changed to %#x", g_Globals.uDebugMask); 
        }

        dprintf("\n");
#else
  
        dprintf("This is a free build, no debug mask support\n");

#endif
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dlpcmsg.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dtlpx.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dtlpc.hxx"
#include "util.hxx"
#include "spmlpc.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdlpcm);
    dprintf(kstrsplpc);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrBrief);
}

HRESULT ProcessSpmlpcMsgOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 's':
                *pfOptions |=  SHOW_SUMMARY_ONLLY;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumplpcmessage)
{
    HRESULT hRetval = E_FAIL;
    PCSTR pszDontCare = NULL;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;
    ULONG64 addrMessage = 0;

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) - 1);

    hRetval = ProcessSpmlpcMsgOptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval)) {

        hRetval = !IsEmpty(szArgs) && GetExpressionEx(szArgs, &addrMessage, &pszDontCare) && addrMessage ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = spmlpc(Client, args);
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dtkn.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dtkn.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dtkn.hxx"
#include "util.hxx"
#include "token.hxx"
#include "sid.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdtkn);
    dprintf(kstrtkn);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
}

HRESULT ProcessDumpTokenOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumptoken)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrToken = 0;
    PCSTR pszDontCare = NULL;

    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessDumpTokenOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrToken, &pszDontCare) && addrToken ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = token(Client, args);
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dtlpc.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dtlpx.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dtlpc.hxx"
#include "util.hxx"
#include "spmlpc.hxx"
#include "secb.hxx"
#include "dlpcmsg.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdtlpc);
    dprintf(kstrsplpc);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrBrief);
}

HRESULT ProcessThreadSpmlpcOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 's':
                *pfOptions |=  SHOW_SUMMARY_ONLLY;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumpthreadlpc)
{
    HRESULT hRetval = E_FAIL;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) - 1);

    hRetval = ProcessThreadSpmlpcOptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval)) {

        hRetval = IsEmpty(szArgs) ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = spmlpc(Client, args);
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\globals.cxx ===
/*++

Copyright (C) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    globals.cxx

Abstract:

    Holds global definitions

Author:

    Larry Zhu (LZhu)                May 1, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#define _GLOBALS
#include "globals.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dlpcr.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dlpcr.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dlpcr.hxx"
#include "util.hxx"

#include "spmlpc.hxx"

#define SHOW_INTERNAL_LPC_LOG        0x1
#define SHOW_LPC_LOG_BY_MESSAGE_ID   0x2

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdlpcr);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf("   -i   Display internal API log (instead of LPC API log)\n");
    dprintf("   -m   Display API log by message id\n");

}

HRESULT ProcessLPCROptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'i':
                *pfOptions |=  SHOW_INTERNAL_LPC_LOG;
                break;

            case 'm':
                *pfOptions |= SHOW_LPC_LOG_BY_MESSAGE_ID;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

void ShowLpcDispatchRecord(IN ULONG64 addrLog, IN ULONG fOptions, IN ULONG ulMessageIdTarget)
{
    CHAR szField[64] = {0};
    CHAR szTimebuf[128] = {0};
    CHAR timebuf2[64] = {0};
    ULONG ulMessageId = 0;
    ULONG ulCurrent = 0;
    ULONG ulThreadId = 0;
    ULONG ulTotalSize = 0;
    ULONG64 addrLogEntry = 0;
    ULONG64 addrMessage = 0;
    BOOLEAN bLoop = TRUE;

    if (!addrLog) {

        throw "Invalid LPC LOG";
    }

    // dprintf(kstrTypeAddrLn, kstrSapApiLog, addrLog);

    dprintf("\nMessageId Status and Time\n");

    ReadStructField(addrLog, kstrSapApiLog, "TotalSize", sizeof(ulTotalSize), &ulTotalSize);
    ReadStructField(addrLog, kstrSapApiLog, "Current", sizeof(ulCurrent), &ulCurrent);

    for (ULONG i = 0; bLoop && (i < ulTotalSize); i++) {

        ExitIfControlC();

        _snprintf(szField, sizeof(szField) - 1, "Entries[%#x]", i);
        addrLogEntry = addrLog + ReadFieldOffset(kstrSapApiLog, szField);

        LsaInitTypeRead(addrLogEntry, lsasrv!_LSAP_API_LOG_ENTRY);

        ulMessageId = LsaReadULONGField(MessageId);

        if (fOptions & SHOW_LPC_LOG_BY_MESSAGE_ID) {

            if (ulMessageId != ulMessageIdTarget) {
                continue;
            } else {
                bLoop = FALSE;
            }
        }

        dprintf("%08x%c ", ulMessageId, (i == ulCurrent ? '*' : ' '));

        ulThreadId = LsaReadULONGField(ThreadId);

        addrMessage = LsaReadPtrField(pvMessage);

        if (!ulThreadId) {

            CTimeStampFromULONG64(LsaReadULONG64Field(QueueTime), TRUE, sizeof(szTimebuf) - 1, szTimebuf);
            dprintf("Queued, Message %s, Task %s, QueueTime %s\n",
                PtrToStr(addrMessage),
                PtrToStr(LsaReadPtrField(WorkItem)),
                szTimebuf);

        } else if (ulThreadId == 0xFFFFFFFF) {

            ElapsedTimeAsULONG64ToString(LsaReadULONG64Field(WorkTime), sizeof(szTimebuf) - 1, szTimebuf);

            dprintf("Completed, (%s, Task %s), WorkTime %s\n", ApiName(static_cast<ULONG>(addrMessage)), PtrToStr(LsaReadPtrField(WorkItem)), szTimebuf);

        } else {

            CTimeStampFromULONG64(LsaReadULONG64Field(WorkTime), TRUE, sizeof(szTimebuf) - 1, szTimebuf);
            dprintf("Active, Thread cid %#x, Message %s, WorkTime %s\n", ulThreadId, PtrToStr(addrMessage), szTimebuf);
        }
    }

    if (fOptions & SHOW_LPC_LOG_BY_MESSAGE_ID) {
       if (!bLoop) {    // found it
           if (ulThreadId != 0xFFFFFFFF && ulThreadId) {

               dprintf("\nmatching entry: ");
               dprintf(kstrTypeAddrLn, "lsasrv!_LSAP_API_LOG_ENTRY", addrLogEntry);
               dprintf("lpc message id: %#x\nlsass thread cid: %#x\n", ulMessageIdTarget, ulThreadId);
           }
       } else {
           dprintf("\nno lsa thread is found working on message %#x\n", ulMessageIdTarget);
       }
    }
}

DECLARE_API(dlpcr)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};
    PCSTR pszApiLog = LPC_APILOG;

    ULONG64 addrAddrLog = 0;
    ULONG64 addrLog = 0;
    ULONG64 MessageIdTarget = 0;

    if (args && *args) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);
    }

    hRetval = ProcessLPCROptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval)) {

        pszApiLog = (fOptions & SHOW_INTERNAL_LPC_LOG) ? INTERNAL_APILOG : LPC_APILOG;

        DBG_LOG(LSA_LOG, ("Displaying LPC records for %s\n", pszApiLog));

        hRetval = GetExpressionEx(pszApiLog, &addrAddrLog, &args) ? S_OK : E_FAIL;

        if (SUCCEEDED(hRetval) && !addrAddrLog)
        {
            dprintf("no LPC records found, verify symbols by \"dt -x %s\"\n", pszApiLog);
            hRetval = E_FAIL;
        }

        if (SUCCEEDED(hRetval) && (fOptions & SHOW_LPC_LOG_BY_MESSAGE_ID)) {
            hRetval = GetExpressionEx(szArgs, &MessageIdTarget, &args) && MessageIdTarget ? S_OK : E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hRetval)) {

        try {

            addrLog = ReadPtrVar(addrAddrLog);

            dprintf("Displaying %s: %s %s\n", pszApiLog, kstrSapApiLog, PtrToStr(toPtr(addrLog)));

            (void)ShowLpcDispatchRecord(addrLog, fOptions, static_cast<ULONG>(MessageIdTarget));

        } CATCH_LSAEXTS_EXCEPTIONS("Unable to display lpc dispatch records", kstrSapApiLog)
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\dttkn.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dttkn.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dttkn.hxx"
#include "util.hxx"
#include "token.hxx"
#include "sid.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdttkn);
    dprintf(kstrtkn);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
    dprintf(kstrVerbose);
}

HRESULT ProcessDumpThreadTokenOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;
            case 'v':
                *pfOptions |= SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumpthreadtoken)
{
    HRESULT hRetval = S_OK;

    ULONG64 addrThread = 0;
    ULONG64 addrToken = 0;
    ULONG64 addrProcess = 0;
    ULONG ActiveImpersonationInfo = 0;
    ULONG64 addrImpersonationInfo = 0;

    ULONG dwProcessor = 0;
    ULONG SessionType = DEBUG_CLASS_UNINITIALIZED;
    ULONG SessionQual = 0;

    CHAR szArgs[MAX_PATH] = {0};
    PCSTR pszDontCare = NULL;
    ULONG fOptions = 0;

    if (args && *args) {
        strncpy(szArgs, args, sizeof(szArgs) - 1);
        hRetval = ProcessDumpThreadTokenOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = ExtQuery(Client);
    }

    if (SUCCEEDED(hRetval)) {

       hRetval = g_ExtControl->GetDebuggeeType(&SessionType, &SessionQual);
    }

    if (SUCCEEDED(hRetval)) {

         if (DEBUG_CLASS_KERNEL == SessionType) {

            if (!IsEmpty(szArgs)) {

                hRetval = GetExpressionEx(szArgs, &addrThread, &pszDontCare) && addrThread ? S_OK : E_INVALIDARG;
            }

            if (SUCCEEDED(hRetval))
            {
                if (!addrThread) {

                    hRetval = GetCurrentProcessor(Client, &dwProcessor, NULL);
    
                    if (SUCCEEDED(hRetval)) {
                        GetCurrentThreadAddr(dwProcessor, &addrThread);
                        hRetval = IsAddressInNonePAEKernelAddressSpace(addrThread) ? S_OK : E_FAIL;
                    } 
                } else {
                    hRetval = IsAddressInNonePAEKernelAddressSpace(addrThread) ? S_OK : E_FAIL;
                }
            }

            try {
           
                if (SUCCEEDED(hRetval)) {
    
                    addrThread &= ~((ULONG64) ( IsPtr64() ? 0xF : 7 ));

                    //
                    // ActiveImpersonationInfo is of type C Bit Fields and has a width of 1 (Bitfield Pos 3, 1 Bit)
                    //
        
                    LsaInitTypeRead(addrThread, nt!_ETHREAD);
                    ActiveImpersonationInfo = LsaReadULONGField(ActiveImpersonationInfo);
                    
                    if (ActiveImpersonationInfo) {
                    
                        addrImpersonationInfo = ReadStructPtrField(addrThread, "nt!_ETHREAD", "ImpersonationInfo");
                    }
                    
                    if (addrImpersonationInfo) {
                    
                        LsaInitTypeRead(addrImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);
                    
                        addrToken = LsaReadPtrField(Token);
                    
                        dprintf("nt!_PS_IMPERSONATION_INFORMATION %#I64x\n    Token: %#I64x\n    CopyOnOpen: %s\n    EffectiveOnly: %s\n    ImpersonationLevel: %s\n",
                            addrImpersonationInfo,
                            addrToken,
                            LsaReadUCHARField(CopyOnOpen) ? "true" : "false", 
                            LsaReadUCHARField(EffectiveOnly) ? "true" : "false", 
                            ImpLevel(LsaReadULONGField(ImpersonationLevel)));                           
                    }               

                    //
                    //  If addrToken is NULL, then this is not an impersonation case
                    //

                    if (SUCCEEDED(hRetval)) {

                        if (!addrToken) {

                            if (!addrThread) {
                                dprintf("Thread is not impersonating. Using process token...\n");
                                GetCurrentProcessAddr(dwProcessor, addrThread, &addrProcess);
                                addrProcess &= ~((ULONG64) ( IsPtr64() ? 0xF : 7 ));
                                hRetval = IsAddressInNonePAEKernelAddressSpace(addrProcess) ? S_OK : E_FAIL;
        
                                if (FAILED(hRetval)) {
        
                                    dprintf("Unable to read current process address\n");
        
                                } else {
        
                                    addrToken = ReadStructPtrField(addrProcess, "nt!_EPROCESS", "Token");
        
                                    hRetval = IsAddressInNonePAEKernelAddressSpace(addrToken) ? S_OK : E_FAIL;
                                }
                            } else {
                                dprintf("Thread _ETHREAD %#I64x is not impersonating\n", toPtr(addrThread));
                                hRetval = E_FAIL;
                            }

                        } else {
                            hRetval = IsAddressInNonePAEKernelAddressSpace(addrToken) ? S_OK : E_FAIL;
                        }
                    }

                    if (SUCCEEDED(hRetval)) {

                        if (addrProcess) {
                    
                            dprintf("_EPROCESS %#I64x, ", toPtr(addrProcess));
                        }
                    
                        if (addrThread) {
                    
                            dprintf("_ETHREAD %#I64x, ", toPtr(addrThread));
                        }
                    
                        dprintf(kstrTypeAddrLn, kstrTkn, toPtr(addrToken));
                    
                        (void)DisplayToken(addrToken, fOptions);
                    }                 
                }
            } CATCH_LSAEXTS_EXCEPTIONS("Unable to display thread token", kstrTkn)
        } else {
            hRetval = IsEmpty(szArgs) ? S_OK : E_INVALIDARG;

            if (SUCCEEDED(hRetval)) {
                hRetval = token(Client, args);
            }
        } 
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    } else if (FAILED(hRetval)) {
        dprintf("Unable to display thread token\n");
    }

    (void)ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\help.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode / Kernel Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "help.hxx"
#include "sid.hxx"

DECLARE_API(help)
{
    dprintf("SPM Debug Commands (use -? on individual commands to get additional help):\n");
    dprintf(kstrberd);
    dprintf(kstrdacl);
    dprintf(kstrclnf);
    dprintf(kstrdhtbl);
    dprintf(kstrlssn);
    dprintf(kstrlssnl);
    dprintf(kstrdlpcr);
    dprintf(kstrlhdl);
    dprintf(kstrlsahl);
    dprintf(kstrlhtbl);
    dprintf(kstrdsidc);
    dprintf(kstrdlpcm);
    dprintf(kstrdpkg);
    dprintf(kstrdsb);
    dprintf(kstrdsbd);
    dprintf(kstrdsd);
    dprintf(kstrdssn);
    dprintf(kstrdssnl);
    dprintf(kstrdsid);
    dprintf(kstrtclnf);
    dprintf(kstrdtlpc);
    dprintf(kstrdtssn);
    dprintf(kstrdttkn);
    dprintf(kstrdtkn);
    dprintf(kstrgtls);
    dprintf(kstrhelp);
    dprintf(kstrkch);
    dprintf(kstrkchl);
    dprintf(kstrkrbnm);
    dprintf(kstrkrbss);
    dprintf(kstrnm2sd);
    dprintf(kstrntlm);
    dprintf(kstrobjs);
    dprintf(kstrsd2nm);

    dprintf("\nShortcuts:\n");
    dprintf("   acl             DumpAcl\n");
    dprintf("   ber             BERDecode\n");
    dprintf("   sb              DumpSecBuffer\n");
    dprintf("   sbd             DumpSecBufferDesc\n");
    dprintf("   sd              DumpSD\n");
    dprintf("   sess            DumpSession\n");
    dprintf("   sid             DumpSid\n");
    dprintf("   spmlpc          DumpThreadLpc and DumpLpcMessage\n");
    dprintf("   task            DumpThreadTask\n");
    dprintf("   tls             GetTls\n");
    dprintf("   token           DumpThreadToken and DumpToken\n");

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\handle.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "handle.hxx"
#include "util.hxx"

#include <sht.hxx>
#include <lht.hxx>

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdhtbl);
}

PCSTR g_cszLhtFlags[] = {
    "NoSerialize", "Callback", "Unique",
    "Child", "LimitDepth", "DeletePending", "NoFree"};

PCSTR g_cszShtFlags[] = {
    "NoSerialize", "Callback", "Unique",
    "NoFree", "DeletePending"};

PCSTR g_cszSecHandleFlags[] = {
    "Locked", "DeletePending", "NoCallback"};

void ShowSmallTable(IN ULONG64 addrSmallTable, IN ULONG Indent)
{
    CHAR szBuffer[64] = {0};
    CHAR szIndentString[80] = {0};

    ULONG64 Disp = 0;
    ULONG64 addr = 0;
    ULONG64 addrListAnchor = 0;

    ULONG Flags = 0;
    ULONG Count = 0;
    ULONG i = 0;

    TSHT sht(addrSmallTable);

    ExitIfControlC();

    for (i = 0; i < Indent; i++)
    {
        szIndentString[i] = ' ';
    }

    szIndentString[Indent] = '\0' ;


    Flags = sht.GetFlags();
    Count = sht.GetCount();
    addrListAnchor = sht.GetHandleListAnchor();

    DisplayFlags(Flags, COUNTOF(g_cszShtFlags), g_cszShtFlags, sizeof(szBuffer), szBuffer);

    dprintf(kstrTypeAddrLn, kstrSHT, addrSmallTable);
    dprintf("%s  Flags           %x : %s\n", szIndentString, Flags, szBuffer);
    dprintf("%s  Count           %d\n", szIndentString, Count);
    dprintf("%s  Pending         %s\n", szIndentString, PtrToStr(sht.GetPendingHandle()));
    dprintf("%s  ListAnchor      %#I64x\n", szIndentString, sht.GetHandleListAnchor());

    addr = ReadPtrVar(addrListAnchor);

    for (i = 0; (addr != addrListAnchor) && (i < Count); i++)
    {
        LsaInitTypeRead(addr, _SEC_HANDLE_ENTRY);
        Flags = LsaReadULONGField(Flags);
        DisplayFlags(Flags, COUNTOF(g_cszSecHandleFlags), g_cszSecHandleFlags, sizeof(szBuffer), szBuffer);

        dprintf("%s    #%d) %s %#I64x: Handle %#I64x:%#I64x, HandleCount %#x, HandleIssuedCount %#x, ctxt %#I64x, ref %d, flags %#x : %s\n",
            szIndentString, i, kstrHdlEntry, addr,
            LsaReadPtrField(Handle.dwUpper),
            LsaReadPtrField(Handle.dwLower),
            LsaReadULONGField(HandleCount),
            LsaReadULONGField(HandleIssuedCount),
            LsaReadPtrField(Context),
            LsaReadULONGField(RefCount),
            Flags,
            szBuffer);
        addr = LsaReadPtrField(List.Flink);
    }

    if ((i < Count) || (addr != addrListAnchor))
    {
        dprintf("Warning! List does not contain \"Count\" number of entries, memory might be corrupted\n");
    }

    addr = sht.GetDeleteCallback();

    if (addr)
    {
        GetSymbol(addr, szBuffer, &Disp);
        dprintf( "%s  Callback        %s\n", szIndentString, GetSymbolStr(addr, szBuffer));
    }
}

void ShowLargeTable(IN ULONG64 addrLargeTable, IN ULONG Indent)
{
    ULONG64 addrSubTable ;

    CHAR szBuffer[64] = {0};
    CHAR szIndentString[64] = {0};

    ULONG Flags = 0;
    ULONG64 Disp = 0;
    ULONG64 addr = 0;

    TLHT lht(addrLargeTable);

    ExitIfControlC();

    for (ULONG i = 0; i < Indent; i++)
    {
        szIndentString[i] = ' ';
    }

    szIndentString[Indent] = '\0';

    Flags = lht.GetFlags();

    DisplayFlags(Flags, COUNTOF(g_cszLhtFlags), g_cszLhtFlags, sizeof(szBuffer), szBuffer);

    dprintf(kstrTypeAddrLn, kstrLHT, addrLargeTable);
    dprintf("%s  Flags           %x : %s\n", szIndentString, Flags, szBuffer);
    dprintf("%s  Depth           %d\n", szIndentString, lht.GetDepth());
    dprintf("%s  Parent          %s\n", szIndentString, PtrToStr(lht.GetParent()));
    dprintf("%s  Count           %d\n", szIndentString, lht.GetCount());

    addr = lht.GetDeleteCallback();

    if (addr)
    {
        GetSymbol(addr, szBuffer, &Disp);
        dprintf( "%s  Callback        %s\n", szIndentString, GetSymbolStr(addr, szBuffer));
    }

    dprintf("%s  Lists\n", szIndentString);

    for (ULONG i = 0; i < HANDLE_TABLE_SIZE; i++)
    {
        Flags = lht.GetListsFlags(i);

        if (Flags & LHT_SUB_TABLE)
        {
            if (Flags & (~LHT_SUB_TABLE))
            {
                dprintf("%s    CORRUPT\n", szIndentString);
            }
            else
            {
                addr = lht.GetListsFlink(i);

                dprintf("%s    %x : Sub Table at %s\n", szIndentString, i, PtrToStr(addr));

                PrintSpaces(Indent + 4);

                dprintf("#%d) ", i);

                ShowLargeTable(addr, Indent + 4);
            }
        }
        else
        {
            PrintSpaces(Indent + 4);

            dprintf("#%d) ", i);

            ShowSmallTable(lht.GetAddrLists(i), Indent + 4);
        }
    }
}

DECLARE_API(dumphandletable)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrHandleTable = 0;

    ULONG Tag = 0;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    try
    {
        if (SUCCEEDED(hRetval))
        {
            hRetval = GetExpressionEx(args, &addrHandleTable, &args) && addrHandleTable ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval))
        {
            Tag = ReadULONGVar(addrHandleTable);

            if (Tag == LHT_TAG)
            {
                ShowLargeTable(addrHandleTable, 0);
            }
            else if (Tag == SHT_TAG)
            {
                ShowSmallTable(addrHandleTable, 0);
            }
            else
            {
                dprintf("%#I64x - not a handle table\n", addrHandleTable);
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display handle table", kstrLHT);

    if (E_INVALIDARG == hRetval)
    {
        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\kerbcachelist.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kerbcachelist.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       August 10, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "kerbcache.hxx"
#include "kerbcachelist.hxx"

#include "util.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrkchl);
}

DECLARE_API(kerbcachelist)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 addrCacheAnchor = 0;
    ULONG64 addrCacheEntry = 0;
    ULONG ulFieldOffset = 0;
    ULONG cCacheEntries = 0;

    hRetval = args && *args ? ProcessHelpRequest(args) : E_INVALIDARG;

    try {

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(args, &addrCacheAnchor, &args) && addrCacheAnchor ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval)) {

            addrCacheEntry = ReadStructPtrField(addrCacheAnchor, kstrListEntry, kstrFlink);

            ulFieldOffset = ReadFieldOffset(kstrKTCE, "ListEntry.Next");

            while (addrCacheEntry != addrCacheAnchor) {

                dprintf("#%d) ", cCacheEntries++);

                ShowKerbTCacheEntry(kstr2Spaces, addrCacheEntry);

                addrCacheEntry = ReadStructPtrField(addrCacheEntry, kstrKTCE, "ListEntry.Next") - ulFieldOffset;
            }

            dprintf("There are a total of %d ticket cache entries\n", cCacheEntries);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display kerberos cache list", kstrKTCE);

    if (E_INVALIDARG == hRetval) {
        (void)DisplayUsage();
    } else if (FAILED(hRetval)) {
        dprintf("Fail to display kerberos cache list\n");
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\list.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    list.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       January 10, 2002

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "list.hxx"

LIST_ENTRY g_SummaryAnchor;
BOOLEAN g_bSummaryOnly;
ULONG64 g_KeyOffset; // offset used to match
ULONG64 g_KeyLength; // key length
ULONG64 g_KeyValue;  // key value
ULONG g_cEntries;

BOOL
UpdateSummary(
    IN ULONG64 Value
    )
{
    SUMMARY_NODE* NextNode;
    LIST_ENTRY* Next;

    for (Next = g_SummaryAnchor.Flink;
         Next != &g_SummaryAnchor; Next = Next->Flink) {
        NextNode = CONTAINING_RECORD(Next, SUMMARY_NODE, ListEntry);
        DBG_LOG(LSA_LOG, ("Examing existing node with %#I64x, for %#I64x, cEntries %#x\n",
                NextNode->KeyValue, Value, NextNode->cEntries));
        if (Value == NextNode->KeyValue) {
            NextNode->cEntries++;
            DBG_LOG(LSA_LOG, ("Updated existing node for %#I64x, cEntries %#x\n",
                Value, NextNode->cEntries));
            return TRUE;
        } else if (Value < NextNode->KeyValue) {
            break;
        }
    }

    NextNode = CONTAINING_RECORD(Next, SUMMARY_NODE, ListEntry);

    SUMMARY_NODE* NewNode = new SUMMARY_NODE();
    if (!NewNode) {
        dprintf("UpdateSummary out of memory\n");
        return FALSE;
    }

    NewNode->KeyValue = Value;
    NewNode->cEntries = 1;
    InsertTailList(&NextNode->ListEntry, &NewNode->ListEntry);

    DBG_LOG(LSA_LOG, ("Created node for %#I64x, cEntries %#x\n", Value, NewNode->cEntries));

    return TRUE;
}

VOID
DisplaySummaryList(
    VOID
    )
{
    if (!IsListEmpty(&g_SummaryAnchor)) {
        dprintf("\nKey \tEntries\n\n");
    }
    for (LIST_ENTRY* Current = g_SummaryAnchor.Flink;
            Current != &g_SummaryAnchor; Current = Current->Flink) {
        SUMMARY_NODE* Node = CONTAINING_RECORD(Current, SUMMARY_NODE, ListEntry);
        dprintf("%#I64x \t%#x\n", Node->KeyValue, Node->cEntries);
    }
    dprintf("\ntotal entries %#x\n", g_cEntries);
}

VOID
ReleaseSummaryList(
    VOID
    )
{
    for (LIST_ENTRY* Current = g_SummaryAnchor.Flink;
         Current != &g_SummaryAnchor; /* empty */) {
        SUMMARY_NODE* Node = CONTAINING_RECORD(Current, SUMMARY_NODE, ListEntry);
        Current = Current->Flink;
        RemoveEntryList(&Node->ListEntry);
        delete Node;
    }
}

ULONG
ListCallback(
    IN PFIELD_INFO Field,
    IN PVOID Context
    )
{
    CHAR  Execute[MAX_PATH] = {0};
    PCHAR Buffer;
    PLIST_TYPE_PARAMS pListParams = (PLIST_TYPE_PARAMS) Context;
    ULONG64 Value = 0;
    BOOLEAN Skip = FALSE;

    if (g_KeyOffset != -1) {

        if (!ReadMemory(
            Field->address + g_KeyOffset,
            &Value,
            (ULONG) min(g_KeyLength, sizeof(Value)),
            NULL)) {
            dprintf("failed to read at %I64x\n", Field->address);
            return TRUE;
        }

        DBG_LOG(LSA_LOG, ("Filtering %#I64x value %#I64x with offset %#I64x len %#I64x value %#I64x\n",
            Field->address,
            Value,
            g_KeyOffset,
            g_KeyLength,
            g_KeyValue));

        if (g_bSummaryOnly) {
            g_cEntries++;

            if (!UpdateSummary(Value)) {
                return TRUE;
            } else {
                Skip = TRUE;
            }
        }

        if (!Skip && Value != g_KeyValue) {
            Skip = TRUE;
        }
    }

    if (!Skip && g_bSummaryOnly) {
        g_cEntries++;
        Skip = TRUE;
    }

    if (!Skip) {

        g_cEntries++;

        // Execute command
        _snprintf(Execute, sizeof(Execute) - 1,
            "%s %I64lx %s",
            pListParams->Command,
            Field->address, // - pListParams->FieldOffset,
            pListParams->CommandArgs);

        DBG_LOG(LSA_LOG, ("ListCallback execute %s\n", Execute));

        dprintf("Examining node at %p\n", Field->address);

        g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT, Execute, DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
    }

    if (CheckControlC()) {
        return TRUE;
    }

    return FALSE;
}

VOID
ReleaseArgumentList(
    IN ULONG cArgs,
    IN PCSTR* ppszArgs
    )
{
    if (ppszArgs) {
        for (ULONG i = 0; i < cArgs; i++) {
            delete  [] ppszArgs[i];
        }
        delete [] ppszArgs;
    }
}

HRESULT
String2ArgumentList(
    IN PCSTR pszArgs,
    OUT ULONG* pcArgs,
    OUT PCSTR** pppszArgs
    )
{
    HRESULT hRetval = S_OK;

    ULONG cArgs = 0;
    PCSTR* ppszArgs = NULL;
    PCSTR pszSave = pszArgs;

    *pcArgs = NULL;
    *pppszArgs = NULL;

    // DBG_LOG(LSA_LOG, ("String2ArgumentList %s\n", pszArgs));

    while (pszArgs && *pszArgs) {
        SKIP_WSPACE(pszArgs);
        ++cArgs;

        // DBG_LOG(LSA_LOG, ("String2ArgumentList #1 %s\n", pszArgs));

        // check for quote
        if (*pszArgs == '"') {
            ++pszArgs;
            if (*pszArgs == '"') {
                continue;
            }
            while (*pszArgs && (*pszArgs++ != '"')) /* empty */;
            if (*(pszArgs - 1) != '"') {
                hRetval = E_INVALIDARG;
                goto Cleanup;
            }
        } else {
            SKIP_NON_WSPACE(pszArgs);
        }
    }

    if (cArgs) {
        pszArgs = pszSave;
        ppszArgs = new PCSTR[cArgs];

        if (!ppszArgs) {
            hRetval = E_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(ppszArgs, cArgs * sizeof(PCSTR));

        ULONG argc = 0;

        while (pszArgs && *pszArgs) {
            SKIP_WSPACE(pszArgs);

            PCSTR pStart = pszArgs;
            PCSTR pEnd = pStart;

            // check for quote
            if (*pszArgs == '"') {
                ++pszArgs;
                pStart = pszArgs;
                if (*pszArgs == '"') {
                    pEnd = pStart;
                } else {
                    while (*pszArgs && (*pszArgs++ != '"')) /* empty */;

                    pEnd = pszArgs - 1;
                }
            } else {
                SKIP_NON_WSPACE(pszArgs);
                pEnd = pszArgs;
            }

            PSTR pszItem = new CHAR[pEnd - pStart + 1];

            if (!pszItem) {
                // DBG_LOG(LSA_ERROR, ("String2ArgumentList out of memory, pStart %p pEnd %p %#x\n", pStart, pEnd, pEnd - pStart + 1));
                hRetval = E_OUTOFMEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                pszItem,
                pStart,
                pEnd - pStart
                );

            pszItem[pEnd - pStart] = '\0';

            ppszArgs[argc] = pszItem;

            ++argc;

            // DBG_LOG(LSA_LOG, ("String2ArgumentList #2 %s\n", pszArgs));
        }
    }

    *pppszArgs = ppszArgs;
    *pcArgs = cArgs;

    #if 0
    DBG_LOG(LSA_LOG, ("String2ArgumentList argc %#x, argv %p\n", cArgs, ppszArgs));

    for (ULONG i = 0; i < cArgs; i++) {
        DBG_LOG(LSA_LOG, ("String2ArgumentList argv[%#x] %s\n", i, ppszArgs[i]));
    }
    #endif

    cArgs = 0;
    ppszArgs = NULL;

Cleanup:

    ReleaseArgumentList(cArgs, ppszArgs);

    return hRetval;
}

DECLARE_API( listx )
{
    HRESULT hRetval = E_FAIL;

    PCSTR pszCommand = "dp";
    PCSTR pszCmdArgs = "";
    CHAR szType[MAX_PATH] = {0};
    CHAR szField[MAX_PATH] = {0};
    LIST_TYPE_PARAMS ListParams = {0};
    ULONG64 cLists = 1;
    ULONG64 Start = 0;
    ULONG64 cbListAnchor = 0;

    ULONG argc = 0;
    PCSTR* argv = NULL;
    ULONG mark = 0;
    ULONG cArgs = 0;

    ULONG i;
    ULONG64 Offset = 0;
    ULONG64 Next;

    // DBG_OPEN(kstrLsaDbgPrompt, (LSA_WARN | LSA_ERROR | LSA_LOG));

    InitializeListHead(&g_SummaryAnchor);
    g_bSummaryOnly = FALSE;
    g_KeyOffset = -1; // offset used to match
    g_KeyLength = 0; // key length
    g_KeyValue = 0; // key value
    g_cEntries = 0;

    hRetval = String2ArgumentList(args, &cArgs, &argv);

    if (FAILED(hRetval)) {
        goto Cleanup;
    }

    argc = cArgs;

    while (argc) {

        DBG_LOG(LSA_LOG, ("argv[%#x] %s\n", mark, argv[mark]));

        if (argc > 1) {
            DBG_LOG(LSA_LOG, ("    next argv[%#x] %s\n", mark + 1, argv[mark + 1]));
        }

        if (!strcmp(argv[mark], "-t") && argc > 1) {
            argc--; mark++;

            PCHAR pDot = strchr(argv[mark], '.');
            if (pDot) {
                strncpy(
                    szType,
                    argv[mark],
                    (ULONG) (ULONG_PTR) (pDot - argv[mark]));
                pDot++;
                i = 0;
                while (*pDot && (i < MAX_PATH - 1)
                       && (*pDot != ' ') && (*pDot != '\t'))
                       szField[i++] = *pDot++;
            } else {
                dprintf("missing \".\" in the type specifier\n");
                goto Cleanup;
            }
            argc--; mark++;

            if (szType[0] && szField[0]) {

                if (GetFieldOffset(szType, szField, &ListParams.FieldOffset)) {
                    dprintf("GetFieldOffset failed for %s.%s\n", szType, szField);
                    hRetval = E_FAIL;
                    goto Cleanup;
                }
                Offset = ListParams.FieldOffset;
            }
            DBG_LOG(LSA_LOG, ("Read type %s, field %s, offset %#I64x\n", szType, szField, Offset));
        } else if (!strcmp(argv[mark], "-x") && argc > 1)  {
            argc--; mark++;

            pszCommand = argv[mark];

            argc--; mark++;
        } else if (!strcmp(argv[mark], "-a") && argc > 1)  {
           argc--; mark++;

           pszCmdArgs = argv[mark];

           argc--; mark++;
        } else if (!strcmp(argv[mark], "-clists") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &cLists, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
           argc--; mark++;
        } else if (!strcmp(argv[mark], "-cbanchor") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &cbListAnchor, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
           }
           DBG_LOG(LSA_LOG, ("Read cbanchor %#I64x\n", cbListAnchor));

           argc--; mark++;
        } else if (!strcmp(argv[mark], "-offset") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &Offset, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
           DBG_LOG(LSA_LOG, ("Read LIST_ENTRY Offset %#I64x\n", Offset));
           argc--; mark++;
        } else if (!strcmp(argv[mark], "-keyoffset") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &g_KeyOffset, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
           DBG_LOG(LSA_LOG, ("Read keyoffset %#I64x\n", g_KeyOffset));
           argc--; mark++;
        } else if (!strcmp(argv[mark], "-keylen") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &g_KeyLength, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
           DBG_LOG(LSA_LOG, ("Read keylen %#I64x\n", g_KeyLength));
           argc--; mark++;
        } else if (!strcmp(argv[mark], "-keyvalue") && argc > 1)  {
           argc--; mark++;

           if (!GetExpressionEx(argv[mark], &g_KeyValue, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
           DBG_LOG(LSA_LOG, ("Read keyvalue %#I64x\n", g_KeyValue));
           argc--; mark++;
        } else if (!strcmp(argv[mark], "-s")) {
            argc--; mark++;
            g_bSummaryOnly = TRUE;
        } else if (!strcmp(argv[mark], "-h") || (!strcmp(argv[mark], "-?")) || (Start != 0)) {
            dprintf("Usage: !listx -t [mod!]TYPE.Field <Start-Address>\n"
                "             -x \"Command-for-each-element\"\n"
                "             -a \"Command-arguments\"\n"
                "             -clists <number of lists>\n"
                "             -cbanchor <list anchor size>\n"
                "             -offset <offset of list entry field from node>\n"
                "             -keyoffset <matching-key offset from node>\n"
                "             -keylen <key length>\n"
                "             -keyvalue <key value>\n"
                "             -s\n"
                "             -h\n"
                "Command after -x is executed for each list element. Its first argument is\n"
                "list-head address and remaining arguments are specified after -a. \n"
                "-s summary only\n"
                "eg. !listx -t MYTYPE.l.Flink -x \"dd\" -a \"l2\" 0x6bc00\n"
                "     dumps first 2 dwords in list of MYTYPE at 0x6bc00\n\n");
                hRetval = S_OK;
                goto Cleanup;
        } else {

            if (!GetExpressionEx(argv[mark], &Start, &args)) {
                dprintf("Invalid expression in %s\n", argv[mark]);
                hRetval = E_FAIL;
                goto Cleanup;
            }
            argc--; mark++;
        }
    }

    if (0 == cbListAnchor) {

        cbListAnchor = 2 * GetTypeSize("void*");
    }

    if (0 == g_KeyLength) {
        g_KeyLength = GetTypeSize("void*");
    }

    if (!cbListAnchor || !g_KeyLength) 
    {
        dprintf("\nsizes wrong (symbols could be problematic) cbListAnchor %#x, g_KeyLength %#x, use -cbanchor or -keylen to work around\n\n",
            cbListAnchor, g_KeyLength);
        goto Cleanup;
    }

    if (cLists != 1) {
        dprintf("Examining %#I64x lists, cbListAnchor %#I64x, ListAnchor %#I64x, ListEntryOffset %#I64x\n",
                cLists, cbListAnchor, Start, Offset);
    }

    if (g_KeyOffset != -1) {
        dprintf("Filter keyoffset %#I64x, keylen %#I64x, keyvalue %#I64x\n",
            g_KeyOffset, g_KeyLength, g_KeyValue);
    }

    for (ULONG j = 0; j < cLists; j++) {
        ULONG64 ListAnchor = Start + cbListAnchor * j;

        dprintf("Examining list %#x, anchor %I64x ...\n", j, ListAnchor);

        if (!ReadPointer(ListAnchor, &Next)) {
            dprintf("Cannot read next element at %p\n", ListAnchor);
            break;
        }

        if (szType[0] && szField[0]) {

            ListParams.Command = (PCHAR) pszCommand;
            ListParams.CommandArgs = (PCHAR) pszCmdArgs;
            ListParams.nElement = 0;

            INIT_API();

            ListType(szType, Next, FALSE, szField, (PVOID) &ListParams, &ListCallback );

            EXIT_API();

            continue;
        }

        INIT_API();

        while (Next != ListAnchor) {
            CHAR Execute[MAX_PATH] = {0};
            PCHAR Buffer;
            ULONG64 Value = 0;
            BOOLEAN Skip = FALSE;

            DBG_LOG(LSA_LOG, ("Examining node at %#I64x\n", Next));

            if (g_KeyOffset != -1) {

                if (!ReadMemory(
                    Next - Offset + g_KeyOffset,
                    &Value,
                    (ULONG) min(g_KeyLength, sizeof(Value)),
                    NULL)) {
                    dprintf("Failed to read at %I64x\n", Next - Offset + g_KeyOffset);
                    return TRUE;
                }

                DBG_LOG(LSA_LOG,
                    ("Filtering %#I64x value %#I64x with offset %#I64x len %#I64x value %#I64x\n",
                    Next,
                    Value,
                    g_KeyOffset,
                    g_KeyLength,
                    g_KeyValue));

                if (g_bSummaryOnly) {
                    g_cEntries++;
                    if (!UpdateSummary(Value)) {
                        hRetval = E_OUTOFMEMORY;
                        goto Cleanup;
                    } else {
                        Skip = TRUE; // do not execute, sumary only
                    }
                }

                if (!Skip && Value != g_KeyValue) {
                    Skip = TRUE;
                }
            }

            if (!Skip && g_bSummaryOnly) {
                g_cEntries++;
                Skip = TRUE;
            }

            if (!Skip) {

                g_cEntries++;

                // Execute command
                _snprintf(Execute,
                    sizeof(Execute) - 1,
                    "%s %I64lx %s",
                    pszCommand,
                    Next - Offset,
                    pszCmdArgs);

                DBG_LOG(LSA_LOG, ("Execute %s\n", Execute));

                dprintf("Examining node at %p\n", Next - Offset);

                g_ExtControl->Execute(
                    DEBUG_OUTCTL_AMBIENT,
                    Execute,
                    DEBUG_EXECUTE_DEFAULT
                    );

                dprintf("\n");
            }

            if (!ReadPointer(Next, &Next)) {
                dprintf("Cannot read next element at %p\n", Next);
                break;
            }
            if (!Next) {
                dprintf("Next element is null\n");
                break;
            }
            if (CheckControlC()) {
                break;
            }
        }

        EXIT_API();
    }

    DisplaySummaryList();

Cleanup:

    ReleaseSummaryList();
    ReleaseArgumentList(cArgs, argv);

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\kerbcache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kerbcache.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       August 10, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "kerbname.hxx"
#include "kerbcache.hxx"

#include "util.hxx"

VOID PrintEType(IN ULONG EType)
{
    dprintf("%#x : ", EType);

    switch(EType) {
    case KERB_ETYPE_NULL:
        dprintf("KERB_ETYPE_NULL\n"); break;
    case KERB_ETYPE_DES_CBC_CRC:
        dprintf("KERB_ETYPE_DES_CBC_CRC\n"); break;
    case KERB_ETYPE_DES_CBC_MD4:
        dprintf("KERB_ETYPE_DES_CBC_MD4\n"); break;
    case KERB_ETYPE_DES_CBC_MD5:
        dprintf("KERB_ETYPE_DES_CBC_MD5\n"); break;
    case KERB_ETYPE_OLD_RC4_MD4:
        dprintf("KERB_ETYPE_OLD_RC4_MD4\n"); break;
    case KERB_ETYPE_OLD_RC4_PLAIN:
        dprintf("KERB_ETYPE_OLD_RC4_PLAIN\n"); break;
    case KERB_ETYPE_OLD_RC4_LM:
        dprintf("KERB_ETYPE_OLD_RC4_LM\n"); break;
    case KERB_ETYPE_OLD_RC4_SHA:
        dprintf("KERB_ETYPE_OLD_RC4_SHA\n"); break;
    case KERB_ETYPE_OLD_DES_PLAIN:
        dprintf("KERB_ETYPE_OLD_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_MD4:
        dprintf("KERB_ETYPE_RC4_MD4\n"); break;
    case KERB_ETYPE_RC4_PLAIN2:
        dprintf("KERB_ETYPE_RC4_PLAIN2\n"); break;
    case KERB_ETYPE_RC4_LM:
        dprintf("KERB_ETYPE_RC4_LM\n"); break;
    case KERB_ETYPE_RC4_SHA:
        dprintf("KERB_ETYPE_RC4_SHA\n"); break;
    case KERB_ETYPE_DES_PLAIN:
        dprintf("KERB_ETYPE_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_PLAIN:
        dprintf("KERB_ETYPE_RC4_PLAIN\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD:
        dprintf("KERB_ETYPE_RC4_HMAC_OLD\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
        dprintf("KERB_ETYPE_RC4_HMAC_OLD_EXP\n"); break;
    case KERB_ETYPE_RC4_PLAIN_EXP:
        dprintf("KERB_ETYPE_RC4_PLAIN_EXP\n"); break;
    case KERB_ETYPE_DSA_SIGN:
        dprintf("KERB_ETYPE_DSA_SIGN\n"); break;
    case KERB_ETYPE_RSA_PRIV:
        dprintf("KERB_ETYPE_RSA_PRIV\n"); break;
    case KERB_ETYPE_RSA_PUB:
        dprintf("KERB_ETYPE_RSA_PUB\n"); break;
    case KERB_ETYPE_RSA_PUB_MD5:
        dprintf("KERB_ETYPE_RSA_PUB_MD5\n"); break;
    case KERB_ETYPE_RSA_PUB_SHA1:
        dprintf("KERB_ETYPE_RSA_PUB_SHA1\n"); break;
    case KERB_ETYPE_PKCS7_PUB:
        dprintf("KERB_ETYPE_PKCS7_PUB\n"); break;
    case KERB_ETYPE_DES_CBC_MD5_NT:
        dprintf("KERB_ETYPE_DES_CBC_MD5_NT\n"); break;
    case KERB_ETYPE_RC4_HMAC_NT:
        dprintf("KERB_ETYPE_RC4_HMAC_NT\n"); break;
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
        dprintf("KERB_ETYPE_RC4_HMAC_NT_EXP\n"); break;
    default:
        dprintf("Unknown EType: 0x%lx\n", EType); break;
    }
}

#define KERB_TICKET_CACHE_PRIMARY_TGT           0x01             // ticket is primary TGT
#define KERB_TICKET_CACHE_DELEGATION_TGT        0x02             // ticket is delegation TGT
#define KERB_TICKET_CACHE_S4U_TICKET            0x04             // ticket is an S4U ticket
#define KERB_TICKET_CACHE_ASC_TICKET            0x08             // ticket is from AcceptSecurityContext
#define KERB_TICKET_CACHE_TKT_ENC_IN_SKEY       0x10             // ticket is encrypted with a session key

VOID ShowCacheFlags(IN PCSTR pszPad, IN ULONG ulFlags)
{

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (ulFlags & x) {                                   \
            dprintf("%s ", #x);                              \
            ulFlags &= ~ x;                                  \
        }                                                    \
    } while(0)                                               \

    dprintf("%s%#x : ", pszPad, ulFlags);

    BRANCH_AND_PRINT(KERB_TICKET_CACHE_PRIMARY_TGT);
    BRANCH_AND_PRINT(KERB_TICKET_CACHE_DELEGATION_TGT);
    BRANCH_AND_PRINT(KERB_TICKET_CACHE_S4U_TICKET);
    BRANCH_AND_PRINT(KERB_TICKET_CACHE_ASC_TICKET);
    BRANCH_AND_PRINT(KERB_TICKET_CACHE_TKT_ENC_IN_SKEY);

    if (ulFlags)
    {
        dprintf("%#x", ulFlags);
    }
    dprintf(kstrNewLine);

#undef BRANCH_AND_PRINT
}

VOID ShowKdCOptions(IN ULONG dwOptions);

VOID ShowKerbTCacheEntry(IN PCSTR pszPad, IN ULONG64 addrCache)
{
    HRESULT hRetval;

    dprintf(kstrTypeAddrLn, kstrKTCE, addrCache);
    LsaInitTypeRead(addrCache, kerberos!_KERB_TICKET_CACHE_ENTRY);

    dprintf("%s  Next            %#I64x\n", pszPad, toPtr(LsaReadPtrField(ListEntry.Next)));
    dprintf("%s  ReferenceCount  %d\n", pszPad, LsaReadULONGField(ListEntry.ReferenceCount));

    try {
    
        dprintf("%s  Linked          %s\n", pszPad, LsaReadULONGField(Linked) ? "true" : "false");

    } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL);

    dprintf("%s  TargetName      ", pszPad);
    ShowKerbName(kstrEmptyA, LsaReadPtrField(TargetName), 0);

    dprintf("%s  AltTargetDomain %ws\n", pszPad, TSTRING(addrCache + ReadFieldOffset(kstrKTCE, "AltTargetDomainName")).toWStrDirect());    
    
    try {

        dprintf("%s  AltClientName   %ws\n", pszPad, TSTRING(addrCache + ReadFieldOffset(kstrKTCE, "AltClientName")).toWStrDirect());

    } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL);


    dprintf("%s  CacheFlags      ", pszPad);
    ShowCacheFlags(kstrEmptyA, LsaReadULONGField(CacheFlags));

    dprintf("%s  TimeSkew(min)   %f\n", pszPad, LsaReadULONG64Field(TimeSkew) / 10000000 * 60.0);

    // names in the ticket 

    dprintf("%s  ServiceName     ", pszPad);
    ShowKerbName(kstrEmptyA, LsaReadPtrField(ServiceName), 0);

    dprintf("%s  DomainName      %ws\n", pszPad, TSTRING(addrCache + ReadFieldOffset(kstrKTCE, "DomainName")).toWStrDirect());
    dprintf("%s  TargetDomain    %ws\n", pszPad, TSTRING(addrCache + ReadFieldOffset(kstrKTCE, "TargetDomainName")).toWStrDirect());


    dprintf("%s  ClientName      ", pszPad);
    ShowKerbName(kstrEmptyA, LsaReadPtrField(ClientName), 0);

    dprintf("%s  ClientDomain    %ws\n", pszPad, TSTRING(addrCache + ReadFieldOffset(kstrKTCE, "ClientDomainName")).toWStrDirect());

    dprintf("%s  TicketFlags     ", pszPad);
    ShowKdCOptions(LsaReadULONGField(TicketFlags));

    dprintf("%s  EncryptionType  ", pszPad);
    PrintEType(LsaReadULONGField(SessionKey.keytype));

    dprintf("%s  StartTime       ", pszPad);
    ShowSystemTimeAsLocalTime(NULL, LsaReadULONG64Field(StartTime));

    dprintf("%s  EndTime         ", pszPad);
    ShowSystemTimeAsLocalTime(NULL, LsaReadULONG64Field(EndTime));

    dprintf("%s  RenewUntil      ", pszPad);
    ShowSystemTimeAsLocalTime(NULL, LsaReadULONG64Field(RenewUntil));
}

BOOL DumpKerbNameType(IN PCSTR pszPad, IN ULONG KerbNameType)
{

#define BRANCH_AND_PRINT(x) case x: dprintf("%s%s", pszPad, #x); break

    dprintf("%s%#x : ", pszPad, KerbNameType);

    switch (KerbNameType)
    {
    BRANCH_AND_PRINT(KRB_NT_UNKNOWN);
    BRANCH_AND_PRINT(KRB_NT_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_PRINCIPAL_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_SRV_INST);
    BRANCH_AND_PRINT(KRB_NT_SRV_INST_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_SRV_HST);
    BRANCH_AND_PRINT(KRB_NT_SRV_XHST);
    BRANCH_AND_PRINT(KRB_NT_UID);
    BRANCH_AND_PRINT(KRB_NT_ENTERPRISE_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_ENT_PRINCIPAL_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_MS_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_MS_PRINCIPAL_AND_ID);

    default:
        dprintf("%sUnknown KerbNameType\n", pszPad);
        return FALSE;
    }

#undef BRANCH_AND_PRINT

    return TRUE;
}

static VOID DisplayUsage(VOID)
{
    dprintf(kstrUsage);
    dprintf(kstrkch);
}

DECLARE_API(kerbcache)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 addrCache = 0;

    hRetval = args && *args ? ProcessHelpRequest(args) : E_INVALIDARG;

    try
    {
        if (SUCCEEDED(hRetval))
        {
            hRetval = GetExpressionEx(args, &addrCache, &args) && addrCache ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval))
        {
            ShowKerbTCacheEntry(kstrEmptyA, addrCache);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display kerberos cache", kstrKTCE);

    if (E_INVALIDARG == hRetval)
    {
        (VOID)DisplayUsage();
    }
    else if (FAILED(hRetval))
    {
       dprintf("Fail to display kerberos cache\n");
    }

    return hRetval;
}

//
// There are two sets of flags linked by KerbConvertKdcOptionsToTicketFlags
// which ignores flags it does not recognize
//
// I prefer KERB_TICKET_FLAGS over KERB_KDC_OPTIONS but the following are
// are missing their correspondences
//

#define  KERB_KDC_OPTIONS_renewable_ok            0x00000010
#define  KERB_KDC_OPTIONS_enc_tkt_in_skey         0x00000008
#define  KERB_KDC_OPTIONS_renew                   0x00000002

VOID ShowKdCOptions(IN ULONG dwOptions)
{

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (dwOptions & KERB_TICKET_FLAGS_##x) {             \
            dprintf("%s ", #x);                              \
            dwOptions &= ~KERB_TICKET_FLAGS_##x;             \
        }                                                    \
    } while(0)                                               \

    dprintf("%#x : ", dwOptions);

    BRANCH_AND_PRINT(reserved);
    BRANCH_AND_PRINT(forwardable);
    BRANCH_AND_PRINT(forwarded);
    BRANCH_AND_PRINT(proxiable);
    BRANCH_AND_PRINT(proxy);
    BRANCH_AND_PRINT(may_postdate);
    BRANCH_AND_PRINT(postdated);
    BRANCH_AND_PRINT(invalid);
    BRANCH_AND_PRINT(renewable);
    BRANCH_AND_PRINT(initial);
    BRANCH_AND_PRINT(pre_authent);
    BRANCH_AND_PRINT(hw_authent);
    BRANCH_AND_PRINT(ok_as_delegate);
    BRANCH_AND_PRINT(name_canonicalize);
    BRANCH_AND_PRINT(reserved1);

#undef BRANCH_AND_PRINT

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (dwOptions & KERB_KDC_OPTIONS_##x) {              \
            dprintf("%s ", #x);                              \
            dwOptions &= ~KERB_KDC_OPTIONS_##x;              \
        }                                                    \
    } while(0)                                               \

    BRANCH_AND_PRINT(renewable_ok);
    BRANCH_AND_PRINT(enc_tkt_in_skey);
    BRANCH_AND_PRINT(renew);

#undef BRANCH_AND_PRINT

    if (dwOptions)
    {
        dprintf("%#x", dwOptions);
    }
    dprintf(kstrNewLine);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsaexts.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsaexts.cxx

Abstract:

    This file contains the generic routines and initialization code
    for the debugger extensions dll.

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode / Kernel Mode

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <ntverp.h>
#include <tchar.h>

//
// Queries for all debugger interfaces.
//
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status = E_FAIL;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK) {

        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK) {

        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK) {

        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK) {

        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                 (void **)&g_ExtSymbols)) != S_OK) {

        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK) {

        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

Fail:

    ExtRelease();
    return Status;
}

//
// Cleans up all debugger interfaces.
//
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

HRESULT ExecuteDebuggerCommand(IN PCSTR cmd)
{
    HRESULT hRetval = g_ExtClient && cmd ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {
        hRetval = ExtQuery(g_ExtClient);
    }

    if (SUCCEEDED(hRetval)) {
        hRetval = g_ExtControl->Execute(
            DEBUG_OUTCTL_ALL_CLIENTS | DEBUG_OUTCTL_OVERRIDE_MASK | DEBUG_OUTCTL_NOT_LOGGED,
            cmd,
            DEBUG_EXECUTE_DEFAULT);
    }

    (void)ExtRelease();

    return hRetval;
}

//
// Normal output.
//
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

//
// Error output.
//
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

//
// Warning output.
//
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

//
// Verbose output.
//
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

typedef
HRESULT
(* PFuncDebugCreate)(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );

HRESULT
LsaDebugCreate(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT hRetval = E_FAIL;
    PFuncDebugCreate pfuncDebugCreate = NULL;
    HMODULE hLib = NULL;

    DBG_LOG(LSA_LOG, ("LsaDebugCreate Loading DBGENG.DLL\n"));

    hLib = LoadLibrary(_T("DBGENG.DLL"));

    hRetval = hLib ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval))
    {
        pfuncDebugCreate = (PFuncDebugCreate) GetProcAddress(hLib, "DebugCreate");

        if (pfuncDebugCreate)
        {
            hRetval = pfuncDebugCreate(InterfaceId, Interface);
        }
        else
        {
            hRetval = GetLastErrorAsHResult();
        }
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    DBG_LOG(LSA_LOG, ("LsaDebugCreate leaving %#x\n", hRetval));

    return hRetval;
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;

    if ((hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK) {
        return hr;
    }

    if ((hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK) {
        return hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {

        return hr;
    }

    DBG_OPEN(kstrLsaDbgPrompt, (LSA_WARN | LSA_ERROR));

    DebugControl->Release();
    DebugClient->Release();

    return S_OK;
}

extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //
    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!g_Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT hr;
        ULONG64 Page;

        if ((hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK) {
            //
            // Get the page size and PAE enable flag
            //
            if ((hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK) {

                if ((hr = DebugDataSpaces->ReadDebuggerData(

                    DEBUG_DATA_MmPageSize, &Page,
                    sizeof(Page), NULL)) == S_OK) {
                    g_PageSize = (ULONG)(ULONG_PTR)Page;
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //
            if ((hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK) {

                if ((hr = DebugControl->GetActualProcessorType(
                    &g_TargetMachine)) == S_OK) {

                    g_Connected = TRUE;
                }
                ULONG Qualifier;
                hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier);

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }

    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE) {

        g_Connected = FALSE;
        g_PageSize = 0;
        g_TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    DBG_CLOSE();
}

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(reinterpret_cast<HMODULE>(hModule));
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\kerbname.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kerbname.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       August 10, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "kerbname.hxx"
#include "util.hxx"

void DumpKerbNameType(IN PCSTR pszPad, IN LONG KerbNameType)
{

#define BRANCH_AND_PRINT(x) case x: dprintf("%s%s,", pszPad, #x); break

    DBG_LOG(LSA_LOG, ("DumpKerbNameType %#x\n", KerbNameType));

    dprintf("%s%#x : ", pszPad, KerbNameType);

    switch (KerbNameType) {
    BRANCH_AND_PRINT(KRB_NT_UNKNOWN);
    BRANCH_AND_PRINT(KRB_NT_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_PRINCIPAL_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_SRV_INST);
    BRANCH_AND_PRINT(KRB_NT_SRV_INST_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_SRV_HST);
    BRANCH_AND_PRINT(KRB_NT_SRV_XHST);
    BRANCH_AND_PRINT(KRB_NT_UID);
    BRANCH_AND_PRINT(KRB_NT_ENTERPRISE_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_ENT_PRINCIPAL_AND_ID);
    BRANCH_AND_PRINT(KRB_NT_MS_PRINCIPAL);
    BRANCH_AND_PRINT(KRB_NT_MS_PRINCIPAL_AND_ID);

    default:
        dprintf("%sUnknown KerbNameType\n", pszPad);
        break;
    }

#undef BRANCH_AND_PRINT

}

void ShowCString(IN ULONG64 addrStr)
{
    UCHAR c = 0;
    while (c = ReadUCHARVar(addrStr++)) {
        if (isprint(c)) {
            dprintf("%c", c);
        } else {
            dprintf("<non printable character encountered>\n");
            break;
        }
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrkrbnm);
}

void ShowKerbName(IN PCSTR pszPad, IN ULONG64 addrName, IN ULONG fOptions)
{
    if (!addrName) {
        dprintf("%s(null)\n", pszPad);
        return;
    }

    ULONG ulNameType = ReadULONGVar(addrName);
    ULONG64 addrKPN = 0;

    //
    // here we apply some heuristic to see whether it is kdc name or principal
    // name: we assume that the value of name type is either less than 255 or
    // is a negative number for principal names
    //

    if ((ulNameType <= 0xff) || (static_cast<LONG>(ulNameType) < 0)) {

        //
        // Kerberos principal names
        //

        ULONG64 tmp = 0;

        if (fOptions & SHOW_VERBOSE_INFO) {

            dprintf(pszPad);
            dprintf(kstrTypeAddrLn, "kerberos!KERB_PRINCIPAL_NAME", addrName);
        }

        DumpKerbNameType(pszPad, ulNameType);

        dprintf(pszPad);

        //
        // dumping KERB_PRINCIPAL_NAME_name_string_s
        //

        for (addrKPN = ReadStructPtrField(addrName, "kerberos!KERB_PRINCIPAL_NAME", "name_string");
             addrKPN;
             addrKPN = ReadStructPtrField(addrKPN, "kerberos!KERB_PRINCIPAL_NAME_name_string_s", "next")) {
            dprintf(" \"");
            tmp = ReadStructPtrField(addrKPN, "kerberos!KERB_PRINCIPAL_NAME_name_string_s", "value");
            ShowCString(tmp);
            dprintf("\"");
        }
        dprintf(kstrNewLine);
    } else {

        CHAR szField[16] = {0};

        //
        // kdc names or kerberos internal names
        //

        if (fOptions & SHOW_VERBOSE_INFO) {
            dprintf(pszPad);
            dprintf(kstrTypeAddrLn, "kerberos!_KERB_INTERNAL_NAME", addrName);
        }

        DumpKerbNameType(pszPad, static_cast<LONG>(static_cast<SHORT>(ulNameType)));
        dprintf(pszPad);

        for (UINT i = 0; i < (ulNameType >> 16); i ++ ) {
            _snprintf(szField, sizeof(szField) - 1, "Names[%#x]", i);
            dprintf(" \"%ws\"", TSTRING(addrName + ReadFieldOffset("kerberos!_KERB_INTERNAL_NAME", szField)).toWStrDirect());
        }
        dprintf(kstrNewLine);
    }
}

DECLARE_API(kerbname)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 addrName = 0;

    hRetval = args && *args ? ProcessHelpRequest(args) : E_INVALIDARG;

    try {
        if (SUCCEEDED(hRetval)) {
            hRetval = GetExpressionEx(args, &addrName, &args) && addrName ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval)) {
            ShowKerbName(kstrEmptyA, addrName, SHOW_VERBOSE_INFO);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display kerberos name", "kerberos!KERB_PRINCIPAL_NAME");

    if (E_INVALIDARG == hRetval) {
        (void)DisplayUsage();
    } else if (FAILED(hRetval)) {
        dprintf("Fail to display kerberos name\n");
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsahandle.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsahandle.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsahandle.hxx"
#include "util.hxx"

#include "sid.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrlhdl);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
    dprintf(kstrVerbose);
}

void ShowLsaHandle(IN PCSTR pszBanner, IN ULONG64 addrDbHandle, IN ULONG fOptions)
{
    LARGE_INTEGER LocalTime = {0};
    TIME_FIELDS TimeFields = {0};
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ULONG fieldOffset = 0;
    ULONG64 addrSid = 0;
    LARGE_INTEGER Time = {0};
    CHAR szTmp[MAX_PATH] = {0};

    HRESULT hRetval = S_OK;

    ExitIfControlC();

    dprintf(kstrTypeAddrLn, kstrDbHandle, addrDbHandle);

    LsaInitTypeRead(addrDbHandle, _LSAP_DB_HANDLE);

    dprintf("%sNext            %#I64x\n", pszBanner, LsaReadPtrField(Next));
    dprintf("%sPrevious        %#I64x\n", pszBanner, LsaReadPtrField(Previous));
    dprintf("%sUsrHdlLst Flnk  %s\n", pszBanner, PtrToStr(LsaReadPtrField(UserHandleList.Flink)));
    dprintf("%sUsrHdlLst Blnk  %s\n", pszBanner, PtrToStr(LsaReadPtrField(UserHandleList.Blink)));
    dprintf("%sAllocated       %s\n", pszBanner, LsaReadUCHARField(Allocated) ? "TRUE" : "FALSE" );
    dprintf("%sReferenceCount  %#lu\n", pszBanner, LsaReadUCHARField(ReferenceCount));

    fieldOffset = ReadFieldOffset(kstrDbHandle, "LogicalNameU");
    dprintf("%sLogicalNameU    %ws\n", pszBanner, TSTRING(addrDbHandle + fieldOffset).toWStrDirect());

    fieldOffset = ReadFieldOffset(kstrDbHandle, "PhysicalNameU");
    dprintf("%sPhysicalNameU   %ws\n", pszBanner, TSTRING(addrDbHandle + fieldOffset).toWStrDirect());

    addrSid = LsaReadPtrField(Sid);

    _snprintf(szTmp, sizeof(szTmp) - 1, "%sSid             ", pszBanner);
    ShowSid(szTmp, addrSid > 0x100 ? addrSid : 0, fOptions); // filter out invalid sids

    dprintf("%sKeyHandle       %#x\n", pszBanner, LsaReadPtrField(KeyHandle));
    dprintf("%sObjectTypeId    %#lu\n", pszBanner, LsaReadULONGField(ObjectTypeId));
    dprintf("%sContainerHandle %#I64x\n", pszBanner, LsaReadPtrField(ContainerHandle));
    dprintf("%sDesiredAccess   %#08lx\n", pszBanner, LsaReadULONGField(DesiredAccess));
    dprintf("%sGrantedAccess   %#08lx\n", pszBanner, LsaReadULONGField(GrantedAccess));
    dprintf("%sRequestAccess   %#08lx\n", pszBanner, LsaReadULONGField(RequestedAccess));
    dprintf("%sGenerateOnClose %s\n", pszBanner, LsaReadUCHARField(GenerateOnClose) ? "TRUE" : "FALSE" );
    dprintf("%sTrusted         %s\n", pszBanner, LsaReadUCHARField(Trusted) ? "TRUE" : "FALSE" );
    dprintf("%sDeletedObject   %s\n", pszBanner, LsaReadUCHARField(DeletedObject) ? "TRUE" : "FALSE" );
    dprintf("%sNetworkClient   %s\n", pszBanner, LsaReadUCHARField(NetworkClient) ? "TRUE" : "FALSE" );
    dprintf("%sOptions         %#08lx\n", pszBanner, LsaReadULONGField(Options));

    fieldOffset = ReadFieldOffset(kstrDbHandle, "PhysicalNameDs");
    dprintf("%sPhysicalNameDs  %ws\n", pszBanner, TSTRING(addrDbHandle + fieldOffset).toWStrDirect());

    dprintf("%sfWriteDs        %s\n", pszBanner, LsaReadUCHARField(fWriteDs) ? "TRUE" : "FALSE" );
    dprintf("%sObjectOptions   %#08lx\n", pszBanner, LsaReadULONGField(ObjectOptions));
    dprintf("%sUserEntry       %s\n", pszBanner, PtrToStr(LsaReadPtrField(UserEntry)));


    if (fOptions & SHOW_VERBOSE_INFO) {

        //
        // Only on checked targets HandleCreateTime and HandleLastAccessTime exist
        //
        try {

            Time = ULONG642LargeInteger(LsaReadULONG64Field(HandleCreateTime));

            Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

            if (!NT_SUCCESS(Status)) {

                dprintf("Can't convert create time from GMT to Local time: 0x%lx\n", Status);

            } else {

                RtlTimeToTimeFields(&LocalTime, &TimeFields);

                dprintf("%sCreateTime      %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                    pszBanner,
                    TimeFields.Month,
                    TimeFields.Day,
                    TimeFields.Year,
                    TimeFields.Hour,
                    TimeFields.Minute,
                    TimeFields.Second,
                    Time.LowPart,
                    Time.HighPart);
            }

            Time = ULONG642LargeInteger(LsaReadULONG64Field(HandleLastAccessTime));

            Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

            if (!NT_SUCCESS(Status)) {

                dprintf("Can't convert LastAccess time from GMT to Local time: 0x%lx\n", Status);

            } else {

                RtlTimeToTimeFields(&LocalTime, &TimeFields);

                dprintf("%sLastAccessTime  %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                    pszBanner,
                    TimeFields.Month,
                    TimeFields.Day,
                    TimeFields.Year,
                    TimeFields.Hour,
                    TimeFields.Minute,
                    TimeFields.Second,
                    Time.LowPart,
                    Time.HighPart);
            }
        } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL);

        if (FAILED(hRetval)) {

            dprintf("%sNo handle creation and access time available\n", pszBanner);
        }
    }
}

HRESULT ProcessLsaHandleOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case 'n':
            *pfOptions |=  SHOW_FRIENDLY_NAME;
            break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumplsahandle)
{
    HRESULT hRetval = E_FAIL;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrLsaHandle = 0;
    ULONG fieldOffset = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    try {

        if (SUCCEEDED(hRetval)) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessLsaHandleOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval)) {

            hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
        }

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(szArgs, &addrLsaHandle, &args) && addrLsaHandle ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hRetval)) {

           ShowLsaHandle(kstr4Spaces, addrLsaHandle, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display lsa handle", kstrDbHandle);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\kerbsess.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kerbsess.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       August 10, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "kerbsess.hxx"

#include "kerbcache.hxx"
#include "util.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrkrbss);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrVerbose);
    dprintf(kstrRemarks);
    dprintf("   LogonId must be of form <HighPart>:<LowPart>\n");
}

HRESULT ProcessKerbLogonSessionListOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++)
    {
        if (*pszArgs == '-' || *pszArgs == '/')
        {
            switch (*++pszArgs)
            {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

#define KERB_LOGON_DEFERRED             0x00000001
#define KERB_LOGON_NO_PASSWORD          0x00000002
#define KERB_LOGON_LOCAL_ONLY           0x00000004
#define KERB_LOGON_ONE_SHOT             0x00000008
#define KERB_LOGON_SMARTCARD            0x00000010
#define KERB_LOGON_MIT_REALM            0x00000020
#define KERB_LOGON_DELEGATE_OK          0x00000100 // Means we can delegate this - ok for proxy

//
// None of the below have credentials (TGT / pwd), so we need
// to do S4U to go off box, or we'll use a NULL connection..
//

#define KERB_LOGON_S4U_SESSION          0x00001000
#define KERB_LOGON_DUMMY_SESSION        0x00002000 // "other" package satisfied logon
#define KERB_LOGON_ASC_SESSION          0x00004000 // formed from AcceptSecurityCtxt.

#define KERB_LOGON_CREDMAN_INITIALIZED  0x80000000

#define KERB_LOGON_S4U_REQUIRED         0x0000F000

//
// Delegation with unconstrained delegation.
//

#define KERB_LOGON_DELEGATED            0x00010000

void ShowLogonSessionFlags(IN PCSTR pszPad, IN ULONG ulFlags)
{

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (ulFlags & KERB_LOGON_##x) {                      \
            dprintf("%s ", #x);                              \
            ulFlags &= ~ KERB_LOGON_##x;                     \
        }                                                    \
    } while(0)                                               \

    dprintf("%s%#x : ", pszPad, ulFlags);

    BRANCH_AND_PRINT(DEFERRED);
    BRANCH_AND_PRINT(NO_PASSWORD);
    BRANCH_AND_PRINT(LOCAL_ONLY);
    BRANCH_AND_PRINT(ONE_SHOT);
    BRANCH_AND_PRINT(DELEGATED);
    BRANCH_AND_PRINT(SMARTCARD);
    BRANCH_AND_PRINT(MIT_REALM);
    BRANCH_AND_PRINT(S4U_SESSION);
    BRANCH_AND_PRINT(DUMMY_SESSION);
    BRANCH_AND_PRINT(ASC_SESSION);
    BRANCH_AND_PRINT(DELEGATE_OK);
    BRANCH_AND_PRINT(DELEGATED);
    BRANCH_AND_PRINT(CREDMAN_INITIALIZED);

    if (ulFlags)
    {
        dprintf("%#x", ulFlags);
    }
    dprintf(kstrNewLine);

#undef BRANCH_AND_PRINT
}

#define KERB_CRED_INBOUND       SECPKG_CRED_INBOUND
#define KERB_CRED_OUTBOUND      SECPKG_CRED_OUTBOUND
#define KERB_CRED_BOTH          SECPKG_CRED_BOTH
#define KERB_CRED_TGT_AVAIL     0x80000000
#define KERB_CRED_NO_PAC        0x40000000
#define KERB_CRED_RESTRICTED    0x10000000
#define KERB_CRED_S4U_REQUIRED  0x01000000
#define KERB_CRED_LOCATE_ONLY   0x04000000     // Don't update the supplied credentials.  Used for S4UToSelf location only.
#define KERB_CRED_LOCAL_ACCOUNT 0x08000000     // set on local accounts so Cred Man may be used
#define KERB_CRED_NULL_SESSION  0x20000000

void ShowKerbCredFlags(IN PCSTR pszPad, IN ULONG ulFlags)
{

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (ulFlags & KERB_CRED_##x) {                       \
            dprintf("%s ", #x);                              \
            ulFlags &= ~ KERB_CRED_##x;                      \
        }                                                    \
    } while(0)                                               \

    dprintf("%s%#x : ", pszPad, ulFlags);

    BRANCH_AND_PRINT(INBOUND);
    BRANCH_AND_PRINT(OUTBOUND);
    BRANCH_AND_PRINT(TGT_AVAIL);
    BRANCH_AND_PRINT(NO_PAC);
    BRANCH_AND_PRINT(RESTRICTED);
    BRANCH_AND_PRINT(S4U_REQUIRED);
    BRANCH_AND_PRINT(LOCATE_ONLY);
    BRANCH_AND_PRINT(NULL_SESSION);

    if (ulFlags)
    {
        dprintf("%#x", ulFlags);
    }
    dprintf(kstrNewLine);

#undef BRANCH_AND_PRINT
}

void ShowKerbPrimaryCredential(IN PCSTR pszBanner, IN ULONG64 addrPrimaryCredential, IN ULONG fOptions)
{
    HRESULT hRetval;

    ExitIfControlC();

    dprintf("%s  ", pszBanner);
    dprintf(kstrTypeAddrLn, kstrKerbPrimCred, addrPrimaryCredential);

    LsaInitTypeRead(addrPrimaryCredential, kerberos!_KERB_PRIMARY_CREDENTIAL);

    dprintf("%s  UserName        %ws\n", pszBanner, TSTRING(addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "UserName")).toWStrDirect());
    dprintf("%s  DomainName      %ws\n", pszBanner, TSTRING(addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "DomainName")).toWStrDirect());

    dprintf("%s  ClearPassword   (%#x, %#x, %#I64x)\n", pszBanner,
        LsaReadUSHORTField(ClearPassword.Length),
        LsaReadUSHORTField(ClearPassword.MaximumLength),
        LsaReadPtrField(ClearPassword.Buffer));

    if (fOptions & SHOW_VERBOSE_INFO)
    {
        dprintf("%s  OldUserName     %ws\n", pszBanner, TSTRING(addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "OldUserName")).toWStrDirect());
        dprintf("%s  OldDomainName   %ws\n", pszBanner, TSTRING(addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "OldDomainName")).toWStrDirect());
    }

    dprintf("%s  Passwords       _KERB_STORED_CREDENTIAL %s\n", pszBanner, PtrToStr(LsaReadPtrField(Passwords)));
    dprintf("%s  OldPasswords    _KERB_STORED_CREDENTIAL %s\n", pszBanner, PtrToStr(LsaReadPtrField(OldPasswords)));

    dprintf("%s  PublicKeyCreds  _KERB_PUBLIC_KEY_CREDENTIALS %s\n", pszBanner, PtrToStr(LsaReadPtrField(PublicKeyCreds)));

    dprintf("%s  SvcTicketCache  _KERB_TICKET_CACHE %#x\n", pszBanner, addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "ServerTicketCache"));
    
    try {
        dprintf("%s  S4UTicketCache  _KERB_TICKET_CACHE %#x\n", pszBanner, addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "S4UTicketCache"));
    } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL);

    dprintf("%s  AS TicketCache  _KERB_TICKET_CACHE %#x\n", pszBanner, addrPrimaryCredential + ReadFieldOffset(kstrKerbPrimCred, "AuthenticationTicketCache"));
}

void ShowKerbLogonSession(IN PCSTR pszBanner, IN ULONG64 addrKerbLogonSession, IN ULONG fOptions)
{
    ULONG ulFieldOffset;
    ULONG64 addrCredmanCredHead;
    ULONG64 addrCredmanCred;
                           
    CHAR szBanner[MAX_PATH] = {0};
    CHAR szBanner2[MAX_PATH] = {0};

    HRESULT hRetval;

    ExitIfControlC();

    _snprintf(szBanner, RTL_NUMBER_OF(szBanner) - 1, "%s%s", pszBanner, pszBanner);
    _snprintf(szBanner2, RTL_NUMBER_OF(szBanner2) - 1, "%s%s%s", pszBanner, pszBanner, pszBanner);

    dprintf(pszBanner);
    dprintf(kstrTypeAddrLn, kstrKrbLogSess, addrKerbLogonSession);

    LsaInitTypeRead(addrKerbLogonSession, kerberos!_KERB_LOGON_SESSION);

    dprintf("%s  LogonId         %#x:%#x\n", pszBanner, LsaReadULONGField(LogonId.HighPart), LsaReadULONGField(LogonId.LowPart));

    dprintf("%s  Lifetime        ", pszBanner);
    ShowSystemTimeAsLocalTime(NULL, LsaReadULONG64Field(Lifetime));

    dprintf("%s  LogonSessFlags  ", pszBanner);
    ShowLogonSessionFlags(kstrEmptyA, LsaReadULONGField(LogonSessionFlags));

    if (fOptions & SHOW_VERBOSE_INFO)
    {
        dprintf("%s  ExtraCred       Count %#x, !list -x \"dt _KERB_EXTRA_CRED\" %s\n", pszBanner,
            LsaReadULONGField(ExtraCredentials.Count),
            PtrToStr(LsaReadPtrField(ExtraCredentials.CredList)));
    }

    dprintf("%s  PrimaryCred\n", pszBanner);
    ShowKerbPrimaryCredential(szBanner, addrKerbLogonSession + ReadFieldOffset(kstrKrbLogSess, "PrimaryCredentials"), fOptions); 

    try {
   
        addrCredmanCredHead = addrKerbLogonSession + ReadFieldOffset(kstrKrbLogSess, "CredmanCredentials");
        ulFieldOffset = ReadFieldOffset(kstrKerbCredCred, "ListEntry.Next");
    
        dprintf("%s  CredmanCredHead %#x\n", pszBanner, addrCredmanCredHead);
    
        for (addrCredmanCred = ReadStructPtrField(addrCredmanCredHead, kstrListEntry, kstrFlink);
             addrCredmanCred != addrCredmanCredHead;
             addrCredmanCred = ReadStructPtrField(addrCredmanCred, kstrListEntry, kstrFlink))
        {
            dprintf("%s  ", szBanner);
            dprintf(kstrTypeAddrLn, kstrKerbCredCred, addrCredmanCred);
    
            LsaInitTypeRead(addrCredmanCred - ulFieldOffset, kerberos!_KERB_CREDMAN_CRED);
        
            dprintf("%s  CredentialFlags ", szBanner);
            ShowKerbCredFlags(kstrEmptyA, LsaReadULONGField(CredentialFlags));
    
            dprintf("%s  CredUserName    %ws\n", szBanner, TSTRING(addrCredmanCred - ulFieldOffset + ReadFieldOffset(kstrKerbCredCred, "CredmanUserName")).toWStrDirect());
            dprintf("%s  CredDomainName  %ws\n", szBanner, TSTRING(addrCredmanCred - ulFieldOffset + ReadFieldOffset(kstrKerbCredCred, "CredmanDomainName")).toWStrDirect());
    
            ShowKerbPrimaryCredential(szBanner2, ReadStructPtrField(addrCredmanCred -  ulFieldOffset, kstrKerbCredCred, "SuppliedCredentials"), fOptions);
        }  
    } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL);
}

DECLARE_API(kerbsess)
{
    HRESULT hRetval = S_OK;

    LUID LogonId = {0};
    LUID LogonIdRemote = {0};

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG64 exprValue = 0;
    BOOL bOneOnly = FALSE;
    BOOL bIsDone = FALSE;
    PSTR pszTmp = NULL;

    //
    // kerb Logon Session list anchor
    //

    ULONG64 addrKerbLogonSessionHead = 0;
    ULONG64 addrKerbLogonSession = 0;
    ULONG ulFieldOffset = 0;
    ULONG cKerbLogonSessions = 0;

    try
    {
        if (args && *args)
        {
            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessKerbLogonSessionListOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval) && !IsEmpty(szArgs))
        {
            bOneOnly = TRUE;

            pszTmp = strchr(szArgs, ':');

            if (pszTmp)
            {
                *pszTmp = ' ';

                hRetval = GetExpressionEx(szArgs, &exprValue, &args) ? S_OK : E_FAIL;

                if (SUCCEEDED(hRetval))
                {
                    LogonId.HighPart = static_cast<ULONG>(exprValue);

                    hRetval = GetExpressionEx(args, &exprValue, &args) ? S_OK : E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    LogonId.LowPart = static_cast<ULONG>(exprValue);
                    DBG_LOG(LSA_LOG, ("kerbsess %#x:%#x\n", LogonId.HighPart, LogonId.LowPart));
                }
            }
            else
            {
                 hRetval = GetExpressionEx(szArgs, &addrKerbLogonSession, &args) && addrKerbLogonSession ? S_OK : E_INVALIDARG;
            }
        }

        if (SUCCEEDED(hRetval))
        {
            ulFieldOffset = ReadFieldOffset(kstrKrbLogSess, "ListEntry.Next");

            if (!bOneOnly || pszTmp) // pszTmp not null means an logon id is supplied
            {
                hRetval = GetExpressionEx(KERB_LOGON_LIST, &addrKerbLogonSessionHead, &args) && addrKerbLogonSessionHead ? S_OK : E_FAIL;

                if (FAILED(hRetval))
                {
                    dprintf("Unable to read " KERB_LOGON_LIST ", try \"dt -x " KERB_LOGON_LIST "\" to verify\n");

                    hRetval = E_FAIL;
                }
                else
                {
                    if (!bOneOnly)
                    {
                        dprintf("Kerb logon session anchor %#I64x\n", toPtr(addrKerbLogonSessionHead));
                    }

                    for (addrKerbLogonSession = ReadStructPtrField(addrKerbLogonSessionHead, kstrListEntry, kstrFlink);
                         addrKerbLogonSession != addrKerbLogonSessionHead && !bIsDone;
                         addrKerbLogonSession = ReadStructPtrField(addrKerbLogonSession, kstrListEntry, kstrFlink))
                    {
                        ReadStructField(addrKerbLogonSession - ulFieldOffset, kstrKrbLogSess, "LogonId.HighPart", sizeof(LogonIdRemote.HighPart), &LogonIdRemote.HighPart);
                        ReadStructField(addrKerbLogonSession - ulFieldOffset, kstrKrbLogSess, "LogonId.LowPart", sizeof(LogonIdRemote.LowPart), &LogonIdRemote.LowPart);

                        if (bOneOnly)
                        {
                            if (!RtlEqualLuid(&LogonId, &LogonIdRemote))
                            {
                                continue;
                            }
                            else
                            {
                                 bIsDone = TRUE;
                            }
                        }

                        if (!bOneOnly)
                        {
                            dprintf("#%d)", cKerbLogonSessions++);
                        }

                        ShowKerbLogonSession(bOneOnly ? kstrEmptyA : kstr2Spaces, addrKerbLogonSession - ulFieldOffset, fOptions);
                    }
                    if (!bOneOnly)
                    {
                        dprintf("There are a total of %d kerberos logon sessions\n", cKerbLogonSessions);
                    }
                    else if (!bIsDone)
                    {
                        dprintf("Kerberos logon session for %#x:%#x was not found\n", LogonId.HighPart, LogonId.LowPart);
                    }
                }
            }
            else
            {
                ShowKerbLogonSession(kstrEmptyA, addrKerbLogonSession - ulFieldOffset, fOptions);
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display kerb logon session", kstrKrbLogSess);

    if (E_INVALIDARG == hRetval)
    {
        (void)DisplayUsage();
    }
    else if (FAILED(hRetval))
    {
        dprintf("Fail to display kerb Logon Session\n");
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsahandlelst.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsahandlelst.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsahandlelst.hxx"
#include "util.hxx"

#include "sid.hxx"
#include "lsahandle.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrlsahl);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
    dprintf(kstrVerbose);
}

HRESULT ProcessLsaHandleListOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

void ShowLsaHandleList(IN ULONG64 addrLsaHandleList, IN ULONG fOptions)
{
    ULONG64 addrStop = 0;
    ULONG64 addrNext = 0;

    ULONG cHandles = 0;

    dprintf("List anchor is ");

    dprintf(kstrTypeAddrLn, kstrDbHandle, addrLsaHandleList);

    LsaInitTypeRead(addrLsaHandleList, _LSAP_DB_HANDLE);

    addrStop = addrLsaHandleList;

    for (addrNext = LsaReadPtrField(Next); addrNext != addrStop; addrNext = LsaReadPtrField(Next)) {

        dprintf( "  #%lu) LsaHandleTable ", cHandles++);

        ShowLsaHandle(kstr4Spaces, addrNext, fOptions);
    }

    dprintf("  There are a total of %d lsa handles\n", cHandles);

    return;
}

DECLARE_API(dumplsahandlelist)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrLsaHandleList = 0;
    ULONG fieldOffset = 0;

    try {

        if (args && *args) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessLsaHandleListOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval)) {

           if (!IsEmpty(szArgs)) {

                hRetval = GetExpressionEx(szArgs, &addrLsaHandleList, &args) && addrLsaHandleList ? S_OK : E_FAIL;

            } else {

                hRetval = GetExpressionEx(DB_HANDLE_LST, &addrLsaHandleList, &args) && addrLsaHandleList ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read " DB_HANDLE_LST ", try \"dt -x " DB_HANDLE_LST "\" to verify\n");

                    hRetval = E_FAIL;
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

           ShowLsaHandleList(addrLsaHandleList, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display lsa handle list", kstrDbHandle);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsahandletbl.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsahandletbl.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsahandletbl.hxx"
#include "util.hxx"

#include "sid.hxx"
#include "lsahandle.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrlhtbl);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
    dprintf(kstrVerbose);
}

HRESULT ProcessLsaHandleTableOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

void ShowLsaHandleTypeList(IN ULONG64 addrListHead, IN ULONG fOptions)
{
    ULONG64 addrNext = 0;

    ULONG64 addrDbHandle = 0;
    ULONG fieldOffset = 0;
    ULONG cLsaHandles = 0;

    ExitIfControlC();

    dprintf("List anchor is ");

    dprintf(kstrTypeAddrLn, kstrDbHandle, addrListHead);

    addrNext = ReadStructPtrField(addrListHead, kstrListEntry, kstrFlink);

    fieldOffset = ReadFieldOffset(kstrDbHandle, kstrNext);

    while (addrNext != addrListHead) {

        addrDbHandle = addrNext - fieldOffset;

        dprintf("  #%d) ", cLsaHandles++);

        ShowLsaHandle(kstr4Spaces, addrDbHandle, fOptions);

        addrNext = ReadStructPtrField(addrDbHandle, kstrDbHandle, kstrNext);
    }

    dprintf("  There are a total of %d lsa handles\n", cLsaHandles);
}

void ShowLsaHandleTable(IN ULONG64 addrHandleTable, IN ULONG fOptions)
{
    ULONG64 addrCurrentUserEntry = 0;

    ULONG fieldOffset = 0;
    ULONG UserCount = 0;
    LUID LogonId = {0};

    dprintf(kstrTypeAddrLn, kstrDbHandleTbl, addrHandleTable);

    LsaInitTypeRead(addrHandleTable, _LSAP_DB_HANDLE_TABLE);

    fieldOffset = ReadFieldOffset(kstrDbTblUsr, kstrNext);

    addrCurrentUserEntry = LsaReadPtrField(UserHandleList.Flink) - fieldOffset;

    UserCount = LsaReadULONGField(UserCount);

    for (ULONG i = 0; i < UserCount; i++) {

        dprintf("#%lu) %s %#I64x\n", i, kstrDbTblUsr, addrCurrentUserEntry);

        ReadStructField(addrCurrentUserEntry, kstrDbTblUsr, "LogonId.HighPart", sizeof(LogonId.HighPart), &LogonId.HighPart);
        ReadStructField(addrCurrentUserEntry, kstrDbTblUsr, "LogonId.LowPart", sizeof(LogonId.LowPart), &LogonId.LowPart);

        dprintf("User id %x:%x\n", LogonId.HighPart, LogonId.LowPart);

        dprintf("UserToken %s\n", PtrToStr(ReadStructPtrField(addrCurrentUserEntry, kstrDbTblUsr, "UserToken")));

        dprintf("Policy Handle List: ");

        ShowLsaHandleTypeList(addrCurrentUserEntry + ReadFieldOffset(kstrDbTblUsr, "PolicyHandles"), fOptions);

        dprintf("Object Handle List: ");
        ShowLsaHandleTypeList(addrCurrentUserEntry + ReadFieldOffset(kstrDbTblUsr, "ObjectHandles"), fOptions);

        addrCurrentUserEntry = ReadStructPtrField(addrCurrentUserEntry, kstrDbTblUsr, "Next") - fieldOffset;
    }
}


DECLARE_API(dumplsahandletable)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrLsaHandleTable = 0;
    ULONG fieldOffset = 0;

    try {

        if (args && *args) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessLsaHandleTableOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval)) {

            if (!IsEmpty(szArgs)) {

                hRetval = GetExpressionEx(szArgs, &addrLsaHandleTable, &args) && addrLsaHandleTable ? S_OK : E_FAIL;

            } else {

                hRetval = GetExpressionEx(DB_HANDLE_TBL, &addrLsaHandleTable, &args) && addrLsaHandleTable ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read " DB_HANDLE_TBL ", try \"dt -x " DB_HANDLE_LST "\" to verify\n");

                    hRetval = E_FAIL;
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

           ShowLsaHandleTable(addrLsaHandleTable, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display lsa handle table", kstrDbHandleTbl);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsession.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsession.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsession.hxx"
#include "util.hxx"

#include "session.hxx"
#include "sid.hxx"

PCSTR g_cszLogonTypes[] =
{
    kstrInvalid,
    kstrInvalid,
    "Interactive",
    "Network",
    "Batch",
    "Service",
    "Proxy",
    "Unlock",
    "NetworkCleartext",
    "NewCredentials",
    "RemoteInteractive",  // Remote, yet interactive.  Terminal server
    "CachedInteractive",
};

#define LOGON_TYPE_NAME(x)  ((x < COUNTOF(g_cszLogonTypes)) ? g_cszLogonTypes[x] : kstrInvalid)

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrlssn);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf("   -c   Display NTLM logon sessin\n");
    dprintf("   -k   Display kerberos logon session\n");
    dprintf(kstrSidName);
    dprintf("   -s   Display SPNEGO logon session\n");
    dprintf(kstrRemarks);
    dprintf("   LogonId must be of form <HighPart>:<LowPart>\n");
}

HRESULT ProcessLogonSessionOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++)
    {
        if (*pszArgs == '-' || *pszArgs == '/')
        {
            switch (*++pszArgs)
            {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case 'c':
                *pfOptions |=  SHOW_NTLM;
                break;

            case 'k':
                *pfOptions |=  SHOW_KERB;
                 break;

            case 's':
                *pfOptions |=  SHOW_SPNEGO;
                 break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

#define LOGON_BY_NETLOGON   0x01    // Entry was validated by NETLOGON service
#define LOGON_BY_CACHE      0x02    // Entry was validated by local cache
#define LOGON_BY_OTHER_PACKAGE 0x04 // Entry was validated by another authentication package
#define LOGON_BY_LOCAL 0x08         // Entry was validated by local sam
#define LOGON_BY_NTLM3_DC   0x10    // Entry was validated by DC that understands NTLM3

void ShowNTLMActiveLogonFlags(IN PCSTR pszPad, IN ULONG ulFlags)
{

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (ulFlags & x) {                                   \
            dprintf("%s ", #x);                              \
            ulFlags &= ~ x;                                  \
        }                                                    \
    } while(0)                                               \

    dprintf("%s%#x : ", pszPad, ulFlags);

    BRANCH_AND_PRINT(LOGON_BY_NETLOGON);
    BRANCH_AND_PRINT(LOGON_BY_CACHE);
    BRANCH_AND_PRINT(LOGON_BY_OTHER_PACKAGE);
    BRANCH_AND_PRINT(LOGON_BY_LOCAL);
    BRANCH_AND_PRINT(LOGON_BY_NTLM3_DC);

    if (ulFlags)
    {
        dprintf("%#x", ulFlags);
    }
    dprintf(kstrNewLine);

#undef BRANCH_AND_PRINT
}

void ShowLogonSession(IN ULONG64 addrLogonSession, IN PCSTR pszLogEntry, IN ULONG fOptions)
{
    CHAR szBuffer[80] = {0};
    ULONG fieldOffset = 0;
    ULONG LogonType = 0;

    ExitIfControlC();

    dprintf(kstrTypeAddrLn, pszLogEntry, addrLogonSession);

    if (fOptions & SHOW_LSAP)
    {
        LsaInitTypeRead(addrLogonSession, lsasrv!_LSAP_LOGON_SESSION);
    }
    else if (fOptions & SHOW_NTLM)
    {
        LsaInitTypeRead(addrLogonSession, msv1_0!_ACTIVE_LOGON);
    }
    else if (fOptions & SHOW_KERB)
    {
        LsaInitTypeRead(addrLogonSession, kerberos!_KERB_LOGON_SESSION);
    }
    else if (fOptions & SHOW_SPNEGO)
    {
        LsaInitTypeRead(addrLogonSession, lsasrv!_NEG_LOGON_SESSION);
    }
    else
    {
        dprintf("Unknown logon session type %#x\n", fOptions);
        return;
    }

    dprintf("  LogonId         %#x:%#x\n", LsaReadULONGField(LogonId.HighPart), LsaReadULONGField(LogonId.LowPart));

    if (fOptions & SHOW_LSAP)
    {
        dprintf("  AuthorityName   %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "AuthorityName"));
        dprintf("  AccountName     %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "AccountName"));
        dprintf("  SID             ");
        ShowSid(kstrEmptyA, LsaReadPtrField(UserSid), fOptions);

        if (fOptions & SHOW_VERBOSE_INFO)
        {
            LogonType = LsaReadULONGField(LogonType);
            dprintf("  Logon Type      %d (%s)\n", LogonType, LOGON_TYPE_NAME(LogonType));
            dprintf("  Package         %d\n", LsaReadPtrField(CreatingPackage));
            dprintf("  Packages        _LSAP_PACKAGE_CREDENTIALS %s\n", PtrToStr(LsaReadPtrField(Packages)));
            dprintf("  UserCredSets    _USER_CREDENTIAL_SETS %s\n", PtrToStr(LsaReadPtrField(CredentialSets.UserCredentialSets)));
            dprintf("  SessCredSets    _SESSION_CREDENTIAL_SETS %s\n", PtrToStr(LsaReadPtrField(CredentialSets.SessionCredSets)));
            dprintf("  CredFlags       %#x\n", LsaReadULONGField(CredentialSets.Flags));
            dprintf("  DsNames         NameUnknown - NameDnsDomain -a%d PLSAP_DS_NAME_MAP %#x\n", DS_DNS_DOMAIN_NAME, addrLogonSession + ReadFieldOffset("lsasrv!_LSAP_LOGON_SESSION", "DsNames"));

            CTimeStampFromULONG64(LsaReadULONG64Field(LogonTime), TRUE, sizeof(szBuffer), szBuffer);
            dprintf("  Logon Time      %s\n", szBuffer);
        }
    }
    else if (fOptions & SHOW_NTLM)
    {
        dprintf("  LogonDomainName %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "LogonDomainName"));
        dprintf("  UserName        %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "UserName"));
        dprintf("  SID             ");
        ShowSid(kstrEmptyA, LsaReadPtrField(UserSid), fOptions);

        if (fOptions & SHOW_VERBOSE_INFO)
        {
            LogonType = LsaReadULONGField(LogonType);
            dprintf("  Logon Type      %d (%s)\n", LogonType, LOGON_TYPE_NAME(LogonType));
            ShowNTLMActiveLogonFlags("  Flags           ", LsaReadULONGField(Flags));
        }
    }
    else if (fOptions & SHOW_SPNEGO)
    {
        dprintf("  CreatingPackage %d\n", LsaReadULONGField(CreatingPackage));
        dprintf("  AlternateName   %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "AlternateName"));
    }
    else if (fOptions & SHOW_KERB)
    {
        dprintf("  DomainName      %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "PrimaryCredentials.DomainName"));
        dprintf("  UserName        %ws\n", ReadStructWStrField(addrLogonSession, pszLogEntry, "PrimaryCredentials.UserName"));
    }
}

ULONG LogonIdToListIndex(
    IN LUID* pId,
    IN ULONG ulListCount
    )
{
    return pId->LowPart & (ulListCount - 1);
}

DECLARE_API(dumplogonsession)
{
    HRESULT hRetval = E_FAIL;

    BOOL bIsLogonId = FALSE;
    LUID LogonId = {0};
    LUID LogonIdRemote = {0};

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 exprValue = 0;
    ULONG64 addrLogonSession = 0;

    PCSTR pszLogList = LSAP_LOGON_LIST;
    PCSTR pszLogEntry = "lsasrv!_LSAP_LOGON_SESSION";
    PCSTR pszNext = kstrListFlink;
    ULONG cLists = 1;

    //
    // Logon Session list anchor
    //

    ULONG64 addrLogonSessionHead = 0;
    ULONG64 addrLogonSessionHeadBase = 0;
    ULONG64 Temp = 0;

    ULONG fieldOffset = 0;
    ULONG cbListHead = 0;
    BOOLEAN bFound = FALSE;

    PSTR pTmp = NULL;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    try
    {
        if (SUCCEEDED(hRetval)) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);
            hRetval = ProcessLogonSessionOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval))
        {

            hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
        }

        if (SUCCEEDED(hRetval))
        {
            if (fOptions & SHOW_KERB)
            {
                pszLogList = KERB_LOGON_LIST;
                pszLogEntry = "kerberos!_KERB_LOGON_SESSION";
                pszNext = "ListEntry.Next.Flink";
            }
            else if (fOptions & SHOW_NTLM)
            {
                pszLogList = NTLM_LOGON_LIST;
                pszLogEntry = "msv1_0!_ACTIVE_LOGON";
                pszNext = "ListEntry.Flink";
            }
            else if (fOptions & SHOW_SPNEGO)
            {
                pszLogList = NEG_LOGON_LIST;
                pszLogEntry = "lsasrv!_NEG_LOGON_SESSION";
            }
            else
            {
                // fOptions & SHOW_LSAP
                fOptions |= SHOW_LSAP;

                pszLogList = LSAP_LOGON_LIST;
                pszLogEntry = "lsasrv!_LSAP_LOGON_SESSION";

                hRetval = GetExpressionEx("lsasrv!LogonSessionListCount", &Temp, &args) ? S_OK : E_FAIL;

                if (FAILED(hRetval))
                {
                    dprintf("Unable to read _LSAP_LOGON_SESSION list count, try \"dt -x lsasrv!LogonSessionListCount\" to verify\n");
                }
                else
                {
                    cLists = ReadULONGVar(Temp);
                    dprintf("number of _LSAP_LOGON_SESSION lists are %d\n", cLists);
                }
            }
        }

        if (SUCCEEDED(hRetval))
        {
            pTmp = strchr(szArgs, ':');

            if (pTmp)
            {
                bIsLogonId = TRUE;
                *pTmp = ' ';
            }

            if (bIsLogonId)
            {
                hRetval = GetExpressionEx(szArgs, &exprValue, &args) ? S_OK : E_FAIL;

                if (SUCCEEDED(hRetval))
                {
                    LogonId.HighPart = static_cast<ULONG>(exprValue);

                    hRetval = GetExpressionEx(args, &exprValue, &args) ? S_OK : E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    LogonId.LowPart = static_cast<ULONG>(exprValue);

                    hRetval = GetExpressionEx(pszLogList, &addrLogonSessionHeadBase, &args) ? S_OK : E_FAIL;
                }

                if (SUCCEEDED(hRetval) && !addrLogonSessionHeadBase)
                {
                    dprintf("Unable to read %s try \"dt -x %s\" to verify\n", pszLogEntry, pszLogEntry);

                    hRetval = E_FAIL;
                }

                if (SUCCEEDED(hRetval))
                {
                    if (!(fOptions & SHOW_NTLM))
                    {
                        fieldOffset = ReadFieldOffset(pszLogEntry, pszNext);
                    }
                    else
                    {
                        fieldOffset = 0;
                    }
                }

                if (cLists)
                {
                    if (fOptions & SHOW_NTLM)
                    {
                        cbListHead = ReadTypeSizeInArray(pszLogEntry);
                    }
                    else // everything else
                    {
                        cbListHead = ReadTypeSizeInArray("_LIST_ENTRY");
                    }
                }

                for (ULONG i = 0; SUCCEEDED(hRetval) && i < cLists; i++)
                {
                    if (fOptions & SHOW_LSAP)
                    {
                        i = LogonIdToListIndex(&LogonId, cLists);
                        dprintf("searching logon id %#x:%#x in %s[%d] outof %d lists\n", LogonId.HighPart, LogonId.LowPart, pszLogList, i, cLists);
                        cLists = i; // stop the loop
                    }

                    //
                    // Get list anchor's Flink
                    //

                    addrLogonSessionHead = addrLogonSessionHeadBase + i * cbListHead;
                    addrLogonSession = ReadPtrVar(addrLogonSessionHead);

                    for (
                         /* empty */;
                         addrLogonSession != addrLogonSessionHead;
                         addrLogonSession = ReadStructPtrField(addrLogonSession, pszLogEntry, pszNext) - fieldOffset
                         )
                    {
                        ReadStructField(addrLogonSession, pszLogEntry, "LogonId.HighPart", sizeof(LogonIdRemote.HighPart), &LogonIdRemote.HighPart);
                        ReadStructField(addrLogonSession, pszLogEntry, "LogonId.LowPart", sizeof(LogonIdRemote.LowPart), &LogonIdRemote.LowPart);

                        if (RtlEqualLuid(&LogonId, &LogonIdRemote))
                        {
                            DBG_LOG(LSA_LOG, ("found in %s %#I64x\n", pszLogEntry, addrLogonSession));
                            bFound = TRUE;
                            break;
                        }
                    }
                }
            }
            else
            {
                hRetval = GetExpressionEx(szArgs, &addrLogonSession, &args) && addrLogonSession ? S_OK : E_FAIL;
            }

            if (SUCCEEDED(hRetval))
            {
                if ((bIsLogonId && bFound) || !bIsLogonId)
                {
                    ShowLogonSession(addrLogonSession, pszLogEntry, fOptions | SHOW_VERBOSE_INFO);
                }
                else if (bIsLogonId && !bFound)
                {
                    dprintf("Logon session %#x:%#x is not found in %s\n", LogonId.HighPart, LogonId.LowPart, pszLogList);
                }
            }
            else
            {
                dprintf("Failed to display Logon Session\n");
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display logon session", pszLogList);

    if (E_INVALIDARG == hRetval)
    {
        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\name2sid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    name2sid.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "name2sid.hxx"
#include "util.hxx"
#include "token.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrnm2sd);
    dprintf(kstrRemarks);
    dprintf("   Account name is in standard file path notation and of form domain\\user\n");
}

DECLARE_API(name2sid)
{
    HRESULT hRetval = E_FAIL;
    CHAR Sid[MAX_PATH] = {0}; // SubAuthority count is 63 is properly large enough
    DWORD cbSid = sizeof(Sid);
    CHAR szDomainName[MAX_PATH] = {0};
    DWORD cbDomainName = sizeof(szDomainName) - 1;
    SID_NAME_USE eUse = SidTypeInvalid;
    PCSTR pszUserName = NULL;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    if (FAILED(hRetval) && (E_INVALIDARG == hRetval)) {

        DBG_LOG(LSA_LOG, ("args are %s\n", args));
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetFileNamePart(args, &pszUserName);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = LsaLookupAccountNameA(NULL, args, Sid, &cbSid, szDomainName, &cbDomainName, &eUse) ? S_OK : GetLastErrorAsHResult();

        DBG_LOG(LSA_LOG, ("LookupAccountNameA for \"%s\" status %#x\n", args, hRetval));
    }

    if (SUCCEEDED(hRetval)) {

        dprintf("Account name: %s\nResolved as: %s\\%s\nSid type: %s\nSid: ", args, szDomainName, EasyStr(pszUserName), TSID::GetSidTypeStr(eUse));
        LocalDumpSid(kstrEmptyA, Sid, 0);

    } else if (FAILED(hRetval) && (ERROR_NONE_MAPPED == HRESULT_CODE(hRetval))) {

        dprintf("No mapping sid is found for account \"%s\"\n", args);
        hRetval = S_OK;
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();

    } else if (FAILED(hRetval)) {

        dprintf("Unable to look up sid by account name\n");
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\lsessionlst.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lsessionlst.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsessionlst.hxx"
#include "util.hxx"

#include "lsession.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrlssnl);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf("   -c   Display NTLM logon sessin list\n");
    dprintf("   -k   Display kerberos logon session list\n");
    dprintf(kstrSidName);
    dprintf("   -s   Display SPNEGO logon session list\n");
    dprintf(kstrVerbose);
}

HRESULT ProcessLogonSessionListOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++)
    {
        if (*pszArgs == '-' || *pszArgs == '/')
        {
            switch (*++pszArgs)
            {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case 'c':
                *pfOptions |=  SHOW_NTLM;
                break;

            case 'k':
                *pfOptions |=  SHOW_KERB;
                 break;

            case 's':
                *pfOptions |=  SHOW_SPNEGO;
                 break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumplogonsessionlist)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrLogonSession = 0;
    PCSTR pszLogList = LSAP_LOGON_LIST;
    PCSTR pszLogEntry = "lsasrv!_LSAP_LOGON_SESSION";
    PCSTR pszNext = kstrListFlink;
    ULONG LogonSessionListCount = 0;
    ULONG64 Temp = 0;

    //
    // Logon Session's list anchor
    //

    ULONG64 addrLogonSessionHead = 0;
    ULONG64 addrLogonSessionHeadBase = 0;

    ULONG fieldOffset = 0;
    ULONG cLogonSession = 0;
    ULONG cLists = 1;
    ULONG cbListHead = 0;

    try
    {
        if (args && *args)
        {
            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessLogonSessionListOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval))
        {
            if (fOptions & SHOW_KERB)
            {
                pszLogList = KERB_LOGON_LIST;
                pszLogEntry = "kerberos!_KERB_LOGON_SESSION";
                pszNext = "ListEntry.Next.Flink";
            }
            else if (fOptions & SHOW_NTLM)
            {
                pszLogList = NTLM_LOGON_LIST;
                pszLogEntry = "msv1_0!_ACTIVE_LOGON";
                pszNext = "ListEntry.Flink";
            }
            else if (fOptions & SHOW_SPNEGO)
            {
                pszLogList = NEG_LOGON_LIST;
                pszLogEntry = "lsasrv!_NEG_LOGON_SESSION";
            }
            else
            {
                // fOptions & SHOW_LSAP
                fOptions |= SHOW_LSAP;

                pszLogList = LSAP_LOGON_LIST;
                pszLogEntry = "lsasrv!_LSAP_LOGON_SESSION";
                hRetval = GetExpressionEx("lsasrv!LogonSessionListCount", &Temp, &args) ? S_OK : E_FAIL;

                if (FAILED(hRetval))
                {
                    dprintf("Unable to read _LSAP_LOGON_SESSION list count, try \"dt -x lsasrv!LogonSessionListCount\" to verify\n");
                }
                else
                {
                    cLists = ReadULONGVar(Temp);
                    dprintf("number of _LSAP_LOGON_SESSION lists are %d\n", cLists);
                }
            }
        }

        if (SUCCEEDED(hRetval))
        {
            if (!IsEmpty(szArgs))
            {
                pszLogList = NULL;
                cLists = 1; // one list only
                hRetval = GetExpressionEx(szArgs, &addrLogonSessionHeadBase, &args) && addrLogonSessionHeadBase ? S_OK : E_INVALIDARG;
            }
            else
            {
                hRetval = GetExpressionEx(pszLogList, &addrLogonSessionHeadBase, &args) ? S_OK : E_FAIL;

                if (SUCCEEDED(hRetval) && !addrLogonSessionHeadBase)
                {
                    dprintf("LogonSession list head %s not found, try \"dt -x %s \" to verify\n", pszLogList, pszLogList);

                    hRetval = E_FAIL;
                }
            }
        }

        if (SUCCEEDED(hRetval))
        {
            if (!(fOptions & SHOW_NTLM))
            {
                fieldOffset = ReadFieldOffset(pszLogEntry, pszNext);
            }
            else
            {
                fieldOffset = 0;
            }

            if (cLists)
            {
                cbListHead = ReadTypeSizeInArray("_LIST_ENTRY");
            }

            for (ULONG i = 0; SUCCEEDED(hRetval) && i < cLists; i++)
            {
                //
                // Get list anchor's Flink
                //

                addrLogonSessionHead = addrLogonSessionHeadBase + i * cbListHead;
                addrLogonSession = ReadPtrVar(addrLogonSessionHead);

                dprintf("\nList head is %s %#I64x\n", pszLogEntry, addrLogonSessionHead);

                for (
                     /* empty */;
                     addrLogonSession != addrLogonSessionHead;
                     addrLogonSession = ReadStructPtrField(addrLogonSession, pszLogEntry, pszNext) - fieldOffset
                     )
                {
                    dprintf("#%d) ", cLogonSession++);
                    ShowLogonSession(addrLogonSession, pszLogEntry, fOptions);
                }
            }

            if (FAILED(hRetval))
            {
                dprintf("Unable to display %s\n", pszLogList);
            }
            else
            {
                dprintf("\nThere are a total of %d logon sessions\n", cLogonSession);
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display logon session list", pszLogList);

    if (E_INVALIDARG == hRetval)
    {
        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\objsec.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    objsec.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "objsec.hxx"
#include "util.hxx"
#include "sid.hxx"
#include "acl.hxx"
#include "sd.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrobjs);
    dprintf(kstrOptions);
    dprintf(kstrSidName);
    dprintf(kstrVerbose);
}

void  DumpSID(PCSTR pszPad, PSID psid_to_dump, ULONG Flag)
{
    NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING us = {0};

    if (psid_to_dump) {

        ntstatus = RtlConvertSidToUnicodeString(&us, psid_to_dump, TRUE);

        if (NT_SUCCESS(ntstatus)) {

            dprintf("%s%wZ", pszPad, &us);
            RtlFreeUnicodeString(&us);

        } else {

            dprintf("%#x: Can't Convert SID to UnicodeString\n", ntstatus);
        }

        if (Flag & SHOW_FRIENDLY_NAME) {

            dprintf(kstrSpace);

            PCSTR pszStr = TSID::ConvertSidToFriendlyName(psid_to_dump, kstrSidNameFmt);

            if (pszStr && *pszStr) {

                dprintf(pszStr);
            }
        }
    } else {

        dprintf("%s is (null)", pszPad);
    }

    dprintf(kstrNewLine);
}

BOOL DumpACL (IN PCSTR pszPad, IN ACL *pacl, IN ULONG Flags)
{
    USHORT x = 0;
    CHAR more_pad[MAX_PATH] = {0};
    CHAR tmp_pad[MAX_PATH] = {0};

    sprintf(more_pad, "%s    ", pszPad);

    if (pacl == NULL) {
        dprintf("%s is (null)\n", pszPad);
        return FALSE;
    }

    dprintf("%sAclRevision: %#x\n", pszPad, pacl->AclRevision);
    dprintf("%sSbz1: %#x\n", pszPad, pacl->Sbz1);
    dprintf("%sAclSize: %#x\n", pszPad, pacl->AclSize);
    dprintf("%sAceCount: %#x\n", pszPad, pacl->AceCount);
    dprintf("%sSbz2: %#x\n", pszPad, pacl->Sbz2);

    for (x = 0; x < pacl->AceCount; x++) {

        PACE_HEADER ace = NULL;
        NTSTATUS result = STATUS_UNSUCCESSFUL;

        dprintf("%sAce[%u]\n", pszPad, x);

        result = RtlGetAce(pacl, x, reinterpret_cast<void**>(&ace));
        if (!NT_SUCCESS(result)) {

            dprintf("%sCan't GetAce, %#x\n", pszPad, result);
            return FALSE;
        }

        dprintf("%s    AceType %#x: ", pszPad, ace->AceType);

        if (!DumpAceType(kstrEmptyA, ace->AceType)) {

             continue;
        }

        dprintf("%s    AceFlags: %#x\n", pszPad, ace->AceFlags);

        _snprintf(tmp_pad, sizeof(tmp_pad) - 1, "%s        ", pszPad);
        DumpAceFlags(tmp_pad, ace->AceFlags);

        dprintf("%s    AceSize: %#x\n", pszPad, ace->AceSize);

        /*
            From now on it is ace specific stuff.
            Fortunately ACEs can be split into 3 groups,
            with the ACE structure being the same within the group
        */

        switch (ace->AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            {
                SYSTEM_AUDIT_ACE* tace = reinterpret_cast<SYSTEM_AUDIT_ACE*>(ace);

                dprintf("%s    Mask: %#x\n", pszPad, tace->Mask);

                DumpSID(more_pad, &(tace->SidStart), Flags);
            }
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            {
                COMPOUND_ACCESS_ALLOWED_ACE* tace = reinterpret_cast<COMPOUND_ACCESS_ALLOWED_ACE*>(ace);
                BYTE* ptr = NULL;

                dprintf("%s    Mask: %#x\n", pszPad, tace->Mask);
                dprintf("%s    CompoundAceType: %#x\n", pszPad, tace->CompoundAceType);
                dprintf("%s    Reserved: %#x\n", pszPad, tace->Reserved);

                DumpSID(more_pad, &(tace->SidStart), Flags);

                ptr = reinterpret_cast<BYTE*>(&(tace->SidStart));
                ptr += RtlLengthSid(reinterpret_cast<PSID>(ptr)); /* Skip this & get to next sid */

                DumpSID(more_pad, ptr, Flags);
            }
            break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            {
                ACCESS_ALLOWED_OBJECT_ACE *tace = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE*>(ace);
                BYTE* ptr = NULL;
                GUID* obj_guid = NULL, *inh_obj_guid = NULL;

                dprintf("%s    Mask: %#x\n", pszPad, tace->Mask);
                dprintf("%s    Flags: %#x\n", pszPad, tace->Flags);

                ptr = reinterpret_cast<BYTE*>(&(tace->ObjectType));

                if (tace->Flags & ACE_OBJECT_TYPE_PRESENT) {

                    dprintf("%s         ACE_OBJECT_TYPE_PRESENT\n", pszPad);
                    obj_guid = &(tace->ObjectType);
                    ptr = reinterpret_cast<BYTE*>(&(tace->InheritedObjectType));
                }

                if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

                    dprintf("%s        ACE_INHERITED_OBJECT_TYPE_PRESENT\n", pszPad);
                    inh_obj_guid = &(tace->InheritedObjectType);
                    ptr = reinterpret_cast<PBYTE>(&(tace->SidStart));
                }

                if (obj_guid) {

                    dprintf("%s    ObjectType (in HEX): ", pszPad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        obj_guid->Data1,
                        obj_guid->Data2,
                        obj_guid->Data3,
                        obj_guid->Data4[0],
                        obj_guid->Data4[1],
                        obj_guid->Data4[2],
                        obj_guid->Data4[3],
                        obj_guid->Data4[4],
                        obj_guid->Data4[5],
                        obj_guid->Data4[6],
                        obj_guid->Data4[7]);
                }

                if (inh_obj_guid) {

                    dprintf("%s    InhObjTYpe (in HEX): ", pszPad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        inh_obj_guid->Data1,
                        inh_obj_guid->Data2,
                        inh_obj_guid->Data3,
                        inh_obj_guid->Data4[0],
                        inh_obj_guid->Data4[1],
                        inh_obj_guid->Data4[2],
                        inh_obj_guid->Data4[3],
                        inh_obj_guid->Data4[4],
                        inh_obj_guid->Data4[5],
                        inh_obj_guid->Data4[6],
                        inh_obj_guid->Data4[7]);
                }

                DumpSID(more_pad, ptr, Flags);
            }
        }
    }

    return TRUE;
}

void DumpSD(IN PVOID pvSD, IN ULONG fOptions)
{
    SECURITY_DESCRIPTOR* pSD = reinterpret_cast<SECURITY_DESCRIPTOR*>(pvSD);

    PSID pOwner = NULL, pGroup = NULL;
    PACL pDacl = NULL, pSacl = NULL;

    dprintf("Revision: %lu\n", pSD->Revision);
    dprintf("Sbz1: %lu\n", pSD->Sbz1);
    dprintf("Control: %#x\n", pSD->Control);

    DumpSDControlFlags(kstr4Spaces, pSD->Control);

    if ((pSD->Control & SE_SELF_RELATIVE) == SE_SELF_RELATIVE) {

        SECURITY_DESCRIPTOR_RELATIVE *pSDR = reinterpret_cast<SECURITY_DESCRIPTOR_RELATIVE*>(pSD);

        DBG_LOG(LSA_LOG, ("0x%p _SECURITY_DESCRIPTOR_RELATIVE\n", pSDR));

        if (pSDR->Owner != 0) {

            pOwner = reinterpret_cast<SID*>(reinterpret_cast<UCHAR*>(pSDR) + pSDR->Owner);
        }

        if (pSDR->Group != 0) {

            pGroup = reinterpret_cast<SID*>(reinterpret_cast<UCHAR*>(pSDR) + pSDR->Group);        }

        if (pSDR->Dacl != 0) {

            pDacl = reinterpret_cast<ACL*>(reinterpret_cast<UCHAR*>(pSDR) + pSDR->Dacl);
        }

        if (pSDR->Sacl != 0) {

            pSacl = reinterpret_cast<ACL*>(reinterpret_cast<UCHAR*>(pSDR) + pSDR->Sacl);
        }

    } else {

        DBG_LOG(LSA_LOG, ("0x%p SECURITY_DESCRIPTOR\n", pSD));

        pOwner = pSD->Owner;
        pGroup = pSD->Group;
        pDacl = pSD->Dacl;
        pSacl = pSD->Sacl;
    }

    dprintf("Owner: ");

    if (pOwner) {

        DumpSID(kstrEmptyA, pOwner, fOptions);

    } else {

        dprintf(kstrStrLn, kstrNullPtrA);
    }

    dprintf("Group: ");

    if (pGroup) {

        DumpSID(kstrEmptyA, pGroup, fOptions);

    } else {

        dprintf(kstrStrLn, kstrNullPtrA);
    }

    dprintf("DACL:\n");

    if (pDacl) {

        DumpACL(kstr4Spaces, pDacl, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }

    dprintf("SACL:\n");

    if (pSacl) {

        DumpACL(kstr4Spaces, pSacl, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }
}

HRESULT ProcessObjsecOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {

            case 'n':
                *pfOptions |= SHOW_FRIENDLY_NAME;
                break;

            case 'v':
                *pfOptions |= SHOW_VERBOSE_INFO;
                break;


            // case '1': // allow -1 pseudo handle
            //    continue;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

NTSTATUS ShowSecDesc(IN HANDLE hSecObj, IN ULONG fOptions)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PVOID pSecurityDescriptor = NULL;
    ULONG Length = 0;
    BOOLEAN Present = FALSE;
    BOOLEAN defaulted = FALSE;

    NtStatus = NtQuerySecurityObject(hSecObj, DACL_SECURITY_INFORMATION, NULL, 0, &Length);

    if (STATUS_BUFFER_TOO_SMALL == NtStatus) {

        pSecurityDescriptor = new UCHAR[Length];

        NtStatus = pSecurityDescriptor ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtQuerySecurityObject(hSecObj, DACL_SECURITY_INFORMATION, pSecurityDescriptor, Length, &Length);
    }

    if (NT_SUCCESS(NtStatus) && pSecurityDescriptor) {

        (void)DumpSD(pSecurityDescriptor, fOptions);

    } else {

        DBG_LOG(LSA_ERROR, ("ShowSecDesc failed with %#x\n", NtStatus));

        dprintf("NtQuerySecurityObject failed with %#x\n", NtStatus);
    }

    if (pSecurityDescriptor) {

        delete [] pSecurityDescriptor;
    }

    return NtStatus;
}

NTSTATUS ShowObjSec(IN HANDLE hSourceProcess, IN HANDLE hObj, IN ULONG fOptions)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    HANDLE hDup = 0;

    NtStatus = DuplicateHandle(hSourceProcess, // source process
                   hObj,
                   GetCurrentProcess(),        // target process
                   &hDup, 0, FALSE,
                   DUPLICATE_SAME_ACCESS) ? STATUS_SUCCESS : GetLastErrorAsNtStatus();

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = ShowSecDesc(hDup, fOptions);

    } else {

        DBG_LOG(LSA_ERROR, ("DuplicateHandle failed to duplicate handle %p with last error %#x\n", hObj, GetLastError()));
    }

    if (hDup) {

        CloseHandle(hDup);
    }

    return NtStatus;
}

NTSTATUS ShowCurrentThreadAndProcessSec(IN HANDLE hProcess, IN HANDLE hThread, IN ULONG fOptions)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    HANDLE hToken = NULL;

    dprintf("Current thread security descriptor...\n");

    NtStatus = ShowSecDesc(hThread, fOptions);

    if (NT_SUCCESS(NtStatus) && (fOptions & SHOW_VERBOSE_INFO)) {

        NtStatus = NtOpenThreadToken(hThread, TOKEN_ALL_ACCESS, FALSE, &hToken);

        if ((NtStatus == STATUS_NO_TOKEN) || (hToken == NULL)) {

            NtStatus = STATUS_SUCCESS;

            dprintf("Thread is not impersonating. no sd for thread token.\n");

        } else if (NT_SUCCESS(NtStatus)) {

            dprintf("Displaying sd for thread token %p...\n", hToken);
            NtStatus = ShowSecDesc(hToken, fOptions);
        }
    }

    if (hToken)
    {
        NtClose(hToken);
        hToken = NULL;
    }

    if (NT_SUCCESS(NtStatus)) {

        dprintf("Current process security descriptor...\n");

        NtStatus = ShowSecDesc(hProcess, fOptions);
    }

    if (NT_SUCCESS(NtStatus) && (fOptions & SHOW_VERBOSE_INFO)) {

        NtStatus = NtOpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &hToken);

        if ((NtStatus == STATUS_NO_TOKEN) || (hToken == NULL)) {

            NtStatus = STATUS_SUCCESS;

            dprintf("Thread is not impersonating. Using process token...\n");

        } else if (NT_SUCCESS(NtStatus)) {

            dprintf("Displaying sd for process token %p...\n", hToken);
            NtStatus = ShowSecDesc(hToken, fOptions);
        }
    }

    if (hToken)
    {
        NtClose(hToken);
    }

    return NtStatus;
}

HRESULT LiveSessionSecobj(IN HANDLE hThread, IN HANDLE hRemoteObj, IN ULONG fOptions)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    HANDLE hProcess = NULL;

    GetCurrentProcessHandle(&hProcess);

    NtStatus = hProcess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    if (NT_SUCCESS(NtStatus)) {

        if (hRemoteObj) {

            NtStatus = ShowObjSec(hProcess, hRemoteObj, fOptions);

        } else {

            DBG_LOG(LSA_LOG, ("Current thread %p, current process %p\n", hThread, hProcess));

            NtStatus = ShowCurrentThreadAndProcessSec(hProcess, hThread, fOptions);
        }
    }

    return NT_SUCCESS(NtStatus) ? S_OK : E_FAIL;
}

DECLARE_API(objsec)
{
    HRESULT hRetval = S_OK;

    ULONG64 addrObjHandle = 0;
    ULONG dwProcessor = 0;
    HANDLE hCurrentThread = 0;
    ULONG SessionType = DEBUG_CLASS_UNINITIALIZED;
    ULONG SessionQual = 0;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    if (args && *args) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessObjsecOptions(szArgs, &fOptions);

        if (SUCCEEDED(hRetval) && !IsEmpty(szArgs)) {

            hRetval = GetExpressionEx(szArgs, &addrObjHandle, &args) && addrObjHandle ? S_OK : E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = ExtQuery(Client);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread);
    }

    if (SUCCEEDED(hRetval)) {

       hRetval = g_ExtControl->GetDebuggeeType(&SessionType, &SessionQual);
    }

    if (SUCCEEDED(hRetval)) {

        if ( SessionType == DEBUG_CLASS_USER_WINDOWS &&
             SessionQual == DEBUG_USER_WINDOWS_PROCESS ) {

            hRetval = LiveSessionSecobj(hCurrentThread,
                                       reinterpret_cast<HANDLE>(static_cast<ULONG_PTR>(addrObjHandle)),
                                       fOptions);

            if (FAILED(hRetval)) {

                dprintf("Unable to display kernel object security descriptor\n");
            }
         } else if (DEBUG_CLASS_KERNEL == SessionType) {

            dprintf("lsaexts.objsec is user mode only, use \"dt nt!_OBJECT_HEADER\" instead\n");

         }  else {

            dprintf("lsaexts.objsec debugger type not supported: SessionType %#x, SessionQual %#x\n", SessionType, SessionQual);

            hRetval = DEBUG_EXTENSION_CONTINUE_SEARCH;
         }
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    (void)ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\ntlm.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntlm.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "ntlm.hxx"
#include "util.hxx"
#include <ntlmsp.h>

//
// Valid values of NegotiateFlags
//
typedef struct _NTLM_NEG_FLAGS {
    PCSTR desc;
    ULONG flag;
} NTLM_NEG_FLAGS;

NTLM_NEG_FLAGS g_flagTable[] = {
//
// Valid values of NegotiateFlags
//
    {"NTLMSSP_NEGOTIATE_UNICODE", NTLMSSP_NEGOTIATE_UNICODE},   // Text strings are in unicode
    {"NTLMSSP_NEGOTIATE_OEM", NTLMSSP_NEGOTIATE_OEM},   // Text strings are in OEM
    {"NTLMSSP_REQUEST_TARGET", NTLMSSP_REQUEST_TARGET},   // Server should return its authentication realm
    {"NTLMSSP_NEGOTIATE_SIGN", NTLMSSP_NEGOTIATE_SIGN},   // Request signature capability
    {"NTLMSSP_NEGOTIATE_SEAL", NTLMSSP_NEGOTIATE_SEAL},   // Request confidentiality
    {"NTLMSSP_NEGOTIATE_DATAGRAM", NTLMSSP_NEGOTIATE_DATAGRAM},   // Use datagram style authentication
    {"NTLMSSP_NEGOTIATE_LM_KEY", NTLMSSP_NEGOTIATE_LM_KEY},   // Use LM session key for sign/seal
    {"NTLMSSP_NEGOTIATE_NETWARE", NTLMSSP_NEGOTIATE_NETWARE},   // NetWare authentication
    {"NTLMSSP_NEGOTIATE_NTLM", NTLMSSP_NEGOTIATE_NTLM},   // NTLM authentication
    {"NTLMSSP_NEGOTIATE_NT_ONLY",  NTLMSSP_NEGOTIATE_NT_ONLY},   // NT authentication only (no LM)
    {"NTLMSSP_NEGOTIATE_NULL_SESSION", NTLMSSP_NEGOTIATE_NULL_SESSION},   // NULL Sessions on NT 5.0 and beyand
    {"NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED", NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED },   // Domain Name supplied on negotiate
    {"NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED", NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED },   // Workstation Name supplied on negotiate
    {"NTLMSSP_NEGOTIATE_LOCAL_CALL", NTLMSSP_NEGOTIATE_LOCAL_CALL},   // Indicates client/server are same machine
    {"NTLMSSP_NEGOTIATE_ALWAYS_SIGN", NTLMSSP_NEGOTIATE_ALWAYS_SIGN},   // Sign for all security levels


//
// Valid target types returned by the server in Negotiate Flags
//
    {"NTLMSSP_TARGET_TYPE_DOMAIN", NTLMSSP_TARGET_TYPE_DOMAIN},   // TargetName is a domain name
    {"NTLMSSP_TARGET_TYPE_SERVER", NTLMSSP_TARGET_TYPE_SERVER},   // TargetName is a server name
    {"NTLMSSP_TARGET_TYPE_SHARE", NTLMSSP_TARGET_TYPE_SHARE},   // TargetName is a share name
    {"NTLMSSP_NEGOTIATE_NTLM2", NTLMSSP_NEGOTIATE_NTLM2},   // NTLM2 authentication added for NT4-SP4

    {"NTLMSSP_NEGOTIATE_IDENTIFY", NTLMSSP_NEGOTIATE_IDENTIFY},   // Create identify level token

//
// Valid requests for additional output buffers
//
    {"NTLMSSP_REQUEST_INIT_RESPONSE", NTLMSSP_REQUEST_INIT_RESPONSE},   // get back session keys
    {"NTLMSSP_REQUEST_ACCEPT_RESPONSE", NTLMSSP_REQUEST_ACCEPT_RESPONSE},   // get back session key, LUID
    {"NTLMSSP_REQUEST_NON_NT_SESSION_KEY", NTLMSSP_REQUEST_NON_NT_SESSION_KEY},   // request non-nt session key
    {"NTLMSSP_NEGOTIATE_TARGET_INFO", NTLMSSP_NEGOTIATE_TARGET_INFO},   // target info present in challenge message

    {"NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT", NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT},   // It's an exported context

    {"NTLMSSP_NEGOTIATE_128", NTLMSSP_NEGOTIATE_128},   // negotiate 128 bit encryption
    {"NTLMSSP_NEGOTIATE_KEY_EXCH", NTLMSSP_NEGOTIATE_KEY_EXCH},   // exchange a key using key exchange key
    {"NTLMSSP_NEGOTIATE_56", NTLMSSP_NEGOTIATE_56},   // negotiate 56 bit encryption

//
// flags used in client space to control sign and seal; never appear on the wire
//
    {"NTLMSSP_APP_SEQ", NTLMSSP_APP_SEQ},   // Use application provided seq num
    };

PCSTR g_attr_table[] = {
    kstrEmptyA,
    "NetbiosServerName",
    "NetbiosDomainName",
    "DnsComputerName",
    "DnsDomainName",
    "DnsTreeName",
    "Flags",
    kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA,
};

void debugPrintString32TargetInfo(IN STRING32* pTargetInfo, IN const void* buffer)
{
    const CHAR* start =  reinterpret_cast<const CHAR*>(buffer) + pTargetInfo->Buffer;
    const CHAR* p = NULL;
    USHORT attr = 0;
    USHORT len = 0;

    //
    // Some poor sanity check
    //
    if (pTargetInfo->Length >= 1024) {

        dprintf("String32 TargetInfo too large\n");
        return;
    }

    debugPrintHex(start, pTargetInfo->Length);

    for (p = start; p - start < pTargetInfo->Length; p += (2 * sizeof(USHORT) + len)) {

       attr = reinterpret_cast<USHORT*>(const_cast<CHAR*>(p))[0];
       len = reinterpret_cast<USHORT*>(const_cast<CHAR*>(p))[1];

       if (attr >= MsvAvNbComputerName && attr <= MsvAvDnsTreeName) {

          dprintf("%s: ", g_attr_table[attr]);
          debugNPrintfW(p + 2 * sizeof(USHORT), len);
          dprintf(kstrNewLine);
       } else if (attr == MsvAvFlags) {

           dprintf("Flags: 0x%x\n", *reinterpret_cast<ULONG*>(const_cast<CHAR*>(p + 2 * sizeof(USHORT))) );
       } else if (attr == MsvAvEOL) {

           break;
       } else {

           dprintf("Unrecognized attribute %d\n", attr);
       }
    }
}

void debugPrintNegFlags(IN ULONG flags)
{
    ULONG i = 0;

    dprintf(" 0x%x\n", flags);

    for (i = 0; i < sizeof(g_flagTable)/sizeof(*g_flagTable); i++) {

        if (g_flagTable[i].flag & flags) {

            flags &= ~g_flagTable[i].flag;
            dprintf("  + %s\n", g_flagTable[i].desc);
        }
    }

    if (flags) {

        dprintf("Unrecognized flags: 0x%x\n" + flags);
    }
}

void DebugPrintNTLMMsg(IN const void* buf, IN ULONG cbBuffer)
{
    const CHAR* buffer = reinterpret_cast<const CHAR*>(buf);
    NTLM_MESSAGE_TYPE msgType = NtLmUnknown;
    NEGOTIATE_MESSAGE* pNeg = reinterpret_cast<NEGOTIATE_MESSAGE*>(const_cast<CHAR*>(buffer));
    CHALLENGE_MESSAGE* pCha = reinterpret_cast<CHALLENGE_MESSAGE*>(const_cast<CHAR*>(buffer));
    AUTHENTICATE_MESSAGE* pAut = reinterpret_cast<AUTHENTICATE_MESSAGE*>(const_cast<CHAR*>(buffer));

    if (strcmp(buffer, "NTLMSSP")) {

        dprintf("Not one of NTLM messages!\n");
        return;
    }

    debugPrintHex(buffer, cbBuffer);
    msgType = *reinterpret_cast<NTLM_MESSAGE_TYPE*>(const_cast<CHAR*>((buffer + strlen(buffer) + 1)));

    switch (msgType) {
        case NtLmNegotiate:
            dprintf("Message type: Negotiate \n");
            dprintf("NegotiateFlags: ");
            debugPrintNegFlags(pNeg->NegotiateFlags);
            dprintf("OemDomainName: \n");
            debugPrintString32(pNeg->OemDomainName, buffer);
            dprintf("OemWorkstationName: \n");
            debugPrintString32(pNeg->OemWorkstationName, buffer);
            break;

        case NtLmChallenge:
            dprintf("Message type: Challenge\n");
            dprintf("TargeName: \n");
            debugPrintString32(pCha->TargetName, buffer);
            dprintf("NegotiateFlags: ");
            debugPrintNegFlags(pCha->NegotiateFlags);
            dprintf("Chanllenge: \n");
            debugPrintHex(pCha->Challenge, MSV1_0_CHALLENGE_LENGTH);
            dprintf("ServerContextHandle: \n");
            debugPrintHex(&pCha->ServerContextHandle, sizeof(pCha->ServerContextHandle));
            dprintf("TargetInfo: \n");
            debugPrintString32TargetInfo(&pCha->TargetInfo, buffer);
            break;

        case NtLmAuthenticate:
            dprintf("Message type: Authenticate\n");
            dprintf("LmChallengeResponse (length %d): \n", pAut->LmChallengeResponse.Length);
            debugPrintHex(buffer + pAut->LmChallengeResponse.Buffer, pAut->LmChallengeResponse.Length);
            dprintf("NtChallengeResponse (length %d): \n", pAut->NtChallengeResponse.Length);
            debugPrintHex(buffer + pAut->NtChallengeResponse.Buffer, pAut->NtChallengeResponse.Length);
            dprintf("DomainName: \n");
            debugPrintString32(pAut->DomainName, buffer);
            dprintf("UserName: \n");
            debugPrintString32(pAut->UserName, buffer);
            dprintf("Workstation: \n");
            debugPrintString32(pAut->Workstation, buffer);
            dprintf("Sessionkey (length %d): \n", pAut->SessionKey.Length);
            debugPrintHex(buffer + pAut->SessionKey.Buffer, pAut->SessionKey.Length);
            dprintf("NegotiateFlags: ");
            debugPrintNegFlags(pAut->NegotiateFlags);
            break;

        case NtLmUnknown:
            dprintf("unknown msg\n");
            break;

        default:
            dprintf("buffer corrupted\n");
            break;
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrntlm);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrfsbd);
    dprintf(kstrRemarks);
    dprintf("   With -d <addr> is SecBufferDesc and [len] is ignored\n");
}

static  HRESULT ProcessNTLMOptions(IN OUT PSTR pszArgs, OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'd':
                *pfOptions |= DECODE_SEC_BUF_DEC;
                break;
            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(ntlm)
{
    HRESULT hRetval = E_FAIL;
    CHAR* pMessage = NULL;
    ULONG64 addr;
    ULONG64 lenTemp = 0;
    ULONG len = 0;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessNTLMOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addr, &args) && addr && !IsEmpty(szArgs) ? S_OK : E_INVALIDARG;
    }

    try {

        if (SUCCEEDED(hRetval)) {

            if (fOptions & DECODE_SEC_BUF_DEC) {

                dprintf("_SecBufferDesc %#I64x", addr);

                addr = TSecBufferDesc(addr).GetTokenAddrDirect(&len);

                if (!addr || !len) {
                    DBG_LOG(LSA_ERROR, ("Message %#I64x cbMessage %#x\n", addr, len));

                    dprintf(" has no token buffer to decode");
                    hRetval = E_FAIL;
                }

                dprintf(kstrNewLine);

            } else {

                hRetval = GetExpressionEx(args, &lenTemp, &args) && lenTemp ? S_OK : E_INVALIDARG;

                if (SUCCEEDED(hRetval)) {

                    len = static_cast<ULONG>(lenTemp);
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

            pMessage = new CHAR[len];

            hRetval = pMessage ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hRetval)) {

            hRetval = ReadMemory(addr, pMessage, len, NULL) ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hRetval)) {

            DBG_LOG(LSA_LOG, ("Message %#I64x cbMessage %#x\n", addr, len));

            (void)DebugPrintNTLMMsg(pMessage, len);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display NTLM message", NULL)

    if (pMessage) {

        delete [] pMessage;
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\package.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    package.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "package.hxx"
#include "util.hxx"

//
// Flags used in DumpPackage
//
#define PACKAGE_VERBOSE 0x00000001
#define PACKAGE_NOISY   0x00000002
#define PACKAGE_TITLE   0x00000004
#define PACKAGE_ALL     0x00000008
#define PACKAGE_SINGLE  0x00000010
#define PACKAGE_INDEX   0x00000020
#define PACKAGE_ADDR    0x00000040

#if 0

#define SP_INVALID          0x00000001  // Package is now invalid for use
#define SP_PREFERRED        0x00000002  // The preferred package
#define SP_INFO             0x00000004  // Supports Extended Info
#define SP_SHUTDOWN         0x00000008  // Shutdown has completed
#define SP_WOW_SUPPORT      0x00000010  // Package can support WOW6432 clients

#endif

PCSTR g_cszPackageFlags[] = {
    kstrInvalid, "Preferred", "ExtendedInfo", "Shutdown", "WowSupport"};

#if 0

//
//  Security Package Capabilities
//
#define SECPKG_FLAG_INTEGRITY       0x00000001  // Supports integrity on messages
#define SECPKG_FLAG_PRIVACY         0x00000002  // Supports privacy (confidentiality)
#define SECPKG_FLAG_TOKEN_ONLY      0x00000004  // Only security token needed
#define SECPKG_FLAG_DATAGRAM        0x00000008  // Datagram RPC support
#define SECPKG_FLAG_CONNECTION      0x00000010  // Connection oriented RPC support
#define SECPKG_FLAG_MULTI_REQUIRED  0x00000020  // Full 3-leg required for re-auth.
#define SECPKG_FLAG_CLIENT_ONLY     0x00000040  // Server side functionality not available
#define SECPKG_FLAG_EXTENDED_ERROR  0x00000080  // Supports extended error msgs
#define SECPKG_FLAG_IMPERSONATION   0x00000100  // Supports impersonation
#define SECPKG_FLAG_ACCEPT_WIN32_NAME   0x00000200  // Accepts Win32 names
#define SECPKG_FLAG_STREAM          0x00000400  // Supports stream semantics
#define SECPKG_FLAG_NEGOTIABLE      0x00000800  // Can be used by the negotiate package
#define SECPKG_FLAG_GSS_COMPATIBLE  0x00001000  // GSS Compatibility Available
#define SECPKG_FLAG_LOGON           0x00002000  // Supports common LsaLogonUser
#define SECPKG_FLAG_ASCII_BUFFERS   0x00004000  // Token Buffers are in ASCII
#define SECPKG_FLAG_FRAGMENT        0x00008000  // Package can fragment to fit
#define SECPKG_FLAG_MUTUAL_AUTH     0x00010000  // Package can perform mutual authentication
#define SECPKG_FLAG_DELEGATION      0x00020000  // Package can delegate

#endif

PCSTR g_cszCapabilities[] = {
    "Sign/Verify", "Seal/Unseal", "Token Only", "Datagram",
    "Connection", "Multi-Required", "ClientOnly", "ExtError",
    "Impersonation", "Win32Name", "Stream", "Negotiable",
    "GSS Compat", "Logon", "AsciiBuffer", "Fragment",
    "MutualAuth", "Delegation", kstrEmptyA, kstrEmptyA,
    kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA};

//
// Maximum length of function names, names longer than this is chopped
//
const ULONG eMaxSecFuncNameLen = 26;

void ShowSecPkgFuncTbl(IN ULONG64 addrSecPkgFuncTbl)
{
    dprintf("  Function table: _SECPKG_FUNCTION_TABLE %#I64x\n", addrSecPkgFuncTbl);

    LsaInitTypeRead(addrSecPkgFuncTbl, _SECPKG_FUNCTION_TABLE);

#define PRINT_PTR_WITH_SYM(x)                                       \
                                                                    \
    do {                                                            \
                                                                    \
       dprintf("%s%.*s  ", kstr4Spaces, eMaxSecFuncNameLen, #x);    \
                                                                    \
       PrintSpaces(eMaxSecFuncNameLen - strlen(#x));                \
                                                                    \
       PrintPtrWithSymbolsLn(kstrEmptyA, LsaReadPtrField(x));       \
                                                                    \
    } while (0)

    PRINT_PTR_WITH_SYM(InitializePackage);
    PRINT_PTR_WITH_SYM(LogonUser);
    PRINT_PTR_WITH_SYM(CallPackage);
    PRINT_PTR_WITH_SYM(LogonTerminated);
    PRINT_PTR_WITH_SYM(CallPackageUntrusted);
    PRINT_PTR_WITH_SYM(CallPackagePassthrough);
    PRINT_PTR_WITH_SYM(LogonUserEx);
    PRINT_PTR_WITH_SYM(LogonUserEx2);
    PRINT_PTR_WITH_SYM(Initialize);
    PRINT_PTR_WITH_SYM(Shutdown);
    PRINT_PTR_WITH_SYM(GetInfo);
    PRINT_PTR_WITH_SYM(AcceptCredentials);
    PRINT_PTR_WITH_SYM(AcquireCredentialsHandle);
    PRINT_PTR_WITH_SYM(QueryCredentialsAttributes);
    PRINT_PTR_WITH_SYM(FreeCredentialsHandle);
    PRINT_PTR_WITH_SYM(SaveCredentials);
    PRINT_PTR_WITH_SYM(GetCredentials);
    PRINT_PTR_WITH_SYM(DeleteCredentials);
    PRINT_PTR_WITH_SYM(InitLsaModeContext);
    PRINT_PTR_WITH_SYM(AcceptLsaModeContext);
    PRINT_PTR_WITH_SYM(DeleteContext);
    PRINT_PTR_WITH_SYM(ApplyControlToken);
    PRINT_PTR_WITH_SYM(GetUserInfo);
    PRINT_PTR_WITH_SYM(GetExtendedInformation);
    PRINT_PTR_WITH_SYM(QueryContextAttributes);
    PRINT_PTR_WITH_SYM(AddCredentials);
    PRINT_PTR_WITH_SYM(SetExtendedInformation);
    PRINT_PTR_WITH_SYM(SetContextAttributes);

#undef PRINT_PTR_WITH_SYM

}

void ShowPackageControl(IN ULONG64 addrSecPkgCtrl, IN DWORD fVerbose)
{
    CHAR szBuffer[MAX_PATH] = {0};
    ULONG fieldOffset = 0;
    ULONG fPackage = 0;
    ULONG fCapabilities = 0;

    ExitIfControlC();

    fieldOffset = ReadFieldOffset(kstrSapSecPkg, "Name");

    if (fVerbose & PACKAGE_TITLE) {

        dprintf("  %s %s\n", kstrSapSecPkg, PtrToStr(addrSecPkgCtrl));
    }

    if (!addrSecPkgCtrl) {

        throw "Invalid _LSAP_SECURITY_PACKAGE address\n";
    }

    LsaInitTypeRead(addrSecPkgCtrl, _LSAP_SECURITY_PACKAGE);

    dprintf("  ID         \t%d\n", LsaReadULONGField(dwPackageID));
    dprintf("  Name       \t%ws\n", TSTRING(addrSecPkgCtrl + fieldOffset).toWStrDirect());

    fPackage = LsaReadULONGField(fPackage);
    fCapabilities = LsaReadULONGField(fCapabilities);

    if (fVerbose & (PACKAGE_VERBOSE | PACKAGE_SINGLE)) {

        DisplayFlags(fPackage, COUNTOF(g_cszPackageFlags), g_cszPackageFlags, sizeof(szBuffer) - 1, szBuffer);
        dprintf("  Flags    \t%#x : %s\n", fPackage, szBuffer);
        DisplayFlags(fCapabilities, COUNTOF(g_cszCapabilities), g_cszCapabilities, sizeof(szBuffer) - 1, szBuffer);
        dprintf("  Capabilities\t%#x : %s\n", fCapabilities, szBuffer);
        dprintf("  RPC ID   \t%d\n", LsaReadULONGField(dwRPCID));
        dprintf("  Version  \t%d\n", LsaReadULONGField(Version));
        dprintf("  TokenSize\t%d\n", LsaReadULONGField(TokenSize));
        dprintf("  Thunks   \t%#I64x\n", LsaReadPtrField(Thunks));
    }

    if (fVerbose & (PACKAGE_NOISY | PACKAGE_SINGLE)) {

        fieldOffset = ReadFieldOffset(kstrSapSecPkg, "FunctionTable");

        ShowSecPkgFuncTbl(addrSecPkgCtrl + fieldOffset);
    }

    if (!(fVerbose & PACKAGE_SINGLE)) {

        dprintf(kstrNewLine);
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdpkg);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf("   -b   Display symbolic function table\n");
    dprintf(kstrVerbose);
}

HRESULT ProcessDPKGOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    ULONG fDump = 0;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'V':
            case 'v':
                fDump |= PACKAGE_VERBOSE;
                break;

            case 'B':
            case 'b':
                fDump |= PACKAGE_NOISY;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    if (SUCCEEDED(hRetval)) {

        *pfOptions |= fDump;
    }

    return hRetval;
}

DECLARE_API(dumppackage)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = PACKAGE_TITLE;
    CHAR szArgs[MAX_PATH] = {0};
    DWORD dwIndex = 0;
    ULONG cPackages = 0;
    ULONG cbPtrSize = 0;
    PCSTR pszDontCare = NULL;

    ULONG64 exprTemp = 0;
    ULONG64 addrSPC = 0;
    ULONG64 addrAddrSPC = 0;
    ULONG64 addrAddrAddrSPC = 0;
    ULONG64 addrcPackages = 0;

    try {

        if (args && *args) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessDPKGOptions(szArgs, &fOptions);

        } else {

            fOptions = PACKAGE_ALL;
        }

        if (SUCCEEDED(hRetval) && !IsEmpty(szArgs)) {

            fOptions |= PACKAGE_SINGLE;
            hRetval = GetExpressionEx(szArgs, &exprTemp, &args) ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(PACKAGE_COUNT, &addrcPackages, &pszDontCare) && addrcPackages ? S_OK : E_FAIL;

            if (SUCCEEDED(hRetval)) {

                cPackages = ReadULONGVar(addrcPackages);

            } else {

                dprintf(kstrIncorrectSymbols);
                dprintf("Unable to read " PACKAGE_COUNT ", try \"dt -x " PACKAGE_COUNT "\" to verify\n");
            }
        }

        if (SUCCEEDED(hRetval) && (fOptions & PACKAGE_SINGLE)) {

            if (exprTemp < cPackages) {

                dwIndex = static_cast<ULONG>(exprTemp);
                fOptions |= PACKAGE_INDEX;

            } else if (exprTemp < 0x00010000) {

                dprintf("Invalid package ID (%d)\n", static_cast<ULONG>(exprTemp));
                hRetval = E_FAIL;

            } else {

                fOptions |= PACKAGE_ADDR;
                addrSPC = exprTemp;
            }
        }

        if (SUCCEEDED(hRetval) && !(fOptions & PACKAGE_ADDR)) {

            hRetval = GetExpressionEx(PACKAGE_LIST, &addrAddrAddrSPC, &pszDontCare) && addrAddrAddrSPC ? S_OK : E_FAIL;

            if (SUCCEEDED(hRetval)) {

                addrAddrSPC = ReadPtrVar(addrAddrAddrSPC);
                hRetval = addrAddrSPC ? S_OK : E_FAIL;
            }
        }

        if (SUCCEEDED(hRetval)) {

            cbPtrSize = ReadPtrSize();

            if (fOptions & PACKAGE_SINGLE) {

                if (fOptions & PACKAGE_INDEX) {

                    addrSPC = ReadPtrVar(addrAddrSPC + dwIndex * cbPtrSize);

                    dprintf("  Package Control List: %s %#I64x\n", kstrSapSecPkg, addrAddrSPC);

                    ShowPackageControl(addrSPC, fOptions | PACKAGE_TITLE);

                } else {

                    ShowPackageControl(addrSPC, fOptions);
                }
            } else {

                dprintf("  There are %d packages in the system\n", cPackages);

                for (dwIndex = 0; dwIndex < cPackages; dwIndex++) {

                    addrSPC = ReadPtrVar(addrAddrSPC + dwIndex * cbPtrSize);

                    ShowPackageControl(addrSPC, fOptions);
                }
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display packages", kstrSapSecPkg)


    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\sd.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sd.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sd.hxx"
#include "util.hxx"
#include "acl.hxx"
#include "sid.hxx"

void DumpSDControlFlags(IN PCSTR pszPad, IN USHORT ControlFlags)
{

#define BRANCH_AND_PRINT(x) if (ControlFlags & x){ dprintf("%s%s\n", pszPad, #x); }

    BRANCH_AND_PRINT(SE_OWNER_DEFAULTED);
    BRANCH_AND_PRINT(SE_GROUP_DEFAULTED);
    BRANCH_AND_PRINT(SE_DACL_PRESENT);
    BRANCH_AND_PRINT(SE_DACL_DEFAULTED);
    BRANCH_AND_PRINT(SE_SACL_PRESENT);
    BRANCH_AND_PRINT(SE_SACL_DEFAULTED);
    BRANCH_AND_PRINT(SE_DACL_UNTRUSTED);
    BRANCH_AND_PRINT(SE_SERVER_SECURITY);
    BRANCH_AND_PRINT(SE_DACL_AUTO_INHERIT_REQ);
    BRANCH_AND_PRINT(SE_SACL_AUTO_INHERIT_REQ);
    BRANCH_AND_PRINT(SE_DACL_AUTO_INHERITED);
    BRANCH_AND_PRINT(SE_SACL_AUTO_INHERITED);
    BRANCH_AND_PRINT(SE_DACL_PROTECTED);
    BRANCH_AND_PRINT(SE_SACL_PROTECTED);
    BRANCH_AND_PRINT(SE_RM_CONTROL_VALID);
    BRANCH_AND_PRINT(SE_SELF_RELATIVE);

#undef BRANCH_AND_PRINT

}

void ShowSD(IN ULONG64 addrSd, IN ULONG fOptions)
{
    ULONG64 baseOffset = 0;
    ULONG64 addrOwner = 0;
    ULONG64 addrGroup = 0;
    ULONG64 addrDacl = 0;
    ULONG64 addrSacl = 0;
    USHORT Control = 0;

    Control = ReadUSHORTVar(addrSd + 2 * sizeof(UCHAR));

    dprintf("Revision %lu\n", ReadUCHARVar(addrSd));
    dprintf("Sbz1 %lu\n", ReadUCHARVar(addrSd + sizeof(UCHAR)));
    dprintf("Control 0x%lx\n", Control);
    DumpSDControlFlags(kstr4Spaces, Control);

    baseOffset = addrSd + 2 * sizeof(UCHAR) + sizeof(USHORT);

    DBG_LOG(LSA_LOG, ("ShowSD reading owner _SECURITY_DESCRIPTOR::Owner from %#I64x\n", baseOffset));

    if ((Control & SE_SELF_RELATIVE) == SE_SELF_RELATIVE) {

        DBG_LOG(LSA_LOG, ("_SECURITY_DESCRIPTOR_RELATIVE %#I64x \n", toPtr(addrSd)));

        addrOwner = ReadULONGVar(baseOffset);
        addrGroup = ReadULONGVar(baseOffset + sizeof(ULONG));
        addrSacl =  ReadULONGVar(baseOffset + 2 * sizeof(ULONG));
        addrDacl =  ReadULONGVar(baseOffset + 3 * sizeof(ULONG));

        if ( addrOwner) {

            addrOwner = addrSd + addrOwner;
        }

        if ( addrGroup) {

            addrGroup = addrSd + addrGroup;
        }

        if ( addrDacl) {

            addrDacl = addrSd + addrDacl;
        }

        if ( addrSacl) {

            addrSacl = addrSd + addrSacl;
        }
    } else {

        DBG_LOG(LSA_LOG, ("_SECURITY_DESCRIPTOR %#I64x\n", toPtr(addrSd)));

        baseOffset = ForwardAdjustPtrAddr(baseOffset);

        addrOwner = ReadPtrVar(baseOffset);
        addrGroup = ReadPtrVar(baseOffset + ReadPtrSize());
        addrSacl =  ReadPtrVar(baseOffset + 2 * ReadPtrSize());
        addrDacl =  ReadPtrVar(baseOffset + 3 * ReadPtrSize());
    }

    dprintf("Owner: ");

    if (addrOwner) {

        ShowSid(kstrEmptyA, addrOwner, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }

    dprintf("Group: ");

    if (addrGroup) {

        ShowSid(kstrEmptyA, addrGroup, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }

    dprintf("DACL:\n");

    if (addrDacl) {

        ShowAcl(kstr4Spaces, addrDacl, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }

    dprintf("SACL:\n");

    if (addrSacl) {

        ShowAcl(kstr4Spaces, addrSacl, fOptions);

    } else {

        dprintf(kstr2StrLn, kstr4Spaces, kstrNullPtrA);
    }
}

HRESULT ProcessSDOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdsd);
    dprintf(kstrsd);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
}

DECLARE_API(sd)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSd = 0 ;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);
        hRetval = ProcessSDOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrSd, &args) && addrSd ? S_OK : E_INVALIDARG;
    }

    try {
        if (SUCCEEDED(hRetval)) {

            (void)ShowSD(addrSd, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display SECURITY_DESCRIPTOR", NULL)

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\secbd.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    secb.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "secbd.hxx"
#include "util.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdsbd);
    dprintf(kstrsbd);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrVerbose);
}

HRESULT ProcessSbdOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(sbd)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSbd = 0 ;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessSbdOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrSbd, &args) && addrSbd ? S_OK : E_INVALIDARG;
    }

    try {

        if (SUCCEEDED(hRetval)) {

            dprintf(kstrTypeAddrLn, kstrSecBuffDesc, toPtr(addrSbd));

            TSecBufferDesc(addrSbd).ShowDirect(fOptions & SHOW_VERBOSE_INFO);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display SecBufferDesc", NULL)

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\session.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "session.hxx"
#include "util.hxx"

#include <sht.hxx>
#include <lht.hxx>

PCSTR g_cszSessFlags[] = {
    "Queue", "TcbPriv", "Clone", "Impersonate",
    "Desktop", "Untrusted", "InProc", "Autonomous",
    "Default", "Unload", "Scavenger", "Cleanup",
    "Kernel", "Restricted", "MaybeKernel", "EFS",
    "Shadow", "Wow64", kstrEmptyA, kstrEmptyA,
    kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA,
    kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA,
    kstrEmptyA, kstrEmptyA, kstrEmptyA, kstrEmptyA};

void ShowHandleTable(IN PCSTR pszBanner, IN ULONG64 addrTable)
{
    ULONG dwTag = 0;
    DWORD Count = 0;

    if (!addrTable) {

        dprintf(kstrStrLn, kstrNullPtrA);

        return;
    }

    dwTag = ReadULONGVar(addrTable);

    if (dwTag == LHT_TAG) {

        ReadStructField(addrTable, "_LARGE_HANDLE_TABLE", "Count", sizeof(Count), &Count);

        dprintf("  %s\t_LARGE_HANDLE_TABLE %#I64x, %d handles\n", pszBanner, addrTable, Count);

    } else if (dwTag == SHT_TAG) {

        ReadStructField(addrTable, "_SMALL_HANDLE_TABLE", "Count", sizeof(Count), &Count);

        dprintf("  %s\t_SMALL_HANDLE_TABLE %#I64x, %d handles\n", pszBanner, addrTable, Count );

    } else {

        dprintf("  %s\t %#I64x, not a valid table\n", pszBanner, addrTable );
    }
}

void ShowSession(IN ULONG64 addrSession, IN BOOL bVerbose)
{
    CHAR szBuffer[MAX_PATH] = {0};
    DWORD dwThreadId = 0;
    ULONG fSession = 0;
    ULONG64 addrListEnd = 0;
    ULONG64 addrListEntry = 0;
    ULONG64 addrSharedData = 0;
    ULONG64 Disp = 0;
    ULONG64 addr = 0;

    ExitIfControlC();

    dprintf(kstrTypeAddrLn, kstrSession, addrSession);

    if (!addrSession) {

        dprintf("No session data avaiable\n");

        return;
    }

    LsaInitTypeRead(addrSession, _Session);

    dprintf("  Process ID\t%#x\n", LsaReadULONGField(dwProcessID));
    dprintf("  LPC Port  \t%s\n", PtrToStr(LsaReadPtrField(hPort)));

    fSession = LsaReadULONGField(fSession);

    DisplayFlags(fSession, COUNTOF(g_cszSessFlags), g_cszSessFlags, COUNTOF(szBuffer), szBuffer);

    dprintf("  Flags     \t%#x : %s\n", fSession, szBuffer);

    addrSharedData = LsaReadPtrField(SharedData);

    if (addrSharedData) {

        dprintf("  cRefs     \t%#x (lsasrv!_LSAP_SHARED_SESSION_DATA %#I64x)\n", 
            ReadULONGVar(addrSharedData + ReadFieldOffset(kstrSharedData, "cRefs")),
            addrSharedData);

        ShowHandleTable(kstrCredTbl, ReadStructPtrField(addrSharedData, kstrSharedData, kstrCredTbl));

        ShowHandleTable(kstrCtxtTble, ReadStructPtrField(addrSharedData, kstrSharedData, kstrCtxtTble));

        dprintf("  TaskQueue \t%s\n", PtrToStr(ReadStructPtrField(addrSharedData, kstrSharedData, "pQueue")));

    } else {

        dprintf("  No shared data\n");
    }

    dprintf("  RefCount  \t%d\n", LsaReadULONGField(RefCount));

    addrListEnd = addrSession + ReadFieldOffset(kstrSession, "RundownList") ;

    addrListEntry = LsaReadPtrField(RundownList.Flink);

    if (addrListEntry == addrListEnd) {

        dprintf("  No rundown functions\n" );

    } else {

        dprintf("  Rundown Functions:\n" );

        do {

            if (bVerbose) {

                dprintf("    %s %#I64x\n", kstrRundown, addrListEntry);
            }

            addr = ReadStructPtrField(addrListEntry, kstrRundown, "Rundown");
            GetSymbol(addr, szBuffer, &Disp );
            dprintf("      %s( %s )\n", GetSymbolStr(addr, szBuffer), PtrToStr(ReadStructPtrField(addrListEntry, kstrRundown, "Parameter")));

            addrListEntry = ReadStructPtrField(addrListEntry, kstrRundown, kstrListFlink);

        } while (addrListEntry != addrListEnd);
    }

    addrListEnd = addrSession + ReadFieldOffset(kstrSession, "SectionList") ;

    addrListEntry = LsaReadPtrField(SectionList.Flink);

    if (addrListEntry == addrListEnd) {

        dprintf("  No shared sections\n");

    } else {

        dprintf("  Shared Sections\n");

        do {

            if (bVerbose) {

                dprintf("  %s %#I64x\n", kstrShared, addrListEntry);
            }

            dprintf("    Section %s, base at %s\n",
                PtrToStr(ReadStructPtrField(addrListEntry, kstrShared, "Section")),
                PtrToStr(ReadStructPtrField(addrListEntry, kstrShared, "Base")));

            addrListEntry = ReadStructPtrField(addrListEntry, kstrShared, kstrListFlink);

            ExitIfControlC();

        } while (addrListEntry != addrListEnd);
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdssn);
    dprintf(kstrssn);
}

DECLARE_API(sess)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSession = 0;

    //
    // Session list anchor
    //
    ULONG64 addrSessionHead = 0;

    ULONG fieldOffset = 0;
    ULONG id = 0;
    BOOL bFound = FALSE;
    DWORD dwProcessID = 0;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(args, &addrSession, &args) && addrSession ? S_OK : E_INVALIDARG;
    }

    try {

        if (SUCCEEDED(hRetval)) {

            if ( addrSession < 0x00010000 ) {

                id = static_cast<ULONG>(addrSession);

                //
                // Search by process id:
                //
                hRetval = GetExpressionEx(SESSION_LIST, &addrSessionHead, &args) && addrSessionHead ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read " SESSION_LIST ", try \"dt -x " SESSION_LIST "\" to verify\n");

                    hRetval = E_FAIL;

                } else {

                    //
                    // Get Session list anchor's Flink
                    //
                    addrSession = ReadPtrVar(addrSessionHead);

                    fieldOffset = ReadFieldOffset(kstrSession, kstrList);

                    do {

                        ReadStructField(addrSession, kstrSession, "dwProcessID", sizeof(dwProcessID), &dwProcessID);

                        if (dwProcessID == id) {

                            bFound = TRUE ;
                            break;
                        }

                        addrSession = ReadStructPtrField(addrSession, kstrSession, kstrListFlink) - fieldOffset;

                    } while (addrSession != addrSessionHead);

                    if (!bFound) {

                        dprintf("No session found with process id == %#x\n", id);
                        hRetval = E_FAIL;
                    }
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

            ShowSession(addrSession, TRUE);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display session", kstrSession);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\secb.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    secb.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "secb.hxx"
#include "util.hxx"
#include "acl.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdsb);
    dprintf(kstrsb);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrVerbose);
}

HRESULT ProcessSbOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(sb)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSb = 0;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args,  sizeof(szArgs) - 1);

        hRetval = ProcessSbOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrSb, &args) && addrSb ? S_OK : E_INVALIDARG;
    }

    try {
        if (SUCCEEDED(hRetval)) {

            dprintf(kstrTypeAddrLn, kstrSecBuffer, toPtr(addrSb));
            TSecBuffer(addrSb).ShowDirect(kstrShowSecBuffer, fOptions & SHOW_VERBOSE_INFO);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display SecBuffer", NULL)

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\sid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sid.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sid.hxx"
#include "util.hxx"

void ShowSid(IN PCSTR pszPad, IN ULONG64 addrSid, IN ULONG fOptions)
{
    if (!addrSid) {

        dprintf(kstr2StrLn, pszPad, kstrNullPtrA);
        return;
    }

    TSID sid(addrSid);

    dprintf(pszPad);
    dprintf(sid.toStrDirect(kstrSidFmt));

    if (fOptions & SHOW_FRIENDLY_NAME) {

        dprintf(kstrSpace);

        PCSTR pszStr = sid.GetFriendlyNameDirect(kstrSidNameFmt);

        if (pszStr && *pszStr) {

            dprintf(pszStr);
        }
    }

    dprintf(kstrNewLine);
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdsid);
    dprintf(kstrsid);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
}

HRESULT ProcessSidOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(sid)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSid = 0;
    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    hRetval = args && *args ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessSidOptions(szArgs, &fOptions);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = IsEmpty(szArgs) ? E_INVALIDARG : S_OK;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(szArgs, &addrSid, &args) && addrSid ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        try {

            dprintf(kstrTypeAddrLn, kstrSid, toPtr(addrSid));

            (void)ShowSid(kstrEmptyA, addrSid, fOptions);

        } CATCH_LSAEXTS_EXCEPTIONS("Unable to display SID", NULL)
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\sessionlst.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sessionlst.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sessionlst.hxx"
#include "util.hxx"

#include "session.hxx"

HRESULT ProcessSessionListOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdssnl);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrVerbose);
}

DECLARE_API(dumpsessionlist)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrSession = 0;

    //
    // Session List anchor
    //
    ULONG64 addrSessionHead = 0;
    ULONG fieldOffset = 0;

    ULONG cSessions = 0;

    try {

        if (args && *args) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessSessionListOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval)) {

            if (!IsEmpty(szArgs)) {

                hRetval = GetExpressionEx(szArgs, &addrSession, &args) && addrSession ? S_OK : E_INVALIDARG;

            } else {

                hRetval = GetExpressionEx(SESSION_LIST, &addrSessionHead, &args) && addrSessionHead ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read " SESSION_LIST ", try \"dt -x " SESSION_LIST "\" to verify\n");

                    hRetval = E_FAIL;

                } else {

                    //
                    // Get list anchor's Flink
                    //
                    addrSession = ReadPtrVar(addrSessionHead);

                    hRetval = addrSession ? S_OK : E_FAIL;
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

            if (fOptions & SHOW_VERBOSE_INFO) {

                dprintf("Head of Session List is %#I64x\n", addrSessionHead);
            }

            fieldOffset = ReadFieldOffset(kstrSession, kstrList);

            while (addrSession != addrSessionHead) {

                dprintf("#%d) ", cSessions++);

                ShowSession(addrSession, fOptions & SHOW_VERBOSE_INFO);

                addrSession = ReadStructPtrField(addrSession, kstrSession, kstrListFlink) - fieldOffset;

            }

            dprintf("There are a total of %d sessions\n", cSessions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display session list", kstrSession);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\sid2name.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sid2name.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sid2name.hxx"
#include "util.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrsd2nm);
    dprintf(kstrRemarks);
    dprintf("   Sid string is in standard string notation and of form S-1-5-32-544\n");
    dprintf("   Refer to SDK header ntseapi.h for details\n");
}

HRESULT ProcessSidString(IN OUT PSTR pszSid, OUT ULONG* pSubAuthuorityCount)
{
    HRESULT hRetval = E_FAIL;
    PSTR pCh = NULL;

    ULONG cDashes = 0;

    hRetval = pszSid && pSubAuthuorityCount ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        pCh = strchr(pszSid, 'S');

        if (!pCh) {

            pCh = strchr(pszSid, 's');
        }

        hRetval = pCh && (pCh[1] == '-') ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

       //
       // Replace 'S' and '-' with spaces
       //
       for (; pCh; pCh = strchr(pCh, '-')) {

           *pCh++ = ' ';
           cDashes++;
       }

       //
       // Do not count prefix "S"
       //
       cDashes--;

       hRetval = cDashes >= 2 ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

       *pSubAuthuorityCount = cDashes - 2;
    }

    return hRetval;
}

HRESULT InitializeSid(IN PCSTR pszArgs, IN ULONG SubAuthorityCount, OUT SID* pSid)
{
    HRESULT hRetval = pszArgs && pSid ? S_OK : E_INVALIDARG;

    ULONG64 expr = 0;

    LARGE_INTEGER Auth = {0};

    if (SUCCEEDED(hRetval)) {

        pSid->SubAuthorityCount = static_cast<UCHAR>(SubAuthorityCount);

        hRetval = GetExpressionEx(pszArgs, &expr, &pszArgs) ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        pSid->Revision = static_cast<UCHAR>(expr);

        hRetval = GetExpressionEx(pszArgs, &expr, &pszArgs) ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        Auth = ULONG642LargeInteger(expr);

        //
        // Indentifier Authority is in big endian!
        //
        pSid->IdentifierAuthority.Value[0] = static_cast<UCHAR>(Auth.HighPart >> 8);
        pSid->IdentifierAuthority.Value[1] = static_cast<UCHAR>(Auth.HighPart >> 0);

        pSid->IdentifierAuthority.Value[2] = static_cast<UCHAR>(Auth.LowPart >> 24);
        pSid->IdentifierAuthority.Value[3] = static_cast<UCHAR>(Auth.LowPart >> 16);
        pSid->IdentifierAuthority.Value[4] = static_cast<UCHAR>(Auth.LowPart >> 8);
        pSid->IdentifierAuthority.Value[5] = static_cast<UCHAR>(Auth.LowPart >> 0);

        for(ULONG i = 0; i < SubAuthorityCount; i++) {

            hRetval = GetExpressionEx(pszArgs, &expr, &pszArgs) ? S_OK : E_INVALIDARG;

            if (FAILED(hRetval)) {

                break;
            }

            pSid->SubAuthority[i] = static_cast<ULONG>(expr);
        }
    }

    return hRetval;
}

DECLARE_API(sid2name)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 expr = 0;
    ULONG SubAuthorityCount = 0;
    ULONG cbSid = 0;
    SID* pSid = NULL;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG Radix = 0;
    BOOL bIsRadixChanged = FALSE;

    hRetval = args && *args ? ProcessHelpRequest(args) : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        strncpy(szArgs, args, sizeof(szArgs) - 1);

        hRetval = ProcessSidString(szArgs, &SubAuthorityCount);
    }

    //
    // SID string uses base 10 by default
    //
    if (SUCCEEDED(hRetval)) {

        hRetval = ExtQuery(Client);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = g_ExtControl->GetRadix(&Radix);
    }

    //
    // Set default radix to 10 if it is not already
    //
    if (SUCCEEDED(hRetval) && (Radix != 10)) {

        hRetval = g_ExtControl->SetRadix(10);

        if (SUCCEEDED(hRetval)) {

            bIsRadixChanged = TRUE;
        }
    }

    if (SUCCEEDED(hRetval)) {

        cbSid = RtlLengthRequiredSid(SubAuthorityCount);

        pSid = reinterpret_cast<SID*>(new CHAR[cbSid]);

        hRetval = pSid ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = InitializeSid(szArgs, SubAuthorityCount, pSid);
    }

    if (bIsRadixChanged) {

        hRetval = g_ExtControl->SetRadix(Radix);
    }

    if (SUCCEEDED(hRetval)) {

        try {

            dprintf("%s -> %s\n", args, TSID::ConvertSidToFriendlyName(pSid, kstrSdNmFmt));

        } CATCH_LSAEXTS_EXCEPTIONS("Unable to get account name for specified sid", NULL)
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    delete [] pSid;

    ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\spmlpc.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spmlpc.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lsalpc.hxx>
#include "util.hxx"

#include "tls.hxx"
#include "tcallinfo.hxx"
#include "dlpcr.hxx"

#if 0

//
// These are the valid flags to set in the fAPI field
//

#define SPMAPI_FLAG_ERROR_RET   0x0001  // Indicates an error return
#define SPMAPI_FLAG_MEMORY      0x0002  // Memory was allocated in client
#define SPMAPI_FLAG_PREPACK     0x0004  // Data packed in bData field
#define SPMAPI_FLAG_GETSTATE    0x0008  // driver should call GetState

#define SPMAPI_FLAG_ANSI_CALL   0x0010  // Called via ANSI stub
#define SPMAPI_FLAG_HANDLE_CHG  0x0020  // A handle was changed
#define SPMAPI_FLAG_CALLBACK    0x0040  // Callback to calling process
#define SPMAPI_FLAG_ALLOCS      0x0080  // VM Allocs were placed in prepack
#define SPMAPI_FLAG_EXEC_NOW    0x0100  // Execute in LPC thread
#define SPMAPI_FLAG_WIN32_ERROR 0x0200  // Status is a win32 error
#define SPMAPI_FLAG_KMAP_MEM    0x0400  // Call contains buffers in the kmap

#endif

PCSTR g_cszAPIFlags[] = {
    "Error", "Memory", "PrePack",
    "GetState", "AnsiCall",  "HandleChange", "CallBack",
    "VmAlloc", "ExecNow", "Win32Error", "KMap"};

PCSTR g_cszMessageNames[] = {
    "<Disconnect>",
    "<Connect>",
    "LsaLookupPackage",             // LsapAuLookupPackageApi
    "LsaLogonUser",                 // LsapAuLogonUserApi
    "LsaCallPackage",               // LsapAuCallPackageApi
    "LsaDeregisterLogonProcess",    // LsapAuDeregisterLogonProcessApi
    "<empty>",                      // LsapAuMaxApiNumber

    "(I) GetBinding",               // SPMAPI_GetBinding
    "(I) SetSession",               // SPMAPI_SetSession
    "(I) FindPackage",              // SPMAPI_FindPackage
    "EnumeratePackages",            // SPMAPI_EnumPackages
    "AcquireCredentialHandle",      // SPMAPI_AcquireCreds

    "EstablishCredentials",         // SPMAPI_EstablishCreds
    "FreeCredentialHandle",         // SPMAPI_FreeCredHandle
    "InitializeSecurityContext",    // SPMAPI_InitContext
    "AcceptSecurityContext",        // SPMAPI_AcceptContext
    "ApplyControlToken",            // SPMAPI_ApplyToken

    "DeleteSecurityContext",        // SPMAPI_DeleteContext
    "QueryPackage",                 // SPMAPI_QueryPackage
    "GetUserInfo",                  // SPMAPI_GetUserInfo
    "GetCredentials",               // SPMAPI_GetCreds
    "SaveCredentials",              // SPMAPI_SaveCreds

    "QueryCredAttributes",          // SPMAPI_QueryCredAttributes
    "AddPackage",                   // SPMAPI_AddPackage
    "DeletePackage",                // SPMAPI_DeletePackage
    "GenerateKey",                  // SPMAPI_EfsGenerateKey

    "GenerateDirEfs",               // SPMAPI_EfsGenerateDirEfs
    "DecryptFek",                   // SPMAPI_EfsDecryptFek
    "GenerateSessionKey",           // SPMAPI_EfsGenerateSessionKey
    "Callback",                     // SPMAPI_Callback
    "QueryContextAttributes",       // SPMAPI_QueryContextAttr

    "PolicyChangeNotify",           // SPMAPI_LsaPolicyChangeNotify
    "GetUserName",                  // SPMAPI_GetUserNameX
    "AddCredential",                // SPMAPI_AddCredential
    "EnumLogonSession",             // SPMAPI_EnumLogonSession
    "GetLogonSessionData",          // SPMAPI_GetLogonSessionData

    "SetContextAttribute",          // SPMAPI_SetContextAttr
    "LookupAccountName",            // SPMAPI_LookupAccountNameX
    "LookupAccountSid",             // SPMAPI_LookupAccountSidX
    "<empty>",                      // SPMAPI_MaxApiNumber
     };

PCSTR ApiName(IN ULONG apiNum)
{
    DBG_LOG(LSA_LOG, ("Look up API num %d\n", apiNum));

    apiNum += 2;

    return  apiNum < COUNTOF(g_cszMessageNames) ? g_cszMessageNames[(apiNum)] : "[Illegal API Number!]";
}

PCSTR LogonTypeName(IN ULONG type)
{
    switch (type) {
    case Interactive:        // Interactively logged on (locally or remotely)
        return "Interactive";
    case Network:            // Accessing system via network
        return "Network";
    case Batch:              // Started via a batch queue
        return "Batch";
    case Service:            // Service started by service controller
        return "Service";
    case Proxy:              // Proxy logon
        return "Proxy";
    case Unlock:             // Unlock workstation
        return "Unlock";
    case NetworkCleartext:   // Network logon with cleartext credentials
        return "NetworkCleartext";
    case NewCredentials:     // Clone caller, new default credentials
        return "NewCredentials";
    case RemoteInteractive:  // Remote, yet interactive.  Terminal server
        return "RemoteInteractive";
    case CachedInteractive:  // Try cached credentials without hitting the net.
        return "CachedInteractive";
    default:
        return "Unknown Logon Type";
    }
}

PCSTR g_cszNameFormats[] = {
    "NameUnknown", "NameFullyQualifiedDN", "NameSamCompatible", "NameDisplay",
    "Invalid",  "Invalid", 
    "NameUniqueId", "NameCanonical", "NameUserPrincipal", "NameCanonicalEx",
    "NameServicePrincipal", "NameDnsDomain"
    };

#define SPM_NAME_OPTION_MASK        0xFFFF0000
#define SPM_NAME_OPTION_NT4_ONLY    0x00010000  // GetUserNameX only, not Ex
#define SPM_NAME_OPTION_FLUSH       0x00020000

void DisplayGetUserNameOptionsAndType(IN PCSTR pszPad, IN ULONG cbBuf, IN CHAR* pBuf, IN ULONG Options)
{
    LONG cbUsed = 0;

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (Options & SPM_NAME_OPTION_##x) {                 \
            cbUsed = _snprintf(pBuf, cbBuf, " %s", #x);      \
            if (cbUsed <= 0) return;                         \
            cbBuf -= cbUsed;                                 \
            pBuf += cbUsed;                                  \
            Options &= ~ SPM_NAME_OPTION_##x;                \
        }                                                    \
    } while(0)                                               \

    cbUsed = _snprintf(pBuf, cbBuf, "%s%#x : Opt %#x", pszPad, Options, ((Options & SPM_NAME_OPTION_MASK) >> 16) & 0xFFFF);

    if (cbUsed <= 0) return;  
    
    cbBuf -= cbUsed;
    pBuf += cbUsed;

    BRANCH_AND_PRINT(NT4_ONLY);
    BRANCH_AND_PRINT(FLUSH);

    if (Options & SPM_NAME_OPTION_MASK)
    {
        cbUsed = _snprintf(pBuf, cbBuf, "%#x", ((Options & SPM_NAME_OPTION_MASK) >> 16) & 0xFFFF);
        if (cbUsed <= 0) return;  
        cbBuf -= cbUsed;
        pBuf += cbUsed;

    }

    cbUsed = _snprintf(pBuf, cbBuf, "; Type %#x %s\n",
                 (Options & (~SPM_NAME_OPTION_MASK)),
                 ((Options & (~SPM_NAME_OPTION_MASK)) < RTL_NUMBER_OF(g_cszNameFormats)) 
                       ? g_cszNameFormats[Options & (~SPM_NAME_OPTION_MASK)] : "Invalid");
    
    if (cbUsed <= 0) return;  
    
    cbBuf -= cbUsed;
    pBuf += cbUsed;

#undef BRANCH_AND_PRINT
   
}

#if 0
typedef enum
{
    // Examples for the following formats assume a fictitous company
    // which hooks into the global X.500 and DNS name spaces as follows.
    //
    // Enterprise root domain in DNS is
    //
    //      widget.com
    //
    // Enterprise root domain in X.500 (RFC 1779 format) is
    //
    //      O=Widget, C=US
    //
    // There exists the child domain
    //
    //      engineering.widget.com
    //
    // equivalent to
    //
    //      OU=Engineering, O=Widget, C=US
    //
    // There exists a container within the Engineering domain
    //
    //      OU=Software, OU=Engineering, O=Widget, C=US
    //
    // There exists the user
    //
    //      CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US
    //
    // And this user's downlevel (pre-ADS) user name is
    //
    //      Engineering\JohnDoe

    // unknown name type
    NameUnknown = 0,

    // CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US
    NameFullyQualifiedDN = 1,

    // Engineering\JohnDoe
    NameSamCompatible = 2,

    // Probably "John Doe" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    NameDisplay = 3,


    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    NameUniqueId = 6,

    // engineering.widget.com/software/John Doe
    NameCanonical = 7,

    // johndoe@engineering.com
    NameUserPrincipal = 8,

    // Same as NameCanonical except that rightmost '/' is
    // replaced with '\n' - even in domain-only case.
    // eg: engineering.widget.com/software\nJohn Doe
    NameCanonicalEx = 9,

    // www/srv.engineering.com/engineering.com
    NameServicePrincipal = 10,

    // DNS domain name + SAM username
    // eg: engineering.widget.com\JohnDoe
    NameDnsDomain = 12

} EXTENDED_NAME_FORMAT, * PEXTENDED_NAME_FORMAT ;

#endif 

void ShowSpmLpcMessage(IN TSPM_LPC_MESSAGE* pMessage, IN ULONG fOptions)
{
    CHAR  Flags[80] = {0};
    ULONG cInputBuffers = 0;
    ULONG cOutputBuffers = 0;

    ULONG dwAPI = pMessage->GetdwAPI();

    if (dwAPI > SPMAPI_MaxApiNumber) {

        dprintf("dwAPI %d exceeds SPMAPI_MaxApiNumber (%d): maybe invalid message\n", dwAPI, SPMAPI_MaxApiNumber);
    }

    dprintf("_SPM_LPC_MESSAGE %#I64x\n", pMessage->GetLpcMsgBase());
    dprintf("  Message id   \t%#x\n", pMessage->GetMessageId());
    dprintf("  From         \t%#I64x.%#I64x\n", pMessage->GetUniqueProcess(), pMessage->GetUniqueThread());
    dprintf("  API Number   \t%#x (%s)\n", dwAPI, ApiName(dwAPI));

    if (!(fOptions & SHOW_SUMMARY_ONLLY)) {

        dprintf("  Result       \t0x%08lx\n",pMessage->GetscRet());
        dprintf("  LSA Args     \t%s\n", PtrToStr(pMessage->GetLsaArgsBase()));
        dprintf("  SPM Args     \t%s\n", PtrToStr(pMessage->GetLsaApiBase()));
        dprintf("  Data         \t%s\n", PtrToStr(pMessage->GetbData()));

        if (dwAPI > LsapAuMaxApiNumber) {

            Flags[0] = '\0';

            DisplayFlags(pMessage->GetfAPI(), COUNTOF(g_cszAPIFlags), g_cszAPIFlags, sizeof(Flags) - 1, Flags);

            dprintf("  Flags        \t%#x : %s\n", pMessage->GetfAPI(), Flags);

            dprintf("  Context      \t%s\n", PtrToStr(pMessage->GetContextPointer()));
        }

        switch (dwAPI) {

        case LsapAuLookupPackageApi:
            dprintf("  %s %#I64x\n", kstrLkpPkgArgs, pMessage->GetLookupPackageArgsBase());
            dprintf("   (o) Number  \t%#x\n", pMessage->GetAuthenticationPackage());
            dprintf("   (i) Length  \t%#x\n", pMessage->GetPackageNameLength());
            dprintf("   (i) Name    \t%s\n", pMessage->GetPackageName());
            break;

        case LsapAuLogonUserApi:
            dprintf("  _LSAP_LOGON_USER_ARGS %#I64x\n", pMessage->GetLogonUser());

            LsaInitTypeRead(pMessage->GetLogonUser(), _LSAP_LOGON_USER_ARGS);

            dprintf("   (i) Origin  \t{Len: %d, MaxLen: %d, Buffer: %s}\n", LsaReadUSHORTField(OriginName.Length),
                LsaReadUSHORTField(OriginName.MaximumLength), PtrToStr(LsaReadPtrField(OriginName.Buffer)));
            dprintf("   (i) LogonTyp\t%s\n", LogonTypeName(LsaReadULONGField(LogonType)));
            dprintf("   (i) Package \t%#x\n", LsaReadULONGField(AuthenticationPackage));
            dprintf("   (i) AuthInfo\t%#I64x\n", LsaReadPtrField(AuthenticationInformation));
            dprintf("   (i) AuthInfo\t%d\n", LsaReadULONGField(AuthenticationInformationLength));
            dprintf("   (i) GroupCou\t%d\n", LsaReadULONGField(LocalGroupsCount));
            dprintf("   (i) Groups  \t%#I64x\n", LsaReadPtrField(LocalGroups));
            dprintf("   (i) Source  \t%s\n", pMessage->GetSourceContextSourceName());
            dprintf("   (o) SubStat \t0x%08lx\n", LsaReadULONGField(SubStatus));
            dprintf("   (o) Profile \t%#I64x\n", LsaReadPtrField(ProfileBuffer));
            dprintf("   (o) ProfLen \t%#x\n", LsaReadULONGField(ProfileBufferLength));
            dprintf("   (o) LogonId \t%#x:%#x\n", LsaReadULONGField(LogonId.HighPart), LsaReadULONGField(LogonId.LowPart));
            dprintf("   (o) Token   \t%#I64x\n", LsaReadPtrField(Token));
            dprintf("   (o) Quota   \t%#I64x\n", LsaReadPtrField(Quotas.PagedPoolLimit));

            break;

        case LsapAuCallPackageApi:
            dprintf("   _LSAP_CALL_PACKAGE_ARGS %s\n",  PtrToStr(pMessage->GetCallPackage()));

            LsaInitTypeRead(pMessage->GetCallPackage(), _LSAP_CALL_PACKAGE_ARGS);

            dprintf("    (i) Package\t%#x\n", LsaReadULONGField(AuthenticationPackage));
            dprintf("    (i) Buffer \t%s\n", PtrToStr(LsaReadPtrField(ProtocolSubmitBuffer)));
            dprintf("    (i) Length \t%#x\n", LsaReadULONGField(SubmitBufferLength));
            dprintf("    (o) Status \t0x%08lx\n", LsaReadULONGField(ProtocolStatus));
            dprintf("    (o) RBuffer\t%s\n", PtrToStr(LsaReadPtrField(ProtocolReturnBuffer)));
            dprintf("    (o) Length \t%#x\n", LsaReadULONGField(ReturnBufferLength));
            break;

        case LsapAuDeregisterLogonProcessApi:
            break;

        case SPMAPI_GetBinding:
            dprintf("   _SPMGetBindingAPI %s\n", PtrToStr(pMessage->GetGetBinding()));

            LsaInitTypeRead(pMessage->GetGetBinding(), _SPMGetBindingAPI);

            dprintf("    (i) ulPackageId    \t%#I64x\n", LsaReadPtrField(ulPackageId));
            break;

        case SPMAPI_InitContext:
            dprintf("   _SPMInitSecContextAPI %#I64x\n", pMessage->GetInitContext());

            LsaInitTypeRead(pMessage->GetInitContext(), _SPMInitSecContextAPI);

            dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
            dprintf("    (i) hContext       \t%#I64x:%#I64x\n", LsaReadPtrField(hContext.dwUpper), LsaReadPtrField(hContext.dwLower));
            dprintf("    (i) ssTarget       \t%#I64x\n", LsaReadPtrField(ssTarget.Buffer));
            dprintf("    (i) fContextReq    \t%#x\n", LsaReadULONGField(fContextReq));
            dprintf("    (i) Reserved1      \t%#x\n", LsaReadULONGField(dwReserved1));
            dprintf("    (i) TargetDataRep  \t%#x\n", LsaReadULONGField(TargetDataRep));
            dprintf("    (i) sbdInput       \tcBuffer: %d, pBuffers: %s\n", LsaReadULONGField(sbdInput.cBuffers), PtrToStr(LsaReadPtrField(sbdInput.pBuffers)));
            dprintf("    (i) Reserved2      \t%#x\n", LsaReadULONGField(dwReserved2));
            dprintf("    (o) hNewContext    \t%#I64x:%#I64x\n", LsaReadPtrField(hNewContext.dwUpper),  LsaReadPtrField(hNewContext.dwLower));
            dprintf("    (b) sbdOutput      \tcBuffers: %d, pBuffers: %s\n", LsaReadULONGField(sbdOutput.cBuffers), PtrToStr(LsaReadPtrField(sbdOutput.pBuffers)));
            dprintf("    (o) fContextAttr   \t%#x\n", LsaReadULONGField(fContextAttr));
            dprintf("    (o) tsExpiry       \t%#I64x\n", LsaReadULONG64Field(tsExpiry));
            dprintf("    (o) MappedContext  \t%#x\n", LsaReadUCHARField(MappedContext));

            dprintf(pMessage->GetSecBufferInitContextData().toStr("    (o) ContextData  \t"));

            cInputBuffers = LsaReadULONGField(sbdInput.cBuffers);
            for (ULONG i = 0; i < cInputBuffers; i++)
            {
                dprintf(pMessage->GetSecBufferInitSbData(i).toStr("     (i) InputBuffer\t"));
            }

            cOutputBuffers = LsaReadULONGField(sbdOutput.cBuffers);
            for (ULONG i = 0; i <  cOutputBuffers; i++)
            {
                dprintf(pMessage->GetSecBufferInitSbData(i + cInputBuffers).toStr("     (b) OutputBuffer\t"));
            }
            break;

        case SPMAPI_AcceptContext:
            dprintf("   _SPMAcceptContextAPI %#I64x\n", pMessage->GetAcceptContext());

            LsaInitTypeRead(pMessage->GetAcceptContext(), _SPMAcceptContextAPI);

            dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
            dprintf("    (i) hContext       \t%#I64x:%#I64x\n", LsaReadPtrField(hContext.dwUpper), LsaReadPtrField(hContext.dwLower));
            dprintf("    (i) sbdInput       \tcBuffers: %d, pBuffers: %s\n", LsaReadULONGField(sbdInput.cBuffers), PtrToStr(LsaReadPtrField(sbdInput.pBuffers)));
            dprintf("    (i) fContextReq    \t%#x\n", LsaReadULONGField(fContextReq));
            dprintf("    (i) TargetDataRep  \t%#x\n", LsaReadULONGField(TargetDataRep));
            dprintf("    (o) hNewContext    \t%#I64x:%#I64x\n", LsaReadPtrField(hNewContext.dwUpper), LsaReadPtrField(hNewContext.dwLower));
            dprintf("    (b) sbdOutput      \tcBuffers: %d, pBuffers: %s\n", LsaReadULONGField(sbdOutput.cBuffers), PtrToStr(LsaReadPtrField(sbdOutput.pBuffers)));
            dprintf("    (o) fContextAttr   \t%#x \n", LsaReadULONGField(fContextAttr));
            dprintf("    (o) MappedContext  \t%#x\n", LsaReadUCHARField(MappedContext));

            dprintf(pMessage->GetSecBufferAcceptContextData().toStr("    (o) ContextData  \t"));

            cInputBuffers = LsaReadULONGField(sbdInput.cBuffers);

            for (ULONG i = 0; i < cInputBuffers; i++)
            {
                dprintf(pMessage->GetSecBufferAcceptsbData(i).toStr("     (i) InputBuffer\t"));
            }

            cOutputBuffers = LsaReadULONGField(sbdOutput.cBuffers);

            for (ULONG i = 0; i < cOutputBuffers; i++)
            {
                dprintf(pMessage->GetSecBufferAcceptsbData(i + cInputBuffers).toStr("     (b) OutputBuffer\t"));
            }
            break;

        case SPMAPI_FindPackage:
        case SPMAPI_EnumPackages:
            break;

        case SPMAPI_AcquireCreds:
            dprintf("   _SPMAcquireCredsAPI %#I64x\n", pMessage->GetAcquireCreds());

            LsaInitTypeRead(pMessage->GetAcquireCreds(), _SPMAcquireCredsAPI);

            dprintf("    (i) ssPrincipal    \t{Len: %d, MaxLen: %d, Buffer: %s}\n", LsaReadUSHORTField(ssPrincipal.Length),
                LsaReadUSHORTField(ssPrincipal.MaximumLength), PtrToStr(LsaReadPtrField(ssPrincipal.Buffer)));
            dprintf("    (i) ssSecPackage   \t{Len: %d, MaxLen: %d, Buffer: %s}\n", LsaReadUSHORTField(ssSecPackage.Length),
                LsaReadUSHORTField(ssSecPackage.MaximumLength), PtrToStr(LsaReadPtrField(ssSecPackage.Buffer)));
            dprintf("    (i) fCredentialUse \t%#x\n", LsaReadULONGField(fCredentialUse));
            dprintf("    (i) LogonId        \t%#x:%#x\n", LsaReadULONGField(LogonID.HighPart), LsaReadULONGField(LogonID.LowPart));
            dprintf("    (i) pvAuthData     \t%s\n", PtrToStr(LsaReadPtrField(pvAuthData)));
            dprintf("    (i) pvGetKeyFn     \t%s\n", PtrToStr(LsaReadPtrField(pvGetKeyFn)));
            dprintf("    (i) ulGetKeyArgs   \t%#I64x\n", LsaReadPtrField(ulGetKeyArgument));
            dprintf("    (o) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
            break;

        case SPMAPI_EstablishCreds:
            break;

        case SPMAPI_FreeCredHandle:
            dprintf("  _SPMFreeCredHandleAPI %#I64x\n", pMessage->GetFreeCredHandle());

            LsaInitTypeRead(pMessage->GetFreeCredHandle(), _SPMFreeCredHandleAPI);

            dprintf("    (i) hCredential    \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
            break;

        case SPMAPI_ApplyToken:
            break;

        case SPMAPI_DeleteContext:
            dprintf("  _SPMDeleteContextAPI %#I64x\n", pMessage->GetDeleteContext());

            LsaInitTypeRead(pMessage->GetDeleteContext(), _SPMDeleteContextAPI);

            dprintf("    (i) hContext       \t%#I64x:%#I64x\n", LsaReadPtrField(hContext.dwUpper), LsaReadPtrField(hContext.dwLower));
            break;

        case SPMAPI_QueryPackage:
        case SPMAPI_GetUserInfo:
        case SPMAPI_GetCreds:
        case SPMAPI_SaveCreds:
            break;

        case SPMAPI_QueryCredAttributes:
            dprintf("  QueryCredAttributes\n");
            dprintf("  _SPMQueryCredAttributesAPI %#I64x\n", pMessage->GetQueryCredAttributes());

            LsaInitTypeRead(pMessage->GetQueryCredAttributes(), _SPMQueryCredAttributesAPI);

            dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredentials.dwUpper), LsaReadPtrField(hCredentials.dwLower));
            dprintf("    (i) ulAttribute    \t%#x\n", LsaReadULONGField(ulAttribute));
            dprintf("    (i) pBuffer        \t%#I64x\n", LsaReadPtrField(pBuffer));

            cOutputBuffers = LsaReadULONGField(Allocs);

            dprintf("    (o) Allocs         \t%#x\n", cOutputBuffers);

            for (i = 0; i < cOutputBuffers; i++)
            {
                dprintf("    (o) Buffers[%#x] \t%s\n", i, PtrToStr(pMessage->GetQueryCredAttrBuffers(i)));
            }
            break;

        case SPMAPI_QueryContextAttr:
            dprintf("  QueryContextAttributes\n");
            dprintf("  _SPMSetContextAttrAPI %#I64x\n", pMessage->GetQueryContextAttributes());

            LsaInitTypeRead(pMessage->GetQueryContextAttributes(), _SPMQueryContextAttrAPI);

            dprintf("    (i) hContext       \t%#I64x:%#I64x\n", LsaReadPtrField(hContext.dwUpper), LsaReadPtrField(hContext.dwLower));
            dprintf("    (i) ulAttribute    \t%#x\n", LsaReadULONGField(ulAttribute));
            dprintf("    (i) pBuffer        \t%#I64x\n", LsaReadPtrField(pBuffer));

            cOutputBuffers = LsaReadULONGField(Allocs);

            dprintf("    (o) Allocs         \t%#x\n", cOutputBuffers);

            for (i = 0; i < cOutputBuffers; i++)
            {
                dprintf("    (o) Buffers[%#x] \t%s\n", i, PtrToStr(pMessage->GetQueryContextAttrBuffers(i)));
            }
            break;

        case SPMAPI_AddPackage:
        case SPMAPI_DeletePackage:
            break;

        case SPMAPI_EfsGenerateKey:
            dprintf("  _SPMEfsGenerateKeyAPI %#I64x\n", pMessage->GetEfsGenerateKey());

            LsaInitTypeRead(pMessage->GetEfsGenerateKey(), _SPMEfsGenerateKeyAPI);

            dprintf("    (i) EfsStream      \t%#I64x\n", LsaReadPtrField(EfsStream));
            dprintf("    (i) DirectoryEfsStream\t%#I64x\n", LsaReadPtrField(DirectoryEfsStream));
            dprintf("    (i) DirectoryStreamLen\t%#x\n", LsaReadULONGField(DirectoryEfsStreamLength));
            dprintf("    (i) Fek            \t%#I64x\n", LsaReadPtrField(Fek));
            dprintf("    (o) BufferLength   \t%#x\n", LsaReadULONGField(BufferLength));
            dprintf("    (o) BufferBase     \t%#I64x\n", LsaReadPtrField(BufferBase));
            break;

        case SPMAPI_EfsGenerateDirEfs:
            dprintf("  _SPMEfsGenerateDirEfsAPI %#I64x\n", pMessage->GetEfsGenerateDirEfs());

            LsaInitTypeRead(pMessage->GetEfsGenerateDirEfs(), _SPMEfsGenerateDirEfsAPI);

            dprintf("    (i) DirectoryEfsStream\t%#I64x\n", LsaReadPtrField(DirectoryEfsStream));
            dprintf("    (i) DirectoryStreamLen\t%#x\n", LsaReadULONGField(DirectoryEfsStreamLength));
            dprintf("    (i) EfsStream      \t%#I64x\n", LsaReadPtrField(EfsStream));
            dprintf("    (o) BufferBase     \t%#I64x\n", LsaReadPtrField(BufferBase));
            dprintf("    (o) BufferLength   \t%#x\n", LsaReadULONGField(BufferLength));
            break;

        case SPMAPI_EfsDecryptFek:
            dprintf("  _SPMEfsDecryptFekAPI %#I64x\n", pMessage->GetEfsDecryptFek());

            LsaInitTypeRead(pMessage->GetEfsDecryptFek(), _SPMEfsDecryptFekAPI);

            dprintf("    (i) Fek            \t%#I64x\n", LsaReadPtrField(Fek));
            dprintf("    (i) EfsStream      \t%#I64x\n", LsaReadPtrField(EfsStream));
            dprintf("    (i) EfsStreamLength\t%#I64x\n", LsaReadULONGField(EfsStreamLength));
            dprintf("    (i) OpenType       \t%#x\n", LsaReadULONGField(OpenType));
            dprintf("    (?) NewEfs         \t%#I64x\n", LsaReadPtrField(NewEfs));
            dprintf("    (o) BufferBase     \t%#I64x\n", LsaReadPtrField(BufferBase));
            dprintf("    (o) BufferLength   \t%#x\n", LsaReadULONGField(BufferLength));
            break;

        case SPMAPI_EfsGenerateSessionKey:
            break;

        case SPMAPI_Callback:
            dprintf("  _SPMCallbackAPI %#I64x\n", pMessage->GetCallback());

            LsaInitTypeRead(pMessage->GetCallback(), _SPMCallbackAPI);

            dprintf("    (i) Type       \t%#x\n", LsaReadULONGField(Type));
            dprintf("    (i) CallbackFunction\t%#I64x\n", LsaReadPtrField(CallbackFunction));
            dprintf("    (i) Argument1  \t%#I64x\n", LsaReadPtrField(Argument1));
            dprintf("    (i) Argument2  \t%#I64x\n", LsaReadPtrField(Argument2));
            dprintf(pMessage->GetSecBufferCallbackInput().toStr("    (i) Input      \t"));
            dprintf(pMessage->GetSecBufferCallbackOutput().toStr("    (o) Output     \t"));;
            break;

        case SPMAPI_LsaPolicyChangeNotify:
            break;

        case SPMAPI_GetUserNameX:
        {
            ULONG Options;

            dprintf("  GetUserNameX\n");
            dprintf("  _SPMGetUserNameXAPI %#I64x\n", pMessage->GetAddCredential());
            
            LsaInitTypeRead(pMessage->GetAddCredential(), _SPMGetUserNameXAPI);
            
            Options = LsaReadULONGField(Options);

            DisplayGetUserNameOptionsAndType("", sizeof(Flags) - 1, Flags, Options);
            
            dprintf("    (i) Options   %s", Flags);
            dprintf("    (o) Name      {Len: %d, MaxLen: %d, Buffer: %s}\n", 
                LsaReadUSHORTField(Name.Length),
                LsaReadUSHORTField(Name.MaximumLength), 
                PtrToStr(LsaReadPtrField(Name.Buffer)));
            break;
        }

        case SPMAPI_AddCredential:
            dprintf("  AddCredential\n");
            dprintf("  _SPMAddCredentialAPI %#I64x\n", pMessage->GetAddCredential());

            LsaInitTypeRead(pMessage->GetAddCredential(), _SPMAddCredentialAPI);

            dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n",
                                    LsaReadPtrField(hCredentials.dwUpper), LsaReadPtrField(hCredentials.dwLower));
            dprintf("    (i) fCredentialUse \t%#x\n", LsaReadULONGField(fCredentialUse));
            dprintf("    (i) LogonId        \t%#x:%#x\n", LsaReadULONGField(LogonID.HighPart), LsaReadULONGField(LogonID.LowPart));
            dprintf("    (i) pvAuthData     \t%s\n", PtrToStr(LsaReadPtrField(pvAuthData)));
            dprintf("    (i) pvGetKeyFn     \t%s\n", PtrToStr(LsaReadPtrField(pvGetKeyFn)));
            dprintf("    (i) ulGetKeyArgs   \t%#I64x\n", LsaReadPtrField(ulGetKeyArgument));
            break;

        case SPMAPI_EnumLogonSession:
        case SPMAPI_GetLogonSessionData:
        case SPMAPI_SetContextAttr:
        case SPMAPI_LookupAccountSidX:
        case SPMAPI_LookupAccountNameX:
            break;

        default:
            dprintf("No message parsing for this message\n");
            break;
        }
    } else {

        switch (dwAPI) {
        case LsapAuLookupPackageApi:
        dprintf("   (i) Name    \t%s\n", pMessage->GetPackageName());
        break;

        case LsapAuCallPackageApi:
        LsaInitTypeRead(pMessage->GetCallPackage(), _LSAP_CALL_PACKAGE_ARGS);

        dprintf("    (i) Package\t%#x\n", LsaReadULONGField(AuthenticationPackage));
        break;

        case SPMAPI_GetBinding:
        LsaInitTypeRead(pMessage->GetGetBinding(), _SPMGetBindingAPI);

        dprintf("    (i) ulPackageId    \t%#I64x\n", LsaReadPtrField(ulPackageId));
        break;

        case LsapAuLogonUserApi:
        LsaInitTypeRead(pMessage->GetLogonUser(), _LSAP_LOGON_USER_ARGS);

        dprintf("   (i) LogonTyp\t%s\n", LogonTypeName(LsaReadULONGField(LogonType)));
        dprintf("   (i) Package \t%#x\n", LsaReadULONGField(AuthenticationPackage));
        break;

        case SPMAPI_InitContext:
        LsaInitTypeRead(pMessage->GetInitContext(), _SPMInitSecContextAPI);

        dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
        break;

        case SPMAPI_AcceptContext:
        LsaInitTypeRead(pMessage->GetAcceptContext(), _SPMAcceptContextAPI);

        dprintf("    (i) hCredentials   \t%#I64x:%#I64x\n", LsaReadPtrField(hCredential.dwUpper), LsaReadPtrField(hCredential.dwLower));
        break;

        default:
            break;
        }
    }
}

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrsplpc);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrBrief);
}

HRESULT ProcessSpmLpcOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 's':
                *pfOptions |=  SHOW_SUMMARY_ONLLY;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(spmlpc)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 addrCallInfo = 0;
    ULONG64 addrMessage = 0 ;
    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) - 1);

    hRetval = ProcessSpmLpcOptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval) && !IsEmpty(szArgs)) {

        hRetval = GetExpressionEx(szArgs, &addrMessage, &args) && addrMessage ? S_OK : E_INVALIDARG;
    }

    try {

        if (SUCCEEDED(hRetval) && !addrMessage) {

            addrCallInfo = ReadAddrCallInfo();

            hRetval = addrCallInfo ? S_OK : E_FAIL;

            if (SUCCEEDED(hRetval)) {

                addrMessage = ReadStructPtrField(addrCallInfo, kstrCallInfo, "Message");
                hRetval = addrMessage ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Null message in _LSA_CALL_INFO %#I64x\n", addrCallInfo);
                }
            } else {

                dprintf("No thread LPC info is available, TLS call info is null\n");
            }
        }

        if (SUCCEEDED(hRetval)) {

            TSPM_LPC_MESSAGE spmLpcMsg(addrMessage);

            hRetval = spmLpcMsg.IsValid();

            if (SUCCEEDED(hRetval)) {

                (void)ShowSpmLpcMessage(&spmLpcMsg, fOptions);

            } else {

                dprintf("Failed to read _SPM_LPC_MESSAGE %#I64x\n", addrMessage);
                dprintf(kstrIncorrectSymbols);
                dprintf(kstrCheckSym, kstrSpmLpcMsg);
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display SPM_LPC_MESSAGE", kstrSpmLpcMsg);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\sidcache.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sidcache.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sidcache.hxx"
#include "util.hxx"
#include "sid.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdsidc);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
}

PCSTR SidNameUseXLate(IN SID_NAME_USE SidType)
{
    switch (SidType) {
    case SidTypeUser:
        return "User";
    case SidTypeGroup:
        return "Group";
    case SidTypeDomain:
        return "Domain";
    case SidTypeAlias:
        return "Alias";
    case SidTypeWellKnownGroup:
        return "WellKnownGroup";
    case SidTypeDeletedAccount:
        return "Deleted Account";
    case SidTypeInvalid:
        return "Invalid Sid";
    case SidTypeUnknown:
        return "Unknown Type";
    case SidTypeComputer:
        return "Computer";
    default:
        return "Really Unknown -- This is a bug";
    }
}

void ShowSidCache(IN ULONG64 addrSidCacheEntry, IN ULONG fOptions)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    LARGE_INTEGER LocalTime = {0};
    TIME_FIELDS TimeFields = {0};
    LARGE_INTEGER Time = {0};

    ULONG64 addrNextEntry = 0;
    ULONG fieldOffset = 0;
    ULONG cEntries = 0;

    ExitIfControlC();

    //
    // The first is the head and as such is empty
    //
    if (!(fOptions & SHOW_SINGLE_ENTRY)) {

       dprintf("Head of list located at address %#I64x\n", addrSidCacheEntry);
    }

    if (!addrSidCacheEntry) {

        dprintf("Sid cache is empty!\n");
        return;
    }

    while (addrSidCacheEntry) {

        ExitIfControlC();

        LsaInitTypeRead(addrSidCacheEntry, _LSAP_DB_SID_CACHE_ENTRY);

        addrNextEntry = LsaReadPtrField(Next);

        if (!(fOptions & SHOW_SINGLE_ENTRY)) {

            dprintf("#%d) ", cEntries++);
        }

        dprintf("%s %#I64x, next entry %s\n", kstrSidCacheEntry, addrSidCacheEntry, PtrToStr(addrNextEntry));

        fieldOffset = ReadFieldOffset(kstrSidCacheEntry, "AccountName");

        dprintf("  Account Name    %ws\n", TSTRING(addrSidCacheEntry + fieldOffset).toWStrDirect());

        ShowSid("  Account Sid     ", LsaReadPtrField(Sid), fOptions);

        fieldOffset = ReadFieldOffset(kstrSidCacheEntry, "DomainName");

        dprintf("  Domain Name     %ws\n", TSTRING(addrSidCacheEntry + fieldOffset).toWStrDirect());

        ShowSid("  Domain Sid      ", LsaReadPtrField(DomainSid), fOptions);

        dprintf("  Sid Type        %s\n", SidNameUseXLate(static_cast<SID_NAME_USE>(LsaReadULONGField(SidType))));

        Time = ULONG642LargeInteger(LsaReadULONG64Field(CreateTime));

        Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

        if (!NT_SUCCESS(Status)) {

            dprintf("Can't convert create time from GMT to Local time: 0x%lx\n", Status);

        } else {

             RtlTimeToTimeFields(&LocalTime, &TimeFields );

             dprintf("  Create Time     %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        }

        Time = ULONG642LargeInteger(LsaReadULONG64Field(RefreshTime));

        Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

        if (!NT_SUCCESS(Status)) {

            dprintf("Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status);

        } else {

            RtlTimeToTimeFields(&LocalTime, &TimeFields);

            dprintf("  Refresh Time    %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        }

        Time = ULONG642LargeInteger(LsaReadULONG64Field(ExpirationTime));

        Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

        if (!NT_SUCCESS(Status)) {

            dprintf("Can't convert expiration time from GMT to Local time: 0x%lx\n", Status);

        } else {

            RtlTimeToTimeFields(&LocalTime, &TimeFields);

            dprintf("  Expir Time      %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        }

        Time = ULONG642LargeInteger(LsaReadULONG64Field(LastUse));

        Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

        if (!NT_SUCCESS(Status)) {

            dprintf("Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status);

        } else {

            RtlTimeToTimeFields(&LocalTime, &TimeFields);

            dprintf("  Last Used       %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        }

        dprintf("  Flags           %d\n", LsaReadULONGField(Flags));

        if (fOptions & SHOW_SINGLE_ENTRY) {

            break;
        }

        //
        // Get the next entry
        //
        addrSidCacheEntry = addrNextEntry;

    }  // while

    if (!(fOptions & SHOW_SINGLE_ENTRY)) {

        dprintf("There are a total of %d cache entries\n", cEntries);
    }
}

HRESULT ProcessSidCacheOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
            *pfOptions |=  SHOW_FRIENDLY_NAME;
            break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(dumplsasidcache)
{
    HRESULT hRetval = S_OK;

    ULONG fOptions = 0;
    CHAR szArgs[MAX_PATH] = {0};

    ULONG64 addrSidCache = 0;
    ULONG64 addrAddrSidCache = 0;

    try {

        if (args && *args) {

            strncpy(szArgs, args, sizeof(szArgs) - 1);

            hRetval = ProcessSidCacheOptions(szArgs, &fOptions);
        }

        if (SUCCEEDED(hRetval)) {

            if (!IsEmpty(szArgs)) {

                fOptions |= SHOW_SINGLE_ENTRY;

                hRetval = GetExpressionEx(szArgs, &addrSidCache, &args) ? S_OK : E_INVALIDARG;

            } else {

                hRetval = GetExpressionEx(LSA_SID_CACHE, &addrAddrSidCache, &args) && addrAddrSidCache ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read " LSA_SID_CACHE ", try \"dt -x " LSA_SID_CACHE "\" to verify\n");

                    hRetval = E_FAIL;

                } else {

                    addrSidCache = ReadPtrVar(addrAddrSidCache);
                }
            }
        }

        if (SUCCEEDED(hRetval)) {

            ShowSidCache(addrSidCache, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display sid cache", kstrSidCacheEntry);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\tcallinfo.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tcallinfo.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tcallinfo.hxx"
#include "util.hxx"

#include "callinfo.hxx"
#include "tls.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrtclnf);
}

ULONG64 ReadAddrCallInfo(void)
{
    DWORD dwCallInfo;
    ULONG64 addrCallInfo;
    BOOL  success = FALSE;
    PCSTR donotCare = NULL;

    //
    // read the offset of dwCallInfo
    //
    if (!GetExpressionEx(TLS_CALLINFO, &addrCallInfo, &donotCare)) {

        dprintf("Unable to get address of " TLS_CALLINFO ", try \"dt -x " TLS_CALLINFO "\" to verify\n");

        throw "ReadAddrCallInfo was unable to read address of " TLS_CALLINFO;
    }

    //
    // read the value of call info, which is the index
    //
    if (!ReadMemory(addrCallInfo, &dwCallInfo, sizeof(DWORD), NULL)) {

        dprintf(("Unable to get value of " TLS_CALLINFO " at %#I64x\ntry \"dt -x " TLS_CALLINFO "\" to verify\n"), addrCallInfo);

        throw "ReadAddrCallInfo was unable to read value of " TLS_CALLINFO;
    }

    #if 0
    if (dwCallInfo > TLS_MINIMUM_AVAILABLE) {
        dprintf("Index to _TEB::TlsSlots %d exceeds normal value %d\n", dwCallInfo, TLS_MINIMUM_AVAILABLE);
        dprintf("LSASRV!dwCallInfo maybe invalid, try \"!spmlpc <address>\" instead\n");
    }
    #endif

    addrCallInfo = ReadTlsValue(dwCallInfo);

    if (!addrCallInfo) {

        dprintf("No call info available, try \"!tls (poi " TLS_CALLINFO ")\" to verify\n");

        throw "Thread's call info is null";
    }

    return addrCallInfo;
}

DECLARE_API(dumpthreadcallinfo)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrCallInfo = 0;

    hRetval = (args && *args) ? E_INVALIDARG : S_OK;

    try {

        if (SUCCEEDED(hRetval)) {

            addrCallInfo = ReadAddrCallInfo();
        }

        if (SUCCEEDED(hRetval)){

            ShowCallInfo(addrCallInfo);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display thread's call info", kstrCallInfo);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\tls.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tls.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tls.hxx"
#include "util.hxx"
#include "spmlpc.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrgtls);
    dprintf(kstrtls);
}

ULONG64 ReadTlsFromTeb(IN ULONG index, IN ULONG64 addrTeb)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 tlsEntry = 0;
    ULONG fieldOffset = 0;

    static ULONG pointerSize = ReadPtrSize();

    fieldOffset = ReadFieldOffset(kstrTeb, "TlsSlots");

    if (GetPtrWithVoidStar(addrTeb + fieldOffset + index * pointerSize, &tlsEntry)) {

        dprintf("Unable to read TlsSlots %#x from _TEB %#I64x\n", index, addrTeb);
        throw "ReadTlsFromTeb failed";
    }

    return tlsEntry;
}

ULONG64 ReadTlsValue(IN ULONG tlsEntry)
{
   ULONG64 addrTeb = 0;

   GetTebAddress(&addrTeb);

   if (!addrTeb) {

       throw  "ReadTlsValue failed: unable to get current thread address";
   }

   return ReadTlsFromTeb(tlsEntry, addrTeb);
}

DECLARE_API(tls)
{
    HRESULT hRetval = E_FAIL;
    ULONG64 indexTls = 0;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) {

        hRetval = GetExpressionEx(args, &indexTls, &args) && indexTls ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        try {

            dprintf("TLS slot # %#x is %s\n", static_cast<ULONG>(indexTls), PtrToStr(ReadTlsValue(static_cast<ULONG>(indexTls))));

        } CATCH_LSAEXTS_EXCEPTIONS("Unable to get TLS entry", kstrTeb)
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\task.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    task.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "task.hxx"
#include "util.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdtask);
    dprintf(kstrtask);
}

void ShowThreadTask(ULONG64 addrTask)
{
    CHAR szSymbol[256] = {0};

    ULONG64 Disp = 0;
    ULONG64 addr = 0;

    if (!addrTask) {

        dprintf("Task is null\n");

        return;
    }

    dprintf(kstrTypeAddrLn, kstrThreadTask, addrTask);

    LsaInitTypeRead(addrTask, _LSAP_THREAD_TASK);

    addr = LsaReadPtrField(pFunction);
    GetSymbol(addr, szSymbol, &Disp);
    dprintf("  Function     \t%s\n", GetSymbolStr(addr, szSymbol));

    dprintf("  Parameter    \t%s\n", PtrToStr(LsaReadPtrField(pvParameter)));
    dprintf("  Session      \t%s\n", PtrToStr(LsaReadPtrField(pSession)));
    dprintf("  Next task    \t%s\n", PtrToStr(LsaReadPtrField(Next.Flink)));
}

DECLARE_API(dumpthreadtask)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrThreadTask = 0;

    hRetval = args && *args ? ProcessKnownOptions(args) : E_INVALIDARG;

    try {

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(args, &addrThreadTask, &args) && addrThreadTask ? S_OK : E_INVALIDARG;
        }

        if (SUCCEEDED(hRetval)) {

            ShowThreadTask(addrThreadTask);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display thread's task", kstrThreadTask);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\systime.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    systime.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       April 6, 2002

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "systime.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrsyst);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrVerbose);
}

HRESULT ProcessSystimeOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

PCSTR TimeZoneId(
    IN ULONG ZoneId
    )
{
    static PCSTR szZoneId[] = {
        "Unknown", "Standard", "DayLight"
    };

    return (ZoneId < COUNTOF(szZoneId)) ? szZoneId[ZoneId] : "Invalid";
}

DECLARE_API(systime)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrTime = 0;

    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) - 1);

    hRetval = ProcessSystimeOptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval)) {

        if (!IsEmpty(szArgs)) {
            hRetval = GetExpressionEx(szArgs, &addrTime, &args)
                && addrTime ? S_OK : E_INVALIDARG;
        } else {
            fOptions |= SHOW_VERBOSE_INFO;
        }
    }

    try {
        if (SUCCEEDED(hRetval)) {

            if (addrTime) {
                dprintf("addrTime %#I64x\n", addrTime);

                ShowSystemTimeAsLocalTime(NULL, ReadULONG64Var(addrTime));
            }

            if (fOptions & SHOW_VERBOSE_INFO) {
                SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo = {0};
                ULONG cbLen = sizeof(SYSTEM_TIMEOFDAY_INFORMATION);
                hRetval = NtQuerySystemInformation(
                    SystemTimeOfDayInformation,
                    &TimeOfDayInfo,
                    cbLen,
                    &cbLen
                    );
                if (SUCCEEDED(hRetval)) {
                    double timezonebias = TimeOfDayInfo.TimeZoneBias.QuadPart / 10000000.0 / 3600;
                    double boottimebias = ((LONGLONG) TimeOfDayInfo.BootTimeBias) / 10000000.0 / 3600;
                    double sleeptimebias = TimeOfDayInfo.SleepTimeBias / 10000000.0 / 3600;

                    dprintf("TimeOfDayInfo\n  TimeZoneId %s\n  TimeZoneBias %f hours\n  BootTimeBias %f hours\n  SleepTimeBias %f hours\n",
                        TimeZoneId(TimeOfDayInfo.TimeZoneId),
                        timezonebias, boottimebias, sleeptimebias);

                    ShowSystemTimeAsLocalTime("  BootTime", TimeOfDayInfo.BootTime.QuadPart);
                    ShowSystemTimeAsLocalTime("  CurrentTime", TimeOfDayInfo.CurrentTime.QuadPart);
                } else {
                    LARGE_INTEGER SystemTime = {0};
                    dprintf("NtQuerySystemInformation failed with %#x, return len %#x\n", (HRESULT) hRetval, cbLen);
                    hRetval = NtQuerySystemTime(&SystemTime);
                    if (FAILED(hRetval)) {
                        printf("NtQuerySystemTime failed with code %#x\n", (HRESULT) hRetval);
                    } else {
                        ShowSystemTimeAsLocalTime(NULL, *((ULONG64*) &SystemTime));
                    }
                }
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display systime", NULL)

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    } else if (FAILED(hRetval)) {
        dprintf("Systime failed\n");
    }

    (void)ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\tsession.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tsession.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001  Created

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tsession.hxx"
#include "util.hxx"

#include "session.hxx"
#include "tls.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdtssn);
}

DECLARE_API(dumpthreadsession)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrSession = 0;
    ULONG64 addrTlsEntry = 0;
    ULONG tlsEntry = 0;

    hRetval = args && *args ? E_INVALIDARG : S_OK;

    try {

        if (SUCCEEDED(hRetval)) {

            hRetval = GetExpressionEx(TLS_SESSION, &addrTlsEntry, &args) && addrTlsEntry ? S_OK : E_FAIL;

            if (FAILED(hRetval)) {

                dprintf("Unable to read " TLS_SESSION ", try \"dt -x " TLS_SESSION "\" to verify\n");

                hRetval = E_FAIL;

            } else {

                tlsEntry = ReadULONGVar(addrTlsEntry);

                addrSession = ReadTlsValue(tlsEntry);

                if (addrSession) {

                    ShowSession(addrSession, TRUE);

                } else {

                    dprintf("No session data aviable, try \"!tls (poi " TLS_SESSION ")\" to verify\n");
                    hRetval = E_FAIL;
                }
            }
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display thread's session", kstrSession);

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\util.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode / Kernel Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <ntlmsp.h>        // for STRING32

PCSTR g_cszMonths[] = {kstrEmptyA, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

void debugPrintString32(STRING32 str32, const void* base)
{
    //
    // Some poor sanity check
    //

    if (str32.Length <= 1024) {

        debugPrintHex((reinterpret_cast<const CHAR*>(base) + str32.Buffer), str32.Length);

    } else {

        dprintf(" Length %d, MaximumLenght %d ", str32.Length, str32.MaximumLength);
        dprintf(" <not initialized>\n");
    }
}

void debugNPrintfW(IN PCSTR buffer, IN ULONG len)
{
    CHAR bf[256] = {0};

    for (ULONG i = 0; (i < len) && (i < (sizeof(bf) - 1)); i += 2) {
        bf[i / 2] = buffer[i];
    }

    dprintf(bf);
}

void DisplayFlags(IN DWORD Flags, IN DWORD FlagLimit, IN PCSTR flagset[], IN ULONG cbBuffer, OUT PSTR buffer)
{
    PSTR offset = buffer;
    DWORD test = 0;
    DWORD i = 0;
    DWORD scratch = 0;

    if (!Flags) {
        sprintf(buffer, "%.*s", cbBuffer, "None");
        return;
    }

    buffer[0] = '\0';
    test = 1;

    for (i = 0; (i < FlagLimit) && Flags; i++) {
        if (Flags & test) {
            scratch = sprintf(offset, ((offset > buffer) ? ", %.*s" : "%.*s"), cbBuffer, flagset[i]);
            offset += scratch;
            cbBuffer -= scratch;
            Flags &= ~test;
        }
        test <<= 1;
    }

    if (Flags)
    {
        _snprintf(offset, cbBuffer, ((offset > buffer) ? ", %#x" : "%#x"), Flags);
    }
}

void ULONG642TimeStamp(IN ULONG64* pvalue, OUT TimeStamp* pTimeStamp)
{
    C_ASSERT(sizeof(ULONG64) == sizeof(TimeStamp));

    memcpy(pTimeStamp, pvalue, sizeof(TimeStamp));
}

void CTimeStamp(IN PTimeStamp ptsTime, IN BOOL LocalOnly, IN ULONG cbTimeBuf, OUT PSTR pszTimeBuf)
{
    SYSTEMTIME stTime = {0};
    FILETIME tLocal = {0};
    SYSTEMTIME stLocal = {0};

    if (!ptsTime->HighPart) {

        _snprintf(pszTimeBuf, cbTimeBuf, "(zero)");
        return;

    } else if (ptsTime->HighPart >= 0x7FFFFFFF) {\

        _snprintf(pszTimeBuf, cbTimeBuf, "(never)");
        return;
    }

    FileTimeToLocalFileTime((LPFILETIME) ptsTime, &tLocal);
    FileTimeToSystemTime((LPFILETIME) ptsTime, &stTime);
    FileTimeToSystemTime(&tLocal, &stLocal);

    if (LocalOnly) {

        _snprintf(pszTimeBuf, cbTimeBuf, "%02d:%02d:%02d.%03d",
          stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds);

    } else {

        _snprintf(pszTimeBuf, cbTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d %s %02d Local)", stTime.wHour,
            stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
            g_cszMonths[stTime.wMonth], stTime.wDay, stTime.wYear,
            stLocal.wHour, stLocal.wMinute, g_cszMonths[stLocal.wMonth], stLocal.wDay);
    }
}

void CTimeStampFromULONG64(IN ULONG64 tsTimeAsULONG64, IN BOOL LocalOnly, IN ULONG cbTimeBuf, OUT PSTR pszTimeBuf)
{
    TimeStamp tsTime = {0};

    ULONG642TimeStamp(&tsTimeAsULONG64, &tsTime);

    CTimeStamp(&tsTime, LocalOnly, cbTimeBuf, pszTimeBuf);
}

void ElapsedTimeToString(IN PLARGE_INTEGER Time, IN ULONG cbBuffer, IN PSTR Buffer)
{
    TIME_FIELDS ElapsedTime = {0};

    RtlTimeToElapsedTimeFields(Time, &ElapsedTime);

    if (ElapsedTime.Hour) {

        _snprintf(Buffer, cbBuffer, "%d:%02d:%02d.%03d",
            ElapsedTime.Hour,
            ElapsedTime.Minute,
            ElapsedTime.Second,
            ElapsedTime.Milliseconds);

    } else if (ElapsedTime.Minute) {

        _snprintf(Buffer, cbBuffer, "%02d:%02d.%03d",
            ElapsedTime.Minute,
            ElapsedTime.Second,
            ElapsedTime.Milliseconds);

    } else if (ElapsedTime.Second) {

        _snprintf(Buffer, cbBuffer, "%02d.%03d", ElapsedTime.Second, ElapsedTime.Milliseconds);

    } else if (ElapsedTime.Milliseconds) {

        _snprintf(Buffer, cbBuffer, "0.%03d", ElapsedTime.Milliseconds);

    } else {

        _snprintf(Buffer, cbBuffer, "(zero)" );
    }
}

void ElapsedTimeAsULONG64ToString(IN ULONG64 timeAsULONG64, IN ULONG cbBuffer, IN PSTR Buffer)
{
    TimeStamp tsTime = {0};

    ULONG642TimeStamp(&timeAsULONG64, &tsTime);

    ElapsedTimeToString(&tsTime, cbBuffer, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\core\token.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    token.cxx

Abstract:

    Lsaexts debugger extension

Author:

    Larry Zhu          (LZhu)       May 1, 2001

Environment:

    User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "token.hxx"
#include "util.hxx"
#include "sid.hxx"

static void DisplayUsage(void)
{
    dprintf(kstrUsage);
    dprintf(kstrdttkn);
    dprintf(kstrdtkn);
    dprintf(kstrtkn);
    dprintf(kstrOptions);
    dprintf(kstrHelp);
    dprintf(kstrSidName);
    dprintf("\n   handle/addr is the token handle in user mode or TOKEN address in\n");
    dprintf("   kernel mode\n");
}

WCHAR*  GetPrivName(IN LUID* pPriv)
{
    switch (pPriv->LowPart) {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        case SE_UNDOCK_PRIVILEGE:
            return(SE_UNDOCK_NAME);
        case SE_SYNC_AGENT_PRIVILEGE:
            return(SE_SYNC_AGENT_NAME);
        case SE_ENABLE_DELEGATION_PRIVILEGE:
            return(SE_ENABLE_DELEGATION_NAME);
        case SE_MANAGE_VOLUME_PRIVILEGE:
            return(SE_MANAGE_VOLUME_NAME);
        default:
            return(L"Unknown Privilege");
    }
}

void LocalDumpSid(IN PCSTR pszPad, PSID pxSid, IN ULONG fOptions)
{
    UNICODE_STRING ucsSid = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    NtStatus = RtlConvertSidToUnicodeString(&ucsSid, pxSid, TRUE);

    if (NT_SUCCESS(NtStatus)) {

        dprintf("%s", pszPad);
        dprintf(kstrSidFmt, &ucsSid);

    } else {

        dprintf("LocadDumpSid failed to dump Sid at addr %p\n", pxSid);
    }

    RtlFreeUnicodeString(&ucsSid);

    if (fOptions & SHOW_FRIENDLY_NAME) {

        dprintf(kstrSpace);

        dprintf(EasyStr(TSID::ConvertSidToFriendlyName(pxSid, kstrSidNameFmt)));
    }

    dprintf(kstrNewLine);
}

void DumpAttr(IN PCSTR pszPad, IN ULONG attributes, IN ULONG SAType)
{
    if (SAType == SATYPE_GROUP)
    {
        dprintf("%sAttributes - ", pszPad);

        if (attributes & SE_GROUP_MANDATORY)
        {
            attributes &= ~SE_GROUP_MANDATORY;
            dprintf("Mandatory ");
        }

        if (attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            attributes &= ~SE_GROUP_ENABLED_BY_DEFAULT;
            dprintf("Default ");
        }

        if (attributes & SE_GROUP_ENABLED)
        {
            attributes &= ~SE_GROUP_ENABLED;
            dprintf("Enabled ");
        }

        if (attributes & SE_GROUP_OWNER)
        {
            attributes &= ~SE_GROUP_OWNER;
            dprintf("Owner ");
        }

        if (attributes & SE_GROUP_LOGON_ID)
        {
            attributes &= ~SE_GROUP_LOGON_ID;
            dprintf("LogonId ");
        }

        if (attributes & SE_GROUP_USE_FOR_DENY_ONLY)
        {
            attributes &= ~SE_GROUP_USE_FOR_DENY_ONLY;
            dprintf("DenyOnly ");
        }

        if (attributes & SE_GROUP_RESOURCE)
        {
            attributes &= ~SE_GROUP_RESOURCE;
            dprintf("GroupResource ");
        }

        if (attributes)
        {
            dprintf("%#x ", attributes);
        }
    }
}

void DumpSidAttr(IN PSID_AND_ATTRIBUTES pSA, IN ULONG SAType, IN ULONG fOptions)
{
    LocalDumpSid(kstrEmptyA, pSA->Sid, fOptions);
    DumpAttr(kstr4Spaces, pSA->Attributes, SAType);
}

void DumpSidAttr(IN ULONG64 addrSid, IN ULONG attributes, IN ULONG SAType, IN ULONG fOptions)
{
    ShowSid(kstrEmptyA, addrSid, fOptions);
    DumpAttr(kstr4Spaces, attributes, SAType);
}

void DumpLuidAttr(PLUID_AND_ATTRIBUTES pLA, ULONG LAType)
{
    dprintf("0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    dprintf(" %-32ws", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV) {

        dprintf("  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED) {

            dprintf("Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) {

            dprintf("Default ");
        }
    }
}

VOID PrintToken(IN HANDLE hToken, IN ULONG fOptions)
{
    TOKEN_USER* pTUser = NULL;
    TOKEN_GROUPS* pTGroups = NULL;
    TOKEN_PRIVILEGES* pTPrivs = NULL;
    TOKEN_PRIMARY_GROUP* pTPrimaryGroup = NULL;
    TOKEN_STATISTICS TStats = {0};
    ULONG cbRetInfo = 0;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    DWORD i = 0;
    DWORD dwSessionId = 0;

    CHAR bufferUser[256];
    CHAR bufferGroups[4096];
    CHAR bufferPriv[1024];
    CHAR bufferPriGrp[128];

    pTUser = reinterpret_cast<TOKEN_USER*>(bufferUser);
    pTGroups = reinterpret_cast<TOKEN_GROUPS*>(bufferGroups);
    pTPrivs = reinterpret_cast<TOKEN_PRIVILEGES*>(bufferPriv);
    pTPrimaryGroup = reinterpret_cast<TOKEN_PRIMARY_GROUP*>(bufferPriGrp);

    status = NtQueryInformationToken(hToken, TokenSessionId, &dwSessionId, sizeof(dwSessionId), &cbRetInfo);

    if (!NT_SUCCESS(status)) {

        dprintf("NtQueryInformationToken TokenSessionId returned: %#x\n", status);
        return;
    }
    dprintf(kstrTsId, dwSessionId);

    status = NtQueryInformationToken(hToken, TokenUser, pTUser, sizeof(bufferUser), &cbRetInfo);

    if (!NT_SUCCESS(status)) {

        dprintf("NtQueryInformationToken TokenUser returned: %#x\n", status);
        return;
    }

    dprintf(kstrUser);
    DumpSidAttr(&pTUser->User, SATYPE_USER, fOptions);

    dprintf(kstrGroups);
    status = NtQueryInformationToken(hToken, TokenGroups, pTGroups, sizeof(bufferGroups), &cbRetInfo);

    if (!NT_SUCCESS(status)) {

        printf("NtQueryInformationToken TokenGroups returned: %#x\n", status);
        return;
    }

    for (i = 0; i < pTGroups->GroupCount; i++) {

        dprintf("\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP, fOptions);
    }

    RtlZeroMemory(pTGroups, sizeof(bufferGroups));
    status = NtQueryInformationToken(hToken, TokenRestrictedSids, pTGroups, sizeof(bufferGroups), &cbRetInfo);
    if (!NT_SUCCESS(status)) {
    
        printf("NtQueryInformationToken TokenRestrictedSids returned: %#x\n", status);
        return;
    }
    
    if (pTGroups->GroupCount) {
        dprintf(kstrResSids);
    }
    for (i = 0; i < pTGroups->GroupCount; i++) {
    
        dprintf("\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP, fOptions);
    }

    status = NtQueryInformationToken(hToken, TokenPrimaryGroup, pTPrimaryGroup, sizeof(bufferPriGrp), &cbRetInfo);

    if (!NT_SUCCESS(status)) {

        printf("NtQueryInformationToken TokenPrimaryGroup returned: %#x\n", status);
        return;
    }

    dprintf(kstrNewLine);
    dprintf(kstrPrimaryGroup);
    LocalDumpSid(kstrEmptyA, pTPrimaryGroup->PrimaryGroup, fOptions);

    dprintf(kstrPrivs);
    status = NtQueryInformationToken(hToken, TokenPrivileges, pTPrivs, sizeof(bufferPriv), &cbRetInfo);

    if (!NT_SUCCESS(status)) {

        printf("NtQueryInformationToken TokenPrivileges returned: %#x\n", status);
        return;
    }
    for (i = 0; i < pTPrivs->PrivilegeCount; i++) {

        dprintf("\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }
    
    status = NtQueryInformationToken(hToken, TokenStatistics, &TStats, sizeof(TStats), &cbRetInfo);
    if (!NT_SUCCESS(status)) {

        printf("NtQueryInformationToken TokenStatistics returned: %#x\n", status);
        return;
    }
    
    dprintf(kstrAuthId, TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    dprintf(kstrModifiedId, TStats.ModifiedId.HighPart, TStats.ModifiedId.LowPart);
    dprintf(kstrRestricted, pTGroups->GroupCount ? "true" : "false");
    dprintf(kstrImpLevel, ImpLevel(TStats.ImpersonationLevel));
    dprintf(kstrTknType, TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
}

HRESULT
LiveSessionToken(
    IN HANDLE hProcess,
    IN HANDLE hThread,
    IN HANDLE hRemoteToken,
    IN ULONG fOptions,
    OUT BOOLEAN* pbImpersonating
    )
{
    HRESULT hRetval = S_OK;
    HANDLE hToken = NULL;

    *pbImpersonating = FALSE;

    hRetval = hProcess ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) {

        if (hRemoteToken == NULL) {

            hRetval = NtOpenThreadToken(hThread, TOKEN_QUERY, TRUE, &hToken);

            if ((hRetval == STATUS_NO_TOKEN)) {

                dprintf("Thread is not impersonating. Using process token...\n");

                hRetval = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);

            } else if (SUCCEEDED(hRetval)) {

                *pbImpersonating = TRUE;
            }
        } else {

            hRetval = DuplicateHandle(
                        hProcess,
                        hRemoteToken,
                        GetCurrentProcess(),
                        &hToken,
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS
                        ) ? STATUS_SUCCESS : GetLastErrorAsNtStatus();
        }
    }

    if (SUCCEEDED(hRetval)) {

        DBG_LOG(LSA_LOG, ("token %p, remote token %p\n", hToken, hRemoteToken));

        try {
            
            PrintToken(hToken, fOptions);

        } CATCH_LSAEXTS_EXCEPTIONS(NULL, NULL)

    } else {

        dprintf("Error %#x getting token\n", hRetval);
    }

    if (hToken) {

        CloseHandle(hToken);
    }

    return hRetval;
}

void DisplayPrivilegs(IN ULONG64 privAddr, IN ULONG cPriv)
{
   UCHAR buffer[1024] = {0};
   LUID_AND_ATTRIBUTES* pPrivileges = reinterpret_cast<LUID_AND_ATTRIBUTES*>(buffer);

   LsaReadMemory(privAddr, cPriv * sizeof(LUID_AND_ATTRIBUTES), pPrivileges);

   for (ULONG i = 0; i < cPriv ; i++) {

       dprintf("\n %02d ", i);
       DumpLuidAttr(pPrivileges + i, SATYPE_PRIV);
   }
}

void DisplayGroups(IN ULONG64 addrGroups, IN ULONG cGroup, IN ULONG cbSA, IN ULONG fOptions)
{
    for (ULONG i = 0; i < cGroup; i++) {

        dprintf("\n %02d ", i);
        TSID_AND_ATTRIBUTES sa(addrGroups + i * cbSA);
        DumpSidAttr(sa.GetSidAddr(), sa.GetAttributes(), SATYPE_GROUP, fOptions);
    }
}

//
// Token Flags
//
// Flags that may be defined in the TokenFlags field of the token object,
// or in an ACCESS_STATE structure
//

#define TOKEN_HAS_TRAVERSE_PRIVILEGE    0x01
#define TOKEN_HAS_BACKUP_PRIVILEGE      0x02
#define TOKEN_HAS_RESTORE_PRIVILEGE     0x04
#define TOKEN_HAS_ADMIN_GROUP           0x08
#define TOKEN_IS_RESTRICTED             0x10
#define TOKEN_SESSION_NOT_REFERENCED    0x20
#define TOKEN_SANDBOX_INERT             0x40

PCSTR g_cszTokenFlags[] = {
    "HasTraversePriv", "HasBackupPriv", "HasRestorePri", "HasAdminGroup",
    "IsRestricted", "SessionNotResferenced", "SandBoxInert"};

void DisplayToken(ULONG64 addrToken, IN ULONG fOptions)
{
    ULONG cGroup = 0;
    ULONG cbSA = 0;
    ULONG cRestrictedSids = 0;
    ULONG64 addrRestrictedSids = 0;
    ULONG64 addrGroups = 0;
    CHAR szTokenFlags[MAX_PATH] = {0};

    //
    // ExFastReference()
    //

    addrToken &= ~((ULONG64) ( IsPtr64() ? 0xF : 7 )); // the last 3/4 bits are for fast ref _EX_FAST_REF

    LsaInitTypeRead(addrToken, nt!_TOKEN);

    dprintf(kstrTsId, LsaReadULONGField(SessionId));

    dprintf(kstrUser); // nt!_TOKEN
    TSID_AND_ATTRIBUTES tsa(LsaReadPtrField(UserAndGroups));
    DumpSidAttr(tsa.GetSidAddr(), tsa.GetAttributes(), SATYPE_USER, fOptions);

    dprintf(kstrGroups);

    cGroup = LsaReadULONGField(UserAndGroupCount);

    addrGroups = LsaReadPtrField(UserAndGroups);
    cbSA = TSID_AND_ATTRIBUTES::GetcbSID_AND_ATTRIBUTESInArray();

    //
    // stolen from NtQueryInformationToken because the first sid is the user itself
    //
    addrGroups += cbSA;
    cGroup -= 1;

    DisplayGroups(addrGroups, cGroup, cbSA, fOptions);


    cRestrictedSids = LsaReadULONGField(RestrictedSidCount);

    if (cRestrictedSids) {
        dprintf(kstrResSids);
        addrRestrictedSids = LsaReadPtrField(RestrictedSids);
        DisplayGroups(addrRestrictedSids, cRestrictedSids, cbSA, fOptions);
    }

    dprintf(kstrNewLine);
    dprintf(kstrPrimaryGroup);
    ShowSid(kstrEmptyA, LsaReadPtrField(PrimaryGroup), fOptions);

    dprintf(kstrPrivs);
    DisplayPrivilegs(LsaReadPtrField(Privileges), LsaReadULONGField(PrivilegeCount));

    dprintf(kstrAuthId, LsaReadULONGField(AuthenticationId.HighPart), LsaReadULONGField(AuthenticationId.LowPart));
    dprintf(kstrModifiedId, LsaReadULONGField(ModifiedId.HighPart), LsaReadULONGField(ModifiedId.LowPart));

    DisplayFlags(
        LsaReadULONGField(TokenFlags), 
        RTL_NUMBER_OF(g_cszTokenFlags),
        g_cszTokenFlags,
        sizeof(szTokenFlags), 
        szTokenFlags
        );

    dprintf("TokenFlags: %#x %s\n", 
        LsaReadULONGField(TokenFlags),
        szTokenFlags
        );

    //
    // SeTokenIsRestricted()
    //

    dprintf(kstrRestricted, LsaReadULONGField(TokenFlags) & TOKEN_IS_RESTRICTED ? "true" : "false");
    
    dprintf(kstrImpLevel, ImpLevel(LsaReadULONGField(ImpersonationLevel)));

    dprintf(kstrTknType, LsaReadULONGField(TokenType) == TokenPrimary ? "Primary" : "Impersonation");
}

#if 0

//
// This is the logic to determine impersonation info in !thread
//
if (ActiveImpersonationInfo) {
    InitTypeRead(ImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);
    ImpersonationInfo_Token = ReadField(Token);
    ImpersonationInfo_ImpersonationLevel = ReadField(ImpersonationLevel);

    if (ImpersonationInfo_Token) {
        dprintf("%sImpersonation token:  %p (Level %s)\n",
                    pszPad, ImpersonationInfo_Token,
                    SecImpLevels( ImpersonationInfo_ImpersonationLevel ) );
    }
    else
    {
        dprintf("%sUnable to read Impersonation Information at %x\n",
                    pszPad, ImpersonationInfo );
    }
} else {

    dprintf("%sNot impersonating\n", pszPad);
}

#endif

HRESULT DumpSessionToken(IN ULONG dwProcessor, IN ULONG64 addrToken, IN ULONG fOptions)
{
    HRESULT hRetval = S_OK;

    ULONG64 addrThread = 0;
    ULONG64 addrProcess = 0;
    ULONG ActiveImpersonationInfo = 0;
    ULONG64 addrImpersonationInfo = 0;

    //
    // If no token addr is input as argument, addrToken is zero
    //
    if (addrToken && !IsAddressInNonePAEKernelAddressSpace(addrToken)) {

        //
        // This can not be a kernel mode access token address
        //
        dprintf("%#I64x is not a valid KM token address, if this is an access token handle,\n", addrToken);
        dprintf("try \"!handle %#I64x\" to get the token address first\n\n", addrToken);
        hRetval = E_FAIL;
    }

    try {

        if (SUCCEEDED(hRetval) && !addrToken) {

            GetCurrentThreadAddr(dwProcessor, &addrThread);
            addrThread &= ~((ULONG64) ( IsPtr64() ? 0xF : 7 ));
            hRetval = IsAddressInNonePAEKernelAddressSpace(addrThread) ? S_OK : E_FAIL;

            if (FAILED(hRetval)) {

                dprintf("Unable to read current thread address\n");

            } else {

                //
                // ActiveImpersonationInfo is of type C Bit Fields and has a width of 1 (Bitfield Pos 3, 1 Bit)
                //
                LsaInitTypeRead(addrThread, nt!_ETHREAD);
                ActiveImpersonationInfo = LsaReadULONGField(ActiveImpersonationInfo);

                if (ActiveImpersonationInfo) {

                    addrImpersonationInfo = ReadStructPtrField(addrThread, "nt!_ETHREAD", "ImpersonationInfo");
                }

                if (addrImpersonationInfo) {

                    LsaInitTypeRead(addrImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);

                    addrToken = LsaReadPtrField(Token);

                    dprintf("nt!_PS_IMPERSONATION_INFORMATION %#I64x\n    Token %#I64x, CopyOnOpen %#x, EffectiveOnly %#x, ImpersonationLevel %#x\n",
                        addrImpersonationInfo,
                        addrToken,
                        LsaReadUCHARField(CopyOnOpen), 
                        LsaReadUCHARField(EffectiveOnly), 
                        LsaReadULONGField(ImpersonationLevel));                           
                }
            }

            //
            //  If addrToken is NULL, then this is not an impersonation case
            //
            if (SUCCEEDED(hRetval) && !addrToken) {

                dprintf("Thread is not impersonating. Using process token...\n");
                GetCurrentProcessAddr(dwProcessor, addrThread, &addrProcess);
                addrProcess &= ~((ULONG64) ( IsPtr64() ? 0xF : 7 ));
                hRetval = IsAddressInNonePAEKernelAddressSpace(addrProcess) ? S_OK : E_FAIL;

                if (FAILED(hRetval)) {

                    dprintf("Unable to read current process address\n");

                } else {

                    addrToken = ReadStructPtrField(addrProcess, "nt!_EPROCESS", "Token");

                    hRetval = IsAddressInNonePAEKernelAddressSpace(addrToken) ? S_OK : E_FAIL;
                }
            }

            if (FAILED(hRetval)) {

                dprintf("Unable to read token address\n");
            }
        }

        if (SUCCEEDED(hRetval)) {

            if (addrProcess) {

                dprintf("_EPROCESS %#I64x, ", toPtr(addrProcess));
            }

            if (addrThread) {

                dprintf("_ETHREAD %#I64x, ", toPtr(addrThread));
            }

            dprintf(kstrTypeAddrLn, kstrTkn, toPtr(addrToken));

            (void)DisplayToken(addrToken, fOptions);
        }
    } CATCH_LSAEXTS_EXCEPTIONS("Unable to display token", kstrTkn)

    return hRetval;
}

HRESULT ProcessTokenOptions(IN OUT PSTR pszArgs, IN OUT ULONG* pfOptions)
{
    HRESULT hRetval = pszArgs && pfOptions ? S_OK : E_INVALIDARG;

    for (; SUCCEEDED(hRetval) && *pszArgs; pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case 'n':
                *pfOptions |=  SHOW_FRIENDLY_NAME;
                break;

            case 'v':
                *pfOptions |=  SHOW_VERBOSE_INFO;
                break;

            case '?':
            default:
                hRetval = E_INVALIDARG;
                break;
            }

            *(pszArgs - 1) = *(pszArgs) = ' ';
        }
    }

    return hRetval;
}

DECLARE_API(token)
{
    HRESULT hRetval = E_FAIL;

    ULONG64 addrToken = 0;
    ULONG dwProcessor = 0;
    HANDLE hCurrentThread = NULL;
    HANDLE hProcess = NULL;
    ULONG SessionType = DEBUG_CLASS_UNINITIALIZED;
    ULONG SessionQual = 0;

    CHAR szArgs[MAX_PATH] = {0};
    ULONG fOptions = 0;

    strncpy(szArgs, args ? args : kstrEmptyA, sizeof(szArgs) - 1);

    hRetval = ProcessTokenOptions(szArgs, &fOptions);

    if (SUCCEEDED(hRetval) && !IsEmpty(szArgs)) {

        hRetval = GetExpressionEx(szArgs, &addrToken, &args) && addrToken ? S_OK : E_INVALIDARG;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = ExtQuery(Client);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread);
    }

    if (SUCCEEDED(hRetval)) {

       hRetval = g_ExtControl->GetDebuggeeType(&SessionType, &SessionQual);
    }

    if (SUCCEEDED(hRetval)) {

        if ( SessionType == DEBUG_CLASS_USER_WINDOWS &&
             SessionQual == DEBUG_USER_WINDOWS_PROCESS ) {

            HANDLE hToken = NULL;
            BOOLEAN bImpersonating = FALSE;
            GetCurrentProcessHandle(&hProcess);

            if (fOptions & SHOW_FRIENDLY_NAME) {

                //
                // "-n" will hang the machine if it is running under usermode
                // and the process being debugged is lsass.exe
                //

                CHAR szProcessPathDebugged[MAX_PATH] = {0};
                CHAR szFileName[_MAX_FNAME] = {0};

                hRetval = g_ExtSystem->GetCurrentProcessExecutableName(
                            szProcessPathDebugged,
                            sizeof(szProcessPathDebugged) - 1,
                            NULL
                            );

                if (SUCCEEDED(hRetval)) {
                    _splitpath(szProcessPathDebugged, NULL, NULL, szFileName, NULL);
                    DBG_LOG(LSA_LOG, ("ProcessPath %s, FileName %s\n", szProcessPathDebugged, szFileName));
                }

                if (FAILED(hRetval) || (!_stricmp(szFileName, "lsass"))) {
                    dprintf("\nWARNING: sid2name lookup (-n) while debugging lsass.exe hangs the machine, ignore lookup request\n\n");
                    fOptions &= ~SHOW_FRIENDLY_NAME;
                }
            }

            if (SUCCEEDED(hRetval)) {
                hRetval = LiveSessionToken(
                                hProcess,
                                hCurrentThread,
                                reinterpret_cast<HANDLE>(static_cast<ULONG_PTR>(addrToken)),
                                fOptions,
                                &bImpersonating
                                );
            }
            if (SUCCEEDED(hRetval) && (fOptions & SHOW_VERBOSE_INFO) && bImpersonating) {

                dprintf("\nDisplaying process token when thread is impersonating...\n");
                hRetval = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);

                if (SUCCEEDED(hRetval)) {

                    PrintToken(hToken, fOptions);
                }
            }

            if (hToken) {
                NtClose(hToken);
            }
         } else if (DEBUG_CLASS_KERNEL == SessionType) {

            hRetval = DumpSessionToken(dwProcessor, addrToken, fOptions);

         }  else {

            dprintf("lsaexts!token debugger type not supported: SessionType %#x, SessionQual %#x\n", SessionType, SessionQual);

            hRetval = DEBUG_EXTENSION_CONTINUE_SEARCH;
         }
    }

    if (E_INVALIDARG == hRetval) {

        (void)DisplayUsage();
    }

    (void)ExtRelease();

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaclientid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaclientid.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaclientid.hxx"

TCLIENT_ID::TCLIENT_ID(void) : m_hr(E_FAIL)
{
}

TCLIENT_ID::TCLIENT_ID(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TCLIENT_ID::~TCLIENT_ID(void)
{
}

HRESULT TCLIENT_ID::IsValid(void) const
{
    return m_hr;
}

ULONG64 TCLIENT_ID::GetUniqueProcess(void) const
{
    return ReadStructPtrField(m_baseOffset, "_CLIENT_ID", "UniqueProcess");
}

ULONG64 TCLIENT_ID::GetUniqueThread(void) const
{
    return ReadStructPtrField(m_baseOffset, "_CLIENT_ID", "UniqueThread");
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TCLIENT_ID::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TCLIENT_ID::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaargs.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaargs.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001 Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaargs.hxx"

TSPM_LSA_ARGUMENTS::TSPM_LSA_ARGUMENTS(void) : m_hr(E_FAIL)
{
}

TSPM_LSA_ARGUMENTS::TSPM_LSA_ARGUMENTS(IN ULONG64 baseOffset)
    : TLSA_API(baseOffset), TSPMLPCAPI(baseOffset),
      m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSPM_LSA_ARGUMENTS::~TSPM_LSA_ARGUMENTS(void)
{
}

HRESULT TSPM_LSA_ARGUMENTS::IsValid(void) const
{
    return m_hr;
}

ULONG64 TSPM_LSA_ARGUMENTS::GetLsaArgsBase(void) const
{
    return m_baseOffset;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSPM_LSA_ARGUMENTS::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSPM_LSA_ARGUMENTS::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = TLSA_API::Initialize(baseOffset);

    if (SUCCEEDED(m_hr)) {
        m_hr = TSPMLPCAPI::Initialize(baseOffset);
    }

    if (SUCCEEDED(m_hr)) {
        m_hr = Initialize();
    }

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaapi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaapi.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaapi.hxx"

TLSA_API::TLSA_API(IN ULONG64 baseOffset)
   : TLSAP_LOOKUP_PACKAGE_ARGS(baseOffset),
     m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TLSA_API::TLSA_API(void) : m_hr(E_FAIL)
{
}

TLSA_API::~TLSA_API(void)
{
}

HRESULT TLSA_API::IsValid(void) const
{
    return m_hr;
}

ULONG64 TLSA_API::GetLogonUser(void) const
{
    return m_baseOffset;
}

ULONG64 TLSA_API::GetCallPackage(void) const
{
    return m_baseOffset;
}

ULONG64 TLSA_API::GetLsaApiBase(void) const
{
    return m_baseOffset;
}

#ifndef TOKEN_SOURCE_LENGTH
#define TOKEN_SOURCE_LENGTH 8
#endif

PCSTR TLSA_API::GetSourceContextSourceName(void) const
{
   static ULONG fieldOffset = ReadFieldOffset("_LSAP_LOGON_USER_ARGS", "SourceContext.SourceName");
   static CHAR szBuffer[TOKEN_SOURCE_LENGTH + 1] = {0};

   if (!ReadMemory(m_baseOffset + fieldOffset,
                             szBuffer,
                             TOKEN_SOURCE_LENGTH,
                             NULL)) {
       throw "Read LogonUserArgs SourceContext.SourceName failed";
    }

    return szBuffer;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TLSA_API::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TLSA_API::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;
    m_hr = TLSAP_LOOKUP_PACKAGE_ARGS::Initialize(baseOffset);

    if (SUCCEEDED(m_hr)) {
        m_hr = Initialize();
    }

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsagbl.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    lsagbl.cxx

Abstract:

    Lsa Library Globals

Author:

    Larry Zhu (Lzhu)  May 1, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

namespace LSA_NS {

TLsaLibarayGlobals g_Globals = { 1,    // major version
                                 2,    // minor version
                                 0,    // debug mask
                                 NULL, // debug prompt
                               };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsacstr.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    lsacstr.cxx

Abstract:

    LSA Constant Strings.

Author:

    Larry Zhu (Lzhu)  May 1, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "lsacstr.hxx"

namespace LSA_NS {

PCTSTR kstrEmpty             = _T("");
PCSTR  kstrEmptyA            = ("");
PCSTR  kstrNewLine           = ("\n");
PCSTR  kstrStrLn             = ("%s\n");
PCSTR  kstr2StrLn            = ("%s%s\n");
PCSTR  kstrLsaDbgPrompt      = ("lsaexts> ");
PCSTR  kstrSpace             = (" ");
PCSTR  kstr2Spaces           = ("  ");
PCSTR  kstr4Spaces           = ("    ");
PCSTR  kstr8Spaces           = ("        ");
PCSTR  kstrNullPtrA          = ("(null)");
PCWSTR kstrNullPtrW          = (L"(null)");
PCSTR  kstrInvalid           = ("Invalid");

//
// Format strings used to dump SID
//
PCSTR kstrSidNameFmt         = ("(%s: %s\\%s)");
PCSTR kstrSdNmFmt            = ("%s: %s\\%s");
PCSTR kstrSidFmt             = ("%wZ");
PCSTR kstrShowSecBuffer      = ("SecBuffer: ");

PCSTR kstrExitOnControlC     = ("Exit on Control C");

//
// some type names
//
PCSTR kstrClBk         = ("_SPMCallbackAPI");
PCSTR kstrLkpPkgArgs   = ("_LSAP_LOOKUP_PACKAGE_ARGS");
PCSTR kstrSA           = ("_SID_AND_ATTRIBUTES");
PCSTR kstrSid          = ("_SID");
PCSTR kstrPrtMsg       = ("_PORT_MESSAGE");
PCSTR kstrSecBuffer    = ("_SecBuffer");
PCSTR kstrSecBuffDesc  = ("_SecBufferDesc");
PCSTR kstrSpmApiMsg    = ("_SPM_API_MESSAGE");
PCSTR kstrSpmCptCntxt  = ("_SPMAcceptContextAPI");
PCSTR kstrSpmLpcMsg    = ("_SPM_LPC_MESSAGE");
PCSTR kstrSpmNtCntxt   = ("_SPMInitSecContextAPI");
PCSTR kstrSpmLpcApi    = ("_SPMLPCAPI");
PCSTR kstrListEntry    = ("_LIST_ENTRY");
PCSTR kstrLHT          = ("_LARGE_HANDLE_TABLE");
PCSTR kstrSHT          = ("_SMALL_HANDLE_TABLE");
PCSTR kstrCtxtData     = ("ContextData");
PCSTR kstrNext         = ("Next");
PCSTR kstrFlink        = ("Flink");
PCSTR kstrNextFlink    = ("Next.Flink");
PCSTR kstrList         = ("List");
PCSTR kstrListFlink    = ("List.Flink");
PCSTR kstrSbData       = ("sbData");
PCSTR kstrVoidStar     = ("void*");

//
// misc
//
PCSTR kstrSbdWrn       = ("Only 16 buffers are printed, the buffer descriptor may be wrong\n");
PCSTR kstrIncorrectSymbols =
      ("*************************************************************************\n"
       "***                                                                   ***\n"
       "***                                                                   ***\n"
       "***    Your debugger is not using the correct symbols                 ***\n"
       "***                                                                   ***\n"
       "***    In order for this command to work properly, your symbol path   ***\n"
       "***    must point to .pdb files that have full type information.      ***\n"
       "***                                                                   ***\n"
       "***    Certain .pdb files (such as the public OS symbols) do not      ***\n"
       "***    contain the required information.  Contact the group that      ***\n"
       "***    provided you with these symbols if you need this command to    ***\n"
       "***    work.                                                          ***\n"
       "***                                                                   ***\n"
       "***                                                                   ***\n"
       "*************************************************************************\n");
PCSTR kstrCheckSym = ("try \"dt -x %s\" to check for required type information\n");

} // LSA_NS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaapim.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaapim.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001 Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaapim.hxx"

TSPM_API_MESSAGE::TSPM_API_MESSAGE(void) : m_hr(E_FAIL)
{
}

TSPM_API_MESSAGE::TSPM_API_MESSAGE(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSPM_API_MESSAGE::~TSPM_API_MESSAGE(void)
{
}

HRESULT TSPM_API_MESSAGE::IsValid(void) const
{
    return m_hr;
}

ULONG TSPM_API_MESSAGE::GetdwAPI(void) const
{
    DWORD dwAPI = 0;

    ReadStructField(m_baseOffset, kstrSpmApiMsg, "dwAPI", sizeof(dwAPI), &dwAPI);

    return dwAPI;
}

HRESULT TSPM_API_MESSAGE::GetscRet(void) const
{
    HRESULT scRet = E_FAIL;

    ReadStructField(m_baseOffset, kstrSpmApiMsg, "scRet", sizeof(scRet), &scRet);

    return scRet;
}

ULONG64 TSPM_API_MESSAGE::GetbData() const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrSpmApiMsg, "bData");

    return m_baseOffset + fieldOffset;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSPM_API_MESSAGE::Initialize(void)
{
    HRESULT hRetval = E_FAIL;
    ULONG fieldOffset = 0;

    hRetval = NO_ERROR == GetFieldOffset(kstrSpmApiMsg, "Args", &fieldOffset) ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) {

        hRetval = TSPM_LSA_ARGUMENTS::Initialize(m_baseOffset + fieldOffset);
    }

    return hRetval;
}

HRESULT TSPM_API_MESSAGE::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;
    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsalht.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsalht.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsalht.hxx"
#include <stdio.h>
#include <string.h>

TLHT::TLHT(void) : m_hr(E_FAIL)
{
}

TLHT::TLHT(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TLHT::~TLHT(void)
{
}

HRESULT TLHT::IsValid(void) const
{
    return m_hr;
}

ULONG TLHT::GetFlags(void) const
{
    ULONG Flags = 0;

    ReadStructField(m_baseOffset, kstrLHT, "Flags", sizeof(Flags), &Flags);

    return Flags;
}

ULONG TLHT::GetCount(void) const
{
    ULONG Count = 0;

    ReadStructField(m_baseOffset, kstrLHT, "Count", sizeof(Count), &Count);

    return Count;
}

ULONG TLHT::GetListsFlags(IN ULONG index) const
{
    CHAR szTmp[64] = {0};
    ULONG Flags = 0;

    _snprintf(szTmp, sizeof(szTmp) - 1, "Lists[%#x].Flags", index);

    DBG_LOG(LSA_LOG, ("Reading %s from %s %#I64x\n", szTmp, kstrLHT, m_baseOffset));

    ReadStructField(m_baseOffset, kstrLHT, szTmp, sizeof(Flags), &Flags);

    return Flags;
}

ULONG64 TLHT::GetPendingHandle(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrLHT, "PendingHandle");
}

ULONG64 TLHT::GetListsFlink(IN ULONG index) const
{
    CHAR szTmp[64] = {0};

    _snprintf(szTmp, sizeof(szTmp) - 1, "Lists[%#x].List.Flink", index);

    DBG_LOG(LSA_LOG, ("Reading %s from %s %#I64x\n", szTmp, kstrLHT, m_baseOffset));

    return ReadStructPtrField(m_baseOffset, kstrLHT, szTmp);
}

ULONG64 TLHT::GetAddrLists(IN ULONG index) const
{
    CHAR szTmp[64] = {0};

    ULONG fieldOffset = 0;

    _snprintf(szTmp, sizeof(szTmp) - 1, "Lists[%#x]", index);

    DBG_LOG(LSA_LOG, ("Reading offset %s from %s %#I64x\n", szTmp, kstrLHT, m_baseOffset));

    fieldOffset = ReadFieldOffset(kstrLHT, szTmp);

    return m_baseOffset + fieldOffset;
}

ULONG64 TLHT::GetDeleteCallback(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrLHT, "DeleteCallback");
}

ULONG TLHT::GetDepth(void) const
{
    ULONG Depth = 0;

    ReadStructField(m_baseOffset, kstrLHT, "Depth", sizeof(Depth), &Depth);

    return Depth;
}

ULONG64 TLHT::GetParent(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrLHT, "Parent");
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TLHT::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TLHT::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsalookup.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsalookup.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             6-May-2001  Created.

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsalookup.hxx"

TLSAP_LOOKUP_PACKAGE_ARGS::TLSAP_LOOKUP_PACKAGE_ARGS(void) : m_hr(E_FAIL)
{
}

TLSAP_LOOKUP_PACKAGE_ARGS::TLSAP_LOOKUP_PACKAGE_ARGS(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TLSAP_LOOKUP_PACKAGE_ARGS::~TLSAP_LOOKUP_PACKAGE_ARGS(void)
{
}

HRESULT TLSAP_LOOKUP_PACKAGE_ARGS::IsValid(void) const
{
    return m_hr;
}

ULONG TLSAP_LOOKUP_PACKAGE_ARGS::GetAuthenticationPackage(void) const
{
    ULONG AuthenticatonPackage = 0;

    ReadStructField(m_baseOffset, kstrLkpPkgArgs, "AuthenticationPackage", sizeof(AuthenticatonPackage), &AuthenticatonPackage);

    return AuthenticatonPackage;
}

ULONG TLSAP_LOOKUP_PACKAGE_ARGS::GetAuthenticationPackageDirect(void) const
{
    ULONG AuthenticatonPackage = 0;

    if (!ReadMemory(m_baseOffset, &AuthenticatonPackage, sizeof(AuthenticatonPackage), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read AuthenticatonPackage for LSAP_LOOKUP_PACKAGE_ARGS at %#I64x\n", m_baseOffset));

        throw "LSAP_LOOKUP_PACKAGE_ARGS::GetAuthenticationPackageDirect failed";
    }

    return AuthenticatonPackage;
}

ULONG TLSAP_LOOKUP_PACKAGE_ARGS::GetPackageNameLengthDirect(void) const
{
    ULONG PackageNameLength = 0;

    if (!ReadMemory(m_baseOffset + sizeof(ULONG), &PackageNameLength, sizeof(PackageNameLength), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read PackageNameLength for LSAP_LOOKUP_PACKAGE_ARGS at %#I64x\n", m_baseOffset));

        throw "LSAP_LOOKUP_PACKAGE_ARGS::GetPackageNameLengthDirect failed";
    }

    return PackageNameLength;
}

ULONG TLSAP_LOOKUP_PACKAGE_ARGS::GetPackageNameLength(void) const
{
    ULONG PackageNameLength = 0;

    ReadStructField(m_baseOffset, kstrLkpPkgArgs, "PackageNameLength", sizeof(PackageNameLength), &PackageNameLength);

    return PackageNameLength;
}

PCSTR TLSAP_LOOKUP_PACKAGE_ARGS::GetPackageNameDirect(void) const
{
    static ULONG fieldOffset = 2 * sizeof(ULONG);
    static CHAR szPackageName[LSAP_MAX_PACKAGE_NAME_LENGTH + 1] = {0};


    if (!ReadMemory(m_baseOffset + fieldOffset, szPackageName, GetPackageNameLengthDirect(), NULL)) {

       DBG_LOG(LSA_ERROR, ("Unable to read PackageName for LSAP_LOOKUP_PACKAGE_ARGS at %#I64x\n", m_baseOffset));

       throw "TLSAP_LOOKUP_PACKAGE_ARGS::GetPackageNameDirect failed";
    }

    return szPackageName;
}

PCSTR TLSAP_LOOKUP_PACKAGE_ARGS::GetPackageName(void) const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrLkpPkgArgs, "PackageName");
    static CHAR szPackageName[LSAP_MAX_PACKAGE_NAME_LENGTH + 1] = {0};


    if (!ReadMemory(m_baseOffset + fieldOffset, szPackageName, GetPackageNameLength(), NULL)) {

       throw "Read LookupPackageArgs PackageName failed";
    }

    return szPackageName;
}

ULONG64 TLSAP_LOOKUP_PACKAGE_ARGS::GetLookupPackageArgsBase(void) const
{
    return m_baseOffset;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TLSAP_LOOKUP_PACKAGE_ARGS::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TLSAP_LOOKUP_PACKAGE_ARGS::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsasa.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasa.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasa.hxx"

TSID_AND_ATTRIBUTES::TSID_AND_ATTRIBUTES(void) : m_hr(E_FAIL)
{
}

TSID_AND_ATTRIBUTES::TSID_AND_ATTRIBUTES(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSID_AND_ATTRIBUTES::~TSID_AND_ATTRIBUTES(void)
{
}

HRESULT TSID_AND_ATTRIBUTES::IsValid(void) const
{
    return m_hr;
}

ULONG TSID_AND_ATTRIBUTES::GetcbSID_AND_ATTRIBUTESInArray(void)
{
    static ULONG  cbSA = ReadTypeSize("nt!_SID_AND_ATTRIBUTES[1]");
    static ULONG cbSA2 = ReadTypeSize("nt!_SID_AND_ATTRIBUTES[2]");

    return cbSA2 - cbSA;
}

ULONG TSID_AND_ATTRIBUTES::GetcbSID_AND_ATTRIBUTESInArrayDirect(void)
{
    static ULONG cbSize = max(ReadPtrSize() + sizeof(ULONG), 2 * ReadPtrSize());

    return cbSize;
}

ULONG64 TSID_AND_ATTRIBUTES::GetSidAddrDirect(void) const
{
    return m_baseOffset;
}

ULONG64 TSID_AND_ATTRIBUTES::GetSidAddr(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrSA, "Sid");
}

ULONG TSID_AND_ATTRIBUTES::GetAttributes(void) const
{
    ULONG value = 0;

    ReadStructField(m_baseOffset, kstrSA, "Attributes", sizeof(value), &value);

    return value;
}

ULONG TSID_AND_ATTRIBUTES::GetAttributesDirect(void) const
{
    ULONG value = 0;

    if (!ReadMemory(m_baseOffset + ReadPtrSize(), &value, sizeof(value), NULL)) {

        DBG_LOG(LSA_ERROR, ("unable to read Attributes for SID_AND_ATTRIBUTES at %#I64x\n", m_baseOffset));

        throw "TSID_AND_ATTRIBUTES::GetAttributesDirect failed";
    }

    return value;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSID_AND_ATTRIBUTES::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSID_AND_ATTRIBUTES::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsasecbfr.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasecbfr.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasecbfr.hxx"
#include <stdio.h>
#include <string.h>

#define SECBUFFER_ATTRMASK                  0xF0000000
#define SECBUFFER_READONLY                  0x80000000  // Buffer is read-only
#define SECBUFFER_RESERVED                  0x40000000
#define SECBUFFER_READONLY_WITH_CHECKSUM    0x10000000  // Buffer is read-only, and checksummed
#define SECBUFFER_UNMAPPED                  0x40000000

//
// This flag is used to indicate that the buffer was mapped into the LSA
// from kernel mode.
//

#define SECBUFFER_KERNEL_MAP                0x20000000

#if 0

#define SECBUFFER_EMPTY                 0   // Undefined, replaced by provider
#define SECBUFFER_DATA                  1   // Packet data
#define SECBUFFER_TOKEN                 2   // Security token
#define SECBUFFER_PKG_PARAMS            3   // Package specific parameters
#define SECBUFFER_MISSING               4   // Missing Data indicator
#define SECBUFFER_EXTRA                 5   // Extra data
#define SECBUFFER_STREAM_TRAILER        6   // Security Trailer
#define SECBUFFER_STREAM_HEADER         7   // Security Header
#define SECBUFFER_NEGOTIATION_INFO      8   // Hints from the negotiation pkg
#define SECBUFFER_PADDING               9   // non-data padding
#define SECBUFFER_STREAM               10   // whole encrypted message
#define SECBUFFER_MECHLIST             11  
#define SECBUFFER_MECHLIST_SIGNATURE   12 
#define SECBUFFER_TARGET               13
#define SECBUFFER_CHANNEL_BINDINGS     14

#endif

PCSTR TSecBuffer::GetSecBufferTypeStr(IN ULONG type)
{
    static PCSTR aszSecBufferTypes[] = {
        "Empty", "Data", "Token", "Package", "Missing",
        "Extra", "Trailer", "Header", "NegoInfo", "Padding", 
        "Stream", "MechList", "MechListSignature", "Target", 
        "ChannelBinding"};

    type &= ~SECBUFFER_ATTRMASK;

    return (type < COUNTOF(aszSecBufferTypes)) ?
           aszSecBufferTypes[type] : kstrInvalid;
}

void ShowSecBufferAttrs(IN PCSTR pszPad, IN ULONG cbBuf, IN CHAR* pBuf, IN ULONG ulFlags)
{
    LONG cbUsed = 0;

#define BRANCH_AND_PRINT(x)                                  \
    do {                                                     \
        if (ulFlags & SECBUFFER_##x) {                       \
            cbUsed = _snprintf(pBuf, cbBuf, "%s ", #x);      \
            if (cbUsed <= 0) return;                         \
            cbBuf -= cbUsed;                                 \
            pBuf += cbUsed;                                  \
            ulFlags &= ~ SECBUFFER_##x;                      \
        }                                                    \
    } while(0)                                               \

    cbUsed = _snprintf(pBuf, cbBuf, "%s%#x : ", pszPad, (ulFlags >> 28) & 0xF);
    if (cbUsed <= 0) return;  
    cbBuf -= cbUsed;
    pBuf += cbUsed;

    BRANCH_AND_PRINT(READONLY);
    BRANCH_AND_PRINT(READONLY_WITH_CHECKSUM);
    BRANCH_AND_PRINT(UNMAPPED);
    BRANCH_AND_PRINT(KERNEL_MAP);

    if (ulFlags & SECBUFFER_ATTRMASK)
    {
        cbUsed = _snprintf(pBuf, cbBuf, "%#x", (ulFlags >> 28) & 0xF);
        if (cbUsed <= 0) return;  
        cbBuf -= cbUsed;
        pBuf += cbUsed;

    }

    cbUsed = _snprintf(pBuf, cbBuf, "\n");
    if (cbUsed <= 0) return;  
    cbBuf -= cbUsed;
    pBuf += cbUsed;

#undef BRANCH_AND_PRINT
}

ULONG TSecBuffer::GetcbSecBufferSizeInArray(void)
{
    //
    // To get the size of one element we do as follows in case there is
    // padding after each elements
    //

    static ULONG cbSecBufferTypeSize = ReadTypeSize(kstrSecBuffer);
    static ULONG cbTwoSecBufferTypeSize = ReadTypeSize("_SecBuffer[2]");
    return cbTwoSecBufferTypeSize - cbSecBufferTypeSize;
}

ULONG TSecBuffer::GetcbSecBufferSizeInArrayDirect(void)
{
    static ULONG cbSecBuffer = 2 * sizeof(ULONG) + ReadPtrSize();

    return cbSecBuffer;
}

TSecBuffer::TSecBuffer(void) : m_hr(E_FAIL)
{
}

TSecBuffer::TSecBuffer(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSecBuffer::~TSecBuffer(void)
{
}

HRESULT TSecBuffer::IsValid(void) const
{
    return m_hr;
}

ULONG TSecBuffer::GetcbBuffer(void) const
{
    ULONG cbBuffer = 0;

    ReadStructField(m_baseOffset, kstrSecBuffer, "cbBuffer", sizeof(cbBuffer), &cbBuffer);

    return cbBuffer;
}

ULONG TSecBuffer::GetcbBufferDirect(void) const
{
    ULONG cbBuffer = 0;

    if (!ReadMemory(m_baseOffset, &cbBuffer, sizeof(cbBuffer), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read SecBuffer %#I64x cbBuffer\n", m_baseOffset));

        throw "TSecBuffer::GetcbBufferDirect failed";
    }

    return cbBuffer;
}

ULONG TSecBuffer::GetBufferType(void) const
{
    ULONG BufferType = 0;

    ReadStructField(m_baseOffset, kstrSecBuffer, "BufferType", sizeof(BufferType), &BufferType);

    return BufferType;
}

ULONG TSecBuffer::GetBufferTypeDirect(void) const
{
    ULONG BufferType = 0;

    if (!ReadMemory(m_baseOffset + sizeof(ULONG), &BufferType, sizeof(BufferType), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read BufferType for SecBuffer at %#I64x\n", m_baseOffset));

        throw "TSecBuffer::GetBufferTypeDirect failed";
    }

    return BufferType;
}

ULONG64 TSecBuffer::GetpvBuffer(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrSecBuffer, "pvBuffer");
}

ULONG64 TSecBuffer::GetpvBufferDirect(void) const
{
    DBG_LOG(LSA_LOG, ("TSecBuffer::GetpvBufferDirect reading _SecBuffer %#I64x pvBuffer\n", m_baseOffset));

    return toPtr(ReadPtrVar(ForwardAdjustPtrAddr(m_baseOffset + 2 * sizeof(ULONG))));
}

PCSTR TSecBuffer::toStr(IN PCSTR pszBanner) const
{
    static CHAR szBuffer[256] = {0};
    LONG cbUsed = 0;

    ULONG type = GetBufferType();
    ULONG dwAttrMask = type & SECBUFFER_ATTRMASK;

    ExitIfControlC();

    szBuffer[RTL_NUMBER_OF(szBuffer) - 1] = '\0';

    if ((cbUsed = _snprintf(szBuffer, RTL_NUMBER_OF(szBuffer) - 1,
                        "%s%s %#x bytes, pvBuffer %s, attr ",
                        pszBanner ? pszBanner : "",
                        GetSecBufferTypeStr(type),
                        GetcbBuffer(),
                        PtrToStr(GetpvBuffer()))) <= 0) {

        DBG_LOG(LSA_ERROR, ("Unable to print _SecBuffer %#I64x\n", m_baseOffset));

        throw "TSecBuffer::toStr failed";
    }

    ShowSecBufferAttrs(kstrEmptyA, RTL_NUMBER_OF(szBuffer) - cbUsed, szBuffer + cbUsed, dwAttrMask );

    return szBuffer;
}

PCSTR TSecBuffer::toStrDirect(IN PCSTR pszBanner) const
{
    static CHAR szBuffer[256] = {0};
    LONG cbUsed;

    ULONG type = GetBufferTypeDirect();
    ULONG dwAttrMask = type & SECBUFFER_ATTRMASK;

    ExitIfControlC();

    szBuffer[RTL_NUMBER_OF(szBuffer) - 1] = '\0';

    if ((cbUsed = _snprintf(szBuffer, RTL_NUMBER_OF(szBuffer) - 1,
                        "%s%s %#x bytes, pvBuffer %s, attr ",
                        pszBanner ? pszBanner : "",
                        GetSecBufferTypeStr(type),
                        GetcbBufferDirect(),
                        PtrToStr(GetpvBufferDirect()))) <= 0) {

        DBG_LOG(LSA_ERROR, ("Unable to print _SecBuffer %#I64x\n", m_baseOffset));

        throw "TSecBuffer::toStrDirect failed";
    }

    ShowSecBufferAttrs(kstrEmptyA, RTL_NUMBER_OF(szBuffer) - cbUsed, szBuffer + cbUsed, dwAttrMask );

    return szBuffer;
}

void TSecBuffer::ShowDirect(IN PCSTR pszBanner, IN BOOL bVerbose) const
{
    ULONG type = GetBufferTypeDirect();
    ULONG dwAttrMask = type & SECBUFFER_ATTRMASK;

    ULONG cbBuffer = 0;
    ULONG64 addrBuffer = 0;
    CHAR* pBuffer = NULL;
    CHAR szBuffer[256] = {0};

    ExitIfControlC();

    cbBuffer = GetcbBufferDirect();
    addrBuffer = GetpvBufferDirect();

    dprintf("%s%s %#x bytes, pvBuffer %s, attr ",
        pszBanner ? pszBanner : "",
        GetSecBufferTypeStr(type),
        cbBuffer,
        PtrToStr(addrBuffer));
    ShowSecBufferAttrs(kstrEmptyA, RTL_NUMBER_OF(szBuffer), szBuffer, dwAttrMask );
    dprintf("%s", szBuffer);

    //
    // Now print out the content of security buffers
    //

    if (bVerbose && addrBuffer) {

        pBuffer = new char[cbBuffer];

        if (!pBuffer) {

            throw "TSecBuffer::ShowDirect out of memory";
        }

        if (ReadMemory(addrBuffer, pBuffer, cbBuffer, NULL)) {

            debugPrintHex(pBuffer, cbBuffer);

        } else {

            DBG_LOG(LSA_ERROR, ("Unable to print SecBuffer::pvBuffer at %#I64x\n", toPtr(addrBuffer)));

            delete[] pBuffer;

            throw "TSecBuffer::ShowDirect read memory error";
        }
    }

    delete[] pBuffer;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSecBuffer::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSecBuffer::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsasht.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasht.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasht.hxx"
#include <stdio.h>
#include <string.h>

TSHT::TSHT(void) : m_hr(E_FAIL)
{
}

TSHT::TSHT(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSHT::~TSHT(void)
{
}

HRESULT TSHT::IsValid(void) const
{
    return m_hr;
}

ULONG TSHT::GetFlags(void) const
{
    ULONG Flags = 0;

    ReadStructField(m_baseOffset, kstrSHT, "Flags", sizeof(Flags), &Flags);

    return Flags;
}

ULONG TSHT::GetCount(void) const
{
    ULONG Count = 0;

    ReadStructField(m_baseOffset, kstrSHT, "Count", sizeof(Count), &Count);

    return Count;
}

ULONG64 TSHT::GetPendingHandle(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrSHT, "PendingHandle");
}

ULONG64 TSHT::GetListFlink(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrSHT, kstrListFlink);
}

ULONG64 TSHT::GetHandleListAnchor(void) const
{
    return m_baseOffset + ReadFieldOffset(kstrSHT, "List");
}

ULONG64 TSHT::GetDeleteCallback(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrLHT, "DeleteCallback");
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSHT::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSHT::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsalpc.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsalpc.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsalpc.hxx"

TSPM_LPC_MESSAGE::TSPM_LPC_MESSAGE(void) : m_hr(E_FAIL)
{
}

TSPM_LPC_MESSAGE::TSPM_LPC_MESSAGE(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSPM_LPC_MESSAGE::~TSPM_LPC_MESSAGE(void)
{
}

HRESULT TSPM_LPC_MESSAGE::IsValid(void) const
{
    return m_hr;
}

ULONG64 TSPM_LPC_MESSAGE::GetLpcMsgBase(void) const
{
    return m_baseOffset;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSPM_LPC_MESSAGE::Initialize(void)
{
    HRESULT hRetval = E_FAIL;
    ULONG fieldOffset = 0;

    hRetval = NO_ERROR == GetFieldOffset(kstrSpmLpcMsg, "ApiMessage", &fieldOffset) ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) {

        hRetval = TSPM_API_MESSAGE::Initialize(m_baseOffset + fieldOffset);
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = NO_ERROR == GetFieldOffset(kstrSpmLpcMsg, "pmMessage", &fieldOffset) ? S_OK : E_FAIL;
    }

    if (SUCCEEDED(hRetval)) {

        hRetval = TPORT_MESSAGE::Initialize(m_baseOffset + fieldOffset);
    }

    return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaport.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaport.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaport.hxx"

TPORT_MESSAGE::TPORT_MESSAGE(void) : m_hr(E_FAIL)
{
}

TPORT_MESSAGE::TPORT_MESSAGE(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TPORT_MESSAGE::~TPORT_MESSAGE(void)
{
}

HRESULT TPORT_MESSAGE::IsValid(void) const
{
    return m_hr;
}

ULONG TPORT_MESSAGE::GetMessageId(void) const
{
    ULONG MessageId = 0;

    ReadStructField(m_baseOffset, kstrPrtMsg, "MessageId", sizeof(MessageId), &MessageId);

    return MessageId;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TPORT_MESSAGE::Initialize(void)
{
    HRESULT hRetval = E_FAIL;
    ULONG fieldOffset = 0;

    hRetval = NO_ERROR == GetFieldOffset(kstrPrtMsg, "ClientId", &fieldOffset) ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) {

        hRetval = TCLIENT_ID::Initialize(m_baseOffset + fieldOffset);
    }

    return hRetval;
}

HRESULT TPORT_MESSAGE::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsasid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasid.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasid.hxx"
#include <stdio.h>
#include <string.h>

TSID::TSID(void) : m_hr(E_FAIL)
{
}

TSID::TSID(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSID::~TSID(void)
{
}

HRESULT TSID::IsValid(void) const
{
    return m_hr;
}

BOOLEAN TSID::IsSidValid(void) const
{
    SID sid = {0};

    if (!ReadMemory(m_baseOffset, &sid, sizeof(sid), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read SID at %#I64x\n", m_baseOffset));

        throw "TSID::IsSidValid failed";
    }

    return RtlValidSid(&sid);
}

UCHAR TSID::GetSubAuthorityCount(void) const
{
    UCHAR value = 0;

    ReadStructField(m_baseOffset, kstrSid, "SubAuthorityCount", sizeof(value), &value);

    return value;
}

UCHAR TSID::GetSubAuthorityCountDirect(void) const
{
    UCHAR value = 0;

    DBG_LOG(LSA_LOG, ("Read _SID %#I64x SubAuthorityCount\n", m_baseOffset));

    if (!ReadMemory(m_baseOffset + sizeof(UCHAR), &value, sizeof(value), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable read SID::SubAuthorityCount from %#I64x\n", m_baseOffset));

        throw "TSID::GetSubAuthorityCountDirect failed";
    }

    return value;
}

ULONG TSID::GetSize(void) const
{
    return RtlLengthRequiredSid(GetSubAuthorityCount());
}

ULONG TSID::GetSizeDirect(void) const
{
    return RtlLengthRequiredSid(GetSubAuthorityCountDirect());
}

PCSTR TSID::toStr(void) const
{
    return toStr(kstrSidFmt);
}

PCSTR TSID::toStr(IN PCSTR pszFmt) const
{
    return InternalToStr(GetSize(), pszFmt);
}

PCSTR TSID::toStrDirect(void) const
{
    return toStrDirect(kstrSidFmt);
}

PCSTR TSID::toStrDirect(IN PCSTR pszFmt) const
{
    return InternalToStr(GetSizeDirect(), pszFmt);
}

PCSTR TSID::GetFriendlyNameDirect(IN PCSTR pszFmt) const
{
    return InternalGetFriendlyName(GetSizeDirect(), pszFmt);
}

PCSTR TSID::ConvertSidToFriendlyName(IN PSID pSid, IN PCSTR pszFmt)
{
    return ConvertSidToFriendlyName(reinterpret_cast<SID*>(pSid), pszFmt);
}

PCSTR TSID::ConvertSidToFriendlyName(IN SID* pSid, IN PCSTR pszFmt)
{
    HRESULT hRetval = E_FAIL;

    static CHAR szSid[MAX_PATH] = {0};

    CHAR szName[MAX_PATH] = {0};
    CHAR szDomainName[MAX_PATH] = {0};
    SID_NAME_USE eUse = SidTypeInvalid;
    DWORD cbName = sizeof(szName) - 1;
    DWORD cbDomainName = sizeof(szDomainName) - 1;

    ExitIfControlC();

    //
    // null terminates szSid
    //
    szSid[0] = 0;

    hRetval = LsaLookupAccountSidA(NULL, pSid,
                    szName, &cbName,
                    szDomainName, &cbDomainName,
                    &eUse) ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval)) {

        hRetval = _snprintf(szSid, sizeof(szSid) -1, pszFmt, GetSidTypeStr(eUse), *szDomainName ? szDomainName : "localhost", szName) >= 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    if (FAILED(hRetval) && (ERROR_NONE_MAPPED != HRESULT_CODE(hRetval))) {

        DBG_LOG(LSA_ERROR, ("ConvertSidToFriendlyName LsaLookupAccountSidA failed with error code %#x\n", HRESULT_CODE(hRetval)));

        throw "LsaLookupAccountSid failed";
    }

    //
    // Indicate none mapped if so
    //
    if (!*szSid) {

        _snprintf(szSid, sizeof(szSid) - 1, "(no name mapped)");
    }

    return szSid;
}

PCSTR TSID::GetSidTypeStr(IN SID_NAME_USE eUse)
{
    static PCSTR acszSidTypeStr[] = {
        kstrInvalid, "User", "Group", "Domain", "Alias", "Well Known Group",
        "Deleted Account", kstrInvalid, "Unknown", "Computer",
    };

    if (eUse < SidTypeUser || eUse > SidTypeComputer) {
        throw "Unrecognized SID";
    }

    return acszSidTypeStr[eUse];
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSID::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSID::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}

PCSTR TSID::InternalToStr(IN ULONG cbSid, IN PCSTR pszFmt) const
{
    static CHAR szBuffer[SID_MAX_SUB_AUTHORITIES * sizeof(ULONG) + kSidHeaderLen];

    UNICODE_STRING  ucsSid = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    ExitIfControlC();

    if (!IsSidValid()) {

       DBG_LOG(LSA_ERROR, ("_SID %#I64x is invlaid\n", toPtr(m_baseOffset)));

       throw "Invalid SID";
    }

    if (cbSid > sizeof(szBuffer))  {

        DBG_LOG(LSA_ERROR, ("Insufficient buffer in TSID::InternalToStr, _SID %#I64x maybe invalid, SubAuthCount is %d\n", m_baseOffset, (cbSid - sizeof(SID)) / sizeof(ULONG) + 1));

        throw "Insufficient buffer";
    }

    if (!ReadMemory(m_baseOffset, szBuffer, cbSid, NULL)) {

         DBG_LOG(LSA_ERROR, ("Unable to read SID from location %#I64x\n", toPtr(m_baseOffset)));

         throw "Unable to read SID";
    }

    NtStatus = RtlConvertSidToUnicodeString(&ucsSid, reinterpret_cast<SID*>(szBuffer), TRUE);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = _snprintf(szBuffer, sizeof(szBuffer) - 1, pszFmt, &ucsSid) >= 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(NtStatus)) {

        DBG_LOG(LSA_ERROR, ("Unable to convert SID at address %#I64x to string\n", toPtr(m_baseOffset)));

        throw "TSID::InternalToStr failed";
    }

    RtlFreeUnicodeString(&ucsSid);

    return szBuffer;
}

PCSTR TSID::InternalGetFriendlyName(IN ULONG cbSid, IN PCSTR pszFmt) const
{
    static CHAR szBuffer[SID_MAX_SUB_AUTHORITIES * sizeof(ULONG) + kSidHeaderLen] = {0};

    ExitIfControlC();

    if (!IsSidValid()) {

       DBG_LOG(LSA_ERROR, ("_SID %#I64x is invlaid\n", toPtr(m_baseOffset)));

       throw "Invalid SID";
    }

    if (cbSid > sizeof(szBuffer)) {

        DBG_LOG(LSA_ERROR, ("Insufficient buffer in TSID::GetFriendlyName, _SID %#I64x maybe invalid, SubAuthCount is %d\n", m_baseOffset, (cbSid - sizeof(SID)) / sizeof(ULONG) + 1));

        throw "Insufficient buffer";
    }

    if (!ReadMemory(m_baseOffset, szBuffer, cbSid, NULL)) {

         DBG_LOG(LSA_ERROR, ("Unable to read SID from location %#I64x\n", toPtr(m_baseOffset)));

         throw "Unable to read SID";
    }

    return ConvertSidToFriendlyName(reinterpret_cast<SID*>(szBuffer), pszFmt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsasecbfrd.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsasecbfrd.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsasecbfrd.hxx"
#include <stdio.h>
#include <string.h>

#define SECBUFFER_TOKEN   2   // Security token

TSecBufferDesc::TSecBufferDesc(void) : m_hr(E_FAIL)
{
}

TSecBufferDesc::TSecBufferDesc(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSecBufferDesc::~TSecBufferDesc(void)
{
}

HRESULT TSecBufferDesc::IsValid(void) const
{
    return m_hr;
}

ULONG TSecBufferDesc::GetcBuffersDirect(void) const
{
    ULONG cbBuffers = 0;

    if (!ReadMemory(m_baseOffset + sizeof(ULONG), &cbBuffers, sizeof(cbBuffers), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read cBuffers for SecBufferDesc at %#I64x\n", m_baseOffset));

        throw "TSecBufferDesc::GetcBuffersDirect failed";
    }

    return cbBuffers;
}

ULONG TSecBufferDesc::GetulVersionDirect(void) const
{
    ULONG ulVersion = 0;

    if (!ReadMemory(m_baseOffset, &ulVersion, sizeof(ulVersion), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable to read ulVersion for SecBufferDesc at %#I64x\n", m_baseOffset));

        throw "TSecBuffer::GetulVersionDirect failed";
    }

    return ulVersion;
}

ULONG64 TSecBufferDesc::GetpBuffersDirect(void) const
{
    DBG_LOG(LSA_LOG, ("TSecBufferDesc::GetpBuffersDirect reading _SecBuffer::pBuffers from %#I64x\n", m_baseOffset));

    return toPtr(ReadPtrVar(ForwardAdjustPtrAddr(m_baseOffset + 2 * sizeof(ULONG))));
}

ULONG64 TSecBufferDesc::GetTokenAddrDirect(OUT ULONG* pcbBuffer OPTIONAL) const
{
    ULONG64 addr = 0;
    ULONG cbSecBufferInArray = TSecBuffer::GetcbSecBufferSizeInArrayDirect();
    ULONG cBuffers = GetcBuffersDirect();
    ULONG64 addrBuffers = GetpBuffersDirect();

    if (pcbBuffer) {
       *pcbBuffer = 0;
    }

    for (ULONG i = 0; i < min(cBuffers, 16); i++) {
        TSecBuffer sb(addrBuffers + i * cbSecBufferInArray);
        ULONG type = sb.GetBufferTypeDirect();

        if (type & SECBUFFER_TOKEN) {
            addr = sb.GetpvBufferDirect();
            if (pcbBuffer) {
                *pcbBuffer = sb.GetcbBufferDirect();
            }
            break;
        }
    }

    //
    // return NULL if no token buffer is found
    //
    return addr;
}

void TSecBufferDesc::ShowDirect(IN BOOL bVerbose) const
{
    ULONG64 addrpBuffers = 0;
    ULONG64 addrBuffers = 0;
    ULONG cBuffers = 0;
    ULONG cbSecBufferInArray = 0;
    CHAR szBanner[MAX_PATH] = {0};

    ExitIfControlC();

    cBuffers = GetcBuffersDirect();

    cbSecBufferInArray = TSecBuffer::GetcbSecBufferSizeInArrayDirect();

    dprintf("ulVersion     \t%d\n", GetulVersionDirect());

    addrpBuffers = ForwardAdjustPtrAddr(m_baseOffset + 2 * sizeof(ULONG));

    DBG_LOG(LSA_LOG, ("TSecBufferDesc::ShowDirect reading _SecBufferDesc::pBuffers from %#I64x\n", addrpBuffers));

    addrBuffers = ReadPtrVar(addrpBuffers);

    dprintf("pBuffers      \t%#I64x\n", addrBuffers);

    dprintf("cBuffers      \t%x\n", cBuffers);

    //
    // Display not more than 16 SecBuffer at a time
    //
    for (ULONG i = 0; i < min(cBuffers, 16); i++) {

        _snprintf(szBanner, sizeof(szBanner) - 1, "%s%d) %s %#I64x: ", kstr4Spaces, i, kstrSecBuffer, addrBuffers + i * cbSecBufferInArray);

        TSecBuffer(addrBuffers + i * cbSecBufferInArray).ShowDirect(szBanner, bVerbose);
    }

    if (cBuffers > 16) {
        dprintf(kstrSbdWrn);
    }
}

PCSTR TSecBufferDesc::toStrDirect(void) const
{
    HRESULT hRetval = E_FAIL;

    static CHAR szBuffer[1024] = {0};

    PSTR pszBuffer = szBuffer;
    ULONG cbBuffer = sizeof(szBuffer) - 1;
    LONG cStored = 0;
    CHAR szBanner[MAX_PATH] = {0};

    ULONG64 addrpBuffers = 0;
    ULONG64 addrBuffers = 0;

    ULONG cbSecBufferInArray = 0;

    ExitIfControlC();

    ULONG cBuffers = GetcBuffersDirect();

    cbSecBufferInArray = TSecBuffer::GetcbSecBufferSizeInArrayDirect();

    if (SUCCEEDED(hRetval)) {

        addrpBuffers = ForwardAdjustPtrAddr(m_baseOffset + 2 * sizeof(ULONG));

        DBG_LOG(LSA_LOG, ("TSecBufferDesc::toStrDirect reading _SecBufferDesc::pBuffers from %#I64x\n", addrpBuffers));

        addrBuffers = ReadPtrVar(addrpBuffers);

        cStored = _snprintf(pszBuffer, cbBuffer,
                            "ulVersion     \t%d\n"
                            "pBuffers      \t%#I64x\n"
                            "cBuffers      \t%x\n",
                            GetulVersionDirect(),
                            addrBuffers,
                            cBuffers);
        hRetval =  cStored >= 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Display not more than 16 SecBuffer at a time
    //
    for (ULONG i = 0; SUCCEEDED(hRetval) && (i < min(cBuffers, 16)); i++) {

        cbBuffer -= cStored;
        pszBuffer += cStored;

        _snprintf(szBanner, sizeof(szBanner) - 1, "%s%d) %s %#I64x: ", kstr4Spaces, i, kstrSecBuffer, addrBuffers + i * cbSecBufferInArray);

        cStored = _snprintf(pszBuffer, cbBuffer, "%s", EasyStr(TSecBuffer(addrBuffers + i * cbSecBufferInArray).toStrDirect(szBanner)));
        hRetval =  cStored >= 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    if (SUCCEEDED(hRetval) && (cBuffers > 16)) {
        dprintf(kstrSbdWrn);
    }

    if (FAILED(hRetval)) {

        DBG_LOG(LSA_ERROR, ("TSecBuffer::toStrDirect _SecBufferDesc %#I64x failed with error code %#x\n", m_baseOffset, hRetval));

        throw "TSecBuffer::toStrDirect failed";
    }

    return szBuffer;
}


/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSecBufferDesc::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSecBufferDesc::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaspmapi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaspmapi.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaspmapi.hxx"

TSPM_API::TSPM_API(void) : m_hr(E_FAIL)
{
}

TSPM_API::TSPM_API(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSPM_API::~TSPM_API(void)
{
}

HRESULT TSPM_API::IsValid(void) const
{
    return m_hr;
}

ULONG64 TSPM_API::GetGetBinding(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetInitContext(void) const
{
    return m_baseOffset;
}

TSecBuffer TSPM_API::GetSecBufferInitSbData(IN ULONG index) const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrSpmNtCntxt, kstrSbData);
    static ULONG cbSecBufferSize = TSecBuffer::GetcbSecBufferSizeInArray();

    return TSecBuffer(m_baseOffset + fieldOffset + index * cbSecBufferSize);
}

TSecBuffer TSPM_API::GetSecBufferInitContextData(void) const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrSpmNtCntxt, kstrCtxtData);

    return TSecBuffer(m_baseOffset + fieldOffset);
}

ULONG64 TSPM_API::GetAcceptContext(void) const
{
    return m_baseOffset;
}

TSecBuffer TSPM_API::GetSecBufferAcceptContextData(void) const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrSpmCptCntxt, kstrCtxtData);

    return TSecBuffer(m_baseOffset + fieldOffset);
}

TSecBuffer TSPM_API::GetSecBufferAcceptsbData(IN ULONG index) const
{
    static ULONG fieldOffset = ReadFieldOffset(kstrSpmCptCntxt, kstrSbData);
    static ULONG cbSecBufferSize = TSecBuffer::GetcbSecBufferSizeInArray();

    return TSecBuffer(m_baseOffset + fieldOffset + index * cbSecBufferSize);
}

ULONG64 TSPM_API::GetAcquireCreds(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetFreeCredHandle(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetDeleteContext(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetQueryCredAttributes(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetQueryContextAttributes(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetQueryCredAttrBuffers(IN ULONG index) const
{
    static ULONG fieldOffset = ReadFieldOffset("_SPMQueryCredAttributesAPI", "Buffers");
    static ULONG cbPointerSize = ReadTypeSize("ULONG_PTR");

    ULONG64 value = 0;

    if (GetPtrWithVoidStar(m_baseOffset + fieldOffset + index * cbPointerSize, &value)) {

        DBG_LOG(LSA_ERROR, ("Unable to read TSPM_API %#I64x::QueryCredAttrBuffer index %d\n", m_baseOffset, index));

        throw "TSPM_API::GetQueryCredAttrBuffer failed";
    }

    return toPtr(value);
}

ULONG64 TSPM_API::GetQueryContextAttrBuffers(IN ULONG index) const
{
    static ULONG fieldOffset = ReadFieldOffset("_SPMQueryContextAttrAPI", "Buffers");
    static ULONG cbPointerSize = ReadTypeSize("ULONG_PTR");

    ULONG64 value = 0;

    if (GetPtrWithVoidStar(m_baseOffset + fieldOffset + index * cbPointerSize, &value)) {

        DBG_LOG(LSA_ERROR, ("Unable to read TSPM_API %#I64x::GetQueryContextAttrBuffer index %d\n", m_baseOffset, index));

        throw "TSPM_API::GetQueryContextAttrBuffer failed";
    }

    return toPtr(value);
}

ULONG64 TSPM_API::GetEfsGenerateKey(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetEfsGenerateDirEfs(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetEfsDecryptFek(void) const
{
    return m_baseOffset;
}

ULONG64 TSPM_API::GetCallback(void) const
{
    return m_baseOffset;
}

TSecBuffer TSPM_API::GetSecBufferCallbackInput(void) const
{
   static ULONG fieldOffset = ReadFieldOffset(kstrClBk, "Input");

   return TSecBuffer(m_baseOffset + fieldOffset);
}

TSecBuffer TSPM_API::GetSecBufferCallbackOutput(void) const
{
   static ULONG fieldOffset = ReadFieldOffset(kstrClBk, "Output");

   return TSecBuffer(m_baseOffset + fieldOffset);
}

ULONG64 TSPM_API::GetAddCredential(void) const
{
    return m_baseOffset;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSPM_API::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSPM_API::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;
    m_hr = S_OK;

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\sources.inc ===
USE_NATIVE_EH=1

SOURCES=                     \
        ..\lsautil.cxx       \
        ..\lsagbl.cxx        \
        ..\lsacstr.cxx       \
        ..\lsasecbfr.cxx     \
        ..\lsasid.cxx        \
        ..\lsasa.cxx         \
        ..\lsaclientid.cxx   \
        ..\lsaport.cxx       \
        ..\lsaspmapi.cxx     \
        ..\lsalookup.cxx     \
        ..\lsaapi.cxx        \
        ..\lsaapim.cxx       \
        ..\lsaspmlpcapi.cxx  \
        ..\lsaargs.cxx       \
        ..\lsalpc.cxx        \
        ..\lsasecbfrd.cxx    \
        ..\lsastring.cxx     \
        ..\lsasht.cxx        \
        ..\lsalht.cxx        \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsaspmlpcapi.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsaspmlpcapi.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsaspmlpcapi.hxx"

TSPMLPCAPI::TSPMLPCAPI(void) : m_hr(E_FAIL)
{
}

TSPMLPCAPI::TSPMLPCAPI(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSPMLPCAPI::~TSPMLPCAPI(void)
{
}

HRESULT TSPMLPCAPI::IsValid(void) const
{
    return m_hr;
}

USHORT TSPMLPCAPI::GetfAPI() const
{
    USHORT fAPI = 0;

    ReadStructField(m_baseOffset, kstrSpmLpcApi, "fAPI", sizeof(fAPI), &fAPI);

    return fAPI;
}

ULONG64 TSPMLPCAPI::GetContextPointer(void) const
{
    return ReadStructPtrField(m_baseOffset, kstrSpmLpcApi, "ContextPointer");
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSPMLPCAPI::Initialize(void)
{
    HRESULT hRetval = E_FAIL;
    ULONG fieldOffset = 0;

    hRetval = NO_ERROR == GetFieldOffset(kstrSpmLpcApi, "API", &fieldOffset) ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) {

        hRetval = TSPM_API::Initialize(m_baseOffset + fieldOffset);
    }

    return hRetval;
}

HRESULT TSPMLPCAPI::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\lsa.s ===
*
 * File name: lsa.s
 *
 * Author: Larry Zhu (LZhu)  May 1, 2001
 *
 * How to use: type "$<\\foo\bar\ntlm.s" in kd/ntsd/windbg
 *
 * Remarks: For IA64 targets, the following syntax should be used.
 *
 *     bp LSASRV!DispatchAPI "!DumpLpcMessage (poi @bsp);g"
 *
 *   or
 *
 *     bp LSASRV!DispatchAPI "!DumpLpcMessage @r32;g"
 *
 bp LSASRV!DispatchAPI "!DumpLpcMessage (poi (@esp+4));g"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\lsaexts.s ===
*
* File name: lsaexts.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
* 
bp LSASRV!DispatchAPI "!spmlpc (poi (@esp+4));g"
bp msv1_0!SsprHandleChallengeMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
bp msv1_0!SsprHandleNegotiateMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
bp msv1_0!SsprHandleAuthenticateMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsautil.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    lsautil.cxx

Abstract:

    Lsa Utility functions

Author:

    Larry Zhu (Lzhu)  May 1, 2001

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

namespace LSA_NS {

/*++

Title:

    StripPathFromFileName

Routine Description:

    Function used stip the path component from a fully
    qualified file name.

Arguments:

    pszFile - pointer to full file name.

Return Value:

    Pointer to start of file name in path.

--*/
LPCTSTR
StripPathFromFileName(
    IN LPCTSTR pszFile
    )
{
    LPCTSTR pszFileName;

    if (pszFile)
    {
        pszFileName = _tcsrchr( pszFile, _T('\\') );

        if (pszFileName)
        {
            pszFileName++;
        }
        else
        {
            pszFileName = pszFile;
        }
    }
    else
    {
        pszFileName = kstrEmpty;
    }

    return pszFileName;
}

/////////////////////////////////////////////////////////////////////
ULONG
GetStructFieldVerbose(
    IN ULONG64 addrStructBase,
    IN PCSTR pszStructTypeName,
    IN PCSTR pszStructFieldName,
    IN ULONG BufferSize,
    OUT PVOID Buffer)
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset
    //
    ErrorCode = GetFieldOffset(pszStructTypeName, pszStructFieldName, &FieldOffset );

    if (ErrorCode == NO_ERROR) {

        //
        // Read the data
        //
        Success = ReadMemory(addrStructBase + FieldOffset, Buffer, BufferSize, NULL);

        if (Success != TRUE) {

            DBG_LOG(LSA_ERROR, ("Cannot read structure field value at 0x%p, error %u\n", addrStructBase + FieldOffset, ErrorCode));

            return MEMORY_READ_ERROR;
        }
    } else {

        DBG_LOG(LSA_ERROR, ("Cannot get field offset of %s in %s, error %u\n", EasyStr(pszStructFieldName), EasyStr(pszStructTypeName), ErrorCode));

        return ErrorCode;
    }

    return 0; // 0 on success
}

/////////////////////////////////////////////////////////////////////
ULONG
GetStructPtrFieldVerbose(
    IN ULONG64 addrStructBase,
    IN PCSTR pszStructTypeName,
    IN PCSTR pszStructFieldName,
    IN PULONG64 Buffer)
{
    ULONG FieldOffset = 0;
    ULONG ErrorCode = 0;

    //
    // Get the field offset inside the structure
    //
    ErrorCode = GetFieldOffset(pszStructTypeName, pszStructFieldName, &FieldOffset);

    if (ErrorCode == NO_ERROR) {

        //
        // Read the data
        //

        ErrorCode = GetPtrWithVoidStar(addrStructBase + FieldOffset, Buffer);

        if (ErrorCode != S_OK) {

            DBG_LOG(LSA_ERROR, ("Cannot read structure field value at 0x%p, error %u\n", addrStructBase + FieldOffset, ErrorCode));
        }
    } else {

        DBG_LOG(LSA_ERROR, ("Cannot get field offset of %s in structure %s, error %u\n", EasyStr(pszStructFieldName), EasyStr(pszStructTypeName), ErrorCode));
    }

    return ErrorCode;
}

//
// This function is stolen from !process
//

HRESULT
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    HRESULT                 hr = E_INVALIDARG;
    PDEBUG_SYSTEM_OBJECTS   DebugSystem;
    ULONG64                 hCurrentThread;

    if (phCurrentThread != NULL) *phCurrentThread = NULL;
    if (pProcessor != NULL) *pProcessor = 0;

    if (Client == NULL ||
        (hr = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                     (void **)&DebugSystem)) != S_OK)
    {
        return hr;
    }

    hr = DebugSystem->GetCurrentThreadHandle(&hCurrentThread);

    if (hr == S_OK)
    {
        if (phCurrentThread != NULL)
        {
            *phCurrentThread = (HANDLE) hCurrentThread;
        }

        if (pProcessor != NULL)
        {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }
    }

    DebugSystem->Release();

    return hr;
}

void LocalPrintGuid(IN const GUID *pGuid)
{   
    UNICODE_STRING GuidString = {0};

    NTSTATUS Status;

    if (pGuid) {

         Status = RtlStringFromGUID(*pGuid, &GuidString);

         if (NT_SUCCESS(Status)) 
         {
             dprintf("%wZ", &GuidString);
         }
         else
         {
             dprintf( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                 pGuid->Data1, pGuid->Data2, pGuid->Data3, pGuid->Data4[0],
                 pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4],
                 pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7] );
         }
    }

    if (GuidString.Buffer) 
    {
        RtlFreeUnicodeString(&GuidString);
    }
}

BOOL IsAddressInNonePAEKernelAddressSpace(IN ULONG64 addr)
{
    static BOOL bIsPtr64 = IsPtr64WithVoidStar();

    if (!bIsPtr64) {

        return  static_cast<LONG>(addr) < 0;

    } else {

        return static_cast<LONG64>(addr) < 0;
    }
}

/*++

Routine Name:

    HResultFromWin32

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    dwError   - Win32 error code

Return Value:

    An HRESULT

--*/
HRESULT HResultFromWin32(IN DWORD dwError)
{
    return HRESULT_FROM_WIN32(dwError);
}

/*++

Routine Name:

    GetLastErrorAsHResult

Routine Description:

    Returns the last error as an HRESULT assuming a failure.

Arguments:

    None

Return Value:

    An HRESULT.

--*/
HRESULT GetLastErrorAsHResult(void)
{
    return HResultFromWin32(GetLastError());
}

NTSTATUS NtStatusFromWin32(IN DWORD dwError)
{
    return (STATUS_SEVERITY_ERROR << 30) | (FACILITY_DEBUGGER << 16) | dwError;
}

NTSTATUS GetLastErrorAsNtStatus(void)
{
    return NtStatusFromWin32(GetLastError());
}

BOOLEAN IsEmpty(IN PCSTR pszArgs)
{
    if (!pszArgs) {

        return FALSE;
    }

    for (; *pszArgs; pszArgs++) {

        if (!isspace(*pszArgs)) {
            return FALSE;
        }
    }

    return TRUE;
}

void debugPrintHandle(IN HANDLE handle)
{
    ULONG64 addrHandle = reinterpret_cast<ULONG_PTR>(handle);

    dprintf("%s", PtrToStr(addrHandle));
}

void PrintMessages(
    IN PCSTR pszMsg, OPTIONAL
    IN PCSTR pszSymHint OPTIONAL
    )
{
    if (pszMsg || pszSymHint) {

        dprintf(kstrNewLine);
    }

    if (pszMsg) {

        dprintf(kstrStrLn, pszMsg);
    }

    if (pszSymHint) {

        dprintf(kstrCheckSym, pszSymHint);
    }
}

void handleLsaException(
    IN ELsaExceptionCode eExceptionCode,
    IN PCSTR pszMsg,    OPTIONAL
    IN PCSTR pszSymHint OPTIONAL
    )
{
    switch (eExceptionCode) {
    case kIncorrectSymbols:
        DBG_LOG(LSA_ERROR, ("\n%s", kstrIncorrectSymbols));
        PrintMessages(pszMsg, pszSymHint);
        break;

    case kExitOnControlC:
        DBG_LOG(LSA_LOG, (kstrStrLn, kstrExitOnControlC));
        dprintf(kstrNewLine);
        dprintf(kstrStrLn, kstrExitOnControlC);
        break;

    case kInvalid:
    default:
        DBG_LOG(LSA_ERROR, ("Invalid LSA exception code\n"));
        PrintMessages(pszMsg, pszSymHint);
        break;
    }
}

BOOL IsPtr64WithVoidStar(void)
{
    static ULONG cbPtrSize = GetTypeSize(kstrVoidStar);

    return  sizeof(ULONG64) == cbPtrSize;
}

PCSTR
ReadStructStrField(
    IN ULONG64 addrStructBase,
    IN PCSTR pszStructTypeName,
    IN PCSTR pszStructStringFieldName)
{
    ULONG fieldOffset = 0;

    fieldOffset = ReadFieldOffset(pszStructTypeName, pszStructStringFieldName);

    return TSTRING(addrStructBase + fieldOffset).toStrDirect();
}

PCWSTR
ReadStructWStrField(
    IN ULONG64 addrStructBase,
    IN PCSTR pszStructTypeName,
    IN PCSTR pszStructWStringFieldName)
{
    ULONG fieldOffset = 0;

    fieldOffset = ReadFieldOffset(pszStructTypeName, pszStructWStringFieldName);

    return TSTRING(addrStructBase + fieldOffset).toWStrDirect();
}

HRESULT ProcessKnownOptions(IN PCSTR pszArgs OPTIONAL)
{
    HRESULT hRetval = S_OK;

    for (; SUCCEEDED(hRetval) && (pszArgs && *pszArgs); pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case '?':
                hRetval = E_INVALIDARG;
                break;
            default:
                break;
            }
        }
    }

    return hRetval;
}

HRESULT ProcessHelpRequest(IN PCSTR pszArgs OPTIONAL)
{
    HRESULT hRetval = S_OK;

    for (; SUCCEEDED(hRetval) && (pszArgs && *pszArgs); pszArgs++) {

        if (*pszArgs == '-' || *pszArgs == '/') {

            switch (*++pszArgs) {
            case '?':
                hRetval = E_INVALIDARG;
                break;
            default:
                break;
            }
        }
    }

    return hRetval;
}


HRESULT GetFileNamePart(IN PCSTR pszFullPath, OUT PCSTR *ppszFileName)
{
   HRESULT hRetval = E_FAIL;
   CHAR szfname[_MAX_FNAME] = {0};

   hRetval = pszFullPath && ppszFileName ? S_OK : E_INVALIDARG;

   if (SUCCEEDED(hRetval)) {

       _splitpath(pszFullPath, NULL, NULL, szfname, NULL);
       *ppszFileName = strstr(pszFullPath, szfname);
   }

   return hRetval;
}


CHAR toChar(IN CHAR c)
{
    if (isprint(c)) {

        return c;
    }

    return '.';
}

void spaceIt(IN CHAR* buf, IN ULONG len)
{
    memset(buf, ' ', len);
}

CHAR toHex(IN ULONG c)
{
    static PCSTR pszDigits = "0123456789abcdef";
    static ULONG len = strlen(pszDigits);

    if (c <= len) { // c >= 0
        return pszDigits[c];
    }

    return '*';
}

void debugPrintHex(IN const void* buffer, IN ULONG cbBuffer)
{
    const UCHAR* p = reinterpret_cast<const UCHAR*>(buffer);
    CHAR tmp[16] = {0};
    ULONG high = 0;
    ULONG low = 0;
    CHAR line[256] = {0};
    ULONG i = 0;

    if (!cbBuffer) return;

    spaceIt(line, 72);

    for (i = 0; i < cbBuffer; i++) {
        high = p[i] / 16;
        low = p[i] % 16;

        line[3 * (i % 16)] = toHex(high);
        line[3 * (i % 16) + 1] = toHex(low);
        line [52 + (i % 16)] = toChar(p[i]);

        if (i % 16 == 7  && i != (cbBuffer - 1)) {
            line[3 * (i % 16) + 2] = '-';
        }

        if (i % 16 == 15) {

            dprintf("  %s\n", line);
            spaceIt(line, 72);
        }
    }

    dprintf("  %s\n", line);
}

typedef
BOOL
(* PFuncLookupAccountNameA)(
    IN LPCSTR lpSystemName,
    IN LPCSTR lpAccountName,
    OUT PSID Sid,
    IN OUT LPDWORD cbSid,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    );

BOOL
WINAPI
LsaLookupAccountNameA(
    IN LPCSTR lpSystemName,
    IN LPCSTR lpAccountName,
    OUT PSID Sid,
    IN OUT LPDWORD cbSid,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    )
{
    PFuncLookupAccountNameA pFuncLookupAccountNameA = NULL;
    BOOL bRetval = FALSE;

    HMODULE hLib = LoadLibrary("advapi32.dll");

    if (hLib)
    {
        pFuncLookupAccountNameA = (PFuncLookupAccountNameA) GetProcAddress(hLib, "LookupAccountNameA");

        if (pFuncLookupAccountNameA)
        {
            bRetval = pFuncLookupAccountNameA(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cbReferencedDomainName, peUse);
        }

        FreeLibrary(hLib);
    }

    return bRetval;
}

typedef
BOOL
(* PFuncLookupAccountSidA)(
    IN LPCSTR lpSystemName,
    IN PSID Sid,
    OUT LPSTR Name,
    IN OUT LPDWORD cbName,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    );

BOOL
WINAPI
LsaLookupAccountSidA(
    IN LPCSTR lpSystemName,
    IN PSID Sid,
    OUT LPSTR Name,
    IN OUT LPDWORD cbName,
    OUT LPSTR ReferencedDomainName,
    IN OUT LPDWORD cbReferencedDomainName,
    OUT PSID_NAME_USE peUse
    )
{
    PFuncLookupAccountSidA pFuncLookupAccountSidA = NULL;
    BOOL bRetval = FALSE;

    HMODULE hLib = LoadLibrary("advapi32.dll");

    if (hLib)
    {
        pFuncLookupAccountSidA = (PFuncLookupAccountSidA) GetProcAddress(hLib, "LookupAccountSidA");

        if (pFuncLookupAccountSidA)
        {
            bRetval = pFuncLookupAccountSidA(lpSystemName, Sid, Name, cbName, ReferencedDomainName, cbReferencedDomainName, peUse);
        }

        FreeLibrary(hLib);
    }

    return bRetval;

}

LARGE_INTEGER ULONG642LargeInteger(IN ULONG64 value)
{
    LARGE_INTEGER tmp = {0};

    C_ASSERT(sizeof(ULONG64) == sizeof(LARGE_INTEGER));

    memcpy(&tmp, &value, sizeof(LARGE_INTEGER));

    return tmp;
}

VOID
ShowSystemTimeAsLocalTime(
    IN PCSTR pszBanner,
    IN ULONG64 ul64Time
    )
{
    LARGE_INTEGER Time = ULONG642LargeInteger(ul64Time);
    LARGE_INTEGER LocalTime = {0};
    TIME_FIELDS TimeFields = {0};

    NTSTATUS Status = RtlSystemTimeToLocalTime(&Time, &LocalTime);

    if (!NT_SUCCESS(Status))
    {
        dprintf("Can't convert file time from GMT to Local time: 0x%lx\n", Status);
    }
    else
    {
        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        if (pszBanner) {

            dprintf("%s %ld/%ld/%ld %ld:%2.2ld:%2.2ld (L%8.8lx H%8.8lx)\n",
                pszBanner,
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        } else {
            dprintf("%ld/%ld/%ld %ld:%2.2ld:%2.2ld (L%8.8lx H%8.8lx)\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                Time.LowPart,
                Time.HighPart);
        }
    }
}

} // LSA_NS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\more.s ===
*
* File name: more.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
* 
* How to use: type "$<\\foo\bar\more.s" in kd/ntsd/windbg
*
bp msv1_0!SsprHandleChallengeMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
bp @$ra "!ntlm (poi (poi (poi OutputBuffers+8)+0*c+8)) (poi (poi (poi OutputBuffers+8)+0*c));k1;g"
* "!sbd -v (poi OutputBuffers);g"
g
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\ntlm.s ===
*
* File name: ntlm.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
* 
* How to use: type "$<\\foo\bar\ntlm.s" in kd/ntsd/windbg
*
bp msv1_0!SsprHandleChallengeMessage "!ntlm (poi InputToken) (poi InputTokenSize);$<z:\\drop\\more.s"
bp msv1_0!SsprHandleNegotiateMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
bp msv1_0!SsprHandleAuthenticateMessage "!ntlm (poi InputToken) (poi InputTokenSize);g"
bp msv1_0!MsvpPasswordValidate "k1;dd (poi Passwords) l9;g"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\lib\lsastring.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    lsastring.cxx

Abstract:

    This file provides useful accssors and mutators.

Author:

    Larry Zhu   (LZhu)             May 1, 2001  Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsastring.hxx"
#include <stdio.h>
#include <string.h>

TSTRING::TSTRING(void) : m_hr(E_FAIL)
{
}

TSTRING::TSTRING(IN ULONG64 baseOffset)
    : m_baseOffset(baseOffset), m_hr(E_FAIL)
{
    m_hr = Initialize();
}

TSTRING::~TSTRING(void)
{
}

HRESULT TSTRING::IsValid(void) const
{
    return m_hr;
}

USHORT TSTRING::GetMaximumLengthDirect(void) const
{
    USHORT MaximumLength = 0;

    if (!ReadMemory(m_baseOffset + sizeof(USHORT), &MaximumLength, sizeof(MaximumLength), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable read STRING::MaximumLength from %#I64x\n", m_baseOffset));

        throw "TSTRING::GetMaximumLengthDirect failed";
    }

    return MaximumLength;
}

USHORT TSTRING::GetLengthDirect(void) const
{
    USHORT Length = 0;

    if (!ReadMemory(m_baseOffset, &Length, sizeof(Length), NULL)) {

        DBG_LOG(LSA_ERROR, ("Unable read STRING::Length from %#I64x\n", m_baseOffset));

        throw "TSTRING::GetLengthDirect failed";
    }

    return Length;
}


PCWSTR TSTRING::toWStrDirect(void) const
{
   //
   // use cDontCare in the template function InternalToTStrDirect to instantiate "T"
   //

   WCHAR cDontCare = 0;

   PCWSTR pszWStr = InternalToTStrDirect(cDontCare);

   return !*pszWStr ? kstrNullPtrW : pszWStr;
}

PCSTR TSTRING::toStrDirect(void) const
{
   //
   // use cDontCare in the template function InternalToTStrDirect to instantiate "T"
   //

   CHAR cDontCare = 0;

   PCSTR pszStr = InternalToTStrDirect(cDontCare);

   return !*pszStr ? kstrNullPtrA : pszStr;
}

/******************************************************************************

    Private Methods

******************************************************************************/
/*++

Routine Name:

    Initialize

Routine Description:

    Do necessary initialization.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT TSTRING::Initialize(void)
{
    HRESULT hRetval = E_FAIL;

    hRetval = S_OK;

    return hRetval;
}

HRESULT TSTRING::Initialize(IN ULONG64 baseOffset)
{
    m_baseOffset = baseOffset;

    m_hr = Initialize();

    return m_hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\null.s ===
*
* File name: null.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
* 
bp LSASRV!DispatchAPI 
bp msv1_0!SsprHandleChallengeMessage
bp msv1_0!SsprHandleNegotiateMessag
bp msv1_0!SsprHandleAuthenticateMessag
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\token.s ===
*
* File name: token.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
* 
bp LSASRV!DispatchAPI "!token;g"
bp msv1_0!SsprHandleChallengeMessage "!token;g"
bp msv1_0!SsprHandleNegotiateMessage "!token;g"
bp msv1_0!SsprHandleAuthenticateMessage "!token;g"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\rc4.s ===
*
 * File name: rc4.s
 *
 * Author: Larry Zhu (LZhu)  May 1, 2001
 *
 * How to use: type "$<\\foo\bar\rc4.s" in kd/ntsd/windbg
 *
 * bp Secur32!MakeSignature "kb1;dd @esp l6;!sbd -v (poi (@esp+c));g"
 * bp Secur32!VerifySignature "kb1;dd @esp l6;!sbd -v (poi (@esp+8));g"
 *

bp SECURITY!MakeSignature "kb1;dd @esp l6;dd poi (@esp+c) l3;dd poi (poi (@esp+c)+8) lf;db poi ((poi (poi (@esp+c)+8))+8) l10;db poi ((poi (poi (@esp+c)+8))+8+c) l10;db poi ((poi (poi (@esp+c)+8))+8+c+c) l10;db poi ((poi (poi (@esp+c)+8))+8+c+c+c) l10;db poi ((poi (poi (@esp+c)+8))+8+c+c+c+c) l10;g"

bp SECURITY!VerifySignature "kb1;dd @esp l6;dd poi (@esp+8) l3;dd poi (poi (@esp+8)+8) lf;db poi ((poi (poi (@esp+8)+8))+8) l10;db poi ((poi (poi (@esp+8)+8))+8+c) l10;db poi ((poi (poi (@esp+8)+8))+8+c+c) l10;db poi ((poi (poi (@esp+8)+8))+8+c+c+c) l10;db poi ((poi (poi (@esp+8)+8))+8+c+c+c+c) l10;g"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\extsdll\test\passwd.s ===
*
* File name: passwd.s
*
* Author: Larry Zhu (LZhu)  May 1, 2001
*
bp lsasrv!DispatchAPI "!spmlpc -s;g"
bp `msv1_0!msvpaswd.c:1716`
bp msv1_0!MspLm20ChangePassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\crclient.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    crclient.c

Abstract:

    Local Security Authority - Client Cipher Routines

    These routines interface the LSA client side with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)   	December 13, 1991

Environment:

Revision History:

--*/

#include <lsaclip.h>


NTSTATUS
LsapCrClientGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_CR_CIPHER_KEY OutputSessionKey = NULL;
    ULONG OutputSessionKeyBufferLength;

    //
    // Allocate memory for the Session Key buffer and LSAP_CR_CIPHER_KEY
    // structure.
    //

    OutputSessionKeyBufferLength = sizeof (USER_SESSION_KEY);

    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputSessionKey = MIDL_user_allocate(
                           OutputSessionKeyBufferLength +
                           sizeof (LSAP_CR_CIPHER_KEY)
                           );

    if (OutputSessionKey == NULL) {

        goto ClientGetSessionKeyError;
    }

    //
    // Fill in the Cipher key structure, making the buffer point to
    // just beyond the header.
    //

    OutputSessionKey->Length = OutputSessionKeyBufferLength;
    OutputSessionKey->MaximumLength = OutputSessionKeyBufferLength;
    OutputSessionKey->Buffer = (PUCHAR) (OutputSessionKey + 1);

    Status = RtlGetUserSessionKeyClient(
                 ObjectHandle,
                 (PUSER_SESSION_KEY) OutputSessionKey->Buffer
                 );

    if (!NT_SUCCESS(Status)) {

        goto ClientGetSessionKeyError;
    }


ClientGetSessionKeyFinish:

    *SessionKey = OutputSessionKey;
    return(Status);

ClientGetSessionKeyError:

    goto ClientGetSessionKeyFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    This module contains the RPC client side routines for the credential manager.

Author:

    Cliff Van Dyke (CliffV)    January 11, 2000

Revision History:

--*/

#include "lsaclip.h"
#include "align.h"
#include "credp.h"
#include <rpcasync.h>

DWORD
CredpNtStatusToWinStatus(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    Covert an NT Status code to a windows status code.

    There a enough funky status codes to justify this routine.

Arguments:

    Status - NT Status code to convert

Return Values:

    Windows status code.

--*/

{

    //
    // Some HRESULTS should simply be returned to the caller
    //

    if ( HRESULT_FACILITY(Status) == FACILITY_SCARD ||
         HRESULT_FACILITY(Status) == FACILITY_SECURITY ) {
        return Status;
    }


    //
    // Translate all other status codes
    //
    switch ( Status ) {
    case STATUS_SUCCESS:
        return NO_ERROR;
    case STATUS_INVALID_ACCOUNT_NAME:
        return ERROR_BAD_USERNAME;
    case STATUS_INVALID_PARAMETER_1:
        return ERROR_INVALID_FLAGS;
    default:
        return RtlNtStatusToDosError( Status );
    }
}

BOOL
APIENTRY
CredpEncodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    )

/*++

Routine Description:

    This routine encodes sensitive credential data for passing via LPC to
    the LSA process.

Arguments:

    Credential - Specifies the credential to be encode.
        Encode the buffer in-place.  The caller must ensure there is extra space
        available in the buffer pointed to by Credential->CredentialBlob by allocating
        a buffer AlocatedCredBlobSize() bytes long.


Return Values:

    TRUE on success
    None

--*/

{
    NTSTATUS Status;

    //
    // If there is no credential blob,
    //  we're done.
    //

    if ( Credential->Cred.CredentialBlob == NULL ||
         Credential->Cred.CredentialBlobSize == 0 ) {

        Credential->Cred.CredentialBlob = NULL;
        Credential->Cred.CredentialBlobSize = 0;
        Credential->ClearCredentialBlobSize = 0;

    //
    // Otherwise RtlEncryptMemory it.
    //  (That's all we need since we're passing the buffer via LPC.)
    //

    } else {

        ULONG PaddingSize;

        //
        // Compute the real size of the passed in buffer
        //
        Credential->Cred.CredentialBlobSize = AllocatedCredBlobSize( Credential->ClearCredentialBlobSize );

        //
        // Clear the padding at the end to ensure we can compare encrypted blobs
        //
        PaddingSize = Credential->Cred.CredentialBlobSize -  Credential->ClearCredentialBlobSize;

        if ( PaddingSize != 0 ) {
            RtlZeroMemory( &Credential->Cred.CredentialBlob[Credential->ClearCredentialBlobSize],
                           PaddingSize );
        }

        Status = RtlEncryptMemory( Credential->Cred.CredentialBlob,
                                   Credential->Cred.CredentialBlobSize,
                                   RTL_ENCRYPT_OPTION_SAME_LOGON );

        if ( !NT_SUCCESS(Status)) {
            return FALSE;
        }


    }

    return TRUE;

}

BOOL
APIENTRY
CredpDecodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    )

/*++

Routine Description:

    This routine decodes sensitive credential data passed via LPC from
    the LSA process.

    The credential is decoded in-place.

Arguments:

    Credential - Specifies the credential to be decode.


Return Values:

    None

--*/

{
    NTSTATUS Status;

    //
    // Only decode data if it is there
    //

    if ( Credential->Cred.CredentialBlobSize != 0 ) {

        //
        // Sanity check the data
        //

        if ( Credential->Cred.CredentialBlobSize <
             Credential->ClearCredentialBlobSize ) {
            return FALSE;
        }


        //
        // Decrypt the data.
        //

        Status = RtlDecryptMemory( Credential->Cred.CredentialBlob,
                                   Credential->Cred.CredentialBlobSize,
                                   RTL_ENCRYPT_OPTION_SAME_LOGON );

        if ( !NT_SUCCESS(Status)) {
            return FALSE;
        }

        //
        // Set the used size of the buffer.
        //
        Credential->Cred.CredentialBlobSize = Credential->ClearCredentialBlobSize;

    }

    return TRUE;

}

//
// Include shared credential conversion ruotines
//

#include <crconv.c>

DWORD
CredpAllocStrFromStr(
    IN WTOA_ENUM WtoA,
    IN LPCWSTR InputString,
    IN BOOLEAN NullOk,
    OUT LPWSTR *OutString
    )

/*++

Routine Description:

    Convert a string to another format.

    Exceptions are caught.  So this routine can be used to capture user data.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InputString - Specifies the zero terminated string to convert.

    NullOk - if TRUE, a NULL string or zero length string is OK.

    OutputString - Converted zero terminated string.
        The buffer must be freed using MIDL_user_free.


Return Value:

    Status of the operation.

--*/

{
    DWORD WinStatus;
    ULONG Size;
    LPWSTR LocalString = NULL;
    LPBYTE Where;

    *OutString = NULL;

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
    try {

        //
        // Determine the size of the string buffer.
        //

        Size = CredpConvertStringSize ( WtoA, (LPWSTR)InputString );

        if ( Size == 0 ) {
            if ( NullOk ) {
                WinStatus = NO_ERROR;
            } else {
                WinStatus = ERROR_INVALID_PARAMETER;
            }
            goto Cleanup;
        }


        //
        // Allocate a buffer for the converted string
        //

        *OutString = MIDL_user_allocate( Size );

        if ( *OutString == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Covert the string
        //

        Where = (LPBYTE) *OutString;
        WinStatus = CredpConvertString ( WtoA,
                                         (LPWSTR)InputString,
                                         OutString,
                                         &Where );

Cleanup: NOTHING;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }

    //
    // Clean up
    //

    if ( WinStatus != NO_ERROR ) {
        if ( *OutString != NULL ) {
            MIDL_user_free( *OutString );
            *OutString = NULL;
        }
    }

    return WinStatus;

}



BOOL
APIENTRY
CredWriteA (
    IN PCREDENTIALA Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredWriteW.

Arguments:

    See CredWriteW.

Return Values:

    See CredWriteW.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process and convert to UNICODE
    //

    WinStatus = CredpConvertCredential ( DoAtoW,                    // Ansi to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWrite(
                            NULL,   // This API is always local.
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    MIDL_user_free( EncodedCredential );

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
CredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

    The CredWrite API is available in ANSI and UNICODE versions.

Arguments:

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        ERROR_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process.
    //

    WinStatus = CredpConvertCredential ( DoWtoW,                    // Unicode to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWrite(
                            NULL,   // This API is always local.
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    MIDL_user_free( EncodedCredential );

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredReadA (
    IN LPCSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags,
    OUT PCREDENTIALA *Credential
    )

/*++

Routine Description:

    The ANSI version of CredReadW.

Arguments:

    See CredReadW.

Return Values:

    See CredReadW.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW LocalCredential = NULL;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR) TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrRead(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags,
                            (PENCRYPTED_CREDENTIALW *)&LocalCredential );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;



    //
    // Decode the returned credential and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredential ( DoWtoA,        // Unicode to Ansi
                                             DoBlobDecode,  // Decode the credential blob
                                             LocalCredential,
                                             (PCREDENTIALW *)Credential );
    }


Cleanup:
    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }
    if ( LocalCredential != NULL ) {
        MIDL_user_free( LocalCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredReadW (
    IN LPCWSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredRead API is available in ANSI and UNICODE versions.

Arguments:

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW LocalCredential = NULL;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Capture the input args
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrRead(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags,
                            (PENCRYPTED_CREDENTIALW *)&LocalCredential );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credential and align appropriate blobs to ALIGN_WORST bounday
    //
    if ( WinStatus == NO_ERROR ) {

        WinStatus = CredpConvertCredential ( DoWtoW,        // Unicode to Unicode
                                             DoBlobDecode,  // Decode the credential blob
                                             LocalCredential,
                                             Credential );
    }


Cleanup:
    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }
    if ( LocalCredential != NULL ) {
        MIDL_user_free( LocalCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredEnumerateA (
    IN LPCSTR Filter,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALA **Credentials
    )

/*++

Routine Description:

    The ANSI version of CredEnumerateW

Arguments:

    See CredEnumerateW

Return Values:

    See CredEnumerateW

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    LPWSTR UnicodeFilter = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;


    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)Filter, TRUE, &UnicodeFilter );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrEnumerate(
                            NULL,   // This API is always local.
                            UnicodeFilter,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoA,        // Unicode to Ansi
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              (PCREDENTIALW **)Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeFilter != NULL ) {
        MIDL_user_free( UnicodeFilter );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredEnumerate API is available in ANSI and UNICODE versions.

Arguments:

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credentials matching the specified Filter.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    LPWSTR UnicodeFilter = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;


    //
    // Capture the user's input parameters
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, Filter, TRUE, &UnicodeFilter );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrEnumerate(
                            NULL,   // This API is always local.
                            UnicodeFilter,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;




    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoW,        // Unicode to Unicode
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeFilter != NULL ) {
        MIDL_user_free( UnicodeFilter );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredWriteDomainCredentialsA (
    IN PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    IN PCREDENTIALA Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredWriteDomainCredentialsW

Arguments:

    See CredWriteDomainCredentialsW

Return Values:

    See CredWriteDomainCredentialsW

--*/

{
    DWORD WinStatus;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process and convert to UNICODE
    //

    WinStatus = CredpConvertCredential ( DoAtoW,                    // Ansi to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to Unicode
    //

    WinStatus = CredpConvertTargetInfo( DoAtoW,                    // Ansi to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWriteDomainCredentials(
                            NULL,   // This API is always local.
                            UnicodeTargetInfo,
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

Cleanup:
    if ( EncodedCredential != NULL ) {
        MIDL_user_free( EncodedCredential );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

BOOL
APIENTRY
CredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName.

    The CredWriteDomainCredentials API is available in ANSI and UNICODE versions.

Arguments:

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.


Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        ERROR_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        ERROR_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Encode the credential before LPCing it to the LSA process
    //

    WinStatus = CredpConvertCredential ( DoWtoW,                    // Unicode to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Capture the target info to prevent us from AVing in our code.
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWriteDomainCredentials(
                            NULL,   // This API is always local.
                            TargetInfo,
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


Cleanup:
    if ( EncodedCredential != NULL ) {
        MIDL_user_free( EncodedCredential );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
CredReadDomainCredentialsA (
    IN PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALA **Credentials
    )

/*++

Routine Description:

    The ANSI version of CredReadDomainCredentialsW

Arguments:

    See CredReadDomainCredentialsW

Return Values:

    See CredReadDomainCredentialsW

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;

    //
    // Convert the target info to Unicode
    //

    WinStatus = CredpConvertTargetInfo( DoAtoW,                    // Ansi to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.

        Status = CredrReadDomainCredentials(
                            NULL,   // This API is always local.
                            UnicodeTargetInfo,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoA,        // Unicode to Ansi
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              (PCREDENTIALW **)Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
CredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

    The CredReadDomainCredentials API is available in ANSI and UNICODE versions.

Arguments:

    TargetInfo - Specifies the target information identifying the target ser

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_CACHE_TARGET_INFORMATION: The TargetInfo should be cached for a subsequent read via
            CredGetTargetInfo.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The most specific existing credential matching the TargetInfo is returned.
        If there is both a CRED_TYPE_DOMAIN_PASSWORD and CRED_TYPE_DOMAIN_CERTIFICATE
        credential, both are returned. If a connection were to be made to the named
        target, this most-specific credential would be used.

        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - None of the naming parameters were specified.

        ERROR_NOT_FOUND - There are no credentials matching the specified naming parameters.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;

    //
    // Capture the user's parameters to prevent AVing in our code.
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.

        Status = CredrReadDomainCredentials(
                            NULL,   // This API is always local.
                            TargetInfo,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoW,        // Unicode to Unicode
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              Credentials );
        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }

Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
CredDeleteA (
    IN LPCSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredDeleteW

Arguments:

    See CredDeleteW

Return Values:

    See CredDeleteW

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrDelete(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredDeleteW (
    IN LPCWSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredDelete API is available in ANSI and UNICODE versions.

Arguments:

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrDelete(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredRenameA (
    IN LPCSTR OldTargetName,
    IN LPCSTR NewTargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredRenameW

Arguments:

    See CredRenameW

Return Values:

    See CredRenameW

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeOldTargetName = NULL;
    LPWSTR UnicodeNewTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPCWSTR)OldTargetName, FALSE, &UnicodeOldTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPCWSTR)NewTargetName, FALSE, &UnicodeNewTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrRename(
                            NULL,   // This API is always local.
                            UnicodeOldTargetName,
                            UnicodeNewTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeOldTargetName != NULL ) {
        MIDL_user_free( UnicodeOldTargetName );
    }

    if ( UnicodeNewTargetName != NULL ) {
        MIDL_user_free( UnicodeNewTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredRename API is available in ANSI and UNICODE versions.

Arguments:

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified OldTargetName.

        ERROR_ALREADY_EXISTS - There is already a credential named NewTargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeOldTargetName = NULL;
    LPWSTR UnicodeNewTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, OldTargetName, FALSE, &UnicodeOldTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpAllocStrFromStr( DoWtoW, NewTargetName, FALSE, &UnicodeNewTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrRename(
                            NULL,   // This API is always local.
                            UnicodeOldTargetName,
                            UnicodeNewTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeOldTargetName != NULL ) {
        MIDL_user_free( UnicodeOldTargetName );
    }

    if ( UnicodeNewTargetName != NULL ) {
        MIDL_user_free( UnicodeNewTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

VOID
APIENTRY
CredFree (
    IN PVOID Buffer
    )

/*++

Routine Description:

    The CredFree API de-allocates a buffer returned from the various other Credential API.

Arguments:

    Buffer -Specifies the buffer to be de-allocated.

Return Values:

    None


--*/

{
    MIDL_user_free( Buffer );
}


BOOL
APIENTRY
CredGetTargetInfoA (
    IN LPCSTR ServerName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONA *TargetInfo
    )

/*++

Routine Description:

    The ANSI version of CredGetTargetInfoW

Arguments:

    See CredGetTargetInfoW

Return Values:

    See CredGetTargetInfoW

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeServerName = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)ServerName, FALSE, &UnicodeServerName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetTargetInfo(
                            NULL,   // This API is always local.
                            UnicodeServerName,
                            Flags,
                            &UnicodeTargetInfo );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to ANSI
    //

    WinStatus = CredpConvertTargetInfo( DoWtoA,                    // Unicode to Ansi
                                        UnicodeTargetInfo,
                                        (PCREDENTIAL_TARGET_INFORMATIONW *)TargetInfo,
                                        NULL );


Cleanup:
    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }
    if ( UnicodeServerName != NULL ) {
        MIDL_user_free( UnicodeServerName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

BOOL
APIENTRY
CredGetTargetInfoW (
    IN LPCWSTR ServerName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    ServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no target info for the named server.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeServerName = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, ServerName, FALSE, &UnicodeServerName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetTargetInfo(
                            NULL,   // This API is always local.
                            UnicodeServerName,
                            Flags,
                            &UnicodeTargetInfo );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to ANSI
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        UnicodeTargetInfo,
                                        TargetInfo,
                                        NULL );


Cleanup:
    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }
    if ( UnicodeServerName != NULL ) {
        MIDL_user_free( UnicodeServerName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
CredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetSessionTypes(
                            NULL,   // This API is always local.
                            MaximumPersistCount,
                            MaximumPersist );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredProfileLoaded (
    VOID
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    None.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    DWORD WinStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrProfileLoaded(
                            NULL );   // This API is always local.

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

VOID
CredpMarshalChar(
    IN OUT LPWSTR *Current,
    IN ULONG Byte
    )
/*++

Routine Description:

    This routine marshals 6 bits into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Byte - Specifies the 6 bits to marshal

Return Values:

    None.

--*/
{
    UCHAR MappingTable[] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '#', '-'
    };

    if ( Byte > 0x3F ) {
        *(*Current) = '=';
    } else {
        *(*Current) = MappingTable[Byte];
    }
    (*Current)++;
}

ULONG
CredpMarshalSize(
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine returns the number of bytes that would be marshaled by
    CredpMarshalBytes when passed a buffer ByteCount bytes long.

Arguments:

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    The number of bytes that would be marshaled.

--*/
{
    ULONG CharCount;
    ULONG ExtraBytes;

    //
    // If byte count is a multiple of 3, the char count is straight forward
    //
    CharCount = ByteCount / 3 * 4;

    ExtraBytes = ByteCount % 3;

    if ( ExtraBytes == 1 ) {
        CharCount += 2;
    } else if ( ExtraBytes == 2 ) {
        CharCount += 3;
    }

    return CharCount * sizeof(WCHAR);

}

VOID
CredpMarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine marshals bytes into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Bytes - Specifies the buffer to marshal

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    None.

--*/
{
    ULONG i;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    //
    // Loop through marshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }
        RtlCopyMemory( Bits.ByteValues, &Bytes[i], BytesToCopy );

        //
        // Marshal the first twelve bits
        //
        CredpMarshalChar( Current, Bits.BitValues.Bits1 );
        CredpMarshalChar( Current, Bits.BitValues.Bits2 );

        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            CredpMarshalChar( Current, Bits.BitValues.Bits3 );
            if ( BytesToCopy > 2 ) {
                CredpMarshalChar( Current, Bits.BitValues.Bits4 );
            }
        }

    }

}

BOOL
CredpUnmarshalChar(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    OUT PULONG Value
    )
/*++

Routine Description:

    This routine unmarshals 6 bits from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Value - returns the unmarshaled 6 bits value.

Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    WCHAR CurrentChar;

    //
    // Ensure the character is available in the buffer
    //

    if ( *Current >= End ) {
        return FALSE;

    }

    //
    // Grab the character
    //

    CurrentChar = *(*Current);
    (*Current)++;

    //
    // Map it the 6 bit value
    //

    switch ( CurrentChar ) {
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
        *Value = CurrentChar - 'A';
        break;

    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
        *Value = CurrentChar - 'a' + 26;
        break;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        *Value = CurrentChar - '0' + 26 + 26;
        break;
    case '#':
        *Value = 26 + 26 + 10;
        break;
    case '-':
        *Value = 26 + 26 + 10 + 1;
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CredpUnmarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine unmarshals bytes bytes from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Bytes - Specifies the buffer to unmarsal into

    ByteCount - Specifies the number of bytes to unmarshal


Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    ULONG i;
    ULONG Value;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    //
    // Loop through unmarshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }

        //
        // Unarshal the first twelve bits
        //
        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits1 = Value;

        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits2 = Value;


        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                return FALSE;
            }
            Bits.BitValues.Bits3 = Value;
            if ( BytesToCopy > 2 ) {
                if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                    return FALSE;
                }
                Bits.BitValues.Bits4 = Value;
            }
        }

        //
        // Copy the unmarshaled bytes to the caller's buffer.
        //

        RtlCopyMemory( &Bytes[i], Bits.ByteValues, BytesToCopy );

    }

    return TRUE;
}

BOOL
APIENTRY
CredMarshalCredentialA(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPSTR *MarshaledCredential
    )
/*++

Routine Description:

    The ANSI version of CredMarshalCredentialW

Arguments:

    See CredMarshalCredentialW.

Return Values:

    See CredMarshalCredentialW.

--*/
{
    BOOL RetVal;
    DWORD WinStatus;
    LPWSTR UnicodeMarshaledCredential;

    RetVal = CredMarshalCredentialW( CredType, Credential, &UnicodeMarshaledCredential );

    if ( RetVal ) {

        //
        // Convert the value to ANSI.
        //

        WinStatus = CredpAllocStrFromStr( DoWtoA, UnicodeMarshaledCredential, FALSE, (LPWSTR *)MarshaledCredential );

        if ( WinStatus != NO_ERROR ) {
            SetLastError( WinStatus );
            RetVal = FALSE;
        }

        CredFree( UnicodeMarshaledCredential );
    }

    return RetVal;
}

BOOL
APIENTRY
CredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    )
/*++

Routine Description:

    The CredMarshalCredential API is a private API used by the keyring UI to marshal a
    credential.  The keyring UI needs to be able to pass a certificate credential through
    interfaces (e.g., NetUseAdd) that have historically accepted DomainName UserName and Password.

Arguments:

    CredType - Specifies the type of credential to marshal.
        This enum will be expanded in the future.

    Credential - Specifies the credential to marshal.
        If CredType is CertCredential, then Credential points to a CERT_CREDENTIAL_INFO structure.

    MarshaledCredential - Returns a text string containing the marshaled credential.
        The marshaled credential should be passed as the UserName string to any API that
        is currently passed credentials.  If that API is currently passed a
        password, the password should be passed as NULL or empty.  If that API is
        currently passed a domain name, that domain name should be passed as NULL or empty.

        The caller should free the returned buffer using CredFree.


Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - CredType is invalid.

--*/
{
    DWORD WinStatus;
    ULONG Size;
    LPWSTR RetCredential = NULL;
    LPWSTR Current;
    PCERT_CREDENTIAL_INFO CertCredentialInfo = NULL;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCredentialInfo = NULL;
    ULONG UsernameTargetUserNameSize;
#define CRED_MARSHAL_HEADER L"@@"
#define CRED_MARSHAL_HEADER_LENGTH 2

    //
    // Ensure credential isn't null
    //

    if ( Credential == NULL ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Validate CredType
    //

    Size = (CRED_MARSHAL_HEADER_LENGTH+2) * sizeof(WCHAR);
    switch ( CredType ) {
    case CertCredential:
        CertCredentialInfo = (PCERT_CREDENTIAL_INFO) Credential;

        if ( CertCredentialInfo->cbSize < sizeof(CERT_CREDENTIAL_INFO) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Size += CredpMarshalSize( sizeof(CertCredentialInfo->rgbHashOfCert) );
        break;

    case UsernameTargetCredential:
        UsernameTargetCredentialInfo = (PUSERNAME_TARGET_CREDENTIAL_INFO) Credential;

        if ( UsernameTargetCredentialInfo->UserName == NULL ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        UsernameTargetUserNameSize = wcslen(UsernameTargetCredentialInfo->UserName)*sizeof(WCHAR);

        if ( UsernameTargetUserNameSize == 0 ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Size += CredpMarshalSize( sizeof(UsernameTargetUserNameSize) ) +
                CredpMarshalSize( UsernameTargetUserNameSize );
        break;

    default:
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Allocate a buffer to put the marshaled string into.
    //

    RetCredential = (LPWSTR) MIDL_user_allocate( Size );

    if ( RetCredential == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Add the header onto the marshaled string
    //


    Current = RetCredential;

    RtlCopyMemory( Current, CRED_MARSHAL_HEADER, CRED_MARSHAL_HEADER_LENGTH*sizeof(WCHAR) );
    Current += CRED_MARSHAL_HEADER_LENGTH;

    //
    // Add the CredType
    //

    CredpMarshalChar( &Current, CredType );

    //
    // Marshal the CredType specific data
    //

    switch ( CredType ) {
    case CertCredential:
        CredpMarshalBytes( &Current, CertCredentialInfo->rgbHashOfCert, sizeof(CertCredentialInfo->rgbHashOfCert) );
        break;
    case UsernameTargetCredential:
        CredpMarshalBytes( &Current, (LPBYTE)&UsernameTargetUserNameSize, sizeof(UsernameTargetUserNameSize) );
        CredpMarshalBytes( &Current, (LPBYTE)UsernameTargetCredentialInfo->UserName, UsernameTargetUserNameSize );
        break;
    }

    //
    // Finally, zero terminate the string
    //

    *Current = L'\0';
    Current ++;

    //
    // Return the marshaled credential to the caller.
    //

    ASSERT( Current == &RetCredential[Size/sizeof(WCHAR)] );


    *MarshaledCredential = RetCredential;
    RetCredential = NULL;
    WinStatus = NO_ERROR;

Cleanup:
    if ( RetCredential != NULL ) {
        MIDL_user_free( RetCredential );
    }
    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredUnmarshalCredentialA(
    IN LPCSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
/*++

Routine Description:

    The ANSI version of CredUnmarshalCredentialW

Arguments:

    See CredUnmarshalCredentialW.

Return Values:

    See CredUnmarshalCredentialW.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeMarshaledCredential = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)MarshaledCredential, FALSE, &UnicodeMarshaledCredential );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the unmarshaling
    //
    if ( !CredUnmarshalCredentialW( UnicodeMarshaledCredential,
                                    CredType,
                                    Credential ) ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

Cleanup:
    if ( UnicodeMarshaledCredential != NULL ) {
        MIDL_user_free( UnicodeMarshaledCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
/*++

Routine Description:

    The CredMarshalCredential API is a private API used by an authentication package to unmarshal a
    credential.  The keyring UI needs to be able to pass a certificate credential through
    interfaces (e.g., NetUseAdd) that have historically accepted DomainName UserName and Password.

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

    CredType - Returns the type of credential.

    Credential - Returns a pointer to the unmarshaled credential.
        If CredType is CertCredential, then the returned pointer is to a CERT_CREDENTIAL_INFO structure.

        The caller should free the returned buffer using CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - MarshaledCredential is not valid

--*/
{
    DWORD WinStatus;
    LPWSTR Current;
    LPCWSTR End;
    PCERT_CREDENTIAL_INFO CertCredentialInfo;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCredentialInfo;
    PVOID RetCredential = NULL;
    ULONG UsernameTargetUserNameSize;
    LPBYTE Where;
    ULONG MarshaledCredentialLength;

    //
    // Validate the passed in buffer.
    //

    if ( MarshaledCredential == NULL ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure the first few bytes are the appropriate header
    //

    if ( MarshaledCredential[0] != CRED_MARSHAL_HEADER[0] || MarshaledCredential[1] != CRED_MARSHAL_HEADER[1] ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the credential type
    //

    MarshaledCredentialLength = wcslen(MarshaledCredential);
    Current = (LPWSTR) &MarshaledCredential[2];
    End = &MarshaledCredential[MarshaledCredentialLength];

    if ( !CredpUnmarshalChar( &Current, End, (PULONG)CredType ) ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch ( *CredType ) {
    case CertCredential:

        //
        // Allocate a buffer that will be more than big enough
        //

        CertCredentialInfo = MIDL_user_allocate( sizeof(*CertCredentialInfo) );

        if ( CertCredentialInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RetCredential = CertCredentialInfo;
        CertCredentialInfo->cbSize = sizeof(*CertCredentialInfo);

        //
        // Unmarshal the data
        //

        if ( !CredpUnmarshalBytes( &Current, End, CertCredentialInfo->rgbHashOfCert, sizeof(CertCredentialInfo->rgbHashOfCert) ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        break;

    case UsernameTargetCredential:


        //
        // Allocate a buffer that will be more than big enough
        //

        UsernameTargetCredentialInfo = MIDL_user_allocate(
                                sizeof(*UsernameTargetCredentialInfo) +
                                MarshaledCredentialLength*sizeof(WCHAR) +
                                sizeof(WCHAR) );

        if ( UsernameTargetCredentialInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RetCredential = UsernameTargetCredentialInfo;
        Where = (LPBYTE)(UsernameTargetCredentialInfo+1);

        //
        // Unmarshal the size of the data
        //

        if ( !CredpUnmarshalBytes( &Current, End, (LPBYTE)&UsernameTargetUserNameSize, sizeof(UsernameTargetUserNameSize) ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( UsernameTargetUserNameSize != ROUND_UP_COUNT( UsernameTargetUserNameSize, sizeof(WCHAR)) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( UsernameTargetUserNameSize == 0 ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }



        //
        // Unmarshal the data
        //

        UsernameTargetCredentialInfo->UserName = (LPWSTR)Where;

        if ( !CredpUnmarshalBytes( &Current, End, Where, UsernameTargetUserNameSize ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Where += UsernameTargetUserNameSize;

        //
        // Zero terminate it
        //
        *((PWCHAR)Where) = L'\0';

        break;

    default:
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure we've unmarshalled the entire string
    //

    if ( Current != End ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;
    *Credential = RetCredential;

Cleanup:
    if ( WinStatus != NO_ERROR ) {
        *Credential = NULL;
        if ( RetCredential != NULL ) {
            MIDL_user_free( RetCredential );
        }
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    )
/*++

Routine Description:

    The ANSI version of CredIsMarshaledCredentialW

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

Return Values:

    Returns TRUE if the credential is a marshalled credential.

--*/
{
    DWORD WinStatus;
    CRED_MARSHAL_TYPE CredType;
    PVOID UnmarshalledUsername;

    if ( !CredUnmarshalCredentialA( MarshaledCredential, &CredType, &UnmarshalledUsername ) ) {
        return FALSE;
    }

    CredFree( UnmarshalledUsername );

    return TRUE;
}

BOOL
APIENTRY
CredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    )
/*++

Routine Description:

    The CredIsMarshaledCredential API is a private API used by an authentication package to
    determine if a credential is a unmarshaled credential or not.

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

Return Values:

    Returns TRUE if the credential is a marshalled credential.

--*/
{
    DWORD WinStatus;
    CRED_MARSHAL_TYPE CredType;
    PVOID UnmarshalledUsername;

    if ( !CredUnmarshalCredentialW( MarshaledCredential, &CredType, &UnmarshalledUsername ) ) {
        return FALSE;
    }

    CredFree( UnmarshalledUsername );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\crconv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crconv.c

Abstract:

    This module contains credential conversion routines shared between advapi32.dll and crtest.exe

Author:

    Cliff Van Dyke (CliffV)    February 25, 2000

Revision History:

--*/


DWORD
CredpConvertStringSize (
    IN WTOA_ENUM WtoA,
    IN LPWSTR String OPTIONAL
    )

/*++

Routine Description:

    Determines the size of the converted string

Arguments:

    WtoA - Specifies the direction of the string conversion.

    String - The string to convert

Return Values:

    Returns the size (in bytes) of the converted string.

--*/

{
    ULONG Size = 0;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    if ( String == NULL ) {
        return Size;
    }

    switch ( WtoA ) {
    case DoWtoA:
        Status = RtlInitUnicodeStringEx( &UnicodeString, String );
        if ( NT_SUCCESS( Status )) {
            Size = RtlUnicodeStringToAnsiSize( &UnicodeString );
        }
        break;

    case DoAtoW:
        RtlInitAnsiString( &AnsiString, (LPSTR)String );
        Size = RtlAnsiStringToUnicodeSize( &AnsiString );
        break;
    case DoWtoW:
        Size = (wcslen( String ) + 1) * sizeof(WCHAR);
        break;
    }

    return Size;

}

DWORD
CredpConvertString (
    IN WTOA_ENUM WtoA,
    IN LPWSTR String OPTIONAL,
    OUT LPWSTR *OutString,
    IN OUT LPBYTE *WherePtr
    )

/*++

Routine Description:

    Determines the size of the converted string

Arguments:

    WtoA - Specifies the direction of the string conversion.

    String - The string to convert

    OutString - Returns the pointer to the marshaled string

    WherePtr - Specifies the address of the first byte to write the string to.
        Returns a pointer to the first byte after the marshaled string

Return Values:

    Returns the status of the conversion


--*/

{
    NTSTATUS Status;

    ULONG Size;

    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPBYTE Where = *WherePtr;

    if ( String == NULL ) {
        *OutString = NULL;
        return NO_ERROR;
    }

    *OutString = (LPWSTR)Where;

    switch ( WtoA ) {
    case DoWtoA:
        Status = RtlInitUnicodeStringEx( &UnicodeString, String );
        if ( !NT_SUCCESS(Status) ) {
            return RtlNtStatusToDosError( Status );
        }

        AnsiString.Buffer = (PCHAR)Where;
        AnsiString.MaximumLength = 0xFFFF;

        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if ( !NT_SUCCESS(Status) ) {
            return RtlNtStatusToDosError( Status );
        }

        Where += AnsiString.Length + sizeof(CHAR);
        break;

    case DoAtoW:
        RtlInitAnsiString( &AnsiString, (LPSTR)String );
        UnicodeString.Buffer = (LPWSTR)Where;
        UnicodeString.MaximumLength = 0xFFFE;

        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
        if ( !NT_SUCCESS(Status) ) {
            return RtlNtStatusToDosError( Status );
        }

        Where += UnicodeString.Length + sizeof(WCHAR);

        break;
    case DoWtoW:
        Size = (wcslen( String ) + 1) * sizeof(WCHAR);

        RtlCopyMemory( Where, String, Size );
        Where += Size;
        break;
    }

    *WherePtr = Where;
    return NO_ERROR;

}

DWORD
CredpConvertOneCredentialSize (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIALW InCredential
    )

/*++

Routine Description:

    Computes the size of a converted credential

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InCredential - Input credential

Return Values:

    Returns the size (in bytes) the CredpConvertOneCredential will need to
        copy this credential into a buffer.

--*/

{
    DWORD WinStatus;
    ULONG Size;

    ULONG i;

    //
    // Compute the initial size
    //

    Size = ROUND_UP_COUNT( sizeof(ENCRYPTED_CREDENTIALW), ALIGN_WORST ) +
           ROUND_UP_COUNT( InCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW), ALIGN_WORST );

    if ( InCredential->CredentialBlobSize != 0 ) {
        ULONG CredBlobSize;

        // Leave room for the encoding over the wire
        CredBlobSize = AllocatedCredBlobSize( InCredential->CredentialBlobSize );

        // Align the data following the credential blob
        Size += ROUND_UP_COUNT( CredBlobSize, ALIGN_WORST );
    }


    //
    // Compute the size of the strings in the right character set.
    //

    Size += CredpConvertStringSize( WtoA, InCredential->TargetName );
    Size += CredpConvertStringSize( WtoA, InCredential->Comment );
    Size += CredpConvertStringSize( WtoA, InCredential->TargetAlias );
    Size += CredpConvertStringSize( WtoA, InCredential->UserName );

    //
    // Compute the size of the attributes
    //

    if ( InCredential->AttributeCount != 0 ) {

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            Size += CredpConvertStringSize( WtoA, InCredential->Attributes[i].Keyword );

            Size += ROUND_UP_COUNT(InCredential->Attributes[i].ValueSize, ALIGN_WORST);

        }
    }

    Size = ROUND_UP_COUNT( Size, ALIGN_WORST );

    return Size;

}

DWORD
CredpConvertOneCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    IN OUT LPBYTE *WherePtr
    )

/*++

Routine Description:

    Converts one credential from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.
        If DoBlobDecode, then InCredential really points to a PENCRYPTED_CREDENTIALW.

    InCredential - Input credentials

    WherePtr - Specifies the address of the first byte to write the credential to.
        On input, the strucure should be aligned ALIGN_WORST.
        Returns a pointer to the first byte after the marshaled credential.
        The output credential is actually a ENCRYPTED_CREDENTIALW.  The caller
        can use it as a CREDENTIALW depending on the DoDecode value.


Return Values:

    Window status code

--*/

{
    DWORD WinStatus;

    ULONG i;
    LPBYTE Where = *WherePtr;
    LPBYTE OldWhere;
    PENCRYPTED_CREDENTIALW OutCredential;


    //
    // Initialize the base structure
    //

    OutCredential = (PENCRYPTED_CREDENTIALW) Where;

    RtlZeroMemory( OutCredential, sizeof(*OutCredential) );
    Where += sizeof(*OutCredential);

    // Align the running pointer again
    OldWhere = Where;
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );


    //
    // Copy the fixed size data
    //

    OutCredential->Cred.Flags = InCredential->Flags;
    OutCredential->Cred.Type = InCredential->Type;
    OutCredential->Cred.LastWritten = InCredential->LastWritten;
    OutCredential->Cred.CredentialBlobSize = InCredential->CredentialBlobSize;
    OutCredential->Cred.Persist = InCredential->Persist;
    OutCredential->Cred.AttributeCount = InCredential->AttributeCount;

    //
    // Copy the data we don't know the alignment for.
    //  (ALIGN_WORST so our caller can't blame us.)
    //

    if ( InCredential->CredentialBlobSize != 0 ) {
        ULONG CredBlobSize;

        OutCredential->Cred.CredentialBlob = Where;
        RtlCopyMemory( Where, InCredential->CredentialBlob, InCredential->CredentialBlobSize );
        Where += InCredential->CredentialBlobSize;

        // Leave room for the encoding over the wire
        CredBlobSize = AllocatedCredBlobSize( InCredential->CredentialBlobSize );

        // Align the running pointer again
        OldWhere = Where;
        // Align the data following the credential blob
        Where = (LPBYTE) ROUND_UP_POINTER( OldWhere+(CredBlobSize-InCredential->CredentialBlobSize), ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        //  Encode or decode the Credential blob as requested
        //

        switch (DoDecode) {
        case DoBlobDecode:
            OutCredential->ClearCredentialBlobSize = ((PENCRYPTED_CREDENTIALW)InCredential)->ClearCredentialBlobSize;
#ifndef _CRTEST_EXE_
            CredpDecodeCredential( OutCredential );
#endif // _CRTEST_EXE_
            break;
        case DoBlobEncode:
            OutCredential->ClearCredentialBlobSize = InCredential->CredentialBlobSize;
#ifndef _CRTEST_EXE_
            if (!CredpEncodeCredential( OutCredential ) ) {
                return ERROR_INVALID_PARAMETER;
            }
#endif // _CRTEST_EXE_
            break;
        case DoBlobNeither:
            OutCredential->ClearCredentialBlobSize = InCredential->CredentialBlobSize;
            break;
        default:
            return ERROR_INVALID_PARAMETER;
        }
    }

    if ( InCredential->AttributeCount != 0 ) {

        //
        // Push an array of attribute structs
        //
        OutCredential->Cred.Attributes = (PCREDENTIAL_ATTRIBUTEW) Where;
        Where += InCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW);

        // Align the running pointer again
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        // Fill it in.
        //

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            OutCredential->Cred.Attributes[i].Flags = InCredential->Attributes[i].Flags;
            OutCredential->Cred.Attributes[i].ValueSize = InCredential->Attributes[i].ValueSize;

            if ( InCredential->Attributes[i].ValueSize != 0 ) {
                OutCredential->Cred.Attributes[i].Value = Where;
                RtlCopyMemory( Where, InCredential->Attributes[i].Value, InCredential->Attributes[i].ValueSize );
                Where += InCredential->Attributes[i].ValueSize;

                // Align the running pointer again
                OldWhere = Where;
                Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
                RtlZeroMemory( OldWhere, Where-OldWhere );
            } else {
                OutCredential->Cred.Attributes[i].Value = NULL;
            }

        }
    }


    //
    // Convert the strings to the right character set.
    //

    WinStatus = CredpConvertString( WtoA, InCredential->TargetName, &OutCredential->Cred.TargetName, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->Comment, &OutCredential->Cred.Comment, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->TargetAlias, &OutCredential->Cred.TargetAlias, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->UserName, &OutCredential->Cred.UserName, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    if ( InCredential->AttributeCount != 0 ) {

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            WinStatus = CredpConvertString( WtoA, InCredential->Attributes[i].Keyword, &OutCredential->Cred.Attributes[i].Keyword, &Where );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        }
    }

    // Align the running pointer again
    OldWhere = Where;
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    *WherePtr = Where;
    WinStatus = NO_ERROR;

    //
    // Be tidy
    //
Cleanup:

    return WinStatus;

}

#ifndef _CRTEST_EXE_
DWORD
APIENTRY
CredpConvertCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    OUT PCREDENTIALW *OutCredential
    )

/*++

Routine Description:

    Converts a credential from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.

    InCredential - Input credentials

    OutCredential - Output credential
        This credential should be freed using MIDL_user_free.

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size = 0;

    LPBYTE Where;

    //
    // BVTs pass NULL explicitly.  We could let the AV be caught in the try/except, but
    //  that would prevent them from being able to run under a debugger.  So, handle NULL
    //  explicitly.
    //

    if ( InCredential == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //

#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_

        //
        // Compute the size needed for the output credential
        //

        Size = CredpConvertOneCredentialSize( WtoA, InCredential );


        //
        // Allocate a buffer for the resultant credential
        //

        *OutCredential = (PCREDENTIALW) MIDL_user_allocate( Size );

        if ( *OutCredential == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Convert the credential into the allocated buffer
        //

        Where = (LPBYTE) *OutCredential;

        WinStatus = CredpConvertOneCredential( WtoA, DoDecode, InCredential, &Where );

        if ( WinStatus != NO_ERROR ) {
            MIDL_user_free( *OutCredential );
            *OutCredential = NULL;
        } else {
            ASSERT( (ULONG)(Where - ((LPBYTE)*OutCredential)) == Size );
        }
Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    return WinStatus;

}

DWORD
APIENTRY
CredpConvertTargetInfo (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *OutTargetInfo,
    OUT PULONG OutTargetInfoSize OPTIONAL
    )

/*++

Routine Description:

    Converts a target info from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InTargetInfo - Input TargetInfo

    OutTargetInfo - Output TargetInfo
        This TargetInfo should be freed using CredFree.

    OutTargetInfoSize - Size (in bytes) of the buffer returned in OutTargetInfo

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size;

    LPBYTE Where;

    *OutTargetInfo = NULL;

    //
    // BVTs pass NULL explicitly.  We could let the AV be caught in the try/except, but
    //  that would prevent them from being able to run under a debugger.  So, handle NULL
    //  explicitly.
    //

    if ( InTargetInfo == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_
        //
        // Compute the size needed for the output target info
        //

        Size = sizeof(CREDENTIAL_TARGET_INFORMATIONW);


        //
        // Compute the size of the strings in the right character set.
        //

        Size += CredpConvertStringSize( WtoA, InTargetInfo->TargetName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->NetbiosServerName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsServerName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->NetbiosDomainName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsDomainName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsTreeName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->PackageName );
        Size += InTargetInfo->CredTypeCount * sizeof(DWORD);


        //
        // Allocate a buffer for the resultant credential
        //

        *OutTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW) MIDL_user_allocate( Size );

        if ( *OutTargetInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( ARGUMENT_PRESENT(OutTargetInfoSize) ) {
            *OutTargetInfoSize = Size;
        }
        Where = (LPBYTE)((*OutTargetInfo) + 1);


        //
        // Copy the fixed size data
        //

        (*OutTargetInfo)->Flags = InTargetInfo->Flags;

        //
        // Copy the DWORD aligned data
        //

        (*OutTargetInfo)->CredTypeCount = InTargetInfo->CredTypeCount;
        if ( InTargetInfo->CredTypeCount != 0 ) {
            (*OutTargetInfo)->CredTypes = (LPDWORD) Where;
            RtlCopyMemory( Where, InTargetInfo->CredTypes, InTargetInfo->CredTypeCount * sizeof(DWORD) );
            Where += InTargetInfo->CredTypeCount * sizeof(DWORD);
        } else {
            (*OutTargetInfo)->CredTypes = NULL;
        }


        //
        // Convert the strings to the right character set.
        //

        WinStatus = CredpConvertString( WtoA, InTargetInfo->TargetName, &(*OutTargetInfo)->TargetName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->NetbiosServerName, &(*OutTargetInfo)->NetbiosServerName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsServerName, &(*OutTargetInfo)->DnsServerName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->NetbiosDomainName, &(*OutTargetInfo)->NetbiosDomainName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsDomainName, &(*OutTargetInfo)->DnsDomainName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsTreeName, &(*OutTargetInfo)->DnsTreeName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->PackageName, &(*OutTargetInfo)->PackageName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        ASSERT( (ULONG)(Where - ((LPBYTE)*OutTargetInfo)) == Size );
Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    //
    // Be tidy
    //
    if ( WinStatus != NO_ERROR ) {
        if ( *OutTargetInfo != NULL ) {
            MIDL_user_free( *OutTargetInfo );
            *OutTargetInfo = NULL;
        }
    }

    return WinStatus;

}
#endif // _CRTEST_EXE_

DWORD
CredpConvertCredentials (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW *InCredential,
    IN ULONG InCredentialCount,
    OUT PCREDENTIALW **OutCredential
    )

/*++

Routine Description:

    Converts a set of credentials from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.

    InCredential - Input credentials

    OutCredential - Output credential
        This credential should be freed using MIDL_user_free.

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size = 0;
    ULONG i;

    LPBYTE Where;
    LPBYTE OldWhere;

    *OutCredential = NULL;

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_

        //
        // Compute the size needed for the output credentials
        //

        for ( i=0; i<InCredentialCount; i++ ) {
            Size += CredpConvertOneCredentialSize( WtoA, InCredential[i] );
        }


        //
        // Allocate a buffer for the resultant credential array
        //

        Size += ROUND_UP_COUNT( InCredentialCount * sizeof(PCREDENTIALW), ALIGN_WORST );

        *OutCredential = (PCREDENTIALW *)MIDL_user_allocate( Size );

        if ( *OutCredential == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Convert the credential into the allocated buffer
        //

        Where = (LPBYTE) *OutCredential;
        Where += InCredentialCount * sizeof(PCREDENTIALW);

        // Align the running pointer again
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        for ( i=0; i<InCredentialCount; i++ ) {

            //
            // Save a pointer to this credential
            //

            (*OutCredential)[i] = (PCREDENTIALW) Where;

            //
            // Marshal the credential
            //

            WinStatus = CredpConvertOneCredential( WtoA, DoDecode, InCredential[i], &Where );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }
        }

        ASSERT( (ULONG)(Where - ((LPBYTE)*OutCredential)) == Size );
        WinStatus = NO_ERROR;

Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    if ( WinStatus != NO_ERROR ) {
        if ( *OutCredential != NULL ) {
            MIDL_user_free( *OutCredential );
            *OutCredential = NULL;
        }
    }

    return WinStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\efsrpc_c_stub.c ===
#include "efsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\eclient.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    eclient.c

Abstract:

    EFS RPC client code.

Author:

    Robert Gu       (RobertG)    Aug, 1997

Environment:

Revision History:

--*/


#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <wincrypt.h>
#include <efsrpc.h>
#include <efsstruc.h>
#include <dfsfsctl.h>
#include <rpcasync.h>

#define  DAVHEADER  0x01

//
// Internal prototypes
//

void __RPC_FAR
EfsPipeAlloc(
    char __RPC_FAR * State,
    unsigned long ReqSize,
    unsigned char __RPC_FAR * __RPC_FAR * Buf,
    unsigned long __RPC_FAR * RealSize
    );

void __RPC_FAR
EfsPipeRead (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteCount
    );

void __RPC_FAR
EfsPipeWrite (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteRequested,
    unsigned long *ByteFromCaller
    );

DWORD
GetFullName(
    LPCWSTR FileName,
    LPWSTR *FullName,
    LPWSTR *ServerName,
    ULONG   Flags,
    DWORD  *dwCreationDistribution, 
    DWORD   dwAttributes, 
    PSECURITY_DESCRIPTOR pRelativeSD,
    BOOL    bInheritHandle
    );

DWORD
EnablePrivilege(
    ULONG   Flags,
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    );

VOID
RestorePrivilege(
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    );


DWORD
EnablePrivilege(
    ULONG   Flags,
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    )
{

    TOKEN_PRIVILEGES    Privs;
    DWORD   RetCode = ERROR_SUCCESS;

    BOOL    b;
    DWORD   ReturnLength;

    *TokenHandle = NULL;
    *OldPrivs = NULL;

    *OldPrivs = ( TOKEN_PRIVILEGES *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof( TOKEN_PRIVILEGES )
                            );


    if ( *OldPrivs == NULL ){

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // We're impersonating, use the thread token.
    //

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            FALSE,
            TokenHandle
            );

    if (!b) {
        b = OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TokenHandle
            );
    }

    if ( b ) {

        //
        // We've got a token handle
        //

        //
        // If we're doing a create for import, enable restore privilege,
        // otherwise enable backup privilege.
        //


        Privs.PrivilegeCount = 1;
        Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( !(Flags & CREATE_FOR_IMPORT) ){

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_BACKUP_PRIVILEGE);

        } else {

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
        }

        ReturnLength = sizeof( TOKEN_PRIVILEGES );

        (VOID) AdjustTokenPrivileges (
                    *TokenHandle,
                    FALSE,
                    &Privs,
                    sizeof( TOKEN_PRIVILEGES ),
                    *OldPrivs,
                    &ReturnLength
                    );

        if ( ERROR_SUCCESS != (RetCode = GetLastError()) ) {

            //
            // Privilege adjust failed
            //

            CloseHandle( *TokenHandle );
            *TokenHandle = NULL;
            RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
            *OldPrivs = NULL;

        }

    } else {
        *TokenHandle = NULL;
        RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
        *OldPrivs = NULL;
    }

    return RetCode;
}


VOID
RestorePrivilege(
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    )
{
    if (!TokenHandle || !OldPrivs || !(*TokenHandle) || !(*OldPrivs)) {
        return;
    }
    (VOID) AdjustTokenPrivileges (
                *TokenHandle,
                FALSE,
                *OldPrivs,
                0,
                NULL,
                NULL
                );

    CloseHandle( *TokenHandle );
    *TokenHandle = 0;
    RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
    *OldPrivs = NULL;
}

DWORD
EfsOpenFileRawRPCClient(
    IN  LPCWSTR    FileName,
    IN  ULONG   Flags,
    OUT PVOID * Context
    )

/*++

Routine Description:

    This routine is the client side of EfsOpenFileRaw. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FileName  --  File name of the file to be exported

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   PEXIMPORT_CONTEXT_HANDLE RawContext;
   LPWSTR  FullName;
   LPWSTR  Server;
   HANDLE  TokenHandle;
   PTOKEN_PRIVILEGES OldPrivs;

   *Context = NULL;
   RetCode = GetFullName(
                     FileName,
                     &FullName,
                     &Server,
                     Flags,
                     NULL,
                     0,
                     NULL,
                     FALSE
                     );

   if ( RetCode == ERROR_SUCCESS ){

       (VOID) EnablePrivilege(
                    Flags,
                    &TokenHandle,
                    &OldPrivs
                    );

       Status = RpcpBindRpc (
                    Server,
                    L"lsarpc",
                    L"security=Impersonation static true",
                    &binding_h
                    );

       if (NT_SUCCESS(Status)){
           RpcTryExcept {
               RetCode = EfsRpcOpenFileRaw(
                                   binding_h,
                                   &RawContext,
                                   FullName,
                                   Flags
                                   );
               if ( ERROR_SUCCESS == RetCode ){

                   //
                   //  Send the context handle back to the user
                   //

                   if (RawContext) {
                       *Context = (PVOID) RawContext;
                   } else {

                       //
                       // The server is hacked?
                       //

                       RetCode = ERROR_DEV_NOT_EXIST;

                   }

               }
           } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
               RetCode = RpcExceptionCode();
           } RpcEndExcept;

           //
           // Free the binding handle
           //

           RpcpUnbindRpc( binding_h );
       } else {
           RetCode = RtlNtStatusToDosError( Status );
       }

       RestorePrivilege(
           &TokenHandle,
           &OldPrivs
       );

       RtlFreeHeap( RtlProcessHeap(), 0, FullName );
       RtlFreeHeap( RtlProcessHeap(), 0, Server );
   }

   return RetCode;
}

VOID
EfsCloseFileRawRPCClient(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsCloseFileRaw.

Arguments:

    Context - Export/Import context used by READ/WRITE raw data.


Return Value:

    None.

--*/
{

    PEXIMPORT_CONTEXT_HANDLE phContext;

    phContext = (PEXIMPORT_CONTEXT_HANDLE) Context;
    RpcTryExcept {
        EfsRpcCloseRaw(
            &phContext
            );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    } RpcEndExcept;

}

DWORD
EfsReadFileRawRPCClient(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsReadFileRaw.

Arguments:

    ExportCallback - Caller provided callback function.

    CallbackContext - Caller's context.

    Context - Export context used by READ raw data.


Return Value:

    None.
*/
{
    PEXIMPORT_CONTEXT_HANDLE phContext;
    EFS_EXIM_STATE  Pipe_State;
    EFS_EXIM_PIPE   ExportPipe;
    DWORD RetCode;

    if ( NULL == Context){
        return ERROR_ACCESS_DENIED;
    }

    phContext = ( PEXIMPORT_CONTEXT_HANDLE ) Context;

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    Pipe_State.BufLength = FSCTL_OUTPUT_INITIAL_LENGTH;
    Pipe_State.WorkBuf = NULL;

    while ( !Pipe_State.WorkBuf  &&
                (Pipe_State.BufLength >= FSCTL_OUTPUT_MIN_LENGTH)
               ){

        Pipe_State.WorkBuf = RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                Pipe_State.BufLength
                                );
        if ( !Pipe_State.WorkBuf ){

            //
            // Memory allocation failed.
            // Try smaller allocation.
            //

            Pipe_State.BufLength -= FSCTL_OUTPUT_LESS_LENGTH;

        }

    }
    if (!Pipe_State.WorkBuf){
        return ERROR_OUTOFMEMORY;
    }

    Pipe_State.ExImCallback = (PVOID) ExportCallback;
    Pipe_State.CallbackContext = CallbackContext;
    Pipe_State.Status = NO_ERROR;
    ExportPipe.state = (char *) &Pipe_State;
    ExportPipe.alloc = EfsPipeAlloc;
    ExportPipe.pull = NULL;
    ExportPipe.push = EfsPipeRead;

    RpcTryExcept{

        RetCode = EfsRpcReadFileRaw(
                                phContext,
                                &ExportPipe
                                );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            if ( NO_ERROR == Pipe_State.Status ){
                RetCode = RpcExceptionCode();
            } else {
                RetCode =   Pipe_State.Status;
            }
    } RpcEndExcept;

    RtlFreeHeap( RtlProcessHeap(), 0, Pipe_State.WorkBuf );

    return RetCode;
}

DWORD
EfsWriteFileRawRPCClient(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsWriteFileRaw.

Arguments:

    ImportCallback - Caller provided callback function.

    CallbackContext - Caller's context.

    Context - Import context used by WRITE raw data.


Return Value:

    None.
*/
{
    PEXIMPORT_CONTEXT_HANDLE phContext;
    EFS_EXIM_STATE  Pipe_State;
    EFS_EXIM_PIPE   ImportPipe;
    DWORD RetCode;

    HANDLE  TokenHandle;
    PTOKEN_PRIVILEGES OldPrivs;

    if ( NULL == Context){
        return ERROR_ACCESS_DENIED;
    }
    phContext = ( PEXIMPORT_CONTEXT_HANDLE ) Context;

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    Pipe_State.BufLength = FSCTL_OUTPUT_INITIAL_LENGTH;
    Pipe_State.WorkBuf = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            Pipe_State.BufLength
                            );

    if (!Pipe_State.WorkBuf){
        return ERROR_OUTOFMEMORY;
    }

    Pipe_State.ExImCallback = (PVOID) ImportCallback;
    Pipe_State.CallbackContext = CallbackContext;
    Pipe_State.Status = NO_ERROR;
    ImportPipe.state = (char *) &Pipe_State;
    ImportPipe.alloc = EfsPipeAlloc;
    ImportPipe.pull = EfsPipeWrite;
    ImportPipe.push = NULL;


    (VOID) EnablePrivilege(
                 CREATE_FOR_IMPORT,
                 &TokenHandle,
                 &OldPrivs
                 );

    RpcTryExcept{
        RetCode = EfsRpcWriteFileRaw(
                                phContext,
                                &ImportPipe
                                );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            if ( NO_ERROR == Pipe_State.Status ){
                RetCode = RpcExceptionCode();
            } else {
                RetCode =   Pipe_State.Status;
            }
    } RpcEndExcept;

    RestorePrivilege(
        &TokenHandle,
        &OldPrivs
    );

    RtlFreeHeap( RtlProcessHeap(), 0, Pipe_State.WorkBuf );

    return RetCode;
}

void __RPC_FAR
EfsPipeAlloc(
    char __RPC_FAR * State,
    unsigned long ReqSize,
    unsigned char __RPC_FAR * __RPC_FAR * Buf,
    unsigned long __RPC_FAR * RealSize
    )
/*++

Routine Description:

    This routine is required by the RPC pipe. It allocates the memory
    for the push and pull routines.

Arguments:

    State - Pipe status.

    ReqSize - Required buffer sixe in bytes.

    Buf - Buffer pointer.

    RealSize - Size of allocated buffer in bytes.

Return Value:

    None.
*/
{

    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    //
    //  If error had occured, this is the chance to tell the RPC LIB to
    //  stop the pipe work.
    //
    if ( NO_ERROR != Pipe_State->Status){
        *RealSize = 0;
        *Buf = NULL;
    } else {
        if ( ReqSize > Pipe_State->BufLength ){
            *RealSize = Pipe_State->BufLength;
        } else {
            *RealSize = ReqSize;
        }
        *Buf = Pipe_State->WorkBuf;
    }

}

void __RPC_FAR
EfsPipeRead (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteCount
    )
/*++

Routine Description:

    This routine is called by the RPC pipe. It send the exported data to the caller.

Arguments:

    State - Pipe status.

    DataBuf - Buffer pointer.

    ByteCount - Number of bytes to be sent out.

Return Value:

    None.
*/
{
    DWORD HResult;
    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    PFE_EXPORT_FUNC ExportCallback;
    PVOID   CallbackContext;

    ExportCallback = Pipe_State->ExImCallback;
    CallbackContext = Pipe_State->CallbackContext;
    HResult = (*ExportCallback)( DataBuf, CallbackContext, ByteCount);
    if ( NO_ERROR != HResult ){
        Pipe_State->Status = HResult;
    }
}

void __RPC_FAR
EfsPipeWrite (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteRequested,
    unsigned long *ByteFromCaller
    )
/*++

Routine Description:

    This routine is called by the RPC pipe. It requests the imported data from the caller.

Arguments:

    State - Pipe status.

    DataBuf - Buffer pointer.

    ByteRequested - Number of bytes requested to write to the pipe.

    ByteFromCaller - Number of bytes available for writing to the pipe.

Return Value:

    None.


*/
{
    DWORD HResult;
    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    PFE_IMPORT_FUNC ImportCallback;
    PVOID   CallbackContext;

    ImportCallback = Pipe_State->ExImCallback;
    CallbackContext = Pipe_State->CallbackContext;
    *ByteFromCaller = ByteRequested;
    HResult = (*ImportCallback)( DataBuf, CallbackContext, ByteFromCaller);
    if ( NO_ERROR != HResult ){
        Pipe_State->Status = HResult;
    }
}


DWORD
EfsEncryptFileRPCClient(
    UNICODE_STRING *FullFileNameU
    )
/*++

Routine Description:

    This routine is the client side of Encryption API. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FullFileNameU - Supplies the name of the file to be encrypted.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{


    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        FullFileNameU->Buffer,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcEncryptFileSrv(
                                    binding_h,
                                    FullName
                                    );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
EfsDecryptFileRPCClient(
    UNICODE_STRING *FullFileNameU,
    DWORD        dwRecovery
    )
/*++

Routine Description:

    This routine is the client side of Decryption API. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FullFileNameU - Supplies the name of the file to be encrypted.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        FullFileNameU->Buffer,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcDecryptFileSrv(
                                binding_h,
                                FullName,
                                dwRecovery
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;
            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
GetFullName(
    LPCWSTR FileName,
    LPWSTR *FullName,
    LPWSTR *ServerName,
    ULONG   Flags,
    DWORD  *dwCreationDistribution, 
    DWORD   dwAttributes, 
    PSECURITY_DESCRIPTOR pRelativeSD,
    BOOL    bInheritHandle
    )
/*++

Routine Description:

    This routine will extract the server name and the file UNC name from the
    passed in file name.

Arguments:

    FileName - Supplies the name of the file to be parsed.
    FullName - File name used on the server.
    ServerName - The server machine name where the file lives.
    Flags - Indicates if the object is a directory or a file. CREATE_FOR_DIR for directory.
    dwCreationDistribution - How the file should be created.
    dwAtrributes - The attributes for creating a new object.
    pRelativeSD - Security Descriptor.
    bInheritHandle - If the file to be created should inherit the security.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{

    HANDLE FileHdl = 0;
    HANDLE DriverHandle;
    UNICODE_STRING DfsDriverName;
    DWORD RetCode = ERROR_SUCCESS;
    LPWSTR  TmpFullName;
    DWORD FullNameLength;
    DWORD FileNameLength;


    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileNtName;
    NTSTATUS NtStatus;
    BOOL    b = TRUE;
    DWORD   FileAttributes = 0;
    DWORD   CreationDistribution = 0;
    DWORD   CreateOptions = 0;
    ULONG ii, jj;
    BOOL    GotRoot;
    WCHAR *PathName;
    UINT   DriveType;
    PFILE_NAME_INFORMATION FileNameInfo;
    WCHAR  WorkBuffer[MAX_PATH+4];
    DWORD  BufSize;
    DWORD  BufferLength;

    NETRESOURCEW RemotePathResource;
    NETRESOURCEW *pNetInfo;

    FileNameLength = wcslen(FileName);

    BufferLength = (FileNameLength + 1) <= MAX_PATH ?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (FileNameLength + 1) * sizeof (WCHAR);
    PathName = (WCHAR *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            BufferLength
                            );

    if ( !PathName  ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    GotRoot = GetVolumePathNameW(
                    FileName,
                    PathName,
                    BufferLength / sizeof(WCHAR)
                    );

    if (!GotRoot) {
        RetCode = GetLastError();
        RtlFreeHeap( RtlProcessHeap(), 0, PathName );
        return RetCode;
    }

    DriveType = GetDriveTypeW(PathName);
    RtlFreeHeap( RtlProcessHeap(), 0, PathName );

    if (DriveType == DRIVE_REMOTE){

        if ((Flags & CREATE_FOR_IMPORT) || (dwAttributes !=0) ) {

            //
            // Called from OpenRaw or DuplicateInfo.
            // Use NtCreateFile()
            //

            FileAttributes = GetFileAttributesW( FileName );

            if (dwAttributes) {

                //
                // From dup
                //

    
                if (-1 != FileAttributes) {

                    //
                    // File existed
                    //

                    if ( dwCreationDistribution && (*dwCreationDistribution == CREATE_NEW) ){
        
                        return ERROR_FILE_EXISTS;
        
                    }

                    CreationDistribution = FILE_OPEN;
                    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        if ((Flags & CREATE_FOR_DIR) == 0) {
                            return ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;
                        }
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        
                    }
    
                } else {

                    //
                    // Destination not existing
                    //

                    CreationDistribution = FILE_CREATE;
                    if (dwCreationDistribution && (*dwCreationDistribution == CREATE_NEW) ) {
                        *dwCreationDistribution = CREATE_ALWAYS;
                    }
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    } else {
                        CreateOptions |= FILE_NO_COMPRESSION;
                    }


                }

            } else {

                //
                // From OpenRaw import
                //

                dwAttributes = FILE_ATTRIBUTE_NORMAL;
                CreateOptions = FILE_OPEN_FOR_BACKUP_INTENT;

                if (-1 == FileAttributes) {

                    CreationDistribution = FILE_CREATE;
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    } else {
                        CreateOptions |= FILE_NO_COMPRESSION;
                    }

                } else {

                    //
                    // File already existing
                    //

                    CreationDistribution = FILE_OPEN;
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    }
                }


            }


            RtlInitUnicodeString(
                &FileNtName,
                NULL
                );

            b =  RtlDosPathNameToNtPathName_U(
                                FileName,
                                &FileNtName,
                                NULL,
                                NULL
                                );

            if (b) {

                dwAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED | FILE_ATTRIBUTE_READONLY);
        
                InitializeObjectAttributes(
                            &Obja,
                            &FileNtName,
                            bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                            0,
                            pRelativeSD? ((PEFS_RPC_BLOB)pRelativeSD)->pbData:NULL
                            );
        
                NtStatus = NtCreateFile(
                                &FileHdl,
                                FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                dwAttributes,
                                0,
                                CreationDistribution,
                                CreateOptions,
                                NULL,
                                0
                                );


                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    FileNtName.Buffer
                    );

                if (!NT_SUCCESS(NtStatus)) {
                    return (RtlNtStatusToDosError( NtStatus ));
                }
            } else {
                return ERROR_PATH_NOT_FOUND;
            }


        } else {

            FileHdl = CreateFileW(
                FileName,
                FILE_READ_ATTRIBUTES,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL
                );
            if (INVALID_HANDLE_VALUE == FileHdl) {
                RetCode = GetLastError();
                return RetCode;
            }

        }


        FileNameInfo = (PFILE_NAME_INFORMATION) WorkBuffer;
        BufSize = sizeof (WorkBuffer);

        do {

          NtStatus = NtQueryInformationFile(
                         FileHdl,
                         &IoStatusBlock,
                         FileNameInfo,
                         BufSize,
                         FileNameInformation
                         );
          if ( NtStatus == STATUS_BUFFER_OVERFLOW || NtStatus == STATUS_BUFFER_TOO_SMALL ) {

              BufSize *= 2;
              if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                  RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
              }
              FileNameInfo = (PFILE_NAME_INFORMATION) RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                BufSize
                                );
              if (!FileNameInfo) {
                  CloseHandle(FileHdl);
                  return ERROR_NOT_ENOUGH_MEMORY;
              }

          }
        } while (NtStatus == STATUS_BUFFER_OVERFLOW || NtStatus == STATUS_BUFFER_TOO_SMALL);

        CloseHandle(FileHdl);
        if (!NT_SUCCESS(NtStatus)) {
            if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
            }
            return RtlNtStatusToDosError(NtStatus);
        } else {
            ASSERT((FileNameInfo->FileName)[ 0 ] == L'\\');
        }

        //
        // We got the UNC name
        //

        *FullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    FileNameInfo->FileNameLength+2*sizeof (WCHAR)
                    );
    
        *ServerName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    ( MAX_PATH + 1) * sizeof (WCHAR)
                    );

        if ( (NULL == *FullName) || (NULL == *ServerName) ){
    
            if ( *FullName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                *FullName = NULL;
            }
            if ( *ServerName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *ServerName );
                *ServerName = NULL;
            }

            if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
            }
    
            return ERROR_NOT_ENOUGH_MEMORY;
    
        }

    } else {

        //
        // The path is local
        //

        *FullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    (FileNameLength + 1) * sizeof (WCHAR)
                    );
    
        *ServerName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    8 * sizeof (WCHAR)
                    );

        //
        // Use . for local case.
        //

        if ( (NULL == *FullName) || (NULL == *ServerName) ){
    
            if ( *FullName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                *FullName = NULL;
            }
            if ( *ServerName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *ServerName );
                *ServerName = NULL;
            }
    
            return ERROR_NOT_ENOUGH_MEMORY;
    
        }

        wcscpy ( *ServerName, L".");
        wcscpy ( *FullName, FileName);
        return ERROR_SUCCESS;

    }


    //
    // Let's get the UNC server and path name
    //

    FullNameLength = FileNameInfo->FileNameLength;
    ii = jj = 0;

    while ( (FileNameInfo->FileName)[ jj ] == L'\\' ) {
        jj ++;
    }
    while ( jj < FullNameLength/sizeof(WCHAR) && ((FileNameInfo->FileName)[ jj ] != L'\\') ){
        (*ServerName)[ii++] = (FileNameInfo->FileName)[ jj++ ];
    }
    (*ServerName)[ii] = 0;

    if (FileNameInfo->FileName[0] == L'\\' && FileNameInfo->FileName[1] != L'\\' ) {

        //
        // NtQueryInformationFile returns \server\share\...
        //

        (*FullName)[0] = L'\\';
        wcsncpy( &((*FullName)[1]), &FileNameInfo->FileName[0], FullNameLength/sizeof(WCHAR) );
        (*FullName)[1+FullNameLength/sizeof(WCHAR)] = 0;
    } else{

        //
        // Just in case we get \\server\share\...
        //

        wcsncpy( &((*FullName)[0]), &FileNameInfo->FileName[0], FullNameLength/sizeof(WCHAR) );
        (*FullName)[FullNameLength/sizeof(WCHAR)] = 0;
    }

    //
    // WorkBuffer is freed here. It can be reused from here.
    //

    if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
    }

    //
    //  This is a workaround to test DFS path.
    //  Let's see if the path could be a DFS path or not
    //


    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    InitializeObjectAttributes(
         &Obja,
         &DfsDriverName,
         OBJ_CASE_INSENSITIVE,
         NULL,
         NULL
    );

    NtStatus = NtCreateFile(
                        &DriverHandle,
                        SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

    if ( NT_SUCCESS( NtStatus ) ){

        //
        // DfsDriver opened successfully
        //

        TmpFullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    FullNameLength + 2*sizeof (WCHAR)
                    );

        if (TmpFullName) {

            NtStatus = NtFsControlFile(
                                DriverHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DFS_GET_SERVER_NAME,
                                *FullName,
                                FullNameLength + 2*sizeof (WCHAR) ,
                                TmpFullName,
                                FullNameLength + 2* sizeof (WCHAR)
                                );
    
            if ( STATUS_BUFFER_OVERFLOW == NtStatus ){

                ULONG OldFullNameLength = FullNameLength;

                FullNameLength = *(ULONG *)TmpFullName + sizeof (WCHAR);
                RtlFreeHeap( RtlProcessHeap(), 0, TmpFullName );
                TmpFullName = RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                FullNameLength
                                );
    
                if (NULL == TmpFullName){

                    //
                    // Remember this is just a workaround.
                    // Let's assume this is not DFS path. If it is, it will fail later anyway.
                    //
                    
                    NtClose( DriverHandle );
                    DriverHandle = NULL;
    
                } else {

                    NtStatus = NtFsControlFile(
                                    DriverHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_DFS_GET_SERVER_NAME,
                                    *FullName,
                                    OldFullNameLength + 2*sizeof (WCHAR) ,
                                    TmpFullName,
                                    FullNameLength
                                    );
                }
    
    
            }

            if (TmpFullName) {

                if ( NT_SUCCESS( NtStatus ) ){
            
                    //
                    // The name is a DFS file name. Use the name in the TmpFullName
                    //
            
                    RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                    *FullName = TmpFullName;
    
                    //
                    // Reset the server name
                    //
    
                    ii = jj = 0;
                
                    while ( (*FullName)[ jj ] == L'\\' ) {
                        jj ++;
                    }
                    while ( ((*FullName)[ jj ]) && ((*FullName)[ jj ] != L'\\') ){
                        (*ServerName)[ii++] = (*FullName)[ jj++ ];
                    }
                    (*ServerName)[ii] = 0;
                
                }  else  {
    
                    //
                    // Not a DFS name
                    //
    
                    RtlFreeHeap( RtlProcessHeap(), 0, TmpFullName );
    
                }
            }

        }

        if (DriverHandle) {
            NtClose( DriverHandle );
        }
    }

    //
    // Let's see if the path is a WEB DAV path or not
    //

    BufSize = 1024; //If not enough, we will allocate more

    pNetInfo =  (NETRESOURCEW *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            BufSize
                            );

    //
    // If we can't decide if the path is WEBDAV path, we assume not.
    // Error will be returned later if it turns out to be a WEBDAV Share.
    //

    if (pNetInfo) {
    
        LPWSTR  lpSysName;

        RemotePathResource.dwScope = RESOURCE_CONNECTED;
        RemotePathResource.dwType = RESOURCETYPE_DISK;
        RemotePathResource.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        RemotePathResource.dwUsage = 0;
        RemotePathResource.lpLocalName = NULL;
        RemotePathResource.lpRemoteName = *FullName;
        RemotePathResource.lpComment = NULL;
        RemotePathResource.lpProvider = NULL;
        RetCode = WNetGetResourceInformationW (
                      &RemotePathResource, // network resource
                      (LPVOID) pNetInfo,   // information buffer
                      (LPDWORD) &BufSize,  // size of information buffer
                      &lpSysName           
                      );
        if (RetCode == ERROR_MORE_DATA) {

            //
            // This is not likely to happen
            //

            RtlFreeHeap( RtlProcessHeap(), 0, pNetInfo );

            pNetInfo =  (NETRESOURCEW *) RtlAllocateHeap(
                                    RtlProcessHeap(),
                                    0,
                                    BufSize
                                    );
            if (pNetInfo) {

                RetCode = WNetGetResourceInformationW (
                              &RemotePathResource, // network resource
                              (LPVOID) pNetInfo,   // information buffer
                              (LPDWORD) &BufSize,  // size of information buffer
                              &lpSysName           
                              );

            } else {

                RetCode = ERROR_NOT_ENOUGH_MEMORY; 
            }


        }

        if (ERROR_SUCCESS == RetCode) {

            WCHAR *WebDavPath;
            DWORD DavNameLength;

            WebDavPath = WorkBuffer;
            DavNameLength = sizeof(WorkBuffer) / sizeof (WCHAR);

            RetCode = WNetGetProviderNameW(
                                WNNC_NET_DAV,
                                WebDavPath,
                                &DavNameLength
                                );

            if (ERROR_SUCCESS != RetCode) {

                if ( ERROR_MORE_DATA == RetCode) {

                    WebDavPath = RtlAllocateHeap(
                                    RtlProcessHeap(),
                                    0,
                                    DavNameLength * sizeof (WCHAR)
                                    );
                    if (WebDavPath) {

                        RetCode = WNetGetProviderNameW(
                                            WNNC_NET_DAV, 
                                            WebDavPath,
                                            &DavNameLength
                                            );
                    } else {

                        RetCode = ERROR_NOT_ENOUGH_MEMORY;

                    }

                } 
            }



            //
            // Check to see if the provider is WEBDAV
            //

            if ((ERROR_SUCCESS == RetCode) && !wcscmp(WebDavPath, pNetInfo->lpProvider)){

                //
                // This is the WEBDAV. Let's redo the name.
                //

                RtlFreeHeap( RtlProcessHeap(), 0, pNetInfo );
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );

                if (WebDavPath && (WebDavPath != WorkBuffer)) {
                    RtlFreeHeap( RtlProcessHeap(), 0, WebDavPath );
                }

                
                *FullName = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            (FileNameLength + 3) * sizeof (WCHAR)
                            );
            
        
                //
                // Use . for local case.
                //

                if (*FullName) {
                    wcscpy ( *ServerName, L".");
                    (*FullName)[0] = DAVHEADER;
                    (*FullName)[1] = 0;
                    wcscat ( *FullName, FileName);
                    return ERROR_SUCCESS;

                } else {

                    //
                    // Out of memory
                    //

                    RtlFreeHeap( RtlProcessHeap(), 0, *ServerName );
                    *ServerName = NULL;
            
                    return ERROR_NOT_ENOUGH_MEMORY;

                }
        

            }

            if (WebDavPath && (WebDavPath != WorkBuffer)) {

                RtlFreeHeap( RtlProcessHeap(), 0, WebDavPath );

            }

        }

        if (pNetInfo) {
            RtlFreeHeap( RtlProcessHeap(), 0, pNetInfo );
        }

    }

    return ERROR_SUCCESS;


}

//
// Beta 2 API
//

DWORD
EfsAddUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ) {
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcAddUsersToFile(
                                binding_h,
                                FullName,
                                pEncryptionCertificates
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}



DWORD
EfsRemoveUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcRemoveUsersFromFile(
                                binding_h,
                                FullName,
                                pHashes
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
EfsQueryRecoveryAgentsRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    //
    // Clear out this parameter, or RPC will choke on the server
    // side.
    //

    *pRecoveryAgents = NULL;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcQueryRecoveryAgents(
                                binding_h,
                                FullName,
                                pRecoveryAgents
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}


DWORD
EfsQueryUsersRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   LPWSTR  FullName;
   LPWSTR  Server;

   //
   // Clear out this parameter, or RPC will choke on the server
   // side.
   //

   *pUsers = NULL;

   RetCode = GetFullName(
       lpFileName,
       &FullName,
       &Server,
       0,
       NULL,
       0,
       NULL,
       FALSE
       );

   if ( RetCode == ERROR_SUCCESS ){

       Status = RpcpBindRpc (
                    Server,
                    L"lsarpc",
                    0,
                    &binding_h
                    );

       if (NT_SUCCESS(Status)){
           RpcTryExcept {
               RetCode = EfsRpcQueryUsersOnFile(
                               binding_h,
                               FullName,
                               pUsers
                               );

               if ((ERROR_SUCCESS == RetCode) && !(*pUsers)) {

                   //
                   // The server is hacked? There should always be one user on the file.
                   //

                   RetCode = ERROR_DEV_NOT_EXIST;

               }

           } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
               RetCode = RpcExceptionCode();
           } RpcEndExcept;

           //
           // Free the binding handle
           //

           RpcpUnbindRpc( binding_h );

       } else {

           RetCode = RtlNtStatusToDosError( Status );
       }
       RtlFreeHeap( RtlProcessHeap(), 0, FullName );
       RtlFreeHeap( RtlProcessHeap(), 0, Server );
   }

   return RetCode;
}


DWORD
EfsSetEncryptionKeyRPCClient(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   WCHAR ServerName[3 ];


   wcscpy(&ServerName[0], L".");

   Status = RpcpBindRpc (
                 &ServerName[0],
                 L"lsarpc",
                 0,
                 &binding_h
                 );

   if (NT_SUCCESS(Status)){
       RpcTryExcept {

           RetCode = EfsRpcSetFileEncryptionKey(
                          binding_h,
                          pEncryptionCertificate
                          );

       } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
           RetCode = RpcExceptionCode();
       } RpcEndExcept;

       //
       // Free the binding handle
       //

       RpcpUnbindRpc( binding_h );

    } else {

        RetCode = RtlNtStatusToDosError( Status );
    }


    return RetCode;
}


DWORD
EfsDuplicateEncryptionInfoRPCClient(
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   LPWSTR  SrcServer;
   LPWSTR  DestServer;

   LPWSTR FullSrcName;
   LPWSTR FullDestName;
   DWORD  FileAttribute;
   DWORD  MyCreationDistribution = dwCreationDistribution;
   DWORD  Flags = 0;

   RetCode = GetFullName(
               lpSrcFileName,
               &FullSrcName,
               &SrcServer,
               0,
               NULL,
               0,
               NULL,
               FALSE
               );

   if (RetCode == ERROR_SUCCESS) {

       FileAttribute = GetFileAttributesW(lpSrcFileName);
       if (-1 != FileAttribute) {
           if (FileAttribute & FILE_ATTRIBUTE_DIRECTORY) {
               Flags = CREATE_FOR_DIR;
           }
       }

       if (dwAttributes == 0) {
           FileAttribute = FILE_ATTRIBUTE_NORMAL;
       } else {
           FileAttribute = dwAttributes; 
       }

       RetCode = GetFullName(
                   lpDestFileName,
                   &FullDestName,
                   &DestServer,
                   Flags,
                   &MyCreationDistribution,
                   FileAttribute,
                   pRelativeSD,
                   bInheritHandle
                   );

       if (RetCode == ERROR_SUCCESS) {

           BOOL SamePC = TRUE;

           //
           // Only do this if they're on the same server.
           //

           SamePC = (_wcsicmp( SrcServer, DestServer ) == 0);
           if (!SamePC) {

               //
               //  Check loopback case.
               //

               if ((wcscmp( SrcServer, L".") == 0) || (wcscmp( DestServer, L".") == 0)){

                   WCHAR MyComputerName[( MAX_COMPUTERNAME_LENGTH + 1) * sizeof (WCHAR)];
                   DWORD WorkBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                   BOOL  b;
    
                   b = GetComputerNameW(
                               MyComputerName,
                               &WorkBufferLength
                               );
                   if (b) {
                       if (wcscmp( SrcServer, L".") == 0) {
                           SamePC = (_wcsicmp( MyComputerName, DestServer ) == 0); 
                       } else {
                           SamePC = (_wcsicmp( MyComputerName, SrcServer ) == 0); 
                       }
                   }

               }
           }

           if (SamePC) {

               Status = RpcpBindRpc (
                            SrcServer,
                            L"lsarpc",
                            0,
                            &binding_h
                            );

               if (NT_SUCCESS(Status)){
                   RpcTryExcept {

                       RetCode = EfsRpcDuplicateEncryptionInfoFile(
                                     binding_h,
                                     FullSrcName,
                                     FullDestName,
                                     MyCreationDistribution, 
                                     dwAttributes, 
                                     pRelativeSD,
                                     bInheritHandle
                                     );

                   } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                       RetCode = RpcExceptionCode();
                   } RpcEndExcept;

                   //
                   // Free the binding handle
                   //

                   RpcpUnbindRpc( binding_h );

               } else {

                   RetCode = RtlNtStatusToDosError( Status );
               }

           } else {

               RetCode = ERROR_INVALID_PARAMETER;
           }

           RtlFreeHeap( RtlProcessHeap(), 0, FullDestName );
           RtlFreeHeap( RtlProcessHeap(), 0, DestServer );
       }

       if ((RetCode != ERROR_SUCCESS) && (RetCode != ERROR_FILE_EXISTS) && (CREATE_NEW == dwCreationDistribution)) {

           //
           // Let's delete the file. This is the best effort. No return code is to be
           // checked.
           //

           DeleteFileW(lpDestFileName);

       }

       RtlFreeHeap( RtlProcessHeap(), 0, FullSrcName );
       RtlFreeHeap( RtlProcessHeap(), 0, SrcServer );
   }


   return RetCode;
}


DWORD
EfsFileKeyInfoRPCClient(
    IN LPCWSTR lpFileName,
    IN DWORD   InfoClass,
    OUT PEFS_RPC_BLOB *KeyInfo
    )
{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;
 
    //
    // Clear out this parameter, or RPC will choke on the server
    // side.
    //
 
    if (KeyInfo) {
        *KeyInfo = NULL;
    }
 
    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        NULL,
        0,
        NULL,
        FALSE
        );
 
    if ( RetCode == ERROR_SUCCESS ){
 
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );
 
        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcFileKeyInfo(
                                binding_h,
                                FullName,
                                InfoClass,
                                KeyInfo
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;
 
            //
            // Free the binding handle
            //
 
            RpcpUnbindRpc( binding_h );
 
        } else {
 
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }
 
    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\lsaclip.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaclip.h

Abstract:

    LSA - Client Side private includes

Author:

    Scott Birrell       (ScottBi)      January 23, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>
// #include "lsarpc_c.h"
#include <rpcndr.h>

NTSTATUS
LsapEncryptAuthInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ClearAuthInfo,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *EncryptedAuthInfo
);

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );


NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\lsarpc_c_stub.c ===
#include "lsarpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\rpcapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rpcapi.c

Abstract:

    This module contains the routines for the LSA API that use RPC.  The
    routines in this module are merely wrappers that work as follows:

    o Client program calls LsaFoo in this module
    o LsaFoo calls RPC client stub interface routine LsapFoo with
      similar parameters.  Some parameters are translated from types
      (e.g structures containing PVOIDs or certain kinds of variable length
      parameters such as pointers to SID's) that are not specifiable on an
      RPC interface, to specifiable form.
    o RPC client stub LsapFoo calls interface specific marshalling routines
      and RPC runtime to marshal parameters into a buffer and send them over
      to the server side of the LSA.
    o Server side calls RPC runtime and interface specific unmarshalling
      routines to unmarshal parameters.
    o Server side calls worker LsapFoo to perform API function.
    o Server side marshals response/output parameters and communicates these
      back to client stub LsapFoo
    o LsapFoo exits back to LsaFoo which returns to client program.

Author:

    Scott Birrell     (ScottBi)    April 24, 1991

Revision History:

--*/

#include "lsaclip.h"
#include <align.h>
#include <rpcasync.h>

//
// Functions private to this module
//

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );

BOOLEAN
LsapNeutralizeNt4Emulation()
{
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    HKEY hkey;
    DWORD Type;
    DWORD Value;
    DWORD Size = sizeof( Value );
    static DWORD AmIDC = 0xFFFFFFFF;
    ULONG i;
    CHAR * Paths[] = {
        "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters\\GpParameters",
        "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
    };

    //
    // NT4 emulation is always disabled on domain controllers
    //

    if ( AmIDC == 0xFFFFFFFF ) {

        NT_PRODUCT_TYPE ProductType = NtProductWinNt;

        if ( TRUE == RtlGetNtProductType( &ProductType )) {

            if ( ProductType == NtProductLanManNt ) {

                AmIDC = TRUE;

            } else {

                AmIDC = FALSE;
            }
        }
    }

    if ( AmIDC == TRUE ) {

        return TRUE;
    }

    //
    // This is not a DC; must go to the registry for the special "neutralize" value
    // which could be either under NetLogon or NetLogon/GroupPolicy parameters key
    //

    for ( i = 0; i < sizeof( Paths ) / sizeof( Paths[0] ); i++ ) {

        if ( ERROR_SUCCESS != RegOpenKeyEx(
                                  HKEY_LOCAL_MACHINE,
                                  Paths[i],
                                  0,
                                  KEY_READ,
                                  &hkey )) {

            continue;
        }

        if ( ERROR_SUCCESS != RegQueryValueEx(
                                  hkey,
                                  "NeutralizeNt4Emulator",
                                  NULL,
                                  &Type,
                                  (LPBYTE)&Value,
                                  &Size ) ||
             Type != REG_DWORD ||
             Size != sizeof( DWORD )) {

            RegCloseKey( hkey );
            continue;

        } else {

            RegCloseKey( hkey );
            Result = ( Value != 0 );
            break;
        }
    }

    return Result;
}

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API function prototypes           //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsaOpenPolicy(
    IN OPTIONAL PUNICODE_STRING SystemName,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    To administer the Local Security Policy of a local or remote system,
    this API must be called to establish a session with that system's
    Local Security Authority (LSA) subsystem.  This API connects to
    the LSA of the target system and opens the object representing
    the target system's Local Security Policy database.  A handle to
    the object is returned.  This handle must be used on all subsequent API
    calls to administer the Local Security Policy information for the
    target system.

Arguments:

    SystemName - Name of the target system to be administered.
        Administration of the local system is assumed if NULL is specified.

    ObjectAttributes - Pointer to the set of attributes to use for this
        connection.  The security Quality Of Service information is used and
        normally should provide Security Identification level of
        impersonation.  Some operations, however, require Security
        Impersonation level of impersonation.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target LsaDatabase object to determine whether the
        accesses will be granted or denied.

    PolicyHandle - Receives a handle to be used in future requests to
        access the Local Security Policy of the target system.  This handle
        represents both the handle to the LsaDatabase object and
        the RPC Context Handle for the connection to the target LSA
        susbsystem.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;
    LSA_HANDLE LocalHandle = NULL ;

    RpcTryExcept {

        //
        // Get the Server Name as a Unicode String buffer.  Set it to
        // NULL (i.e. local machine) if a zero length or NULL Unicode String
        // structure us passed.  If a non NULL server name is given, we must
        // ensure that it is terminated with a NULL wide character.  Allocate
        // a buffer that is one wide character longer than the server name
        // buffer, copy the server name to that buffer and append a trailing
        // NULL wide character.
        //

        if (ARGUMENT_PRESENT(SystemName) &&
            (SystemName->Buffer != NULL) &&
            (SystemName->Length > 0)) {

            NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

            ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

            if (ServerName != NULL) {

                RtlMoveMemory(
                    ServerName,
                    SystemName->Buffer,
                    SystemName->Length
                    );

                ServerName[SystemName->Length / sizeof( WCHAR )] = L'\0';

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status)) {

            *PolicyHandle = NULL;

            ObjectAttributes->RootDirectory = NULL;

            Status = LsarOpenPolicy2(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the open failed because the new API doesn't exist, try the
    // old one.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {
            ASSERT(*PolicyHandle == NULL);
            ASSERT(ObjectAttributes->RootDirectory == NULL);

            Status = LsarOpenPolicy(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );


        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

    }

    //
    // If necessary, free the NULL-terminated server name buffer.
    //

    if (ServerName != NULL) {

        MIDL_user_free( ServerName );
    }

    if ( NT_SUCCESS( Status ) ) {

        *PolicyHandle = LocalHandle;
    }

    return Status;
}


NTSTATUS
LsaOpenPolicySce(
    IN OPTIONAL PUNICODE_STRING SystemName,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    Essentially the same as LsaOpenPolicy, except used only by SCE
    to obtain a special "synchronized" policy handle that would serialize
    access to policy operations.

Arguments:

    Same as LsaOpenPolicy

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

        STATUS_PRIVILEGE_NOT_HELD - Caller must come in with TCB privilege.

        STATUS_TIMEOUT - Timed out waiting on SCE to send pending changes

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;
    LSA_HANDLE LocalHandle = NULL ;

    RpcTryExcept {

        //
        // Get the Server Name as a Unicode String buffer.  Set it to
        // NULL (i.e. local machine) if a zero length or NULL Unicode String
        // structure us passed.  If a non NULL server name is given, we must
        // ensure that it is terminated with a NULL wide character.  Allocate
        // a buffer that is one wide character longer than the server name
        // buffer, copy the server name to that buffer and append a trailing
        // NULL wide character.
        //

        if (ARGUMENT_PRESENT(SystemName) &&
            (SystemName->Buffer != NULL) &&
            (SystemName->Length > 0)) {

            NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

            ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

            if (ServerName != NULL) {

                RtlMoveMemory(
                    ServerName,
                    SystemName->Buffer,
                    SystemName->Length
                    );

                ServerName[SystemName->Length / sizeof( WCHAR )] = L'\0';

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status)) {

            *PolicyHandle = NULL;

            ObjectAttributes->RootDirectory = NULL;

            Status = LsarOpenPolicySce(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If necessary, free the NULL-terminated server name buffer.
    //

    if (ServerName != NULL) {

        MIDL_user_free( ServerName );
    }

    if ( NT_SUCCESS( Status ) ) {

        *PolicyHandle = LocalHandle;
    }

    return Status;
}


NTSTATUS
LsaQueryInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION

    Buffer - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        Others TBS
--*/

{
    NTSTATUS   Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation;

    if ( InformationClass == PolicyDnsDomainInformationInt ) {

        return STATUS_INVALID_PARAMETER;
    }

Retry:

    PolicyInformation = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationPolicy.
        //

        switch (InformationClass)
        {
        case PolicyDnsDomainInformation:
        case PolicyDnsDomainInformationInt:
            Status = LsarQueryInformationPolicy2(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         &PolicyInformation
                         );
            break;

        default:
            Status = LsarQueryInformationPolicy(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         &PolicyInformation
                         );
        }

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //

        *Buffer = PolicyInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Policy Information,
        // free it.
        //

        if (PolicyInformation != NULL) {

            MIDL_user_free(PolicyInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If we suspect that the call failed due to NT4 emulation by the server,
    // and we're configured to neutralize emulation, try the call again, neutralizing
    //

    if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE &&
         InformationClass == PolicyDnsDomainInformation &&
         LsapNeutralizeNt4Emulation()) {

         InformationClass = PolicyDnsDomainInformationInt;
         goto Retry;
    }

    return Status;
}


NTSTATUS
LsaSetInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyAuditLogInformation         POLICY_AUDIT_LOG_ADMIN
        PolicyAuditEventsInformation      POLICY_SET_AUDIT_REQUIREMENTS
        PolicyPrimaryDomainInformation    POLICY_TRUST_ADMIN
        PolicyAccountDomainInformation    POLICY_TRUST_ADMIN
        PolicyPdAccountInformation        Not settable by this API
        PolicyLsaServerRoleInformation    POLICY_SERVER_ADMIN
        PolicyReplicaSourceInformation    POLICY_SERVER_ADMIN
        PolicyDefaultQuotaInformation     POLICY_SET_DEFAULT_QUOTA_LIMITS
        PolicyDnsDomainInformation        POLICY_DNS_DOMAIN_INFO
        PolicyDnsDomainInformationInt     POLICY_DNS_DOMAIN_INFO

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS   Status;

    if ( InformationClass == PolicyDnsDomainInformationInt ) {

        return STATUS_INVALID_PARAMETER;
    }

Retry:

    RpcTryExcept {

        //
        // Call the Client Stub for LsaSetInformationPolicy.
        //

        switch (InformationClass)
        {
        case PolicyDnsDomainInformation:
        case PolicyDnsDomainInformationInt:
            Status = LsarSetInformationPolicy2(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         (PLSAPR_POLICY_INFORMATION) Buffer
                         );
            break;

        default:
            Status = LsarSetInformationPolicy(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         (PLSAPR_POLICY_INFORMATION) Buffer
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If we suspect that the call failed due to NT4 emulation by the server,
    // and we're configured to neutralize emulation, try the call again, neutralizing
    //

    if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE &&
         InformationClass == PolicyDnsDomainInformation &&
         LsapNeutralizeNt4Emulation()) {

         InformationClass = PolicyDnsDomainInformationInt;
         goto Retry;
    }

    return Status;
}


NTSTATUS
LsaClearAuditLog(
    IN LSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function clears the Audit Log.  Caller must have POLICY_AUDIT_LOG_ADMIN
    access to the Policy Object to perform this operation.

Arguments:

    PolicyHandle - handle from an LsaOpenPolicy call.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the required access
            to perform the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy Object.
--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClearAuditLog.
        //

        Status = LsarClearAuditLog(
                     (LSAPR_HANDLE) PolicyHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}



NTSTATUS
LsaLookupPrivilegeValue(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING Name,
    OUT PLUID Value
    )

/*++

Routine Description:

    This function retrieves the value used on the target system
    to locally represent the specified privilege.  The privilege
    is specified by programmatic name.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - Is the privilege's programmatic name.

    Value - Receives the locally unique ID the privilege is known by on the
        target machine.



Return Value:

    NTSTATUS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    LUID Buffer;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeValue.
        //

        Status = LsarLookupPrivilegeValue(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING)Name,
                     &Buffer
                     );

        *Value = Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaLookupPrivilegeName(
    IN LSA_HANDLE PolicyHandle,
    IN PLUID Value,
    OUT PUNICODE_STRING *Name
    )

/*++

Routine Description:

    This function programmatic name corresponding to the privilege
    represented on the target system by the provided LUID.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Value - is the locally unique ID the privilege is known by on the
        target machine.

    Name - Receives the privilege's programmatic name.



Return Value:

    NTSTATUS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    PLSAPR_UNICODE_STRING Buffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeName.
        //

        Status = LsarLookupPrivilegeName(
                     (LSAPR_HANDLE) PolicyHandle,
                     Value,
                     &Buffer
                     );

        (*Name) = (PUNICODE_STRING)Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (Buffer != NULL) {

            MIDL_user_free(Buffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaLookupPrivilegeDisplayName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING *DisplayName,
    OUT PSHORT LanguageReturned
    )

/*++

Routine Description:

    This function retrieves a displayable name representing the
    specified privilege.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - The programmatic privilege name to look up.

    DisplayName - Receives a pointer to the privilege's displayable
        name.

    LanguageReturned - Receives the language of the returned displayable
        name.


Return Value:

    NTSTATUS - The privilege text was found and returned.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.


    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/
{
    NTSTATUS Status;
    SHORT ClientLanguage, ClientSystemDefaultLanguage;
    PLSAPR_UNICODE_STRING Buffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeDisplayName.
        //

        ClientLanguage = (SHORT)NtCurrentTeb()->CurrentLocale;
        ClientSystemDefaultLanguage = ClientLanguage; //no sys default yet
        Status = LsarLookupPrivilegeDisplayName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING)Name,
                     ClientLanguage,
                     ClientSystemDefaultLanguage,
                     &Buffer,
                     (PWORD)LanguageReturned
                     );

        (*DisplayName) = (PUNICODE_STRING)Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (Buffer != NULL) {

            MIDL_user_free(Buffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaClose(
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This API closes a handle to the LsaDatabase object or open object within
    the database.  If a handle to the LsaDatabase object is closed and there
    are no objects still open within the current connection to the LSA, the
    connection is closed.  If a handle to an object within the database is
    closed and the object is marked for DELETE access, the object will be
    deleted when the last handle to that object is closed.

Arguments:

    ObjectHandle - This parameter is either a handle to the LsaDatabase
        object, which represents the entire LSA Database and also a
        connection to the LSA of a target system, or a handle to an
        object within the database.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS   Status;

    LSAPR_HANDLE Handle = (LSAPR_HANDLE) ObjectHandle;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClose.  Note that an additional
        // level of indirection for the context handle parameter is required
        // for the stub, because the server returns a NULL pointer to the handle
        // so that the handle will be unbound by the stub.
        //

        Status = LsarClose( &Handle );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        ULONG Code = RpcExceptionCode();
        // Don't assert on bad handles -- this will cause bogus stress breaks
        // ASSERT(Code != RPC_X_SS_CONTEXT_MISMATCH);
        ASSERT(Code != RPC_S_INVALID_BINDING);
        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (  !NT_SUCCESS(Status)
       && (0 != Handle)) {
        //
        // Make sure in all error cases to remove the client side resources
        // consumed by this handle.
        //
        RpcTryExcept  {
            (void) RpcSsDestroyClientContext(&Handle);
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            //
            // The try/except is for app compat so that bad handles don't bring
            // the process down
            //
            NOTHING;
        } RpcEndExcept;
    }

    ASSERT( Status != STATUS_INVALID_PARAMETER_12 );
    ASSERT( Status != STATUS_INVALID_HANDLE );
    return Status;
}


NTSTATUS
LsaDelete(
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    The LsaDelete API deletes an object.  The object must be
    open for DELETE access.

Arguments:

    ObjectHandle - Handle from an LsaOpen<object-type> call.

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified handle is not valid.

        Result codes from RPC.
--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        //
        // Try calling the new worker routine LsarDeleteObject().  If
        // this fails because it does not exist (versions 1.369 and earlier)
        // then call the old routine LsarDelete().
        //

        Status = LsarDeleteObject((LSAPR_HANDLE *) &ObjectHandle);

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            Status = LsarDelete((LSAPR_HANDLE) ObjectHandle);

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;
    }

    return(Status);
}


NTSTATUS
LsaQuerySecurityObject(
    IN LSA_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    The LsaQuerySecurityObject API returns security information assigned
    to an LSA Database object.

    Based on the caller's access rights and privileges, this procedure will
    return a security descriptor containing any or all of the object's owner
    ID, group ID, discretionary ACL or system ACL.  To read the owner ID,
    group ID, or the discretionary ACL, the caller must be granted
    READ_CONTROL access to the object.  To read the system ACL, the caller must
    have SeSecurityPrivilege privilege.

    This API is modelled after the NtQuerySecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.  The values that may be
        specified are the same as those defined in the NtSetSecurityObject()
        API section.

    SecurityDescriptor - receives a pointer to a buffer containing the
        requested security information.  This information is returned in
        the form of a security descriptor.  The caller is responsible for
        freeing the returned buffer using LsaFreeMemory() when no longer
        needed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    LSAPR_SR_SECURITY_DESCRIPTOR ReturnedSD;
    PLSAPR_SR_SECURITY_DESCRIPTOR PReturnedSD;

    //
    // The retrieved security descriptor is returned via a data structure that
    // looks like:
    //
    //             +-----------------------+
    //             | Length (bytes)        |
    //             |-----------------------|          +--------------+
    //             | SecurityDescriptor ---|--------->| Self-Relative|
    //             +-----------------------+          | Security     |
    //                                                | Descriptor   |
    //                                                +--------------+
    //
    // The first of these buffers is a local stack variable.  The buffer containing
    // the self-relative security descriptor is allocated by the RPC runtime.  The
    // pointer to the self-relative security descriptor is what is passed back to our
    // caller.
    //
    //

    //
    // To prevent RPC from trying to marshal a self-relative security descriptor,
    // make sure its field values are appropriately initialized to zero and null.
    //

    ReturnedSD.Length = 0;
    ReturnedSD.SecurityDescriptor = NULL;

    //
    // Call the server ...
    //


    RpcTryExcept{

        PReturnedSD = &ReturnedSD;

        Status = LsarQuerySecurityObject(
                     (LSAPR_HANDLE) ObjectHandle,
                     SecurityInformation,
                     &PReturnedSD
                     );

        if (NT_SUCCESS(Status)) {

            (*SecurityDescriptor) = ReturnedSD.SecurityDescriptor;

        } else {

            (*SecurityDescriptor) = NULL;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecurityObjectError;
    }

QuerySecurityObjectFinish:

    return(Status);

QuerySecurityObjectError:

    goto QuerySecurityObjectFinish;
}



NTSTATUS
LsaSetSecurityObject(
    IN LSA_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    The LsaSetSecurityObject API takes a well formaed Security Descriptor
    and assigns specified portions of it to an object.  Based on the flags set
    in the SecurityInformation parameter and the caller's access rights, this
    procedure will replace any or alll of the security information associated
    with the object.

    The caller must have WRITE_OWNER access to the object to change the
    owner or Primary group of the object.  The caller must have WRITE_DAC
    access to the object to change the Discretionary ACL.  The caller must
    have SeSecurityPrivilege to assign a system ACL to an object.

    This API is modelled after the NtSetSecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Indicates which security information is to be
        applied to the object.  The values that may be specified are the
        same as those defined in the NtSetSecurityObject() API section.
        The value(s) to be assigned are passed in the SecurityDescriptor
        parameter.

    SecurityDescriptor - A pointer to a well formed Security Descriptor.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    ULONG SDLength;
    LSAPR_SR_SECURITY_DESCRIPTOR DescriptorToPass = { 0 };

    //
    // Make a self relative security descriptor for use in the RPC call..
    //

    SDLength = 0;

    Status = RtlMakeSelfRelativeSD( SecurityDescriptor, NULL, &SDLength);

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetSecurityObjectError;
    }

    DescriptorToPass.SecurityDescriptor = MIDL_user_allocate( SDLength );

    if (DescriptorToPass.SecurityDescriptor == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SetSecurityObjectError;
    }

    //
    // Make an appropriate self-relative security descriptor
    //

    Status = RtlMakeSelfRelativeSD(
                 SecurityDescriptor,
                 (PSECURITY_DESCRIPTOR)DescriptorToPass.SecurityDescriptor,
                 &SDLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

    DescriptorToPass.Length = SDLength;

    RpcTryExcept{

        Status = LsarSetSecurityObject(
                     (LSAPR_HANDLE) ObjectHandle,
                     SecurityInformation,
                     &DescriptorToPass
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

SetSecurityObjectFinish:

    //
    // If necessary, free the Self Relative SD passed to the worker.
    //

    if (DescriptorToPass.SecurityDescriptor != NULL) {

        MIDL_user_free( DescriptorToPass.SecurityDescriptor );

        DescriptorToPass.SecurityDescriptor = NULL;
    }

    return(Status);

SetSecurityObjectError:

    goto SetSecurityObjectFinish;
}



NTSTATUS
LsaChangePassword(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    The LsaChangePassword API is used to change a user account's password.
    The user must have appropriate access to the user account and must
    know the current password value.


Arguments:

    ServerName - The name of the Domain Controller at which the password
        can be changed.

    DomainName - The name of the domain in which the account exists.

    AccountName - The name of the account whose password is to be changed.

    NewPassword - The new password value.

    OldPassword - The old (current) password value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
            contains characters that can't be entered from the keyboard.

        STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
            from being changed.  This may be for an number of reasons,
            including time restrictions on how often a password may be changed
            or length restrictions on the provided (new) password.

            This error might also be returned if the new password matched
            a password in the recent history log for the account.  Security
            administrators indicate how many of the most recently used
            passwords may not be re-used.

        STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
            current password.

        STATUS_NO_SUCH_USER - The SID provided does not lead to a user
            account.

        STATUS_CANT_UPDATE_MASTER - An attempt to update the master copy
            of the password was unsuccessful.  Please try again later.

--*/

{
    NTSTATUS Status;

    DBG_UNREFERENCED_PARAMETER( ServerName );
    DBG_UNREFERENCED_PARAMETER( DomainName );
    DBG_UNREFERENCED_PARAMETER( AccountName );
    DBG_UNREFERENCED_PARAMETER( OldPassword );
    DBG_UNREFERENCED_PARAMETER( NewPassword );

    Status = STATUS_NOT_IMPLEMENTED;

    return(Status);
}



NTSTATUS
LsaCreateAccount(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE AccountHandle
    )

/*++

Routine Description:

    The LsaCreateAccount API adds a user or group account to the
    list of accounts in the target system's LsaDatabase object.  The
    newly added account object is initially placed in the opened state and
    a handle to it is returned.  The caller must have LSA_CREATE_ACCOUNT
    access to the LsaDatabase object.

    Note that no check is made to determine whether there is an account
    of the given Sid in the target system's Primary Domain (if any), nor
    is any check made to verify that the Sid and name describe the same
    account.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    AccountSid - Points to the SID of the Account object.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened account.

    AccountHandle - Receives a handle to the newly created and opened
        account.  This handle is used on subsequent accesses to the account
        until closed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ACCOUNT_ALREADY_EXISTS - A user or group account object having
            the Sid given in AccountInformation already exists.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified,
            one or more of the following apply.

            - CreateDisposition not valid
            - A user or group account having the Sid given AccountInformation
              already exists, but CreateDisposition = LSA_OBJECT_CREATE.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarCreateAccount(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) AccountHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaEnumerateAccounts(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    The LsaEnumerateAccounts API returns information about
    Account objects.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationInformation - Receives a pointer to an array of structures
       each describing an Account object.  Currently, each structure contains
       a pointer to the Account Sid.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to location which receives the number of entries
        returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully, there may be
            more entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.

        STATUS_INVALID_PARAMETER - Invalid parameter.

            - NULL return pointer for enumeration buffer.
--*/

{
    NTSTATUS   Status;

    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    RpcTryExcept {

        //
        // Enumerate the Accounts.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Accounts enumerated this call
        // and a pointer to an array of Account Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Account Info for Domain 0
        //                                      Account Info for Domain 1
        //                                      ...
        //                                      Account Info for Domain
        //                                         (EntriesRead - 1)
        //

        Status = LsarEnumerateAccounts(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaCreateTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

--*/

{
    NTSTATUS   Status;

    *TrustedDomainHandle = NULL;

    RpcTryExcept {

        Status = LsarCreateTrustedDomain(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_TRUST_INFORMATION) TrustedDomainInformation,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaOpenTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenTrustedDomain(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaQueryInfoTrustedDomain(
    IN LSA_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    TrustedDomainHandle - Handle from an LsaOpenTrustedDomain or
        LsaCreateTrustedDomain call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedAccountNameInformation     TRUSTED_QUERY_ACCOUNT_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixInformation           TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status;

    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation = NULL;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
    case TrustedDomainInformationEx2Internal:
    case TrustedDomainFullInformation2Internal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationTrustedDomain.
        //

        Status = LsarQueryInfoTrustedDomain(
                     (LSAPR_HANDLE) TrustedDomainHandle,
                     InformationClass,
                     &TrustedDomainInformation
                     );

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //

        *Buffer = TrustedDomainInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Trusted Domain Information,
        // free it.
        //

        if (TrustedDomainInformation != NULL) {

            MIDL_user_free(TrustedDomainInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaSetInformationTrustedDomain(
    IN LSA_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The LsaSetInformationTrustedDomain API modifies information in the Trusted
    Domain Object.  The caller must have access appropriate to the
    information to be changedin the Policy Object, see the InformationClass
    parameter.

Arguments:

    TrustedDomainHandle -  Handle from an LsaOpenTrustedDomain or
        LsaCreateTrustedDomain call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedAccountInformation         ( Cannot be set )
        TrustedControllersInformation     TRUSTED_SET_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_POSIX_INFORMATION

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - Call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - Handle is invalid or is of the wrong type.

        STATUS_INVALID_PARAMETER - Invalid parameter:
            Information class invalid
            Information class cannot be set
--*/

{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;
    PVOID InternalBuffer;
    TRUSTED_INFORMATION_CLASS InternalInformationClass;

    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL InternalFullBuffer;

    //
    // Initialization
    //

    InternalInformationClass = InformationClass;
    InternalBuffer = Buffer;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedPasswordInformation:
    case TrustedDomainInformationBasic:
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
    case TrustedDomainInformationEx2Internal:
    case TrustedDomainFullInformation2Internal:
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainAuthInformation: {

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( TrustedDomainHandle,
                                      (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) Buffer,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainAuthInformationInternal;
        InternalBuffer = InternalAuthBuffer;
        break;
    }

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainFullInformation: {
        PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullBuffer =
                    (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION) Buffer;

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( TrustedDomainHandle,
                                      &FullBuffer->AuthInformation,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy all of the information into a single new structure.
        //

        InternalFullBuffer.Information = FullBuffer->Information;
        InternalFullBuffer.PosixOffset = FullBuffer->PosixOffset;
        InternalFullBuffer.AuthInformation = *InternalAuthBuffer;

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainFullInformationInternal;
        InternalBuffer = &InternalFullBuffer;
        break;
    }
    }

    //
    // If the information class was morphed,
    //  try the morphed class.
    //

    if ( InternalInformationClass != InformationClass ) {
        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarSetInformationTrustedDomain(
                         (LSAPR_HANDLE) TrustedDomainHandle,
                         InternalInformationClass,
                         (PLSAPR_TRUSTED_DOMAIN_INFO) InternalBuffer
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        //
        // If the morphed info class is valid,
        //  we're all done with this call.
        //  (Otherwise, drop through to try the non-morphed class.)
        //

        if ( Status != RPC_NT_INVALID_TAG ) {
            goto Cleanup;
        }
    }

    //
    // Handle non-morphed information classes.
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarSetInformationTrustedDomain(
                     (LSAPR_HANDLE) TrustedDomainHandle,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}


NTSTATUS
LsaEnumerateTrustedDomains(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    The LsaEnumerateTrustedDomains API returns information about the accounts
    in the target system's Policy object.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    Buffer - Receives a pointer to a buffer containing enumeration
        information.  This buffer is an array of structures of type
        LSA_TRUST_INFORMATION.  If no trusted domains are found,
        NULL is returned.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully, there may be
            more entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.

        STATUS_INVALID_PARAMETER - Invalid parameter.

            - NULL return pointer for enumeration buffer.
--*/

{
    NTSTATUS   Status;

    LSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer;
    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    //
    // Verify that caller has provided a return buffer pointer.
    //

    if (!ARGUMENT_PRESENT(Buffer)) {

        return(STATUS_INVALID_PARAMETER);
    }

    RpcTryExcept {

        //
        // Enumerate the Trusted Domains.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Trusted Domains enumerated this call
        // and a pointer to an array of Trust Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Trust Info for Domain 0
        //                                      Trust Info for Domain 1
        //                                      ...
        //                                      Trust Info for Domain
        //                                         (EntriesRead - 1)
        //
        //

        Status = LsarEnumerateTrustedDomains(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Trust Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}



NTSTATUS
LsaEnumeratePrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This function returnes information about privileges known on this
    system.  This call requires POLICY_VIEW_LOCAL_INFORMATION access
    to the Policy Object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls
    can be made to get all of the information.  To support this feature,
    the caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    variable that has been initialized to 0.

    WARNING!  CURRENTLY, THIS FUNCTION ONLY RETURNS INFORMATION ABOUT
              WELL-KNOWN PRIVILEGES.  LATER, IT WILL RETURN INFORMATION
              ABOUT LOADED PRIVILEGES.
Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.

    EnumerationContext - API specific handle to allow multiple calls
        (see Routine Description).

    Buffer - Receives a pointer to a buffer containing information for
        one or more Privileges.  This information is an array of structures
        of type POLICY_PRIVILEGE_DEFINITION.

        When this information is no longer needed, it must be released by
        passing the returned pointer to LsaFreeMemory().

    PreferedMaximumLength - Prefered maximim length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves as
        a guide.  Due to data conversion between systems with different
        natural data sizes, the actual amount of data returned may be
        greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy object.

        STATUS_ACCESS_DENIED - The caller does not have the necessary
            access to perform the operation.

        STATUS_MORE_ENTRIES - There are more entries, so call again.  This
            is an informational status only.

        STATUS_NO_MORE_ENTRIES - No entries were returned because there
            are no more.

        Errors from RPC.

--*/

{
    NTSTATUS   Status;
    LSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.Entries = 0;
    EnumerationBuffer.Privileges = NULL;

    RpcTryExcept {

        //
        // Enumerate the Privileges.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Privileges enumerated this call
        // and a pointer to an array of Privilege Definition Entries.
        //
        // EnumerationBuffer ->  Entries
        //                       Privileges -> Privilege Definition 0
        //                                      Privilege Definition 1
        //                                      ...
        //                                      Privilege Definition
        //                                         (Entries - 1)
        //

        Status = LsarEnumeratePrivileges(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.Entries;
        *Buffer = EnumerationBuffer.Privileges;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Privileges != NULL) {

            MIDL_user_free(EnumerationBuffer.Privileges);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}



NTSTATUS
LsaCreateSecret(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE SecretHandle
    )

/*++

Routine Description:

    The LsaCreateSecretInLsa API creates a named Secret object in the
    Lsa Database.  Each Secret Object can have two values assigned,
    called the Current Value and the Old Value.  The meaning of these
    values is known to the Secret object creator.  The caller must have
    LSA_CREATE_SECRET access to the LsaDatabase object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    SecretName - Pointer to Unicode String specifying the name of the
        secret.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened secret.

    SecretHandle - Receives a handle to the newly created and opened
        Secret object.  This handle is used on subsequent accesses to
        the object until closed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_COLLISION - A Secret object having the given name
            already exists.

        STATUS_TOO_MANY_SECRETS - The maximum number of Secret objects in the
            system has been reached.

        STATUS_PRIVILEGE_NOT_HELD - ACCESS_SYSTEM_SECURITY was specified as part
            of DesiredAccess mask, but the caller does not hold SE_SECURITY_PRIVILEGE
--*/

{
    NTSTATUS   Status;

    *SecretHandle = NULL;

    RpcTryExcept {

        //
        // Verify that the given SecretName has non-null length.  Currently
        // midl cannot handle this.
        //

        if ((SecretName == NULL) ||
            (SecretName->Buffer == NULL) ||
            (SecretName->Length == 0) ||
            (SecretName->Length > SecretName->MaximumLength)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            Status = LsarCreateSecret(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_UNICODE_STRING) SecretName,
                         DesiredAccess,
                         (PLSAPR_HANDLE) SecretHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaLookupNames2(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Flags,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID2 *Sids
    )

/*++

Routine Description:

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Flags - LSA_LOOKUP_ISOLATED_AS_LOCAL

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.

        STATUS_TOO_MANY_NAMES - Too many Names have been specified.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    ULONG i;

    if ( (NULL == Sids)
      || (NULL == ReferencedDomains  ) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Init the out parameters since LsaICLookupNames expects this
    //
    *ReferencedDomains = NULL;
    *Sids = NULL;

    Status = LsaICLookupNames(
                 PolicyHandle,
                 Flags,
                 Count,
                 Names,
                 (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                 (PLSA_TRANSLATED_SID_EX2*)Sids,
                 LsapLookupWksta,
                 0,
                 &MappedCount,
                 NULL
                 );

    return(Status);
}


NTSTATUS
LsaLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID *Sids
    )

/*++

Routine Description:

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.

        STATUS_TOO_MANY_NAMES - Too many Names have been specified.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    PLSA_TRANSLATED_SID_EX2 SidsEx = NULL;
    ULONG i;

    if ( (NULL == Sids)
      || (NULL == ReferencedDomains  ) ) {

        return STATUS_INVALID_PARAMETER;
    }

    *Sids = NULL;
    *ReferencedDomains = NULL;

    Status = LsaICLookupNames(
                 PolicyHandle,
                 0,
                 Count,
                 Names,
                 (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                 &SidsEx,
                 LsapLookupWksta,
                 LSAIC_NO_LARGE_SID,
                 &MappedCount,
                 NULL
                 );

    if ( SidsEx ) {

        //
        // Some sids were returned -- map the new structure to the old one
        //
        ULONG SizeNeeded = 0;
        PLSA_TRANSLATED_SID TempSids = NULL;

        SizeNeeded = Count * sizeof( LSA_TRANSLATED_SID );
        TempSids = midl_user_allocate( SizeNeeded );
        if ( TempSids ) {

            RtlZeroMemory( TempSids, SizeNeeded );
            for ( i = 0; i < Count; i++ ) {

                TempSids[i].Use = SidsEx[i].Use;

                if (SidTypeDomain == SidsEx[i].Use) {

                    TempSids[i].RelativeId = LSA_UNKNOWN_ID;

                } else if (SidsEx[i].Sid) {

                    ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(SidsEx[i].Sid);
                    TempSids[i].RelativeId = *RtlSubAuthoritySid(SidsEx[i].Sid, (SubAuthCount - 1));

                } else {
                    TempSids[i].RelativeId = 0;
                }

                TempSids[i].DomainIndex = SidsEx[i].DomainIndex;
            }

            *Sids = TempSids;

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            if ( *ReferencedDomains ) {

                midl_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }

        midl_user_free( SidsEx );
    }

    return(Status);
}



NTSTATUS
LsaICLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,
    IN OUT PULONG MappedCount,
    IN OUT PULONG ServerRevision
    )

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupNames
    API.  It is called both from the client side of the Lsa and also
    the server side of the LSA (when calling out to another LSA).  The
    function is identical to the LsaLookupNames API except that there is an
    additional parameter, the LookupLevel parameter.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    LookupOptions - Values to pass through to LsarLookupNames2 and above

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on the
        target machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

    Flags - flags to control the operation of the function.  Currently defined:

            LSAIC_NO_LARGE_SID -- implies only call interfaces that will return
                                  the old style format SID (no more than
                                  28 bytes)

            LSAIC_NT4_TARGET -- target server is known to be NT4

            LSAIC_WIN2K_TARGET -- target server is known to be Win2k

    MappedCount - Pointer to location that contains a count of the Names
        mapped so far.  On exit, this count will be updated.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;
    ULONG  LsaLookupNameRevision = 3;
    LSAPR_TRANSLATED_SIDS_EX2 ReturnedSidsEx2 = { 0, NULL };
    LSAPR_TRANSLATED_SIDS_EX  ReturnedSidsEx  = { 0, NULL };
    LSAPR_TRANSLATED_SIDS     ReturnedSids    = { 0, NULL };

    ULONG Size, SidCount = 0;
    PBYTE NextSid;
    ULONG i;

    ULONG StartingRevision = 3;

    //
    // There are no known clients who pass in a value here
    //
    ASSERT( *ReferencedDomains == NULL );
    ASSERT( *Sids == NULL );

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    *ReferencedDomains = NULL;
    *Sids = NULL;

    //
    // Check that we have not specfied more than the maximum number of names
    // allowed.
    //

    if (Count > LSA_MAXIMUM_LOOKUP_NAMES_COUNT) {

        return(STATUS_TOO_MANY_NAMES);
    }

    if ( ServerRevision ) {
        // The latest client's will prefer the latest servers
        *ServerRevision = LSA_LOOKUP_REVISION_LATEST;
    }

    //
    // Adjust the starting version
    //
    StartingRevision = 3;
    if ((Flags & LSAIC_NO_LARGE_SID)
     || (Flags & LSAIC_WIN2K_TARGET) ) {
        StartingRevision = 2;
    }
    if (Flags & LSAIC_NT4_TARGET) {
        StartingRevision = 1;
    }

    switch (StartingRevision) {
    case 3:

        RpcTryExcept {

            Status = LsarLookupNames3(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSidsEx2,
                         LookupLevel,
                         MappedCount,
                         LookupOptions,
                         LSA_LOOKUP_REVISION_LATEST
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 2:

        RpcTryExcept {

            Status = LsarLookupNames2(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSidsEx,
                         LookupLevel,
                         MappedCount,
                         LookupOptions,
                         LSA_LOOKUP_REVISION_LATEST
                         );

            LsaLookupNameRevision = 2;
            if ( ReturnedSidsEx.Sids ) {
                // Memory can be allocated on !NT_SUCCESS, namely
                // STATUS_NONE_MAPPED
                SidCount = ReturnedSidsEx.Entries;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 1:

        if ( ServerRevision ) {
            *ServerRevision = LSA_LOOKUP_REVISION_1;
        }

        RpcTryExcept {

            Status = LsarLookupNames(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSids,
                         LookupLevel,
                         MappedCount
                         );

            LsaLookupNameRevision = 1;
            if ( ReturnedSids.Sids ) {
                // Memory can be allocated on !NT_SUCCESS, namely
                // STATUS_NONE_MAPPED
                SidCount = ReturnedSids.Entries;
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        break;

    default:

        ASSERT(FALSE && "Programming error -- invalid revision" );
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Prevent against network hacks
    //
    if (   NT_SUCCESS( Status )
        && (Count > 0)
        && (   (LsaLookupNameRevision == 1) && ((ReturnedSids.Entries == 0)
                                             || (ReturnedSids.Sids == NULL))
            || (LsaLookupNameRevision == 2) && ((ReturnedSidsEx.Entries == 0)
                                             || (ReturnedSidsEx.Sids == NULL))
            || (LsaLookupNameRevision == 3) && ((ReturnedSidsEx2.Entries == 0)
                                             || (ReturnedSidsEx2.Sids == NULL)))) {
        //
        // This is bogus -- an NT server would never return this
        //
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Cleanup;
    }

    //
    // Ok at this point, we have a success -- map the return values
    // to the latest revision: LSA_TRANSLATES_SID_EX2
    //

    if (  ((LsaLookupNameRevision == 2) && ReturnedSidsEx.Sids != NULL)
       || ((LsaLookupNameRevision == 1) && ReturnedSids.Sids != NULL) ) {

        //
        // There should be a ReferencedDomains
        //
        ASSERT( NULL != *ReferencedDomains);

        //
        // Calculate the size necessary.  All SID's from non Sid-Extended domains
        // will be less than 28 bytes.  However, we still sanity check the values
        // returned from the untrusted net before copying in (see below).
        //

    #define MAX_DOWNLEVEL_SID_SIZE 28

        //
        // Since we are returning a buffer containing all allocations, make sure
        // everything aligned properly
        //

        ASSERT(MAX_DOWNLEVEL_SID_SIZE ==
               ROUND_UP_COUNT(MAX_DOWNLEVEL_SID_SIZE, ALIGN_DWORD));
        ASSERT(sizeof(LSA_TRANSLATED_SID_EX2) ==
               ROUND_UP_COUNT(sizeof(LSA_TRANSLATED_SID_EX2), ALIGN_DWORD));

        Size =  SidCount * sizeof(LSA_TRANSLATED_SID_EX2);
        Size += SidCount * MAX_DOWNLEVEL_SID_SIZE;
        ReturnedSidsEx2.Sids = MIDL_user_allocate(Size);
        if (NULL == ReturnedSidsEx2.Sids) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(ReturnedSidsEx2.Sids, Size);
        NextSid = (PBYTE) ReturnedSidsEx2.Sids;
        NextSid += (SidCount * sizeof(LSA_TRANSLATED_SID_EX2));

        for ( i = 0; i < SidCount; i++ ) {

            BYTE  Buffer[MAX_DOWNLEVEL_SID_SIZE];
            PSID  Sid = (PSID)Buffer;
            ULONG SidLength;
            ULONG DomainIndex;
            ULONG Rid;
            SID_NAME_USE SidNameUse;
            ULONG Flags;
            PSID  DomainSid;

            if (1 == LsaLookupNameRevision) {

                DomainIndex = ReturnedSids.Sids[i].DomainIndex;
                Rid = ReturnedSids.Sids[i].RelativeId;
                SidNameUse = ReturnedSids.Sids[i].Use;
                Flags = 0;

            } else  {

                ASSERT( 2 == LsaLookupNameRevision );

                DomainIndex = ReturnedSidsEx.Sids[i].DomainIndex;
                Rid = ReturnedSidsEx.Sids[i].RelativeId;
                SidNameUse = ReturnedSidsEx.Sids[i].Use;
                Flags = ReturnedSidsEx.Sids[i].Flags;
            }

            //
            // Copy over the simple values
            //
            ReturnedSidsEx2.Sids[i].Use = SidNameUse;
            ReturnedSidsEx2.Sids[i].DomainIndex = DomainIndex;
            ReturnedSidsEx2.Sids[i].Flags = Flags;

            //
            // Copy over the sid if possible
            //
            // To support possible additions in the future, check for the negative cases.
            // These types will never have any SIDs; all others must have a SID portion.
            //
            if ( (SidNameUse != SidTypeDeletedAccount)
              && (SidNameUse != SidTypeInvalid)
              && (SidNameUse != SidTypeUnknown)  ) {

                if (DomainIndex == LSA_UNKNOWN_INDEX) {
                    //
                    // This is a bogus return value
                    //
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                    goto Cleanup;
                }

                //
                // N.B.  For domain names, the RID is set to LSA_UNKNOWN_ID and
                // to be compatible with the LsarLookupName3 routine, return
                // a SID in ReturedSidsEx2 structure.
                //
                DomainSid = (*ReferencedDomains)->Domains[DomainIndex].Sid;
                if (RtlLengthSid(DomainSid) > (MAX_DOWNLEVEL_SID_SIZE - sizeof(DWORD))){
                    //
                    // This is a bogus return value
                    //
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                    goto Cleanup;
                }

                RtlCopySid(sizeof(Buffer), Sid, DomainSid);
                if ( Rid != LSA_UNKNOWN_ID ) {
                    ULONG RidAuthority;
                    RidAuthority= (*(RtlSubAuthorityCountSid(Sid)))++;
                    *RtlSubAuthoritySid(Sid,RidAuthority) = Rid;
                }

                SidLength = RtlLengthSid(Sid);
                RtlCopySid(SidLength, (PSID)NextSid, Sid);

                ReturnedSidsEx2.Sids[i].Sid = (PSID)NextSid;
                NextSid += RtlLengthSid(Sid);

            } else {

                //
                // Either no domain SID, or account is unknown
                //

                ReturnedSidsEx2.Sids[i].Sid = NULL;
            }
        }
    }

    *Sids = (PLSA_TRANSLATED_SID_EX2) ReturnedSidsEx2.Sids;
    ReturnedSidsEx2.Sids = NULL;

Cleanup:

    if ( (STATUS_INVALID_NETWORK_RESPONSE == Status)
     ||  (STATUS_NO_MEMORY == Status)    ) {
        if ( *ReferencedDomains ) {
            MIDL_user_free( *ReferencedDomains );
            *ReferencedDomains = NULL;
        }
        *Sids = NULL;
    }

    if ( ReturnedSids.Sids ) {
        MIDL_user_free( ReturnedSids.Sids );
    }
    if ( ReturnedSidsEx.Sids ) {
        MIDL_user_free( ReturnedSidsEx.Sids );
    }
    if ( ReturnedSidsEx2.Sids ) {
        MIDL_user_free( ReturnedSidsEx2.Sids );
    }

    return(Status);
}


NTSTATUS
LsaLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME *Names
    )

/*++

Routine Description:

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the returned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        Rest TBS
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    PLSA_TRANSLATED_NAME_EX NamesEx = NULL;
    ULONG i;

    if ( NULL == Names ) {

        return STATUS_INVALID_PARAMETER;
    }

    Status = LsaICLookupSids(
                 PolicyHandle,
                 Count,
                 Sids,
                 ReferencedDomains,
                 &NamesEx,
                 LsapLookupWksta,
                 0,
                 &MappedCount,
                 NULL
                 );

    if ( NamesEx != NULL ) {

        //
        // Some names were returned -- map the new structure to the old one
        // and keep allocations in the same block of memory so existing clients
        // won't have memory leaks
        //
        ULONG SizeNeeded = 0;
        PBYTE NextBuffer;
        PLSA_TRANSLATED_NAME TempNames = NULL;

        SizeNeeded = Count * sizeof( LSA_TRANSLATED_NAME );
        for ( i = 0; i < Count; i++ ) {
            SizeNeeded += NamesEx[i].Name.MaximumLength;
        }

        TempNames = MIDL_user_allocate( SizeNeeded );
        if ( TempNames ) {

            RtlZeroMemory( TempNames, SizeNeeded );
            NextBuffer = ((PBYTE)TempNames) + (Count * sizeof( LSA_TRANSLATED_NAME ));

            for ( i = 0; i < Count; i++ ) {

                TempNames[i].Use = NamesEx[i].Use;
                TempNames[i].DomainIndex = NamesEx[i].DomainIndex;

                TempNames[i].Name = NamesEx[i].Name;
                RtlCopyMemory( NextBuffer, NamesEx[i].Name.Buffer, NamesEx[i].Name.Length );
                TempNames[i].Name.Buffer = (WCHAR*)NextBuffer;

                NextBuffer += NamesEx[i].Name.MaximumLength;
            }

        } else {

            //
            // The call succeeded but the extra allocation didn't
            //

            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Return the results (or NULL)
        //

        *Names = TempNames;

        MIDL_user_free( NamesEx );

    } else {

        *Names = NULL;
    }

    return(Status);
}


NTSTATUS
LsapVerifyReturnedNames(
    IN  LSAPR_TRANSLATED_NAMES_EX *ReturnedNames,
    IN  ULONG Count,
    IN  PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains
    )
/*++

Routine Description:

    This routine validates the returned names structure from the server.
    There are some checks that RPC can't make that the client assumes are
    true and will AV otherwise.

Arguments:

    Count -- the number of elements the client asked the server to resolve

    ReturnedNames -- the structure holding the data returned from the server

    ReferencedDomains -- the array of domains that ReturnedNames points into
                         (also returned from the server)

Return Values:

    STATUS_SUCCESS

    STATUS_INVALID_NETWORK_RESPONSE

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    if (ReturnedNames->Entries != Count) {

        //
        // Entries returned should always equal the number of items asked for
        //

        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Finish;
    }

    if ( Count > 0
     && (ReturnedNames->Names == NULL))  {

        //
        // If there are entries, then there must be an array
        //

        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Finish;
    }

    for (i = 0; i < Count; i++) {

        //
        // All resolved names must have a valid domain index
        //
        if ( (ReturnedNames->Names[i].Use != SidTypeInvalid) &&
             (ReturnedNames->Names[i].Use != SidTypeDeletedAccount) &&
             (ReturnedNames->Names[i].Use != SidTypeUnknown) ) {

            if (NULL == ReferencedDomains) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto Finish;
            } else if ( (ReturnedNames->Names[i].DomainIndex == LSA_UNKNOWN_INDEX)
                    ||  (ReturnedNames->Names[i].DomainIndex < 0)
                    ||  ((ULONG)ReturnedNames->Names[i].DomainIndex >= ReferencedDomains->Entries)) {
                // 
                // App verifier recently added support for RPC packet 
                // corruption injection which makes the following assert
                // overactive.  Re-enable to track any real suspected 
                // malformed responses.
                //
                // ASSERT(FALSE && "Invalid network response!");
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto Finish;
            }
        }
    }

Finish:

    return Status;
}


NTSTATUS
LsaICLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,
    IN OUT PULONG MappedCount,
    OUT OPTIONAL ULONG *ServerRevision
    )

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupSids
    API.  It is called both from the client side of the Lsa and also
    the server side of the LSA (when calling out to another LSA).  The
    function is identical to the LsaLookupSids API except that there is an
    additional parameter, the LookupLevel parameter.

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the retruned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on the
        target machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

    Flags:
            LSAIC_NT4_TARGET -- target server is known to be NT4

            LSAIC_WIN2K_TARGET -- target server is known to be Win2k

    MappedCount - Pointer to location that contains a count of the Sids
        mapped so far.  On exit, this count will be updated.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        STATUS_TOO_MANY_SIDS - Too many Sids have been specified.

--*/

{
    NTSTATUS  Status;
    BOOLEAN NamesArraySpecified = FALSE;
    LSAPR_SID_ENUM_BUFFER SidEnumBuffer;
    LSAPR_TRANSLATED_NAMES_EX ReturnedNames = {0, NULL};
    LSAPR_TRANSLATED_NAMES    DownlevelNames  = {0, NULL};
    ULONG StartingRevision = 2;

    if ( ServerRevision ) {
        // The latest client's will prefer the latest servers
        *ServerRevision = LSA_CLIENT_LATEST;
    }

    //
    // Verify that the Count is positive and not too high
    //

    if (Count == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Count > LSA_MAXIMUM_LOOKUP_SIDS_COUNT) {

        return STATUS_TOO_MANY_SIDS;
    }

    SidEnumBuffer.Entries = Count;
    SidEnumBuffer.SidInfo = (PLSAPR_SID_INFORMATION) Sids;

    //
    // If this is a Workstation-Level lookup, the Names and
    // ReferencedDomain Lists have not been created.  Since these
    // are input parameters in the general case, we need to set them
    // to NULL.
    //

    if (LookupLevel == LsapLookupWksta) {

        *ReferencedDomains = NULL;
        *Names = NULL;
    }

    //
    // There may already be a name translation array in cases where
    // we are called internally (i.e. with lookup level higher than
    // LsapLookupWksta).  Initialize the ReturnedNames structure
    // accordingly.
    //

    ReturnedNames.Entries = 0;
    ReturnedNames.Names = NULL;

    if (*Names != NULL) {

        ReturnedNames.Entries = Count;
        ReturnedNames.Names = (PLSAPR_TRANSLATED_NAME_EX) *Names;
        NamesArraySpecified = TRUE;
    }

    //
    // Adjust the StartingRevision
    //

    StartingRevision = 2;
    if (Flags & LSAIC_NT4_TARGET) {
        StartingRevision = 1;
    }

    //
    // Lookup Sids on the Server..
    //

    switch (StartingRevision) {
    case 2:

        RpcTryExcept {
            Status = LsarLookupSids2(
                         (LSAPR_HANDLE) PolicyHandle,
                         &SidEnumBuffer,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedNames,
                         LookupLevel,
                         MappedCount,
                         0,
                         LSA_CLIENT_NT5
                         );

            //
            // Return the array of translation to name info or NULL.
            //
            // NOTE:  The array of name translations is allocated by the called
            // client stub as a single block via MIDL_user_allocate, because
            // Information is allocated all-nodes.  We can therefore pass back the pointer
            // directly to the client, who will be able to free the memory after
            // use via LsaFreeMemory() [which makes a MIDL_user_free call].
            //

            *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            //
            // If memory was allocated for the name translation array,
            // free it.
            //

            if ((!NamesArraySpecified) && ReturnedNames.Names != NULL) {

                MIDL_user_free( ReturnedNames.Names );
                ReturnedNames.Names = NULL;
            }

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 1:

        if ( ServerRevision ) {
            // This is pre nt5
            *ServerRevision = LSA_CLIENT_PRE_NT5;
        }

        RpcTryExcept {

            //
            // Ok, lower down to the previous version
            //
            Status = LsarLookupSids(
                         (LSAPR_HANDLE) PolicyHandle,
                         &SidEnumBuffer,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &DownlevelNames,
                         LookupLevel,
                         MappedCount
                         );

            if ( DownlevelNames.Names != NULL ) {

                ULONG i;
                ULONG SizeNeeded = 0;
                PBYTE NextBuffer;

                //
                // Package the results into a new structure.  Note all memory
                // must be in the same block as LSA_TRANSLATED_NAMES and
                // LSA_TRANSLATED_NAMES_EX are NOT allocate all nodes
                //
                SizeNeeded = DownlevelNames.Entries * sizeof( LSA_TRANSLATED_NAME_EX );
                for ( i = 0; i < DownlevelNames.Entries; i++ ) {
                    SizeNeeded += DownlevelNames.Names[i].Name.MaximumLength;
                }
                if ( !NamesArraySpecified ) {
                    ReturnedNames.Names = MIDL_user_allocate( SizeNeeded );
                    if ( !ReturnedNames.Names ) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        _leave;
                    }
                    RtlZeroMemory( ReturnedNames.Names, SizeNeeded );
                    ReturnedNames.Entries = Count;
                }
                NextBuffer = ((PBYTE)ReturnedNames.Names) + (Count * sizeof( LSA_TRANSLATED_NAME_EX ));

                ReturnedNames.Entries = DownlevelNames.Entries;
                for ( i = 0; i < DownlevelNames.Entries; i++ ) {

                    ReturnedNames.Names[i].Use = DownlevelNames.Names[i].Use;
                    ReturnedNames.Names[i].Name = DownlevelNames.Names[i].Name;
                    RtlCopyMemory( NextBuffer, DownlevelNames.Names[i].Name.Buffer, DownlevelNames.Names[i].Name.Length );
                    ReturnedNames.Names[i].Name.Buffer = (WCHAR*)NextBuffer;
                    ReturnedNames.Names[i].DomainIndex = DownlevelNames.Names[i].DomainIndex;
                    NextBuffer += DownlevelNames.Names[i].Name.MaximumLength;
                }
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            if ( DownlevelNames.Names ) {

                MIDL_user_free( DownlevelNames.Names );
                DownlevelNames.Names = NULL;
            }

            if ((!NamesArraySpecified) && ReturnedNames.Names != NULL) {

                MIDL_user_free( ReturnedNames.Names );
                ReturnedNames.Names = NULL;
            }

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        break;

    default:
        ASSERT(FALSE && "Programming error -- wrong revision");
        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // Return the array of translation to name info or NULL.
    //
    // NOTE:  The array of name translations is allocated by the called
    // client stub as a single block via MIDL_user_allocate, because
    // Information is allocated all-nodes.  We can therefore pass back the pointer
    // directly to the client, who will be able to free the memory after
    // use via LsaFreeMemory() [which makes a MIDL_user_free call].
    //

    *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;

    //
    // This memory, if allocated is never returned to the caller, so free
    //
    if ( DownlevelNames.Names ) {

        MIDL_user_free( DownlevelNames.Names );
    }

    //
    // Prevent against network hacks
    //
    if (NT_SUCCESS(Status)) {

        Status = LsapVerifyReturnedNames(&ReturnedNames,
                                         Count,
                                         *ReferencedDomains);

        if (!NT_SUCCESS(Status)) {

            if ( (!NamesArraySpecified) && ReturnedNames.Names ) {
                MIDL_user_free( ReturnedNames.Names );
                *Names = NULL;
            }

            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }
    }

    return(Status);
}


NTSTATUS
LsaOpenAccount(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE AccountHandle
    )

/*++

Routine Description:

    The LsaOpenAccount API opens an account object in the Lsa Database of the
    target system.  An account must be opened before any operation can be
    performed, including deletion of the account.  A handle to the account
    object is returned for use on subsequent API calls that access the
    account.  Before calling this API, the caller must have connected to
    the target system's LSA and opened the Policy object by means
    of a preceding call to LsaOpenPolicy.

Arguments:

    PolicyHandle - Handle from an LsaOpenLsa call.

    AccountSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target Account object to determine whether the accesses will be
        granted or denied.

    AccountHandle - Pointer to location in which a handle to the opened
        account object will be returned if the call succeeds.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ACCOUNT_DOES_NOT_EXIST - There is no account object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenAccount(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) AccountHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaEnumeratePrivilegesOfAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PPRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        *Privileges = NULL;

        Status = LsarEnumeratePrivilegesAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     (PLSAPR_PRIVILEGE_SET *) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaAddPrivilegesToAccount(
    IN LSA_HANDLE AccountHandle,
    IN PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    The LsaAddPrivilegesToAccount API adds privileges and their attributes
    to an account object.  If any provided privilege is already assigned
    to the account object, the attributes of that privilege are replaced
    by the newly rpovided values.  This API call requires
    LSA_ACCOUNT_ADJUST_PRIVILEGES access to the account object.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be added.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Points to a set of privileges (and their attributes) to
        be assigned to the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarAddPrivilegesToAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     (PLSAPR_PRIVILEGE_SET) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaRemovePrivilegesFromAccount(
    IN LSA_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    The LsaRemovePrivilegesFromAccount API removes privileges from an
    account object.  This API call requires LSA_ACCOUNT_ADJUST_PRIVILEGES
    access to the account object.  Note that if all privileges are removed
    from the account object, the account object remains in existence until
    deleted explicitly via a call to the LsaDelete API.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be removed.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    AllPrivileges - If TRUE, then all privileges are to be removed from
        the account.  In this case, the Privileges parameter must be
        specified as NULL.  If FALSE, the Privileges parameter specifies
        the privileges to be removed, and must be non NULL.

    Privileges - Optionally points to a set of privileges (and their
        attributes) to be removed from the account object.  The attributes
        fields of this structure are ignored.  This parameter must
        be specified as non-NULL if and only if AllPrivileges is set to
        FALSE.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INVALID_PARAMETER - The optional Privileges paraemter was
            specified as NULL and AllPrivileges was set to FALSE.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarRemovePrivilegesFromAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     AllPrivileges,
                     (PLSAPR_PRIVILEGE_SET) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaGetQuotasForAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota and explicit value is returned.  This
    call requires LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept{

        Status = LsarGetQuotasForAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     QuotaLimits
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaSetQuotasForAccount(
    IN LSA_HANDLE AccountHandle,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    The LsaSetQuotasForAccount API sets the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota an explicit value or the system default
    may be specified.  This call requires LSA_ACCOUNT_ADJUST_QUOTAS
    access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be set.  This handle will have been returned from a prior
        LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure containing the system resource
        quota limits applicable to each session logged on to this account.
        A zero value specified in any field indicates that the current
        System Default Quota Limit is to be applied.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarSetQuotasForAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     QuotaLimits
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaGetSystemAccessAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    The LsaGetSystemAccessAccount() service returns the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS   Status;

    //
    // Avoid RPC stub code raising exception on NULL handle so that
    // we can return the error code STATUS_INVALID_HANDLE in this case
    // too.
    //

    if (!ARGUMENT_PRESENT(AccountHandle)) {

        return(STATUS_INVALID_HANDLE);
    }

    RpcTryExcept{

        Status = LsarGetSystemAccessAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     SystemAccess
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaSetSystemAccessAccount(
    IN LSA_HANDLE AccountHandle,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    The LsaSetSystemAccessAccount() service sets the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_ADJUST_SYSTEM_ACCESS access.

    SystemAccess - A mask of the system access flags to assign to the
        Account object.  The valid access flags include:

        POLICY_MODE_INTERACTIVE - Account can be accessed interactively

        POLICY_MODE_NETWORK - Account can be accessed remotely

        POLICY_MODE_SERVICE - TBS

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

        STATUS_INVALID_PARAMETER - The specified Access Flags are invalid.
--*/

{
    NTSTATUS Status;

    //
    // Avoid RPC stub code raising exception on NULL handle so that
    // we can return the error code STATUS_INVALID_HANDLE in this case
    // too.
    //

    if (!ARGUMENT_PRESENT(AccountHandle)) {

        return(STATUS_INVALID_HANDLE);
    }

    RpcTryExcept {

        Status = LsarSetSystemAccessAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     SystemAccess
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaFreeMemory(
    IN PVOID Buffer
    )

/*++

Routine Description:


    Some LSA services that return a potentially large amount of memory,
    such as an enumeration might, allocate the buffer in which the data
    is returned.  This function is used to free those buffers when they
    are no longer needed.

Parameters:

    Buffer - Pointer to the buffer to be freed.  This buffer must
        have been allocated by a previous LSA service call.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    MIDL_user_free( Buffer );

    return Status;
}



NTSTATUS
LsaOpenSecret(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE SecretHandle
    )

/*++

Routine Description:

    The LsaOpenSecret API opens a Secret Object within the LSA Database.
    A handle is returned which must be used to perform operations on the
    secret object.

Arguments:

    PolicyHandle - Handle from an LsaOpenLsa call.

    SecretName - Pointer to a Unicode String structure that references the
        name of the Secret object to be opened.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the secret object being opened.  These access types
        are reconciled with the Discretionary Access Control List of the
        target secret object to determine whether the accesses will be
        granted or denied.


    SecretHandle - Pointer to location that will receive a handle to the
        newly opened Secret object.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.

--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarOpenSecret(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) SecretName,
                     DesiredAccess,
                     (PLSAPR_HANDLE) SecretHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaSetSecret(
    IN LSA_HANDLE SecretHandle,
    IN OPTIONAL PUNICODE_STRING CurrentValue,
    IN OPTIONAL PUNICODE_STRING OldValue
    )

/*++

Routine Description:

    The LsaSetSecret API optionally sets one or both values associated with
    a secret.  These values are known as the "current value" and "old value"
    of the secret and have a meaning known to the creator of the Secret
    object.  The values given are stored in encrypted form.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CurrentValue - Optional pointer to Unicode String containing the
        value to be assigned as the "current value" of the Secret
        object.  The meaning of "current value" is dependent on the
        purpose for which the Secret object is being used.

    OldValue - Optional pointer to Unicode String containing the
        value to be assigned as the "old value" of the Secret object.
        The meaning of "old value" is dependent on the purpose for
        which the Secret object is being used.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.
--*/

{
    NTSTATUS Status;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldValue = NULL;
    LSAP_CR_CLEAR_VALUE ClearCurrentValue;
    LSAP_CR_CLEAR_VALUE ClearOldValue;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    //
    // Convert input from Unicode Structures to Clear Value Structures.
    //

    LsapCrUnicodeToClearValue( CurrentValue, &ClearCurrentValue );
    LsapCrUnicodeToClearValue( OldValue, &ClearOldValue );

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( SecretHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecretError;
    }

    //
    // Encrypt the Current Value if specified and not too long.
    //

    if (ARGUMENT_PRESENT(CurrentValue)) {

        Status = LsapCrEncryptValue(
                     &ClearCurrentValue,
                     SessionKey,
                     &CipherCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }
    }

    //
    // Encrypt the Old Value if specified and not too long.
    //

    if (ARGUMENT_PRESENT(OldValue)) {

        Status = LsapCrEncryptValue(
                     (PLSAP_CR_CLEAR_VALUE) &ClearOldValue,
                     SessionKey,
                     &CipherOldValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }
    }

    //
    // Set the Secret Values.
    //

    RpcTryExcept {

        Status = LsarSetSecret(
                     (LSAPR_HANDLE) SecretHandle,
                     (PLSAPR_CR_CIPHER_VALUE) CipherCurrentValue,
                     (PLSAPR_CR_CIPHER_VALUE) CipherOldValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecretError;
    }

SetSecretFinish:

    //
    // If necessary, free memory allocated for the Encrypted Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsaFreeMemory(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Encrypted Old Value.
    //

    if (CipherOldValue != NULL) {

        LsaFreeMemory(CipherOldValue);
    }

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    return(Status);

SetSecretError:

    goto SetSecretFinish;
}


NTSTATUS
LsaQuerySecret(
    IN LSA_HANDLE SecretHandle,
    IN OUT OPTIONAL PUNICODE_STRING *CurrentValue,
    OUT PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PUNICODE_STRING *OldValue,
    OUT PLARGE_INTEGER OldValueSetTime
    )

/*++

Routine Description:

    The LsaQuerySecret API optionally returns one or both of the values
    assigned to a Secret object.  These values are known as the "current value"
    and the "old value", and they have a meaning known to the creator of the
    Secret object.  The values are returned in their original unencrypted form.
    The caller must have LSA_QUERY_SECRET access to the Secret object.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CurrentValue - Optional pointer to location which will receive a pointer
        to a Unicode String containing the value assigned as the "current
        value" of the secret object.  If no "current value" is assigned to
        the Secret object, a NULL pointer is returned.

    CurrentValueSetTime - The date/time at which the current secret value
        was established.

    OldValue - Optional pointer to location which will receive a pointer
        to a Unicode String containing the value assigned as the "old
        value" of the secret object.  If no "current value" is assigned to
        the Secret object, a NULL pointer is returned.

    OldValueSetTime - The date/time at which the old secret value
        was established.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearCurrentValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearOldValue = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    RpcTryExcept {

        Status = LsarQuerySecret(
                     (PLSAPR_HANDLE) SecretHandle,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherCurrentValue,
                     CurrentValueSetTime,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherOldValue,
                     OldValueSetTime
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( SecretHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (ARGUMENT_PRESENT(CurrentValue)) {

        if (CipherCurrentValue != NULL) {

            Status = LsapCrDecryptValue(
                         CipherCurrentValue,
                         SessionKey,
                         &ClearCurrentValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto QuerySecretError;
            }

            //
            // Convert Clear Current Value to Unicode
            //

            LsapCrClearValueToUnicode(
                ClearCurrentValue,
                (PUNICODE_STRING) ClearCurrentValue
                );

            *CurrentValue = (PUNICODE_STRING) ClearCurrentValue;

        } else {

            *CurrentValue = NULL;
        }
    }

    //
    // If the Old Value is requested and an Old Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (ARGUMENT_PRESENT(OldValue)) {

        if (CipherOldValue != NULL) {

            Status = LsapCrDecryptValue(
                         CipherOldValue,
                         SessionKey,
                         &ClearOldValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto QuerySecretError;
            }

            //
            // Convert Clear Old Value to Unicode
            //

            LsapCrClearValueToUnicode(
                ClearOldValue,
                (PUNICODE_STRING) ClearOldValue
                );

            *OldValue = (PUNICODE_STRING) ClearOldValue;

        } else {

            *OldValue = NULL;
        }
    }

    //
    // Getting here means that the operation completed successfully,
    // but Status can be something other than STATUS_SUCCESS.
    // For instance, if both output buffers are NULL, the value of Status
    // at this point will be STATUS_LOCAL_USER_SESSION_KEY.
    // Explicitly clear Status here and avoid confusion for the client.
    //

    Status = STATUS_SUCCESS;

QuerySecretFinish:

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsapCrFreeMemoryValue(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Old Value.
    //

    if (CipherOldValue != NULL) {

        LsapCrFreeMemoryValue(CipherOldValue);
    }

    return(Status);

QuerySecretError:

    //
    // If necessary, free memory allocated for the Clear Current Value
    //

    if (ClearCurrentValue != NULL) {

        LsapCrFreeMemoryValue(ClearCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Clear Old Value
    // Unicode string (buffer and structure).
    //

    if (ClearOldValue != NULL) {

        LsapCrFreeMemoryValue(ClearOldValue);
    }


    if (ARGUMENT_PRESENT(CurrentValue)) {

        *CurrentValue = NULL;
    }

    if (ARGUMENT_PRESENT(OldValue)) {

        *OldValue = NULL;
    }

    goto QuerySecretFinish;
}


NTSTATUS
LsaGetUserName(
    OUT PUNICODE_STRING * UserName,
    OUT OPTIONAL PUNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This function returns the callers user name and domain name


Arguments:

    UserName - Receives a pointer to the user's name.

    DomainName - Optionally receives a pointer to the user's domain name.


Return Value:

    NTSTATUS - The privilege was found and returned.


--*/

{
    NTSTATUS Status;
    PLSAPR_UNICODE_STRING UserNameBuffer = NULL;
    PLSAPR_UNICODE_STRING DomainNameBuffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaGetUserName
        //

        Status = LsarGetUserName(
                     NULL,
                     &UserNameBuffer,
                     ARGUMENT_PRESENT(DomainName) ? &DomainNameBuffer : NULL
                     );

        (*UserName) = (PUNICODE_STRING)UserNameBuffer;

        if (ARGUMENT_PRESENT(DomainName)) {
            (*DomainName) = (PUNICODE_STRING)DomainNameBuffer;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (UserNameBuffer != NULL) {

            MIDL_user_free(UserNameBuffer);
        }

        if (DomainNameBuffer != NULL) {

            MIDL_user_free(DomainNameBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaGetRemoteUserName(
    IN PUNICODE_STRING SystemName,
    OUT PUNICODE_STRING * UserName,
    OUT OPTIONAL PUNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This function returns the callers user name and domain name


Arguments:

    SystemName  - Name of system on which to obtain the user name.

    UserName - Receives a pointer to the user's name.

    DomainName - Optionally receives a pointer to the user's domain name.


Return Value:

    NTSTATUS - The privilege was found and returned.


--*/

{
    NTSTATUS Status;
    PLSAPR_UNICODE_STRING UserNameBuffer = NULL;
    PLSAPR_UNICODE_STRING DomainNameBuffer = NULL;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;

    if (ARGUMENT_PRESENT(SystemName) &&
        (SystemName->Buffer != NULL) &&
        (SystemName->Length > 0)) {

        NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

        ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

        if (ServerName != NULL) {

            RtlMoveMemory(
                ServerName,
                SystemName->Buffer,
                SystemName->Length
                );

            ServerName[SystemName->Length / sizeof( WCHAR )] = L'\0';

        } else {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaGetUserName
        //

        Status = LsarGetUserName(
                     ServerName,
                     &UserNameBuffer,
                     ARGUMENT_PRESENT(DomainName) ? &DomainNameBuffer : NULL
                     );

        (*UserName) = (PUNICODE_STRING)UserNameBuffer;

        if (ARGUMENT_PRESENT(DomainName)) {
            (*DomainName) = (PUNICODE_STRING)DomainNameBuffer;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (UserNameBuffer != NULL) {

            MIDL_user_free(UserNameBuffer);
        }

        if (DomainNameBuffer != NULL) {

            MIDL_user_free(DomainNameBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (ServerName != NULL) {

        MIDL_user_free(ServerName);
    }

    return(Status);
}



NTSTATUS
LsaICLookupNamesWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine performs a lookup with the using an LSA context handle.
    Its purpose is to facilitate lookups over NETLOGON's secure channel.

    N.B. The routine uses only TCP/IP as the transport.

Arguments:

    ServerName             -- the destination server, NULL terminated

    ServerPrincipalName,
    AuthnLevel,
    AuthSvc,
    AuthIdentity,
    AuthzSvc               -- see RpcSetAuthInfo

    Rset of the parameters -- see LsaLookupNames2

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS              Status = STATUS_SUCCESS;
    DWORD                 RpcError = 0;
    RPC_BINDING_HANDLE    BindingHandle = NULL;
    WCHAR                *StringBinding = NULL;
    LSAPR_TRANSLATED_SIDS_EX2 ReturnedSidsEx2 = { 0, NULL };

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    if ((ServerName == NULL)
     ||  (ReferencedDomains == NULL)
     || (Sids == NULL)
     || (MappedCount == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    *ReferencedDomains = NULL;
    *Sids = NULL;
    *MappedCount = 0;

    if ( 0 == wcsncmp(ServerName, L"\\\\", 2) ) {
       ServerName += 2;
    }

    RpcError = RpcStringBindingComposeW(
                           NULL,
                           L"ncacn_ip_tcp",
                           ServerName,
                           NULL,
                           NULL,
                           &StringBinding);

    if (RPC_S_OK == RpcError) {

       RpcError = RpcBindingFromStringBindingW(
                           StringBinding,
                           &BindingHandle);

       if ( RPC_S_OK == RpcError ) {

           RpcError = RpcBindingSetAuthInfoW(
                       BindingHandle,
                       ServerPrincipalName,
                       AuthnLevel,
                       AuthnSvc,
                       AuthIdentity,
                       AuthzSvc
                       );
       }
    }

    if (RPC_S_OK != RpcError) {
        //
        // This is fatal
        //
        Status = I_RpcMapWin32Status(RpcError);
        goto Cleanup;
    }

    RpcTryExcept {

        ReturnedSidsEx2.Entries = 0;
        ReturnedSidsEx2.Sids = NULL;

        Status = LsarLookupNames4(
                     BindingHandle,
                     Count,
                     (PLSAPR_UNICODE_STRING) Names,
                     (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                     &ReturnedSidsEx2,
                     LookupLevel,
                     MappedCount,
                     0,            // no flags currently defined
                     LSA_LOOKUP_REVISION_LATEST
                     );

        *Sids = (PLSA_TRANSLATED_SID_EX2)ReturnedSidsEx2.Sids;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:

    //
    // Make the handling of this unsupported condition simpler by returning
    // one error code
    //
    if ( (Status == RPC_NT_UNKNOWN_IF) ||
         (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ||
         (Status == EPT_NT_NOT_REGISTERED) ) {

        Status = STATUS_NOT_SUPPORTED;
    }

    if (BindingHandle) {
       RpcBindingFree(&BindingHandle);
    }

    if (StringBinding){
       RpcStringFreeW(&StringBinding);
    }

    return(Status);
}

NTSTATUS
LsaICLookupSidsWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine performs a lookup with the using an LSA context handle.
    Its purpose is to facilitate lookups over NETLOGON's secure channel.

    N.B. The routine uses only TCP/IP as the transport.

Arguments:

    ServerName             -- the destination server, NULL terminated

    ServerPrincipalName,
    AuthnLevel,
    AuthSvc,
    AuthIdentity,
    AuthzSvc               -- see RpcSetAuthInfo

    Rset of the parameters -- see LsaLookupSids

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/
{

    NTSTATUS              Status = STATUS_SUCCESS;
    DWORD                 RpcError = 0;
    RPC_BINDING_HANDLE    BindingHandle = NULL;
    WCHAR                *StringBinding = NULL;
    LSAPR_TRANSLATED_NAMES_EX ReturnedNames = { 0, NULL };
    LSAPR_SID_ENUM_BUFFER SidEnumBuffer;

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    if ((ServerName == NULL)
     || (ReferencedDomains == NULL)
     || (Names == NULL)
     || (MappedCount == NULL)
     || (Count == 0)  ) {
        return STATUS_INVALID_PARAMETER;
    }
    *ReferencedDomains = NULL;
    *Names = NULL;
    *MappedCount = 0;

    SidEnumBuffer.Entries = Count;
    SidEnumBuffer.SidInfo = (PLSAPR_SID_INFORMATION) Sids;

    if ( 0 == wcsncmp(ServerName, L"\\\\", 2) ) {
       ServerName += 2;
    }

    RpcError = RpcStringBindingComposeW(
                           NULL,
                           L"ncacn_ip_tcp",
                           ServerName,
                           NULL,
                           NULL,
                           &StringBinding);

    if (RPC_S_OK == RpcError) {

       RpcError = RpcBindingFromStringBindingW(
                           StringBinding,
                           &BindingHandle);

       if ( RPC_S_OK == RpcError ) {

           RpcError = RpcBindingSetAuthInfoW(
                       BindingHandle,
                       ServerPrincipalName,
                       AuthnLevel,
                       AuthnSvc,
                       AuthIdentity,
                       AuthzSvc
                       );
       }
    }

    if (RPC_S_OK != RpcError) {
        Status = I_RpcMapWin32Status(RpcError);
        goto Cleanup;
    }

    RpcTryExcept {

        ReturnedNames.Entries = 0;
        ReturnedNames.Names = NULL;

        //
        // Lookup Sids on the Server..
        //

        Status = LsarLookupSids3(
                     BindingHandle,
                     &SidEnumBuffer,
                     (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                     &ReturnedNames,
                     LookupLevel,
                     MappedCount,
                     0,
                     LSA_CLIENT_NT5
                     );

       *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    //
    // Prevent against network hacks
    //
    if (NT_SUCCESS(Status)) {

        Status = LsapVerifyReturnedNames(&ReturnedNames,
                                         Count,
                                         *ReferencedDomains);

        if (!NT_SUCCESS(Status)) {

            if (*Names) {
                MIDL_user_free(*Names);
                *Names = NULL;
            }

            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }
    }

Cleanup:

    //
    // Make the handling of this unsupported condition simpler by returning
    // one error code
    //
    if ( (Status == RPC_NT_UNKNOWN_IF) ||
         (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ||
         (Status == EPT_NT_NOT_REGISTERED) ) {

        Status = STATUS_NOT_SUPPORTED;

    }

    if (BindingHandle) {
       RpcBindingFree(&BindingHandle);
    }

    if (StringBinding){
       RpcStringFreeW(&StringBinding);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\rpcclimm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcclimm.c

Abstract:

    LSA - Client RPC Memory Management Routines

    NOTE: These routines use windows API, so are different from
          their server counterparts.
Author:

    Scott Birrell       (ScottBi)      May 1, 1991

Environment:

Revision History:

--*/

#include "lsaclip.h"
/*
#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <lsarpc.h>     // generated by the MIDL complier
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // LocalAlloc
#include <string.h>     // for strcpy strcat strlen memcmp
*/


PVOID
MIDL_user_allocate (
    unsigned int   NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC server transactions.  The RPC stubs will
    either call MIDL_user_allocate when it needs to un-marshall data into a
    buffer that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return (LocalAlloc(LMEM_FIXED,NumBytes));
}



VOID
MIDL_user_free (
    void    *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/

{
    LocalFree(MemPointer);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=lsa
MINORCOMP=uclient

TARGETTYPE=LIBRARY

INCLUDES=..;..\..\inc;        \
         ..\..\idl;           \
         ..\..\idl\$(O);      \
         $(SECURITY_INC);     \
         $(BASE_INC_PATH);    \
         $(NET_INC_PATH);     \
         $(DS_INC_PATH);      \
         $(DS_INC_PATH)\crypto; \
         $(COM_INC_PATH);     \
         $(DRIVERS_INC_PATH);

UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\rpcapi2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rpcapi2.c

Abstract:

    This module contains the routines for the LSA API that use RPC.  The
    routines in this module are merely wrappers that work as follows:

    o Client program calls LsaFoo in this module
    o LsaFoo calls RPC client stub interface routine LsapFoo with
      similar parameters.  Some parameters are translated from types
      (e.g structures containing PVOIDs or certain kinds of variable length
      parameters such as pointers to SID's) that are not specifiable on an
      RPC interface, to specifiable form.
    o RPC client stub LsapFoo calls interface specific marshalling routines
      and RPC runtime to marshal parameters into a buffer and send them over
      to the server side of the LSA.
    o Server side calls RPC runtime and interface specific unmarshalling
      routines to unmarshal parameters.
    o Server side calls worker LsapFoo to perform API function.
    o Server side marshals response/output parameters and communicates these
      back to client stub LsapFoo
    o LsapFoo exits back to LsaFoo which returns to client program.

Author:

    Mike Swift      (MikeSw)    December 7, 1994

Revision History:

--*/

#define UNICODE         // required for TEXT() to be defined properly
#include "lsaclip.h"

#include <lmcons.h>
#include <logonmsv.h>
#include <rc4.h>
#include <rpcasync.h>

//
// The following structure and the global table is also defined in 
// lsawrap.c. This version of the table is only used if the 
// corresponding high level api doesn't exist. If it does, then 
// the client RPCs over to the code in lsawrap.c and uses the new copy 
// of the table.  Old servers that don't support the high level api, 
// only support the 4 rights listed in the table. Therefore it is not a 
// bug that this table doesn't contain all of the rights.
//

typedef struct _LSAP_DB_RIGHT_AND_ACCESS {
    UNICODE_STRING UserRight;
    ULONG SystemAccess;
} LSAP_DB_RIGHT_AND_ACCESS, *PLSAP_DB_RIGHT_AND_ACCESS;

#define LSAP_DB_SYSTEM_ACCESS_TYPES 4

LSAP_DB_RIGHT_AND_ACCESS LsapDbRightAndAccess[LSAP_DB_SYSTEM_ACCESS_TYPES] = {
    {{sizeof(SE_INTERACTIVE_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_INTERACTIVE_LOGON_NAME),
      SE_INTERACTIVE_LOGON_NAME},
      SECURITY_ACCESS_INTERACTIVE_LOGON},
    {{sizeof(SE_NETWORK_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_NETWORK_LOGON_NAME),
      SE_NETWORK_LOGON_NAME},
      SECURITY_ACCESS_NETWORK_LOGON},
    {{sizeof(SE_BATCH_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_BATCH_LOGON_NAME),
      SE_BATCH_LOGON_NAME},
      SECURITY_ACCESS_BATCH_LOGON},
    {{sizeof(SE_SERVICE_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_SERVICE_LOGON_NAME),
      SE_SERVICE_LOGON_NAME},
      SECURITY_ACCESS_SERVICE_LOGON}
    };

//
// Structure to maintain list of enumerated accounts
//

typedef struct _SID_LIST_ENTRY {
    struct _SID_LIST_ENTRY * Next;
    PSID Sid;
} SID_LIST_ENTRY, *PSID_LIST_ENTRY;

//
// Functions private to this module
//

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );

NTSTATUS
LsapApiConvertRightsToPrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING UserRights,
    IN ULONG RightCount,
    OUT PPRIVILEGE_SET * Privileges,
    OUT PULONG SystemAccess
    );

NTSTATUS
LsapApiConvertPrivilegesToRights(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN OPTIONAL ULONG SystemAccess,
    OUT PUNICODE_STRING * UserRights,
    OUT PULONG RightCount
    );


//////////////////////////////////////////////////////////////////////
//
// This set of routines implements the same functionality as the APIs
// below but do it with the APIs present through NT 3.5
//
/////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsapEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PUNICODE_STRING UserRights,
    OUT PVOID *EnumerationBuffer,
    OUT PULONG CountReturned
    )

/*++

Routine Description:


    The LsaEnumerateAccountsWithUserRight API returns information about
    the accounts in the target system's Lsa Database.  This call requires
    LSA_ENUMERATE_ACCOUNTS access to the Policy object.  Since this call
    accesses the privileges of an account, you must have ACCOUNT_VIEW access
    access to all accounts.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    UserRight - Name of the right that the account must have.

    Buffer - Receives a pointer to a LSA_ENUMERATION_INFORMATION structure
        containing the SIDs of all the accounts.

    CountReturned - Receives the number of sids returned.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/


{
    NTSTATUS Status;
    PLSA_ENUMERATION_INFORMATION Accounts = NULL;
    PPRIVILEGE_SET DesiredPrivilege = NULL;
    ULONG DesiredAccess = 0;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    ULONG AccountCount;
    ULONG AccountIndex;
    LSA_HANDLE AccountHandle = NULL;
    PSID_LIST_ENTRY AccountList = NULL;
    PSID_LIST_ENTRY NextAccount = NULL;
    ULONG AccountSize;
    PUCHAR Where;
    ULONG PrivilegeIndex;

    Status = LsapApiConvertRightsToPrivileges(
                PolicyHandle,
                UserRights,
                (UserRights ? 1 : 0),
                &DesiredPrivilege,
                &DesiredAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Enumerate all the accounts.
    //

    do
    {
        Status = LsaEnumerateAccounts(
                    PolicyHandle,
                    &EnumContext,
                    &Accounts,
                    32000,
                    &AccountCount
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // For each account, check that it has the desired right
        //

        for (AccountIndex = 0; AccountIndex < AccountCount ; AccountIndex++ ) {

            if ((DesiredPrivilege != NULL) || (DesiredAccess != 0)) {

                Status = LsaOpenAccount(
                            PolicyHandle,
                            Accounts[AccountIndex].Sid,
                            ACCOUNT_VIEW,
                            &AccountHandle
                            );

                if (!NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                //
                // If a privilege was requested, get the privilegs
                //

                if (DesiredPrivilege != NULL) {

                    Privileges = NULL;
                    Status = LsaEnumeratePrivilegesOfAccount(
                                AccountHandle,
                                &Privileges
                                );
                    if (!NT_SUCCESS(Status)) {
                        goto Cleanup;
                    }

                    //
                    // Search for the desired privilege
                    //

                    for (PrivilegeIndex = 0;
                         PrivilegeIndex < Privileges->PrivilegeCount ;
                         PrivilegeIndex++) {

                        if (RtlEqualLuid(&Privileges->Privilege[PrivilegeIndex].Luid,
                                         &DesiredPrivilege->Privilege[0].Luid)) {
                                break;
                        }
                    }

                    //
                    // If we found the privilege, add it to the list.
                    //

                    if (PrivilegeIndex != Privileges->PrivilegeCount) {

                        //
                        // Add this account to the enumeration.
                        //

                        NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                        if (NextAccount == NULL) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                        if (NextAccount->Sid == NULL) {
                            MIDL_user_free(NextAccount);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        RtlCopyMemory(
                            NextAccount->Sid,
                            Accounts[AccountIndex].Sid,
                            RtlLengthSid(Accounts[AccountIndex].Sid)
                            );
                        NextAccount->Next = AccountList;
                        AccountList = NextAccount;

                    }
                    LsaFreeMemory(Privileges);
                    Privileges = NULL;

                } else {

                    //
                    // Otherwise get the system access
                    //

                    ASSERT(DesiredAccess != 0);

                    Status = LsaGetSystemAccessAccount(
                                AccountHandle,
                                &SystemAccess
                                );

                    if (!NT_SUCCESS(Status)) {
                        goto Cleanup;
                    }

                    //
                    // Check for the desired access
                    //

                    if ((SystemAccess & DesiredAccess) != 0) {

                        //
                        // Add this account to the enumeration.
                        //

                        NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                        if (NextAccount == NULL) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                        if (NextAccount->Sid == NULL) {
                            MIDL_user_free(NextAccount);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        RtlCopyMemory(
                            NextAccount->Sid,
                            Accounts[AccountIndex].Sid,
                            RtlLengthSid(Accounts[AccountIndex].Sid)
                            );
                        NextAccount->Next = AccountList;
                        AccountList = NextAccount;

                    }
                }

                LsaClose(AccountHandle);
                AccountHandle = NULL;


            } else {
                //
                // always add the account if the caller didn't want
                // filtering.
                //

                NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                if (NextAccount == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                if (NextAccount->Sid == NULL) {
                    MIDL_user_free(NextAccount);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                RtlCopyMemory(
                    NextAccount->Sid,
                    Accounts[AccountIndex].Sid,
                    RtlLengthSid(Accounts[AccountIndex].Sid)
                    );
                NextAccount->Next = AccountList;
                AccountList = NextAccount;
            }

        }
        LsaFreeMemory(Accounts);
        Accounts = NULL;

    } while ( 1 );

    if (Status != STATUS_NO_MORE_ENTRIES) {
        goto Cleanup;
    }

    AccountSize = 0;
    AccountCount = 0;
    for (NextAccount = AccountList ; NextAccount != NULL; NextAccount = NextAccount->Next) {
        AccountSize += sizeof(LSA_ENUMERATION_INFORMATION) +
                        RtlLengthSid(NextAccount->Sid);
        AccountCount++;
    }

    //
    // If there were no accounts return a warning now.
    //

    if (AccountCount == 0) {
        *EnumerationBuffer = NULL;
        *CountReturned = 0;
        Status = STATUS_NO_MORE_ENTRIES;
        goto Cleanup;
    }

    Accounts = MIDL_user_allocate(AccountSize);
    if (Accounts == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Marshall all the sids into the array.
    //

    Where = (PUCHAR) Accounts + AccountCount * sizeof(LSA_ENUMERATION_INFORMATION);

    for (   NextAccount = AccountList,AccountIndex = 0 ;
            NextAccount != NULL;
            NextAccount = NextAccount->Next, AccountIndex++) {

        Accounts[AccountIndex].Sid = (PSID) Where;
        RtlCopyMemory(
            Where,
            NextAccount->Sid,
            RtlLengthSid(NextAccount->Sid)
            );
        Where += RtlLengthSid(NextAccount->Sid);
    }
    ASSERT(AccountIndex == AccountCount);
    ASSERT(Where - (PUCHAR) Accounts == (LONG) AccountSize);
    *EnumerationBuffer = Accounts;
    Accounts = NULL;
    *CountReturned = AccountCount;
    Status = STATUS_SUCCESS;


Cleanup:
    if (AccountList != NULL) {
        while (AccountList != NULL) {
            NextAccount = AccountList->Next;
            MIDL_user_free(AccountList->Sid);
            MIDL_user_free(AccountList);
            AccountList = NextAccount;
        }
    }

    if (Accounts != NULL) {
        MIDL_user_free(Accounts);
    }

    if (Privileges != NULL) {
        LsaFreeMemory(Privileges);
    }

    if( DesiredPrivilege ) {
        MIDL_user_free( DesiredPrivilege );
    }
    
    return(Status);
}



NTSTATUS
NTAPI
LsapEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PUNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    )

/*++

Routine Description:

    Returns all the rights of an account.  This is done by gathering the
    privileges and system access of an account and translating that into
    an array of strings.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  This API requires
        no special access.

    AccountSid - Sid of account to open.

    UserRights - receives an array of user rights (UNICODE_STRING) for
        the account.

    CountOfRights - receives the number of rights returned.


Return Value:

    STATUS_ACCESS_DENIED - the caller did not have sufficient access to
        return the privileges or system access of the account.

    STATUS_OBJECT_NAME_NOT_FOUND - the specified account did not exist.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the
        request.

--*/
{
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess = 0;
    PUNICODE_STRING Rights = NULL;
    ULONG RightCount = 0;
    LSA_HANDLE AccountHandle = NULL;

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_VIEW,
                &AccountHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Query the privilegs and system access
    //

    Status = LsaEnumeratePrivilegesOfAccount(
                AccountHandle,
                &Privileges
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &SystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Convert the privileges and access to rights
    //

    Status = LsapApiConvertPrivilegesToRights(
                PolicyHandle,
                Privileges,
                SystemAccess,
                &Rights,
                &RightCount
                );
    if (NT_SUCCESS(Status)) {
        *CountOfRights = RightCount;
        *UserRights = Rights;
    }
Cleanup:
    if (Privileges != NULL) {
        LsaFreeMemory(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }

    return(Status);

}

NTSTATUS
NTAPI
LsapAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )
/*++

Routine Description:

    Adds rights to the account specified by the account sid.  If the account
    does not exist, it creates the account.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must have
        POLICY_CREATE_ACCOUNT access if this is the first call for this
        AccountSid.

    AccountSid - Sid of account to add rights to

    UserRights - Array of unicode strings naming rights to add to the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess;
    ULONG OldAccess;

    //
    // Convert the rights into privileges and system access.
    //

    Status = LsapApiConvertRightsToPrivileges(
                PolicyHandle,
                UserRights,
                CountOfRights,
                &Privileges,
                &SystemAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Open the account.  If it does not exist ,create the account.
    //

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_ADJUST_PRIVILEGES |
                    ACCOUNT_ADJUST_SYSTEM_ACCESS |
                    ACCOUNT_VIEW,
                &AccountHandle
                );

    //
    // if the account did not exist, try to create it.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = LsaCreateAccount(
                    PolicyHandle,
                    AccountSid,
                    ACCOUNT_ADJUST_PRIVILEGES |
                        ACCOUNT_ADJUST_SYSTEM_ACCESS |
                        ACCOUNT_VIEW,
                    &AccountHandle
                    );
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &OldAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaSetSystemAccessAccount(
                AccountHandle,
                OldAccess | SystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaAddPrivilegesToAccount(
                AccountHandle,
                Privileges
                );
Cleanup:

    if (Privileges != NULL) {
        MIDL_user_free(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }
    return(Status);
}

NTSTATUS
NTAPI
LsapRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Removes rights to the account specified by the account sid.  If the
    AllRights flag is set or if all the rights are removed, the account
    is deleted.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call

    AccountSid - Sid of account to remove rights from

    UserRights - Array of unicode strings naming rights to remove from the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    PPRIVILEGE_SET NewPrivileges = NULL;
    ULONG SystemAccess = 0 ;
    ULONG OldAccess;
    ULONG DesiredAccess;
    ULONG NewAccess;

    //
    // Convert the rights into privileges and system access.
    //

    if (!AllRights) {
        Status = LsapApiConvertRightsToPrivileges(
                    PolicyHandle,
                    UserRights,
                    CountOfRights,
                    &Privileges,
                    &SystemAccess
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        DesiredAccess = ACCOUNT_ADJUST_PRIVILEGES |
                            ACCOUNT_ADJUST_SYSTEM_ACCESS |
                            ACCOUNT_VIEW | DELETE;
    } else {
        DesiredAccess = DELETE;
    }



    //
    // Open the account.
    //

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                DesiredAccess,
                &AccountHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If we are to remove all rights, just delete the account ,and if that
    // succeeds, zero the handle so we don't try to close it later.
    //

    if (AllRights) {
        Status = LsaDelete(
                    AccountHandle
                    );
        if (NT_SUCCESS(Status)) {
            AccountHandle = NULL;
        }
        goto Cleanup;
    }

    //
    // Get the old system access to adjust
    //

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &OldAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    NewAccess = OldAccess & ~SystemAccess;
    Status = LsaSetSystemAccessAccount(
                AccountHandle,
                NewAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaRemovePrivilegesFromAccount(
                AccountHandle,
                FALSE,          // don't remove all
                Privileges
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Now query the privilegs to see if they are zero.  If so, and
    // system access is zero, delete the account.
    //

    Status = LsaEnumeratePrivilegesOfAccount(
                AccountHandle,
                &NewPrivileges
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // If the account has no privileges or access, delete it.
    //

    if ((NewPrivileges->PrivilegeCount == 0) &&
        (NewAccess == 0)) {

        Status = LsaDelete(
                    AccountHandle
                    );
        if (NT_SUCCESS(Status)) {
            AccountHandle = NULL;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if (Privileges != NULL) {
        MIDL_user_free(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }
    if (NewPrivileges != NULL) {
        LsaFreeMemory(NewPrivileges);
    }
    return(Status);

}


NTSTATUS
LsapApiBuildSecretName(
    PTRUSTED_DOMAIN_NAME_INFO NameInfo,
    PUNICODE_STRING OutputSecretName
    )
{
    UNICODE_STRING SecretName;

    //
    // The secret name is G$$domain name, where G$ is the global prefix and
    // $ is the ssi prefix
    //

    SecretName.Length = NameInfo->Name.Length +
                        (SSI_SECRET_PREFIX_LENGTH +
                         LSA_GLOBAL_SECRET_PREFIX_LENGTH) * sizeof(WCHAR);
    SecretName.MaximumLength = SecretName.Length;
    SecretName.Buffer = (LPWSTR) MIDL_user_allocate( SecretName.Length );

    if (SecretName.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    wcscpy(
        SecretName.Buffer,
        LSA_GLOBAL_SECRET_PREFIX
        );

    wcscat(
        SecretName.Buffer,
        SSI_SECRET_PREFIX
        );
    RtlCopyMemory(
        SecretName.Buffer +
            LSA_GLOBAL_SECRET_PREFIX_LENGTH +
            SSI_SECRET_PREFIX_LENGTH,
        NameInfo->Name.Buffer,
        NameInfo->Name.Length
        );
    *OutputSecretName = SecretName;
    return(STATUS_SUCCESS);

}

NTSTATUS
NTAPI
LsapQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryTrustedDomainInfo API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).  It also
    may query the secret object (for the TrustedDomainPasswordInformation
    class).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to query.

    InformationClass - Specifies the information to be returned.

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/
{
    NTSTATUS Status;
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;
    PUNICODE_STRING OldPassword = NULL;
    PUNICODE_STRING Password = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInfo = NULL;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    ULONG DesiredAccess;
    PVOID LocalBuffer = NULL;
    TRUSTED_INFORMATION_CLASS LocalInfoClass;
    UNICODE_STRING SecretName;
    PUCHAR Where;
    ULONG PasswordSize;

    SecretName.Buffer = NULL;

    //
    // Find the desired access type for the info we are
    // querying.
    //

    LocalInfoClass = InformationClass;

    switch(InformationClass) {
    case TrustedDomainNameInformation:
        DesiredAccess = TRUSTED_QUERY_DOMAIN_NAME;
        break;
    case TrustedPosixOffsetInformation:
        DesiredAccess = TRUSTED_QUERY_POSIX;
        break;
    case TrustedPasswordInformation:
        DesiredAccess = TRUSTED_QUERY_DOMAIN_NAME;
        LocalInfoClass = TrustedDomainNameInformation;
        break;
    default:
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Open the domain for the desired access
    //


    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                DesiredAccess,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                LocalInfoClass,
                &LocalBuffer
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If the class wasn't trusted password information, return here.
    //

    if (InformationClass != TrustedPasswordInformation) {
        *Buffer = LocalBuffer;
        LocalBuffer = NULL;
        goto Cleanup;
    }
    NameInfo = (PTRUSTED_DOMAIN_NAME_INFO) LocalBuffer;

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Query the secret
    //

    Status = LsaQuerySecret(
                SecretHandle,
                &Password,
                NULL,
                &OldPassword,
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Marshall the passwords into the output structure.
    //

    PasswordSize = sizeof(TRUSTED_PASSWORD_INFO);
    if (Password != NULL) {
        PasswordSize += Password->MaximumLength;
    }

    if (OldPassword != NULL) {
        PasswordSize += OldPassword->MaximumLength;
    }

    PasswordInfo = (PTRUSTED_PASSWORD_INFO) MIDL_user_allocate(PasswordSize);
    if (PasswordInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        PasswordInfo,
        PasswordSize
        );

    Where = (PUCHAR) (PasswordInfo+1);

    if (Password != NULL) {
        PasswordInfo->Password = *Password;
        PasswordInfo->Password.Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            Password->Buffer,
            Password->MaximumLength
            );
        Where += Password->MaximumLength;
    }

    if (OldPassword != NULL) {
        PasswordInfo->OldPassword = *OldPassword;
        PasswordInfo->OldPassword.Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            OldPassword->Buffer,
            OldPassword->MaximumLength
            );
        Where += OldPassword->MaximumLength;
    }

    ASSERT(Where - (PUCHAR) PasswordInfo == (LONG) PasswordSize);

    *Buffer = PasswordInfo;
    Status = STATUS_SUCCESS;

Cleanup:
    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    if (LocalBuffer != NULL) {
        LsaFreeMemory(LocalBuffer);
    }

    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    return(Status);

}

NTSTATUS
NTAPI
LsapSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
/*++

Routine Description:


    The LsaSetTrustedDomainInformation API modifies information in the Trusted
    Domain Object and in the Secret Object.  The caller must have access
    appropriate to the information to be changed in the Policy Object, see
    the InformationClass parameter.

    If the domain does not yet exist and the information class is
    TrustedDomainNameInformation, then the domain is created.  If the
    domain exists and the class is TrustedDomainNameInformation, an
    error is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to modify.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation      POLICY_TRUST_ADMIN
        TrustedPosixOffsetInformation     none
        TrustedPasswordInformation        POLICY_CREATE_SECRET

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    PUNICODE_STRING OldPassword;
    PUNICODE_STRING Password;
    LSA_TRUST_INFORMATION DomainInformation;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInfo;
    UNICODE_STRING SecretName;

    SecretName.Buffer = NULL;

    //
    // If the information is the domain name, try to create the domain.
    //

    if (InformationClass == TrustedDomainNameInformation) {
        DomainInformation.Sid = TrustedDomainSid;
        DomainInformation.Name = ((PTRUSTED_DOMAIN_NAME_INFO) Buffer)->Name;

        Status = LsaCreateTrustedDomain(
                    PolicyHandle,
                    &DomainInformation,
                    0,  //desired access,
                    &DomainHandle
                    );
        goto Cleanup;
    }

    //
    // For posix offset, open the domain for SET_POSIX and call the old
    // LSA API to set the offset.
    //

    if (InformationClass == TrustedPosixOffsetInformation) {
        Status = LsaOpenTrustedDomain(
                    PolicyHandle,
                    TrustedDomainSid,
                    TRUSTED_SET_POSIX,
                    &DomainHandle
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = LsaSetInformationTrustedDomain(
                    DomainHandle,
                    InformationClass,
                    Buffer
                    );
        goto Cleanup;
    }

    //
    // The only only remaining allowed class is password information.
    //

    if (InformationClass != TrustedPasswordInformation) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the name so we can find the secret name.
    //

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &NameInfo
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                SECRET_SET_VALUE,
                &SecretHandle
                );

    //
    // If the secret didn't exist, create it now.
    //
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = LsaCreateSecret(
                    PolicyHandle,
                    &SecretName,
                    SECRET_SET_VALUE,
                    &SecretHandle
                    );

    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If the old password wasn't specified, set it to be the new
    // password.
    //

    PasswordInfo = (PTRUSTED_PASSWORD_INFO) Buffer;
    Password = &PasswordInfo->Password;
    if (PasswordInfo->OldPassword.Buffer == NULL) {
        OldPassword = Password;
    } else {
        OldPassword = &PasswordInfo->OldPassword;
    }

    Status = LsaSetSecret(
                SecretHandle,
                Password,
                OldPassword
                );
Cleanup:
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    if (NameInfo != NULL) {
        LsaFreeMemory(NameInfo);
    }

    return(Status);


}

NTSTATUS
NTAPI
LsapDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    )

/*++

Routine Description:

    This routine deletes a trusted domain and the associated secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to delete

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to delete
        the requested domain.

    STATUS_OBJECT_NAME_NOT_FOUND - The requested domain does not exist.

--*/
{
    UNICODE_STRING SecretName;
    NTSTATUS Status;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;


    SecretName.Buffer = NULL;

    //
    // Open the domain for query name and delete access. We need query name
    // to find the secret name.
    //

    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME | DELETE,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the name so we can find the secret name.
    //

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &NameInfo
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaDelete(DomainHandle);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Zero the handle so we don't try to free it again.
    //

    DomainHandle = NULL;

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                DELETE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        //
        // If the secret does not exist, that is o.k. - it means the password
        // was never set.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    Status = LsaDelete(SecretHandle);
    if (NT_SUCCESS(Status)) {
        //
        // Zero the handle so we don't try to free it again.
        //
        SecretHandle = NULL;
    }

Cleanup:
    if (NameInfo != NULL) {
        LsaFreeMemory(NameInfo);
    }
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }
    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    return(Status);



}


NTSTATUS
NTAPI
LsapStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    IN OPTIONAL PUNICODE_STRING PrivateData
    )

/*++

Routine Description:

    This routine stores private data in a secret named KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  If this is the
        first call, it requres POLICY_CREATE_SECRET access.

    KeyName - Name of secret to store

    PrivateData - Private data to store.  If this is null, the secret is
        deleted.

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient privilege to set
        the workstation password.

--*/

{
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    ULONG DesiredAccess;
    BOOLEAN DeleteSecret = FALSE;

    //
    // check whether to delete the secret or not.
    //

    if (ARGUMENT_PRESENT(PrivateData)) {
        DesiredAccess = SECRET_SET_VALUE;
    } else {
        DesiredAccess = DELETE;
        DeleteSecret = TRUE;
    }


    Status = LsaOpenSecret(
                PolicyHandle,
                KeyName,
                DesiredAccess,
                &SecretHandle
                );

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND) && !DeleteSecret) {
        Status = LsaCreateSecret(
                    PolicyHandle,
                    KeyName,
                    DesiredAccess,
                    &SecretHandle
                    );


    }
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (DeleteSecret) {
        Status = LsaDelete(
                    SecretHandle
                    );

        if (NT_SUCCESS(Status)) {
            SecretHandle = NULL;
        }
        goto Cleanup;

    }

    Status = LsaSetSecret(
                SecretHandle,
                PrivateData,
                PrivateData
                );

Cleanup:
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    return(Status);


}

NTSTATUS
NTAPI
LsapRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    OUT PUNICODE_STRING * PrivateData
    )

/*++

Routine Description:

    This routine returns the secret data stored under KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall

    KeyName - Name of secret data to retrieve

    PrivateData - Receives a pointer private data

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to get the
        workstation password.

    STATUS_OBJECT_NAME_NOT_FOUND - there is no workstation password.

--*/
{
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;

    //
    // Make the secret name
    //


    Status = LsaOpenSecret(
                PolicyHandle,
                KeyName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaQuerySecret(
                SecretHandle,
                PrivateData,
                NULL,
                NULL,
                NULL
                );
Cleanup:
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    return(Status);

}

/////////////////////////////////////////////////////////////////////////
//
// RPC wrappers for LSA APIs added in nt3.51.  This routines call the
// LSA, and if the interface doesn't exist, calls the LsapXXX routine
// to accomplish the same task using the older routines.
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PUNICODE_STRING UserRight,
    OUT PVOID *Buffer,
    OUT PULONG CountReturned
    )

/*++

Routine Description:


    The LsaEnumerateAccounts API returns information about the accounts
    in the target system's Lsa Database.  This call requires
    LSA_ENUMERATE_ACCOUNTS access to the Policy object.  Since this call
    accesses the privileges of an account, you must have PRIVILEGE_VIEW
    access to the pseudo-privilege object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    UserRight - Name of the right that the account must have.

    Buffer - Receives a pointer to a LSA_ENUMERATION_INFORMATION structure
        containing the SIDs of all the accounts.

    CountReturned - Receives the number of sids returned.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS   Status;

    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    RpcTryExcept {

        //
        // Enumerate the Accounts.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Accounts enumerated this call
        // and a pointer to an array of Account Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Account Info for Domain 0
        //                                      Account Info for Domain 1
        //                                      ...
        //                                      Account Info for Domain
        //                                         (EntriesRead - 1)
        //

        Status = LsarEnumerateAccountsWithUserRight(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) UserRight,
                     &EnumerationBuffer
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapEnumerateAccountsWithUserRight(
                    PolicyHandle,
                    UserRight,
                    Buffer,
                    CountReturned
                    );
    }

    return Status;

}



NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PUNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    )


/*++

Routine Description:

    Returns all the rights of an account.  This is done by gathering the
    privileges and system access of an account and translating that into
    an array of strings.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  This API requires
        no special access.

    AccountSid - Sid of account to open.

    UserRights - receives an array of user rights (UNICODE_STRING) for
        the account.

    CountOfRights - receives the number of rights returned.


Return Value:

    STATUS_ACCESS_DENIED - the caller did not have sufficient access to
        return the privileges or system access of the account.

    STATUS_OBJECT_NAME_NOT_FOUND - the specified account did not exist.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the
        request.

--*/

{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = 0;
    UserRightSet.UserRights = NULL;

    RpcTryExcept {


        Status = LsarEnumerateAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     &UserRightSet
                     );

        *CountOfRights = UserRightSet.Entries;
        *UserRights = (PUNICODE_STRING) UserRightSet.UserRights;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
        if (UserRightSet.UserRights != NULL) {
            MIDL_user_free(UserRightSet.UserRights);
        }

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapEnumerateAccountRights(
                    PolicyHandle,
                    AccountSid,
                    UserRights,
                    CountOfRights
                    );

    }

    return Status;
}


NTSTATUS
NTAPI
LsaAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Adds rights to the account specified by the account sid.  If the account
    does not exist, it creates the account.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must have
        POLICY_CREATE_ACCOUNT access if this is the first call for this
        AccountSid.

    AccountSid - Sid of account to add rights to

    UserRights - Array of unicode strings naming rights to add to the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/

{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = CountOfRights;
    UserRightSet.UserRights = (PLSAPR_UNICODE_STRING) UserRights;

    RpcTryExcept {

        Status = LsarAddAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     &UserRightSet
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapAddAccountRights(
                    PolicyHandle,
                    AccountSid,
                    UserRights,
                    CountOfRights
                    );
    }
    return Status;
}


NTSTATUS
NTAPI
LsaRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Removes rights to the account specified by the account sid.  If the
    AllRights flag is set or if all the rights are removed, the account
    is deleted.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call

    AccountSid - Sid of account to remove rights from

    UserRights - Array of unicode strings naming rights to remove from the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = CountOfRights;
    UserRightSet.UserRights = (PLSAPR_UNICODE_STRING) UserRights;

    RpcTryExcept {

        Status = LsarRemoveAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     AllRights,
                     &UserRightSet
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapRemoveAccountRights(
                    PolicyHandle,
                    AccountSid,
                    AllRights,
                    UserRights,
                    CountOfRights
                    );
    }

    return Status;
}

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryTrustedDomainInfo API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).  It also
    may query the secret object (for the TrustedDomainPasswordInformation
    class).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to query.

    InformationClass - Specifies the information to be returned.

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/
{
    NTSTATUS Status;
    PLSAP_CR_CIPHER_VALUE CipherPassword = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldPassword = NULL;
    PLSAP_CR_CLEAR_VALUE ClearPassword = NULL;
    PLSAP_CR_CLEAR_VALUE ClearOldPassword = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    ULONG DomainInfoSize;
    PUCHAR Where = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInformation = NULL;

    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation = NULL;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationTrustedDomain.
        //

        Status = LsarQueryTrustedDomainInfo(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     InformationClass,
                     &TrustedDomainInformation
                     );

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //


    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Trusted Domain Information,
        // free it.
        //

        if (TrustedDomainInformation != NULL) {

            MIDL_user_free(TrustedDomainInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // if we aren't getting passwords, skip out here. Otherwise we need to
    // decrypt the passwords.
    //

    if (InformationClass != TrustedPasswordInformation) {
        *Buffer = TrustedDomainInformation;
        TrustedDomainInformation = NULL;
        goto Cleanup;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (TrustedDomainInformation->TrustedPasswordInfo.Password != NULL) {

        Status = LsapCrDecryptValue(
                     (PLSAP_CR_CIPHER_VALUE)
                        TrustedDomainInformation->TrustedPasswordInfo.Password,
                     SessionKey,
                     &ClearPassword
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearPassword,
            (PUNICODE_STRING) ClearPassword
            );


    }

    //
    // Get the old password
    //

    if (TrustedDomainInformation->TrustedPasswordInfo.OldPassword != NULL) {

        Status = LsapCrDecryptValue(
                    (PLSAP_CR_CIPHER_VALUE)
                        TrustedDomainInformation->TrustedPasswordInfo.OldPassword,
                    SessionKey,
                    &ClearOldPassword
                    );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearOldPassword,
            (PUNICODE_STRING) ClearOldPassword
            );


    }


    MIDL_user_free(TrustedDomainInformation);
    TrustedDomainInformation = NULL;


    //
    // Allocate a buffer for the two passwords and marshall the
    // passwords into the buffer.
    //

    DomainInfoSize = sizeof(TRUSTED_PASSWORD_INFO);

    if (ClearPassword != NULL) {

        DomainInfoSize += ((PUNICODE_STRING) ClearPassword)->MaximumLength;
    }
    if (ClearOldPassword != NULL) {

        DomainInfoSize += ((PUNICODE_STRING) ClearOldPassword)->MaximumLength;
    }

    PasswordInformation = (PTRUSTED_PASSWORD_INFO) MIDL_user_allocate(DomainInfoSize);
    if (PasswordInformation == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) (PasswordInformation+1);

    if (ClearPassword != NULL)
    {
        PasswordInformation->Password = *(PUNICODE_STRING) ClearPassword;
        PasswordInformation->Password.Buffer = (LPWSTR) Where;
        Where += PasswordInformation->Password.MaximumLength;
        RtlCopyUnicodeString(
            &PasswordInformation->Password,
            (PUNICODE_STRING) ClearPassword
            );
    }

    if (ClearOldPassword != NULL)
    {
        PasswordInformation->OldPassword = *(PUNICODE_STRING) ClearOldPassword;
        PasswordInformation->OldPassword.Buffer = (LPWSTR) Where;
        Where += PasswordInformation->OldPassword.MaximumLength;
        RtlCopyUnicodeString(
            &PasswordInformation->OldPassword,
            (PUNICODE_STRING) ClearOldPassword
            );
    }
    ASSERT(Where - (PUCHAR) PasswordInformation == (LONG) DomainInfoSize);

    *Buffer = PasswordInformation;
    PasswordInformation = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherPassword != NULL) {

        LsapCrFreeMemoryValue(CipherPassword);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Old Value.
    //

    if (CipherOldPassword != NULL) {

        LsapCrFreeMemoryValue(CipherOldPassword);
    }
    if (ClearPassword != NULL) {

        LsapCrFreeMemoryValue(ClearPassword);
    }
    if (ClearOldPassword != NULL) {

        LsapCrFreeMemoryValue(ClearOldPassword);
    }

    if (TrustedDomainInformation != NULL) {
        MIDL_user_free(TrustedDomainInformation);
    }

    if (PasswordInformation != NULL) {
        MIDL_user_free(PasswordInformation);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapQueryTrustedDomainInfo(
                    PolicyHandle,
                    TrustedDomainSid,
                    InformationClass,
                    Buffer
                    );
    }

    return Status;
}

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )


/*++

Routine Description:


    The LsaSetTrustedDomainInformation API modifies information in the Trusted
    Domain Object and in the Secret Object.  The caller must have access
    appropriate to the information to be changed in the Policy Object, see
    the InformationClass parameter.

    If the domain does not yet exist and the information class is
    TrustedDomainNameInformation, then the domain is created.  If the
    domain exists and the class is TrustedDomainNameInformation, an
    error is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to modify.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation      POLICY_TRUST_ADMIN
        TrustedPosixOffsetInformation     none
        TrustedPasswordInformation        POLICY_CREATE_SECRET

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_INFO_CLASS - Setting information for specified information class
            is not supported

        Others TBS
--*/

{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_INFO DomainInformation;
    LSAPR_TRUSTED_PASSWORD_INFO LsaPasswordInfo;
    PTRUSTED_PASSWORD_INFO PasswordInformation;
    PLSAP_CR_CIPHER_VALUE CipherPassword = NULL;
    LSAP_CR_CLEAR_VALUE ClearPassword;
    PLSAP_CR_CIPHER_VALUE CipherOldPassword = NULL;
    LSAP_CR_CLEAR_VALUE ClearOldPassword;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    PUNICODE_STRING OldPassword;

    //
    // If the infotype is TrustedPasswordInformation, then we need to
    // setup a secure channel to transmit the secret passwords.
    //

    switch ( InformationClass ) {
    case TrustedPasswordInformation:

        PasswordInformation = (PTRUSTED_PASSWORD_INFO) Buffer;
        LsaPasswordInfo.Password = NULL;
        LsaPasswordInfo.OldPassword = NULL;

        //
        // Obtain the Session Key to be used to two-way encrypt the
        // Current Value.
        //

        RpcTryExcept {

            Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // The password must be specified, even if it is an empty string.
        //

        if (PasswordInformation->Password.Buffer != NULL) {

            //
            // Convert input from Unicode Structures to Clear Value Structures.
            //

            LsapCrUnicodeToClearValue(
                &PasswordInformation->Password,
                &ClearPassword
                );



            //
            // Encrypt the Current Value if specified and not too long.
            //


            Status = LsapCrEncryptValue(
                         &ClearPassword,
                         SessionKey,
                         &CipherPassword
                         );

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            LsaPasswordInfo.Password = (PLSAPR_CR_CIPHER_VALUE) CipherPassword;

            //
            // If the old password wasn't specified, set it to be the
            // new password.
            //

            if (PasswordInformation->OldPassword.Buffer == NULL) {
                OldPassword = &PasswordInformation->Password;
            } else {
                OldPassword = &PasswordInformation->OldPassword;
            }


            //
            // Convert input from Unicode Structures to Clear Value Structures.
            //

            LsapCrUnicodeToClearValue(
                OldPassword,
                &ClearOldPassword
                );



            //
            // Encrypt the Current Value if specified and not too long.
            //


            Status = LsapCrEncryptValue(
                         &ClearOldPassword,
                         SessionKey,
                         &CipherOldPassword
                         );

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            LsaPasswordInfo.OldPassword = (PLSAPR_CR_CIPHER_VALUE) CipherOldPassword;
        } else {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        DomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &LsaPasswordInfo;
        break;

    //
    // There are only two other info levels handled
    //

    case TrustedPosixOffsetInformation:
    case TrustedDomainNameInformation:
        DomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer;
        break;

    //
    // No other info levels are supported
    //
    default:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaSetInformationTrustedDomain
        //

        Status = LsarSetTrustedDomainInfo
        (
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     InformationClass,
                     DomainInformation
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if (SessionKey != NULL) {
        MIDL_user_free(SessionKey);
    }
    if (CipherPassword != NULL) {
        LsaFreeMemory(CipherPassword);
    }
    if (CipherOldPassword != NULL) {
        LsaFreeMemory(CipherOldPassword);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapSetTrustedDomainInformation(
                    PolicyHandle,
                    TrustedDomainSid,
                    InformationClass,
                    Buffer
                    );
    }

    return Status;
}


NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    )

/*++

Routine Description:

    This routine deletes a trusted domain and the associated secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to delete

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to delete
        the requested domain.

    STATUS_OBJECT_NAME_NOT_FOUND - The requested domain does not exist.

--*/
{
    NTSTATUS Status;

    RpcTryExcept {


        Status = LsarDeleteTrustedDomain(
                    (LSAPR_HANDLE) PolicyHandle,
                    (PLSAPR_SID) TrustedDomainSid
                    );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapDeleteTrustedDomain(
                    PolicyHandle,
                    TrustedDomainSid
                    );
    }

    return(Status);
}

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    IN OPTIONAL PUNICODE_STRING PrivateData
    )

/*++

Routine Description:

    This routine stores private data in an LSA secret named KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  If this is the
        first call, it requres POLICY_CREATE_SECRET access.

    KeyName - Name of secret to store.

    PrivateData - Data to store. If not present, the secret is deleted.

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient privilege to set
        the workstation password.

--*/


{
    NTSTATUS Status;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    LSAP_CR_CLEAR_VALUE ClearCurrentValue;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    if (ARGUMENT_PRESENT(PrivateData)) {

        //
        // Convert input from Unicode Structures to Clear Value Structures.
        //


        LsapCrUnicodeToClearValue( PrivateData, &ClearCurrentValue );

        //
        // Obtain the Session Key to be used to two-way encrypt the
        // Current Value.
        //

        RpcTryExcept {

            Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Encrypt the Current Value if specified and not too long.
        //


        Status = LsapCrEncryptValue(
                     &ClearCurrentValue,
                     SessionKey,
                     &CipherCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }


    }

    //
    // Set the Secret Values.
    //

    RpcTryExcept {

        Status = LsarStorePrivateData(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) KeyName,
                     (PLSAPR_CR_CIPHER_VALUE) CipherCurrentValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

Cleanup:

    //
    // If necessary, free memory allocated for the Encrypted Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsaFreeMemory(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapStorePrivateData(
                    PolicyHandle,
                    KeyName,
                    PrivateData
                    );
    }


    return(Status);

}


NTSTATUS
NTAPI
LsaRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    OUT PUNICODE_STRING *PrivateData
    )

/*++

Routine Description:

    This routine returns the secret stored in KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall

    KeyName - Name of secret to retrieve

    PrivateData - Receives private data, should be freed with LsaFreeMemory.


Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to get the
        private data.

    STATUS_OBJECT_NAME_NOT_FOUND - there is no private data stored under
        KeyName.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearCurrentValue = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    RpcTryExcept {

        Status = LsarRetrievePrivateData(
                     (PLSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) KeyName,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherCurrentValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;

    } else {

        //
        // LsapCrClientGetSessionKey may return STATUS_LOCAL_USER_SESSION_KEY
        // which should be hidden behind STATUS_SUCCESS
        //

        Status = STATUS_SUCCESS;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (CipherCurrentValue != NULL) {

        Status = LsapCrDecryptValue(
                     CipherCurrentValue,
                     SessionKey,
                     &ClearCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearCurrentValue,
            (PUNICODE_STRING) ClearCurrentValue
            );
        *PrivateData = (PUNICODE_STRING) ClearCurrentValue;

    } else {

        *PrivateData = NULL;
    }

QuerySecretFinish:

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsapCrFreeMemoryValue(CipherCurrentValue);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapRetrievePrivateData(
                    PolicyHandle,
                    KeyName,
                    PrivateData
                    );
    }

    return(Status);

QuerySecretError:

    //
    // If necessary, free memory allocated for the Clear Current Value
    //

    if (ClearCurrentValue != NULL) {

        LsapCrFreeMemoryValue(ClearCurrentValue);
    }

    *PrivateData = NULL;

    goto QuerySecretFinish;
}



NTSTATUS
LsapApiConvertRightsToPrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING UserRights,
    IN ULONG RightCount,
    OUT PPRIVILEGE_SET * Privileges,
    OUT PULONG SystemAccess
    )
/*++

Routine Description:

    Converts an array of user rights (unicode strings) into a privilege set
    and a system access flag.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall, requires POLICY_LOOKUP_NAME
        access.

    UserRights - Array of user rights

    RightCount - Count of user rights

    Privileges - Receives privilege set, should be freed with MIDL_user_free

    SystemAccess - Receives system access flags.

Return Value:

--*/

{
    ULONG RightIndex;
    ULONG PrivilegeIndex;
    ULONG AccessIndex;
    PPRIVILEGE_SET PrivilegeSet = NULL;
    ULONG Access = 0;
    ULONG PrivilegeSetSize = 0;
    NTSTATUS Status;
    LUID PrivilegeValue;

    //
    // if we weren't passed any privileges, don't allocate anything.
    //

    if (RightCount == 0) {

        *Privileges = NULL;
        *SystemAccess = 0;
        return(STATUS_SUCCESS);
    }

    //
    // Compute the size of the privilege set.  We actually over estimate
    // by assuming that all the rights are privileges.  We subtract one
    // from RightCount to take into account the fact that a PRIVILEGE_SET
    // has one LUID_AND_ATTRIBUTE in it.
    //


    PrivilegeSetSize = sizeof(PRIVILEGE_SET) +
                        (RightCount-1) * sizeof(LUID_AND_ATTRIBUTES);

    PrivilegeSet = (PPRIVILEGE_SET) MIDL_user_allocate(PrivilegeSetSize);

    if (PrivilegeSet == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Try looking up every right.  If we find it as a privilege,
    // add it to the privilege set.
    //

    PrivilegeIndex = 0;

    for (RightIndex = 0; RightIndex < RightCount ; RightIndex++) {
        Status = LsaLookupPrivilegeValue(
                    PolicyHandle,
                    &UserRights[RightIndex],
                    &PrivilegeValue
                    );
        if (NT_SUCCESS(Status)) {
            PrivilegeSet->Privilege[PrivilegeIndex].Luid = PrivilegeValue;
            PrivilegeSet->Privilege[PrivilegeIndex].Attributes = 0;
            PrivilegeIndex++;

        } else if (Status != STATUS_NO_SUCH_PRIVILEGE) {
            //
            // This is a more serious error - bail here.
            //

            goto Cleanup;
        } else {

            //
            // Try looking up the right as a system access type.
            //

            for (AccessIndex = 0; AccessIndex < LSAP_DB_SYSTEM_ACCESS_TYPES ; AccessIndex++) {
                if (RtlCompareUnicodeString(
                        &UserRights[RightIndex],
                        &LsapDbRightAndAccess[AccessIndex].UserRight,
                        FALSE   // case sensitive
                        ) == 0) {
                    Access |= LsapDbRightAndAccess[AccessIndex].SystemAccess;
                    break;
                }
            }

            //
            // If we went through the access types without finding the right,
            // it must not be valid so escape here.
            //

            if (AccessIndex == LSAP_DB_SYSTEM_ACCESS_TYPES) {
                Status = STATUS_NO_SUCH_PRIVILEGE;
                goto Cleanup;
            }

        }
    }

    PrivilegeSet->Control = 0;
    PrivilegeSet->PrivilegeCount = PrivilegeIndex;

    *Privileges = PrivilegeSet;
    *SystemAccess = Access;

    Status = STATUS_SUCCESS;

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (PrivilegeSet != NULL) {
            LsaFreeMemory(PrivilegeSet);
        }
    }

    return(Status);

}

NTSTATUS
LsapApiConvertPrivilegesToRights(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN OPTIONAL ULONG SystemAccess,
    OUT PUNICODE_STRING * UserRights,
    OUT PULONG RightCount
    )
/*++

Routine Description:

    Converts a privilege set and a system access flag into an array of
    user rights (unicode strings).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call, must have
        POLICY_LOOKUP_NAMES access.

    Privileges - Privilege set to convert

    SystemAccess - System access flags to convert

    UserRights - Receives an array of user rights (unicode strings).  Should
        be freed with MIDL_user_free

    RightCount - Receives count of rights in UserRights array


Return Value:

--*/

{
    NTSTATUS Status;
    PUNICODE_STRING OutputRights = NULL;
    PUNICODE_STRING * PrivilegeNames = NULL;
    UNICODE_STRING AccessNames[LSAP_DB_SYSTEM_ACCESS_TYPES];
    ULONG RightSize;
    ULONG PrivilegeSize;
    ULONG Count;
    ULONG PrivilegeIndex;
    ULONG AccessIndex;
    ULONG RightIndex;
    ULONG AccessCount = 0;
    PUCHAR Where;

    //
    // Compute the size of the temporary array. This is just an array of
    // pointers to unicode strings to hold the privilege names until
    // we reallocate them into one big buffer.
    //

    RightSize = 0;
    Count = 0;
    if (ARGUMENT_PRESENT(Privileges)) {

        PrivilegeSize = Privileges->PrivilegeCount * sizeof(PUNICODE_STRING);
        PrivilegeNames = (PUNICODE_STRING *) MIDL_user_allocate(PrivilegeSize);

        if (PrivilegeNames == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory(
            PrivilegeNames,
            PrivilegeSize
            );

        //
        // Lookup the privilge name and store it in the temporary array
        //

        for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ;PrivilegeIndex++ ) {

            Status = LsaLookupPrivilegeName(
                        PolicyHandle,
                        &Privileges->Privilege[PrivilegeIndex].Luid,
                        &PrivilegeNames[PrivilegeIndex]
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            RightSize += sizeof(UNICODE_STRING) + PrivilegeNames[PrivilegeIndex]->MaximumLength;
        }
    }

    //
    // Now convert the system access flags to user rights.
    //

    if (ARGUMENT_PRESENT( (ULONG_PTR)SystemAccess )) {

        AccessCount = 0;
        for (AccessIndex = 0; AccessIndex < LSAP_DB_SYSTEM_ACCESS_TYPES ; AccessIndex++) {

            if ((SystemAccess & LsapDbRightAndAccess[AccessIndex].SystemAccess) != 0) {

                AccessNames[AccessCount] = LsapDbRightAndAccess[AccessIndex].UserRight;
                RightSize += sizeof(UNICODE_STRING) + AccessNames[AccessCount].MaximumLength;
                AccessCount++;
            }
        }
    }

    //
    // Allocate the output buffer and start copying the strings into the
    // buffer.
    //

    Count = Privileges->PrivilegeCount + AccessCount;

    OutputRights = (PUNICODE_STRING) MIDL_user_allocate(RightSize);
    if (OutputRights == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) OutputRights + (Count * sizeof(UNICODE_STRING));

    //
    // Copy in the privileges first
    //

    RightIndex = 0;
    for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ; PrivilegeIndex ++) {

        OutputRights[RightIndex] = *PrivilegeNames[PrivilegeIndex];
        OutputRights[RightIndex].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            PrivilegeNames[PrivilegeIndex]->Buffer,
            OutputRights[RightIndex].MaximumLength
            );
        Where += OutputRights[RightIndex].MaximumLength;
        RightIndex++;
    }

    //
    // Now copy in the access types
    //

    for (AccessIndex = 0; AccessIndex < AccessCount; AccessIndex++) {

        OutputRights[RightIndex] = AccessNames[AccessIndex];
        OutputRights[RightIndex].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            AccessNames[AccessIndex].Buffer,
            OutputRights[RightIndex].MaximumLength
            );
        Where += OutputRights[RightIndex].MaximumLength;
        RightIndex++;
    }

    ASSERT(RightIndex == Count);

    *UserRights = OutputRights;
    OutputRights = NULL;
    *RightCount = Count;

    Status = STATUS_SUCCESS;

Cleanup:

    if (PrivilegeNames != NULL) {
        for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ; PrivilegeIndex++) {
            if (PrivilegeNames[PrivilegeIndex] != NULL) {
                LsaFreeMemory(PrivilegeNames[PrivilegeIndex]);
            }
        }
        MIDL_user_free(PrivilegeNames);
    }

    if (OutputRights != NULL) {
        MIDL_user_free(OutputRights);
    }

    return(Status);
}



NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
{
    NTSTATUS Status;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClearAuditLog.
        //

        Status = LsarQueryTrustedDomainInfoByName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) TrustedDomainName,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO *) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsapRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    ULONG Index;
    LARGE_INTEGER Time;
    ULONG Seed;
    NTSTATUS NtStatus;


    NtStatus = NtQuerySystemTime(&Time);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    Seed = Time.LowPart ^ Time.HighPart;

    for (Index = 0 ; Index < BufferSize ; Index++ )
    {
        *Buffer++ = (UCHAR) (RtlRandom(&Seed) % 256);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
LsapEncryptAuthInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ClearAuthInfo,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *EncryptedAuthInfo
)

/*++

Routine Description:

    This routine takes a cleartext auth info and returns an encrypted auth info.

Parameters:

    PolicyHandle - Handle to the LSA policy.

    ClearAuthInfo - Cleartext of the authentication info.

    EncryptedAuthInfo - Returns an allocated buffer containing the encrypted form
        of the auth info.  The caller should free this buffer using LocalFree.

Return Values:

    STATUS_SUCCESS - the routine has completed successfully.


--*/
{
    NTSTATUS Status;
    USER_SESSION_KEY UserSessionKey;

    ULONG IncomingAuthInfoSize = 0;
    PUCHAR IncomingAuthInfo = NULL;
    ULONG OutgoingAuthInfoSize = 0;
    PUCHAR OutgoingAuthInfo = NULL;

    ULONG EncryptedSize;
    PUCHAR EncryptedBuffer;
    PUCHAR AllocatedBuffer = NULL;

    PUCHAR Where;

    struct RC4_KEYSTRUCT Rc4Key;

    //
    // Get the encryption key
    //

    Status = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)PolicyHandle,
                   &UserSessionKey );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Marshal the incoming and outgoing auth info halfs into contiguous buffers
    //

    Status = LsapDsMarshalAuthInfoHalf(
                LsapDsAuthHalfFromAuthInfo( ClearAuthInfo, TRUE ),
                &IncomingAuthInfoSize,
                &IncomingAuthInfo );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsapDsMarshalAuthInfoHalf(
                LsapDsAuthHalfFromAuthInfo( ClearAuthInfo, FALSE ),
                &OutgoingAuthInfoSize,
                &OutgoingAuthInfo );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build a buffer of:
    //  512 random bytes
    //  The Outgoing auth info buffer.
    //  The Incoming auth info buffer.
    //  The length of the outgoing auth info buffer.
    //  The length of the incoming auth info buffer.
    //
    // (Notice that a hacker might surmise the length of the auth data by
    // observing the length of the encrypted blob. However, the auth data is typically
    // fixed length anyway.  So the above seems adequate.)
    //

   EncryptedSize = LSAP_ENCRYPTED_AUTH_DATA_FILL +
                   OutgoingAuthInfoSize +
                   IncomingAuthInfoSize +
                   sizeof(ULONG) +
                   sizeof(ULONG);

    AllocatedBuffer = LocalAlloc( 0, sizeof(LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) + EncryptedSize );

    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    EncryptedBuffer = AllocatedBuffer + sizeof(LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL);
    Where = EncryptedBuffer;

    Status = LsapRandomFill( LSAP_ENCRYPTED_AUTH_DATA_FILL,
                             Where );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Where += LSAP_ENCRYPTED_AUTH_DATA_FILL;

    RtlCopyMemory( Where, OutgoingAuthInfo, OutgoingAuthInfoSize );
    Where += OutgoingAuthInfoSize;

    RtlCopyMemory( Where, IncomingAuthInfo, IncomingAuthInfoSize );
    Where += IncomingAuthInfoSize;

    RtlCopyMemory( Where, &OutgoingAuthInfoSize, sizeof(ULONG) );
    Where += sizeof(ULONG);

    RtlCopyMemory( Where, &IncomingAuthInfoSize, sizeof(ULONG) );
    Where += sizeof(ULONG);


    //
    // Encrypt the result.
    //

    rc4_key( &Rc4Key,
             sizeof(USER_SESSION_KEY),
             (PUCHAR) &UserSessionKey );

    rc4( &Rc4Key,
         EncryptedSize,
         EncryptedBuffer );

    //
    // Return the result to the caller.
    //

    *EncryptedAuthInfo =
        (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) AllocatedBuffer;
    (*EncryptedAuthInfo)->AuthBlob.AuthBlob = EncryptedBuffer;
    (*EncryptedAuthInfo)->AuthBlob.AuthSize = EncryptedSize;

    Status = STATUS_SUCCESS;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {
        if ( AllocatedBuffer != NULL ) {
            LocalFree( AllocatedBuffer );
        }
        *EncryptedAuthInfo = NULL;
    }

    if ( IncomingAuthInfo != NULL ) {
        MIDL_user_free( IncomingAuthInfo );
    }
    if ( OutgoingAuthInfo != NULL ) {
        MIDL_user_free( OutgoingAuthInfo );
    }
    return Status;
}

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;
    PVOID InternalBuffer;
    TRUSTED_INFORMATION_CLASS InternalInformationClass;

    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL InternalFullBuffer;

    //
    // Initialization
    //

    InternalInformationClass = InformationClass;
    InternalBuffer = Buffer;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedPasswordInformation:
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:

    //
    // TrustedDomainNameInformation is not allowed, either (RAID #416784)
    //
    case TrustedDomainNameInformation:
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainAuthInformation: {

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( PolicyHandle,
                                      (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) Buffer,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainAuthInformationInternal;
        InternalBuffer = InternalAuthBuffer;
        break;

    }

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainFullInformation: {
        PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullBuffer =
                    (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION) Buffer;

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( PolicyHandle,
                                      &FullBuffer->AuthInformation,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy all of the information into a single new structure.
        //

        InternalFullBuffer.Information = FullBuffer->Information;
        InternalFullBuffer.PosixOffset = FullBuffer->PosixOffset;
        InternalFullBuffer.AuthInformation = *InternalAuthBuffer;

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainFullInformationInternal;
        InternalBuffer = &InternalFullBuffer;
        break;

    }
    }

    //
    // If the information class was morphed,
    //  try the morphed class.
    //

    if ( InternalInformationClass != InformationClass ) {
        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarSetTrustedDomainInfoByName(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_UNICODE_STRING) TrustedDomainName,
                         InternalInformationClass,
                         (PLSAPR_TRUSTED_DOMAIN_INFO) InternalBuffer
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        //
        // If the morphed info class is valid,
        //  we're all done with this call.
        //  (Otherwise, drop through to try the non-morphed class.)
        //

        if ( Status != RPC_NT_INVALID_TAG ) {
            goto Cleanup;
        }
    }


    //
    // Handle non-morphed information classes.
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarSetTrustedDomainInfoByName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) TrustedDomainName,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}


NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    NTSTATUS Status;
    LSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer;
    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.EnumerationBuffer = NULL;

    //
    // Verify that caller has provided a return buffer pointer.
    //

    if (!ARGUMENT_PRESENT(Buffer)) {

        return(STATUS_INVALID_PARAMETER);
    }


    RpcTryExcept {

        //
        // Enumerate the Trusted Domains.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Trusted Domains enumerated this call
        // and a pointer to an array of Trust Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Trust Info for Domain 0
        //                                      Trust Info for Domain 1
        //                                      ...
        //                                      Trust Info for Domain
        //                                         (EntriesRead - 1)
        //
        //

        Status = LsarEnumerateTrustedDomainsEx(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.EnumerationBuffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Trust Information array,
        // free it.
        //

        if (EnumerationBuffer.EnumerationBuffer != NULL) {

            MIDL_user_free(EnumerationBuffer.EnumerationBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return(Status);
}


NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;

    //
    // Encrypt the auth data
    //

    Status = LsapEncryptAuthInfo( PolicyHandle,
                                  (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) AuthenticationInformation,
                                  &InternalAuthBuffer );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Try the version of the API that takes encrypted data
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarCreateTrustedDomainEx2(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation,
                     InternalAuthBuffer,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the server doesn't accept the new api,
    //  try the old one.
    // (The old API was only supported in beta versions of NT 5.
    // After NT 5 ships we no longer need to be able to fall back.)
    //

    if (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) {

        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarCreateTrustedDomainEx(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation,
                         (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) AuthenticationInformation,
                         DesiredAccess,
                         (PLSAPR_HANDLE) TrustedDomainHandle
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;
    }

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}



NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation = NULL;

    RpcTryExcept {


        Status = LsarQueryDomainInformationPolicy(
                     (LSAPR_HANDLE) PolicyHandle,
                     InformationClass,
                     &PolicyDomainInformation
                     );

        *Buffer = PolicyDomainInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);

}




NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
{
    NTSTATUS Status;

    if ( InformationClass == PolicyDomainKerberosTicketInformation &&
         Buffer == NULL ) {

        return STATUS_INVALID_PARAMETER;
    }

    RpcTryExcept {

        Status = LsarSetDomainInformationPolicy(
                     (LSAPR_HANDLE) PolicyHandle,
                     InformationClass,
                     Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);

}


NTSTATUS
LsaOpenTrustedDomainByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the Name as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainName - Name of the trusted domain

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenTrustedDomainByName(
                     ( LSAPR_HANDLE ) PolicyHandle,
                     ( PLSAPR_UNICODE_STRING )TrustedDomainName,
                     DesiredAccess,
                     ( PLSAPR_HANDLE )TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}



NTSTATUS
LsaQueryForestTrustInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    OUT PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description

    The LsaQueryForestTrustInformation API returns forest trust information
    for the given trusted domain object.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    ForestTrustInfo - Used to return forest trust information

Returns:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER          Parameters were somehow invalid
                                      Most likely, the TRUST_ATTRIBUTE_FOREST_TRANSITIVE
                                      trust attribute bit is not set on the TDO

    STATUS_NOT_FOUND                  Forest trust information does not exist for this TDO

    STATUS_NO_SUCH_DOMAIN             The specified TDO does not exist

    STATUS_INSUFFICIENT_RESOURCES     Ran out of memory

    STATUS_INVALID_DOMAIN_STATE       Operation is only legal on domain controllers in root domain

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarQueryForestTrustInformation(
                     PolicyHandle,
                     TrustedDomainName,
                     ForestTrustRecordTypeLast,
                     ForestTrustInfo
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

         Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}




NTSTATUS
LsaSetForestTrustInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    IN BOOLEAN CheckOnly,
    OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description

    The LsarSetForestTrustInformation API sets forest trust information
    on the given trusted domain object.

    In case if it fails the operation due to a collision, it will return
    the list of entries that conflicted.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    ForestTrustInfo - Contains forest trust information to set

    CheckOnly - Check for collisions only, do not commit changes to disk

    CollisionInfo - In case of collisoin error, used to return collision info

Returns:

    STATUS_SUCCESS                  operation completed successfully

    STATUS_INVALID_PARAMETER        did not like one of the parameters

    STATUS_INSUFFICIENT_RESOURCES   out of memory

    STATUS_INVALID_DOMAIN_STATE     Operation is only legal on domain
                                    controllers in the root domain

    STATUS_INVALID_DOMAIN_ROLE      Operation is only legal on the primary
                                    domain controller

    STATUS_INVALID_SERVER_STATE     The server is shutting down and can not
                                    process the request

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarSetForestTrustInformation(
                     PolicyHandle,
                     TrustedDomainName,
                     ForestTrustRecordTypeLast,
                     ForestTrustInfo,
                     CheckOnly,
                     CollisionInfo
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

         Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}

#ifdef TESTING_MATCHING_ROUTINE

#include <sddl.h> // ConvertStringSidToSidW



NTSTATUS
NTAPI
LsaForestTrustFindMatch(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Type,
    IN PLSA_UNICODE_STRING Name,
    OUT PLSA_UNICODE_STRING * Match
    )
/*++

Routine Description:

    A debug-only hook for testing the LsaIForestTrustFindMatch API

Arguments:

    Type         type of match

    Name         name to match

    Match        used to return the name of match

Returns:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarForestTrustFindMatch(
                     PolicyHandle,
                     Type,
                     Name,
                     Match
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\rpcbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    LSA - Client RPC Binding Routines

Author:

    Scott Birrell       (ScottBi)      April 30, 1991

Environment:

Revision History:

--*/

#include "lsaclip.h"

#include <ntrpcp.h>     // prototypes for MIDL user functions

#include "adtgen.h"

handle_t
PLSAPR_SERVER_NAME_bind (
    IN OPTIONAL PLSAPR_SERVER_NAME   ServerName
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to the LSA on some server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t    BindingHandle;
    NTSTATUS  Status;

    Status = RpcpBindRpc (
                 ServerName,
                 L"lsarpc",
                 0,
                 &BindingHandle
                 );

    if (!NT_SUCCESS(Status)) {

        // DbgPrint("PLSAPR_SERVER_NAME_bind: RpcpBindRpc failed 0x%lx\n", Status);

    }

    return( BindingHandle);
}


VOID
PLSAPR_SERVER_NAME_unbind (
    IN OPTIONAL PLSAPR_SERVER_NAME  ServerName,
    IN handle_t           BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RpcpUnbindRpc ( BindingHandle );
    return;

    UNREFERENCED_PARAMETER( ServerName );     // This parameter is not used
}



DWORD
LsaNtStatusToWinError(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine converts and NTSTATUS to an win32 error code.  It is used
    by people who want to call the LSA APIs but are writing for a win32
    environment.

Arguments:

    Status - The status code to be mapped

Return Value:

    The return from RtlNtStatusToDosError.  If the error could not be
    mapped, then ERROR_MR_MID_NOT_FOUND is returned.

--*/

{
    return(RtlNtStatusToDosError(Status));
}



NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    )

/*++

Routine Description:

    This function converts an exception code or status value returned
    from the client stub to a value suitable for return by the API to
    the client.

Arguments:

    ExceptionCode - The exception code to be converted.

Return Value:

    NTSTATUS - The converted Nt Status code.

--*/

{
    //
    // Return the actual value if compatible with Nt status codes,
    // otherwise, return STATUS_UNSUCCESSFUL.
    //

    if (!NT_SUCCESS((NTSTATUS) ExceptionCode)) {

        return (NTSTATUS) ExceptionCode;

    } else {

        return STATUS_UNSUCCESSFUL;
    }
}

handle_t
PAUTHZ_AUDIT_EVENT_TYPE_OLD_bind (
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    )
/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to local LSA.

Arguments:

    AuditInfo -- ignored

Return Value:

    The binding handle is returned to the stub routine.
    If the binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t   hBinding=NULL;
    NTSTATUS   Status;
    PWSTR      pszBinding;
    RPC_STATUS RpcStatus;
    
    //
    // the first param takes a server-name. use NULL
    // to force a local binding
    //

    RpcStatus = RpcStringBindingComposeW(
                    NULL,               // uuid of lsarpc
                    L"ncalrpc",         // we want to use LRPC
                    NULL,               // network address (local machine)
                    L"audit",           // endpoint name
                    L"",                // options
                    &pszBinding );

    if ( RpcStatus == RPC_S_OK )
    {
        RpcStatus = RpcBindingFromStringBindingW(
                        pszBinding,
                        &hBinding
                        );
    
        RpcStringFreeW( &pszBinding );
    }

    Status = I_RpcMapWin32Status( RpcStatus );

    if (!NT_SUCCESS(Status)) {

        DbgPrint("PAUDIT_AUTHZ_AUDIT_EVENT_OLD_bind: failed 0x%lx\n", Status);

    }

    UNREFERENCED_PARAMETER( pAuditEventType );

    return( hBinding );
}


VOID
PAUTHZ_AUDIT_EVENT_TYPE_OLD_unbind (
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD  pAuditEventType,    OPTIONAL
    IN handle_t                     BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    AuditInfo     - ignored

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RpcpUnbindRpc ( BindingHandle );

    UNREFERENCED_PARAMETER( pAuditEventType );     // This parameter is not used

    return;

}

handle_t
PSECURITY_SOURCE_NAME_bind (
    IN PSECURITY_SOURCE_NAME pSecuritySource
    )
/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to local LSA.

Arguments:

    pSecuritySource -- ignored

Return Value:

    The binding handle is returned to the stub routine.
    If the binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t   hBinding=NULL;
    NTSTATUS   Status;
    PWSTR      pszBinding;
    RPC_STATUS RpcStatus;
    
    //
    // the first param takes a server-name. use NULL
    // to force a local binding
    //

    RpcStatus = RpcStringBindingComposeW(
                    NULL,               // uuid of lsarpc
                    L"ncalrpc",         // we want to use LRPC
                    NULL,               // network address (local machine)
                    L"securityevent",           // endpoint name
                    L"",                // options
                    &pszBinding );

    if ( RpcStatus == RPC_S_OK )
    {
        RpcStatus = RpcBindingFromStringBindingW(
                        pszBinding,
                        &hBinding
                        );
    
        RpcStringFreeW( &pszBinding );
    }

    Status = I_RpcMapWin32Status( RpcStatus );

    if (!NT_SUCCESS(Status)) {

        DbgPrint("PSECURITY_SOURCE_NAME_bind: failed 0x%lx\n", Status);

    }

    UNREFERENCED_PARAMETER( pSecuritySource );

    return( hBinding );
}


VOID
PSECURITY_SOURCE_NAME_unbind (
    IN PSECURITY_SOURCE_NAME pSecuritySource OPTIONAL,
    IN handle_t              BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    pSecuritySource - ignored

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RpcpUnbindRpc ( BindingHandle );

    UNREFERENCED_PARAMETER( pSecuritySource );     // This parameter is not used

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\tests\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#define UNICODE 1
#define SECURITY_WIN32 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <wincred.h>
#include <credp.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr


#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
// #include <ntlmsspd.h>   // Common definitions between client and server
// #include <ntlmssp.h>    // External definition of the NtLmSsp service
// #include <ntlmcomn.h>

BOOLEAN QuietMode = FALSE; // Don't be verbose


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    }

    printf( "\n" );
}

//
// Entries in this list must have offsets that match the corresponding values
//  of the CRED_TYPE_* defines in wincred.h
//
LPWSTR TypeArray[] = {
    L"Generic",
    L"Password",
    L"Certificate",
    NULL
};
#define TYPE_COUNT (sizeof(TypeArray)/sizeof(TypeArray[0]))

VOID
PrintTargetInfo(
    PCREDENTIAL_TARGET_INFORMATION TargetInformation
    )
/*++

Routine Description:

    Print a Target Info

Arguments:

    TargetInfo to print

Return Value:

    None

--*/
{
    ULONG i;

    printf( "TargetInformation:\n" );
    if ( TargetInformation->TargetName != NULL ) {
        printf( "           TargetName: %ls\n", TargetInformation->TargetName );
    }
    if ( TargetInformation->NetbiosServerName != NULL ) {
        printf( "    NetbiosServerName: %ls\n", TargetInformation->NetbiosServerName );
    }
    if ( TargetInformation->DnsServerName != NULL ) {
        printf( "        DnsServerName: %ls\n", TargetInformation->DnsServerName );
    }
    if ( TargetInformation->NetbiosDomainName != NULL ) {
        printf( "    NetbiosDomainName: %ls\n", TargetInformation->NetbiosDomainName );
    }
    if ( TargetInformation->DnsDomainName != NULL ) {
        printf( "        DnsDomainName: %ls\n", TargetInformation->DnsDomainName );
    }
    if ( TargetInformation->DnsTreeName != NULL ) {
        printf( "          DnsTreeName: %ls\n", TargetInformation->DnsTreeName );
    }
    if ( TargetInformation->PackageName != NULL ) {
        printf( "          PackageName: %ls\n", TargetInformation->PackageName );
    }

    if ( TargetInformation->Flags != 0 ) {
        DWORD LocalFlags = TargetInformation->Flags;

        printf( "                Flags:" );

        if ( LocalFlags & CRED_TI_SERVER_FORMAT_UNKNOWN ) {
            printf(" ServerFormatUnknown");
            LocalFlags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if ( LocalFlags & CRED_TI_DOMAIN_FORMAT_UNKNOWN ) {
            printf(" DomainFormatUnknown");
            LocalFlags &= ~CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        if ( LocalFlags != 0 ) {
            printf( " 0x%lx", LocalFlags );
        }
        printf( "\n" );
    }

    if ( TargetInformation->CredTypeCount != 0 ) {
        printf( "                Types:" );

        for ( i=0; i<TargetInformation->CredTypeCount; i++ ) {
            if ( TargetInformation->CredTypes[i] >= 1 && TargetInformation->CredTypes[i] <= TYPE_COUNT ) {
                printf(" %ls", TypeArray[TargetInformation->CredTypes[i]-1]);
            } else {
                printf("<Unknown>");
            }
        }
        printf( "\n" );
    }

}

VOID
TestLpcRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base LPC functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    DWORD WinStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    ULONG i;
    ULONG UseValidated;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecPkgContext_CredentialName ContextCredentialName;
    UCHAR ContextCredNameBuffer[sizeof(SecPkgContext_CredentialName)+1024];
    PSecPkgContext_CredentialName ContextCredNamePtr = (PSecPkgContext_CredentialName) ContextCredNameBuffer;
    SecPkgContext_CredentialNameA ContextCredentialNameA;
    PSecPkgContext_CredentialNameA ContextCredNamePtrA = (PSecPkgContext_CredentialNameA) ContextCredNameBuffer;

    SecPkgContext_TargetInformation ContextTargetInfo;
    SecPkgContext_TargetInformationA ContextTargetInfoA;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for ( i=0; i<PackageCount; i++ ) {
            printf( "%ld: \"%ws\" \"%ws\"\n", i, PackageInfo[i].Name, PackageInfo[i].Comment );
            printf( "   Cap: 0x%lx Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[i].fCapabilities,
                    PackageInfo[i].wVersion,
                    PackageInfo[i].wRPCID,
                    PackageInfo[i].cbMaxToken );
        }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: 0x%lx Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
// #define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    L"\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }






    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

// #if 0



    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    //
    // Try getting the built in credential name
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialName );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName: %ld %ws\n",
                ContextCredentialName.CredentialType,
                ContextCredentialName.sCredentialName );
    }

    //
    // Set UseValidated
    //
    UseValidated = 5;
    SecStatus = SetContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_USE_VALIDATED,
                    &UseValidated,
                    sizeof(UseValidated) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (usevalidated): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting use validate to %ld worked\n", UseValidated );
    }

    //
    // Set CredentialName
    //
    ContextCredNamePtr->CredentialType = 0x15;
    ContextCredNamePtr->sCredentialName = (LPWSTR)(ContextCredNamePtr+1);
    wcscpy( ContextCredNamePtr->sCredentialName, L"Frederick" );

    SecStatus = SetContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    ContextCredNamePtr,
                    sizeof(*ContextCredNamePtr) +
                        (wcslen(ContextCredNamePtr->sCredentialName) + 1) * sizeof(WCHAR) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting credentialname to %ld %ls worked\n", ContextCredNamePtr->CredentialType, ContextCredNamePtr->sCredentialName );
    }

    //
    // Try getting the credential name we just wrote
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialName );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName: %ld %ws\n",
                ContextCredentialName.CredentialType,
                ContextCredentialName.sCredentialName );
    }

    //
    // Try getting the target info
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_TARGET_INFORMATION,
                    &ContextTargetInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (targetinformation): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName:\n" );
        PrintTargetInfo( ContextTargetInfo.TargetInformation );
    }

    //
    // Set UseValidated
    //
    UseValidated = 34;
    SecStatus = SetContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_USE_VALIDATED,
                    &UseValidated,
                    sizeof(UseValidated) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (usevalidated ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting use validate ANSI to %ld worked\n", UseValidated );
    }

    //
    // Set CredentialName
    //
    ContextCredNamePtrA->CredentialType = 0x18;
    ContextCredNamePtrA->sCredentialName = (LPSTR)(ContextCredNamePtrA+1);
    strcpy( ContextCredNamePtrA->sCredentialName, "Waldo" );

    SecStatus = SetContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    ContextCredNamePtrA,
                    sizeof(*ContextCredNamePtrA) +
                        (strlen(ContextCredNamePtrA->sCredentialName) + 1) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (credentialname ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting credentialname ANSI to %ld %s worked\n", ContextCredNamePtrA->CredentialType, ContextCredNamePtrA->sCredentialName );
    }

    //
    // Try getting the credential name we just wrote
    //
    SecStatus = QueryContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialNameA );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName ANSI: %ld %s\n",
                ContextCredentialNameA.CredentialType,
                ContextCredentialNameA.sCredentialName );
    }

    //
    // Try getting the target info
    //
    SecStatus = QueryContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_TARGET_INFORMATION,
                    &ContextTargetInfoA );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (targetinformation ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PCREDENTIAL_TARGET_INFORMATION TargetInformation;

        WinStatus = CredpConvertTargetInfo( DoAtoW,
                                            (PCREDENTIAL_TARGET_INFORMATIONW)ContextTargetInfoA.TargetInformation,
                                            &TargetInformation,
                                            NULL );

        if ( WinStatus != NO_ERROR ) {
            printf( "QueryContextAttributes (targetinformation ANSI): cannot convert to unicode" );
            PrintStatus( WinStatus );
            return;
        }

        printf( "QueryCredentialName ANSI:\n" );
        PrintTargetInfo( TargetInformation );
    }

// #endif



    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if (STATUS_SUCCESS == QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer )) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );

    }


    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    if (!RevertToSelf())
    {
        printf( "RevertToSelf failed: %d\n ",GetLastError() );
        return;
    }
    CloseHandle(Token);

    //
    // Check password expiry
    //
#ifdef notdef
    SecStatus = SspQueryPasswordExpiry(
                    &ServerContextHandle,
                    &Lifetime
                    );
    if (!NT_SUCCESS(SecStatus))
    {
        printf("Failed to query password expiry: 0x%x\n",SecStatus);
    }
    else
    {
        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields(
            &Lifetime,
            &TimeFields
            );
        printf("Password expires %d-%d-%d %d:%d:%d\n",
            TimeFields.Day,
            TimeFields.Month,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second
            );
    }
#endif
    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

#if DBG
    ULONG FunctionCode;
    ULONG Data;
#endif // DBG

    enum {
        NoAction,
        TestLpc,
#define TESTLPC_PARAM "/TestLpc"
#define TESTLPC2_PARAM "/TestLpc:"
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];


        //
        // Handle /TestLpc
        //

        if ( _stricmp( argument, TESTLPC_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;
            Iterations = 1;

        //
        // Handle /TestLpc:
        //

        } else if ( _strnicmp( argument,
                              TESTLPC2_PARAM,
                              sizeof(TESTLPC2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;

            Iterations = strtoul( &argument[sizeof(TESTLPC2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        //
        // Handle /Quiet
        //

        } else if ( _stricmp( argument, QUIET_PARAM ) == 0 ) {
            QuietMode = TRUE;



        //
        // Handle all other parameters
        //

        } else {
Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTLPC_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic LPC to NtLmSsp service.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {
    case TestLpc: {
        for ( j=0; j<Iterations ; j++ ) {
            TestLpcRoutine( DomainName, UserName, Password );
        }
        break;
    }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\tests\ctcred.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctcred.c

Abstract:

    Component test for cred marshaling and unmarshaling

Author:

    Cliff Van Dyke       (CliffV)    March 22, 2000

Environment:

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <credp.h>
#include <stdio.h>
#include <winnetwk.h>

#include <lmerr.h>

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
{
    DWORD WinStatus;
    NTSTATUS Status;
    UCHAR Buffer[1024];
    UCHAR Buffer2[1024];
    PCERT_CREDENTIAL_INFO CertCred1 = (PCERT_CREDENTIAL_INFO)Buffer;
    PCERT_CREDENTIAL_INFO CertCred2;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCred1 = (PUSERNAME_TARGET_CREDENTIAL_INFO)Buffer;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCred2;
    LONG Size;
    ULONG i;
    int j;
    NETRESOURCEW NetRes;

    LPWSTR MarshaledCredential;

    LPSTR argument;
    BOOLEAN TestCert = FALSE;
    BOOLEAN TestUsernameTarget = FALSE;
    BOOLEAN TestValidateTarget = FALSE;
    BOOLEAN TestNetUse = FALSE;
    BOOLEAN TestAll = TRUE;


    //
    // Loop through the arguments handle each in turn
    //

    for ( j=1; j<argc; j++ ) {

        argument = argv[j];


        //
        // Handle /Cert
        //

        if ( _stricmp( argument, "/Cert" ) == 0 ) {
            TestCert = TRUE;
            TestAll = FALSE;

        //
        // Handle /UsernameTarget
        //

        }else if ( _stricmp( argument, "/UsernameTarget" ) == 0 ) {
            TestUsernameTarget = TRUE;
            TestAll = FALSE;

        //
        // Handle /ValidateTarget
        //

        }else if ( _stricmp( argument, "/ValidateTarget" ) == 0 ) {
            TestValidateTarget = TRUE;
            TestAll = FALSE;

        //
        // Handle /NetUse
        //

        }else if ( _stricmp( argument, "/NetUse" ) == 0 ) {
            TestNetUse = TRUE;
            TestAll = FALSE;



        //
        // Handle all other parameters
        //

        } else {
//Usage:
            fprintf( stderr, "Usage: ctcred [/Cert] [/UsernameTarget] [ValidateTarget] [/NetUse]\n\n" );
            return(1);
        }
    }


    //
    // Test cert marshaling
    //

    if ( TestCert || TestAll ) {
        //
        // NULL cred should fail
        //

        if ( CredMarshalCredentialW( CertCredential,
                                     NULL,
                                     &MarshaledCredential ) ) {
            printf( "Cert: Marshal NULL cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "Cert: Marshal NULL cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Short cred should fail
        //

        RtlZeroMemory( CertCred1, sizeof(*CertCred1) );

        if ( CredMarshalCredentialW( CertCredential,
                                     CertCred1,
                                     &MarshaledCredential ) ) {
            printf( "Cert: Marshal Short cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "Cert: Marshal Short cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Loop marshalling buffers of various sizes
        //

        for ( Size=0; Size<512; Size ++ ) {
            CRED_MARSHAL_TYPE CredType;

            //
            // Build a cred to marshal
            //

            CertCred1->cbSize = sizeof(*CertCred1);

            for ( i=0; i<sizeof(CertCred1->rgbHashOfCert); i++ ) {
                CertCred1->rgbHashOfCert[i] = (BYTE)Size;
            }


            //
            // Marshal it.
            //

            if ( !CredMarshalCredentialW( CertCredential,
                                          CertCred1,
                                          &MarshaledCredential ) ) {
                printf( "Cert: Cannot marshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            printf( "Cert: %ld: %ws\n", Size, MarshaledCredential );

            //
            // Ensure it is a marshaled cred
            //

            if ( !CredIsMarshaledCredentialW( MarshaledCredential ) ) {
                printf( "Cert: Cred isn't marshaled: %ld\n", Size );
                return 1;
            }

            //
            // Unmarshal it
            //

            CredType = (CRED_MARSHAL_TYPE) 87;
            if ( !CredUnmarshalCredentialW( MarshaledCredential,
                                            &CredType,
                                            &CertCred2 ) ) {
                printf( "Cert: Cannot unmarshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            //
            // Verify it
            //

            if ( CredType != CertCredential ) {
                printf( "Cert: Bad CredType: %ld\n", Size );
                return 1;
            }

            if ( !RtlEqualMemory( CertCred1, CertCred2, sizeof(*CertCred1) - 3 * sizeof(ULONG) ) ) {
                printf( "Cert: Bad Cred structure: %ld\n", Size );
                return 1;
            }

            if ( TestNetUse || TestAll ) {
                NetRes.dwType = RESOURCETYPE_ANY;
                NetRes.lpLocalName = NULL;
                NetRes.lpRemoteName = L"\\\\CLIFFV1\\d$";
                NetRes.lpProvider = NULL;

                WinStatus = WNetAddConnection2W( &NetRes,
                                                 L"",   // no password
                                                 MarshaledCredential,
                                                 0 );

                if ( WinStatus != NO_ERROR ) {
                    printf( "Cert: Cannot connect: %ld %ld\n", Size, WinStatus );
                }
            }


            CredFree( CertCred2 );
            CredFree( MarshaledCredential );
        }
    }


    //
    // Test UsernameTarget marshaling
    //

    if ( TestUsernameTarget || TestAll ) {
        //
        // NULL cred should fail
        //

        if ( CredMarshalCredentialW( UsernameTargetCredential,
                                     NULL,
                                     &MarshaledCredential ) ) {
            printf( "UsernameTarget: Marshal NULL cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "UsernameTarget: Marshal NULL cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Empty cred should fail
        //

        RtlZeroMemory( UsernameTargetCred1, sizeof(*UsernameTargetCred1) );

        if ( CredMarshalCredentialW( UsernameTargetCredential,
                                     UsernameTargetCred1,
                                     &MarshaledCredential ) ) {
            printf( "UsernameTarget: Marshal Short cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "UsernameTarget: Marshal Short cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }

        //
        // Loop marshalling buffers of various sizes
        //

        for ( Size=-3; Size<255; Size ++ ) {
            CRED_MARSHAL_TYPE CredType;

            //
            // Build a cred to marshal
            //

            UsernameTargetCred1->UserName = (LPWSTR)Buffer2;

            if ( Size == -3 ) {
                wcscpy( UsernameTargetCred1->UserName, L"a" );
            } else if ( Size == -2 ) {
                wcscpy( UsernameTargetCred1->UserName, L"ntdev\\cliffv" );
            } else if ( Size == -1 ) {
                wcscpy( UsernameTargetCred1->UserName, L"cliffv@ms.com" );
            } else {
                for ( i=0; i<Size*sizeof(WCHAR); i++ ) {
                    Buffer2[i] = (BYTE)Size;
                }
                Buffer2[i*sizeof(WCHAR)] = 0;
                Buffer2[i*sizeof(WCHAR)+1] = 0;
            }



            //
            // Marshal it.
            //

            if ( !CredMarshalCredentialW( UsernameTargetCredential,
                                          UsernameTargetCred1,
                                          &MarshaledCredential ) ) {
                WinStatus = GetLastError();
                if ( Size == 0 && WinStatus == ERROR_INVALID_PARAMETER ) {
                    // This is OK
                    continue;
                } else {
                    printf( "UsernameTarget: Cannot marshal cred: %ld %ld\n", Size, WinStatus );
                    return 1;
                }
            } else {
                if ( Size == 0 ) {
                    printf( "UsernameTarget: Marshal empty cred should have failed\n" );
                    return 1;
                }
            }

            if ( Size < 0 ) {
                printf( "UsernameTarget: %ld: %ws: %ws\n", Size, Buffer2, MarshaledCredential );
            } else {
                printf( "UsernameTarget: %ld: %ws\n", Size, MarshaledCredential );
            }

            //
            // Ensure it is a marshaled cred
            //

            if ( !CredIsMarshaledCredentialW( MarshaledCredential ) ) {
                printf( "UsernameTarget: Cred isn't marshaled: %ld\n", Size );
                return 1;
            }

            //
            // Unmarshal it
            //

            CredType = (CRED_MARSHAL_TYPE) 87;
            if ( !CredUnmarshalCredentialW( MarshaledCredential,
                                            &CredType,
                                            &UsernameTargetCred2 ) ) {
                printf( "UsernameTarget: Cannot unmarshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            //
            // Verify it
            //

            if ( CredType != UsernameTargetCredential ) {
                printf( "UsernameTarget: Bad CredType: %ld\n", Size );
                return 1;
            }

            if ( Size < 0 ) {

                if ( wcscmp( UsernameTargetCred1->UserName, UsernameTargetCred2->UserName ) != 0 ) {
                    printf( "UsernameTarget: %ws: Bad Cred structure: %ld\n", UsernameTargetCred1->UserName, Size );
                    return 1;
                }

            } else {

                if ( !RtlEqualMemory( UsernameTargetCred1->UserName, UsernameTargetCred2->UserName, Size*sizeof(WCHAR) ) ) {
                    printf( "UsernameTarget: Bad Cred structure: %ld\n", Size );
                    return 1;
                }
            }

            //
            // Connect using the credential
            //

            if ( TestNetUse || TestAll ) {
                NetRes.dwType = RESOURCETYPE_ANY;
                NetRes.lpLocalName = NULL;
                NetRes.lpRemoteName = L"\\\\CLIFFV1\\d$";
                NetRes.lpProvider = NULL;

                WinStatus = WNetAddConnection2W( &NetRes,
                                                 L"",   // no password
                                                 MarshaledCredential,
                                                 0 );

                if ( WinStatus != NO_ERROR ) {
                    printf( "UsernameTarget: Cannot connect: %ld %ld\n", Size, WinStatus );
                }
            }


            CredFree( UsernameTargetCred2 );
            CredFree( MarshaledCredential );
        }
    }


    //
    // Test ValidateTargetName
    //

    if ( TestValidateTarget || TestAll ) {

struct {
    LPWSTR TargetName;
    ULONG Type;
    TARGET_NAME_TYPE TargetNameType;
    LPWSTR UserName;
    DWORD Persist;
} ValidTests[] = {
    L"DfsRoot\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.dfsroot.com\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.dfsroot.com.\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.ms.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.ms.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"products1", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*.acme.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*.acme.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"redmond\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"redmond.\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"corp.ms.com\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"corp.ms.com.\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*Session", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"cliffv@ms.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"cliffv@ms.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
};



        for ( i=0; i<sizeof(ValidTests)/sizeof(ValidTests[0]); i++ ) {

            WCHAR TargetName[1024];
            ULONG TargetNameSize;
            WILDCARD_TYPE WildcardType;
            UNICODE_STRING NonWildcardedTargetName;

            // Copy to a buffer that can be canonicalized
            wcscpy( TargetName, ValidTests[i].TargetName );
            printf("Target %ws: ", TargetName );

            Status = CredpValidateTargetName(
                                TargetName,
                                ValidTests[i].Type,
                                ValidTests[i].TargetNameType,
                                ValidTests[i].UserName == NULL ? NULL : &ValidTests[i].UserName,
                                ValidTests[i].Persist == 0 ? NULL : &ValidTests[i].Persist,
                                &TargetNameSize,
                                &WildcardType,
                                &NonWildcardedTargetName );


            if ( !NT_SUCCESS(Status) ) {
                printf("is not valid: 0x%lx\n", Status );
            } else {
                printf("\n       %ws: ", TargetName );
                printf("(%ld) %ld %wZ\n", TargetNameSize, WildcardType, &NonWildcardedTargetName );
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\uclient\tests\crti.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crti.c

Abstract:

    Component test for marshaling and unmarshaling target info

Author:

    Cliff Van Dyke       (CliffV)    October 14, 2000

Environment:

Revision History:

--*/


#define SECURITY_WIN32
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <security.h>
#include <secpkg.h>
#include <stdio.h>
#include <align.h>
// #include <winnetwk.h>

// #include <lmerr.h>

#define MAX_PRINTF_LEN 1024        // Arbitrary.
#define NlPrint(_x_) NlPrintRoutine _x_

VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    (VOID) vsprintf(OutputBuffer, Format, arglist);
    va_end(arglist);

    printf( "%s", OutputBuffer );
    return;
    UNREFERENCED_PARAMETER( DebugFlag );
}


VOID
NlpDumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    IN DWORD DebugFlag;
    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            NlPrint((0,"%02x ", BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            NlPrint((0,"   "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            NlPrint((0,"  %s\n", TextBuffer));
        }

    }

    UNREFERENCED_PARAMETER( DebugFlag );
}

LPWSTR TypeArray[] = {
    L"Generic",
    L"Password",
    L"Certificate",
    L"VisiblePassword",
    NULL
};
#define TYPE_COUNT (sizeof(TypeArray)/sizeof(TypeArray[0]))

VOID
PrintTargetInfo(
    PCREDENTIAL_TARGET_INFORMATION TargetInformation
    )
/*++

Routine Description:

    Print a Target Info

Arguments:

    TargetInfo to print

Return Value:

    None

--*/
{
    ULONG i;

    printf( "TargetInformation:\n" );
    if ( TargetInformation->TargetName != NULL ) {
        printf( "           TargetName: %ls\n", TargetInformation->TargetName );
    }
    if ( TargetInformation->NetbiosServerName != NULL ) {
        printf( "    NetbiosServerName: %ls\n", TargetInformation->NetbiosServerName );
    }
    if ( TargetInformation->DnsServerName != NULL ) {
        printf( "        DnsServerName: %ls\n", TargetInformation->DnsServerName );
    }
    if ( TargetInformation->NetbiosDomainName != NULL ) {
        printf( "    NetbiosDomainName: %ls\n", TargetInformation->NetbiosDomainName );
    }
    if ( TargetInformation->DnsDomainName != NULL ) {
        printf( "        DnsDomainName: %ls\n", TargetInformation->DnsDomainName );
    }
    if ( TargetInformation->DnsTreeName != NULL ) {
        printf( "          DnsTreeName: %ls\n", TargetInformation->DnsTreeName );
    }
    if ( TargetInformation->PackageName != NULL ) {
        printf( "          PackageName: %ls\n", TargetInformation->PackageName );
    }

    if ( TargetInformation->Flags != 0 ) {
        DWORD LocalFlags = TargetInformation->Flags;

        printf( "                Flags:" );

        if ( LocalFlags & CRED_TI_SERVER_FORMAT_UNKNOWN ) {
            printf(" ServerFormatUnknown");
            LocalFlags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if ( LocalFlags & CRED_TI_DOMAIN_FORMAT_UNKNOWN ) {
            printf(" DomainFormatUnknown");
            LocalFlags &= ~CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        if ( LocalFlags != 0 ) {
            printf( " 0x%lx", LocalFlags );
        }
        printf( "\n" );
    }

    if ( TargetInformation->CredTypeCount != 0 ) {
        printf( "                Types:" );

        for ( i=0; i<TargetInformation->CredTypeCount; i++ ) {
            if ( TargetInformation->CredTypes[i] >= 1 && TargetInformation->CredTypes[i] <= TYPE_COUNT ) {
                printf(" %ls", TypeArray[TargetInformation->CredTypes[i]-1]);
            } else {
                printf("<Unknown>");
            }
        }
        printf( "\n" );
    }

}

BOOLEAN
DoOne(
    PCREDENTIAL_TARGET_INFORMATION TargetInformation
    )
/*++

Routine Description:

    Test marhsalling and unmarshalling a single Target Info

Arguments:

    TargetInfo to test

Return Value:

    TRUE on success

--*/
{
    NTSTATUS Status;

    PCREDENTIAL_TARGET_INFORMATIONW RetTargetInfo;
    ULONG RetSize;
    PUSHORT Buffer;
    ULONG BufferSize;
    WCHAR BigBuffer[40000];

    printf( "\n\nInput:\n");
    PrintTargetInfo( TargetInformation );
    Status = CredMarshalTargetInfo( TargetInformation, &Buffer, &BufferSize );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot convert 0x%lx\n", Status );
        return FALSE;
    }

    printf( "\nBinary:\n");
    NlpDumpBuffer( Buffer, BufferSize );

    //
    // Test passing NULL in all optional parameters
    //
    Status = CredUnmarshalTargetInfo ( Buffer,
                                       BufferSize,
                                       NULL,
                                       NULL );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot check format 0x%lx\n", Status );
        return FALSE;
    }


    //
    // Test passing NULL for just the allocated buffer
    //
    Status = CredUnmarshalTargetInfo ( Buffer,
                                       BufferSize,
                                       NULL,
                                       &RetSize );


    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot check size 0x%lx\n", Status );
        return FALSE;
    }


    //
    // Actually convert the data
    //
    Status = CredUnmarshalTargetInfo ( Buffer,
                                       BufferSize,
                                       &RetTargetInfo,
                                       &RetSize );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot convert back 0x%lx\n", Status );
        return FALSE;
    } else {
        printf( "\n\nOutput: %ld\n", RetSize );
        PrintTargetInfo( RetTargetInfo );
    }

    //
    // Try again with a preconcatenated string
    //

    wcscpy( BigBuffer, L"SpnInFrontOfBuffer" );
    wcscat( BigBuffer, Buffer );

    Status = CredUnmarshalTargetInfo ( BigBuffer,
                                       wcslen(BigBuffer)*sizeof(WCHAR),
                                       &RetTargetInfo,
                                       &RetSize );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot convert back with prepended 0x%lx\n", Status );
        return FALSE;
    } else {
        printf( "\n\nOutput: %ld\n", RetSize );
        PrintTargetInfo( RetTargetInfo );
    }

    return TRUE;

}

int __cdecl
main ()
{
    NTSTATUS Status;

    CREDENTIAL_TARGET_INFORMATIONW Ti1;
    PCREDENTIAL_TARGET_INFORMATIONW RetTargetInfo;
    ULONG RetSize;
    PUSHORT Buffer;
    ULONG BufferSize;
    ULONG CredTypes[] = { 1, 3, 0, 7, 2 };


    //
    // Do a trivial target info
    //

    RtlZeroMemory( &Ti1, sizeof(Ti1) );

    Ti1.TargetName = L"The name";

    if (!DoOne( &Ti1 ) ) {
        return 1;
    }

    //
    // More complicated
    //

    RtlZeroMemory( &Ti1, sizeof(Ti1) );

    Ti1.TargetName = L"TargetName";
    Ti1.NetbiosServerName = L"NetbiosServerName";
    Ti1.DnsServerName = L"DnsServerName";
    Ti1.NetbiosDomainName = L"NetbiosDomainName";
    Ti1.DnsDomainName = L"DnsDomainName";
    Ti1.DnsTreeName = L"DnsTreeName";
    Ti1.PackageName = L"PackageName";
    Ti1.Flags=0x12345678;
    Ti1.CredTypeCount = sizeof(CredTypes)/sizeof(DWORD);
    Ti1.CredTypes = CredTypes;

    if (!DoOne( &Ti1 ) ) {
        return 1;
    }

    //
    // Try one with max length strings
    //

    RtlZeroMemory( &Ti1, sizeof(Ti1) );

    Ti1.TargetName = L"TargetName111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
    Ti1.NetbiosServerName = L"NetbiosServerName";
    Ti1.DnsServerName = L"DnsServerName111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
    Ti1.NetbiosDomainName = L"NetbiosDomainName";
    Ti1.DnsDomainName = L"DnsDomainName111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
    Ti1.DnsTreeName = L"DnsTreeName11111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
    Ti1.PackageName = L"PackageName11111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222221111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
    Ti1.Flags=0x87654321;
    Ti1.CredTypeCount = sizeof(CredTypes)/sizeof(DWORD);
    Ti1.CredTypes = CredTypes;

    if (!DoOne( &Ti1 ) ) {
        return 1;
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created
    25-Jul-96       ChandanS    Copied from net\svcdlls\ntlmssp\client\crc32.c
    27-Jan-07       MikeSw      Incorporated x86 ASM code for performance

--*/

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>
#include <winerror.h>

#endif


#include <string.h>
#include <malloc.h>


#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>



#define CRC32_LEN 4


NTSTATUS
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
KerbCrc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);
NTSTATUS
KerbCrc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer);
NTSTATUS
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer);

NTSTATUS
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer);

CHECKSUM_FUNCTION csfCRC32 = {
    KERB_CHECKSUM_REAL_CRC32,
    CRC32_LEN,
    0,
    Crc32Initialize,
    Crc32Sum,
    Crc32Finalize,
    Crc32Finish,
    Crc32InitializeEx,
    NULL
};


CHECKSUM_FUNCTION csfKERB_CRC32 = {
    KERB_CHECKSUM_CRC32,
    CRC32_LEN,
    0,
    KerbCrc32Initialize,
    Crc32Sum,
    KerbCrc32Finalize,
    Crc32Finish,
    KerbCrc32InitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, Crc32Initialize )
#pragma alloc_text( PAGEMSG, Crc32Sum )
#pragma alloc_text( PAGEMSG, Crc32Finalize )
#pragma alloc_text( PAGEMSG, Crc32Finish )
#pragma alloc_text( PAGEMSG, Crc32InitializeEx )
#pragma alloc_text( PAGEMSG, KerbCrc32Initialize )
#pragma alloc_text( PAGEMSG, KerbCrc32Finalize )
#pragma alloc_text( PAGEMSG, KerbCrc32InitializeEx )
#endif

typedef struct _CRC32_CONTEXT {
    ULONG  crc;
} CRC32_CONTEXT, *PCRC32_CONTEXT;



//
// This code comes from Dr. Dobbs Journal, May 1992
//


static unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


NTSTATUS
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbBuffer,
            PUCHAR          pvBuffer )
{
    PCRC32_CONTEXT pContext = pcsBuffer;
    unsigned long dwCrc = pContext->crc;
    unsigned char * pbBuffer;

#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pvBuffer

  mov     edx, DWORD PTR dwCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR dwCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#else // _X86_
    pbBuffer = (unsigned char *) pvBuffer;
#endif
    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    pContext->crc= dwCrc;
    return(STATUS_SUCCESS);

}

NTSTATUS
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer)
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0xffffffff;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS
KerbCrc32Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum)
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc ^ 0xffffffff;
    return(STATUS_SUCCESS);
}

NTSTATUS
KerbCrc32Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum
    )
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc;
    return(STATUS_SUCCESS);
}

NTSTATUS
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer)
{
    return(Crc32Initialize(0, pcsBuffer));
}

NTSTATUS
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer)
{
    return(KerbCrc32Initialize(0, pcsBuffer));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\cryptmgr.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptmgr.c
//
// Contents:    Crypto manager
//
//
// History:     xx Dec 91   RichardW    Created
//              04 Jun 92   RichardW    NTized
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <security.h>

#include <cryptdll.h>


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCSystem )
#pragma alloc_text( PAGEMSG, CDBuildVect )
#pragma alloc_text( PAGEMSG, CDBuildIntegrityVect )
#pragma alloc_text( PAGEMSG, CDLocateCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystemWithKey )
#endif 

#define MAX_CSYSTEMS    16

CRYPTO_SYSTEM    CSystems[MAX_CSYSTEMS];
ULONG           cCSystems = 0;
ULONG           cIntegrityCSystems = 0;

// Register the crypto system

NTSTATUS NTAPI
CDRegisterCSystem(  PCRYPTO_SYSTEM   pcsNewSystem)
{
    if (cCSystems + 1 < MAX_CSYSTEMS)
    {
        CSystems[cCSystems++] = *pcsNewSystem;
        if ((pcsNewSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            cIntegrityCSystems++;
        }
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}


NTSTATUS NTAPI
CDBuildVect(    ULONG *     pcCSystems,
                ULONG *     pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        *pdwEtypes++ = CSystems[iCS].EncryptionType;
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cIntegrityCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        if ((CSystems[iCS].Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            *pdwEtypes++ = CSystems[iCS].EncryptionType;
        }
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDLocateCSystem(ULONG           dwEtype,
                PCRYPTO_SYSTEM * ppcsSystem)
{
    ULONG   iCS = cCSystems;

    while (iCS--)
    {
        if (CSystems[iCS].EncryptionType == dwEtype)
        {
            *ppcsSystem = &CSystems[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_ETYPE_NOT_SUPP);
}


NTSTATUS NTAPI
CDFindCommonCSystem(ULONG   cEntries,
                    ULONG * pdwEtypes,
                    ULONG * pdwCommonEtype)
{
    ULONG   i, j;

    *pdwCommonEtype = 0;

    for (i = 0; i < cEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (pdwEtypes[i] == CSystems[j].EncryptionType)
            {
                *pdwCommonEtype = pdwEtypes[i];
                return(STATUS_SUCCESS);
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype)
{
    ULONG   i, j, k;

    *CommonEtype = 0;

    for (i = 0; i < EncryptionEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (EncryptionTypes[i] == CSystems[j].EncryptionType)
            {

                //
                // Make sure we have a key for this encryption type
                //

                for (k = 0; k < KeyTypeCount ; k++ )
                {
                    if (KeyTypes[k] == EncryptionTypes[i])
                    {
                        *CommonEtype = EncryptionTypes[i];
                        return(STATUS_SUCCESS);

                    }
                }
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\csummgr.c ===
//+-----------------------------------------------------------------------
//
// File:        CSUMMGR.c
//
// Contents:    Checksum management functions
//
//
// History:     25 Feb 92,  RichardW,   Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#define MAX_CHECK_SUMS  16

CHECKSUM_FUNCTION    CheckSumFns[MAX_CHECK_SUMS];
ULONG               cCheckSums = 0;

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCheckSum )
#pragma alloc_text( PAGEMSG, CDLocateCheckSum )
#endif 

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION   pcsfSum)
{
    if (cCheckSums < MAX_CHECK_SUMS)
    {
        CheckSumFns[cCheckSums++] = *pcsfSum;
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}

NTSTATUS NTAPI
CDLocateCheckSum(   ULONG               dwCheckSumType,
                    PCHECKSUM_FUNCTION * ppcsfSum)
{
    ULONG   iCS = cCheckSums;
    while (iCS--)
    {
        if (CheckSumFns[iCS].CheckSumType == dwCheckSumType)
        {
            *ppcsfSum = &CheckSumFns[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_CHECKSUM_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\cryptdll.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        crypt.c
//
// Contents:    Root DLL file
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <security.h>
#include <cryptdll.h>
#include <kerbcon.h>

//#define DONT_SUPPORT_OLD_ETYPES 1

//  List Default CryptoSystems here.  If you add anything, be sure to add it
//  in the LoadCSystems() function


extern CRYPTO_SYSTEM     csRC4_HMAC;
extern CRYPTO_SYSTEM     csRC4_HMAC_EXP;
extern CRYPTO_SYSTEM     csRC4_LM;
extern CRYPTO_SYSTEM     csRC4_PLAIN;
extern CRYPTO_SYSTEM     csRC4_PLAIN_EXP;
#ifndef DONT_SUPPORT_OLD_ETYPES
extern CRYPTO_SYSTEM     csRC4_MD4;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD_EXP;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD_EXP;
#endif

extern CRYPTO_SYSTEM     csDES_MD5;
extern CRYPTO_SYSTEM     csDES_CRC32;
extern CRYPTO_SYSTEM     csDES_PLAIN;
extern CRYPTO_SYSTEM     csNULL;

extern CHECKSUM_FUNCTION csfMD4;
extern CHECKSUM_FUNCTION csfMD5;
extern CHECKSUM_FUNCTION csfCRC32;
extern CHECKSUM_FUNCTION csfKERB_CRC32;
extern CHECKSUM_FUNCTION csfSHA;
extern CHECKSUM_FUNCTION csfLM;
extern CHECKSUM_FUNCTION csfRC4_MD5;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5;
extern CHECKSUM_FUNCTION csfMD5_HMAC;
extern CHECKSUM_FUNCTION csfHMAC_MD5;
extern CHECKSUM_FUNCTION csfMD25;
extern CHECKSUM_FUNCTION csfDesMac;
extern CHECKSUM_FUNCTION csfDesMacK;
extern CHECKSUM_FUNCTION csfDesMac1510;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5_1510;

extern RANDOM_NUMBER_GENERATOR    DefaultRng;

SECURITY_STATUS   LoadCSystems(void);
SECURITY_STATUS   LoadCheckSums(void);
BOOLEAN              LoadRngs(void);

int
LibAttach(
    HANDLE  hInstance,
    PVOID   lpReserved)
{
    SECURITY_STATUS   scRet;


    scRet = LoadCSystems();
    scRet = LoadCheckSums();
    (void) LoadRngs();

    if (scRet)
        return(0);
    else
        return(1);
}

#ifndef KERNEL_MODE
#define _DECL_DLLMAIN
#include <process.h>

BOOL WINAPI DllMain (
    HANDLE          hInstance,
    ULONG           dwReason,
    PVOID           lpReserved)
{
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
    DisableThreadLibraryCalls ( hInstance );
    return LibAttach ( hInstance, lpReserved );
    }
    else
    return TRUE;

}
#endif // KERNEL_MODE

SECURITY_STATUS
LoadCSystems(void)
{
    //
    // The order here is the order of preference
    //

    CDRegisterCSystem( &csRC4_HMAC);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD);
    CDRegisterCSystem( &csRC4_MD4);
#endif
    CDRegisterCSystem( &csDES_MD5);
    CDRegisterCSystem( &csDES_CRC32);
    CDRegisterCSystem( &csRC4_PLAIN);
    CDRegisterCSystem( &csRC4_PLAIN_EXP);
    CDRegisterCSystem( &csRC4_HMAC_EXP);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD_EXP);
    CDRegisterCSystem( &csRC4_PLAIN_OLD);
    CDRegisterCSystem( &csRC4_PLAIN_OLD_EXP);
#endif
    CDRegisterCSystem( &csDES_PLAIN);


    return(0);

}

SECURITY_STATUS
LoadCheckSums(void)
{
    CDRegisterCheckSum( &csfMD5_HMAC );
    CDRegisterCheckSum( &csfHMAC_MD5 );
    CDRegisterCheckSum( &csfMD4);
    CDRegisterCheckSum( &csfMD5);
    CDRegisterCheckSum( &csfKERB_CRC32);
    CDRegisterCheckSum( &csfDES_MAC_MD5 );
    CDRegisterCheckSum( &csfMD25 );
    CDRegisterCheckSum( &csfDesMac );
    CDRegisterCheckSum( &csfRC4_MD5 );
    CDRegisterCheckSum( &csfCRC32);
#ifndef KERNEL_MODE
    CDRegisterCheckSum( &csfLM );
#endif
    CDRegisterCheckSum( &csfSHA );
    CDRegisterCheckSum( &csfDES_MAC_MD5_1510 );
    CDRegisterCheckSum( &csfDesMac1510 );
    CDRegisterCheckSum( &csfDesMacK );

    return(0);
}

BOOLEAN
LoadRngs(void)
{
    CDRegisterRng(&DefaultRng);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\lmwrap.c ===
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef KERNEL_MODE
#include <ntos.h>
#endif
#include <security.h>
#include <cryptdll.h>
#include <crypt.h>
#include <kerbcon.h>
#include <lmcons.h>

typedef struct _LM_STATE_BUFFER {
    LM_OWF_PASSWORD Password;
} LM_STATE_BUFFER, *PLM_STATE_BUFFER;


NTSTATUS
LmWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
LmWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
LmWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
LmWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfLM = {
    KERB_CHECKSUM_LM,
    LM_OWF_PASSWORD_LENGTH,
    CKSUM_COLLISION,
    LmWrapInitialize,
    LmWrapSum,
    LmWrapFinalize,
    LmWrapFinish
    // Note : missing last function
};


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, LmWrapInitialize )
#pragma alloc_text( PAGEMSG, LmWrapSum )
#pragma alloc_text( PAGEMSG, LmWrapFinalize )
#pragma alloc_text( PAGEMSG, LmWrapFinish );
#endif 

NTSTATUS
LmWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PLM_STATE_BUFFER pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( LM_STATE_BUFFER ) );
#else
    pContext = LocalAlloc( LMEM_ZEROINIT, sizeof( LM_STATE_BUFFER ) );
#endif

    if ( pContext != NULL )
    {
        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_INSUFFICIENT_RESOURCES );
}


NTSTATUS
LmCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

#ifdef KERNEL_MODE
    LmPassword.Buffer = ExAllocatePool(NonPagedPool,LM_BUFFER_LENGTH);
#else
    LmPassword.Buffer = LocalAlloc(0,LM_BUFFER_LENGTH);
#endif
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

#ifdef KERNEL_MODE
        ExFreePool(LmPassword.Buffer);
#else
        LocalFree(LmPassword.Buffer);
#endif
    }

    return(NtStatus);
}

NTSTATUS
LmWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;
    UNICODE_STRING TempString;
    PUCHAR LmPassword;
    NTSTATUS Status;

    TempString.Length = TempString.MaximumLength = (USHORT) cbData;
    TempString.Buffer = (LPWSTR) pbData;

    Status = LmCalculateLmPassword(
                &TempString,
                &LmPassword
                );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlCalculateLmOwfPassword(
                LmPassword,
                &pContext->Password
                );
#ifdef KERNEL_MODE
    ExFreePool(LmPassword);
#else
    LocalFree(LmPassword);
#endif

    return( Status );

}


NTSTATUS
LmWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;


    RtlCopyMemory(
        pbSum,
        &pContext->Password,
        LM_OWF_PASSWORD_LENGTH
        );

    return( STATUS_SUCCESS );

}

NTSTATUS
LmWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    RtlZeroMemory( *ppcsBuffer, sizeof( PLM_STATE_BUFFER ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\mdwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        MDWRAP.C
//
// Contents:    MDx Wrapper functions
//
//
// History:     25 Feb 92,  RichardW    Created
//
//------------------------------------------------------------------------


#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>
#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#include "md4.h"
#include "md5.h"
#include "des.h"

typedef struct _MD5_DES_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
} MD5_DES_STATE_BUFFER, *PMD5_DES_STATE_BUFFER;

typedef struct _MD5_DES_1510_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
    UCHAR Confounder[DES_BLOCKLEN];
} MD5_DES_1510_STATE_BUFFER, *PMD5_DES_1510_STATE_BUFFER;

typedef struct _MD5_HMAC_STATE_BUFFER {
    MD5_CTX Md5Context;
    ULONG KeySize;
    UCHAR Key[ANYSIZE_ARRAY];
} MD5_HMAC_STATE_BUFFER, *PMD5_HMAC_STATE_BUFFER;


NTSTATUS NTAPI md4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md25Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md25Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md25Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md5DesInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesInitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5DesFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5DesFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Rc4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Rc4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Rc4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5HmacInitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Hmac2InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5HmacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5HmacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Des1510InitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510InitializeEx2(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Des1510Finish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, md25Initialize )
#pragma alloc_text( PAGEMSG, md25InitializeEx )
#pragma alloc_text( PAGEMSG, md25Sum )
#pragma alloc_text( PAGEMSG, md25Finalize )
#pragma alloc_text( PAGEMSG, md25Finish )
#pragma alloc_text( PAGEMSG, md5DesInitialize )
#pragma alloc_text( PAGEMSG, md5DesInitializeEx )
#pragma alloc_text( PAGEMSG, md5DesSum )
#pragma alloc_text( PAGEMSG, md5DesFinalize )
#pragma alloc_text( PAGEMSG, md5DesFinish )
#pragma alloc_text( PAGEMSG, md5Rc4Initialize )
#pragma alloc_text( PAGEMSG, md5Rc4InitializeEx )
#pragma alloc_text( PAGEMSG, md5Rc4Sum )
#pragma alloc_text( PAGEMSG, md5Rc4Finalize )
#pragma alloc_text( PAGEMSG, md5Rc4Finish )
#pragma alloc_text( PAGEMSG, md5HmacInitialize )
#pragma alloc_text( PAGEMSG, md5HmacInitializeEx )
#pragma alloc_text( PAGEMSG, md5Hmac2InitializeEx )
#pragma alloc_text( PAGEMSG, md5HmacSum )
#pragma alloc_text( PAGEMSG, md5HmacFinalize )
#pragma alloc_text( PAGEMSG, md5HmacFinish )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, md5Des1510Finalize )
#pragma alloc_text( PAGEMSG, md5Des1510Finish )
#endif 


CHECKSUM_FUNCTION    csfMD4 = {
    KERB_CHECKSUM_MD4,          // Checksum type
    MD4_LEN,                    // Checksum length
    0,
    md4Initialize,
    md4Sum,
    md4Finalize,
    md4Finish,
    md4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5 = {
    KERB_CHECKSUM_MD5,          // Checksum type
    MD5_LEN,                    // Checksum length
    0,
    md5Initialize,
    md5Sum,
    md5Finalize,
    md5Finish,
    md5InitializeEx,
    NULL};

CHECKSUM_FUNCTION csfMD25 = {
    KERB_CHECKSUM_MD25,                 // Checksum type
    (MD5_LEN / 2),                      // Checksum length
    CKSUM_KEYED,
    md25Initialize,
    md25Sum,
    md25Finalize,
    md25Finish,
    md25InitializeEx};

CHECKSUM_FUNCTION    csfDES_MAC_MD5 = {
    KERB_CHECKSUM_DES_MAC_MD5,          // Checksum type
    DES_BLOCKLEN,                       // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5DesFinalize,
    md5DesFinish,
    md5DesInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfRC4_MD5 = {
    KERB_CHECKSUM_RC4_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5Rc4Initialize,
    md5Rc4Sum,
    md5Rc4Finalize,
    md5Rc4Finish,
    md5Rc4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5_HMAC = {
    KERB_CHECKSUM_MD5_HMAC,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5HmacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfHMAC_MD5 = {
    KERB_CHECKSUM_HMAC_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5Hmac2InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDES_MAC_MD5_1510 = {
    KERB_CHECKSUM_MD5_DES,              // Checksum type
    DES_BLOCKLEN + MD5_LEN,             // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5Des1510Finalize,
    md5Des1510Finish,
    md5Des1510InitializeEx,
    md5Des1510InitializeEx2};

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md4Initialize(  ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    MD4_CTX *   pMD4Context;

#ifdef KERNEL_MODE
    pMD4Context = ExAllocatePool(NonPagedPool, sizeof(MD4_CTX));
#else
    pMD4Context = malloc(sizeof(MD4_CTX));
#endif
    if (!pMD4Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD4Init(pMD4Context);
    *ppcsBuffer = pMD4Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md4InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(md4Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD4Update((MD4_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD4Final((MD4_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD4_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md5Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;

#ifdef KERNEL_MODE
    pMD5Context = ExAllocatePool(NonPagedPool, sizeof(MD5_CTX));
#else
    pMD5Context = malloc(sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD5Init(pMD5Context);
    *ppcsBuffer = pMD5Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md5InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(md5Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md5Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI
md25Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md25InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR TempBuffer[16];
    ULONG OutputSize;
    UCHAR TempKey[DES_KEYSIZE];
    PCRYPT_STATE_BUFFER DesContext = NULL;
    PCRYPTO_SYSTEM DesSystem;
    ULONG Index;

    memset(
        TempBuffer,
        0,
        sizeof(TempBuffer)
        );

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (MD5_CTX *) ExAllocatePool(NonPagedPool,sizeof(MD5_CTX));
#else
    pMD5Context = (MD5_CTX *) LocalAlloc(0,sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(pMD5Context);

    //
    // Prepare the key by byte reversing it.
    //

    for (Index = 0; Index  < DES_KEYSIZE ; Index++ )
    {
        TempKey[Index] = Key[(DES_KEYSIZE - 1) - Index];
    }

    Status = CDLocateCSystem(
                KERB_ETYPE_DES_PLAIN,
                &DesSystem
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = DesSystem->Initialize(
                TempKey,
                DES_KEYSIZE,
                0,              // no options
                &DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = DesSystem->Encrypt(
                DesContext,
                TempBuffer,
                sizeof(TempBuffer),
                TempBuffer,
                &OutputSize
                );
    ASSERT(OutputSize == sizeof(TempBuffer));
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    (VOID) DesSystem->Discard(&DesContext);

    //
    // Now MD5 update with the encrypted buffer
    //

    MD5Update(
        pMD5Context,
        TempBuffer,
        sizeof(TempBuffer)
        );


    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(Status);
}


NTSTATUS NTAPI
md25Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, MD5_LEN/2);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI
md5DesInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5DesInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);

    //
    // Compute the initialization for the MD5
    //

    Status = desPlainInitialize(
                Key,
                KeySize,
                0,
                &pMD5Context->DesContext
                );

    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5DesSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    ULONG OutputLength;
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Final(&Context->Md5Context);

    desEncrypt(
        Context->DesContext,
        Context->Md5Context.digest,
        MD5_LEN,
        Context->Md5Context.digest,
        &OutputLength
        );

    RtlCopyMemory(
        pbSum,
        Context->Md5Context.digest + MD5_LEN-DES_BLOCKLEN,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;
    desFinish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4ShaInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Initialize(PUCHAR, ULONG, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI
md5Rc4Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Rc4InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);


    Status = rc4Initialize(
                Key,
                KeySize,
                0,              // no options
                0,
                &pMD5Context->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5Rc4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    ULONG OutputSize;
    NTSTATUS Status;

    MD5Final(&Context->Md5Context);

    memcpy(
        pbSum,
        Context->Md5Context.digest,
        MD5_LEN
        );
    Status = rc4Encrypt(
                Context->DesContext,
                pbSum,
                MD5_LEN,
                pbSum,
                &OutputSize
                );


    ASSERT(OutputSize == MD5_LEN);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;

    (VOID) rc4Finish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );


NTSTATUS NTAPI
md5HmacInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5HmacInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        pMD5Context->Key,
        Key,
        KeySize
        );
    pMD5Context->KeySize = KeySize;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Hmac2InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    md5Hmac(
        Key,
        KeySize,
        "signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        pMD5Context->Key
        );
    pMD5Context->KeySize = MD5_LEN;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5HmacSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;

    MD5Final(&Context->Md5Context);

    if (!md5Hmac(
            Context->Key,
            Context->KeySize,
            Context->Md5Context.digest,
            MD5_LEN,
            NULL,               // no secondary material
            0,
            pbSum))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) *ppcsBuffer;

#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Des1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Des1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PMD5_DES_1510_STATE_BUFFER  pContext = NULL;
    ULONG cb = DES_BLOCKLEN;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Make sure we were passed an appropriate key
    //

    if (KeySize != DES_KEYSIZE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#ifdef KERNEL_MODE
    pContext = (PMD5_DES_1510_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_1510_STATE_BUFFER));
#else
    pContext = (PMD5_DES_1510_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_1510_STATE_BUFFER));
#endif
    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    Status = desPlainInitialize(
                FinalKey,
                DES_KEYSIZE,
                0,
                &pContext->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(pContext->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        Status = desEncrypt(
                        pContext->DesContext,
                        ChecksumToVerify,
                        DES_BLOCKLEN,
                        pContext->Confounder,
                        &cb
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    MD5Init(&pContext->Md5Context);

    // hash in the confounder
    MD5Update(&pContext->Md5Context, pContext->Confounder, DES_BLOCKLEN);

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        if (NULL != pContext)
        {
#ifdef KERNEL_MODE
            ExFreePool(pContext);
#else
            LocalFree(pContext);
#endif
        }
    }

    return(Status);

}

NTSTATUS NTAPI
md5Des1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR TmpBuffer[DES_BLOCKLEN * 2];
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) pcsBuffer;
    ULONG cb = DES_BLOCKLEN * 2;
    NTSTATUS Status = STATUS_SUCCESS;

    memcpy(TmpBuffer, pContext->Confounder, DES_BLOCKLEN);
    memcpy(TmpBuffer + DES_BLOCKLEN, pContext->Md5Context.digest, DES_BLOCKLEN);

    Status = desEncrypt(
                    pContext->DesContext,
                    TmpBuffer,
                    DES_BLOCKLEN * 2,
                    pbSum,
                    &cb
                    );

    return(Status);
}

NTSTATUS NTAPI
md5Des1510Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) *ppcsBuffer;
    desFinish(&pContext->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(pContext);
#else
    LocalFree(pContext);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\nullcs.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        nullcs.c
//
// Contents:    Null Crypto system
//
//
// History:
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#include "md4.h"


NTSTATUS NTAPI ncsInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsHashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI ncsRandomKey(PUCHAR, ULONG, PUCHAR );
NTSTATUS NTAPI ncsFinishRandom(void);


CRYPTO_SYSTEM    csNULL = {
    KERB_ETYPE_NULL,        // Etype
    1,                      // Blocksize (stream)
    0,                      // no exportable version
    0,                      // Key size, in bytes
    0,                      // no header size
    KERB_CHECKSUM_MD4,      // Checksum algorithm
    0,                      // no attributes
    L"Microsoft NULL CS",   // Text name
    ncsInitialize,
    ncsEncrypt,
    ncsDecrypt,
    ncsFinish,
    ncsHashPassword,
    ncsRandomKey
    };


NTSTATUS NTAPI
ncsInitialize(  PUCHAR pbKey,
                ULONG KeySize,
                ULONG dwOptions,
                PCRYPT_STATE_BUFFER * psbBuffer)
{

    *psbBuffer = NULL;
    return(S_OK);
}

NTSTATUS NTAPI
ncsEncrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);

    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);
    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    *psbBuffer = NULL;
    return(S_OK);
}


NTSTATUS NTAPI
ncsHashPassword(PSECURITY_STRING pbPassword,
                PUCHAR           pbKey)
{

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
ncsRandomKey(
    IN PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\rc4crypt.c ===
//+-----------------------------------------------------------------------
//
// File:        rc4crypt.c
//
// Contents:    CryptoSystem wrapper functions for RC4 hmac
//
//
// History:     02-Nov-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#include <rc4.h>
#include <md4.h>
#include <md5.h>

typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    UCHAR BaseKey[MD5_LEN];
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;


NTSTATUS NTAPI rc4PlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacPlainControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4HmacHashPassword(PSECURITY_STRING, PUCHAR );

#ifdef KERNEL_MODE
#pragma alloc_text(PAGEMSG, rc4PlainInitialize)
#pragma alloc_text(PAGEMSG, rc4PlainExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacFinish )
#pragma alloc_text(PAGEMSG, rc4HmacControl )
#pragma alloc_text(PAGEMSG, rc4HmacPlainControl )
#pragma alloc_text(PAGEMSG, rc4HmacRandomKey )
#pragma alloc_text(PAGEMSG, rc4HmacHashPassword )
#endif


CRYPTO_SYSTEM    csRC4_HMAC = {
    KERB_ETYPE_RC4_HMAC_NT,     // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


//
// This is not actually export strength - it is a signal that the
// plain version is export strength
//

CRYPTO_SYSTEM    csRC4_HMAC_EXP = {
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


CRYPTO_SYSTEM    csRC4_PLAIN = {
    KERB_ETYPE_RC4_PLAIN,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };

CRYPTO_SYSTEM    csRC4_PLAIN_EXP = {
    KERB_ETYPE_RC4_PLAIN_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };



NTSTATUS NTAPI
rc4HmacHashPassword(
    IN PSECURITY_STRING Password,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(KERB_CHECKSUM_MD4, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}




//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN static
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fiftysixbits",
            sizeof("fiftysixbits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    ASSERT(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4HmacPlainBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    StateBuffer = (PRC4_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->BaseKey
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->BaseKey
            );
        LocalKeySize = 7;       // 56 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    ASSERT(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->BaseKey+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    //
    // Create the encryption key
    //

    rc4_key(
        &StateBuffer->Key,
        MD5_LEN,
        StateBuffer->BaseKey
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4PlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_STATE_BUFFER HmacStateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        //
        // create the new initial key
        //

        md5Hmac(
            HmacStateBuffer->BaseKey,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->BaseKey
            );

        //
        // Create the encryption key
        //

        rc4_key(
            &HmacStateBuffer->Key,
            MD5_LEN,
            HmacStateBuffer->BaseKey
            );

    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    UCHAR LocalKey[MD5_LEN];
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    Offset = sizeof(RC4_MDx_HEADER);
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    RtlZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    CDGenerateRandomBits(
        CryptHeader->Confounder,
        RC4_CONFOUNDER_LEN
        );

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *cbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );


    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );

    //
    // Encrypt everything but the checksum
    //

    rc4(&Rc4Key, *cbOutput-MD5_LEN, pbOutput+MD5_LEN);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecrypt( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    UCHAR LocalKey[MD5_LEN];
    RC4KEY Rc4Key;


    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );


    //
    // Now decrypt the two buffers
    //


    rc4(
        &Rc4Key,
        Offset - MD5_LEN,
        TempHeader.Confounder
        );


    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *cbOutput,
        TempChecksum
        );

    if (RtlEqualMemory(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;
    rc4(
        &StateBuffer->Key,
        cbInput,
        pbInput
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainDecrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;

    rc4(
        &StateBuffer->Key,
        *cbOutput,
        pbOutput
        );
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    CDGenerateRandomBits(pbKey,MD5_LEN);

    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\deswrap.c ===
//+-----------------------------------------------------------------------
//
// File:        DESWRAP.C
//
// Contents:    CryptoSystem wrapper functions for DES
//
//
// History:     06-Sep-1996     MikeSw          Created
//
//------------------------------------------------------------------------

//
// Portions of this code (the key generation code) were taken from the
// MIT kerberos distribution.
//

/*
 *
 * Copyright 1989,1990 by the Massachusetts Institute of Technology.
 * All Rights Reserved.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 *
 * Under U.S. law, this software may not be exported outside the US
 * without license from the U.S. Commerce department.
 *
 * These routines form the library interface to the DES facilities.
 *
 * Originally written 8/85 by Steve Miller, MIT Project Athena.
 */

/* des.c - Routines for implementing the FIPS Data Encryption Standard (DES).
 *
 *         Allan Bjorklund, University of Michigan, ITD/RS/DD.
 *         July 24, 1993.
 *
 *         Revisions for PC memory model portability, July 11, 1994.
 *
 *         Removed model portability header and added Win95 DLL
 *         declarations, May 31, 1995.
 *
 *         Made all declarations Win95 and NT specific, September 18, 1995.
 *
 *         Added quad_cksum, October 9, 1995.
 *
 * Copyright (c) 1995,1996 Regents of The University of Michigan.
 * All Rights Reserved.
 *
 *     Permission to use, copy, modify, and distribute this software and
 *     its documentation for any purpose and without fee is hereby granted,
 *     provided that the above copyright notice appears in all copies and
 *     that both that copyright notice and this permission notice appear
 *     in supporting documentation, and that the name of The University
 *     of Michigan not be used in advertising or publicity pertaining to
 *     distribution of the software without specific, written prior
 *     permission. This software is supplied as is without expressed or
 *     implied warranties of any kind.
 *
 * Research Systems Unix Group
 * The University of Michigan
 * c/o Allan Bjorklund
 * 535 W. William Street
 * Ann Arbor, Michigan
 * kerb95@umich.edu
 */

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#else 

#include <ntifs.h>
#include <winerror.h>

#endif

#include <string.h>
#include <malloc.h>
#include <align.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#include "modes.h"
#include "des.h"
#include "md5.h"

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );

#define DES_CONFOUNDER_LEN 8

typedef struct _DES_HEADER {
    UCHAR Confounder[DES_CONFOUNDER_LEN];
    UCHAR Checksum[MD5_LEN];
} DES_HEADER, *PDES_HEADER;



typedef struct _DES_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_STATE_BUFFER, *PDES_STATE_BUFFER;

typedef struct _DES_MAC_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR Confounder[DES_BLOCKLEN];
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_MAC_STATE_BUFFER, *PDES_MAC_STATE_BUFFER;

typedef struct _DES_MAC_1510_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
    UCHAR Confounder[DES_BLOCKLEN];
    DESTable FinalKeyTable;
} DES_MAC_1510_STATE_BUFFER, *PDES_MAC_1510_STATE_BUFFER;

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desPlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5ExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desCrc32Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desHashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI desInitRandom(ULONG);
NTSTATUS NTAPI desRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI desFinishRandom(void);
NTSTATUS NTAPI desControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI desMacGeneralInitializeEx(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacKInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMac1510Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx2(PUCHAR,ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, desPlainInitialize )
#pragma alloc_text( PAGEMSG, desPlainExpInitialize )
#pragma alloc_text( PAGEMSG, desMd5Initialize )
#pragma alloc_text( PAGEMSG, desMd5ExpInitialize )
#pragma alloc_text( PAGEMSG, desCrc32Initialize )
#pragma alloc_text( PAGEMSG, desEncrypt )
#pragma alloc_text( PAGEMSG, desDecrypt )
#pragma alloc_text( PAGEMSG, desFinish )
#pragma alloc_text( PAGEMSG, desHashPassword )
#pragma alloc_text( PAGEMSG, desInitRandom )
#pragma alloc_text( PAGEMSG, desRandomKey )
#pragma alloc_text( PAGEMSG, desFinishRandom )
#pragma alloc_text( PAGEMSG, desControl )
#pragma alloc_text( PAGEMSG, desMacInitialize )
#pragma alloc_text( PAGEMSG, desMacInitializeEx )
#pragma alloc_text( PAGEMSG, desMacSum )
#pragma alloc_text( PAGEMSG, desMacFinalize )
#pragma alloc_text( PAGEMSG, desMacFinish )
#pragma alloc_text( PAGEMSG, desMacGeneralInitializeEx )
#pragma alloc_text( PAGEMSG, desMacKInitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510Initialize )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, desMac1510Finalize )
#endif


CRYPTO_SYSTEM    csDES_MD5 = {
    KERB_ETYPE_DES_CBC_MD5,     // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_CBC_MD5, // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_MD5,          // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-MD5",    // Text name
    desMd5Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };


CRYPTO_SYSTEM    csDES_CRC32 = {
    KERB_ETYPE_DES_CBC_CRC,     // Etype
    DES_BLOCKLEN,               // Blocksize (stream)
    KERB_ETYPE_DES_CBC_CRC,     // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-CRC",    // Text name
    desCrc32Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };

CRYPTO_SYSTEM    csDES_PLAIN = {
    KERB_ETYPE_DES_PLAIN,       // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_PLAIN,       // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME | CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-Plain",        // Text name
    desPlainInitialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };



CHECKSUM_FUNCTION    csfDesMac = {
    KERB_CHECKSUM_DES_MAC,                  // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMacK = {
    KERB_CHECKSUM_KRB_DES_MAC_K,            // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacKInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMac1510 = {
    KERB_CHECKSUM_KRB_DES_MAC,              // Checksum type
    DES_BLOCKLEN * 2,                       // Checksum length
    CKSUM_KEYED,
    desMac1510Initialize,
    desMacSum,
    desMac1510Finalize,
    desMacFinish,                           // just frees the buffer
    desMac1510InitializeEx,
    desMac1510InitializeEx2};


#define SMASK(step) ((1<<step)-1)
#define PSTEP(x,step) (((x)&SMASK(step))^(((x)>>step)&SMASK(step)))
#define PARITY_CHAR(x, y) \
{\
    UCHAR _tmp1_, _tmp2_; \
    _tmp1_ = (UCHAR) PSTEP((x),4); \
    _tmp2_ = (UCHAR) PSTEP(_tmp1_,2); \
    *(y) = (UCHAR) PSTEP(_tmp2_, 1); \
} \


VOID
desFixupKeyParity(
    PUCHAR Key
    )
{
    ULONG Index;
    UCHAR TempChar;
    for (Index=0; Index < DES_BLOCKLEN; Index++)
    {
        Key[Index] &= 0xfe;
        PARITY_CHAR(Key[Index], &TempChar);
        Key[Index] |= 1 ^ TempChar;
    }

}

typedef UCHAR DES_KEYBLOCK[8];

DES_KEYBLOCK desWeakKeys[] = {
    /* weak keys */
    {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
    {0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe},
    {0x1f,0x1f,0x1f,0x1f,0x0e,0x0e,0x0e,0x0e},
    {0xe0,0xe0,0xe0,0xe0,0xf1,0xf1,0xf1,0xf1},

    /* semi-weak */
    {0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe},
    {0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01},

    {0x1f,0xe0,0x1f,0xe0,0x0e,0xf1,0x0e,0xf1},
    {0xe0,0x1f,0xe0,0x1f,0xf1,0x0e,0xf1,0x0e},

    {0x01,0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1},
    {0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1,0x01},

    {0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e,0xfe},
    {0xfe,0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e},

    {0x01,0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e},
    {0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e,0x01},

    {0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1,0xfe},
    {0xfe,0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1}
};

/*
 * mit_des_is_weak_key: returns true iff key is a [semi-]weak des key.
 *
 * Requires: key has correct odd parity.
 */

BOOLEAN
desIsWeakKey(
    PUCHAR Key
    )
{
    ULONG Index;
    DES_KEYBLOCK * WeakKey = desWeakKeys;

    for (Index = 0; Index < sizeof(desWeakKeys)/DES_BLOCKLEN; Index++) {
        if (RtlEqualMemory(
                WeakKey++,
                Key,
                DES_BLOCKLEN
                ))
        {
            return( TRUE );
        }
    }

    return(FALSE);
}


NTSTATUS NTAPI
desInitialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           Checksum,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    PDES_STATE_BUFFER DesKey = NULL;
    PCHECKSUM_FUNCTION ChecksumFunction = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Get the appropriate checksum here.
    //

    if (Checksum != 0)
    {
        Status = CDLocateCheckSum(
                    Checksum,
                    &ChecksumFunction
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    else
    {
        ChecksumFunction = NULL;
    }

    //
    // Create the key buffer
    //


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool (NonPagedPool, sizeof(DES_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    deskey(&DesKey->KeyTable, pbKey);

    //
    // Initialize the checksum function
    //

    DesKey->ChecksumFunction = ChecksumFunction;

    //
    // DES-CBC-CRC uses the key as the ivec, MD5 and MD4 user zero
    //

    if (Checksum == KERB_CHECKSUM_CRC32)
    {
        RtlCopyMemory(
            DesKey->InitializationVector,
            pbKey,
            DES_BLOCKLEN
            );
    }
    else
    {
        RtlZeroMemory(
            DesKey->InitializationVector,
            DES_BLOCKLEN
            );

    }


    *psbBuffer = (PCRYPT_STATE_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

#if DBG
void
DumpBuf(
    IN PUCHAR Buf,
    IN ULONG BufSize
    )
{
    ULONG Index;
    for (Index = 0; Index < BufSize ;Index++ )
    {
        DbgPrint("%0.2x ",Buf[Index]);
    }
}

#endif

NTSTATUS NTAPI
desMd5Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD5,
                psbBuffer
                ));
}



NTSTATUS NTAPI
desCrc32Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_CRC32,
                psbBuffer
                ));
}

NTSTATUS NTAPI
desPlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                0,              // no checksum
                psbBuffer
                ));
}




//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Encrypts a data buffer using DES
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      stolen from windows\base\ntcyrpto\scp\nt_crypt.c
//
//
//--------------------------------------------------------------------------



NTSTATUS
BlockEncrypt(
    IN PDES_STATE_BUFFER pKey,
    IN PUCHAR  pbData,
    OUT PULONG pdwDataLen,
    IN ULONG dwBufLen
    )
{
    ULONG   cbPartial, dwPadVal, dwDataLen;
    UCHAR    pbBuf[DES_BLOCKLEN];
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Initialize the feedback buffer to the initialization vector
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // check length of the buffer and calculate the pad
    // (if multiple of DES_BLOCKLEN, do a full block of pad)
    //

    cbPartial = (dwDataLen % DES_BLOCKLEN);

    //
    // The original code here put in 8 bytes of padding
    // on an aligned buffer. That is a waste.
    //

    if (cbPartial != 0)
    {
        dwPadVal = DES_BLOCKLEN - cbPartial;
    }
    else
    {
        dwPadVal = 0;
    }

    if (pbData == NULL || dwBufLen < dwDataLen + dwPadVal)
    {
        //
        // set what we need
        //

        *pdwDataLen = dwDataLen + dwPadVal;
        if (pbData == NULL)
        {
            return (STATUS_SUCCESS);
        }
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // allocate memory for a temporary buffer
    //


    //
    // Will this cause MIT clients/servers to flail? The caller
    // should pass in only buffers that are already padded to
    // make MIT clients work.
    //

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        memset(
            pbData + dwDataLen,
            dwPadVal,
            dwPadVal
            );
    }

    dwDataLen += dwPadVal;
    *pdwDataLen = dwDataLen;

    ASSERT((dwDataLen % DES_BLOCKLEN) == 0);

    //
    // pump the full blocks of data through
    //
    while (dwDataLen)
    {
        ASSERT(dwDataLen >= DES_BLOCKLEN);

        //
        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer
        //

        memcpy(pbBuf, pbData, DES_BLOCKLEN);

        CBC(    des,
                DES_BLOCKLEN,
                pbData,
                pbBuf,
                &pKey->KeyTable,
                ENCRYPT,
                FeedBack
                );


        pbData += DES_BLOCKLEN;
        dwDataLen -= DES_BLOCKLEN;
    }
    memcpy(
        pKey->InitializationVector,
        pbData - DES_BLOCKLEN,
        DES_BLOCKLEN
        );


    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Decrypt a block of data encrypted with BlockEncrypt
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
BlockDecrypt(
    IN PDES_STATE_BUFFER pKey,
    IN OUT PUCHAR  pbData,
    IN OUT PULONG pdwDataLen
    )
{
    UCHAR    pbBuf[DES_BLOCKLEN];
    ULONG   dwDataLen, BytePos;
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Check to see if we are decrypting something already
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // The data length must be a multiple of the algorithm
    // pad size.
    //
    if (dwDataLen % DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of DES_BLOCKLEN
    //

    for (BytePos = 0; (BytePos + DES_BLOCKLEN) <= dwDataLen; BytePos += DES_BLOCKLEN)
    {
        //
        // put the encrypted text into a temp buffer
        //

        memcpy (pbBuf, pbData + BytePos, DES_BLOCKLEN);


        CBC(
            des,
            DES_BLOCKLEN,
            pbData + BytePos,
            pbBuf,
            &pKey->KeyTable,
            DECRYPT,
            FeedBack
            );



    }

    memcpy(
        pKey->InitializationVector,
        pbBuf,
        DES_BLOCKLEN
        );

    return STATUS_SUCCESS;
}

NTSTATUS NTAPI
desEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR OutputBuffer,
    OUT PULONG OutputLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader = (PDES_HEADER) OutputBuffer;
    PCHECKSUM_BUFFER SumBuffer = NULL;
    ULONG LocalOutputLength;

    //
    // If we aren't doing raw DES, prepare a header structure
    //

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //
        // Relocate the buffer and inserat the header
        //

        RtlMoveMemory(
            OutputBuffer + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            pbInput,
            cbInput
            );
        LocalOutputLength = cbInput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize;


        //
        // Zero fill the padding space
        //

        RtlZeroMemory(
            OutputBuffer+LocalOutputLength,
            ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN) - LocalOutputLength
            );

        LocalOutputLength = ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN);


        RtlZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            DES_CONFOUNDER_LEN
            );


        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            LocalOutputLength,
            OutputBuffer
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );

    }
    else
    {
        //
        // Just copy the buffer
        //

        RtlCopyMemory(
            OutputBuffer,
            pbInput,
            cbInput
            );

        LocalOutputLength = ROUND_UP_COUNT(cbInput,DES_BLOCKLEN);

        //
        // Zero fill the padding space
        //

        RtlZeroMemory(
            OutputBuffer+cbInput,
            LocalOutputLength - cbInput
            );

    }

    //
    // Encrypt the buffer.
    //


    *OutputLength = LocalOutputLength;

    Status = BlockEncrypt(
                StateBuffer,
                OutputBuffer,
                OutputLength,
                LocalOutputLength
                );


Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader;
    UCHAR Checksum[MD5_LEN];
    PCHECKSUM_BUFFER SumBuffer = NULL;

    //
    // First decrypt the whole buffer
    //

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);

    }

    RtlCopyMemory(
        pbOutput,
        pbInput,
        cbInput
        );
    Status = BlockDecrypt(
                StateBuffer,
                pbOutput,
                &cbInput
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //
        // Now verify the checksum
        //

        CryptHeader = (PDES_HEADER) pbOutput;
        RtlCopyMemory(
            Checksum,
            CryptHeader->Checksum,
            MD5_LEN
            );

        //
        // Zero the checksum field before computing the checksum of the buffer
        //

        RtlZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            cbInput,
            pbOutput
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );


        if (!RtlEqualMemory(
                CryptHeader->Checksum,
                Checksum,
                StateBuffer->ChecksumFunction->CheckSumSize
                ))
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }

        //
        // Copy the input to the output without the header

        *cbOutput = cbInput - (DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize);


        RtlMoveMemory(
            pbOutput,
            pbOutput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            *cbOutput
            );

    }
    else
    {
        *cbOutput = cbInput;

    }

Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) *psbBuffer;


#ifdef KERNEL_MODE
    ExFreePool(StateBuffer);
#else
    LocalFree(StateBuffer);
#endif
    *psbBuffer = NULL;
    return(S_OK);
}

#define MIN(x,y) (((x) < (y)) ? (x) : (y))

#define XORBLOCK(x,y) \
{ \
    PULONG tx = (PULONG) x; \
    PULONG ty = (PULONG) y; \
    *tx++ ^= *ty++; \
    *tx++ ^= *ty++; \
}

VOID
desCbcChecksum(
    IN PUCHAR Password,
    IN ULONG PasswordLength,
    IN PUCHAR InitialVector,
    IN DESTable * KeyTable,
    OUT PUCHAR OutputKey
    )
{
    ULONG Offset;
    UCHAR Feedback[DES_BLOCKLEN];
    UCHAR Block[DES_BLOCKLEN];

    RtlCopyMemory(
        Feedback,
        InitialVector,
        DES_BLOCKLEN
        );

    for (Offset = 0; Offset < PasswordLength ; Offset+= 8 )
    {
        RtlZeroMemory(
            Block,
            DES_BLOCKLEN
            );

        RtlCopyMemory(
            Block,
            Password+Offset,
            MIN(DES_BLOCKLEN, PasswordLength - Offset)
            );

        XORBLOCK(Block, Feedback);
        des(
            Feedback,
            Block,
            KeyTable,
            ENCRYPT
            );


    }
    RtlCopyMemory(
        OutputKey,
        Feedback,
        DES_BLOCKLEN
        );

}

#define BITREVERSE(c)   ((UCHAR)((((c & 0x01) ? 0x80 : 0x00)\
                                |((c & 0x02) ? 0x40 : 0x00)\
                                |((c & 0x04) ? 0x20 : 0x00)\
                                |((c & 0x08) ? 0x10 : 0x00)\
                                |((c & 0x10) ? 0x08 : 0x00)\
                                |((c & 0x20) ? 0x04 : 0x00)\
                                |((c & 0x40) ? 0x02 : 0x00))\
                                & 0xFE))

//
// This is the core routine that converts a buffer into a key. It is called
// by desHashPassword and desRandomKey
//

VOID
desHashBuffer(
    IN PUCHAR LocalPassword,
    IN ULONG PasswordLength,
    IN OUT PUCHAR Key
    )
{
    ULONG Index;
    BOOLEAN Forward;
    PUCHAR KeyPointer = Key;
    DESTable KeyTable;

    RtlZeroMemory(
        Key,
        DES_BLOCKLEN
        );

    //
    // Initialize our temporary parity vector
    //

    //
    // Start fanfolding the bytes into the key
    //

    Forward = TRUE;
    KeyPointer = Key;
    for (Index = 0; Index < PasswordLength ; Index++ )
    {

        if (!Forward)
        {
            *(--KeyPointer) ^= BITREVERSE(LocalPassword[Index] & 0x7F);
        }
        else
        {
            *KeyPointer++  ^= (LocalPassword[Index] & 0x7F) << 1;
        }
        if (((Index+1) & 0x07) == 0)     /* When MOD 8 equals 0 */
        {
            Forward = !Forward;         /* Change direction.   */
        }

    }

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }

    //
    // Now calculate the des-cbc-mac of the original string
    //

    deskey(&KeyTable, Key);

    //
    // Now compute the CBC checksum of the string
    //

    desCbcChecksum(
        LocalPassword,
        PasswordLength,
        Key,                    // initial vector
        &KeyTable,
        Key                     // output key
        );

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }
}

NTSTATUS NTAPI
desHashPassword(
    IN PSECURITY_STRING Password,
    OUT PUCHAR Key
    )
{

    PUCHAR LocalPassword = NULL;
    ULONG PasswordLength;
    OEM_STRING OemPassword;
    NTSTATUS Status;


    //
    // First convert the UNICODE string to an OEM string
    //



    Status = RtlUnicodeStringToOemString(
                &OemPassword,
                Password,
                TRUE            // allocate destination
                );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // We hash the password according to RFC1510
    //
    // This code is derived from the MIT Kerberos code in string2key.c
    //


    PasswordLength = ROUND_UP_COUNT(OemPassword.Length,8);
#ifdef KERNEL_MODE
    LocalPassword = (PUCHAR) ExAllocatePool(NonPagedPool, PasswordLength);
#else
    LocalPassword = (PUCHAR) LocalAlloc(0, PasswordLength);
#endif
    if (LocalPassword == NULL)
    {
        RtlFreeOemString( &OemPassword );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        LocalPassword,
        OemPassword.Buffer,
        OemPassword.Length
        );

    //
    // Zero extend the password
    //

    RtlZeroMemory(
        LocalPassword + OemPassword.Length,
        PasswordLength - OemPassword.Length
        );


    //
    // Initialize our temporary parity vector
    //
    desHashBuffer(
        LocalPassword,
        PasswordLength,
        Key
        );
    RtlFreeOemString( &OemPassword );
#ifdef KERNEL_MODE
    ExFreePool(LocalPassword);
#else
    LocalFree(LocalPassword);
#endif

    return(STATUS_SUCCESS);
}




NTSTATUS NTAPI
desRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey)
{
    UCHAR Buffer[16];
    do
    {
        CDGenerateRandomBits(Buffer,16);

        desHashBuffer(
            Buffer,
            16,
            pbKey
            );

    } while (desIsWeakKey(pbKey));
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    PDES_STATE_BUFFER DesStateBuffer = (PDES_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize != DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    memcpy(
        DesStateBuffer->InitializationVector,
        InputBuffer,
        DES_BLOCKLEN
        );
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
desMacGeneralInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR IV,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PDES_MAC_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create the key buffer
    //


    deskey(&DesKey->KeyTable, Key);


    RtlCopyMemory(
        DesKey->InitializationVector,
        IV,
        DES_BLOCKLEN
        );

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMacInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    UCHAR IV[DES_BLOCKLEN];

    RtlZeroMemory(
        IV,
        DES_BLOCKLEN
        );

    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                IV,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacKInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                Key,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacInitialize(ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

//
// NOTE - This function is used with both DES_MAC_STATE_BUFFER and
// DES_MAC_1510_STATE_BUFFER as the pcsBuffer parameter, since the
// DES_MAC_1510_STATE_BUFFER is the same as DES_MAC_STATE_BUFFER
// except with an added confounder this should be OK.
//
NTSTATUS NTAPI
desMacSum(
    PCHECKSUM_BUFFER     pcsBuffer,
    ULONG                cbData,
    PUCHAR               pbData)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;
    UCHAR FeedBack[DES_BLOCKLEN];
    UCHAR TempBuffer[DES_BLOCKLEN];
    UCHAR OutputBuffer[DES_BLOCKLEN];
    ULONG Index;

    //
    // Set up the IV for this round - it may be zero or the output of
    // a previous MAC
    //

    memcpy(
        FeedBack,
        DesKey->InitializationVector,
        DES_BLOCKLEN
        );

    for (Index = 0; Index < cbData ; Index += DES_BLOCKLEN )
    {
        //
        // Compute the input buffer, with padding
        //

        if (Index+DES_BLOCKLEN > cbData)
        {
            memset(
                TempBuffer,
                0,
                DES_BLOCKLEN
                );
            memcpy(
                TempBuffer,
                pbData,
                Index & (DES_BLOCKLEN-1)
                );

        }
        else
        {
            memcpy(
                TempBuffer,
                pbData+Index,
                DES_BLOCKLEN
                );
        }


        CBC(    des,
                DES_BLOCKLEN,
                TempBuffer,
                OutputBuffer,
                &DesKey->KeyTable,
                ENCRYPT,
                FeedBack
                );
    }

    //
    // Copy the feedback back into the IV for the next round
    //

    memcpy(
        DesKey->InitializationVector,
        FeedBack,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;

    memcpy(pbSum, DesKey->InitializationVector, DES_BLOCKLEN);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMac1510Initialize(ULONG               dwSeed,
                     PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}


NTSTATUS NTAPI
desMac1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
desMac1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PDES_MAC_1510_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_1510_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_1510_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    deskey(&DesKey->FinalKeyTable, FinalKey);

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(DesKey->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        des(DesKey->Confounder, ChecksumToVerify, &DesKey->FinalKeyTable, DECRYPT);
    }

    //
    // Create the key buffer
    //
    deskey(&DesKey->KeyTable, Key);


    // the IV is all zero so no need to use CBC on first block, but the
    // ecncrypted confounder becomes the next IV
    des(DesKey->InitializationVector, DesKey->Confounder, &DesKey->KeyTable, ENCRYPT);

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMac1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR Feedback[DES_BLOCKLEN];
    PDES_MAC_1510_STATE_BUFFER DesKey = (PDES_MAC_1510_STATE_BUFFER) pcsBuffer;

    // the IV is all zero so no need to use CBC on first block
    des(Feedback, DesKey->Confounder, &DesKey->FinalKeyTable, ENCRYPT);

    memcpy(pbSum, Feedback, DES_BLOCKLEN);

    // use CBC on second block
    CBC(    des,
            DES_BLOCKLEN,
            pbSum + DES_BLOCKLEN,
            DesKey->InitializationVector,
            &DesKey->FinalKeyTable,
            ENCRYPT,
            Feedback
            );

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\rng.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rng.c
//
//  Contents:   Random Number Generator
//
//  Classes:
//
//  Functions:
//
//  History:    5-12-93   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <security.h>

#include <cryptdll.h>
#include <windows.h>
#include <randlib.h>
#include <crypt.h>

#ifdef KERNEL_MODE
int _fltused = 0x9875;
#endif

BOOLEAN NTAPI   DefaultRngFn(PUCHAR, ULONG);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 

#define MAX_RNGS    4

RANDOM_NUMBER_GENERATOR   Rngs[MAX_RNGS];
ULONG                   cRngs = 0;

RANDOM_NUMBER_GENERATOR   DefaultRng = {CD_BUILTIN_RNG,
                                        RNG_PSEUDO_RANDOM,
                                        0,
                                        DefaultRngFn };


BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDGenerateRandomBits )
#pragma alloc_text( PAGEMSG, CDRegisterRng )
#pragma alloc_text( PAGEMSG, CDLocateRng )
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 


//
// Management functions:
//

BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer)
{
    return(Rngs[cRngs-1].GenerateBitstream(pBuffer, cbBuffer));
}


BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng)
{
    if (cRngs < MAX_RNGS)
    {
        Rngs[cRngs++] = *pRng;
        return(TRUE);
    }
    return(FALSE);
}

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng)
{
    ULONG   i;

    for (i = 0; i < MAX_RNGS ; i++ )
    {
        if (Rngs[i].GeneratorId == Id)
        {
            *ppRng = &Rngs[i];
            return(TRUE);
        }
    }

    *ppRng = NULL;
    return(FALSE);

}


BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{
    //
    // use the crypto group provided random number generator.
    //

#ifdef KERNEL_MODE
    NewGenRandom(NULL, NULL, pbBuffer, cbBuffer);
    return TRUE;
#else
    return RtlGenRandom( pbBuffer, cbBuffer );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\rc4cwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        RC4CWRAP.C
//
// Contents:    CryptoSystem wrapper functions for RC4
//
//
// History:     25 Feb 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#include <rc4.h>
#include <md4.h>
#include <md5.h>

//#define DONT_SUPPORT_OLD_ETYPES 1

typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_LEGAL_KEYSIZE   8
#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR Checksum[MD4_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER ChecksumBuffer;
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
    BOOLEAN IncludeHmac;
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;

NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI rc4Plain2Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmHashPassword(PSECURITY_STRING, PUCHAR);
#endif
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Md4HashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI rc4Md4RandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4Control(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI rc4PlainInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinishOld(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControlOld(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKeyOld(PUCHAR, ULONG, PUCHAR);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, rc4Md4Initialize )
#pragma alloc_text( PAGEMSG, rc4LmInitialize )
#pragma alloc_text( PAGEMSG, rc4Encrypt )
#pragma alloc_text( PAGEMSG, rc4Decrypt )
#pragma alloc_text( PAGEMSG, rc4Finish )
#pragma alloc_text( PAGEMSG, rc4Md4HashPassword )
#pragma alloc_text( PAGEMSG, rc4Md4RandomKey )
#pragma alloc_text( PAGEMSG, rc4Control )
#pragma alloc_text( PAGEMSG, rc4PlainInitializeOld )
#pragma alloc_text( PAGEMSG, rc4PlainExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacDecryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacEncryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacFinishOld )
#pragma alloc_text( PAGEMSG, rc4HmacControlOld )
#pragma alloc_text( PAGEMSG, rc4HmacRandomKeyOld )
#endif

CRYPTO_SYSTEM    csRC4_MD4 = {
    KERB_ETYPE_RC4_MD4,         // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-MD4",          // Text name
    rc4Md4Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

#ifndef DONT_SUPPORT_OLD_ETYPES

CRYPTO_SYSTEM    csRC4_LM = {
    KERB_ETYPE_RC4_LM,          // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // State buffer size
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_LM,           // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-LM",           // Text name
    rc4LmInitialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4LmHashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

CRYPTO_SYSTEM    csRC4_PLAIN2 = {
    KERB_ETYPE_RC4_PLAIN2,      // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4-PLAIN",        // Text name
    rc4Plain2Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };
#endif

CRYPTO_SYSTEM    csRC4_HMAC_OLD = {
    KERB_ETYPE_RC4_HMAC_OLD,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP,// Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_HMAC_OLD_EXP = {
    KERB_ETYPE_RC4_HMAC_OLD_EXP,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


CRYPTO_SYSTEM    csRC4_PLAIN_OLD = {
    KERB_ETYPE_RC4_PLAIN_OLD,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_PLAIN_OLD_EXP = {
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


NTSTATUS NTAPI
rc4Initialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           ChecksumFunction,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    PRC4_STATE_BUFFER    pRC4Key;
    PCHECKSUM_FUNCTION Checksum = NULL;

    //
    // Get the appropriate checksum here.
    //

    if (ChecksumFunction != 0)
    {
        Status = CDLocateCheckSum(
                    ChecksumFunction,
                    &Checksum
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    //
    // if the key is too short, fail here.
    //

    if (KeySize < RC4_LEGAL_KEYSIZE)
    {
        return(SEC_E_ETYPE_NOT_SUPP);
    }

#ifdef KERNEL_MODE
    pRC4Key = ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    pRC4Key = LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (pRC4Key == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    rc4_key(&pRC4Key->Key, RC4_LEGAL_KEYSIZE, pbKey);

    //
    // Initialize the checksum function, if we have one.
    //

    pRC4Key->ChecksumFunction = Checksum;

    if (Checksum != NULL)
    {

        Status = Checksum->Initialize(
                    0,
                    &pRC4Key->ChecksumBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
#ifdef KERNEL_MODE
            ExFreePool(pRC4Key);
#else
            LocalFree(pRC4Key);
#endif
            return(Status);
        }
    }

    *psbBuffer = (PCRYPT_STATE_BUFFER) pRC4Key;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD4,
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4LmInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_LM,
                psbBuffer
                ));
}

#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI
rc4Plain2Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                0,                      // no checksum
                psbBuffer
                ));
}


#endif

NTSTATUS NTAPI
rc4Encrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;


    RtlZeroMemory(
        CryptHeader,
        Offset
        );

    rc4(&StateBuffer->Key, *cbOutput, pbOutput);

    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Decrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    ULONG Offset = 0;

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);
    }
    RtlCopyMemory(
        pbOutput,
        pbInput,
        cbInput
        );

    rc4(&StateBuffer->Key, cbInput, pbOutput);

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }

    RtlZeroMemory(
        &TempHeader,
        Offset
        );

    if (RtlEqualMemory(
            &TempHeader,
            pbOutput,
            Offset
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }


    *cbOutput = cbInput - Offset;


    RtlMoveMemory(
        pbOutput,
        pbOutput + Offset,
        *cbOutput
        );


    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Finish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) *psbBuffer;


    if (StateBuffer->ChecksumFunction != NULL)
    {
        StateBuffer->ChecksumFunction->Finish(&StateBuffer->ChecksumBuffer);
    }
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
rc4HashPassword(
    IN PSECURITY_STRING Password,
    IN ULONG Checksum,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(Checksum, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4HashPassword(
    PSECURITY_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_MD4, pbKey));
}

NTSTATUS NTAPI
rc4LmHashPassword(
    PSECURITY_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_LM, pbKey));
}


NTSTATUS NTAPI
rc4RandomKey(
    IN ULONG KeyLength,
    OUT PUCHAR pbKey
    )
{

    CDGenerateRandomBits(pbKey,KeyLength);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4RandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    memset(
        pbKey,
        0xab,
        MD4_LEN
        );
    return(rc4RandomKey(5,pbKey));
}




NTSTATUS NTAPI
rc4Control(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    UCHAR TempBuffer[128];

    PRC4_STATE_BUFFER Rc4StateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize > sizeof(TempBuffer))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // We set the IV by encrypting the supplied buffer and leaving the
    // keystate changed.
    //

    memcpy(
        TempBuffer,
        InputBuffer,
        InputBufferSize
        );
    rc4(&Rc4StateBuffer->Key, InputBufferSize, TempBuffer );

    return(STATUS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN IncludeHmac,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    LPSTR Direction = NULL;
    ULONG DirectionSize = 0;
    LPSTR Usage = NULL;
    ULONG UsageSize = 0;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    StateBuffer->IncludeHmac = IncludeHmac;
    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                TRUE,           // include hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4PlainInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // no hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                FALSE,                  // no hmac
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControlOld(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncryptOld(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    if (StateBuffer->IncludeHmac)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    else
    {
        Offset = 0;
    }
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    if (Offset != 0)
    {
        RtlZeroMemory(
            CryptHeader->Checksum,
            MD4_LEN
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            RC4_CONFOUNDER_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            pbOutput,
            *cbOutput,
            NULL,
            0,
            CryptHeader->Checksum
            );
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    rc4(&Rc4Key, *cbOutput, pbOutput);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecryptOld( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    RC4KEY Rc4Key;

    if (!StateBuffer->IncludeHmac)
    {
        Offset = 0;
    }

    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );

    //
    // Now decrypt the two buffers
    //


    if (Offset != 0)
    {
        rc4(
            &Rc4Key,
            Offset,
            (PUCHAR) &TempHeader
            );
    }

    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //

    if (Offset != 0)
    {

        RtlCopyMemory(
            TempChecksum,
            TempHeader.Checksum,
            MD5_LEN
            );

        RtlZeroMemory(
            TempHeader.Checksum,
            MD5_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            (PUCHAR) &TempHeader,
            Offset,
            pbOutput,
            *cbOutput,
            TempHeader.Checksum
            );

        if (RtlEqualMemory(
                TempHeader.Checksum,
                TempChecksum,
                MD5_LEN
                ) != TRUE)
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinishOld(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKeyOld(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(rc4RandomKey(MD5_LEN,pbKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\shawrap.c ===
//
//

#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntddk.h>
#include <winerror.h>

#endif

#include <string.h>
#include <malloc.h>

#include <security.h>
#include <cryptdll.h>

#include <kerbcon.h>

#include "sha.h"


NTSTATUS
ShaWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
ShaWrapInitializeEx(PUCHAR Seed, ULONG dwSeedLength, ULONG MessageType,
                PCHECKSUM_BUFFER * ppcsBuffer);


NTSTATUS
ShaWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
ShaWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
ShaWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfSHA = {
    KERB_CHECKSUM_SHA1,
    A_SHA_DIGEST_LEN,
    CKSUM_COLLISION,
    ShaWrapInitialize,
    ShaWrapSum,
    ShaWrapFinalize,
    ShaWrapFinish,
    ShaWrapInitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, ShaWrapInitialize )
#pragma alloc_text( PAGEMSG, ShaWrapSum )
#pragma alloc_text( PAGEMSG, ShaWrapFinalize )
#pragma alloc_text( PAGEMSG, ShaWrapFinish )
#pragma alloc_text( PAGEMSG, ShaWrapInitializeEx )
#endif 

NTSTATUS
ShaWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}

NTSTATUS
ShaWrapInitializeEx(
    PUCHAR Seed,
    ULONG SeedLength,
    ULONG MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}


NTSTATUS
ShaWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAUpdate( pContext, pbData, cbData );

    return( STATUS_SUCCESS );

}


NTSTATUS
ShaWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAFinal( pContext, pbSum );

    return( STATUS_SUCCESS );

}

NTSTATUS
ShaWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    RtlZeroMemory( *ppcsBuffer, sizeof( A_SHA_CTX ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\dbgtool\dialogs.h ===
#define IDD_DEBUG_TOOL              100
#define IDD_MODULE_BOX              101
#define IDD_CHECK_BOX               102
#define IDD_CHECK_0                 104
#define IDD_CHECK_1                 105
#define IDD_CHECK_2                 106
#define IDD_CHECK_3                 107
#define IDD_CHECK_4                 108
#define IDD_DEBUG_LB                103
#define IDD_CHECK_5                 109
#define IDD_CHECK_6                 110
#define IDD_CHECK_7                 111
#define IDD_CHECK_8                 112
#define IDD_CHECK_9                 113
#define IDD_CHECK_10                114
#define IDD_CHECK_11                115
#define IDD_CHECK_12                116
#define IDD_CHECK_13                117
#define IDD_CHECK_14                118
#define IDD_CHECK_15                119
#define IDD_CHECK_16                120
#define IDD_CHECK_17                121
#define IDD_CHECK_18                122
#define IDD_CHECK_19                123
#define IDD_CHECK_20                124
#define IDD_CHECK_21                125
#define IDD_CHECK_22                126
#define IDD_CHECK_23                127
#define IDD_CHECK_24                128
#define IDD_CHECK_25                129
#define IDD_CHECK_26                130
#define IDD_CHECK_27                131
#define IDD_CHECK_28                132
#define IDD_CHECK_29                133
#define IDD_CHECK_30                134
#define IDD_CHECK_31                135
#define IDD_APPLY                   137
#define IDD_TOTAL_WRITTEN_TEXT      136
#define IDD_TOTAL_OUTPUT            138
#define IDD_MODULE_TEXT             139
#define IDD_MODULE_OUTPUT           140
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\dbgtool\dbgtool.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbgtool.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "dbgtool.h"
#include <stdlib.h>

HANDLE          hMapping;
PDebugHeader    pHeader;
ULONG_PTR       Xlate ;

#define TranslatePointer( x )   (PVOID) ( (x) ? ((PUCHAR) x + Xlate) : NULL )


PVOID
MapDebugMemory(DWORD    pid)
{
    WCHAR           szMapping[32];
    PDebugHeader    pHeader = NULL;
    PVOID           pvMap;
    DWORD           CommitSize;
    SYSTEM_INFO     SysInfo;
    SECURITY_DESCRIPTOR min ;

    GetSystemInfo(&SysInfo);

    swprintf(szMapping, TEXT("Debug.Memory.%x"), pid);

    hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                FALSE,
                                szMapping);

    if ( !hMapping && GetLastError() == ERROR_ACCESS_DENIED )
    {
        hMapping = OpenFileMapping( WRITE_DAC | READ_CONTROL,
                                    FALSE,
                                    szMapping );

        if ( hMapping )
        {
            InitializeSecurityDescriptor(&min, 1);
            SetSecurityDescriptorDacl(&min,FALSE,NULL,FALSE);
            SetKernelObjectSecurity(hMapping, DACL_SECURITY_INFORMATION, &min );

            CloseHandle( hMapping );


            hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                        FALSE,
                                        szMapping);

        }

    }

    if (hMapping)
    {
        pHeader = MapViewOfFileEx(  hMapping,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    0,
                                    NULL);

        if (pHeader && (pHeader != pHeader->pvSection))
        {
            //
            // Rats.  Remap at preferred address:
            //

            pvMap = pHeader->pvSection;
            UnmapViewOfFile(pHeader);
            pHeader = MapViewOfFileEx(  hMapping,
                                        FILE_MAP_READ | FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0,
                                        pvMap);
            if (pHeader)
            {
                CommitSize = pHeader->CommitRange;
            }
            else
            {
                //
                // Can't map at same address, unfortunately.  Set up the translation:
                //

                pHeader = MapViewOfFileEx(  hMapping,
                                            FILE_MAP_READ | FILE_MAP_WRITE,
                                            0,
                                            0,
                                            0,
                                            NULL );

                if ( pHeader )
                {
                    Xlate = (ULONG_PTR) ((PUCHAR) pHeader - (PUCHAR) pHeader->pvSection );
                }
            }
        }
        else
        {


        }
    }
    return(pHeader);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpFindModule
//
//  Synopsis:   Locates a module based on a name
//
//  Arguments:  [pHeader] -- Header to search
//              [pszName] -- module to find
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDebugModule
DbgFindModule(
    PDebugHeader    pHeader,
    CHAR *          pszName)
{
    PDebugModule    pSearch;

    pSearch = TranslatePointer( pHeader->pModules);
    while ( pSearch )
    {
        if (_stricmp( TranslatePointer( pSearch->pModuleName ), pszName) == 0)
        {
            return(pSearch);
        }
        pSearch = TranslatePointer( pSearch->pNext );
    }

    return(NULL);
}

RenameKeys(
    HWND            hDlg,
    PDebugModule    pModule)
{
    int i;
    DWORD   f;


    for (i = 0, f = 1; i < 32 ; i++, f <<= 1 )
    {
        if (pModule->TagLevels[i])
        {
            SetDlgItemTextA(hDlg, i + IDD_CHECK_0, TranslatePointer( pModule->TagLevels[i] ) );
        }
        else
        {
            SetDlgItemTextA(hDlg, i + IDD_CHECK_0, "");
        }

        CheckDlgButton(hDlg, i + IDD_CHECK_0, (pModule->InfoLevel & f) ? 1 : 0);
    }

    return(0);
}

InitDialog(
    HWND        hDlg)
{
    PDebugModule    pSearch;
    LRESULT         index;
    HWND            hLB;
    CHAR            szText[MAX_PATH] = {0}; 
    CHAR            szTitle[MAX_PATH] = {0};

    //
    // Load Listbox:
    //

    hLB = GetDlgItem(hDlg, IDD_DEBUG_LB);
    pSearch = TranslatePointer( pHeader->pModules );
    while (pSearch)
    {
        index = SendMessageA(
                        hLB,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) TranslatePointer( pSearch->pModuleName ) );

        SendMessage(
            hLB,
            LB_SETITEMDATA,
            index,
            (LPARAM) pSearch );

        pSearch = TranslatePointer( pSearch->pNext );
    }

    SetFocus(hLB);

    SendMessage(hLB, LB_SETSEL, 1, 0);

    ShowWindow(GetDlgItem(hDlg, IDD_MODULE_TEXT), SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDD_MODULE_OUTPUT), SW_HIDE);

    if (pHeader->pszExeName)
    {
        GetWindowTextA(hDlg, szText, RTL_NUMBER_OF(szText) - 1);
        _snprintf( szTitle, RTL_NUMBER_OF(szTitle) - 1, "%s : %s", szText, TranslatePointer( pHeader->pszExeName ) );
        SetWindowTextA(hDlg, szTitle);
    }

    return(TRUE);
}

int
ListBoxNotify(
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    LRESULT i;
    PDebugModule    pModule;
    char    Total[16];

    if (HIWORD(wParam) == LBN_SELCHANGE)
    {
        if (!GetWindowLongPtr(hDlg, GWLP_USERDATA))
        {
            ShowWindow(GetDlgItem(hDlg, IDD_MODULE_TEXT), SW_NORMAL);
            ShowWindow(GetDlgItem(hDlg, IDD_MODULE_OUTPUT), SW_NORMAL);
        }

        i = SendMessage(GetDlgItem(hDlg, IDD_DEBUG_LB), LB_GETCURSEL, 0, 0);

        pModule = (PDebugModule) SendMessage(GetDlgItem(hDlg, IDD_DEBUG_LB),
                                        LB_GETITEMDATA, (WPARAM) i, 0);

        RenameKeys(hDlg, pModule);

        sprintf(Total, "%d bytes", pModule->TotalOutput);
        SetDlgItemTextA(hDlg, IDD_MODULE_OUTPUT, Total);

        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM) pModule);

    }

    return(TRUE);

}


HandleCheck(
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int bit;
    PDebugModule pModule;

    pModule = (PDebugModule) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    bit = 1 << (LOWORD(wParam) - IDD_CHECK_0);

    if (IsDlgButtonChecked(hDlg, LOWORD(wParam)))
    {
        pModule->InfoLevel |= bit;
    }
    else
    {
        pModule->InfoLevel&= ~(bit);
    }

    pModule->fModule |= DEBUGMOD_CHANGE_INFOLEVEL;

    return(0);
}


LRESULT
CALLBACK
DialogProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    char    Total[16];


    switch (Message)
    {
        case WM_INITDIALOG:
            return(InitDialog(hDlg));

        case WM_COMMAND:
            sprintf(Total, "%d bytes", pHeader->TotalWritten);
            SetDlgItemTextA(hDlg, IDD_TOTAL_OUTPUT, Total);
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, IDOK);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return(TRUE);

                case IDD_DEBUG_LB:
                    return(ListBoxNotify(hDlg, wParam, lParam));
            }

            if ((LOWORD(wParam) >= IDD_CHECK_0) &&
                (LOWORD(wParam) <= IDD_CHECK_31))
            {
                HandleCheck(hDlg, wParam, lParam);
            }
            return(TRUE);
    }
    return(FALSE);
}

int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons)
{
    WCHAR   szMessage[256];

    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                               // ignored
            (GetLastError()),                     // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    return(MessageBox(hWnd, szMessage, pszTitleBar, Buttons));

}

int WINAPI WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow)
{
    int pid;
    LRESULT Status ;

    pid = strtol(lpszCmdParam, NULL, 0);

    pHeader = MapDebugMemory(pid);

    if (!pHeader)
    {
        ErrorMessage(NULL, TEXT("Map Debug Memory"), MB_OK | MB_ICONSTOP);
        return(0);
    }

    Status = DialogBox(  hInstance,
                    MAKEINTRESOURCE(IDD_DEBUG_TOOL),
                    GetDesktopWindow(),
                    DialogProc);

    if ( Status < 0 )
    {
        ErrorMessage(NULL, TEXT("DialogBox"), MB_OK | MB_ICONSTOP);
    }

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\utest\cryptest.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        cryptest.cxx
//
// Contents:    test program to test encryption functions
//
//
// History:     07-Oct-1996     MikeSw          Created
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <security.h>
#include <cryptdll.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <kerbcomm.h>
#include <align.h>
#include "md5.h"
}


typedef enum _CRYPT_ACTIONS {
    HashPassword,
    EncryptData,
    ChecksumData,
    EnumTypes,
    NoAction
} CRYPT_ACTIONS;

VOID
DoMd5(
    PUCHAR Buffer,
    ULONG BufferLength
    )
{
    MD5_CTX Md5Context;
    MD5Init(&Md5Context);
    MD5Update(&Md5Context, Buffer, BufferLength);
    MD5Final(&Md5Context);
}

void _cdecl
main(int argc, char *argv[])
{
    NTSTATUS Status;
    UNICODE_STRING Password;
    UNICODE_STRING User;
    UNICODE_STRING Domain;
    UNICODE_STRING Salt;
    ULONG CryptType = 0;
    ULONG HashType = 0;
    ULONG SumType = 0;
    WCHAR PasswordBuffer[100];
    WCHAR UserBuffer[100];
    WCHAR DomainBuffer[100];
    KERB_ACCOUNT_TYPE AccountType = UserAccount;
    CRYPT_ACTIONS Command = NoAction;
    int Index;
    ULONG uI;
    KERB_ENCRYPTION_KEY Key;
    KERBERR KerbErr;
    ULONG BlockSize;
    ULONG Overhead;
    ULONG BufferLength;
    ULONG ReqBufferLength;
    UCHAR OriginalBuffer[1000];
    PUCHAR EncryptedBuffer = NULL;
    PUCHAR DecryptedBuffer = NULL;
    PCRYPTO_SYSTEM Crypto;
    PCRYPT_STATE_BUFFER StateBuffer = NULL;






    Index = 1;
    while (Index < argc)
    {
        if (_stricmp(argv[Index],"-hash") == 0)
        {
            Command = HashPassword;
            if (argc < Index+1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&HashType);
        }
        else if (_stricmp(argv[Index],"-pass") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(PasswordBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &Password,
                PasswordBuffer
                );

        }
        else if (_stricmp(argv[Index],"-user") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(UserBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &User,
                UserBuffer
                );

        }
        else if (_stricmp(argv[Index],"-domain") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(DomainBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &Domain,
                DomainBuffer
                );

        }

        else if (_stricmp(argv[Index],"-type") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            if (_stricmp(argv[Index+1],"user") == 0)
            {
                AccountType = UserAccount;
            }
            else if (_stricmp(argv[Index+1],"machine") == 0)
            {
                AccountType = MachineAccount;
            }
            else if (_stricmp(argv[Index+1],"domain") == 0)
            {
                AccountType = DomainTrustAccount;
            }
            else
            {
                printf("Illegal account type: %s\n",argv[Index+1]);
                goto Cleanup;
            }

            Index++;
        }

        else if (_stricmp(argv[Index],"-crypt") == 0)
        {
            Command = EncryptData;
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&CryptType);
        }
        else if (_stricmp(argv[Index],"-sum") == 0)
        {
            Command = ChecksumData;
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&SumType);
        }
        else if (_stricmp(argv[Index],"-enum") == 0)
        {
            Command = EnumTypes;
        }
        else
        {
            goto Cleanup;
        }
        Index++;
    }
    if (Command == NoAction)
    {
        goto Cleanup;
    }

    switch(Command)
    {
    case EnumTypes:
        break;
    case HashPassword:
        KerbErr = KerbBuildKeySalt(
                    &Domain,
                    &User,
                    AccountType,
                    &Salt
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to build key salt: 0x%x\n",KerbErr);
            goto Cleanup;
        }
        printf("KeySalt = %wZ\n",&Salt);
        KerbErr = KerbHashPasswordEx(
                    &Password,
                    &Salt,
                    HashType,
                    &Key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash password: 0x%x\n",KerbErr);
            goto Exit;
        }
        printf("Hash: ");
        for (uI = 0; uI < Key.keyvalue.length ; uI++ )
        {
            printf("%0.2x ",Key.keyvalue.value[uI]);
        }
        printf("\n");
        break;
    case EncryptData:
        //
        // First hash the password
        //

        KerbErr= KerbHashPassword(
                    &Password,
                    CryptType,
                    &Key
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash password: %0x%x\n",KerbErr);
            goto Exit;
        }

        KerbErr = KerbGetEncryptionOverhead(
                    CryptType,
                    &Overhead,
                    &BlockSize
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get enc overhead: 0x%x\n",KerbErr);
            goto Exit;
        }

        BufferLength = sizeof(OriginalBuffer);

        memset(OriginalBuffer,'A',BufferLength);
#ifdef notdef
        KerbErr = KerbRandomFill(
                    OriginalBuffer,
                    BufferLength
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to init random buffer: 0x%x\n",KerbErr);
            goto Exit;
        }
#endif
        ReqBufferLength = ROUND_UP_COUNT(BufferLength + Overhead, BlockSize);
        EncryptedBuffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT, ReqBufferLength);
        if (EncryptedBuffer == NULL)
        {
            printf("Failed to allocate 0x%x bytes: %d\n",ReqBufferLength, GetLastError());
            goto Exit;
        }

        Status = CDLocateCSystem(
                    CryptType,
                    &Crypto
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to locate crypt system 0x%x: 0x%x\n",CryptType,Status);
            goto Exit;
        }

        Status = Crypto->Initialize(
                    Key.keyvalue.value,
                    (ULONG) Key.keyvalue.length,
                    0,          // no options
                    &StateBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("failed to initialize crypto system: 0x%x\n",Status);
            goto Exit;
        }

        Status = Crypto->Encrypt(
                    StateBuffer,
                    OriginalBuffer,
                    BufferLength,
                    EncryptedBuffer,
                    &ReqBufferLength
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to encrypt data: 0x%x\n",Status);
            goto Exit;
        }
        Status = Crypto->Discard(&StateBuffer);
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to discard state buffer: 0x%x\n",Status);
            goto Exit;
        }

        //
        // Now turn around and decrypt it.
        //


        DecryptedBuffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT, ReqBufferLength);
        if (EncryptedBuffer == NULL)
        {
            printf("Failed to allocate 0x%x bytes: %d\n",ReqBufferLength, GetLastError());
            goto Exit;
        }


        Status = Crypto->Initialize(
                    Key.keyvalue.value,
                    (ULONG) Key.keyvalue.length,
                    0,          // no options
                    &StateBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("failed to initialize crypto system: 0x%x\n",Status);
            goto Exit;
        }

        Status = Crypto->Decrypt(
                    StateBuffer,
                    EncryptedBuffer,
                    ReqBufferLength,
                    DecryptedBuffer,
                    &ReqBufferLength
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to decrypt data: 0x%x\n",Status);
            goto Exit;
        }
        Status = Crypto->Discard(&StateBuffer);
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to discard state buffer: 0x%x\n",Status);
            goto Exit;
        }

        //
        // Now compare
        //

        if (!RtlEqualMemory(
                OriginalBuffer,
                DecryptedBuffer,
                BufferLength
                ))
        {
            printf("Buffers don't match!\n");
        }
        else
        {
            printf("Encryption/decryption succeeded!\n");
        }

        break;
    case ChecksumData:

        BufferLength = sizeof(OriginalBuffer);

        memset(OriginalBuffer,'A',BufferLength);
        DoMd5(OriginalBuffer,BufferLength);

    }


Exit:
    return;

Cleanup:

    printf("Usage: %s { -crypt cryptalg -sum sumtype -hash cryptalg -enum } -pass password -user user -domain domain -type accounttype \n",
           argv[0]);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\assert.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       assert.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

typedef ULONG (NTAPI * DBGPROMPT)(PCH, PCH, ULONG);

#define DSYSASSERT_FAILED   0x00000001
#define DSYSASSERT_ERROR    0x00000002
#define DSYSASSERT_WARN     0x00000004

DWORD           __AssertInfoLevel = DSYSASSERT_FAILED;
DebugModule     __AssertModule = {NULL, &__AssertInfoLevel, 0, 7,
                                    NULL, 0, 0, "Assert",
                                    {"FAILED", "Error", "Warning", "",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pAssertModule = &__AssertModule;

VOID
__AssertDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pAssertModule, Mask, Format, ArgList);
}

BOOL
DbgpStartDebuggerOnMyself(BOOL UseKernelDebugger)
{
    WCHAR   cch[80];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HANDLE  hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!hEvent) 
    {
        return FALSE;
    }

    swprintf(cch, TEXT("ntsd %s -p %ld -e %ld -g"), (UseKernelDebugger ? "-d" : ""),
                        GetCurrentProcessId(), hEvent);
    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));

    StartupInfo.cb = sizeof(STARTUPINFO);
    
    if (!UseKernelDebugger)
    {
        StartupInfo.lpDesktop = TEXT("WinSta0\\Default");
    }

    if (CreateProcess(  NULL,
                        cch,
                        NULL,
                        NULL,
                        TRUE,
                        HIGH_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation) )
    {
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        WaitForSingleObject(hEvent, 60000);
        CloseHandle(hEvent);
        return(TRUE);
    }
    else
    {
        __AssertDebugOut( DSYSASSERT_ERROR, "Could not start debugger '%ws', %d\n", cch, GetLastError());
        return(FALSE);
    }
}


VOID
_DsysAssertEx(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message,
    ULONG ContinueCode
    )
{
    CHAR        Response[2];
    HMODULE     hNtDll;
    DBGPROMPT   DbgPromptFn;


    if (DbgpHeader)
    {
        __pAssertModule->pHeader = DbgpHeader;
        if (DbgpHeader->fDebug & DEBUG_DISABLE_ASRT)
        {
            __AssertDebugOut( DSYSASSERT_WARN, "Assertion at %s:%d disabled\n",
                            FileName, LineNumber);
            return;
        }
    }

    if (Message)
        __AssertDebugOut( DSYSASSERT_FAILED, "%s: %s (%s:%d)\n",
                    Message, FailedAssertion, FileName, LineNumber);
     else
        __AssertDebugOut( DSYSASSERT_FAILED, "%s (%s:%d)\n",
                    FailedAssertion, FileName, LineNumber);

    switch (ContinueCode)
    {

        case DSYSDBG_ASSERT_BREAK:
            __AssertDebugOut( DSYSASSERT_FAILED, "\tBreakpoint\n");
            DebugBreak();
            break;

        case DSYSDBG_ASSERT_CONTINUE:
            __AssertDebugOut( DSYSASSERT_WARN, "\tContinuing\n");
            return;

        case DSYSDBG_ASSERT_SUSPEND:
            __AssertDebugOut( DSYSASSERT_WARN, "\tSuspending Thread %d\n", GetCurrentThreadId());
            SuspendThread(GetCurrentThread());
            return;

        case DSYSDBG_ASSERT_KILL:
            __AssertDebugOut( DSYSASSERT_WARN, "\tKill Thread (exit %x)\n", NtCurrentTeb()->LastStatusValue);
            TerminateThread(GetCurrentThread(), NtCurrentTeb()->LastStatusValue);
            return;

        case DSYSDBG_ASSERT_DEBUGGER:
            if (IsDebuggerPresent())
            {
                DebugBreak();
            }
            else
            {
                if (DbgpHeader)
                {
                    if ((DbgpHeader->fDebug & DEBUG_PROMPTS) == 0)
                    {
                        DbgpStartDebuggerOnMyself(DbgpHeader->fDebug & DEBUG_USE_KDEBUG);
                        DebugBreak();
                        break;
                    }
                }

                hNtDll = LoadLibrary(TEXT("ntdll.dll"));
                if (hNtDll)
                {
                    DbgPromptFn = (DBGPROMPT) GetProcAddress(hNtDll, "DbgPrompt");
                }
                else
                {
                    DbgPromptFn = NULL;
                }

                while (TRUE)
                {

                    if (DbgPromptFn)
                    {
                        DbgPromptFn( "Start Debugger, Break, Ignore (dbi)?",
                                    Response, sizeof(Response));

                        switch (Response[0])
                        {
                            case 'i':
                            case 'I':
                                return;

                            case 'd':
                            case 'D':
                                DbgpStartDebuggerOnMyself(DbgpHeader ? (DbgpHeader->fDebug & DEBUG_USE_KDEBUG) : TRUE );

                            case 'b':
                            case 'B':
                                DebugBreak();
                                return;
                        }
                    }
                    else
                    {
                        DbgpStartDebuggerOnMyself(TRUE);
                        DebugBreak();
                        return;
                    }
                }


            }
            break;

        default:
            __AssertDebugOut( DSYSASSERT_ERROR, "Unknown continue code for assert: %d\n",
                        ContinueCode);
            return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\compat.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       compat.c
//
//  Contents:   Compatibility routines for old callers
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"
#include <debnot.h>

DWORD           __CompatInfoLevel = 3;
DebugModule     __CompatGlobal = {NULL, NULL, 0, 0, &__CompatHeader};
DebugHeader     __CompatHeader = {DEBUG_TAG, NULL, INVALID_HANDLE_VALUE,
                                    INVALID_HANDLE_VALUE, 0, &__CompatGlobal};
DebugModule     __CompatModule = {NULL, &__CompatInfoLevel, 0, 3,
                                    &__CompatHeader, 0, 0, "Compat",
                                    {"Error", "Warning", "Trace", "",
                                     "IError", "IWarning", "ITrace", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };
DebugModule *   __pCompatModule = &__CompatModule;


void
vdprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list  ArgList)
{
    __CompatModule.pModuleName = (char *) pszComp;
    if (DbgpHeader)
    {
        __CompatModule.pHeader = DbgpHeader;
    }
    _DebugOut(__pCompatModule, ulCompMask, (char *) ppszfmt, ArgList);
}


void
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    CHAR    szDebug[MAX_PATH];

    szDebug[RTL_NUMBER_OF(szDebug) - 1] = '\0';

    if (szMessage)
    {
        _snprintf(szDebug, RTL_NUMBER_OF(szDebug) - 1, "%d.%d> ASSERTION FAILED: %s, %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szMessage, szFile, iLine);
    }
    else
    {
        _snprintf(szDebug, RTL_NUMBER_OF(szDebug) - 1, "%d.%d> ASSERTION FAILED %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szFile, iLine);
    }

    OutputDebugStringA(szDebug);

    DebugBreak();

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{

    return(ulNewLevel);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    return(ulNewMask);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

typedef unsigned long (APINOT * SetWin4AssertLevelFn)( unsigned long ulNewLevel );

unsigned long
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    SetWin4AssertLevelFn OleSetWin4AssertLevel;
    HMODULE Module;

    Module = GetModuleHandle(L"ole32.dll");


    if (Module != NULL)
    {
        OleSetWin4AssertLevel = (SetWin4AssertLevelFn) GetProcAddress(Module, "SetWin4AssertLevel");
        if (OleSetWin4AssertLevel != NULL)
        {
            OleSetWin4AssertLevel(ulNewLevel);
        }
    }

    return(ulNewLevel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\dbgtool\dbgtool.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbgtool.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include <debugp.h>
#include "dialogs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\dbglibp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbglibp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-01-95   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Common defines for the debug library
//

extern  PDebugHeader        DbgpHeader;
extern  DebugModule         __CompatModule;
extern  DebugHeader         __CompatHeader;

extern  DebugModule *       __pCompatModule;
extern  DebugModule *       __pExceptionModule;
extern  DebugModule *       __pAssertModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\cryptdll\utest\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved


#define UINT4   unsigned long
#define ULONG	unsigned long


#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static const unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (z ^ (x & (y^z)))	/* optimized version of (((x) & (y)) | ((~x) & (z))) */
#define G(x, y, z) (y ^ (z & (x^y)))	/* optimized version of (((x) & (z)) | ((y) & (~z))) */
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) _rotl((x), (n))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
const unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\debuglib.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debuglib.h
//
//  Contents:   DebugLib includes
//
//  Classes:
//
//  Functions:
//
//  History:    3-28-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <stdio.h>

#include <dsysdbg.h>

#include <debugp.h>

#include "dbglibp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\except.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       except.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-19-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

#define DEB_TRACE           0x00000004
#define DSYS_EXCEPT_BREAK   0x00000008

DWORD           __ExceptionsInfoLevel = 0x1;
DebugModule     __ExceptionsModule = {NULL, &__ExceptionsInfoLevel, 0, 7,
                                    NULL, 0, 0, "Exceptions",
                                    {"Error", "Warning", "Trace", "Break",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pExceptionModule = &__ExceptionsModule;

#define DebugOut(x) __ExceptionsDebugOut x

typedef struct _ExName {
    LONG    ExceptionCode;
    PSTR    Name;
} ExName, * PExName;

ExName  __ExceptNames[] = { {EXCEPTION_ACCESS_VIOLATION,    "Access Violation"},
                            {EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "Bounds Exceeded"},
                            {EXCEPTION_BREAKPOINT,          "Break Point"},
                            {EXCEPTION_DATATYPE_MISALIGNMENT, "Alignment (Data)"},
                            {EXCEPTION_FLT_DENORMAL_OPERAND, "(Float) Denormal Operand"},
                            {EXCEPTION_FLT_DIVIDE_BY_ZERO,  "(Float) Divide By Zero"},
                            {EXCEPTION_FLT_INEXACT_RESULT,  "(Float) Inexact Result"},
                            {EXCEPTION_FLT_INVALID_OPERATION, "(Float) Invalid Op"},
                            {EXCEPTION_FLT_OVERFLOW, "(Float) Overflow"},
                            {EXCEPTION_FLT_STACK_CHECK, "(Float) Stack Check"},
                            {EXCEPTION_FLT_UNDERFLOW, "(Float) Underflow"},
                            {EXCEPTION_ILLEGAL_INSTRUCTION, "Illegal Instruction"},
                            {EXCEPTION_IN_PAGE_ERROR, "In Page Error"},
                            {EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide By Zero"},
                            {EXCEPTION_INT_OVERFLOW, "Overflow"},
                            {EXCEPTION_INVALID_DISPOSITION, "Illegal Disposition"},
                            {EXCEPTION_NONCONTINUABLE_EXCEPTION, "Can't Continue"},
                            {EXCEPTION_PRIV_INSTRUCTION, "Privileged Instruction"},
                            {EXCEPTION_SINGLE_STEP, "Single Step"},
                            {EXCEPTION_STACK_OVERFLOW, "Stack OverFlow"},
                            {0xC0000194, "Deadlock"},

                           };

VOID
__ExceptionsDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pExceptionModule, Mask, Format, ArgList);
}

BOOL
DbgpDumpExceptionRecord(
    PEXCEPTION_RECORD   pExceptRecord)
{
    PSTR    pszExcept;
    BOOL    StopOnException;
    DWORD   i;
    ULONG   InfoLevel = NT_SUCCESS(pExceptRecord->ExceptionCode) ? DEB_TRACE : DEB_ERROR;

    StopOnException = FALSE;
    pszExcept = NULL;
    for (i = 0; i < sizeof(__ExceptNames) / sizeof(ExName) ; i++ )
    {
        if (pExceptRecord->ExceptionCode == __ExceptNames[i].ExceptionCode)
        {
            pszExcept = __ExceptNames[i].Name;
            break;
        }
    }

    if (pszExcept)
    {
        DebugOut((InfoLevel, "Exception %#x (%s)\n",
                        pExceptRecord->ExceptionCode, pszExcept));
    }
    else
        DebugOut((InfoLevel, "Exception %#x\n", pExceptRecord->ExceptionCode));

    DebugOut((InfoLevel, "   %s\n",
                pExceptRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE ?
                "Non-Continuable" : "Continuable"));
    DebugOut((InfoLevel, "   Address    %#x\n", pExceptRecord->ExceptionAddress));
    switch (pExceptRecord->ExceptionCode)
    {
        case EXCEPTION_ACCESS_VIOLATION:
        case EXCEPTION_DATATYPE_MISALIGNMENT:
            DebugOut((InfoLevel, "   %s at address %#x\n",
                pExceptRecord->ExceptionInformation[0] ? "Write" : "Read",
                pExceptRecord->ExceptionInformation[1] ));
            StopOnException = TRUE;
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            DebugOut((InfoLevel, "  Resource at %#x\n",
                pExceptRecord->ExceptionInformation[0] ));
            StopOnException = TRUE;
            break;

        default:
            // StopOnException = TRUE;
            DebugOut((InfoLevel, "  %d Parameters\n", pExceptRecord->NumberParameters));
            for (i = 0; i < pExceptRecord->NumberParameters ; i++ )
            {
                DebugOut((InfoLevel, "    [%d] %#x\n", i,
                    pExceptRecord->ExceptionInformation[i] ));
            }
            break;
    }

    return(StopOnException);
}

VOID
DbgpDumpContextRecord(
    PCONTEXT    pContext,
    BOOL        StopOnException)
{
    ULONG InfoLevel = StopOnException ? DEB_ERROR : DEB_TRACE;
#ifdef _MIPS_
    DebugOut((InfoLevel, "MIPS Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "at=%08x v0=%08x v1=%08x a0=%08x\n",
            pContext->IntAt, pContext->IntV0, pContext->IntV1, pContext->IntA0));
        DebugOut((InfoLevel, "a1=%08x a2=%08x a3=%08x t0=%08x\n",
            pContext->IntA1, pContext->IntA2, pContext->IntA3, pContext->IntT0));
        DebugOut((InfoLevel, "t1=%08x t2=%08x t3=%08x t4=%08x\n",
            pContext->IntT1, pContext->IntT2, pContext->IntT3, pContext->IntT4));
        DebugOut((InfoLevel, "t5=%08x t6=%08x t7=%08x s0=%08x\n",
            pContext->IntT5, pContext->IntT6, pContext->IntT7, pContext->IntS0));
        DebugOut((InfoLevel, "s1=%08x s2=%08x s3=%08x s4=%08x\n",
            pContext->IntS1, pContext->IntS2, pContext->IntS3, pContext->IntS4));
        DebugOut((InfoLevel, "s5=%08x s6=%08x s7=%08x t8=%08x\n",
            pContext->IntS5, pContext->IntS6, pContext->IntS7, pContext->IntT8));
        DebugOut((InfoLevel, "t9=%08x s8=%08x hi=%08x lo=%08x\n",
            pContext->IntT9, pContext->IntS8, pContext->IntLo, pContext->IntHi));
        DebugOut((InfoLevel, "k0=%08x k1=%08x gp=%08x sp=%08x\n",
            pContext->IntK0, pContext->IntK1, pContext->IntGp, pContext->IntSp));
        DebugOut((InfoLevel, "ra=%08x\n",
            pContext->IntRa));

    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "Fir=%08x Psr=%08x\n", pContext->Fir,
            pContext->Psr));
    }

#elif _X86_
    DebugOut((InfoLevel, "x86 Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_DEBUG_REGISTERS)
    {
        DebugOut((InfoLevel, "Dr0=%08x Dr1=%08x Dr2=%08x Dr3=%08x \n",
                    pContext->Dr0, pContext->Dr1, pContext->Dr2, pContext->Dr3));
        DebugOut((InfoLevel, "Dr6=%08x Dr7=%08x\n",
                    pContext->Dr6, pContext->Dr7));
    }
    if (pContext->ContextFlags & CONTEXT_SEGMENTS)
    {
        DebugOut((InfoLevel, "gs=%08x fs=%08x es=%08x ds=%08x\n",
                    pContext->SegGs, pContext->SegFs, pContext->SegEs,
                    pContext->SegDs));
    }
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "edi=%08x esi=%08x ebx=%08x\n",
                pContext->Edi, pContext->Esi, pContext->Ebx));
        DebugOut((InfoLevel, "edx=%08x ecx=%08x eax=%08x\n",
                pContext->Edx, pContext->Ecx, pContext->Eax));
    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "ebp=%08x eip=%08x cs=%08x\n",
                pContext->Ebp, pContext->Eip, pContext->SegCs));
        DebugOut((InfoLevel, "flags=%08x esp=%08x ss=%08x\n",
                pContext->EFlags, pContext->Esp, pContext->SegSs));
    }

#elif _ALPHA_
    DebugOut((InfoLevel, "ALPHA Context Record at %x\n", pContext));

#elif _PPC_
    DebugOut((InfoLevel, "PPC Context Record at %x\n", pContext));

#else
    DebugOut((InfoLevel, "Unknown Context Record, %x\n", pContext));

#endif

}

VOID
DbgpDumpException(
    PEXCEPTION_POINTERS pExceptInfo)
{
    BOOL StopOnException;

    StopOnException = DbgpDumpExceptionRecord(pExceptInfo->ExceptionRecord);
    DbgpDumpContextRecord( pExceptInfo->ContextRecord, StopOnException );

    if (StopOnException &&
        ((__ExceptionsInfoLevel & DSYS_EXCEPT_BREAK) != 0))
    {
        DsysAssertMsgEx(FALSE, "Skip Exceptions", DSYSDBG_ASSERT_DEBUGGER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\test.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       test.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <stdio.h>

#include <dsysdbg.h>

#include "debugp.h"

DECLARE_DEBUG2(Test);
DECLARE_DEBUG2(Test2);

DEFINE_DEBUG2(Test);
DEFINE_DEBUG2(Test2);

PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize);

VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory);


DEBUG_KEY   MyKeys[] = { {  1, "Error" },
                         {  2, "Warning" },
                         {  4, "Trace" },
                         {  8, "Yikes" },
                         {  0, NULL }
                       };

int
ExceptionFilter(
    LPEXCEPTION_POINTERS    p)
{
    DsysException(p);
    return(EXCEPTION_EXECUTE_HANDLER);
}

__cdecl main (int argc, char *argv[])
{
    char wait[40];
    PUCHAR  p;
    CHAR c;
    DWORD ChunkSize = 1024 ;
    PUCHAR Mem[ 16 ];
    ULONG i ;
    PDebugModule Alloc ;


    TestInitDebug(MyKeys);

    p = NULL;

    TestDebugPrint(1, "This is an error %d\n", 10);
    TestDebugPrint(2, "This is a warning!\n");

    Test2InitDebug(MyKeys);

    Test2DebugPrint(4, "Should be a trace\n");

    printf("Waiting...");
    gets(wait);

    try
    {
        c = *p;
    }
    except (ExceptionFilter(GetExceptionInformation()))
    {
        TestDebugPrint(1, "That AV'd\n");
    }

    DsysAssert(p);

    printf("Waiting...");
    gets(wait);

    Test2DebugPrint(8, "This is a yikes!\n");

    DsysAssertMsg(argc == 1, "Test Assertion");

    Test2DebugPrint(4, "yada yada\n");

    //
    // Load and unload:
    //

    Test2UnloadDebug();
    TestUnloadDebug();

    Test2InitDebug( MyKeys );
    Test2DebugPrint( 1, "Reload test2\n");
    TestInitDebug( MyKeys );
    TestDebugPrint( 1, "Reload test\n");

    Test2UnloadDebug();
    TestUnloadDebug();
    Test2DebugPrint(1, "Safe test\n" );
    Test2InitDebug( MyKeys );
    Test2DebugPrint(1, "Prints now\n" );


    //
    // Allocation tests:
    //

    Alloc = (PDebugModule) Test2ControlBlock ;

    for ( i = 0 ; i < 16 ; i++ )
    {
        Mem[ i ] = DbgpAlloc( Alloc->pHeader, ChunkSize );

    }

    for ( i = 0 ; i < 16 ; i++ )
    {
        DbgpFree( Alloc->pHeader, Mem[ i ] );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

PDebugHeader        DbgpHeader = NULL;

DebugModule * *     DbgpFixupModules[] = {  &__pAssertModule,
                                            &__pExceptionModule,
                                            NULL };

CHAR                szDebugSection[] = "DSysDebug";
CHAR                szDebugFlags[] = "DebugFlags";

DEBUG_KEY           DbgpKeys[] = { {DEBUG_NO_DEBUGIO,   "NoDebugger"},
                                   {DEBUG_TIMESTAMP,    "TimeStamp"},
                                   {DEBUG_DEBUGGER_OK,  "DebuggerOk"},
                                   {DEBUG_LOGFILE,      "Logfile"},
                                   {DEBUG_AUTO_DEBUG,   "AutoDebug"},
                                   {DEBUG_USE_KDEBUG,   "UseKD"},
                                   {DEBUG_HEAP_CHECK,   "HeapCheck"},
                                   {DEBUG_MULTI_THREAD, "MultiThread"},
                                   {DEBUG_DISABLE_ASRT, "DisableAssert"},
                                   {DEBUG_PROMPTS,      "AssertPrompts"},
                                   {DEBUG_BREAK_ON_ERROR,"BreakOnError"},
                                   {0,                  NULL }
                                 };

#define DEBUG_NUMBER_OF_KEYS    ((sizeof(DbgpKeys) / sizeof(DEBUG_KEY)) - 1)

#define _ALIGN(x,a) ((x) & ((a)-1) ? ((x) + (a)) & ~((a) - 1) : (x));

#define ALIGN_8(x)  _ALIGN(x, 8)
#define ALIGN_16(x) _ALIGN(x, 16)

#ifdef WIN64
#define DBG_ALIGN   ALIGN_16
#else
#define DBG_ALIGN   ALIGN_8
#endif

#define DEBUGMEM_ALLOCATED  0x00000001

typedef struct _DebugMemory {
    struct _DebugMemory *   pNext;
    DWORD                   Size;
    DWORD                   Flags;
} DebugMemory, * PDebugMemory;


#ifdef DEBUG_DEBUG
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug)); OutputDebugStringA("Lock")
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug)); OutputDebugStringA("Unlock")
#else
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug))
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug))
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DbgpComputeMappingName
//
//  Synopsis:   Computes the mapping object name
//
//  Arguments:  [pszName] -- place to stick the name (no more than 32 wchars)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
DbgpComputeMappingName(
    IN PWSTR   pszName,
    IN SIZE_T  NameLen
    )
{
    _snwprintf(pszName, NameLen, TEXT("Debug.Memory.%x"), GetCurrentProcessId());
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeMM
//
//  Synopsis:   Initializes our simple memory manager within the shared mem
//              section.
//
//  Arguments:  [pHeader] -- Header to initialize
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeMM(PDebugHeader   pHeader)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) (pHeader + 1);
    pMem->pNext = NULL;
    pMem->Size = pHeader->CommitRange - (sizeof(DebugHeader) + sizeof(DebugMemory));
    pHeader->pFreeList = pMem;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpAlloc
//
//  Synopsis:   Very, very simple allocator
//
//  Arguments:  [pHeader] -- Header from which to allocate
//              [cSize]   -- size to allocate
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize)
{
    PDebugMemory    pSearch;
    PDebugMemory    pLargest = NULL;
    PDebugMemory    pNew;
    DWORD           cLargest;

    cLargest = 0;
    cSize = DBG_ALIGN(cSize);

    //
    // Very, very simple allocator.  Search free list for an exact match,
    //

    pSearch = (PDebugMemory) pHeader->pFreeList;
    while (pSearch)
    {
        if ( ( pSearch->Flags & DEBUGMEM_ALLOCATED ) == 0 )
        {
            if ( pSearch->Size == cSize )
            {
                break;
            }

            if (pSearch->Size > cLargest)
            {
                pLargest = pSearch;
                cLargest = pSearch->Size;
            }
        }

        pSearch = pSearch->pNext;
    }

    //
    // If no match yet
    //

    if (!pSearch)
    {
        //
        // If the largest free block is still too small,
        //

        if (cLargest < (cSize + sizeof(DebugMemory) * 2))
        {
            //
            // Extend the mapped range
            //
            if (pHeader->CommitRange < pHeader->ReserveRange)
            {
                if ( VirtualAlloc(
                            (PUCHAR) pHeader + pHeader->CommitRange,
                            pHeader->PageSize,
                            MEM_COMMIT,
                            PAGE_READWRITE ) )
                {
                    pNew = (PDebugMemory) ((PUCHAR) pHeader + pHeader->CommitRange );
                    pHeader->CommitRange += pHeader->PageSize ;
                    pNew->Size = pHeader->PageSize - sizeof( DebugMemory );
                    pNew->pNext = pHeader->pFreeList ;
                    pHeader->pFreeList = pNew ;

                    return DbgpAlloc( pHeader, cSize );
                }
                else
                {
                    return NULL ;
                }
            }

            return(NULL);
        }

        //
        // Otherwise, split the largest block into something better...
        //

        pNew = (PDebugMemory) ((PUCHAR) pLargest + (cSize + sizeof(DebugMemory)) );

        pNew->Size = pLargest->Size - (cSize + sizeof(DebugMemory) * 2);
        pNew->pNext = pLargest->pNext ;
        pNew->Flags = 0;

        pLargest->Size = cSize;
        pLargest->Flags |= DEBUGMEM_ALLOCATED;
        pLargest->pNext = pNew;

        return((PVOID) (pLargest + 1) );
    }
    else
    {
        pSearch->Flags |= DEBUGMEM_ALLOCATED ;

        return((PVOID) (pSearch + 1) );
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFree
//
//  Synopsis:   Returns memory to the shared mem segment
//
//  Arguments:  [pHeader] -- Shared memory header
//              [pMemory] -- Memory to free
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:      No compaction.
//
//----------------------------------------------------------------------------
VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) ((PUCHAR) pMemory - sizeof(DebugMemory));
    pMem->Flags &= ~DEBUGMEM_ALLOCATED;
    ZeroMemory( pMemory, pMem->Size );
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFindModule
//
//  Synopsis:   Locates a module based on a name
//
//  Arguments:  [pHeader] -- Header to search
//              [pszName] -- module to find
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDebugModule
DbgpFindModule(
    PDebugHeader    pHeader,
    CHAR *          pszName)
{
    PDebugModule    pSearch;

    pSearch = pHeader->pModules;
    while (pSearch)
    {
        if (_strcmpi(pSearch->pModuleName, pszName) == 0)
        {
            return(pSearch);
        }
        pSearch = pSearch->pNext;
    }

    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpCopyModule
//
//  Synopsis:   Copies a module into a new module.  Used for the builtins.
//              note, no references to the code module that the builtin lived
//              in is kept.  This way, the module can unload.
//
//  Arguments:  [pHeader] --
//              [pSource] --
//              [ppDest]  --
//
//  Requires:   Header must be locked.
//
//  Returns:    0 for failure, non-zero for success
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpCopyModule(
    PDebugHeader    pHeader,
    PDebugModule    pSource,
    PDebugModule *  ppDest)
{
    PDebugModule    pModule;
    DWORD           i;
    DWORD           cStringSpace;
    PCHAR           pStrings;

    *ppDest = NULL;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            cStringSpace += (strlen(pSource->TagLevels[i]) + 1);
        }
    }

    //
    // Allocate an extra DWORD to store the infolevel.
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule) + sizeof( DWORD ) );
    if (!pModule)
    {
        return(0);
    }

    pStrings = DbgpAlloc(pHeader, cStringSpace);

    if ( !pStrings )
    {
        DbgpFree( pHeader, pModule );

        return 0 ;
    }

    pModule->pModuleName = pStrings;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    strcpy(pModule->pModuleName, pSource->pModuleName);

    pStrings += cStringSpace;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            pModule->TagLevels[i] = pStrings;
            cStringSpace = strlen(pSource->TagLevels[i]) + 1;
            strcpy(pStrings, pSource->TagLevels[i]);
            pStrings += cStringSpace;
        }
        else
        {
            pSource->TagLevels[i] = NULL;
        }
    }

    //
    // Add this in to the global list
    //
    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;

    //
    // Do not increment module count - this is a builtin
    //

    //
    // Copy the rest of the interesting stuff
    //
    pModule->pInfoLevel = (PDWORD) (pModule + 1);
    *pModule->pInfoLevel = *pSource->pInfoLevel;

    pModule->InfoLevel = pSource->InfoLevel;
    pModule->fModule = pSource->fModule | DEBUGMOD_BUILTIN_MODULE ;
    pModule->pHeader = pHeader;
    pModule->TotalOutput = pSource->TotalOutput;
    pModule->Reserved = 0;

    *ppDest = pModule;

    return(1);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpAttachBuiltinModules
//
//  Synopsis:   Attaches the builtin library modules to the global shared
//              list
//
//  Arguments:  [pHeader] --
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpAttachBuiltinModules(
    PDebugHeader    pHeader)
{
    PDebugModule    pModule;
    PDebugModule    pFixup;
    DWORD           i;
    BOOL            Success = FALSE;

    i = 0;
    while (DbgpFixupModules[i])
    {
        pFixup = *DbgpFixupModules[i];

        pModule = DbgpFindModule(pHeader, pFixup->pModuleName);
        if (pModule)
        {
            *DbgpFixupModules[i] = pModule;
            Success = TRUE;
        }
        else
        {
            if (DbgpCopyModule(pHeader, pFixup, &pModule))
            {
                *DbgpFixupModules[i] = pModule;
                Success = TRUE;
            }
        }

        i++;
    }

    return(Success);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpBuildModule
//
//  Synopsis:   Initializes a Module, builds the string table
//
//  Arguments:  [pModule]    -- Module pointer
//              [pHeader]    -- Header
//              [pKeys]      -- Key table
//              [pszName]    -- Name
//              [pInfoLevel] -- Pointer to info level
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpBuildModule(
    PDebugModule    pModule,
    PDebugHeader    pHeader,
    PDEBUG_KEY      pKeys,
    PCHAR           pszName,
    PDWORD          pInfoLevel)
{
    PCHAR           pStringData;
    DWORD           cStringData;
    DWORD           cKeys;
    DWORD           i;
    DWORD           KeyIndex;
    DWORD           BitScan;

    //
    // Easy stuff to start..
    //

    pModule->pInfoLevel = pInfoLevel;
    pModule->pHeader = pHeader;

    cStringData = strlen(pszName) + 1;

    //
    // Search through the list of masks and string tags, computing
    // the size needed for containing them all.  If a tag has more
    // than one bit set, reject it.
    //
    for (i = 0; i < 32 ; i++ )
    {
        if (pKeys[i].Mask)
        {
            if (pKeys[i].Mask & (pKeys[i].Mask - 1))
            {
                continue;
            }
        }
        if (pKeys[i].Tag)
        {
            cStringData += strlen(pKeys[i].Tag) + 1;
        }
        else
        {
            break;
        }
    }

    //
    // We know how many keys there are, and how big a space they need.
    //
    cKeys = i;

    pStringData = DbgpAlloc(pHeader, cStringData);

    if ( !pStringData )
    {
        return 0 ;
    }

    pModule->pModuleName = pStringData;
    strcpy(pStringData, pszName);
    pStringData += strlen(pStringData) + 1;

    for (i = 0, KeyIndex = 0; i < cKeys ; i++ )
    {
        if (pKeys[i].Mask & (pKeys[i].Mask - 1))
        {
            continue;
        }

        if (!(pKeys[i].Mask & (1 << KeyIndex)))
        {
            //
            // Grr, out of order.  Do a bit-wise scan.
            //

            KeyIndex = 0;
            BitScan = 1;
            while ((pKeys[i].Mask & BitScan) == 0)
            {
                BitScan <<= 1;
                KeyIndex ++;
            }
        }

        pModule->TagLevels[KeyIndex] = pStringData;
        strcpy(pStringData, pKeys[i].Tag);
        pStringData += strlen(pKeys[i].Tag) + 1;

        KeyIndex++;
    }

    return(cKeys);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetBitmask
//
//  Synopsis:   Based on a parameter line and a key table, builds the bitmask
//
//  Arguments:  [pKeys]          --
//              [cKeys]          --
//              [pszLine]        --
//              [ParameterIndex] --
//              [ParameterValue] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpGetBitmask(
    DEBUG_KEY *     pKeys,
    DWORD           cKeys,
    PCHAR           pszLine,
    DWORD           ParameterIndex,
    PCHAR           ParameterValue)
{
    PCHAR   pszSearch;
    PCHAR   pszParam;
    PCHAR   pszScan;
    DWORD   i;
    DWORD   Mask;
    DWORD   cbParameter = 0;
    DWORD   Compare;
    CHAR    Saved;

    if (ParameterIndex < cKeys)
    {
        cbParameter = strlen(pKeys[ParameterIndex].Tag);
    }

    Mask = 0;

    pszSearch = pszLine;

    //
    // Scan through the line, searching for flags.  Note:  do NOT use strtok,
    // since that is not exported by ntdll, and we would not be able to make
    // security.dll
    //

    while (*pszSearch)
    {
        pszScan = pszSearch;
        while ((*pszScan) && (*pszScan != ','))
        {
            pszScan++;
        }
        Saved = *pszScan;
        *pszScan = '\0';

        for (i = 0; i < cKeys ; i++ )
        {
            if (i == ParameterIndex)
            {
                if (_strnicmp(pKeys[i].Tag, pszSearch, cbParameter) == 0)
                {
                    pszParam = strchr(pszSearch, ':');
                    if (pszParam)
                    {
                        strcpy(ParameterValue, pszParam + 1);
                    }
                    Mask |= pKeys[i].Mask;
                }
            }
            else
            {
                if (_strcmpi(pKeys[i].Tag, pszSearch) == 0)
                {
                    Mask |= pKeys[i].Mask;
                }

            }
        }

        *pszScan = Saved;
        if (Saved)
        {
            while ((*pszScan) && ((*pszScan == ',') || (*pszScan == ' ')))
            {
                pszScan++;
            }
        }
        pszSearch = pszScan;
    }

    return(Mask);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeDebug
//
//  Synopsis:   Initialize the base memory
//
//  Arguments:  [pHeader] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeDebug(
    PDebugHeader    pHeader)
{
    CHAR    szExeName[MAX_PATH] = {0};
    PCHAR   pszExeName;
    PCHAR   dot;
    DWORD   cbExeName;
    CHAR    LogFile[MAX_PATH + 4] = {0}; // add 4 for ".log"
    CHAR    Line[MAX_PATH] = {0};
    PDebugModule pModule;
    HANDLE Token;
    TOKEN_STATISTICS TokenStat;
    ULONG Size;
    LUID LocalSys = SYSTEM_LUID;

    //
    // Plug the debug section in first
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule));
    if (!pModule)
    {
        return;
    }

    DbgpBuildModule(pModule,
                    pHeader,
                    DbgpKeys,
                    DEBUG_MODULE_NAME,
                    &pHeader->fDebug);

    GetModuleFileNameA(NULL, szExeName, RTL_NUMBER_OF(szExeName) - 1);
    pszExeName = strrchr(szExeName, '\\');
    if (pszExeName)
    {
        pszExeName++;
    }
    else
    {
        pszExeName = szExeName;
    }

    dot = strrchr(pszExeName, '.');
    if (dot)
    {
        *dot = '\0';
    }

    cbExeName = (DWORD) (dot - pszExeName);
    pHeader->pszExeName = DbgpAlloc(pHeader, cbExeName + 1);
    if (pHeader->pszExeName)
    {
        strcpy(pHeader->pszExeName, pszExeName);
    }

    LogFile[0] = '\0';

    if (GetProfileStringA(  szDebugSection,
                            pszExeName,
                            "",
                            Line,
                            RTL_NUMBER_OF(Line) - 1))
    {
        pHeader->fDebug = DbgpGetBitmask(   DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    //
    // If running as local system, turn on the kd flag.  That
    // way,

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY,
                           &Token ) )
    {
        if ( GetTokenInformation( Token,
                                  TokenStatistics,
                                  &TokenStat,
                                  sizeof( TokenStat ),
                                  &Size ) )
        {
            if ( (TokenStat.AuthenticationId.LowPart == LocalSys.LowPart ) &&
                 (TokenStat.AuthenticationId.HighPart == LocalSys.HighPart ) )
            {
                pHeader->fDebug |= DEBUG_USE_KDEBUG ;
            }
        }

        CloseHandle( Token );
    }

    if (GetProfileStringA(  szDebugSection,
                            szDebugFlags,
                            "",
                            Line,
                            RTL_NUMBER_OF(Line) - 1))
    {
        pHeader->fDebug |= DbgpGetBitmask(  DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    if ( pHeader->fDebug & DEBUG_USE_KDEBUG )
    {
        //
        // Verify that there is a kernel debugger
        //

        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;
        NTSTATUS Status ;

        Status = NtQuerySystemInformation(
                    SystemKernelDebuggerInformation,
                    &KdInfo,
                    sizeof( KdInfo ),
                    NULL );

        if ( NT_SUCCESS( Status ) )
        {
            if ( !KdInfo.KernelDebuggerEnabled )
            {
                pHeader->fDebug &= ~(DEBUG_USE_KDEBUG) ;
            }
        }

    }

    if (pHeader->fDebug & DEBUG_LOGFILE)
    {
        if (LogFile[0] == '\0')
        {
            strcpy(LogFile, szExeName);
            strcat(LogFile, ".log");
        }
        pHeader->hLogFile = CreateFileA(LogFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, //&sa,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL |
                                        FILE_FLAG_WRITE_THROUGH,
                                        NULL);
    }

    pHeader->pModules = pModule;
    pHeader->pGlobalModule = pModule;
    pModule->pInfoLevel = &pHeader->fDebug;
    pModule->InfoLevel = pHeader->fDebug;

    DbgpAttachBuiltinModules(pHeader);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenLogFileRandom
//
//  Synopsis:   Opens the logfile dynamically
//
//  Arguments:  [pHeader] --
//
//  History:    4-27-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpOpenLogFileRandom(
    PDebugHeader        pHeader)
{
    WCHAR   szLogPath[MAX_PATH + 4] = {0}; // add 4 for ".log"
    DWORD   dwPath;
    PWSTR   pszDot;

    dwPath = GetModuleFileName(NULL, szLogPath, RTL_NUMBER_OF(szLogPath) - 4 - 1);

    pszDot = wcsrchr(szLogPath, L'.');
    if (!pszDot)
    {
        pszDot = &szLogPath[dwPath];
    }

    wcscpy(pszDot, L".log");

    LockDebugHeader(pHeader);

    pHeader->hLogFile = CreateFileW(szLogPath,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL, //&sa,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_WRITE_THROUGH,
                                    NULL);

    if (pHeader->hLogFile == INVALID_HANDLE_VALUE)
    {
        pHeader->fDebug &= ~(DEBUG_LOGFILE);
        UnlockDebugHeader(pHeader);
        return(FALSE);
    }

    UnlockDebugHeader(pHeader);
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   _DbgSetLoggingFile
//
//  Synopsis:   Sets the passed in file handle as the logging file handle.
//              This function should be called in combination with 
//              _DbgSetLoggingOption since this function actually enables/disables
//              file logging.  Note that if _DbgSetLoggingOption is called
//              with the On parameter as FALSE then the file handle will be
//              closed.
//
//  Arguments:  [pHeader] --
//              [hLogFile] --
//
//  History:    7-16-02   jeffspel   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_DbgSetLoggingFile(
    PVOID   pControl,
    HANDLE  hLogFile
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule)pControl;

    if ( pModule )
    {
        LockDebugHeader(pModule->pHeader);

        pModule->pHeader->hLogFile = hLogFile;

        UnlockDebugHeader(pModule->pHeader);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenOrCreateSharedMem
//
//  Synopsis:   Returns a pointer to the shared memory segment,
//              creating it if necessary.  Header is LOCKED on return
//
//  Arguments:  (none)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
DbgpOpenOrCreateSharedMem(DWORD Flags)
{
    HANDLE              hMapping;
    WCHAR               szMappingName[32] = {0};
    PDebugHeader        pHeader;
    SYSTEM_INFO         SysInfo;

    if (DbgpHeader)
    {
        LockDebugHeader(DbgpHeader);
        return(DbgpHeader);
    }

    GetSystemInfo(&SysInfo);

    DbgpComputeMappingName(szMappingName, RTL_NUMBER_OF( szMappingName ) - 1);
    hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                FALSE,
                                szMappingName);

    if (hMapping)
    {
        //
        // Ok, someone else has created the section.  So, we just need to map
        // it.
        //

        pHeader = MapViewOfFileEx(  hMapping,
                                    FILE_MAP_READ | FILE_MAP_WRITE,
                                    0,
                                    0,
                                    SysInfo.dwPageSize,
                                    NULL);

        if ( pHeader )
        {
            if (pHeader != pHeader->pvSection)
            {
                DbgpHeader = pHeader->pvSection;
            }
            else
            {
                DbgpHeader = pHeader;
            }

            UnmapViewOfFile(pHeader);
        }
        else
        {
            DbgpHeader = NULL ;
        }

        //
        // Now that we have the other guy's address, we can throw away this
        // one.
        //
        CloseHandle(hMapping);

        if ( DbgpHeader )
        {
            LockDebugHeader(DbgpHeader);

            DbgpAttachBuiltinModules(DbgpHeader);
        }

        return(DbgpHeader);
    }

    if (Flags & DSYSDBG_OPEN_ONLY)
    {
        return(NULL);
    }

    hMapping = CreateFileMapping(   INVALID_HANDLE_VALUE,
                                    NULL, //&sa,
                                    PAGE_READWRITE | SEC_RESERVE,
                                    0,
                                    SysInfo.dwAllocationGranularity,
                                    szMappingName);
    if (hMapping)
    {
        PDebugHeader pMappedHeader;

        pMappedHeader = MapViewOfFileEx(hMapping,
                                        FILE_MAP_READ | FILE_MAP_WRITE,
                                        0,
                                        0,
                                        SysInfo.dwAllocationGranularity,
                                        NULL);

        if (!pMappedHeader)
        {
            return NULL;
        }

        //
        // Commit the view, so we can initialize the header
        //

        pHeader = (PDebugHeader) VirtualAlloc(pMappedHeader,
                                              SysInfo.dwPageSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

        if (pHeader == NULL)
        {
            UnmapViewOfFile(pMappedHeader);
            return NULL;
        }

        pHeader->Tag = DEBUG_TAG;
        pHeader->pvSection = pHeader;
        pHeader->hMapping = hMapping;
        pHeader->hLogFile = INVALID_HANDLE_VALUE;
        pHeader->CommitRange = SysInfo.dwPageSize;
        pHeader->ReserveRange = SysInfo.dwAllocationGranularity;
        pHeader->PageSize = SysInfo.dwPageSize;
        pHeader->pModules = NULL;
        pHeader->pFreeList = NULL;
        pHeader->pBufferList = &pHeader->DefaultBuffer ;
        pHeader->DefaultBuffer.Next = NULL ;

        InitializeCriticalSection(&pHeader->csDebug);

        LockDebugHeader(pHeader);

        DbgpInitializeMM(pHeader);
        DbgpInitializeDebug(pHeader);

        DbgpHeader = pHeader;

        return(pHeader);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpLoadValidateRoutine
//
//  Synopsis:   Loads RtlValidateProcessHeaps() from ntdll
//
//  Arguments:  [pHeader] --
//
//  History:    5-02-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpLoadValidateRoutine(PDebugHeader    pHeader)
{
    HMODULE hNtDll;

    hNtDll = LoadLibrary(TEXT("ntdll.dll"));
    if (hNtDll)
    {
        pHeader->pfnValidate = (HEAPVALIDATE) GetProcAddress(hNtDll, "RtlValidateProcessHeaps");
        if (!pHeader->pfnValidate)
        {
            pHeader->fDebug &= ~(DEBUG_HEAP_CHECK);
        }

        //
        // We can safely free this handle, since kernel32 and advapi32 DLLs
        // both use ntdll, so the refcount won't go to zero.
        //
        FreeLibrary(hNtDll);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _InitDebug
//
//  Synopsis:   Workhorse of the initializers
//
//  Arguments:  [pInfoLevel]     -- Pointer to module specific infolevel
//              [ppControlBlock] -- Pointer to module specific control pointer
//              [szName]         -- Name
//              [pKeys]          -- Key data
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_InitDebug(
    DWORD       Flags,
    DWORD *     pInfoLevel,
    PVOID *     ppControlBlock,
    CHAR *      szName,
    PDEBUG_KEY  pKeys)
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    CHAR            Line[MAX_PATH] = {0};
    DWORD           cKeys;
    DWORD           i;

    if ( (*ppControlBlock) && (*ppControlBlock != INVALID_HANDLE_VALUE) )
    {
        //
        // Already Initialized
        //
        return ;
    }

    *ppControlBlock = NULL;

    //
    // Find the shared section.
    //

    pHeader = DbgpOpenOrCreateSharedMem(Flags);

    if (!pHeader)
    {
        if (Flags & DSYSDBG_DEMAND_OPEN)
        {
            *ppControlBlock = (PVOID) INVALID_HANDLE_VALUE;
        }
        return;
    }

    //
    // See if we have already registered (dll being loaded several times)
    // if not, allocate a new module.
    //

    pModule = DbgpFindModule(pHeader, szName);
    if (!pModule)
    {
        pModule = DbgpAlloc(pHeader, sizeof(DebugModule) );
        if (!pModule)
        {
            UnlockDebugHeader(pHeader);
            return;
        }
    }
    else
    {
        //
        // Found module already loaded.  Check to see that everything
        // lines up:
        //

        if ( pModule->pInfoLevel != pInfoLevel )
        {
            //
            // Uh oh, there's a module with our name already loaded,
            // but the pointers don't match.  So, let's create our
            // own now.
            //

            pModule = DbgpAlloc( pHeader, sizeof( DebugModule ) );

            if ( !pModule )
            {
                UnlockDebugHeader( pHeader );
                return;
            }
        }
        else
        {
            *ppControlBlock = pModule;
            UnlockDebugHeader(pHeader);
            return;
        }
    }

    //
    // Initialize module
    //

    cKeys = DbgpBuildModule(pModule,
                            pHeader,
                            pKeys,
                            szName,
                            pInfoLevel);

    //
    // Now, load up info levels from ini or registry
    // First, try a module specific entry.
    //

    if (GetProfileStringA(szName, szDebugFlags, "", Line, RTL_NUMBER_OF(Line) - 1))
    {
        pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                            cKeys,
                                            Line,
                                            0xFFFFFFFF,
                                            NULL );
    }

    if (pHeader->pszExeName)
    {
        if (GetProfileStringA(szName, pHeader->pszExeName, "", Line, RTL_NUMBER_OF(Line) - 1))
        {
            pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );

        }
    }

    //  HACK - Make Default DBG / DEBUG_SUPPORT dependent.  See dsysdbg.h
    if (GetProfileStringA(szDebugSection, szName, SZ_DEFAULT_PROFILE_STRING, Line, RTL_NUMBER_OF(Line) - 1))
    {
        pModule->InfoLevel |= DbgpGetBitmask(   pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );
    }

    *pModule->pInfoLevel = pModule->InfoLevel;

    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;
    pHeader->ModuleCount++ ;
    *ppControlBlock = pModule;

    UnlockDebugHeader(pHeader);
}

VOID
_UnloadDebug(
    PVOID pControlBlock
    )
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    PDebugModule    pScan ;
    BOOL FreeIt = FALSE ;

    pModule = (PDebugModule) pControlBlock ;

    if ( !pModule )
    {
        return ;
    }

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    pHeader = pModule->pHeader ;

    LockDebugHeader( pHeader );

    pScan = pHeader->pModules ;

    if ( pScan == pModule )
    {
        pHeader->pModules = pModule->pNext ;
    }
    else
    {
        while ( pScan && ( pScan->pNext != pModule ) )
        {
            pScan = pScan->pNext ;
        }

        if ( pScan )
        {
            pScan->pNext = pModule->pNext ;
        }

        pModule->pNext = NULL ;
    }

    DbgpFree( pHeader, pModule->pModuleName );

    DbgpFree( pHeader, pModule );

    pHeader->ModuleCount-- ;

    if ( pHeader->ModuleCount == 0 )
    {
        FreeIt = TRUE ;
    }

    UnlockDebugHeader( pHeader );

    if ( FreeIt )
    {
        if ( pHeader->hLogFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( pHeader->hLogFile );
        }

        if ( pHeader->hMapping )
        {
            CloseHandle( pHeader->hMapping );
        }

        DeleteCriticalSection( &pHeader->csDebug );

        UnmapViewOfFile( pHeader );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetTextBuffer
//
//  Synopsis:   Gets a text buffer from the header, allocating if necessary
//
//  Arguments:  [pHeader] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDEBUG_TEXT_BUFFER
DbgpGetTextBuffer(
    PDebugHeader pHeader
    )
{
    PDEBUG_TEXT_BUFFER pBuffer ;

    LockDebugHeader( pHeader );

    if ( pHeader->pBufferList )
    {
        pBuffer = pHeader->pBufferList ;

        pHeader->pBufferList = pBuffer->Next ;

    }
    else
    {
        pBuffer = DbgpAlloc( pHeader, sizeof( DEBUG_TEXT_BUFFER ) );
    }

    UnlockDebugHeader( pHeader );

    if ( pBuffer )
    {
        pBuffer->Next = NULL ;
    }

    return pBuffer ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpReleaseTextBuffer
//
//  Synopsis:   Releases a text buffer back to the pool of buffers
//
//  Arguments:  [pHeader] --
//              [pBuffer] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpReleaseTextBuffer(
    PDebugHeader pHeader,
    PDEBUG_TEXT_BUFFER pBuffer
    )
{
    LockDebugHeader( pHeader );

    pBuffer->Next = pHeader->pBufferList ;

    pHeader->pBufferList = pBuffer ;

    UnlockDebugHeader( pHeader );
}

//+---------------------------------------------------------------------------
//
//  Function:   _DebugOut
//
//  Synopsis:   Workhorse for the debug out functions
//
//  Arguments:  [pControl] -- Control pointer
//              [Mask]     -- Event mask
//              [Format]   -- format string
//              [ArgList]  -- va_list...
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_DebugOut(
    PVOID       pControl,
    ULONG       Mask,
    CHAR *      Format,
    va_list     ArgList)
{
    PDebugModule pModule;
    int          Level = 0;
    int          PrefixSize = 0;
    int          TotalSize;
    BOOL         fLocked;
    BOOL         fClean;
    PCHAR        Tag;
    BOOL         Break = FALSE ;
    PDEBUG_TEXT_BUFFER pBuffer ;

    if ( pControl == NULL )
    {
        return ;
    }

    pModule = (PDebugModule) pControl;

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    if (!pModule || (pModule == INVALID_HANDLE_VALUE))
    {
        if (Mask & DSYSDBG_FORCE)
        {
            NOTHING ;
        }
        else
            return;
    }

    if (pModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        *pModule->pInfoLevel = pModule->InfoLevel;
        pModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    if (pModule->pHeader->pGlobalModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        pModule->pHeader->fDebug = pModule->pHeader->pGlobalModule->InfoLevel;
        pModule->pHeader->pGlobalModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    pModule->InfoLevel = *pModule->pInfoLevel;

    if (pModule->pHeader->fDebug & DEBUG_MULTI_THREAD)
    {
        LockDebugHeader(pModule->pHeader);
        fLocked = TRUE;
    }
    else
        fLocked = FALSE;


    if (pModule->pHeader->fDebug & DEBUG_HEAP_CHECK)
    {
        if (!pModule->pHeader->pfnValidate)
        {
            DbgpLoadValidateRoutine(pModule->pHeader);
        }
        if (pModule->pHeader->pfnValidate)
        {
            pModule->pHeader->pfnValidate();
        }
    }

    fClean = ((Mask & DSYSDBG_CLEAN) != 0);

    if ( ( Mask & DEB_ERROR ) &&
         ( pModule->pHeader->fDebug & DEBUG_BREAK_ON_ERROR ) )
    {
        Break = TRUE ;
    }

    pBuffer = DbgpGetTextBuffer( pModule->pHeader );

    if ( !pBuffer )
    {
        OutputDebugStringA( "_DebugOut : Out of memory\n" );
        if ( fLocked )
        {
            UnlockDebugHeader( pModule->pHeader );

        }
        return;
    }

    if (Mask & (pModule->InfoLevel | DSYSDBG_FORCE))
    {

        if (Mask & DSYSDBG_FORCE)
        {
            Tag = "FORCE";
        }
        else
        {
            while (!(Mask & 1))
            {
                Level++;
                Mask >>= 1;
            }
            Tag = pModule->TagLevels[Level];
        }

        //
        // Make the prefix first:  "Process.Thread> Module-Tag:
        //

        if (!fClean)
        {
            if (pModule->pHeader->fDebug & DEBUG_TIMESTAMP)
            {
                SYSTEMTIME  stTime;

                GetLocalTime(&stTime);

                PrefixSize = _snprintf(pBuffer->TextBuffer, RTL_NUMBER_OF(pBuffer->TextBuffer) - 1,
                    "[%2d/%2d %02d:%02d:%02d] %d.%d> %s-%s: ",
                    stTime.wMonth, stTime.wDay,
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    GetCurrentProcessId(),
                    GetCurrentThreadId(), pModule->pModuleName,
                    Tag);
            }
            else
            {
                PrefixSize = _snprintf(pBuffer->TextBuffer, RTL_NUMBER_OF(pBuffer->TextBuffer) - 1,
                    "%d.%d> %s-%s: ",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    pModule->pModuleName, Tag);
            }

            if (PrefixSize < 0)
            {
                PrefixSize = 0; // chop off the prefix
            }
        }

        if ((TotalSize = _vsnprintf(&pBuffer->TextBuffer[PrefixSize],
                                    DEBUG_TEXT_BUFFER_SIZE - PrefixSize - 1,
                                    Format, ArgList)) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("dsysdbg:  Could not pack string into 512 bytes\n");
        }
        else
        {
            TotalSize += PrefixSize;

            if ((pModule->pHeader->fDebug & DEBUG_NO_DEBUGIO) == 0 )
            {
                OutputDebugStringA( pBuffer->TextBuffer );
            }

            if ((pModule->pHeader->fDebug & DEBUG_LOGFILE))
            {
                if (pModule->pHeader->hLogFile == INVALID_HANDLE_VALUE)
                {
                    DbgpOpenLogFileRandom(pModule->pHeader);
                }

                if (!WriteFile(  
                    pModule->pHeader->hLogFile,
                    pBuffer->TextBuffer,
                    (DWORD) TotalSize,
                    (PDWORD) &PrefixSize,
                    NULL 
                    ))
                {
                    CHAR szOutput[MAX_PATH] = {0};
                    
                    _snprintf(szOutput, RTL_NUMBER_OF(szOutput) - 1, "_DebugOut: WriteFile failed with %#x\n", GetLastError());
                    
                    OutputDebugStringA(szOutput);
                }
            }

            pModule->pHeader->TotalWritten += TotalSize;
            pModule->TotalOutput += TotalSize;
        }
    }
    if (fLocked)
    {
        UnlockDebugHeader(pModule->pHeader);
    }

    DbgpReleaseTextBuffer( pModule->pHeader, pBuffer );

    if ( Break )
    {
        OutputDebugStringA( "BreakOnError\n" );
        DebugBreak();
    }
}

VOID
_DbgSetOption(
    PVOID   pControl,
    DWORD   Option,
    BOOL    On,
    BOOL    Global
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule) pControl ;

    if ( pModule )
    {
        if ( Global )
        {
            pModule = pModule->pHeader->pGlobalModule ;
        }

        if ( On )
        {
            pModule->InfoLevel |= Option ;
            *pModule->pInfoLevel |= Option ;
        }
        else
        {
            pModule->InfoLevel &= (~Option) ;
            *pModule->pInfoLevel &= (~Option) ;
        }
    }
}

VOID
_DbgSetLoggingOption(
    PVOID   pControl,
    BOOL    On
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule)pControl;

    if ( pModule )
    {
       if (((pModule->pHeader->fDebug & DEBUG_LOGFILE) == 0) && On )// off, turn it on
       {
          pModule->pHeader->fDebug |= DEBUG_LOGFILE;
       }
       else if ((pModule->pHeader->fDebug & DEBUG_LOGFILE) && !On) // on, turn it off
       {
          pModule->pHeader->fDebug &= (~DEBUG_LOGFILE);
          if ( pModule->pHeader->hLogFile != INVALID_HANDLE_VALUE )
          {
             CloseHandle( pModule->pHeader->hLogFile );
             pModule->pHeader->hLogFile = INVALID_HANDLE_VALUE;
          }
       }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\debuglib\safelock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    safelock.c

Abstract:

    Implementation of the safe lock library - a set of
    thin wrappers around critical section and resource
    routines that ensures proper lock ordering.

    Debug spew is generated when locks are acquired out of
    order.

--*/

#include <debuglib.h>
#include <safelock.h>

#ifdef DBG

typedef struct _SAFE_LOCK_ENTRY {

    DWORD Enum;
    DWORD Count;

} SAFE_LOCK_ENTRY;

typedef struct _SAFE_LOCK_STACK {

    DWORD Top;
    DWORD Size;
    SAFE_LOCK_ENTRY Entries[ANYSIZE_ARRAY];

} SAFE_LOCK_STACK, *PSAFE_LOCK_STACK;

typedef struct _SAFE_LOCK_CONTEXT {

    DWORD SafeLockThreadState;
    DWORD MaxLocks;
    BOOL AssertOnErrors;
    LONG InstanceCounts[ANYSIZE_ARRAY];

} SAFE_LOCK_CONTEXT, *PSAFE_LOCK_CONTEXT;

PSAFE_LOCK_CONTEXT SafeLockContext;

///////////////////////////////////////////////////////////////////////////////
//
// Helper routines
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SafeLockInit(
    IN DWORD MaxLocks,
    IN BOOL AssertOnErrors
    )
/*++

Routine Description:

    Called by the user of the safelock code at startup time,
    once per process initialization.

Parameters:

    MaxLocks          - number of locks to be managed
    AssertOnErrors    - if TRUE, asserts will fire when errors are encountered

Returns:

    STATUS_INSUFFICIENT_RESOURCES      TlsAlloc failed

    STATUS_SUCCESS                     Otherwise

--*/
{
    ASSERT( MaxLocks > 0 );
    ASSERT( MaxLocks < 64 ); // must fit in 6 bits

    SafeLockContext = LocalAlloc( 0, sizeof( SAFE_LOCK_CONTEXT ) + ( MaxLocks - 1) * sizeof( LONG ));

    if ( SafeLockContext == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SafeLockContext->SafeLockThreadState = TlsAlloc();

    if ( SafeLockContext->SafeLockThreadState == TLS_OUT_OF_INDEXES ) {

        LocalFree( SafeLockContext );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SafeLockContext->MaxLocks = MaxLocks;
    SafeLockContext->AssertOnErrors = AssertOnErrors;
    RtlZeroMemory( SafeLockContext->InstanceCounts, MaxLocks * sizeof( LONG ));

    return STATUS_SUCCESS;
}



NTSTATUS
SafeLockCleanup(
    )
/*++

Routine Description:

    Called by the user of the safelock code at cleanup time

Parameters:

    None

Returns:

    STATUS_SUCCESS

--*/
{
    if ( SafeLockContext ) {

        if ( SafeLockContext->SafeLockThreadState != TLS_OUT_OF_INDEXES ) {

            TlsFree( SafeLockContext->SafeLockThreadState );
        }

        LocalFree( SafeLockContext );
        SafeLockContext = NULL;
    }

    return STATUS_SUCCESS;
}



VOID
TrackLockEnter(
    DWORD Enum
    )
/*++

Routine Description:

    Used to insert tracking information about a lock into the stack

Parameters:

    Enum       ordinal number associated with the lock

Returns:

    Nothing, but will assert if not happy

--*/
{
    PSAFE_LOCK_STACK Stack;
    DWORD Index;

    ASSERT(( Enum >> 26 ) < SafeLockContext->MaxLocks );

    //
    // First see if the space for the stack has been allocated
    //

    Stack = ( PSAFE_LOCK_STACK )TlsGetValue( SafeLockContext->SafeLockThreadState );

    if ( Stack == ( PVOID )( -1 )) {

        //
        // Once the TLS value for stack is -1, we can no longer reliably track
        // lock information for this thread, so just give up
        //

        return;

    } else if ( Stack == NULL ) {

        Stack = ( PSAFE_LOCK_STACK )LocalAlloc( 0, sizeof( SAFE_LOCK_STACK ) + ( SafeLockContext->MaxLocks - 1 ) * sizeof( SAFE_LOCK_ENTRY ));

        if ( Stack == NULL ) {

            //
            // Got no better way of dealing with this error here
            //
            DbgPrint( "Out of memory allocating lock tracking stack\n" );
            TlsSetValue( SafeLockContext->SafeLockThreadState, ( PVOID )( -1 ));
            return;
        }

        Stack->Top = 0;
        Stack->Size = SafeLockContext->MaxLocks;

        RtlZeroMemory( Stack->Entries,   SafeLockContext->MaxLocks * sizeof( SAFE_LOCK_ENTRY ));

        TlsSetValue( SafeLockContext->SafeLockThreadState, Stack );
    }

    if ( Stack->Top >= Stack->Size ) {

        //
        // Stack limits exceeded, must grow
        //

        PSAFE_LOCK_STACK StackT = ( PSAFE_LOCK_STACK )LocalAlloc( 0, sizeof( SAFE_LOCK_STACK ) + ( 2 * Stack->Size - 1 ) * sizeof( SAFE_LOCK_ENTRY ));

        if ( StackT == NULL ) {

            //
            // Got no better way of dealing with this error here
            //
            DbgPrint( "Out of memory allocating lock tracking stack\n" );
            LocalFree( Stack );
            TlsSetValue( SafeLockContext->SafeLockThreadState, ( PVOID )( -1 ));
            return;
        }

        StackT->Top = Stack->Top;
        StackT->Size = 2 * Stack->Size;

        RtlCopyMemory( StackT->Entries, Stack->Entries, Stack->Size * sizeof( SAFE_LOCK_ENTRY ));
        RtlZeroMemory( &StackT->Entries[Stack->Size], Stack->Size * sizeof( SAFE_LOCK_ENTRY ));

        LocalFree( Stack );
        Stack = StackT;

        TlsSetValue( SafeLockContext->SafeLockThreadState, Stack );
    }

    if ( Stack->Top == 0 ||
         Enum > Stack->Entries[Stack->Top-1].Enum ) {

        //
        // Lock acquired in order; no further checks are necessary
        //

        Stack->Entries[Stack->Top].Enum = Enum;
        Stack->Entries[Stack->Top].Count = 1;
        Stack->Top += 1;

    } else {

        //
        // Locks with an enum of '0' are presumed to have no dependencies;
        // they must be acquired and released independently
        //

        if (( Enum >> 26 ) == 0 ) {

            CHAR Buffer[128] = {0};
            _snprintf(Buffer, sizeof(Buffer) - 1, "Unplaced lock acquired together with other locks: dt %p _SAFE_LOCK_STACK\n", Stack );
            DbgPrint( Buffer );

            if ( SafeLockContext->AssertOnErrors ) {

                ASSERT( FALSE );
            }

        } else if (( Stack->Entries[0].Enum >> 26 ) == 0 ) {

            CHAR Buffer[128] = {0};
            _snprintf( Buffer, sizeof(Buffer) - 1, "Lock %d acquired together with an unplaced lock\n", ( Enum >> 26 ));
            DbgPrint( Buffer );

            if ( SafeLockContext->AssertOnErrors ) {

                ASSERT( FALSE );
            }
        }

        //
        // See if this lock has been acquired already
        //

        for ( Index = 0; Index < Stack->Top; Index++ ) {

            if ( Stack->Entries[Index].Enum == Enum ) {

                Stack->Entries[Index].Count += 1;
                break;
            }
        }

        if ( Index == Stack->Top ) {

            CHAR Buffer[128] = {0};
            _snprintf( Buffer, sizeof(Buffer) - 1, "Lock %d acquired out of order: dt %p _SAFE_LOCK_STACK\n", ( Enum >> 26 ), Stack );
            DbgPrint( Buffer );

            if ( SafeLockContext->AssertOnErrors ) {

                ASSERT( FALSE );
            }

            //
            // To keep the stack consistent, insert the new item
            // as if it was acquired in proper order
            //

            for ( Index = 0; Index < Stack->Top; Index++ ) {

                if ( Enum < Stack->Entries[Index].Enum ) {

                    MoveMemory( &Stack->Entries[Index+1],
                                &Stack->Entries[Index],
                                sizeof( SAFE_LOCK_ENTRY ) * ( Stack->Top - Index ));

                    break;
                }
            }

            Stack->Entries[Index].Enum = Enum;
            Stack->Entries[Index].Count = 1;
            Stack->Top += 1;
        }
    }

    return;
}



VOID
TrackLockLeave(
    DWORD Enum
    )
/*++

Routine Description:

    Used to remove tracking information about a lock from the stack

Parameters:

    Enum       ordinal number associated with the lock

Returns:

    Nothing, but will assert if not happy

--*/
{
    PSAFE_LOCK_STACK Stack;
    DWORD Index;

    ASSERT(( Enum >> 26 ) < SafeLockContext->MaxLocks );

    Stack = ( PSAFE_LOCK_STACK )TlsGetValue( SafeLockContext->SafeLockThreadState );

    if ( Stack == ( PVOID )( -1 )) {

        //
        // No lock tracking information available for this thread
        //

        return;

    } else if ( Stack == NULL || Stack->Top == 0 ) {

        CHAR Buffer[128] = {0};
        _snprintf( Buffer, sizeof(Buffer) - 1, "Leaving a lock %d that has not been acquired\n", ( Enum >> 26 ));
        DbgPrint( Buffer );

        if ( SafeLockContext->AssertOnErrors ) {

            ASSERT( FALSE );
        }

        return;
    }

    //
    // See if this lock has been acquired already
    //

    for ( Index = 0; Index < Stack->Top; Index++ ) {

        if ( Stack->Entries[Index].Enum == Enum ) {

            Stack->Entries[Index].Count -= 1;
            break;
        }
    }

    if ( Index == Stack->Top ) {

        CHAR Buffer[128] = {0};
        _snprintf( Buffer, sizeof(Buffer) - 1, "Leaving a lock %d that has not been acquired: dt %p _SAFE_LOCK_STACK\n", ( Enum >> 26 ), Stack );
        DbgPrint( Buffer );

        if ( SafeLockContext->AssertOnErrors ) {

            ASSERT( FALSE );
        }

    } else if ( Stack->Entries[Index].Count == 0 ) {

        //
        // Compact the stack
        //

        Stack->Top -= 1;
        MoveMemory( &Stack->Entries[Index],
                    &Stack->Entries[Index+1],
                    sizeof( SAFE_LOCK_ENTRY ) * ( Stack->Top - Index ));
    }

    if ( Stack->Top == 0 ) {

        LocalFree( Stack );
        TlsSetValue( SafeLockContext->SafeLockThreadState, NULL );
    }

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
// RTL_CRITICAL_SECTION wrappers
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SafeEnterCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlEnterCriticalSection.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to enter

Returns:

    See RtlEnterCriticalSection

--*/
{
    NTSTATUS Status;

    TrackLockEnter( CriticalSection->Enum );

    Status = RtlEnterCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



NTSTATUS
SafeLeaveCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlLeaveCriticalSection that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to leave

Returns:

    See RtlLeaveCriticalSection

--*/
{
    NTSTATUS Status;

    TrackLockLeave( CriticalSection->Enum );

    Status = RtlLeaveCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



BOOLEAN
SafeTryEnterCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlTryEnterCriticalSection that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to enter

Returns:

    See RtlTryEnterCriticalSection

--*/
{
    BOOLEAN Result;

    TrackLockEnter( CriticalSection->Enum );

    Result = RtlTryEnterCriticalSection( &CriticalSection->CriticalSection );

    if ( !Result ) {

        TrackLockLeave( CriticalSection->Enum );
    }

    return Result;
}



NTSTATUS
SafeInitializeCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeCriticalSection.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to initialize
    Enum               ordinal number associated with the critical section

Returns:

    See RtlInitializeCriticalSection

--*/
{
    NTSTATUS Status;

    ASSERT( Enum < SafeLockContext->MaxLocks );

    CriticalSection->Enum = ( LONG )InterlockedIncrement( &SafeLockContext->InstanceCounts[Enum] );
    CriticalSection->Enum |= ( Enum << 26 );

    ASSERT(( CriticalSection->Enum >> 26 ) == Enum );

    Status = RtlInitializeCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



NTSTATUS
SafeInitializeCriticalSectionAndSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeCriticalSectionAndSpinCount.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to initialize
    SpinCount          spin count
    Enum               ordinal number associated with the critical section

Returns:

    See RtlInitializeCriticalSectionAndSpinCount

--*/
{
    NTSTATUS Status;

    ASSERT( Enum < SafeLockContext->MaxLocks );

    CriticalSection->Enum = ( LONG )InterlockedIncrement( &SafeLockContext->InstanceCounts[Enum] );
    CriticalSection->Enum |= ( Enum << 26 );

    ASSERT(( CriticalSection->Enum >> 26 ) == Enum );

    Status = RtlInitializeCriticalSectionAndSpinCount( &CriticalSection->CriticalSection, SpinCount );

    return Status;
}



ULONG
SafeSetCriticalSectionSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )
/*++

Routine Description:

    Debug wrapper around RtlSetCriticalSectionSpinCount.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to modify
    SpinCount          see the definition of RtlSetCriticalSectionSpinCount

Returns:

    See RtlSetCriticalSectionSpinCount

--*/
{
    ULONG Result;

    Result = RtlSetCriticalSectionSpinCount( &CriticalSection->CriticalSection, SpinCount );

    return Result;
}



NTSTATUS
SafeDeleteCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlDeleteCriticalSection.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to delete

Returns:

    See RtlDeleteCriticalSection

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
//
// RTL_RESOURCE wrappers
//
///////////////////////////////////////////////////////////////////////////////



VOID
SafeInitializeResource(
    PSAFE_RESOURCE Resource,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeResource.

Arguments:

    Resource    address of a SAFE_RESOURCE to initialize
    Enum        ordinal number associated with the resource

Returns:

    See RtlInitializeResource

--*/
{
    ASSERT( Enum < SafeLockContext->MaxLocks );

    Resource->Enum = ( LONG )InterlockedIncrement( &SafeLockContext->InstanceCounts[Enum] );
    Resource->Enum |= ( Enum << 26 );

    ASSERT(( Resource->Enum >> 26 ) == Enum );

    RtlInitializeResource( &Resource->Resource );

    return;
}



BOOLEAN
SafeAcquireResourceShared(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    )
/*++

Routine Description:

    Debug wrapper around RtlAcquireResourceShared that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to enter
    Wait        see definition of RtlAcquireResourceShared

Returns:

    See RtlAcquireResourceShared

--*/
{
    BOOLEAN Result;

    TrackLockEnter( Resource->Enum );

    Result = RtlAcquireResourceShared( &Resource->Resource, Wait );

    if ( !Result ) {

        TrackLockLeave( Resource->Enum );
    }

    return Result;
}



BOOLEAN
SafeAcquireResourceExclusive(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    )
/*++

Routine Description:

    Debug wrapper around RtlAcquireResourceExclusive that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to enter
    Wait        see definition of RtlAcquireResourceExclusive

Returns:

    See RtlAcquireResourceExclusive

--*/
{
    BOOLEAN Result;

    TrackLockEnter( Resource->Enum );

    Result = RtlAcquireResourceExclusive( &Resource->Resource, Wait );

    if ( !Result ) {

        TrackLockLeave( Resource->Enum );
    }

    return Result;
}



VOID
SafeReleaseResource(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlReleaseResource that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to release

Returns:

    See RtlReleaseResource

--*/
{
    TrackLockLeave( Resource->Enum );

    RtlReleaseResource( &Resource->Resource );

    return;
}



VOID
SafeConvertSharedToExclusive(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlConvertSharedToExclusive.

Arguments:

    Resource    address of a SAFE_RESOURCE to convert

Returns:

    See RtlConvertSharedToExclusive

--*/
{
    RtlConvertSharedToExclusive( &Resource->Resource );

    return;
}



VOID
SafeConvertExclusiveToShared(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlConvertExclusiveToShared.

Arguments:

    Resource    address of a SAFE_RESOURCE to convert

Returns:

    See RtlConvertExclusiveToShared

--*/
{
    RtlConvertExclusiveToShared( &Resource->Resource );

    return;
}



VOID
SafeDeleteResource (
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlDeleteResource.

Arguments:

    Resource    address of a SAFE_RESOURCE to delete

Returns:

    See RtlDeleteResource

--*/
{
    RtlDeleteResource( &Resource->Resource );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\lsaitf\lsaitf.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        lsaitf.c
//
// Contents:    Routines for dynamically calling LSA & Sam routines
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <lsaisrv.h>
#include <samisrv.h>
#include <lsaitf.h>

typedef NTSTATUS (*PI_SamrSetInformationUser)(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    );

typedef NTSTATUS (*PI_SamrCloseHandle)(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    );

typedef NTSTATUS (*PI_SamrOpenDomain)(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    );

typedef NTSTATUS (*PI_SamrQueryInformationDomain)(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    );
    
typedef NTSTATUS (*PI_SamIConnect)(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

typedef NTSTATUS (*PI_SamIAccountRestrictions)(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

typedef NTSTATUS (*PI_SamIGetUserLogonInformation)(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

typedef NTSTATUS (*PI_SamIGetUserLogonInformationEx)(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

typedef VOID (*PI_SamIFree_SAMPR_USER_INFO_BUFFER )(
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

typedef VOID (*PI_SamIFree_SAMPR_ULONG_ARRAY )(
    PSAMPR_ULONG_ARRAY Source
    );

typedef VOID (*PI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY )(
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

typedef VOID (*PI_SamIFreeSidAndAttributesList)(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );

typedef VOID
(NTAPI *PI_SamIIncrementPerformanceCounter)(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );

typedef VOID (*PI_SamIFreeVoid)(
    IN PVOID ptr
    );

typedef NTSTATUS (*PI_SamIUPNFromUserHandle)(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

typedef NTSTATUS (*PI_SamIUpdateLogonStatistics)(
    IN SAMPR_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    );

typedef NTSTATUS (*PI_LsaIOpenPolicyTrusted)(
    OUT PLSAPR_HANDLE PolicyHandle
    );

typedef NTSTATUS (*PI_LsarClose)(
    IN OUT LSAPR_HANDLE *ObjectHandle
    );

typedef NTSTATUS (*PI_LsaIQueryInformationPolicyTrusted)(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );
typedef NTSTATUS (*PI_LsarQueryInformationPolicy)(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    );

typedef VOID (*PI_LsaIFree_LSAPR_POLICY_INFORMATION )(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );


typedef NTSTATUS (*PI_LsarCreateSecret)(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

typedef NTSTATUS (*PI_LsarOpenSecret)(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

typedef NTSTATUS (*PI_LsarSetSecret)(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    );

typedef NTSTATUS (*PI_LsarQuerySecret)(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    );

typedef NTSTATUS (*PI_LsarDelete)(
    IN OUT LSAPR_HANDLE ObjectHandle
    );

typedef VOID (*PI_LsaIFree_LSAPR_CR_CIPHER_VALUE) (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );

typedef NTSTATUS
(NTAPI *PI_LsaIRegisterPolicyChangeNotificationCallback)(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

typedef NTSTATUS
(NTAPI *PI_LsaIUnregisterPolicyChangeNotificationCallback)(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

typedef NTSTATUS
(NTAPI *PI_LsaIAuditAccountLogonEx)(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             LogonStatus,         OPTIONAL
    IN PSID                 ClientSid
    );

typedef
NTSTATUS
(NTAPI *PI_LsaIGetLogonGuid)(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

typedef
NTSTATUS
(NTAPI *PI_LsaISetLogonGuidInLogonSession)(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    );


typedef
VOID
(NTAPI *PI_LsaIAuditKerberosLogon)(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID pLogonId,
    IN LPGUID pLogonGuid,
    IN PLSA_ADT_STRING_LIST TransittedServices
    );

typedef
NTSTATUS
(NTAPI *PI_LsaIAuditLogonUsingExplicitCreds)(
    IN USHORT          AuditEventType,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN HANDLE          User1ProcessId,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid,
    IN PUNICODE_STRING pTargetName,
    IN PUNICODE_STRING pTargetInfo
    );

typedef NTSTATUS
(NTAPI *PI_LsaICallPackage)(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef NTSTATUS
(NTAPI *PI_LsaIAddNameToLogonSession)(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    );

typedef NTSTATUS
(NTAPI *PI_LsaIGetNameFromLuid)(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  BOOLEAN         LocalOnly,
    OUT PUNICODE_STRING Name
    );

typedef NTSTATUS
(NTAPI *PI_LsaISetPackageAttrInLogonSession)(
    IN  PLUID LogonId,
    IN  ULONG PackageAttr
    );

typedef
NTSTATUS
(NTAPI *PI_LsaIAdtAuditingEnabledByCategory)(
    IN  POLICY_AUDIT_EVENT_TYPE Category,
    IN  USHORT                  AuditEventType,
    IN  PSID                    pUserSid,
    IN  PLUID                   pLogonId,
    OUT PBOOLEAN                pbAudit
    );


///////////////////////////////////////////////////////////////////////

BOOLEAN SrvDllsLoaded = FALSE;
NTSTATUS DllLoadStatus = STATUS_SUCCESS;

PI_SamrSetInformationUser pI_SamrSetInformationUser;
PI_SamrCloseHandle pI_SamrCloseHandle;
PI_SamrOpenDomain pI_SamrOpenDomain;
PI_SamrQueryInformationDomain pI_SamrQueryInformationDomain;
PI_SamIConnect pI_SamIConnect;
PI_SamIAccountRestrictions pI_SamIAccountRestrictions;
PI_SamIGetUserLogonInformation pI_SamIGetUserLogonInformation;
PI_SamIGetUserLogonInformationEx pI_SamIGetUserLogonInformationEx;
PI_SamIFree_SAMPR_USER_INFO_BUFFER  pI_SamIFree_SAMPR_USER_INFO_BUFFER ;
PI_SamIFree_SAMPR_ULONG_ARRAY pI_SamIFree_SAMPR_ULONG_ARRAY ;
PI_SamIFreeSidAndAttributesList pI_SamIFreeSidAndAttributesList ;
PI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY pI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY;
PI_SamIIncrementPerformanceCounter pI_SamIIncrementPerformanceCounter;
PI_SamIFreeVoid pI_SamIFreeVoid;
PI_SamIUPNFromUserHandle pI_SamIUPNFromUserHandle;
PI_SamIUpdateLogonStatistics pI_SamIUpdateLogonStatistics;

PI_LsaIOpenPolicyTrusted pI_LsaIOpenPolicyTrusted;
PI_LsarClose pI_LsarClose;
PI_LsaIQueryInformationPolicyTrusted pI_LsaIQueryInformationPolicyTrusted;
PI_LsarQueryInformationPolicy pI_LsarQueryInformationPolicy;
PI_LsaIFree_LSAPR_POLICY_INFORMATION pI_LsaIFree_LSAPR_POLICY_INFORMATION ;
PI_LsarCreateSecret pI_LsarCreateSecret;
PI_LsarOpenSecret pI_LsarOpenSecret;
PI_LsarSetSecret pI_LsarSetSecret;
PI_LsarQuerySecret pI_LsarQuerySecret;
PI_LsarDelete pI_LsarDelete;
PI_LsaIFree_LSAPR_CR_CIPHER_VALUE pI_LsaIFree_LSAPR_CR_CIPHER_VALUE;
PI_LsaIRegisterPolicyChangeNotificationCallback pI_LsaIRegisterPolicyChangeNotificationCallback;
PI_LsaIUnregisterPolicyChangeNotificationCallback pI_LsaIUnregisterPolicyChangeNotificationCallback;
PI_LsaIAuditAccountLogonEx pI_LsaIAuditAccountLogonEx;
PI_LsaIGetLogonGuid pI_LsaIGetLogonGuid;
PI_LsaISetLogonGuidInLogonSession pI_LsaISetLogonGuidInLogonSession;
PI_LsaIAuditKerberosLogon pI_LsaIAuditKerberosLogon;
PI_LsaIAuditLogonUsingExplicitCreds pI_LsaIAuditLogonUsingExplicitCreds;
PI_LsaICallPackage pI_LsaICallPackage;
PI_LsaIAddNameToLogonSession pI_LsaIAddNameToLogonSession;
PI_LsaIGetNameFromLuid pI_LsaIGetNameFromLuid;
PI_LsaISetPackageAttrInLogonSession pI_LsaISetPackageAttrInLogonSession;
PI_LsaIAdtAuditingEnabledByCategory pI_LsaIAdtAuditingEnabledByCategory;


///////////////////////////////////////////////////////////////////////

//
// Macro to grab the address of the named procedure from a DLL
//

#if DBG
#define GRAB_ADDRESS( _Y, _X ) \
    pI_##_X = (PI_##_X) GetProcAddress( _Y, #_X ); \
    \
    if ( pI_##_X == NULL ) { \
        DbgPrint("[security process] can't load " #_X " procedure. %ld\n", GetLastError()); \
        Status = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#else // DBG
#define GRAB_ADDRESS( _Y, _X ) \
    pI_##_X = (PI_##_X) GetProcAddress( _Y, #_X ); \
    \
    if ( pI_##_X == NULL ) { \
        Status = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   EnsureSrvDllsLoaded
//
//  Synopsis:   Ensures that lsasrv.dll & samsrv.dll are loaded and
//              looks up function addresses in them.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
EnsureSrvDllsLoaded(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE SamsrvHandle = NULL;
    HMODULE LsasrvHandle = NULL;

    if (!NT_SUCCESS(DllLoadStatus))
    {
        return(DllLoadStatus);
    }

    //
    // Get handles to the DLLs. We don't want to load the DLLs - just
    // use them if they are present
    //

    SamsrvHandle = GetModuleHandleW(L"samsrv.dll");
    if (SamsrvHandle == NULL)
    {
        Status = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }

    LsasrvHandle = GetModuleHandleW(L"lsasrv.dll");
    if (SamsrvHandle == NULL)
    {
        Status = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }

    GRAB_ADDRESS( SamsrvHandle, SamrSetInformationUser );
    GRAB_ADDRESS( SamsrvHandle, SamrCloseHandle );
    GRAB_ADDRESS( SamsrvHandle, SamrOpenDomain );
    GRAB_ADDRESS( SamsrvHandle, SamrQueryInformationDomain );
    GRAB_ADDRESS( SamsrvHandle, SamIConnect );
    GRAB_ADDRESS( SamsrvHandle, SamIAccountRestrictions );
    GRAB_ADDRESS( SamsrvHandle, SamIGetUserLogonInformation );
    GRAB_ADDRESS( SamsrvHandle, SamIGetUserLogonInformationEx );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_USER_INFO_BUFFER  );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_ULONG_ARRAY );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_RETURNED_USTRING_ARRAY );
    GRAB_ADDRESS( SamsrvHandle, SamIFreeSidAndAttributesList );
    GRAB_ADDRESS( SamsrvHandle, SamIIncrementPerformanceCounter );
    GRAB_ADDRESS( SamsrvHandle, SamIFreeVoid );
    GRAB_ADDRESS( SamsrvHandle, SamIUPNFromUserHandle );
    GRAB_ADDRESS( SamsrvHandle, SamIUpdateLogonStatistics );
    GRAB_ADDRESS( LsasrvHandle, LsaIOpenPolicyTrusted );
    GRAB_ADDRESS( LsasrvHandle, LsaIQueryInformationPolicyTrusted );
    GRAB_ADDRESS( LsasrvHandle, LsarClose );
    GRAB_ADDRESS( LsasrvHandle, LsarQueryInformationPolicy );
    GRAB_ADDRESS( LsasrvHandle, LsaIFree_LSAPR_POLICY_INFORMATION );
    GRAB_ADDRESS( LsasrvHandle, LsarCreateSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarOpenSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarSetSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarQuerySecret );
    GRAB_ADDRESS( LsasrvHandle, LsarDelete );
    GRAB_ADDRESS( LsasrvHandle, LsaIFree_LSAPR_CR_CIPHER_VALUE );
    GRAB_ADDRESS( LsasrvHandle, LsaIRegisterPolicyChangeNotificationCallback );
    GRAB_ADDRESS( LsasrvHandle, LsaIUnregisterPolicyChangeNotificationCallback );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditAccountLogonEx );
    GRAB_ADDRESS( LsasrvHandle, LsaIGetLogonGuid );
    GRAB_ADDRESS( LsasrvHandle, LsaISetLogonGuidInLogonSession );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditKerberosLogon );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditLogonUsingExplicitCreds );
    GRAB_ADDRESS( LsasrvHandle, LsaICallPackage );
    GRAB_ADDRESS( LsasrvHandle, LsaIAddNameToLogonSession );
    GRAB_ADDRESS( LsasrvHandle, LsaIGetNameFromLuid );
    GRAB_ADDRESS( LsasrvHandle, LsaISetPackageAttrInLogonSession );
    GRAB_ADDRESS( LsasrvHandle, LsaIAdtAuditingEnabledByCategory );
    SrvDllsLoaded = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        DllLoadStatus = Status;
    }
    return(Status);
}


///////////////////////////////////////////////////////////////////////

NTSTATUS
I_SamrSetInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrSetInformationUser)(
                UserHandle,
                UserInformationClass,
                Buffer
                ));

}


NTSTATUS
I_SamrCloseHandle(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrCloseHandle)( SamHandle ));
}


NTSTATUS
I_SamrOpenDomain(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrOpenDomain)(
                ServerHandle,
                DesiredAccess,
                DomainId,
                DomainHandle
                ));
}


NTSTATUS
I_SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamrQueryInformationDomain)(
                DomainHandle,
                DomainInformationClass,
                Buffer
                ));
}


NTSTATUS
I_SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamIConnect)(
                ServerName,
                ServerHandle,
                DesiredAccess,
                TrustedClient
                ));
}


NTSTATUS
I_SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamIAccountRestrictions)(
                UserHandle,
                LogonWorkstation,
                Workstations,
                LogonHours,
                LogoffTime,
                KickoffTime
                ));
}


NTSTATUS
I_SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamIGetUserLogonInformation)(
                DomainHandle,
                Flags,
                AccountName,
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}


NTSTATUS
I_SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamIGetUserLogonInformationEx)(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields,
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}


VOID
I_SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_USER_INFO_BUFFER)(
            Source,
            Branch
            );
}


VOID
I_SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_ULONG_ARRAY)( Source );
}


VOID
I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY(
    PSAMPR_RETURNED_USTRING_ARRAY Source
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY)( Source );
}


VOID
I_SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFreeSidAndAttributesList)( List );
}


VOID
I_SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIIncrementPerformanceCounter)( CounterType );
}


VOID
I_SamIFreeVoid(
    IN PVOID ptr
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFreeVoid)( ptr );
}


NTSTATUS
I_SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    return (*pI_SamIUPNFromUserHandle)( UserHandle, UPNDefaulted, UPN );
}


NTSTATUS
I_SamIUpdateLogonStatistics(
    IN  SAMPR_HANDLE UserHandle,
    IN  PSAM_LOGON_STATISTICS LogonStats
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    return (*pI_SamIUpdateLogonStatistics)( UserHandle, LogonStats );
}


NTSTATUS
I_LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsaIOpenPolicyTrusted)( PolicyHandle ));
}


NTSTATUS
I_LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsaIQueryInformationPolicyTrusted)(
                InformationClass,
                Buffer
                ));
}


NTSTATUS
I_LsarClose(
    IN OUT            LSAPR_HANDLE    *       LsaHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarClose)( LsaHandle ));
}


NTSTATUS
I_LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsarQueryInformationPolicy)(
                PolicyHandle,
                InformationClass,
                PolicyInformation
                ));
}


VOID
I_LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_LsaIFree_LSAPR_POLICY_INFORMATION)(
            InformationClass,
            PolicyInformation
            );
}


NTSTATUS
I_LsarCreateSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarCreateSecret)(
        PolicyHandle,
        SecretName,
        DesiredAccess,
        SecretHandle ));
}


NTSTATUS
I_LsarOpenSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarOpenSecret)(
        PolicyHandle,
        SecretName,
        DesiredAccess,
        SecretHandle ));
}


NTSTATUS
I_LsarSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarSetSecret)(
            SecretHandle,
            EncryptedCurrentValue,
            EncryptedOldValue
            ));
}


NTSTATUS
I_LsarQuerySecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsarQuerySecret)(
        SecretHandle,
        EncryptedCurrentValue,
        CurrentValueSetTime,
        EncryptedOldValue,
        OldValueSetTime));
}


NTSTATUS
I_LsarDelete(
    IN LSAPR_HANDLE ObjectHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarDelete)( ObjectHandle ));
}


VOID
I_LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_LsaIFree_LSAPR_CR_CIPHER_VALUE)(
            CipherValue
            );
}


NTSTATUS NTAPI
I_LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsaIRegisterPolicyChangeNotificationCallback)(
        Callback,
        MonitorInfoClass
        ));

}


NTSTATUS NTAPI
I_LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsaIUnregisterPolicyChangeNotificationCallback)(
        Callback,
        MonitorInfoClass
        ));

}


NTSTATUS
I_LsaIAuditAccountLogonEx(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             LogonStatus,          OPTIONAL
    IN PSID                 ClientSid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return((*pI_LsaIAuditAccountLogonEx)(
                AuditId,
                Successful,
                Source,
                ClientName,
                MappedName,
                LogonStatus,
                ClientSid
                ));
}


NTSTATUS
I_LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return (*pI_LsaIGetLogonGuid)(
                pUserName,
                pUserDomain,
                pBuffer,
                BufferSize,
                pLogonGuid
                );
}


NTSTATUS
I_LsaISetLogonGuidInLogonSession(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return (*pI_LsaISetLogonGuidInLogonSession)(
                pLogonId,
                pLogonGuid
                );
}


VOID
I_LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID pLogonId,
    IN LPGUID pLogonGuid,
    IN PLSA_ADT_STRING_LIST TransittedServices
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return;
        }
    }
    (*pI_LsaIAuditKerberosLogon)(
           LogonStatus,
           LogonSubStatus,
           AccountName,
           AuthenticatingAuthority,
           WorkstationName,
           UserSid,
           LogonType,
           TokenSource,
           pLogonId,
           pLogonGuid,
           TransittedServices
           );
}


NTSTATUS
I_LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN HANDLE          User1ProcessId,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid,
    IN PUNICODE_STRING pTargetName,
    IN PUNICODE_STRING pTargetInfo
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    }
    return (*pI_LsaIAuditLogonUsingExplicitCreds)(
                  AuditEventType,
                  pUser1LogonId,
                  pUser1LogonGuid,
                  User1ProcessId,
                  pUser2Name,
                  pUser2Domain,
                  pUser2LogonGuid,
                  pTargetName,
                  pTargetInfo
                  );
}

NTSTATUS
I_LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return((*pI_LsaICallPackage)(
                AuthenticationPackage,
                ProtocolSubmitBuffer,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                ));
}


NTSTATUS
I_LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return((*pI_LsaIAddNameToLogonSession)(
                LogonId,
                NameFormat,
                Name));
}


NTSTATUS
I_LsaIGetNameFromLuid(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  BOOLEAN         LocalOnly,
    OUT PUNICODE_STRING Name
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return((*pI_LsaIGetNameFromLuid)(
                LogonId,
                NameFormat,
                LocalOnly,
                Name));
}


NTSTATUS
I_LsaISetPackageAttrInLogonSession(
    IN  PLUID LogonId,
    IN  ULONG PackageAttr
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return((*pI_LsaISetPackageAttrInLogonSession)(
                LogonId,
                PackageAttr));
}


NTSTATUS
I_LsaIAdtAuditingEnabledByCategory(
    IN  POLICY_AUDIT_EVENT_TYPE Category,
    IN  USHORT                  AuditEventType,
    IN  PSID                    pUserSid,
    IN  PLUID                   pLogonId,
    OUT PBOOLEAN                pbAudit
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return((*pI_LsaIAdtAuditingEnabledByCategory)(
                Category,
                AuditEventType,
                pUserSid,
                pLogonId,
                pbAudit));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\debug\inc\debugp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debugp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUGP_H__
#define __DEBUGP_H__

#define DEBUGMOD_CHANGE_INFOLEVEL   0x00000001
#define DEBUGMOD_BUILTIN_MODULE     0x00000002

struct _DebugHeader;

typedef struct _DebugModule {
    struct _DebugModule *   pNext;
    DWORD *                 pInfoLevel;
    DWORD                   fModule;
    DWORD                   InfoLevel;
    struct _DebugHeader *   pHeader;
    DWORD                   TotalOutput;
    DWORD                   Reserved;
    PCHAR                   pModuleName;      
    PCHAR                   TagLevels[32];
} DebugModule, * PDebugModule;


#define DEBUG_TAG   'gubD'

#define DEBUG_NO_DEBUGIO    0x00000001      // Do not use OutputDebugString
#define DEBUG_TIMESTAMP     0x00000002      // Stamp date/time
#define DEBUG_DEBUGGER_OK   0x00000004      // We're running in a debugger
#define DEBUG_LOGFILE       0x00000008      // Send to log file
#define DEBUG_AUTO_DEBUG    0x00000010      // Start up in debugger
#define DEBUG_USE_KDEBUG    0x00000020      // Use KD
#define DEBUG_DISABLE_ASRT  0x00000100      // Disable asserts
#define DEBUG_PROMPTS       0x00000200      // No prompts for asserts

#define DEBUG_MODULE_NAME   "DsysDebug"

typedef BOOLEAN (NTAPI * HEAPVALIDATE)(VOID);

#define DEBUG_TEXT_BUFFER_SIZE  (512 - sizeof( PVOID ))

typedef struct _DEBUG_TEXT_BUFFER {
    struct _DEBUG_TEXT_BUFFER * Next ;
    CHAR TextBuffer[ DEBUG_TEXT_BUFFER_SIZE ];
} DEBUG_TEXT_BUFFER, * PDEBUG_TEXT_BUFFER ;

typedef struct _DebugHeader {
    DWORD               Tag;            // Check tag
    DWORD               fDebug;         // Global Flags
    PVOID               pvSection;      // Base address of section
    HANDLE              hMapping;       // Mapping handle
    HANDLE              hLogFile;       // Log file handle
    PDebugModule        pGlobalModule;  // Global Flags module
    PDebugModule        pModules;       // List of modules
    HEAPVALIDATE        pfnValidate;    // Heap Validator
    PVOID               pFreeList;      // Free list for allocator
    PCHAR               pszExeName;     // Exe Name
    PDEBUG_TEXT_BUFFER  pBufferList ;   // List of debug string buffers
    CRITICAL_SECTION    csDebug;        // Critical section
    DWORD               CommitRange;    // Range of memory committed
    DWORD               ReserveRange;   // Range of memory reserved
    DWORD               PageSize;       // Page size;
    DWORD               TotalWritten;   // Total Output of debug stuff
    DWORD               ModuleCount ;   // Module Count (not including builtins)
    DEBUG_TEXT_BUFFER   DefaultBuffer ; // One default buffer
} DebugHeader, * PDebugHeader;






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\wxlpc\inc\wxlpcp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxlpcp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __WXLPCP_H__
#define __WXLPCP_H__

typedef enum _WXLPC_MTYPE {
    WxGetKeyDataApi,
    WxReportResultsApi,
    WxMaxValueApi
} WXLPC_MTYPE ;

typedef struct _WXLPC_GETKEYDATA {
    WX_AUTH_TYPE ExpectedAuth ;
    ULONG BufferSize ;
    ULONG BufferData ;
    UCHAR Buffer[ 16 ];
} WXLPC_GETKEYDATA ;

typedef struct _WXLPC_REPORTRESULTS {
    NTSTATUS Status ;
} WXLPC_REPORTRESULTS ;

typedef struct _WXLPC_MESSAGE {
    PORT_MESSAGE    Message;
    NTSTATUS        Status ;
    WXLPC_MTYPE     Api ;
    union {
        WXLPC_GETKEYDATA    GetKeyData ;
        WXLPC_REPORTRESULTS ReportResults ;
    } Parameters ;
} WXLPC_MESSAGE, * PWXLPC_MESSAGE ;

#define WX_PORT_NAME    L"\\Security\\WxApiPort"
//#define WX_PORT_NAME L"\\BaseNamedObjects\\WxApiPort"

#define PREPARE_MESSAGE( Message, ApiCode ) \
    (Message).Message.u1.s1.DataLength = sizeof((Message)) - sizeof(PORT_MESSAGE); \
    (Message).Message.u1.s1.TotalLength = sizeof((Message)); \
    (Message).Message.u2.ZeroInit = 0L; \
    (Message).Api = ApiCode ;


#endif // __WXLPCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\wxlpc\server\testsrv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       testsrv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wxlpc.h>
#include <windows.h>

char _hex[] = "0123456789abcdef" ;
#define fromhex(x)  _hex[x & 0xF]


NTSTATUS
WxGetKeyData(
    HANDLE Ignored,
    WX_AUTH_TYPE ExpectedAuth,
    ULONG BufferSize,
    PUCHAR Buffer,
    PULONG BufferData
    )
{
    RtlCopyMemory( Buffer, _hex, BufferSize );
    *BufferData = BufferSize ;
    return STATUS_SUCCESS ;

}

NTSTATUS
WxReportResults(
    HANDLE Ignored,
    NTSTATUS Status
    )
{
    return STATUS_SUCCESS ;
}

VOID
WxClientDisconnect(
    HANDLE ignored
    )
{
    DbgPrint("Client Disconnect\n");
}

ULONG
ThreadWrapper(
    PVOID Ignored
    )
{
    NTSTATUS Status ;

    Status = WxServerThread( Ignored );

    DbgPrint( "WxServerThread returned %x\n", Status );

    return 0 ;

}

void __cdecl main (int argc, char *argv[])
{
    HANDLE Thread ;
    ULONG Tid ;

    DbgPrint( "Starting up server thread:\n" );

    Thread = CreateThread( 0, NULL, ThreadWrapper, NULL, 0, &Tid );

    if ( Thread )
    {
        DbgPrint( "Waiting on thread\n" );
        WaitForSingleObject( Thread, INFINITE );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\wxlpc\client\wxcli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxcli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <caiseapi.h>

#include <windows.h>
#include <windef.h>
#include <md5.h>
#include <crypt.h>

#include <wxlpc.h>
#include <wxlpcp.h>

#define safe_min(x,y)   ( x < y ? x : y )

NTSTATUS
WxConnect(
    PHANDLE Handle
    )
{
    NTSTATUS Status ;
    UNICODE_STRING PortName ;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Connect to the Winlogon server thread
    //

    RtlInitUnicodeString(&PortName, WX_PORT_NAME );
    Status = NtConnectPort(
                 Handle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status) )
    {
        // DbgPrint("WX: Connection failed %lx\n",Status);
    }


    return Status;
}

NTSTATUS
WxGetKeyData(
    IN HANDLE Handle,
    IN WX_AUTH_TYPE ExpectedAuthSource,
    IN ULONG BufferSize,
    OUT PUCHAR Buffer,
    OUT PULONG BufferData
    )
{
    WXLPC_MESSAGE Message ;
    NTSTATUS Status ;
    WXLPC_GETKEYDATA * Parameters ;

    PREPARE_MESSAGE( Message, WxGetKeyDataApi );

    Parameters = &Message.Parameters.GetKeyData ;

    Parameters->ExpectedAuth = ExpectedAuthSource ;
    Parameters->BufferSize = BufferSize ;

    Status = NtRequestWaitReplyPort(
                    Handle,
                    &Message.Message,
                    &Message.Message );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    if ( NT_SUCCESS( Message.Status ) )
    {
        RtlCopyMemory(  Buffer,
                        Parameters->Buffer,
                        safe_min( Parameters->BufferData, BufferSize ) );
    }

    return Message.Status ;
}

NTSTATUS
WxReportResults(
    IN HANDLE Handle,
    IN NTSTATUS ResultStatus
    )
{
    WXLPC_MESSAGE Message ;
    NTSTATUS Status ;
    WXLPC_REPORTRESULTS * Parameters ;

    PREPARE_MESSAGE( Message, WxReportResultsApi );

    Parameters = &Message.Parameters.ReportResults ;

    Parameters->Status = ResultStatus ;

    Status = NtRequestWaitReplyPort(
                    Handle,
                    &Message.Message,
                    &Message.Message );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    return Message.Status ;

}


/*++

    The following code was moved from syskey to wxcli so as to commonalize this code
    between syskey and samsrv.dll 

--*/
#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif

HIDDEN
UCHAR KeyShuffle[ 16 ] = { 8, 10, 3, 7, 2, 1, 9, 15, 0, 5, 13, 4, 11, 6, 12, 14 };

HIDDEN
CHAR HexKey[ 17 ] = "0123456789abcdef" ;

#define ToHex( f ) (HexKey[f & 0xF])

#define SYSTEM_KEY L"SecureBoot"



HIDDEN BOOLEAN
WxpDeleteLocalKey(VOID)
/*++

    Routine Description

    Deletes the syskey stored on the local machine

--*/
{
    HKEY LsaKey;
    ULONG err;

    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"System\\CurrentControlSet\\Control\\Lsa",
                      0,
                      KEY_READ | KEY_WRITE,
                      & LsaKey );

    if (0!=err)
    {
        return (FALSE);
    }

    (void) RegDeleteKey( LsaKey, TEXT("Data") );
    (void) RegDeleteKey( LsaKey, TEXT("Skew1") );
    (void) RegDeleteKey( LsaKey, TEXT("GBG") );
    (void) RegDeleteKey( LsaKey, TEXT("JD") );

    RegCloseKey(LsaKey);

    return STATUS_SUCCESS ;

}


HIDDEN BOOLEAN
WxpObfuscateKey(
    PWXHASH   Hash
    )
{
    HKEY Key ;
    HKEY Key2 ;
    int Result ;
    WXHASH H ;
    CHAR Classes[ 9 ];
    int i ;
    WXHASH R ;
    PCHAR Class ;
    DWORD Disp ;
    DWORD FailCount = 0;
    HKEY LsaKey = NULL;
    ULONG err=0;
    BOOLEAN fResult = FALSE;
  



     err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"System\\CurrentControlSet\\Control\\Lsa",
                      0,
                      KEY_READ | KEY_WRITE,
                      & LsaKey );

    if (0!=err)
    {
        return FALSE;
    }

    for (Result = 0 ; Result < 16 ; Result++ )
    {
        H.Digest[Result] = Hash->Digest[ KeyShuffle[ Result ] ];
    }

    WxpDeleteLocalKey();

    Classes[8] = '\0';

    if (!RtlGenRandom( R.Digest, 16 ))
    {
        goto Cleanup;
    }

    Class = Classes ;

    for ( i = 0 ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i ] >> 4) );
        *Class++ = ToHex( H.Digest[ i ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "JD",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("Lookup"), 0,
                        REG_BINARY, R.Digest, 6 );

        RegCloseKey( Key );
    }

    else
    {
        goto Cleanup;
    }

    Class = Classes ;

    for ( i = 0 ; i < 4 ; i++ )
    {
        if (!RtlGenRandom( R.Digest, 16 ))
        {
            goto Cleanup;
        }

        *Class++ = ToHex( (H.Digest[ i+4 ] >> 4 ) );
        *Class++ = ToHex( H.Digest[ i+4 ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "Skew1",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("SkewMatrix"), 0,
                        REG_BINARY, R.Digest, 16 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    if (!RtlGenRandom( R.Digest, 16 ))
    {
        goto Cleanup;
    }

    for ( i = 0, Class = Classes ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i+8 ] >> 4 ));
        *Class++ = ToHex( H.Digest[i+8] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "GBG",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("GrafBlumGroup"), 0,
                        REG_BINARY, R.Digest, 9 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    if (!RtlGenRandom( H.Digest, 8 ))
    {
        goto Cleanup;
    }

    Class = Classes ;

    if (!RtlGenRandom( R.Digest, 16 ))
    {
        goto Cleanup;
    }

    for ( i = 0 ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i+12 ] >> 4 ) );
        *Class++ = ToHex( H.Digest[ i+12 ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "Data",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        if (!RtlGenRandom( H.Digest, 16 ))
        {
            RegCloseKey( Key );
            goto Cleanup;
        }

        RegSetValueEx( Key, TEXT("Pattern"), 0,
                        REG_BINARY, R.Digest, 16 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    fResult = TRUE;
Cleanup:
    if (LsaKey)
    {
        RegCloseKey(LsaKey);
    }
    return fResult ;

}


#define FromHex( c )    ( ( ( c >= '0' ) && ( c <= '9') ) ? c - '0' :      \
                          ( ( c >= 'a' ) && ( c <= 'f') ) ? c - 'a' + 10:      \
                          ( ( c >= 'A' ) && ( c <= 'F' ) ) ? c - 'A' + 10: -1 )
                          
HIDDEN BOOLEAN
WxpDeObfuscateKey(
    HKEY Keylocation,
    PWXHASH   Hash
    )
{
    WXHASH ProtoHash ;
    int Result ;
    CHAR Class[ 9 ];
    HKEY Key ;
    DWORD Size ;
    DWORD i ;
    PUCHAR j ;
    int t;
    int t2 ;
    HKEY LsaKey;
    ULONG err;


    if (Keylocation!=NULL) {

        DWORD Type=REG_DWORD;
        DWORD Data;
        DWORD cbData=sizeof(DWORD);
        WCHAR Controlset[256];

        err = RegOpenKeyExW( Keylocation,
                          L"Select",
                          0,
                          KEY_READ | KEY_WRITE,
                          & LsaKey );
        if (0!=err)
        {
            return (FALSE);
        }

        err = RegQueryValueExW(
                          LsaKey, 
                          L"Default",
                          NULL,
                          &Type,       
                          (LPBYTE)&Data,
                          &cbData
                        );
        RegCloseKey(LsaKey);
        if (0!=err)
        {
            return (FALSE);
        }

        if(Data==1){   
            err = RegOpenKeyExW( Keylocation,
                              L"ControlSet001\\Control\\Lsa",
                              0,
                              KEY_READ | KEY_WRITE,
                              & LsaKey );
        } else {
            err = RegOpenKeyExW( Keylocation,
                              L"ControlSet002\\Control\\Lsa",
                              0,
                              KEY_READ | KEY_WRITE,
                              & LsaKey );
        }
        if (0!=err)
        {
            RegCloseKey(LsaKey);
            return (FALSE);
        }
    
    } else {
    
        err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Control\\Lsa",
                          0,
                          KEY_READ | KEY_WRITE,
                          & LsaKey );
    
        if (0!=err)
        {
             return (FALSE);
        }
    }

    Result = RegOpenKeyEx( LsaKey, TEXT("JD"), 0,
                               KEY_READ, &Key );
    j = ProtoHash.Digest ;

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("Skew1"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("GBG"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("Data"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    for ( i = 0 ; i < 16 ; i++ )
    {
        Hash->Digest[ KeyShuffle[ i ] ] = ProtoHash.Digest[ i ] ;
    }

    RegCloseKey(LsaKey);
    return TRUE ;

}

NTSTATUS
WxSaveSysKey(
    IN ULONG    Keylen,
    IN PVOID    Key
    )
    /*++

    Routine Description

    This routine is used to store the syskey 
    in the registry

    Paramaeters

        Keylen - the length of the key
        Key      the actual key itself

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    WXHASH H;

    //
    // key should be 128 bits
    //

    if (Keylen!=sizeof(H.Digest))
        return (STATUS_INVALID_PARAMETER);

    RtlCopyMemory(&H.Digest,
                  Key,
                  Keylen
                  );

    if (WxpObfuscateKey(&H))
    {
    
        return(STATUS_SUCCESS);

    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    return WxReadSysKeyEx(
                        NULL,
                        BufferLength,
                        Key 
                        );
}

NTSTATUS
WxReadSysKeyEx(
    IN HKEY Handle,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters
    
        Handle        Contains a pointer to the syskey in the old registry

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    WXHASH H;

    if ((NULL==Key) || (*BufferLength <sizeof(H.Digest)))
    {
        *BufferLength = sizeof(H.Digest);
        return(STATUS_BUFFER_OVERFLOW);
    }

    if (WxpDeObfuscateKey(Handle,&H))
    {
          *BufferLength = sizeof(H.Digest);
          RtlCopyMemory(
                  Key,
                  &H.Digest,
                  *BufferLength
                  );

          return(STATUS_SUCCESS);
    }

    return (STATUS_UNSUCCESSFUL);
       
}

NTSTATUS
WxLoadSysKeyFromDisk(OUT PVOID Key,
                     OUT PULONG BufferLength
                     )
/*++

    Routine Description

    This routine is used to read the syskey
    from the Disk
    
    Paramaeters

        Key - buffer where the key will be read into
          
        BufferLength - size of the returned key

    Return Values

        STATUS_OBJECT_NAME_NOT_FOUND
        STATUS_FILE_CORRUPT_ERROR
        STATUS_UNSUCCESSFUL
--*/
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;

    LPSTR SysKeyFileName = "A:\\startkey.key";
    
    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    
    hFile = CreateFileA( SysKeyFileName,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );
    
    
    
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        SetErrorMode( ErrorMode );
    
        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }
    
    if (!ReadFile( hFile, Key, SYSKEY_SIZE, &Actual, NULL ) ||
        (Actual != SYSKEY_SIZE ))
    {
        SetErrorMode( ErrorMode );
    
        CloseHandle( hFile );
    
        return STATUS_FILE_CORRUPT_ERROR ;
    
    }
    
    SetErrorMode( ErrorMode );
    
    CloseHandle( hFile );

    *BufferLength = SYSKEY_SIZE;
    return STATUS_SUCCESS;
}

NTSTATUS
WxHashKey(
    IN OUT LPWSTR key,  //will be killed
    OUT PVOID  SysKey,
    IN  OUT DWORD cbSysKey
    )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    MD5_CTX Md5;
    if(cbSysKey<SYSKEY_SIZE) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    cbSysKey=wcslen(key)*sizeof(WCHAR);

    MD5Init( &Md5 );
    MD5Update( &Md5, (PUCHAR) key, cbSysKey );
    MD5Final( &Md5 );

    ZeroMemory( key, cbSysKey );

    cbSysKey=SYSKEY_SIZE;
    CopyMemory( SysKey, Md5.digest, cbSysKey );

    return STATUS_SUCCESS;
}



NTSTATUS
WxSaveBootOption( WX_AUTH_TYPE NewType )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    HKEY LsaKey;
    ULONG err;
   
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"System\\CurrentControlSet\\Control\\Lsa",
                  0,
                  KEY_READ | KEY_WRITE,
                  & LsaKey );

    if (0!=err)
    {
     return (STATUS_UNSUCCESSFUL);
    }

    err = RegSetValueExW( 
                LsaKey,
                SYSTEM_KEY,
                0,
                REG_DWORD,
                (PUCHAR) &NewType,
                sizeof( NewType )
                );

    if (0!=err)
    {
     RegCloseKey(LsaKey);
     return (STATUS_UNSUCCESSFUL);
    }

    RegCloseKey(LsaKey);

    return ( STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\common\wxlpc\server\wxsrv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxsrv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wxlpc.h>
#include <wxlpcp.h>

NTSTATUS
WxpHandleRequest(
    HANDLE Client,
    PWXLPC_MESSAGE Message
    )
{
    WXLPC_GETKEYDATA * GetKey ;
    WXLPC_REPORTRESULTS * ReportResults ;

    switch ( Message->Api )
    {
        case WxGetKeyDataApi:
            GetKey = & Message->Parameters.GetKeyData ;

            if ( ( GetKey->ExpectedAuth != WxNone ) &&
                 ( GetKey->ExpectedAuth != WxStored ) &&
                 ( GetKey->ExpectedAuth != WxPrompt ) &&
                 ( GetKey->ExpectedAuth != WxDisk ) )
            {
                Message->Status = STATUS_INVALID_PARAMETER ;
                break;
            }

            if ( GetKey->BufferSize > 16 )
            {
                Message->Status = STATUS_INVALID_PARAMETER ;
                break;
            }

            Message->Status = WxGetKeyData( NULL,
                                            GetKey->ExpectedAuth,
                                            GetKey->BufferSize,
                                            GetKey->Buffer,
                                            &GetKey->BufferData
                                            );
            break;

        case WxReportResultsApi:
            ReportResults = &Message->Parameters.ReportResults ;

            Message->Status = WxReportResults( NULL,
                                               ReportResults->Status
                                               );

            break;

        default:
            Message->Status = STATUS_NOT_IMPLEMENTED ;
            break;

    }

    return NtReplyPort( Client, &Message->Message );
}


NTSTATUS
WxServerThread(
    PVOID Ignored
    )
{
    HANDLE Port ;
    HANDLE ClientPort = NULL ;
    HANDLE RejectPort ;
    OBJECT_ATTRIBUTES Obja ;
    UNICODE_STRING PortName ;
    NTSTATUS Status ;
    WXLPC_MESSAGE Message ;
    PVOID Context ;


    //
    // Initialize the port:
    //

    RtlInitUnicodeString( &PortName, WX_PORT_NAME );

    InitializeObjectAttributes( &Obja,
                                &PortName,
                                0,
                                NULL,
                                NULL );

    Status = NtCreatePort(  &Port,
                            &Obja,
                            sizeof( ULONG ),
                            sizeof( WXLPC_MESSAGE ),
                            sizeof( WXLPC_MESSAGE )
                            );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Now, wait for a connection:
    //

    Context = NULL ;

    while ( Port )
    {
        Status = NtReplyWaitReceivePort(Port,
                                        &Context,
                                        NULL,
                                        &Message.Message );

        if ( !NT_SUCCESS( Status ) )
        {
            NtClose( Port );

            break;

        }

        switch ( Message.Message.u2.s2.Type )
        {
            case LPC_REQUEST:

                //DbgPrint( "Received request\n" );

                WxpHandleRequest( ClientPort, &Message );

                break;

            case LPC_PORT_CLOSED:

                //DbgPrint( "Received Port Close\n" );

                NtClose( ClientPort );

                NtClose( Port );

                WxClientDisconnect( NULL );

                Port = NULL ;

                break;

            case LPC_CONNECTION_REQUEST:

                //DbgPrint( "Received connection request\n" );
                if ( Context != NULL )
                {
                    Status = NtAcceptConnectPort(
                                    &RejectPort,
                                    NULL,
                                    (PPORT_MESSAGE) &Message,
                                    FALSE,
                                    NULL,
                                    NULL);

                    break;

                }
                else
                {
                    Status = NtAcceptConnectPort(
                                    &ClientPort,
                                    &ClientPort,
                                    &Message.Message,
                                    TRUE,
                                    NULL,
                                    NULL );

                    if ( NT_SUCCESS( Status ) )
                    {
                        NtCompleteConnectPort( ClientPort );
                    }

                }
            default:
                break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\catdbsvc\catdbcli.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catdbcli.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include "unicode.h"
#include "catdb.h"
#include "catdbcli.h"
#include "..\..\cryptsvc\service.h"
#include "errlog.h"
#include "waitsvc.h"

#ifndef KEYSVC_LOCAL_ENDPOINT
#define KEYSVC_LOCAL_ENDPOINT              (L"keysvc")
#endif

#ifndef KEYSVC_LOCAL_PROT_SEQ
#define KEYSVC_LOCAL_PROT_SEQ              (L"ncalrpc")
#endif

#define CATDBCLI_LOGERR_LASTERR()          ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBCLI, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBCLI_LOGERR(x)                 ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBCLI, \
                                                            __LINE__, \
                                                            x, \
                                                            FALSE, \
                                                            FALSE);

#define MAX_RPCRETRIES 20

void
_SSCatDBTeardownRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    RpcBindingFree(phRPCBinding);
}


DWORD
_SSCatDBSetupRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    unsigned short              *pStringBinding = NULL;
    RPC_STATUS                  rpcStatus       = RPC_S_OK;
    static                      BOOL fDone      = FALSE;
    RPC_SECURITY_QOS            RpcSecurityQOS;
    SID_IDENTIFIER_AUTHORITY    SIDAuth         = SECURITY_NT_AUTHORITY;;
    PSID                        pSID            = NULL;
    WCHAR                       szName[64];
    DWORD                       cbName          = 64;
    WCHAR                       szDomainName[256]; // max domain is 255
    DWORD                       cbDomainName    = 256;
    SID_NAME_USE                Use;

    //
    // wait for the service to be available before attempting bind
    //
    if (!WaitForCryptService(SZSERVICENAME, &fDone, TRUE))
    {
        CATDBCLI_LOGERR_LASTERR()

        if (GetLastError() == ERROR_SERVICE_DISABLED)
        {
            return ERROR_SERVICE_DISABLED;
        }
        else
        {
            return ERROR_SERVICE_NOT_ACTIVE;
        }
    }

    //
    // get a binding handle
    //
    if (RPC_S_OK != (rpcStatus = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short *)KEYSVC_LOCAL_PROT_SEQ,
                            NULL, //LPC - no machine name
                            (unsigned short *)KEYSVC_LOCAL_ENDPOINT,
                            0,
                            &pStringBinding)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        goto Ret;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingFromStringBindingW(
                            pStringBinding,
                            phRPCBinding)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        goto Ret;
    }

    if (RPC_S_OK != (rpcStatus = RpcEpResolveBinding(
                            *phRPCBinding,
                            ICatDBSvc_v1_0_c_ifspec)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        _SSCatDBTeardownRPCConnection(phRPCBinding);
        goto Ret;
    }

    //
    // Set the autorization so that we will only call a Local Service process
    //
    memset(&RpcSecurityQOS, 0, sizeof(RpcSecurityQOS));
    RpcSecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    RpcSecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RpcSecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    RpcSecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

   if (AllocateAndInitializeSid(&SIDAuth, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSID) == 0)
    {
        CATDBCLI_LOGERR_LASTERR()
        goto Ret;
    }

    if (LookupAccountSidW(NULL,
                         pSID,
                         szName,
                         &cbName,
                         szDomainName,
                         &cbDomainName,
                         &Use) == 0)
    {
        CATDBCLI_LOGERR_LASTERR()
        goto Ret;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingSetAuthInfoExW(
                            *phRPCBinding,
                            szName,
                            RPC_C_AUTHN_LEVEL_PKT,
                            RPC_C_AUTHN_WINNT,
                            NULL,
                            0,
                            &RpcSecurityQOS)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        goto Ret;
    }

Ret:
    if (pStringBinding != NULL)
    {
        RpcStringFreeW(&pStringBinding);
    }

    if (pSID != NULL)
    {
        FreeSid( pSID );
    }

    return ((DWORD) rpcStatus);
}


DWORD
Client_SSCatDBAddCatalog(
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR *ppwszCatalogNameUsed)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBAddCatalog(
                        hRPCBinding,
                        dwFlags,
                        pwszSubSysGUID,
                        pwszCatalogFile,
                        pwszCatName,
                        ppwszCatalogNameUsed);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD Client_SSCatDBDeleteCatalog(
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBDeleteCatalog(
                        hRPCBinding,
                        dwFlags,
                        pwszSubSysGUID,
                        pwszCatalogFile);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD
Client_SSCatDBEnumCatalogs(
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [size_is][in] */ BYTE *pbHash,
    /* [in] */ DWORD cbHash,
    /* [out] */ DWORD *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR **pppwszCatalogNames)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBEnumCatalogs(
                        hRPCBinding,
                        dwFlags,
                        pwszSubSysGUID,
                        cbHash,
                        pbHash,
                        pdwNumCatalogNames,
                        pppwszCatalogNames);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD
Client_SSCatDBRegisterForChangeNotification(
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBRegisterForChangeNotification(
                        hRPCBinding,
                        EventHandle,
                        dwFlags,
                        pwszSubSysGUID,
                        fUnRegister);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD
Client_SSCatDBPauseResumeService(
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBPauseResumeService(
                    hRPCBinding,
                    dwFlags,
                    fResume);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\catdbsvc\catdbcli.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catdbcli.h
//
//--------------------------------------------------------------------------

#ifndef _CATDBCLI_H_
#define _CATDBCLI_H_


#ifdef __cplusplus
extern "C" {
#endif

DWORD
Client_SSCatDBAddCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR *ppwszCatalogNameUsed);

DWORD 
Client_SSCatDBDeleteCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile);

DWORD
Client_SSCatDBEnumCatalogs( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [size_is][in] */ BYTE *pbHash,
    /* [in] */ DWORD cbHash,
    /* [out] */ DWORD *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR **pppwszCatalogNames);

DWORD
Client_SSCatDBRegisterForChangeNotification( 
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister);

DWORD Client_SSCatDBPauseResumeService( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume);


#ifdef __cplusplus
}
#endif

#endif // _CATDBCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\debug\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//
//	03/20/96    kevinr      wrote it
//  04/17/96    kevinr      added OSS init
//  05-Sep-1997 pberkman    added sub-system debug.
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <asn1code.h>

#if DBG

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <crtdbg.h>

#include "pkicrit.h"
#include "dbgdef.h"

// set DEBUG_MASK=0x26
LPSTR pszDEBUG_MASK = "DEBUG_MASK";
#define DEBUG_MASK_DELAY_FREE_MEM   _CRTDBG_DELAY_FREE_MEM_DF /* 0x02 */
#define DEBUG_MASK_CHECK_ALWAYS     _CRTDBG_CHECK_ALWAYS_DF   /* 0x04 */
#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */
#define DEBUG_MASK_MEM \
(DEBUG_MASK_DELAY_FREE_MEM | DEBUG_MASK_CHECK_ALWAYS | DEBUG_MASK_LEAK_CHECK)


// from asn1code.h:
//      #define DEBUGPDU     0x02 /* produce tracing output */
//      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
// set OSS_DEBUG_MASK=0x02        
// set OSS_DEBUG_MASK=0x10        - only print decoder errors
LPSTR pszOSS_DEBUG_MASK = "OSS_DEBUG_MASK";

// receives trace output
LPSTR pszOSS_DEBUG_TRACEFILE = "OSS_DEBUG_TRACEFILE";

static char  *pszDEBUG_PRINT_MASK   = "DEBUG_PRINT_MASK";
static char  *pszDefualtSSTag       = "ISPU";

static DBG_SS_TAG sSSTags[]         = __DBG_SS_TAGS;

static CRITICAL_SECTION DbgCriticalSection;

#define OSS_SET_DECODING_FLAGS_PROC_IDX     0
#define OSS_SET_ENCODING_FLAGS_PROC_IDX     1
#define OSS_OPEN_TRACE_FILE_PROC_IDX        2
#define OSS_PROC_CNT                        3

static LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossSetDecodingFlags",
    "ossSetEncodingFlags",
    "ossOpenTraceFile"
};

static void *rgpvOssProc[OSS_PROC_CNT];
static HMODULE hmsossDll = NULL;
static BOOL fLoadedOss = FALSE;

static void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

static void OssLoad()
{
    DWORD i;

    if (fLoadedOss)
        return;

    EnterCriticalSection(&DbgCriticalSection);

    if (fLoadedOss)
        goto LeaveReturn;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto msossLoadLibraryError;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto msossGetProcAddressError;
    }

LeaveReturn:
    LeaveCriticalSection(&DbgCriticalSection);
CommonReturn:
    fLoadedOss = TRUE;
    return;

ErrorReturn:
    LeaveCriticalSection(&DbgCriticalSection);
    OssUnload();
    goto CommonReturn;
TRACE_ERROR(msossLoadLibraryError)
TRACE_ERROR(msossGetProcAddressError)
}

typedef int      (DLL_ENTRY* pfnossSetDecodingFlags)(struct ossGlobal *world,
							unsigned long flags);

static int DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetDecodingFlags)
            rgpvOssProc[OSS_SET_DECODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int      (DLL_ENTRY* pfnossSetEncodingFlags)(struct ossGlobal *world,
							unsigned long flags);

static int DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetEncodingFlags)
            rgpvOssProc[OSS_SET_ENCODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int  (DLL_ENTRY*  pfnossOpenTraceFile)(struct ossGlobal *world,
				char                    *fileName);

static int  DLL_ENTRY ossOpenTraceFile(struct ossGlobal *world,
				char                    *fileName)
{
    if (hmsossDll)
        return ((pfnossOpenTraceFile)
            rgpvOssProc[OSS_OPEN_TRACE_FILE_PROC_IDX])(
                world,
                fileName);
    else
        return API_DLL_NOT_LINKED;
}

// 
//+-------------------------------------------------------------------------
//
//  Pithy stubs to create stdcall proc from cdecl
//
//--------------------------------------------------------------------------
void*
_stdcall
scMalloc( size_t size)
{
    return malloc(size);
}

void*
_stdcall
scRealloc( void *memblock, size_t size)
{
    return realloc(memblock, size);
}

void
_stdcall
scFree( void *memblock)
{
    free(memblock);
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgGetDebugFlags
//
//  Synopsis:  Get the debug flags.
//
//  Returns:   the debug flags
//
//--------------------------------------------------------------------------
int
WINAPI
DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv( pszDEBUG_MASK))
        iDebugFlags = strtol( pszEnvVar, &p, 16);

    return iDebugFlags;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessAttach
//
//  Synopsis:  Handle process attach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessAttach()
{
    int     tmpFlag;

#ifdef _DEBUG

    tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );    // get current
    tmpFlag |=  DbgGetDebugFlags();     // enable flags
    tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;   // disable CRT block checking
    _CrtSetDbgFlag( tmpFlag);           // set new value
#endif

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessDetach
//
//  Synopsis:  Handle process detach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessDetach()
{
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug.
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    char    *pszEnvVar;
    char    *p;

  __try {
    // Attempt to do delay, demand loading of msoss.dll
    OssLoad();

    // from asn1code.h:
    //      #define DEBUGPDU 0x02     /* produce tracing output */
    //      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
    // set OSS_DEBUG_MASK=0x02
    // set OSS_DEBUG_MASK=0x10        - only print decoder errors
    if (pszEnvVar = getenv( pszOSS_DEBUG_MASK)) {
        unsigned long ulEnvVar;
        ulEnvVar = strtoul( pszEnvVar, &p, 16) & (DEBUGPDU | DEBUG_ERRORS);
        if ( ulEnvVar)
            ossSetDecodingFlags( pog, ulEnvVar | RELAXBER);
        if ( DEBUGPDU & ulEnvVar)
            ossSetEncodingFlags( pog, DEBUGPDU | FRONT_ALIGN);
        else
            ossSetEncodingFlags( pog, FRONT_ALIGN);
    } else {
        ossSetDecodingFlags( pog, DEBUG_ERRORS | RELAXBER);
        ossSetEncodingFlags( pog, FRONT_ALIGN);
    }

    if (pszEnvVar = getenv( pszOSS_DEBUG_TRACEFILE))
        ossOpenTraceFile( pog, pszEnvVar);

#ifdef _DEBUG
    if (DbgGetDebugFlags() & DEBUG_MASK_MEM) {
        pog->mallocp = scMalloc;
        pog->reallocp = scRealloc;
        pog->freep = scFree;
    }
#else
    pog->mallocp = scMalloc;
    pog->reallocp = scRealloc;
    pog->freep = scFree;
#endif
    return TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    return FALSE;
  }
}


//+-------------------------------------------------------------------------
//
//  Function:  DebugDllMain
//
//  Synopsis:  Initialize the debug DLL
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DebugDllMain(
        HMODULE hInst,
        ULONG   ulReason,
        LPVOID  lpReserved)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = DbgProcessAttach();
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(&DbgCriticalSection);
            if (!fRet)
                DbgProcessDetach();
        }
        break;

    case DLL_PROCESS_DETACH:
        fRet = DbgProcessDetach();
        OssUnload();
        DeleteCriticalSection(&DbgCriticalSection);
        break;

    default:
        break;
    }

  return fRet;
}


const char *DbgGetSSString(DWORD dwSubSystemId)
{
    DBG_SS_TAG  *psSS;

    psSS = &sSSTags[0];

    while (psSS->dwSS > 0)
    {
        if ((psSS->dwSS & dwSubSystemId) > 0)
        {
            if (psSS->pszTag)
            {
                return(psSS->pszTag);
            }

            return(pszDefualtSSTag);
        }

        psSS++;
    }

    return(pszDefualtSSTag);
}

static BOOL DbgIsSSActive(DWORD dwSSIn)
{
    char    *pszEnvVar;
    DWORD   dwEnv;

    dwEnv = 0;

    if (pszEnvVar = getenv(pszDEBUG_PRINT_MASK))
    {
        dwEnv = (DWORD)strtol(pszEnvVar, NULL, 16);
    }


    return((dwEnv & dwSSIn) > 0);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    va_list arglist;
    CHAR    ach1[1024];
    CHAR    ach2[1080];
    int     cch;
    HANDLE  hStdOut;
    DWORD   cb;
    DWORD   dwErr;

    dwErr = GetLastError();

    if (!(DbgIsSSActive(dwSubSystemId)))
    {
        SetLastError(dwErr);
        return(0);
    }

    _try 
    {
        va_start(arglist, lpFmt);

        _vsnprintf( ach1, sizeof(ach1), lpFmt, arglist);

        va_end(arglist);

        cch = wsprintf(ach2,"%s: %s", DbgGetSSString(dwSubSystemId), ach1);

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hStdOut != INVALID_HANDLE_VALUE)
        {
            WriteConsole( hStdOut, ach2, strlen(ach2), &cb, NULL);
        }

        OutputDebugString(ach2);

    } _except( EXCEPTION_EXECUTE_HANDLER) 
    {
        // return failure
        cch = 0;
    }
    SetLastError(dwErr);
    return cch;
}

#else

#ifdef __cplusplus
    extern "C"
    {
#endif

BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog);

int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...);


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug. Do nothing in retail builds
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//		Nothing in retail builds
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{

    return(0);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\dpapi\nt5wrap.cpp ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    nt5wrap.cpp

Abstract:

    Client side CryptXXXData calls.

    Client funcs are preceeded by "CS" == Client Side
    Server functions are preceeded by "SS" == Server Side

Author:

    Scott Field (sfield)    14-Aug-97

Revisions:

    Todds                   04-Sep-97       Ported to .dll
    Matt Thomlinson (mattt) 09-Oct-97       Moved to common area for link by crypt32
    philh                   03-Dec-97       Added I_CertProtectFunction
    philh                   29-Sep-98       Renamed I_CertProtectFunction to
                                            I_CertCltProtectFunction.
                                            I_CertProtectFunction was moved to
                                            ..\ispu\pki\certstor\protroot.cpp

--*/

#ifndef _CRYPT32_
#define _CRYPT32_   // use correct Dll Linkage
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <sha.h>
#include "crypt.h"

#include <lm.h>
#include <malloc.h>

#include "unicode.h"
#include "certprot.h"

// midl generated files
#include "dprpc.h"

#include "dpapiprv.h"


// fwds
RPC_STATUS BindW(
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );

RPC_STATUS BindBackupKeyW(
    LPCWSTR szComputerName,
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );

RPC_STATUS UnbindW(
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );


BOOL
WINAPI
CryptProtectData(
        DATA_BLOB*      pDataIn,
        LPCWSTR         szDataDescr,
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    RPC_BINDING_HANDLE h = NULL;
    LPWSTR pszBinding;
    RPC_STATUS RpcStatus;

    BYTE rgbPasswordHash[ A_SHA_DIGEST_LEN ];
    LPCWSTR wszDescription = szDataDescr?szDataDescr:L"";
    LPWSTR szAlternateDataDescription = (LPWSTR)wszDescription;
    DWORD dwRetVal = ERROR_INVALID_PARAMETER;
    PBYTE pbTempIn = NULL;
    DWORD cbTempIn;

    // check params
    if ((pDataOut == NULL) ||
        (pDataIn == NULL) ||
        (pDataIn->pbData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcStatus = BindW(&pszBinding, &h);
    if(RpcStatus != RPC_S_OK) 
    {
        SetLastError(RpcStatus);
        return FALSE;
    }

    __try {
        PBYTE pbOptionalPassword = NULL;
        DWORD cbOptionalPassword = 0;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT PromptStruct;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT *pLocalPromptStruct = NULL;

        // zero so client stub allocates
        ZeroMemory(pDataOut, sizeof(DATA_BLOB));

        //
        // only call UI function if prompt flags dictate, because we don't
        // want to bring in cryptui.dll unless necessary.
        //

        if( (pPromptStruct != NULL) &&
            ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
             (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
            )
        {

            dwRetVal = I_CryptUIProtect(
                                    pDataIn,
                                    pPromptStruct,
                                    dwFlags,
                                    (PVOID*)&szAlternateDataDescription,
                                    TRUE,
                                    rgbPasswordHash
                                    );

            //
            // If UI dictated strong security, then supply the hash.
            //

            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                cbOptionalPassword = sizeof(rgbPasswordHash);
                pbOptionalPassword = rgbPasswordHash;
            }
        } 
        else 
        {
            dwRetVal = ERROR_SUCCESS;
        }


        //
        // Temporarily encrypt the input buffer, so that it's protected 
        // in the case where RPC leaves memory buffers laying around.
        //

        if( dwRetVal == ERROR_SUCCESS ) 
        {
            DWORD cbPadding;
            NTSTATUS Status;
    
            cbPadding = RTL_ENCRYPT_MEMORY_SIZE - pDataIn->cbData % RTL_ENCRYPT_MEMORY_SIZE;
    
            cbTempIn = pDataIn->cbData + cbPadding;
            pbTempIn = (PBYTE)LocalAlloc(LMEM_FIXED, cbTempIn);
            if(pbTempIn != NULL)
            {
                CopyMemory(pbTempIn, pDataIn->pbData, pDataIn->cbData);
                FillMemory(pbTempIn + pDataIn->cbData, cbPadding, (BYTE)cbPadding);
            }
            else
            {
                dwRetVal = ERROR_OUTOFMEMORY;
            }
    
            if( dwRetVal == ERROR_SUCCESS ) 
            {
                Status = RtlEncryptMemory(pbTempIn,
                                          cbTempIn,
                                          RTL_ENCRYPT_OPTION_SAME_LOGON);
        
                if(!NT_SUCCESS(Status))
                {
                    dwRetVal = ERROR_ENCRYPTION_FAILED;
                }
            }
        }


        //
        // Call over to the lsass.exe process, where the input buffer will be
        // encrypted using the appropriate user (or machine) credentials.
        //

        if( dwRetVal == ERROR_SUCCESS ) 
        {
            if(pPromptStruct != NULL)
            {
                ZeroMemory(&PromptStruct, sizeof(PromptStruct));
                PromptStruct.cbSize = sizeof(PromptStruct);
                PromptStruct.dwPromptFlags = pPromptStruct->dwPromptFlags;
                pLocalPromptStruct = &PromptStruct;
            }

            dwRetVal = SSCryptProtectData(
                        h,
                        &pDataOut->pbData,
                        &pDataOut->cbData,
                        pbTempIn,
                        cbTempIn,
                        szAlternateDataDescription,
                        (pOptionalEntropy) ? pOptionalEntropy->pbData : NULL,
                        (pOptionalEntropy) ? pOptionalEntropy->cbData : 0,
                        pLocalPromptStruct, 
                        dwFlags,
                        pbOptionalPassword,
                        cbOptionalPassword
                        );
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    UnbindW(&pszBinding, &h);

    RtlSecureZeroMemory( rgbPasswordHash, sizeof(rgbPasswordHash) );

    if( szAlternateDataDescription &&
        szAlternateDataDescription != wszDescription )
    {
        LocalFree( szAlternateDataDescription );
    }

    if(pbTempIn != NULL)
    {
        RtlSecureZeroMemory(pbTempIn, cbTempIn);
        LocalFree(pbTempIn);
    }

    if(dwRetVal != ERROR_SUCCESS) 
    {
        SetLastError(dwRetVal);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
CryptUnprotectData(
        DATA_BLOB*      pDataIn,             // in encr blob
        LPWSTR*         ppszDataDescr,       // out
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    RPC_BINDING_HANDLE h = NULL;
    LPWSTR pszBinding;
    RPC_STATUS RpcStatus;

    BYTE rgbPasswordHash[ A_SHA_DIGEST_LEN ];
    DWORD dwRetVal;
    DWORD dwRetryCount = 0;

    // check params
    if ((pDataOut == NULL) ||
        (pDataIn == NULL) ||
        (pDataIn->pbData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    RpcStatus = BindW(&pszBinding, &h);
    if(RpcStatus != RPC_S_OK) 
    {
        SetLastError(RpcStatus);
        return FALSE;
    }

    __try {
        CRYPTPROTECT_PROMPTSTRUCT DerivedPromptStruct;
        PBYTE pbOptionalPassword = NULL;
        DWORD cbOptionalPassword = 0;
        LPCWSTR szDataDescr;
        LPUWSTR szDataDescrUnaligned;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT PromptStruct;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT *pLocalPromptStruct = NULL;

        //
        // define outer+inner wrapper for security blob.
        // this won't be necessary once SAS support is provided by the OS.
        //

        typedef struct {
            DWORD dwOuterVersion;
            GUID guidProvider;

            DWORD dwVersion;
            GUID guidMK;
            DWORD dwPromptFlags;
            DWORD cbDataDescr;
            WCHAR szDataDescr[1];
        } sec_blob, *psec_blob;

        sec_blob UNALIGNED *SecurityBlob = (sec_blob*)(pDataIn->pbData);


        //
        // zero so client stub allocates
        //

        ZeroMemory(pDataOut, sizeof(DATA_BLOB));

        if (ppszDataDescr)
            *ppszDataDescr = NULL;


        //
        // recreate the promptstruct and DataDescr from the security blob.
        //

        DerivedPromptStruct.cbSize = sizeof(DerivedPromptStruct);
        DerivedPromptStruct.dwPromptFlags = SecurityBlob->dwPromptFlags;

	    //
	    // SecurityBlob may be unaligned.  Set szDataDescr to reference
	    // an aligned copy.
	    //

        szDataDescrUnaligned = (SecurityBlob->szDataDescr);
	    WSTR_ALIGNED_STACK_COPY(&szDataDescr,szDataDescrUnaligned);

        if( pPromptStruct )
        {
            DerivedPromptStruct.hwndApp = pPromptStruct->hwndApp;
            DerivedPromptStruct.szPrompt = pPromptStruct->szPrompt;
        } else {
            DerivedPromptStruct.szPrompt = NULL;
            DerivedPromptStruct.hwndApp = NULL;
        }


retry:

        //
        // determine if UI is to be raised, and what type.
        //

        //
        // only call UI function if prompt flags dictate, because we don't
        // want to bring in cryptui.dll unless necessary.
        //

        if( ((DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
             (DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
            )
        {

            dwRetVal = I_CryptUIProtect(
                            pDataIn,
                            &DerivedPromptStruct,
                            dwFlags,
                            (PVOID*)&szDataDescr,
                            FALSE,
                            rgbPasswordHash
                            );

            //
            // If UI dictated strong security, then supply the hash.
            //

            if( DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                cbOptionalPassword = sizeof(rgbPasswordHash);
                pbOptionalPassword = rgbPasswordHash;
            }

        } else {
            if( DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                dwRetVal = ERROR_INVALID_PARAMETER;
            } else {
                dwRetVal = ERROR_SUCCESS;
            }
        }


        //
        // make the RPC call to attempt to unprotect the data.
        //

        if( dwRetVal == ERROR_SUCCESS ) 
        {
            if(pPromptStruct != NULL)
            {
                ZeroMemory(&PromptStruct, sizeof(PromptStruct));
                PromptStruct.cbSize = sizeof(PromptStruct);
                PromptStruct.dwPromptFlags = pPromptStruct->dwPromptFlags;
                pLocalPromptStruct = &PromptStruct;
            }

            dwRetVal = SSCryptUnprotectData(
                        h,
                        &pDataOut->pbData,
                        &pDataOut->cbData,
                        pDataIn->pbData,
                        pDataIn->cbData,
                        ppszDataDescr,
                        (pOptionalEntropy) ? pOptionalEntropy->pbData : NULL,
                        (pOptionalEntropy) ? pOptionalEntropy->cbData : 0,
                        pLocalPromptStruct,
                        dwFlags,
                        pbOptionalPassword,
                        cbOptionalPassword
                        );

            if( (dwRetVal == ERROR_INVALID_DATA) &&
                (DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG))
            {
                //
                // The data did not decrypt correctly, so warn the user that 
                // the password might have been entered incorrectly and let them
                // try it again up to 3 times.
                //

                I_CryptUIProtectFailure(
                                &DerivedPromptStruct,
                                dwFlags,
                                (PVOID*)&szDataDescr);

                if( dwRetryCount++ < 3 )
                {
                    goto retry;
                }
            }


            if(dwRetVal == ERROR_SUCCESS || dwRetVal == CRYPT_I_NEW_PROTECTION_REQUIRED)
            {
                if(pDataOut->cbData > 0)
                {
                    NTSTATUS Status;
                    DWORD cbPadding;

                    // Decrypt output buffer.
                    Status = RtlDecryptMemory(pDataOut->pbData,
                                              pDataOut->cbData,
                                              RTL_ENCRYPT_OPTION_SAME_LOGON);
                    if(!NT_SUCCESS(Status))
                    {
                        dwRetVal = ERROR_DECRYPTION_FAILED;
                    }

                    // Remove padding
                    if(dwRetVal == ERROR_SUCCESS)
                    {
                        cbPadding = pDataOut->pbData[pDataOut->cbData - 1];

                        if((cbPadding > 0) &&
                           (cbPadding <= pDataOut->cbData) && 
                           (cbPadding <= RTL_ENCRYPT_MEMORY_SIZE))
                        {
                            pDataOut->cbData -= cbPadding;
                        }
                        else
                        {
                            dwRetVal = ERROR_INVALID_DATA;
                        }
                    }
                }
            }
        }


    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    RtlSecureZeroMemory( rgbPasswordHash, sizeof(rgbPasswordHash) );

    UnbindW(&pszBinding, &h);

    if((dwFlags & CRYPTPROTECT_VERIFY_PROTECTION ) &&
       ((CRYPT_I_NEW_PROTECTION_REQUIRED == dwRetVal) || 
        (ERROR_SUCCESS == dwRetVal)))
    {
        SetLastError(dwRetVal);
        return TRUE;
    }

    if(dwRetVal != ERROR_SUCCESS) 
    {
        SetLastError(dwRetVal);
        return FALSE;
    }

    return TRUE;
}


C_ASSERT(CRYPTPROTECTMEMORY_SAME_PROCESS == 0);
C_ASSERT(CRYPTPROTECTMEMORY_CROSS_PROCESS == RTL_ENCRYPT_OPTION_CROSS_PROCESS);
C_ASSERT(CRYPTPROTECTMEMORY_SAME_LOGON == RTL_ENCRYPT_OPTION_SAME_LOGON);

WINCRYPT32API
BOOL
WINAPI
CryptProtectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to encrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags
    )
{
    NTSTATUS Status;
    
    Status = RtlEncryptMemory(pDataIn, cbDataIn, dwFlags);

    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    }

    SetLastError( LsaNtStatusToWinError( Status ));

    return FALSE;
}

WINCRYPT32API
BOOL
WINAPI
CryptUnprotectMemory(
    IN OUT          LPVOID          pDataIn,             // in out data to decrypt
    IN              DWORD           cbDataIn,            // multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
    IN              DWORD           dwFlags
    )
{
    NTSTATUS Status;
    
    Status = RtlDecryptMemory(pDataIn, cbDataIn, dwFlags);

    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    }

    SetLastError( LsaNtStatusToWinError( Status ));

    return FALSE;
}


RPC_STATUS BindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            (unsigned short * *)pszBinding
                            );

    if (status)
    {
        return(status);
    }

    status = RpcBindingFromStringBindingW((unsigned short *)*pszBinding, phBind);

    return status;
}


RPC_STATUS UnbindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringFreeW((unsigned short **)pszBinding);

    if (status)
    {
        return(status);
    }

    RpcBindingFree(phBind);

    return RPC_S_OK;
}


void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return LocalAlloc(LMEM_FIXED, len);
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    ZeroMemory(ptr, LocalSize( ptr ));
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\dpapi\reset.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    reset.c

Abstract:

    This module contains client side code to handle the reset machine
    credentials operation.

Author:

    John Banes (jbanes)    July 5, 2001

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>

#include <wincrypt.h>

extern "C" {
#include <ntsam.h>
#include <ntsamp.h>
}
#include "passrec.h"

DWORD
WINAPI
CryptResetMachineCredentials(
    DWORD dwFlags)
{
    BYTE BufferIn[8] = {0};
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    DWORD dwRetVal;
    NTSTATUS Status;

    //
    // Call SamiChangeKeys to reset syskey and SAM stuff.
    // If this fails, don't bother reseting DPAPI keys.
    //

    Status = SamiChangeKeys();
    if (!NT_SUCCESS(Status))
    {
	//
	// Convert the ntstatus to a winerror
        //

        return(RtlNtStatusToDosError(Status));
    }

    //
    // Reset DPAPI LSA secret and reencrypt all of the local machine
    // master keys.
    //

    DataIn.pbData = BufferIn;
    DataIn.cbData = sizeof(BufferIn);

    if(!CryptProtectData(&DataIn,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         CRYPTPROTECT_CRED_REGENERATE,
                         &DataOut))
    {
        dwRetVal = GetLastError();
        return dwRetVal;
    }

    //
    // Force a flush 
    //

     RegFlushKey(HKEY_LOCAL_MACHINE);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\dpapi\passrec.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrec.c

Abstract:

    This module contains client side code to handle the local key recovery case.

Author:

    Pete Skelly (petesk)    May 9, 2000

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>

#include <shlobj.h>
#include <userenv.h>

#include <wincrypt.h>
#include "passrecp.h"
#include "dpapiprv.h"
#include "pasrec.h"
#include "passrec.h"

#define FILETIME_TICKS_PER_SECOND  10000000
#define RECOVERYKEY_LIFETIME (60*60*24*365*5) // 5 Years


DWORD 
PRRecoverPassword(
    IN  LPWSTR pszUsername,
    IN  PBYTE pbRecoveryPrivate,
    IN  DWORD cbRecoveryPrivate,
    IN  LPWSTR pszNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    unsigned short *pszBinding;


    if((NULL == pszUsername) ||
       (NULL == pbRecoveryPrivate) ||
       (NULL == pszNewPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {
        dwError = SSRecoverPassword(h,
                                    (PBYTE)pszUsername,
                                    (wcslen(pszUsername) + 1) * sizeof(WCHAR),
                                    pbRecoveryPrivate,
                                    cbRecoveryPrivate,
                                    (PBYTE)pszNewPassword,
                                    (wcslen(pszNewPassword) + 1) * sizeof(WCHAR));
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }

    return dwError;
}


DWORD
PRQueryStatus(
    IN OPTIONAL LPWSTR pszDomain,
    IN OPTIONAL LPWSTR pszUserName,
    OUT DWORD *pdwStatus)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    WCHAR *pszBinding;
    WCHAR szUserName[UNLEN + 1];
    DWORD cchUserName;

    if(NULL == pdwStatus)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the caller didn't specify a username, then use the
    // username of the calling thread.
    //

    if(pszUserName == NULL)
    {
        pszUserName = szUserName;

        cchUserName = sizeof(szUserName) / sizeof(WCHAR);
        if(!GetUserNameW(szUserName, &cchUserName))
        {
            return GetLastError();
        }
    }


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {
        dwError = SSRecoverQueryStatus(
                                        h,
                                        (PBYTE)pszUserName,
                                        (wcslen(pszUserName) + 1) * sizeof(WCHAR),
                                        pdwStatus);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }

    return dwError;
}



DWORD
PRImportRecoveryKey(
    IN LPWSTR pszUsername,
    IN LPWSTR pszCurrentPassword,
    IN BYTE* pbRecoveryPublic,
    IN DWORD cbRecoveryPublic)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    unsigned short *pszBinding;

    if((NULL == pbRecoveryPublic) ||
       (0 == cbRecoveryPublic) ||
       (NULL == pszUsername) ||
       (NULL == pszCurrentPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }
    


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {

        dwError = SSRecoverImportRecoveryKey(
                                        h,
                                        (PBYTE)pszUsername,
                                        (wcslen(pszUsername) + 1) * sizeof(WCHAR),
                                        (PBYTE)pszCurrentPassword,
                                        (wcslen(pszCurrentPassword) + 1) * sizeof(WCHAR),
                                        pbRecoveryPublic,
                                        cbRecoveryPublic);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }

    return dwError;
}


DWORD GenerateRecoveryCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           LPWSTR pszUsername,
                           PSID pSid,
                           PBYTE *ppbPublicExportData,
                           DWORD *pcbPublicExportLength)
{

    DWORD           dwError = ERROR_SUCCESS;

    CERT_INFO       CertInfo;
    CERT_PUBLIC_KEY_INFO *pKeyInfo = NULL;
    DWORD                 cbKeyInfo = 0;
    CERT_NAME_BLOB  CertName;
    CERT_RDN_ATTR   RDNAttributes[1];
    CERT_RDN        CertRDN[] = {1, RDNAttributes} ;
    CERT_NAME_INFO  NameInfo = {1, CertRDN};
    PCCERT_CONTEXT  pCertContext = NULL;

    GUID GuidKey;


    CertName.pbData = NULL;
    CertName.cbData = 0;

    RDNAttributes[0].Value.pbData = NULL;
    RDNAttributes[0].Value.cbData = 0;

    DWORD cbCertSize = 0;
    PBYTE pbCert = NULL;
    DWORD cSize = 0;


    dwError = UuidCreate( &GuidKey );

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    // Generate a self-signed cert structure

    RDNAttributes[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RDNAttributes[0].pszObjId =    szOID_COMMON_NAME;


    RDNAttributes[0].Value.cbData = wcslen(pszUsername) * sizeof(WCHAR);

    RDNAttributes[0].Value.pbData = (PBYTE)pszUsername;


    //
    // Get the actual public key info from the key
    //
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             NULL,
                             &cbKeyInfo))
    {
        dwError = GetLastError();
        goto error;
    }
    pKeyInfo = (CERT_PUBLIC_KEY_INFO *)midl_user_allocate(cbKeyInfo);
    if(NULL == pKeyInfo)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             pKeyInfo,
                             &cbKeyInfo))
    {
        dwError = GetLastError();
        goto error;

    }

    // 
    // Generate the certificate name
    //

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          NULL,
                          &CertName.cbData))
    {
        dwError = GetLastError();
        goto error;
    }

    CertName.pbData = (PBYTE)midl_user_allocate(CertName.cbData);
    if(NULL == CertName.pbData)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          CertName.pbData,
                          &CertName.cbData))
    {
        dwError = GetLastError();
        goto error;
    }



    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.pbData = (PBYTE)&GuidKey;
    CertInfo.SerialNumber.cbData =  sizeof(GUID);
    CertInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    CertInfo.SignatureAlgorithm.Parameters.cbData = 0;
    CertInfo.SignatureAlgorithm.Parameters.pbData = NULL;
    CertInfo.Issuer.pbData = CertName.pbData;
    CertInfo.Issuer.cbData = CertName.cbData;

    GetSystemTimeAsFileTime(&CertInfo.NotBefore);
    CertInfo.NotAfter = CertInfo.NotBefore;
    ((LARGE_INTEGER * )&CertInfo.NotAfter)->QuadPart += 
           Int32x32To64(FILETIME_TICKS_PER_SECOND, RECOVERYKEY_LIFETIME);



    CertInfo.Subject.pbData = CertName.pbData;
    CertInfo.Subject.cbData = CertName.cbData;
    CertInfo.SubjectPublicKeyInfo = *pKeyInfo;
    CertInfo.SubjectUniqueId.pbData = (PBYTE)pSid;
    CertInfo.SubjectUniqueId.cbData = GetLengthSid(pSid);
    CertInfo.SubjectUniqueId.cUnusedBits = 0;
    CertInfo.IssuerUniqueId.pbData = (PBYTE)pSid;
    CertInfo.IssuerUniqueId.cbData = GetLengthSid(pSid);
    CertInfo.IssuerUniqueId.cUnusedBits = 0;
    CertInfo.cExtension = 0;
    CertInfo.rgExtension = NULL;

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      NULL,
                                      &cbCertSize))
    {
        dwError = GetLastError();
        goto error;
    }

    pbCert = (PBYTE)midl_user_allocate(cbCertSize);
    if(NULL == pbCert)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      pbCert,
                                      &cbCertSize))
    {
        dwError = GetLastError();
        goto error;
    }

    *pcbPublicExportLength = cbCertSize;
  
    *ppbPublicExportData = pbCert;

    // Double-check to make sure certificate is valid
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCertSize);
    if(pCertContext == NULL)
    {
        dwError = GetLastError();
        goto error;
    }
    else
    {
        CertFreeCertificateContext(pCertContext);
    }

    pbCert = NULL;

error:
    if(pbCert)
    {
        midl_user_free(pbCert);
    }
    if(pKeyInfo)
    {
        midl_user_free(pKeyInfo);
    }
    if(CertName.pbData)
    {
        midl_user_free(CertName.pbData);
    }

    return dwError;
}

DWORD
PRGenerateRecoveryKey(
    IN  LPWSTR pszUsername,
    IN  LPWSTR pszCurrentPassword,
    OUT PBYTE *ppbRecoveryPrivate,
    OUT DWORD *pcbRecoveryPrivate)
{
    DWORD      dwError = 0;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    DWORD      dwDefaultKeySize = 2048;
    DWORD      cbPrivateExportLength = 0;
    DWORD      cbPublic = 0;
    PBYTE      pbPublic = NULL;
    PBYTE pbRecoveryPrivate = NULL;
    DWORD cbRecoveryPrivate = 0;
    PSID pSid = NULL;
    DWORD cbSid;
    WCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchDomain;
    SID_NAME_USE AcctType;


    //
    // Obtain SID of current user.
    //

    cchDomain = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerNameW(szDomain, &cchDomain))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           NULL,
                           &cbSid,
                           NULL,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
    }

    pSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(cchDomain > MAX_COMPUTERNAME_LENGTH + 1)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           pSid,
                           &cbSid,
                           szDomain,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();
        goto error;
    }


    //
    // Create recovery private key.
    //

    if(!CryptAcquireContext(&hProv,
                            NULL,
                            MS_STRONG_PROV,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CryptGenKey(hProv, 
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE | (dwDefaultKeySize << 16),
                    &hKey))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = GenerateRecoveryCert(hProv,
                           hKey,
                           pszUsername,
                           pSid,
                           &pbPublic,
                           &cbPublic);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


    // 
    // Get the private key size
    //

    if(!CryptExportKey(hKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       NULL,
                       &cbPrivateExportLength))
    {
        dwError = GetLastError();
        goto error;
    }
    cbRecoveryPrivate = 2*sizeof(DWORD) + cbPrivateExportLength;

    pbRecoveryPrivate = (PBYTE)LocalAlloc(LMEM_FIXED, cbRecoveryPrivate);
    if(NULL == pbRecoveryPrivate)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    *(DWORD *)pbRecoveryPrivate = RECOVERY_BLOB_MAGIC;
    *(DWORD *)(pbRecoveryPrivate + sizeof(DWORD)) = RECOVERY_BLOB_VERSION;


    // 
    // Export the private key
    //

    if(!CryptExportKey(hKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       pbRecoveryPrivate + 2*sizeof(DWORD),
                       &cbPrivateExportLength))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = PRImportRecoveryKey(
                           pszUsername,
                           pszCurrentPassword,
                           pbPublic,
                           cbPublic);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }
                   
    *ppbRecoveryPrivate = pbRecoveryPrivate;
    *pcbRecoveryPrivate = cbRecoveryPrivate;

    pbRecoveryPrivate = NULL;


error:

    if(pbRecoveryPrivate)
    {
        RtlSecureZeroMemory(pbRecoveryPrivate, cbRecoveryPrivate);
        LocalFree(pbRecoveryPrivate);
    }

    if(pbPublic)
    {
        LocalFree(pbPublic);
    }

    if(hKey)
    {
        CryptDestroyKey(hKey);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    if(pSid)
    {
        LocalFree(pSid);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\keysvc\server\makefile.inc ===
$(CRYPTO_INC)\$(O)\keysvc.h: $(O)\keysvc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\cerrpc.h: $(O)\cerrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\keysvc\certpcli.cpp ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    nt5wrap.cpp

Abstract:

    Client side CryptXXXData calls.

    Client funcs are preceeded by "CS" == Client Side
    Server functions are preceeded by "SS" == Server Side

Author:

    Scott Field (sfield)    14-Aug-97

Revisions:

    Todds                   04-Sep-97       Ported to .dll
    Matt Thomlinson (mattt) 09-Oct-97       Moved to common area for link by crypt32
    philh                   03-Dec-97       Added I_CertProtectFunction
    philh                   29-Sep-98       Renamed I_CertProtectFunction to
                                            I_CertCltProtectFunction.
                                            I_CertProtectFunction was moved to
                                            ..\ispu\pki\certstor\protroot.cpp
    petesk                  25-Jan-00       Moved to keysvc

--*/



#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include "unicode.h"
#include "waitsvc.h"
#include "certprot.h"

// midl generated files

#include "keyrpc.h"
#include "lenroll.h"
#include "keysvc.h"
#include "keysvcc.h"
#include "cerrpc.h"



// fwds
RPC_STATUS CertBindA(
    RPC_BINDING_HANDLE *phBind
    );


RPC_STATUS CertUnbindA(
    RPC_BINDING_HANDLE *phBind
    );




BOOL
WINAPI
I_CertCltProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    BOOL fResult;
    DWORD dwRetVal;
    RPC_BINDING_HANDLE h = NULL;
    RPC_STATUS RpcStatus;

    BYTE *pbSSOut = NULL;
    DWORD cbSSOut = 0;
    BYTE rgbIn[1];

    if (NULL == pwszIn)
        pwszIn = L"";
    if (NULL == pbIn) {
        pbIn = rgbIn;
        cbIn = 0;
    }

    if (!FIsWinNT5()) {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        goto ErrorReturn;
    }

    RpcStatus = CertBindA(&h);
    if (RPC_S_OK != RpcStatus) {
        SetLastError(RpcStatus);
        goto ErrorReturn;
    }


    __try {
        dwRetVal = SSCertProtectFunction(
            h,
            dwFuncId,
            dwFlags,
            pwszIn,
            pbIn,
            cbIn,
            &pbSSOut,
            &cbSSOut
            );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    CertUnbindA(&h);

    if (ERROR_SUCCESS != dwRetVal) {
        if (RPC_S_UNKNOWN_IF == dwRetVal)
            dwRetVal = ERROR_CALL_NOT_IMPLEMENTED;
        SetLastError(dwRetVal);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (ppbOut)
        *ppbOut = pbSSOut;
    else if (pbSSOut)
        midl_user_free(pbSSOut);

    if (pcbOut)
        *pcbOut = cbSSOut;

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}



static RPC_STATUS CertBindA(RPC_BINDING_HANDLE *phBind)
{
    static BOOL                 fDone           = FALSE;
    RPC_STATUS                  RpcStatus       = RPC_S_OK;
    unsigned char *             pszBinding      = NULL;
    RPC_BINDING_HANDLE          hBind           = NULL;
    RPC_SECURITY_QOS            RpcSecurityQOS;
    SID_IDENTIFIER_AUTHORITY    SIDAuth         = SECURITY_NT_AUTHORITY;
    PSID                        pSID            = NULL;
    WCHAR                       szName[64];
    DWORD                       cbName          = 64;
    WCHAR                       szDomainName[256]; // max domain is 255
    DWORD                       cbDomainName    = 256;
    SID_NAME_USE                Use;

    //
    // wait for the service to be available before attempting bind
    //

    WaitForCryptService(L"CryptSvc", &fDone);


    RpcStatus = RpcStringBindingComposeA(
                            NULL,
                            (unsigned char*)KEYSVC_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned char*)KEYSVC_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );
    if (RPC_S_OK != RpcStatus)
        goto ErrorReturn;

    RpcStatus = RpcBindingFromStringBindingA(pszBinding, &hBind);
    if (RPC_S_OK != RpcStatus)
        goto ErrorReturn;

    RpcStatus = RpcEpResolveBinding(
                            hBind,
                            ICertProtectFunctions_v1_0_c_ifspec
                            );
    if (RPC_S_OK != RpcStatus)
        goto ErrorReturn;

    //
    // Set the autorization so that we will only call a Local Service process
    //
    memset(&RpcSecurityQOS, 0, sizeof(RpcSecurityQOS));
    RpcSecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    RpcSecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RpcSecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    RpcSecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    if (AllocateAndInitializeSid(&SIDAuth, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSID) == 0)
    {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto ErrorReturn;
    }

    if (LookupAccountSidW(NULL,
                         pSID,
                         szName,
                         &cbName,
                         szDomainName,
                         &cbDomainName,
                         &Use) == 0)
    {
        RpcStatus = RPC_S_UNKNOWN_PRINCIPAL;
        goto ErrorReturn;
    }

    RpcStatus = RpcBindingSetAuthInfoExW(
                            hBind,
                            szName,
                            RPC_C_AUTHN_LEVEL_PKT,
                            RPC_C_AUTHN_WINNT,
                            NULL,
                            0,
                            &RpcSecurityQOS
                            );
    if (RPC_S_OK != RpcStatus)
        goto ErrorReturn;

CommonReturn:
    if (NULL != pszBinding) {
        RpcStringFreeA(&pszBinding);
    }

    if (NULL != pSID) {
        FreeSid(pSID);
    }

    *phBind = hBind;
    return RpcStatus;

ErrorReturn:
    if (NULL != hBind)
    {
        RpcBindingFree(&hBind);
        hBind = NULL;
    }

    goto CommonReturn;
}



static RPC_STATUS CertUnbindA(RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS RpcStatus;

    if (NULL != *phBind) {
        RpcStatus = RpcBindingFree(phBind);
    } else {
        RpcStatus = RPC_S_OK;
    }

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\dpapi\server\makefile.inc ===
$(CRYPTO_INC)\$(O)\pstypes.h: $(O)\pstypes.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@


$(CRYPTO_INC)\$(O)\pstrpc.h: $(O)\pstrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\pasrec.h: $(O)\pasrec.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@


$(CRYPTO_INC)\$(O)\keyrpc.h: $(O)\keyrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\dprpc.h: $(O)\dprpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\keysvc\keysvcc.cpp ===
//depot/Lab03_DEV/Ds/security/cryptoapi/common/keysvc/keysvcc.cpp#3 - edit change 21738 (text)
//depot/Lab03_N/DS/security/cryptoapi/common/keysvc/keysvcc.cpp#9 - edit change 6380 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       keysvcc.cpp
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <rpc.h>
#include <ntdsapi.h>
#include <assert.h>
#include "keysvc.h"
#include "cryptui.h"
#include "lenroll.h"
#include "keysvcc.h"

#include "unicode.h"
#include "waitsvc.h"

typedef struct _WZR_RPC_BINDING_LIST
{
    LPCSTR pszProtSeq;
    LPCSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBindingList[] =
{
    { KEYSVC_LOCAL_PROT_SEQ, KEYSVC_LOCAL_ENDPOINT },
    { KEYSVC_DEFAULT_PROT_SEQ, KEYSVC_DEFAULT_ENDPOINT}
};

DWORD g_cwzrBindingList = sizeof(g_awzrBindingList)/sizeof(g_awzrBindingList[0]);


//
// BUGBUG: TODO: move the following to common header (rkeysvcc.w)
// 
#define RKEYSVC_CONNECT_SECURE_ONLY 0x00000001


/****************************************
 * Client side Key Service handles
 ****************************************/

typedef struct _KEYSVCC_INFO_ {
    KEYSVC_HANDLE   hKeySvc;
    handle_t        hRPCBinding;
} KEYSVCC_INFO, *PKEYSVCC_INFO;


void InitUnicodeString(
                       PKEYSVC_UNICODE_STRING pUnicodeString,
                       LPCWSTR pszString
                       )
{
    pUnicodeString->Length = (USHORT)(wcslen(pszString) * sizeof(WCHAR));
    pUnicodeString->MaximumLength = pUnicodeString->Length + sizeof(WCHAR);
    pUnicodeString->Buffer = (USHORT*)pszString;

    // Ensure that we don't have a string longer than allowed by our interface:
    assert(pUnicodeString->Length < 64*1024); 
    assert(pUnicodeString->MaximumLength < 64*1024); 
}

ULONG SetupRemoteRPCSecurity(handle_t hRPCBinding, LPSTR wszServer, BOOL fMutualAuth)
{
    DWORD               ccServerPrincName; 
    DWORD               dwResult; 
    RPC_SECURITY_QOS    SecurityQOS;
    ULONG               ulErr; 
    unsigned char       szServerPrincName[256]; 

    ZeroMemory(szServerPrincName, sizeof(szServerPrincName)); 

    // Construct the SPN of the server we want to communicate with: 
    ccServerPrincName = sizeof(szServerPrincName) / sizeof(szServerPrincName[0]); 
    dwResult = DsMakeSpn("protectedstorage", wszServer, NULL, 0, NULL, &ccServerPrincName, (LPSTR)szServerPrincName); 
    if (ERROR_SUCCESS != dwResult) { 
	goto Ret; 
    }

    // Specify quality of service parameters.
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE; // the server will need to impersonate us
    SecurityQOS.Version           = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities      = fMutualAuth ? RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH : RPC_C_QOS_CAPABILITIES_DEFAULT ; // do we need mutual auth?
    SecurityQOS.IdentityTracking  = RPC_C_QOS_IDENTITY_STATIC; // calls go to the server under the identity that created the binding handle

    // NOTE: we still need to get MUTUAL_AUTH working in the remote case: 
    ulErr = RpcBindingSetAuthInfoExA(hRPCBinding, szServerPrincName, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_AUTHZ_NAME, &SecurityQOS); 
    if (RPC_S_OK != ulErr)
    {
	goto Ret; 
    }
    
    ulErr = ERROR_SUCCESS; 
 Ret:
    return ulErr;
}

ULONG SetupLocalRPCSecurity(handle_t hRPCBinding, BOOL fMutualAuth)
{
    CHAR                      szDomainName[128]; 
    CHAR                      szName[128]; 
    DWORD                     cbDomainName; 
    DWORD                     cbName; 
    PSID                      pSid          = NULL; 
    RPC_SECURITY_QOS          SecurityQOS;
    SID_IDENTIFIER_AUTHORITY  SidAuthority  = SECURITY_NT_AUTHORITY;
    SID_NAME_USE              SidNameUse; 
    ULONG                     ulErr; 

    // We're doing LRPC -- we need to get the account name of the service to do mutual auth
    if (!AllocateAndInitializeSid(&SidAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSid))
    {	    
	ulErr = GetLastError(); 
	goto Ret; 
    }

    cbName = sizeof(szName); 
    cbDomainName = sizeof(szDomainName); 
    if (!LookupAccountSidA(NULL, pSid, szName, &cbName, szDomainName, &cbDomainName, &SidNameUse)) 
    {
	ulErr = GetLastError(); 
	goto Ret; 
    }
	
    // Specify quality of service parameters.
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE; // the server will need to impersonate us
    SecurityQOS.Version           = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities      = fMutualAuth ? RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH : RPC_C_QOS_CAPABILITIES_DEFAULT ; // do we need mutual auth?
    SecurityQOS.IdentityTracking  = RPC_C_QOS_IDENTITY_STATIC; // calls go to the server under the identity that created the binding handle

    ulErr = RpcBindingSetAuthInfoExA(hRPCBinding, (unsigned char *)szName, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_WINNT, NULL, 0, &SecurityQOS); 
    if (RPC_S_OK != ulErr)
    {
	goto Ret; 
    }

    ulErr = ERROR_SUCCESS; 
 Ret:
    if (NULL != pSid) {
	FreeSid(pSid);
    }
    return ulErr; 
}

//*****************************************************
//
//  Implementation of Client API for Key Service
//
//*****************************************************

//--------------------------------------------------------------------------------
// KeyOpenKeyServiceEx
//
// Creates a KEYSVCC_HANDLE which a keysvc client can use to access the keysvc 
// interface.  This method should 
//
//   a) Create an RPC binding handle based on the best available protseq (LRPC or named pipes)
//   b) request mutual auth to ensure that the (L)RPC server isn't spoofing us.  
//   c) set PKT_PRIVACY encryption type.  NOTE: should this work for LPC?
//   d) ping the server to ensure that it's up (allows for better error reporting)
//   e) determine whether the server is an XP box.  If it is XP, we need to
//      return an old-style KEYSVC_HANDLE for compatibility.  This field
//      is ignored post-XP. 
// 
// rpc_ifspec       - the interface to open (keysvc or remote keysvc)
// pszMachineName   - the server to bind to
// OwnerType        - must be KeySvcMachine
// pwszOwnerName    - must be NULL
// fMutualAuth      - TRUE if mutual auth is required, FALSE otherwise
// pReserved        - must be NULL
// phKeySvcCli      - the handle through which the client can access keysvc.  
//                    Must be closed through KeyCloseKeyService(). 
//
ULONG KeyOpenKeyServiceEx
(/* [in] */ BOOL fRemoteKeysvc, 
 /* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ BOOL fMutualAuth, 
 /* [out][in] */ void *pReserved, 
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)

{
    BOOL static      fDone               = FALSE;
    DWORD            i;
    handle_t         hRPCBinding         = NULL; 
    PKEYSVCC_INFO    pKeySvcCliInfo      = NULL;
    ULONG            ulErr               = 0;
    unsigned char   *pStringBinding      = NULL;


    if (NULL != pReserved || KeySvcMachine != OwnerType || NULL != pwszOwnerName)
    {
        ulErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // allocate for the client key service handle
    if (NULL == (pKeySvcCliInfo =
        (PKEYSVCC_INFO)LocalAlloc(LMEM_ZEROINIT,
                                  sizeof(KEYSVCC_INFO))))
    {
        ulErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    //
    // before doing the Bind operation, wait for the cryptography
    // service to be available.
    //

    WaitForCryptService(L"ProtectedStorage", &fDone);

    // 
    // a) Create the binding handle

    for (i = 0; i < g_cwzrBindingList; i++)
    {
        if (RPC_S_OK != RpcNetworkIsProtseqValid(
                                    (unsigned char *)g_awzrBindingList[i].pszProtSeq))
        {
            goto next; 
        }

        ulErr = RpcStringBindingComposeA(
                              NULL,
                              (unsigned char *)g_awzrBindingList[i].pszProtSeq,
                              (unsigned char *)pszMachineName,
                              (unsigned char *)g_awzrBindingList[i].pszEndpoint,
                              NULL,
                              &pStringBinding);
        if (RPC_S_OK != ulErr)
        {
	    goto next; 
        }

        ulErr = RpcBindingFromStringBinding(
                                    pStringBinding,
                                    &hRPCBinding);
        if (RPC_S_OK != ulErr)
        {
            goto next; 
        }

	//
	// b) we've got the RPC binding, now request mutual auth and
	// c) request PKT_PRIVACY
	//
	if (0 == strcmp("ncalrpc", g_awzrBindingList[i].pszProtSeq)) { 
	    ulErr = SetupLocalRPCSecurity(hRPCBinding, fMutualAuth); 
	    if (ERROR_SUCCESS != ulErr)
	    {
		goto next; 
	    }
	} else if (0 == strcmp("ncacn_np", g_awzrBindingList[i].pszProtSeq)) { 
	    ulErr = SetupRemoteRPCSecurity(hRPCBinding, pszMachineName, fMutualAuth); 
	    if (ERROR_SUCCESS != ulErr)
	    {
		goto next; 
	    }
	} else { 
	    // Unknown binding (shouldn't get here):
	    ulErr = RPC_S_WRONG_KIND_OF_BINDING;
	    goto Ret;
	}

	//
	// d) We've set up mutual auth, now ping the server to make sure it's up.
	//    BUGBUG: There are two recommended ways of doing this.  The "preferred"
	//    way is to resolve the endpoint and call RpcMgmtIsServerListening().  
	//    This didn't work for me -- the function returned RPC_S_OK regardless
	//    of whether the server was up.  The "less preferred but acceptable"
	//    way is simply to call a method on the remote interface.  In the interests
	//    of time, I'm sticking with this method for Whistler. 
	// 
	// e) we'll also try to determine whether we're binding to an XP 
	//    box.  If so, return a KEYSVC_HANDLE for compatibility.  
	//    This is ignored post-XP.

	// we already have the binding we want to return:
	pKeySvcCliInfo->hRPCBinding = hRPCBinding; 
	pKeySvcCliInfo->hKeySvc = NULL; // NULL for post-XP (we'll check this below)

	RpcTryExcept { 
	    KEYSVC_UNICODE_STRING  kusOwnerName; 
	    KEYSVC_BLOB            kBlobAuthentication; 
	    PKEYSVC_BLOB           pkBlobReserved       = NULL; 
	    PKEYSVC_BLOB           pkBlobVersion        = NULL; 
	    KEYSVC_HANDLE          khCli                = NULL; 

	    ZeroMemory(&kusOwnerName,         sizeof(kusOwnerName)); 
	    ZeroMemory(&kBlobAuthentication,  sizeof(kBlobAuthentication)); 

	    if (!fRemoteKeysvc) 
		ulErr = KeyrOpenKeyService(hRPCBinding, KeySvcMachine, &kusOwnerName, 0, &kBlobAuthentication, &pkBlobVersion, &khCli);
	    else
		ulErr = RKeyrOpenKeyService(hRPCBinding, KeySvcMachine, &kusOwnerName, 0, &kBlobAuthentication, &pkBlobVersion, &khCli);
		
	    if (ERROR_SUCCESS == ulErr) 
	    {
		// we've got an XP box.  Return the KEYSVC_HANDLE to the client.
		pKeySvcCliInfo->hKeySvc = khCli; 
	    } else if (ERROR_CALL_NOT_IMPLEMENTED == ulErr) { 
		// we have a post-XP box -- that's fine. 
		ulErr = ERROR_SUCCESS; 
	    } else { 
		// unexpected, we'll give up. 
	    }
	} RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {  // handle only the RPC exceptions 
	    // We encountered an exception trying to contact the remote computer -- 
	    // give up and return the error to the user. 
	    ulErr = RpcExceptionCode(); 
	} RpcEndExcept; 
	
	if (ERROR_SUCCESS == ulErr)
	{
	    break; 
	}

    next: 
	if (NULL != hRPCBinding) { 
	    // If we're talking to an XP box, free server data:
	    if (NULL != pKeySvcCliInfo->hKeySvc) { 
		PKEYSVC_BLOB pTmpReserved = NULL;
		KeyrCloseKeyService(hRPCBinding, pKeySvcCliInfo->hKeySvc, &pTmpReserved);	
		pKeySvcCliInfo->hKeySvc = NULL; 
	    }

	    // close the RPC binding
	    RpcBindingFree(&hRPCBinding);
	    hRPCBinding = NULL; 
	}

	if (NULL != pStringBinding) { 
	    RpcStringFree(&pStringBinding); 
	    pStringBinding = NULL; 
	}
    }	

    if (ERROR_SUCCESS != ulErr)
    {
	// the server's a) not up, b) not supporting mutual auth, or c) not a compatibile version
	goto Ret;
    }
    
    ulErr = ERROR_SUCCESS; 
    *phKeySvcCli = pKeySvcCliInfo; 
Ret:
    __try
    {
        if (pStringBinding)
            RpcStringFree(&pStringBinding);
        if (ERROR_SUCCESS != ulErr)
        {
	    // If we're talking to an XP box, free server data:
	    if (NULL != pKeySvcCliInfo) { 
		if (NULL != pKeySvcCliInfo->hRPCBinding && NULL != pKeySvcCliInfo->hKeySvc) { 
		    PKEYSVC_BLOB pTmpReserved = NULL;
		    KeyrCloseKeyService(pKeySvcCliInfo->hRPCBinding, pKeySvcCliInfo->hKeySvc, &pTmpReserved);	
		}
		LocalFree(pKeySvcCliInfo); 
	    }

	    // close the RPC binding
	    if (NULL != hRPCBinding) { 
		RpcBindingFree(&hRPCBinding);
	    }
	}
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
    return ulErr;
}

ULONG KeyOpenKeyService
(/* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ void *pAuthentication,
 /* [out][in] */ void *pReserved,
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)
{
    return KeyOpenKeyServiceEx
        (FALSE /*local key svc*/, 
         pszMachineName,
         OwnerType,
         pwszOwnerName,
	 TRUE, 
	 pReserved, 
         phKeySvcCli);
}
 
ULONG KeyCloseKeyService(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void * /*pReserved*/)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB    pTmpReserved = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
	    goto Ret;
	}

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

	if (NULL != pKeySvcCliInfo->hRPCBinding) 
	{
	    if (NULL != pKeySvcCliInfo->hKeySvc)
	    {
		ulErr = KeyrCloseKeyService(pKeySvcCliInfo->hRPCBinding,
					    pKeySvcCliInfo->hKeySvc,
					    &pTmpReserved);
	    }
	    RpcBindingFree(&pKeySvcCliInfo->hRPCBinding); 
	}
	LocalFree(hKeySvcCli); 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}



// Params needed for create:
// 
// Params not needed for submit:
//     all except pszMachineName, dwPurpose, dwFlags, fEnroll, dwStoreFlags, hRequest, and dwFlags. 
//
// Params not needed for free:
//     all except pszMachineName, hRequest, and dwFlags. 
//
ULONG KeyEnroll_V2
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
 /* [in] */ LPSTR /*pszMachineName*/,                //RESERVED: must be NULL (we don't support remote machine enrollment anymore)
 /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
 /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
 /* [in] */ DWORD dwFlags,                           //IN Required: Flags for enrollment
 /* [in] */ LPWSTR pszAcctName,                      //IN Optional: Account name the service runs under
 /* [in] */ void * /*pAuthentication*/,              //RESERVED must be NULL
 /* [in] */ BOOL /*fEnroll*/,                        //IN Required: Whether it is enrollment or renew
 /* [in] */ LPWSTR pszCALocation,                    //IN Required: The ca machine names to attempt to enroll with
 /* [in] */ LPWSTR pszCAName,                        //IN Required: The ca names to attempt to enroll with
 /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
 /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
 /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
 /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
 /* [in] */ LPWSTR pszHashAlg,                       //IN Optional: The hash algorithm
 /* [in] */ LPWSTR pszDesStore,                      //IN Optional: The destination store
 /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
 /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
 /* [in] */ LPWSTR pszAttributes,                    //IN Optional: Attribute string for request
 /* [in] */ DWORD dwReservedFlags,                   //RESERVED must be 0
 /* [in] */ BYTE * /*pReserved*/,                    //RESERVED must be NULL
 /* [in][out] */ HANDLE *phRequest,                  //IN OUT Optional: A handle to a created request
 /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
 /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
 /* [out] */ DWORD *pdwStatus)                       //OUT Optional: The status of the enrollment/renewal
{
    PKEYSVC_BLOB                    pReservedBlob = NULL;
    KEYSVC_UNICODE_STRING           AcctName;
    KEYSVC_UNICODE_STRING           CALocation;
    KEYSVC_UNICODE_STRING           CAName;
    KEYSVC_UNICODE_STRING           DesStore;
    KEYSVC_UNICODE_STRING           HashAlg;
    KEYSVC_BLOB                     KeySvcRequest; 
    KEYSVC_BLOB                    *pKeySvcRequest   = NULL;
    KEYSVC_BLOB                    *pPKCS7KeySvcBlob = NULL;
    KEYSVC_BLOB                    *pHashKeySvcBlob  = NULL;
    ULONG                           ulKeySvcStatus   = CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN; 
    KEYSVC_CERT_ENROLL_INFO         EnrollInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW_V2  NewKeyInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW_V2  RenewKeyInfo;
    KEYSVC_BLOB                     CertBlob;
    DWORD                           i;
    DWORD                           j;
    DWORD                           dwErr = 0;
    DWORD                           cbExtensions;
    PBYTE                           pbExtensions;
    BOOL                            fCreateRequest   = 0 == (dwFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    PKEYSVCC_INFO                   pKeySvcCliInfo   = NULL;

    __try
    {
        //////////////////////////////////////////////////////////////
        // 
        // INITIALIZATION:
        //
        //////////////////////////////////////////////////////////////

        if (NULL != pPKCS7Blob) { memset(pPKCS7Blob, 0, sizeof(CERT_BLOB)); } 
        if (NULL != pHashBlob)  { memset(pHashBlob, 0, sizeof(CERT_BLOB)); } 
        if (NULL != phRequest && NULL != *phRequest)
        {
            pKeySvcRequest     = &KeySvcRequest; 
            pKeySvcRequest->cb = sizeof(*phRequest); 
            pKeySvcRequest->pb = (BYTE *)phRequest; 
        }

	memset(&AcctName, 0, sizeof(AcctName));
        memset(&CALocation, 0, sizeof(CALocation));
        memset(&CAName, 0, sizeof(CAName));
        memset(&HashAlg, 0, sizeof(HashAlg));
        memset(&DesStore, 0, sizeof(DesStore));
        memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
        memset(&EnrollInfo, 0, sizeof(EnrollInfo));
        memset(&RenewKeyInfo, 0, sizeof(RenewKeyInfo));
        memset(&CertBlob, 0, sizeof(CertBlob));



        //////////////////////////////////////////////////////////////
        //
        // PROCEDURE BODY:
        //
        //////////////////////////////////////////////////////////////

	if (NULL == hKeySvcCli)
	{
            dwErr = ERROR_INVALID_PARAMETER; 
            goto Ret;
	}

	pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli; 

        // set up the key service unicode structs
        if (pszAcctName)
            InitUnicodeString(&AcctName, pszAcctName);
        if (pszCALocation)
            InitUnicodeString(&CALocation, pszCALocation);
        if (pszCAName)
            InitUnicodeString(&CAName, pszCAName);
        if (pszHashAlg)
            InitUnicodeString(&HashAlg, pszHashAlg);
        if (pszDesStore)
            InitUnicodeString(&DesStore, pszDesStore);

        // set up the new key info structure for the remote call
        // This is only necessary if we are actually _creating_ a request. 
        // Submit-only and free-only operations can skip this operation. 
        // 
        if (TRUE == fCreateRequest)
        {
            NewKeyInfo.ulProvType = pKeyNew->dwProvType;
            if (pKeyNew->pwszProvider)
            {
                InitUnicodeString(&NewKeyInfo.Provider, pKeyNew->pwszProvider);
            }
            NewKeyInfo.ulProviderFlags = pKeyNew->dwProviderFlags;
            if (pKeyNew->pwszKeyContainer)
            {
                InitUnicodeString(&NewKeyInfo.KeyContainer,
                                  pKeyNew->pwszKeyContainer);
            }
            NewKeyInfo.ulKeySpec = pKeyNew->dwKeySpec;
            NewKeyInfo.ulGenKeyFlags = pKeyNew->dwGenKeyFlags;
            
            NewKeyInfo.ulEnrollmentFlags = pKeyNew->dwEnrollmentFlags; 
            NewKeyInfo.ulSubjectNameFlags = pKeyNew->dwSubjectNameFlags;
            NewKeyInfo.ulPrivateKeyFlags = pKeyNew->dwPrivateKeyFlags;
            NewKeyInfo.ulGeneralFlags = pKeyNew->dwGeneralFlags; 

            // set up the usage OIDs
            if (pRequestInfo->pwszUsageOID)
            {
                InitUnicodeString(&EnrollInfo.UsageOID, pRequestInfo->pwszUsageOID);
            }

            // set up the cert DN Name
            if (pRequestInfo->pwszCertDNName)
            {
                InitUnicodeString(&EnrollInfo.CertDNName, pRequestInfo->pwszCertDNName);
            }

            // set up the request info structure for the remote call
            EnrollInfo.ulPostOption = pRequestInfo->dwPostOption;
            if (pRequestInfo->pwszFriendlyName)
            {
                InitUnicodeString(&EnrollInfo.FriendlyName,
                                  pRequestInfo->pwszFriendlyName);
            }
            if (pRequestInfo->pwszDescription)
            {
                InitUnicodeString(&EnrollInfo.Description,
                                  pRequestInfo->pwszDescription);
            }
            if (pszAttributes)
            {
                InitUnicodeString(&EnrollInfo.Attributes, pszAttributes);
            }

            // convert the cert extensions
            // NOTE, the extensions structure cannot be simply cast,
            // as the structures have different packing behaviors in
            // 64 bit systems.
            
            
            EnrollInfo.cExtensions = pRequestInfo->dwExtensions;
            cbExtensions = EnrollInfo.cExtensions*(sizeof(PKEYSVC_CERT_EXTENSIONS) +
                                                   sizeof(KEYSVC_CERT_EXTENSIONS));
            
            for(i=0; i < EnrollInfo.cExtensions; i++)
            {
                cbExtensions += pRequestInfo->prgExtensions[i]->cExtension*
                    sizeof(KEYSVC_CERT_EXTENSION);
            }
            
            EnrollInfo.prgExtensions = (PKEYSVC_CERT_EXTENSIONS*)midl_user_allocate( cbExtensions);
            
            if(NULL == EnrollInfo.prgExtensions)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            
            pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.cExtensions);

            for(i=0; i < EnrollInfo.cExtensions; i++)
            {
                EnrollInfo.prgExtensions[i] = (PKEYSVC_CERT_EXTENSIONS)pbExtensions;
                pbExtensions += sizeof(KEYSVC_CERT_EXTENSIONS);
                EnrollInfo.prgExtensions[i]->cExtension = pRequestInfo->prgExtensions[i]->cExtension;
                
                EnrollInfo.prgExtensions[i]->rgExtension = (PKEYSVC_CERT_EXTENSION)pbExtensions;
                pbExtensions += sizeof(KEYSVC_CERT_EXTENSION)*EnrollInfo.prgExtensions[i]->cExtension;
                
                
                for(j=0; j < EnrollInfo.prgExtensions[i]->cExtension; j++)
                {
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].pszObjId = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].pszObjId;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].fCritical = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].fCritical;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].cbData = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].Value.cbData;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].pbData = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].Value.pbData;
                }
            }

            // if doing renewal then make sure have everything needed
            if ((CRYPTUI_WIZ_CERT_RENEW == dwPurpose) &&
                ((NULL == pRenewKey) || (NULL == pCert)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Ret;
            }
            
            // set up the new key info structure for the remote call
            if (pRenewKey)
            {
                RenewKeyInfo.ulProvType = pRenewKey->dwProvType;
                if (pRenewKey->pwszProvider)
                {
                    InitUnicodeString(&RenewKeyInfo.Provider, pRenewKey->pwszProvider);
                }
                RenewKeyInfo.ulProviderFlags = pRenewKey->dwProviderFlags;
                if (pRenewKey->pwszKeyContainer)
                {
                    InitUnicodeString(&RenewKeyInfo.KeyContainer,
                                      pRenewKey->pwszKeyContainer);
                }
                RenewKeyInfo.ulKeySpec = pRenewKey->dwKeySpec;
                RenewKeyInfo.ulGenKeyFlags = pRenewKey->dwGenKeyFlags;
                RenewKeyInfo.ulEnrollmentFlags = pRenewKey->dwEnrollmentFlags;
                RenewKeyInfo.ulSubjectNameFlags = pRenewKey->dwSubjectNameFlags;
                RenewKeyInfo.ulPrivateKeyFlags = pRenewKey->dwPrivateKeyFlags;
                RenewKeyInfo.ulGeneralFlags = pRenewKey->dwGeneralFlags;
            }
            
            // set up the cert blob for renewal
            if (pCert)
            {
                CertBlob.cb = pCert->cbData;
                CertBlob.pb = pCert->pbData;
		
		// Ensure that we don't have a blob longer than allowed by our interface:
		assert(CertBlob.pb < 128*1024); 
            }
        }
	
        // make the remote enrollment call
        if (0 != (dwErr = KeyrEnroll_V2
                  (pKeySvcCliInfo->hRPCBinding, 
                   fKeyService, 
                   dwPurpose,
                   dwFlags, 
                   &AcctName, 
                   &CALocation, 
                   &CAName, 
                   fNewKey,
                   &NewKeyInfo, 
                   &CertBlob, 
                   &RenewKeyInfo,
                   &HashAlg, 
                   &DesStore, 
                   dwStoreFlags,
                   &EnrollInfo, 
                   dwReservedFlags, 
                   &pReservedBlob,
                   &pKeySvcRequest, 
                   &pPKCS7KeySvcBlob,
                   &pHashKeySvcBlob,
                   &ulKeySvcStatus)))
            goto Ret;

        // allocate and copy the output parameters.
	if ((NULL != pKeySvcRequest)     && 
	    (0     < pKeySvcRequest->cb) && 
	    (NULL != phRequest))
	{
	    memcpy(phRequest, pKeySvcRequest->pb, sizeof(*phRequest));
	}
	    
        if ((NULL != pPKCS7KeySvcBlob)     &&
	    (0     < pPKCS7KeySvcBlob->cb) && 
	    (NULL != pPKCS7Blob))
        {
            pPKCS7Blob->cbData = pPKCS7KeySvcBlob->cb;
            if (NULL == (pPKCS7Blob->pbData =
                (BYTE*)midl_user_allocate(pPKCS7Blob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pPKCS7Blob->pbData, pPKCS7KeySvcBlob->pb,
                   pPKCS7Blob->cbData);
        }
        if ((NULL != pHashKeySvcBlob)     &&
	    (0     < pHashKeySvcBlob->cb) &&
	    (NULL != pHashBlob))
        {
            pHashBlob->cbData = pHashKeySvcBlob->cb;
            if (NULL == (pHashBlob->pbData =
                (BYTE*)midl_user_allocate(pHashBlob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pHashBlob->pbData, pHashKeySvcBlob->pb, pHashBlob->cbData);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
Ret:
    __try
    {
        if(EnrollInfo.prgExtensions)
        {
            midl_user_free(EnrollInfo.prgExtensions);
        }
	if (pKeySvcRequest)
	{
	    midl_user_free(pKeySvcRequest);
	}
        if (pPKCS7KeySvcBlob)
        {
            midl_user_free(pPKCS7KeySvcBlob);
        }
        if (pHashKeySvcBlob)
        {
            midl_user_free(pHashKeySvcBlob);
        }
	if (NULL != pdwStatus)
	{
	    *pdwStatus = (DWORD)ulKeySvcStatus; 
	}

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
    return dwErr;
}


ULONG KeyEnumerateAvailableCertTypes(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void * /*pReserved*/,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
               PKEYSVC_UNICODE_STRING *ppCertTypes)

{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrEnumerateAvailableCertTypes(pKeySvcCliInfo->hRPCBinding,
						pKeySvcCliInfo->hKeySvc, 
						&pTmpReserved,
						pcCertTypeCount, 
						ppCertTypes);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyEnumerateCAs(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void * /*pReserved*/,
    /* [in] */      ULONG  ulFlags,
    /* [out][in] */ ULONG *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING *ppCAs)

{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrEnumerateCAs(pKeySvcCliInfo->hRPCBinding,
				 pKeySvcCliInfo->hKeySvc, 
                                 &pTmpReserved,
                                 ulFlags,
                                 pcCACount, 
                                 ppCAs);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

extern "C" ULONG KeyQueryRequestStatus
(/* [in] */        KEYSVCC_HANDLE                        hKeySvcCli, 
 /* [in] */        HANDLE                                hRequest, 
 /* [out, ref] */  CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
{
    KEYSVC_QUERY_CERT_REQUEST_INFO  ksQueryCertRequestInfo; 
    PKEYSVCC_INFO                   pKeySvcCliInfo          = NULL;
    ULONG                           ulErr                   = 0;

    __try
    {
        if (NULL == hKeySvcCli || NULL == pQueryInfo)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        ZeroMemory(&ksQueryCertRequestInfo, sizeof(ksQueryCertRequestInfo)); 

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrQueryRequestStatus
          (pKeySvcCliInfo->hRPCBinding,
           (unsigned __int64)hRequest, 
           &ksQueryCertRequestInfo); 
        if (ERROR_SUCCESS == ulErr) 
        {
            pQueryInfo->dwSize   = ksQueryCertRequestInfo.ulSize; 
            pQueryInfo->dwStatus = ksQueryCertRequestInfo.ulStatus; 
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}


extern "C" ULONG RKeyOpenKeyService
(/* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ void *ulFlags, 
 /* [out][in] */ void *pReserved,
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)
{
    return KeyOpenKeyServiceEx
        (TRUE /*remote key svc*/, 
         pszMachineName,
         OwnerType,
         pwszOwnerName,
         (0 != (PtrToUlong(ulFlags) & RKEYSVC_CONNECT_SECURE_ONLY)),
         pReserved,
         phKeySvcCli);
}

extern "C" ULONG RKeyCloseKeyService(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved)
{
    return KeyCloseKeyService(hKeySvcCli, pReserved); 
}

extern "C" ULONG RKeyPFXInstall
(/* [in] */ KEYSVCC_HANDLE          hKeySvcCli,
 /* [in] */ PKEYSVC_BLOB            pPFX,
 /* [in] */ PKEYSVC_UNICODE_STRING  pPassword,
 /* [in] */ ULONG                   ulFlags)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = RKeyrPFXInstall(pKeySvcCliInfo->hRPCBinding,
                                pPFX, 
                                pPassword, 
                                ulFlags); 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }

Ret:
    return ulErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\errlog\errlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       errlog.cpp
//
//  Contents:   generic error logging
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include "errlog.h"
#include "unicode.h"

#define WSZ_ERROR_LOGFILE                   L"%SystemRoot%\\System32\\CatRoot2\\dberr.txt"

#define REG_CRYPTOGRAPHY_KEY                L"Software\\Microsoft\\Cryptography"
#define REG_CATDB_LOGGING_VALUE             L"CatDBLogging"

#define CATDB_LOG_ERRORS_TO_FILE            0x00000001
#define CATDB_LOG_ERRORS_TO_DEBUGGER        0x00000002
#define CATDB_LOG_WARNINGS                  0x00000004

#define MAX_LOGFILE_SIZE                    100000
#define TIME_DATE_SIZE                      256
#define WRITE_BUFFER_SIZE                   512

BOOL    g_fErrLogInitialized                = FALSE;

BOOL    g_fLogErrorsToFile                  = TRUE;
BOOL    g_fLogErrorsToDebugger              = FALSE;
BOOL    g_fLogWarnings                      = FALSE;

#define WSZ_TIME_STAMP_FILE                 L"TimeStamp"
#define TIME_ALLOWANCE                      ((ULONGLONG) 10000000 * (ULONGLONG) 60 * (ULONGLONG) 5) // 5 minutes

#define TIMESTAMP_LOGERR_LASTERR()          ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_TIMESTAMP, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define NAME_VALUE_SIZE 28

void
ErrLog_Initialize()
{
    HKEY    hKey;
    DWORD   dwDisposition;
    WCHAR   wszValueName[NAME_VALUE_SIZE];
    DWORD   dwValueNameSize = NAME_VALUE_SIZE;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwValueSize = sizeof(DWORD);
    DWORD   dwIndex;
    LONG    lRet;

    g_fErrLogInitialized = TRUE;

    //
    // See if there is a CatDBLogging value
    //
    if (RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            REG_CRYPTOGRAPHY_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        dwIndex = 0;

        lRet = RegEnumValueU(
                    hKey,
                    dwIndex,
                    wszValueName,
                    &dwValueNameSize,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &dwValueSize);

        while ((lRet == ERROR_SUCCESS) || (lRet == ERROR_MORE_DATA))
        {
            if ((lRet == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)   &&
                (_wcsicmp(wszValueName, REG_CATDB_LOGGING_VALUE) == 0))
            {
                g_fLogErrorsToFile = (dwValue & CATDB_LOG_ERRORS_TO_FILE) != 0;
                g_fLogErrorsToDebugger = (dwValue & CATDB_LOG_ERRORS_TO_DEBUGGER) != 0;
                g_fLogWarnings = (dwValue & CATDB_LOG_WARNINGS) != 0;
                break;
            }
            else
            {
                dwValueNameSize = NAME_VALUE_SIZE;
                dwValueSize = sizeof(DWORD);
                dwIndex++;
                lRet = RegEnumValueU(
                            hKey,
                            dwIndex,
                            wszValueName,
                            &dwValueNameSize,
                            NULL,
                            &dwType,
                            (BYTE *) &dwValue,
                            &dwValueSize);
            }
        }

        RegCloseKey(hKey);
    }
}


void
_WriteErrorOut(
    LPWSTR  pwszLogFileName,
    LPSTR   pwszError,
    BOOL    fLogToFileOnly)
{
    LPWSTR      pwszFileNameToExpand    = pwszLogFileName;
    LPWSTR      pwszExpandedFileName    = NULL;
    DWORD       dwExpanded              = 0;
    HANDLE      hFile                   = INVALID_HANDLE_VALUE;
    DWORD       dwFileSize              = 0;
    DWORD       dwNumBytesWritten       = 0;

    //
    // Output the error string to the debugger
    //
    if (g_fLogErrorsToDebugger && !fLogToFileOnly)
    {
        OutputDebugStringA(pwszError);
    }

    //
    // Log string to file
    //
    if (g_fLogErrorsToFile)
    {
        if (pwszFileNameToExpand == NULL)
        {
            pwszFileNameToExpand = WSZ_ERROR_LOGFILE;
        }

        //
        // expand the filename if needed
        //
        dwExpanded = ExpandEnvironmentStringsU(pwszFileNameToExpand, NULL, 0);

        if (dwExpanded == 0)
        {
            goto Return;
        }

        pwszExpandedFileName = (LPWSTR) malloc(dwExpanded * sizeof(WCHAR));
        if (pwszExpandedFileName == NULL)
        {
            goto Return;
        }

        if (0 == ExpandEnvironmentStringsU(
                        pwszFileNameToExpand,
                        pwszExpandedFileName,
                        dwExpanded))
        {
            goto Return;
        }

        //
        // Get a handle to the file and make sure it isn't took big
        //
        hFile = CreateFileU(
                        pwszExpandedFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        0, //dwShareMode
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            goto Return;
        }

        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize >= MAX_LOGFILE_SIZE)
        {
            //
            // Just nuke the whole thing
            //
            if (SetFilePointer(
                    hFile,
                    0,
                    NULL,
                    FILE_BEGIN) == INVALID_SET_FILE_POINTER)
            {
                goto Return;
            }

            if (!SetEndOfFile(hFile))
            {
                goto Return;
            }
        }

        //
        // Write the new error
        //
        if (SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
        {
            goto Return;
        }

        WriteFile(
            hFile,
            (void *) pwszError,
            strlen(pwszError),
            &dwNumBytesWritten,
            NULL);
    }

Return:

    if (pwszExpandedFileName != NULL)
    {
        free(pwszExpandedFileName);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
}


#define SZ_ERROR_FORMAT         "CatalogDB: %s: File #%u at line #%u encountered error 0x%.8lx\r\n"
#define SZ_LOGSTRING1_FORMAT    "CatalogDB: %s: %S %S\r\n"
#define SZ_LOGSTRING2_FORMAT    "CatalogDB: %s: %S\r\n"

void
ErrLog_LogError(
    LPWSTR  pwszLogFileName,
    DWORD   dwClient,
    DWORD   dwLine,
    DWORD   dwErr,
    BOOL    fWarning,
    BOOL    fLogToFileOnly)
{
    DWORD       dwLastError             = GetLastError();
    int         numChars                = 0;
    char        szTimeDate[TIME_DATE_SIZE];
    char        szWriteBuffer[WRITE_BUFFER_SIZE];
    SYSTEMTIME  st;


    if (!g_fErrLogInitialized)
    {
        ErrLog_Initialize();
    }

    //
    // Get out if this is a warning and we are not logging warnings
    //
    if (!g_fLogWarnings && fWarning)
    {
        return;
    }

    //
    // Create the error string to log
    //
    GetLocalTime(&st);

    numChars = GetTimeFormatA(
                    LOCALE_USER_DEFAULT,
                    0,
                    &st,
                    NULL,
                    szTimeDate,
                    TIME_DATE_SIZE);

    szTimeDate[numChars-1] = ' ';

    GetDateFormatA(
            LOCALE_USER_DEFAULT,
            DATE_SHORTDATE,
            &st,
            NULL,
            &szTimeDate[numChars],
            TIME_DATE_SIZE-numChars);

    //
    // Using 8 characters max for each of dwClient, dwLine, and dwErr
    // dwClient - there are only 4 client files, so this is actually only 1 digit
    // dwLine - there is no way the file line number will exceed 99,999,999
    // dwErr - the format string puts this in hex, so 8 characters is max
    //
    if ((strlen(SZ_ERROR_FORMAT) + strlen(szTimeDate) + 8 + 8 + 8 + 1) > WRITE_BUFFER_SIZE)
    {
        SetLastError(dwLastError);
        return;
    }

    wsprintf(
        szWriteBuffer,
        SZ_ERROR_FORMAT,
        szTimeDate,
        dwClient,
        dwLine,
        (dwErr == 0) ? dwLastError : dwErr);

    //
    // Log it
    //
    _WriteErrorOut(pwszLogFileName, szWriteBuffer, fLogToFileOnly);

    //
    // Make sure last error is the same as when we were called
    //
    SetLastError(dwLastError);
}

void
ErrLog_LogString(
    LPWSTR  pwszLogFileName,
    LPWSTR  pwszMessageString,
    LPWSTR  pwszExtraString,
    BOOL    fLogToFileOnly)
{
    DWORD       dwLastError             = GetLastError();
    int         numChars                = 0;
    char        szTimeDate[TIME_DATE_SIZE];
    SYSTEMTIME  st;
    char        szWriteBuffer[WRITE_BUFFER_SIZE];

    if (!g_fErrLogInitialized)
    {
        ErrLog_Initialize();
    }

    //
    // Create the error string to log
    //
    GetLocalTime(&st);

    numChars = GetTimeFormatA(
                    LOCALE_USER_DEFAULT,
                    0,
                    &st,
                    NULL,
                    szTimeDate,
                    TIME_DATE_SIZE);

    szTimeDate[numChars-1] = ' ';

    GetDateFormatA(
            LOCALE_USER_DEFAULT,
            DATE_SHORTDATE,
            &st,
            NULL,
            &szTimeDate[numChars],
            TIME_DATE_SIZE-numChars);

    if (pwszExtraString != NULL)
    {
        if ((strlen(SZ_LOGSTRING1_FORMAT) +
             strlen(szTimeDate) +
             wcslen(pwszMessageString) +
             wcslen(pwszExtraString) + 1) > WRITE_BUFFER_SIZE)
        {
            SetLastError(dwLastError);
            return;
        }

        wsprintf(
            szWriteBuffer,
            SZ_LOGSTRING1_FORMAT,
            szTimeDate,
            pwszMessageString,
            pwszExtraString);
    }
    else
    {
        if ((strlen(SZ_LOGSTRING2_FORMAT) +
             strlen(szTimeDate) +
             wcslen(pwszMessageString) + 1) > WRITE_BUFFER_SIZE)
        {
            SetLastError(dwLastError);
            return;
        }

        wsprintf(
            szWriteBuffer,
            SZ_LOGSTRING2_FORMAT,
            szTimeDate,
            pwszMessageString);
    }

    //
    // Log it
    //
    _WriteErrorOut(pwszLogFileName, szWriteBuffer, fLogToFileOnly);

    //
    // Make sure last error is the same as when we were called
    //
    SetLastError(dwLastError);
}


BOOL
TimeStampFile_Touch(
    LPWSTR  pwszDir)
{
    BOOL        fRet                = TRUE;
    LPWSTR      pwszFile            = NULL;
    HANDLE      hFile               = INVALID_HANDLE_VALUE;
    DWORD       dwNumBytesWritten   = 0;
    SYSTEMTIME  st;
    FILETIME    ft;
    DWORD       dwErr;
    DWORD       dwRetry             = 0;

    //
    // Create fully qaulified file name
    //
    if (NULL == (pwszFile = (LPWSTR) malloc((
                                        wcslen(pwszDir) +
                                        wcslen(WSZ_TIME_STAMP_FILE)
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    wcscpy(pwszFile, pwszDir);
    if (pwszFile[wcslen(pwszFile)-1] != L'\\')
    {
        wcscat(pwszFile, L"\\");
    }
    wcscat(pwszFile, WSZ_TIME_STAMP_FILE);

    //
    // Get a handle to the file
    //
    while (dwRetry < 10)
    {
        hFile = CreateFileU(
                        pwszFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0, //dwShareMode
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            TIMESTAMP_LOGERR_LASTERR()
            Sleep(1);
        }
        else
        {
            break;
        }

        dwRetry++;
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto ErrorReturn;
    }

    SetLastError(0);

    //
    // Get the current time
    //
    GetLocalTime(&st);

    if (!SystemTimeToFileTime(&st, &ft))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Write the time
    //
    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!SetEndOfFile(hFile))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            (void *) &ft,
            sizeof(ft),
            &dwNumBytesWritten,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

CommonReturn:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (pwszFile != NULL)
    {
        free(pwszFile);
    }

    return (fRet);

ErrorReturn:

    dwErr = GetLastError();

    if (pwszFile != NULL)
    {
        DeleteFileW(pwszFile);
    }

    SetLastError(dwErr);

    fRet = FALSE;

    goto CommonReturn;
}

BOOL
TimeStampFile_InSync(
    LPWSTR  pwszDir1,
    LPWSTR  pwszDir2,
    BOOL    *pfInSync)
{
    BOOL            fRet                = TRUE;
    LPWSTR          pwszFile1           = NULL;
    HANDLE          hFile1              = INVALID_HANDLE_VALUE;
    LPWSTR          pwszFile2           = NULL;
    HANDLE          hFile2              = INVALID_HANDLE_VALUE;
    DWORD           dwNumBytesRead;
    FILETIME        ft1;
    FILETIME        ft2;
    ULARGE_INTEGER  ul1;
    ULARGE_INTEGER  ul2;
    DWORD           dwRetryCount        = 0;

    //
    // Initialize out param
    //
    *pfInSync = FALSE;

    //
    // Create fully qaulified file names
    //
    if (NULL == (pwszFile1 = (LPWSTR) malloc((
                                        wcslen(pwszDir1) +
                                        wcslen(WSZ_TIME_STAMP_FILE)
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    wcscpy(pwszFile1, pwszDir1);
    if (pwszFile1[wcslen(pwszFile1)-1] != L'\\')
    {
        wcscat(pwszFile1, L"\\");
    }
    wcscat(pwszFile1, WSZ_TIME_STAMP_FILE);

    if (NULL == (pwszFile2 = (LPWSTR) malloc((
                                        wcslen(pwszDir2) +
                                        wcslen(WSZ_TIME_STAMP_FILE)
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    wcscpy(pwszFile2, pwszDir2);
    if (pwszFile2[wcslen(pwszFile2)-1] != L'\\')
    {
        wcscat(pwszFile2, L"\\");
    }
    wcscat(pwszFile2, WSZ_TIME_STAMP_FILE);

    //
    // Get a handle to the first file
    //
    while (dwRetryCount < 10)
    {
        hFile1 = CreateFileU(
                        pwszFile1,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hFile1 == INVALID_HANDLE_VALUE)
        {
            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                SetLastError(0);
                goto CommonReturn; // not an error, a legitimate out of sync
            }
            else
            {
                TIMESTAMP_LOGERR_LASTERR()
                Sleep(1);
            }
        }
        else
        {
            break;
        }

        dwRetryCount++;
    }

    //
    // See if we were able to open the file
    //
    if (hFile1 == INVALID_HANDLE_VALUE)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (SetFilePointer(hFile1, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get a handle to the second file
    //
    dwRetryCount = 0;
    while (dwRetryCount < 10)
    {
        hFile2 = CreateFileU(
                        pwszFile2,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hFile2 == INVALID_HANDLE_VALUE)
        {
            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                SetLastError(0);
                goto CommonReturn; // not an error, a legitimate out of sync
            }
            else
            {
                TIMESTAMP_LOGERR_LASTERR()
                Sleep(1);
            }
        }
        else
        {
            break;
        }

        dwRetryCount++;
    }

    //
    // See if we were able to open the file
    //
    if (hFile2 == INVALID_HANDLE_VALUE)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (SetFilePointer(hFile2, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the times out of the files
    //
    if (!ReadFile(
            hFile1,
            &ft1,
            sizeof(ft1),
            &dwNumBytesRead,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (dwNumBytesRead != sizeof(ft1))
    {
        TIMESTAMP_LOGERR_LASTERR()

        //
        // This is really an error, but there is no reason to fail, 
        // just say they are out of sync since that will reinit the time
        // stamp file during the catdb rebuild
        //
        goto CommonReturn; 
    }

    if (!ReadFile(
            hFile2,
            &ft2,
            sizeof(ft2),
            &dwNumBytesRead,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (dwNumBytesRead != sizeof(ft2))
    {
        TIMESTAMP_LOGERR_LASTERR()
                    
        //
        // This is really an error, but there is no reason to fail, 
        // just say they are out of sync since that will reinit the time
        // stamp file during the catdb rebuild
        //
        goto CommonReturn;
    }

    memcpy(&ul1, &ft1, sizeof(ft1));
    memcpy(&ul2, &ft2, sizeof(ft2));

    if ((ul1.QuadPart <= (ul2.QuadPart + TIME_ALLOWANCE)) &&
        (ul2.QuadPart <= (ul1.QuadPart + TIME_ALLOWANCE)))
    {
        *pfInSync = TRUE;
    }

CommonReturn:

    if (hFile1 != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile1);
    }

    if (pwszFile1 != NULL)
    {
        free(pwszFile1);
    }

    if (hFile2 != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile2);
    }

    if (pwszFile2 != NULL)
    {
        free(pwszFile2);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\ossutil\ossconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossconv.cpp
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  Functions:  OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//              OssConvToAttribute
//              OssConvToAlgorithmIdentifier
//              OssConvFromAlgorithmIdentifier
//
//  According to the <draft-ietf-pkix-ipki-part1-10.txt> :
//      For UTCTime. Where YY is greater than or equal to 50, the year shall
//      be interpreted as 19YY. Where YY is less than
//      50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//              03-May-96   kevinr  merged from wincrmsg
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater or equal than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1950
#define YEARLAST                2049
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (unsigned long)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        unsigned long *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN short mindiff,
    IN ossBoolean utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pOssTime->year   = t.wYear % 100;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year >= MAGICYEAR ?
                    (1900 + pOssTime->year) : (2000 + pOssTime->year);
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pOssTime->year   = t.wYear;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->millisec = t.wMilliseconds;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year;
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;
    t.wMilliseconds = pOssTime->millisec;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = OSS_GENERALIZED_TIME_CHOICE;
        pOssTime->year   = t.wYear;
    } else {
        *pwChoice = OSS_UTC_TIME_CHOICE;
        pOssTime->year = t.wYear % 100;
    }
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    if (OSS_UTC_TIME_CHOICE == wChoice)
        return OssConvFromUTCTime(pOssTime, pFileTime);
    else
        return OssConvFromGeneralizedTime(pOssTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\ossutil\pkioss.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkioss.cpp
//
//  Contents:   PKI OSS support functions.
//
//  Functions:  PkiOssEncode
//              PkiOssEncode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <msasn1.h>
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output is allocated and must be freed
//  by calling ossFreeBuf
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;

    ossBuf.length = 0;
    ossBuf.value = NULL;
    iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

    if (0 == iStatus) {
        *ppbEncoded = ossBuf.value;
        *pcbEncoded = ossBuf.length;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }

    return iStatus;
}


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode2(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        ossBuf.length = 0;
        ossBuf.value = NULL;
        iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

        if (0 == iStatus) {
            if (pbEncoded)
                iStatus = (int) ASN1_ERR_OVERFLOW;
            cbEncoded = ossBuf.length;
            if (ossBuf.value)
                ossFreeBuf(Pog, ossBuf.value);
        }
    } else {
        ossBuf.length = cbEncoded;
        ossBuf.value = pbEncoded;
        iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

        if (0 == iStatus)
            cbEncoded = ossBuf.length;
        else if (MORE_BUF == iStatus) {
            // Re-do as length only calculation
            iStatus = PkiOssEncode2(
                Pog,
                pvOssInfo,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (0 == iStatus)
                iStatus = (int) ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return iStatus;
}

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    int pdunum = id;

    ossBuf.length = cbEncoded;
    ossBuf.value = (BYTE *) pbEncoded;
    *ppvOssInfo = NULL;
    iStatus = ossDecode(Pog, &pdunum, &ossBuf, ppvOssInfo);
    return iStatus;
}

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode2(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    int pdunum = id;

    ossBuf.length = *pcbEncoded;
    ossBuf.value = *ppbEncoded;
    *ppvOssInfo = NULL;
    iStatus = ossDecode(Pog, &pdunum, &ossBuf, ppvOssInfo);
    if (0 == iStatus) {
        *ppbEncoded = ossBuf.value;
        *pcbEncoded = ossBuf.length;
    } else if (MORE_INPUT == iStatus)
        iStatus = (int) ASN1_ERR_EOD;
    return iStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\ossutil\ossutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ossutil.cpp
//
//  Contents:   OSS ASN.1 compiler utility helper functions.
//
//  Functions:  OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilSetBitStringWithoutTrailingZeroes
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfoEx
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    if (0 == cbIn)
        return;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)OssUtilAlloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssLength;
            pInfo->pbData = OssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) OssLength;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, OssValue, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//
//  For OssUtilSetInteger, OssUtilFreeInteger must be called to free
//  the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppOssValue = OssUtilAllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pOssLength = 0;
            return FALSE;
        }
    } else
        *ppOssValue = NULL;
    *pOssLength = pInfo->cbData;
    return TRUE;
}

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        )
{
    // Only for BYTE reversal
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    OssUtilGetOctetString(OssLength, pOssValue, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        OssUtilReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by OSS before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//  OssUtilFreeHugeUINT has been #define'd to OssUtilFreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) OssUtilAlloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pOssLength = cb;
    *ppOssValue = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (OssLength > 1 && *pOssValue == 0) {
        pOssValue++;
        OssLength--;
    }
    OssUtilGetHugeInteger(
        OssLength,
        pOssValue,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData) {
        *ppOssValue = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pOssBitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (OssBitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssBitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pOssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) OssBitLength / 8;
        cUnusedBits = OssBitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pOssValue, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    DWORD cbData;
    DWORD cUnusedBits;

    cbData = pInfo->cbData;
    cUnusedBits = pInfo->cUnusedBits;
    assert(cUnusedBits <= 7);

    if (cbData) {
        BYTE *pb;

        // Until we find a nonzero byte (starting with the last byte),
        // decrement cbData. For the last byte don't look at any unused bits.
        pb = pInfo->pbData + cbData - 1;
        if (0 == (*pb & rgbUnusedAndMask[cUnusedBits])) {
            cUnusedBits = 0;
            cbData--;
            pb--;

            for ( ; 0 < cbData && 0 == *pb; cbData--, pb--)
                ;
        }
    }

    if (cbData) {
        BYTE b;

        // Determine the number of unused bits in the last byte. Treat any
        // trailing zeroes as unused.
        b = *(pInfo->pbData + cbData - 1);
        assert(b);
        if (cUnusedBits)
            b = b >> cUnusedBits;
        
        for (; 7 > cUnusedBits && 0 == (b & 0x01); cUnusedBits++) {
            b = b >> 1;
        }
        assert(b & 0x01);
        assert(cUnusedBits <= 7);

        *ppOssValue = pInfo->pbData;
        *pOssBitLength = cbData * 8 - cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pOssLength = 0;
        *ppOssValue = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pOssLength = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) OssUtilAlloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppOssValue = psz;
    *pOssLength = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pOssLength = 0;
InvalidIA5:
    *ppOssValue = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        )
{
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pOssValue,
        OssLength,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pOssValue, OssLength,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pOss->length;
            pInfo->pbData = (BYTE *) pOss->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pOss->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pOss->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cbEncoded;
    OssBuf OssEncoded;
    int OssStatus;
    unsigned char *value;

    if (NULL == pvEncoded || (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    OssEncoded.length = cbEncoded;
    if (cbEncoded == 0)
        value = NULL;
    else
        value = (unsigned char *) pvEncoded;
    OssEncoded.value = value;

    ossSetEncodingRules(Pog, OSS_DER);
    OssStatus = ossEncode(
        Pog,
        pdunum,
        pvOssInfo,
        &OssEncoded);
    cbEncoded = OssEncoded.length;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        PFN_CRYPT_ALLOC pfnAlloc;
        BYTE *pbEncoded;

        if (0 != OssStatus || 0 == cbEncoded) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OssError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbEncoded, OssEncoded.value, cbEncoded);
        *((BYTE **) pvEncoded) = pbEncoded;
        ossFreeBuf(Pog, OssEncoded.value);
        goto SuccessReturn;
    } else if (value == NULL && OssEncoded.value) {
        // Length only calculation with a throw away allocation
        ossFreeBuf(Pog, OssEncoded.value);
        if (pvEncoded && 0 == OssStatus) {
            // Upon entry *pcbEncoded == 0
            goto LengthError;
        }
    }

    if (0 != OssStatus) {
        // For MORE_BUF:: redo as a length only calculation
        if (OssStatus == MORE_BUF && pvEncoded &&
                OssUtilEncodeInfoEx(
                Pog,
                pdunum,
                pvOssInfo,
                0,                  // dwFlags
                NULL,               // pEncodePara
                NULL,               // pbEncoded
                &cbEncoded))
            goto LengthError;
        else {
            cbEncoded = 0;
            goto OssError;
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        Pog,
        pdunum,
        pvOssInfo,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        )
{
    BOOL fResult;
    OssBuf OssEncoded;
    int OssStatus;

    OssEncoded.length = cbEncoded;
    OssEncoded.value = (unsigned char *) pbEncoded;

    ossSetEncodingRules(Pog, OSS_BER);
    *ppvOssInfo = NULL;
    if (0 != (OssStatus = ossDecode(
                Pog,
                &pdunum,
                &OssEncoded,
                ppvOssInfo)))
        goto OssError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvOssInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        )
{
    if (pvOssInfo) {
        ossFreePDU(Pog, pdunum, pvOssInfo);
    }
}

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvOssInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvOssInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvOssInfo = NULL;

    if (!OssUtilDecodeAndAllocInfo(
            Pog,
            pdunum,
            pbEncoded,
            cbEncoded,
            &pvOssInfo
            )) goto OssDecodeError;

    fResult = OssUtilAllocStructInfoEx(
        pvOssInfo,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    OssUtilFreeInfo(Pog, pdunum, pvOssInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OssDecodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkifmt\pkifmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkifmt.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    March-2000   xtan   created
//--------------------------------------------------------------------------

#ifndef __PKIFMT_H__
#define __PKIFMT_H__

#include "xelib.h"

#if DBG
# ifdef UNICODE
#  define szFMTTSTR		"ws"
# else
#  define szFMTTSTR		"hs"
# endif
#endif //DBG

DWORD
SizeBase64Header(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip);

DWORD
HexDecode(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut);

DWORD
HexEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut);

#ifdef __cplusplus
extern "C" {
#endif


#ifdef UNICODE
#define Base64Decode  Base64DecodeW
#else
#define Base64Decode  Base64DecodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD			// ERROR_*
Base64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

    
#ifdef UNICODE
#define Base64Encode  Base64EncodeW
#else
#define Base64Encode  Base64EncodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD			// ERROR_*
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);

    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkifmt\pkifmt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pkifmt.cpp
//
// Contents:    data format conversion
//
// History:     25-Jul-96       vich created
//              2/2000       xtan moved from certsrv to pki
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <wincrypt.h>

#include <dbgdef.h>
#include "pkifmt.h"


#if DBG
# ifdef UNICODE
#  define _DecodeCertSub	_DecodeCertSubW
# else
#  define _DecodeCertSub	_DecodeCertSubA
# endif
#endif //DBG


DWORD
_DecodeCertSub(
    IN TCHAR const *pchIn,
    IN DWORD        cchIn,
    IN DWORD        Flags,
    IN OUT BYTE    *pbOut,
    IN OUT DWORD   *pcbOut,
    OUT OPTIONAL DWORD *pdwSkip)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbOut = 0;

    if (NULL != pbOut)
    {
        cbOut = *pcbOut;
    }

	switch (Flags)
	{
	    case CRYPT_STRING_BASE64HEADER:
	    case CRYPT_STRING_BASE64REQUESTHEADER:
	    case CRYPT_STRING_BASE64X509CRLHEADER:
	    {
		TCHAR const *pchInEnd;
		DWORD cchHeader;
		DWORD cchSkip;

		pchInEnd = &pchIn[cchIn];

		// Skip to the starting '-----....' then skip that line.

		dwErr = ERROR_INVALID_DATA;
		cchHeader = SizeBase64Header(pchIn, cchIn, TRUE, &cchSkip);
		if (MAXDWORD == cchHeader)
		{
		    goto SizeBase64HeaderStartError;
		}
                if (NULL != pdwSkip)
                {
                    *pdwSkip = cchHeader; //for return
                }
		pchIn += cchHeader + cchSkip;
		cchHeader = SizeBase64Header(
					pchIn,
					SAFE_SUBTRACT_POINTERS(pchInEnd, pchIn),
					FALSE,
					&cchSkip);
		if (MAXDWORD == cchHeader)
		{
		    goto SizeBase64HeaderEndError;
		}
		cchIn = cchHeader;
		Flags = CRYPT_STRING_BASE64;	// headers have been removed...
		// FALLTHROUGH
	    }

	    case CRYPT_STRING_BASE64:
		dwErr = Base64Decode(pchIn, cchIn, pbOut, &cbOut);
                if (ERROR_SUCCESS != dwErr)
                {
#if DBG
                    if (ERROR_INVALID_DATA != dwErr)
                    {
                        DbgPrintf(DBG_SS_TRACE,
                                  "Base64Decode err = 0x%x\n", dwErr);
                    }
#endif //DBG
                    goto Base64DecodeError;
                }
		break;

	    case CRYPT_STRING_HEX:
	    case CRYPT_STRING_HEXASCII:
	    case CRYPT_STRING_HEXADDR:
	    case CRYPT_STRING_HEXASCIIADDR:
		dwErr = HexDecode(pchIn, cchIn, Flags, pbOut, &cbOut);
                if (ERROR_SUCCESS != dwErr)
                {
#if DBG
                    if (ERROR_INVALID_DATA != dwErr)
                    {
                        DbgPrintf(DBG_SS_TRACE,
                                  "HexDecode err = 0x%x\n", dwErr);
                    }
#endif //DBG
                    goto HexDecodeError;
                }
		break;

	    case CRYPT_STRING_BINARY:
		if (NULL != pbOut)
		{
		    //assert(sizeof(TCHAR) * cchIn == cbOut);
                    if (*pcbOut < cbOut)
                    {
                        *pcbOut = cbOut;
                        dwErr = ERROR_MORE_DATA;
                        goto MoreDataError;
                    }
		    CopyMemory(pbOut, (BYTE *) pchIn, cbOut);
		}
		else
		{
		    cbOut = sizeof(TCHAR) * cchIn;
		}
		break;

	    default:
		dwErr = ERROR_INVALID_DATA;  //hr = E_INVALIDARG
		break;
	}
    *pcbOut = cbOut;

ErrorReturn:
    return (dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(SizeBase64HeaderEndError, dwErr)
SET_ERROR(SizeBase64HeaderStartError, dwErr)
TRACE_ERROR(HexDecodeError)
TRACE_ERROR(Base64DecodeError)
}

BOOL
WINAPI
CryptStringToBinaryA(
    IN     LPCSTR   pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN OUT BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    IN OUT DWORD    *pdwSkip,    //OPTIONAL
    IN OUT DWORD    *pdwFlags)   //OPTIONAL
{
    DWORD   dwErr;
    DWORD cbOut;
    DWORD const *pFlags;
    DWORD const *pFlagsEnd;

    static DWORD s_aDecodeFlags[] = {
	CRYPT_STRING_BASE64HEADER,
	CRYPT_STRING_BASE64,
	CRYPT_STRING_BINARY		// must be last
    };

    static DWORD s_aHexDecodeFlags[] = {
	CRYPT_STRING_HEXADDR,
	CRYPT_STRING_HEXASCIIADDR,
	CRYPT_STRING_HEX,
	CRYPT_STRING_HEXASCII,
    };

    if (NULL == pszString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (0 == cchString)
    {
        // assume null terminated string
        cchString = strlen(pszString) + 1; //include null terminator
    }

    //init
    if (NULL != pdwSkip)
    {
        *pdwSkip = 0;
    }
    if (NULL != pdwFlags)
    {
        *pdwFlags = 0;
    }
    if (NULL == pbBinary)
    {
        *pcbBinary = 0;
    }

    pFlags = &dwFlags;
    pFlagsEnd = &pFlags[1];
    if (CRYPT_STRING_BASE64_ANY == dwFlags || CRYPT_STRING_ANY == dwFlags)
    {
	pFlags = s_aDecodeFlags;
	pFlagsEnd = &pFlags[sizeof(s_aDecodeFlags)/sizeof(s_aDecodeFlags[0])];
	if (CRYPT_STRING_BASE64_ANY == dwFlags)
	{
	    pFlagsEnd--;	// Disallow CRYPT_STRING_BINARY
	}
    }
    if (CRYPT_STRING_HEX_ANY == dwFlags)
    {
	pFlags = s_aHexDecodeFlags;
	pFlagsEnd = &pFlags[sizeof(s_aHexDecodeFlags)/sizeof(s_aHexDecodeFlags[0])];
    }

    dwErr = ERROR_SUCCESS;
    for ( ; pFlags < pFlagsEnd; pFlags++)
    {
        cbOut = *pcbBinary;
	dwErr = _DecodeCertSub(
                        pszString,
                        cchString,
                        *pFlags,
                        pbBinary,
                        &cbOut,
                        pdwSkip);
	if (ERROR_SUCCESS == dwErr)
	{
            //for return
            *pcbBinary = cbOut;
            if (NULL != pdwFlags)
            {
                *pdwFlags = *pFlags;
            }
	    break;
	}
#if DBG
        if (ERROR_INVALID_DATA != dwErr)
        {
            DbgPrintf(DBG_SS_TRACE, "_DecodeCertSub err = 0x%x\n", dwErr);
        }
#endif //DBG
    }

    if (ERROR_SUCCESS != dwErr)
    {
        goto DecodeCertSubError;
    }

ErrorReturn:
    return (ERROR_SUCCESS == dwErr);

SET_ERROR(DecodeCertSubError, dwErr)
SET_ERROR(InvalidDataError, dwErr)
}

DWORD
BinaryEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    DWORD dwErr;

    if (NULL != pchOut)
    {
        if (*pcchOut < cbIn)
        {
	    dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
        }
        CopyMemory(pchOut, pbIn, cbIn);
    }

    dwErr = ERROR_SUCCESS;
ErrorReturn:

    //get size any way
    *pcchOut = cbIn;

    return dwErr;

SET_ERROR(MoreDataError, dwErr)
}

static TCHAR const szBeginCert[] = TEXT("-----BEGIN CERTIFICATE-----");
static TCHAR const szEndCert[] = TEXT("-----END CERTIFICATE-----");

#define CB_BEGINCERT	(sizeof(szBeginCert) - sizeof(TCHAR))
#define CB_ENDCERT	(sizeof(szEndCert) - sizeof(TCHAR))

static TCHAR const szBeginCertRequest[] = TEXT("-----BEGIN NEW CERTIFICATE REQUEST-----");
static TCHAR const szEndCertRequest[] = TEXT("-----END NEW CERTIFICATE REQUEST-----");

#define CB_BEGINCERTREQUEST	(sizeof(szBeginCertRequest) - sizeof(TCHAR))
#define CB_ENDCERTREQUEST	(sizeof(szEndCertRequest) - sizeof(TCHAR))

static TCHAR const szBeginCRL[] = TEXT("-----BEGIN X509 CRL-----");
static TCHAR const szEndCRL[] = TEXT("-----END X509 CRL-----");

#define CB_BEGINCRL	(sizeof(szBeginCRL) - sizeof(TCHAR))
#define CB_ENDCRL	(sizeof(szEndCRL) - sizeof(TCHAR))

typedef struct _CERTHEADER
{
    TCHAR const *pszBegin;
    DWORD        cbBegin;
    TCHAR const *pszEnd;
    DWORD        cbEnd;
} CERTHEADER;

static CERTHEADER const CertHeaderCert =
{
    szBeginCert,
    CB_BEGINCERT,
    szEndCert,
    CB_ENDCERT
};

static CERTHEADER const CertHeaderCertRequest =
{
    szBeginCertRequest,
    CB_BEGINCERTREQUEST,
    szEndCertRequest,
    CB_ENDCERTREQUEST
};

static CERTHEADER const CertHeaderCRL =
{
    szBeginCRL,
    CB_BEGINCRL,
    szEndCRL,
    CB_ENDCRL
};


BOOL
WINAPI
CryptBinaryToStringA(
    IN  CONST BYTE  *pbBinary,
    IN  DWORD        cbBinary,
    IN  DWORD        dwFlags,
    OUT LPSTR        pszString,
    OUT DWORD       *pcchString)
{
    DWORD  dwErr;
    TCHAR *pchEncode;
    DWORD cchMax;
    DWORD cchOut;
    DWORD cbTotal;
    CERTHEADER const *pCertHeader = NULL;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & dwFlags);
    DWORD cchnl = fNoCR? 1 : 2;
    BOOL  fBinaryCopy = FALSE;

    if (NULL == pbBinary || 0 == cbBinary || NULL == pcchString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (NULL == pszString)
    {
        *pcchString = 0;
    }

    switch (~CRYPT_STRING_NOCR & dwFlags)
    {
        case CRYPT_STRING_BASE64HEADER:
	    pCertHeader = &CertHeaderCert;
	    break;

        case CRYPT_STRING_BASE64REQUESTHEADER:
	    pCertHeader = &CertHeaderCertRequest;
	    break;

        case CRYPT_STRING_BASE64X509CRLHEADER:
	    pCertHeader = &CertHeaderCRL;
	    break;
    }

    pchEncode = pszString;
    cchMax = *pcchString;
    cchOut = cchMax;

    if (NULL != pszString && NULL != pCertHeader)
    {
	// Make sure there's room for the BEGIN header and CR-LF sequence
	
	if (pCertHeader->cbBegin + cchnl > cchMax)
	{
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
	}
	cchOut -= pCertHeader->cbBegin + cchnl;
	CopyMemory(pchEncode, pCertHeader->pszBegin, pCertHeader->cbBegin);
	pchEncode += pCertHeader->cbBegin/sizeof(TCHAR);
	if (!fNoCR)
	{
	    *pchEncode++ = '\r';
	}
	*pchEncode++ = '\n';
    }

    // first determine size

    switch (~CRYPT_STRING_NOCR & dwFlags)
    {
	case CRYPT_STRING_BINARY:
	    dwErr = BinaryEncode(pbBinary, cbBinary, pchEncode, &cchOut);
	    if (ERROR_SUCCESS != dwErr)
            {
                goto BinaryEncodeError;
            }
            fBinaryCopy = TRUE;
	    break;

	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    dwErr = HexEncode(pbBinary, cbBinary, dwFlags, pchEncode, &cchOut);
	    if (ERROR_SUCCESS != dwErr)
            {
                goto HexEncodeError;
            }
	    break;

	default:
	    dwErr = Base64Encode(pbBinary, cbBinary, dwFlags, pchEncode, &cchOut);
            if (ERROR_SUCCESS != dwErr)
            {
                goto Base64EncodeError;
            }
	    break;
    }

    // Compute total size, including the trailing '\0' character.
    if (fBinaryCopy)
    {
        cbTotal = cchOut;
    }
    else
    {
        cbTotal = (cchOut + 1) * sizeof(CHAR);
    }

    // Add space for the BEGIN & END headers, if requested.

    if (NULL != pCertHeader)
    {
	cbTotal += pCertHeader->cbBegin + pCertHeader->cbEnd;
	if (!fNoCR)
	{
	    cbTotal += 2 * sizeof(TCHAR);	// for BEGIN & END '\r' chars
	}
	cbTotal += 2 * sizeof(TCHAR);		// for BEGIN & END '\n' chars
    }

    if (fBinaryCopy)
    {
        *pcchString = cbTotal;
    }
    else
    {
        // if pszString is NULL, set size to include trailing '\0'
        *pcchString = cbTotal / sizeof(CHAR);
    }

    if (NULL == pszString)
    {
        // only determine size, done
        goto done;
    }

    if (NULL != pCertHeader)
    {
	cchOut += pCertHeader->cbBegin/sizeof(CHAR) + cchnl;

	// Make sure there's room for the END header, CR-LF sequence, and '\0'

	if (cchOut + pCertHeader->cbEnd + cchnl + 1 > cchMax)
	{
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
	}
	CopyMemory(&pszString[cchOut], pCertHeader->pszEnd, pCertHeader->cbEnd);
	cchOut += pCertHeader->cbEnd/sizeof(CHAR);
	if (!fNoCR)
	{
	    pszString[cchOut++] = '\r';
	}
	pszString[cchOut++] = '\n';
    }

    if (!fBinaryCopy)
    {
        pszString[cchOut] = '\0';
        assert((cchOut + 1) * sizeof(CHAR) == cbTotal);

        // pszString is not NULL, don't include trailing '\0' in length

        *pcchString = cchOut;
    }

done:
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return(ERROR_SUCCESS == dwErr);

TRACE_ERROR(Base64EncodeError)
TRACE_ERROR(HexEncodeError)
TRACE_ERROR(BinaryEncodeError)
SET_ERROR(InvalidDataError, dwErr)
SET_ERROR(MoreDataError, dwErr)
}


static TCHAR const szBeginMatch[] = TEXT("-----BEGIN ");
static TCHAR const szEndMatch[] = TEXT("-----END ");
static TCHAR const szMinus[] = TEXT("-----");

#define CCH_BEGINMATCH  sizeof(szBeginMatch)/sizeof(szBeginMatch[0]) - 1
#define CCH_ENDMATCH    sizeof(szEndMatch)/sizeof(szEndMatch[0]) - 1
#define CCH_MINUS       sizeof(szMinus)/sizeof(szMinus[0]) - 1

// Returns the count of characters up to the -----BEGIN/-----END delimiter,
//	MAXDWORD on error.
//
// On successful return, *pcchSkip is the count of characters in the delimiter
//	string.

DWORD
SizeBase64Header(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = MAXDWORD;
    TCHAR const *pchT;
    TCHAR const *pchT2;
    TCHAR const *pchEnd;
    TCHAR const *pchMatch;
    DWORD cchMatch;

    // Skip to the starting '-----....' & return count of skipped characters.

    *pcchSkip = 0;
    if (fBegin)
    {
	pchMatch = szBeginMatch;
	cchMatch = CCH_BEGINMATCH;
    }
    else
    {
	pchMatch = szEndMatch;
	cchMatch = CCH_ENDMATCH;
    }
    pchT = pchIn;
    pchEnd = &pchIn[cchIn];

    for (;;)
    {
	// Skip until we match the first character.

	while (pchT < pchEnd && *pchT != *pchMatch)
	{
	    pchT++;
	}

	if (&pchT[cchMatch] > pchEnd)
	{
	    // no room for the "-----BEGIN "/"-----END " string
	    break;
	}
	if (0 == strncmp(pchT, pchMatch, cchMatch))
	{
	    pchT2 = &pchT[cchMatch];
	    while (pchT2 < pchEnd && *pchT2 != szMinus[0])
	    {
		pchT2++;
	    }
	    if (&pchT2[CCH_MINUS] > pchEnd)
	    {
		// no room for the trailing "-----" string
		break;
	    }
	    if (0 == strncmp(pchT2, szMinus, CCH_MINUS))
	    {
		// Allow up to 2 extra leading minus signs

		DWORD cchMinus = 0;

		while (2 > cchMinus && pchT > pchIn)
		{
		    if (TEXT('-') != *--pchT)
		    {
			pchT++;		// oops, went too far
			break;
		    }
		    cchMinus++;
		}

#if DBG
		if (0 != cchMinus)
		{
		    DbgPrintf(DBG_SS_TRACE,
			"Ignored leading data: \"%.*" szFMTTSTR "\"\n",
			cchMinus,
			TEXT("--"));
		}
#endif //DBG

		cchHeader = SAFE_SUBTRACT_POINTERS(pchT, pchIn);
		*pcchSkip = SAFE_SUBTRACT_POINTERS(pchT2, pchT) + CCH_MINUS;
#if DBG
#if 0
		DbgPrintf(
		    DBG_SS_TRACE,
		    "Skipping(%u, %x, %x):\n[%.*" szFMTTSTR "]\n",
		    fBegin,
		    cchHeader,
		    *pcchSkip,
		    cchHeader,
		    pchIn);
#endif
#endif // DBG
		break;
	    }
	}
	pchT++;
    }
    return(cchHeader);
}

BOOL
WINAPI
CryptBinaryToStringW(
    IN  CONST BYTE  *pbBinary,
    IN  DWORD        cbBinary,
    IN  DWORD        dwFlags,
    OUT LPWSTR       pwszString,
    OUT DWORD       *pcchString)
{
    BOOL  fRet = FALSE;
    BOOL  fConversion = FALSE;
    DWORD dwErr;
    int   len;
    CHAR  *pszString = NULL;

    if (NULL == pwszString)
    {
        //only return size
        fRet = CryptBinaryToStringA(
                    pbBinary,
                    cbBinary,
                    dwFlags,
                    NULL, //for size
                    pcchString);
    }
    else
    {
        if (0 == *pcchString)
        {
            //must bigger than 0
            dwErr = ERROR_INVALID_PARAMETER;
            goto InvalidDataError;
        }

        if (CRYPT_STRING_BINARY == (~CRYPT_STRING_NOCR & dwFlags))
        {
            //no conversion needed
            pszString = (CHAR*)pwszString;
        }
        else
        {
            pszString = (CHAR*)LocalAlloc(LMEM_FIXED, *pcchString * sizeof(CHAR));
            if (NULL == pszString)
            {
                goto LocalAllocError;
            }
            fConversion = TRUE;
        }

        fRet = CryptBinaryToStringA(
                    pbBinary,
                    cbBinary,
                    dwFlags,
                    pszString,
                    pcchString);
        if (!fRet)
        {
            goto CryptBinaryToStringAError;
        }
        //pszString in above call is not NULL, so pcchString can be 1 smaller
        //then IN size after the call for exlucding NULL

        if (fConversion)
        {
            len = MultiByteToWideChar(
                    GetACP(),
                    0, 
                    pszString,
                    (*pcchString + 1) * sizeof(CHAR),
                    pwszString,
                    *pcchString + 1);
            //add 1 to *pcchString to include NULL for the conversion
            //but keep *pcchString for return
            if (0 == len)
            {
                fRet = FALSE;
                goto MultiByteToWideCharError;
            }
            assert(len == (int)(*pcchString + 1));
        }
    }

ErrorReturn:
    if (fConversion && NULL != pszString)
    {
        LocalFree(pszString);
    }
    return fRet;

TRACE_ERROR(MultiByteToWideCharError)
TRACE_ERROR(CryptBinaryToStringAError)
TRACE_ERROR(LocalAllocError)
SET_ERROR(InvalidDataError, dwErr)
}


#define NOTEPAD_UNICODE_SPECIAL_WCHAR   L'\xfeff'

BOOL
WINAPI
CryptStringToBinaryW(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN OUT BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    IN OUT DWORD    *pdwSkip,    //OPTIONAL
    IN OUT DWORD    *pdwFlags)   //OPTIONAL
{
    BOOL    fRet = FALSE;
    BOOL    fFree = FALSE;
    DWORD   dwErr;
    CHAR   *pszString = NULL;

    if (NULL == pwszString || NULL == pcbBinary)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (dwFlags == CRYPT_STRING_BINARY)
    {
        //its binary, no conversion
        pszString = (CHAR*)pwszString;
    }
    else
    {
        if (0 == cchString)
        {
            //assume null terminated string
            cchString = wcslen(pwszString) + 1;
        }

        // Check for the special Notepad UNICODE character inserted at the
        // beginning and skip past it if present.
        if (0 < cchString && NOTEPAD_UNICODE_SPECIAL_WCHAR == *pwszString)
        {
            cchString--;
            pwszString++;
        }

        pszString = (CHAR*)LocalAlloc(LMEM_FIXED, cchString * sizeof(CHAR));
        if (NULL == pszString)
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto LocalAllocError;
        }

        fFree = TRUE;
        if (0 == WideCharToMultiByte(
                        GetACP(), 
                        0, 
                        pwszString, 
                        cchString, 
                        pszString, 
                        cchString, 
                        NULL, 
                        NULL))
        {
            goto WideCharToMultiByteError;
        }
    }

    fRet = CryptStringToBinaryA(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
    if (!fRet)
    {
        goto CryptStringToBinaryAError;
    }

ErrorReturn:
    if (fFree && NULL != pszString)
    {
        LocalFree(pszString);
    }
    return fRet;

TRACE_ERROR(CryptStringToBinaryAError)
SET_ERROR(LocalAllocError, dwErr)
SET_ERROR(InvalidDataError, dwErr)
TRACE_ERROR(WideCharToMultiByteError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       asn1util.cpp
//
//  Contents:   ASN.1 utility helper functions.
//
//  Functions:  Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//              Asn1UtilExtractKeyIdFromCertInfo
//
//  History:    04-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a BER encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets if definite
//                       encoding, else CMSG_INDEFINITE_LENGTH
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the encoding
//
//  Returns:
//          success - the number of bytes in the length field, >0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbEncoded)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbEncoded < 1)
        goto TooLittleData;

    if (0x80 == *pbLength) {
        *pcbContent = CMSG_INDEFINITE_LENGTH;
        i = 1;
        goto CommonReturn;
    }

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbEncoded)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

ErrorReturn:
    i = -1;
    goto CommonReturn;
TooLittleData:
    i = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
TRACE_ERROR(LengthTooLargeError)
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
//  NB- If the blob is indefinite-length encoded, *pcbContent is set to
//  CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbEncoded;

    if (0 == cbEncoded--)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        cbIdentifier = 2;
        while (TRUE) {
            if (0 == cbEncoded--)
                goto TooLittleData;
            if (0 == (*pb++ & 0x80))
                break;
            cbIdentifier++;
        }
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = Asn1UtilDecodeLength( &cbContent, pb, cbEncoded))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER)
{
    DWORD cbContent;
    const BYTE *pbContent;

  // Handle MappedFile Exceptions
  __try {

    if (0 < Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent) &&
            (pbContent < pbDER + cbDER) &&
            (0x02 == *pbContent))
        return TRUE;
    else
        return FALSE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    SetLastError(GetExceptionCode());
    return FALSE;
  }
}

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    // Decode the header to get the real length. I've seen files with extra
    // stuff.

    LONG lLen;
    DWORD cbLen;
    DWORD cbContent;
    const BYTE *pbContent;
    lLen = Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent);
    if ((lLen >= 0) && (cbContent != CMSG_INDEFINITE_LENGTH)) {
        cbLen = (DWORD)lLen + cbContent;
        if (cbLen < cbDER)
            cbDER = cbLen;
        // else if (cbLen > cbDER)
        //  DER length exceeds input file
    }
    // else
    //  Can't decode DER length
            
    return cbDER;
}

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValue;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;

    DWORD iValue;
    LONG lAllValues;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & ASN1UTIL_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        BOOL fValueBlob = (dwParaFlags & (ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
                ASN1UTIL_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (0 == cb) {
            if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                goto TooLittleData;
            if (fValueBlob) {
                rgValueBlob[iValue].pbData = NULL;
                rgValueBlob[iValue].cbData = 0;
            }
            continue;
        }

        // Assumption: single byte tag for doing comparison
        if (pbParaTag) {
            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                    goto InvalidTag;
                if (fValueBlob) {
                    rgValueBlob[iValue].pbData = NULL;
                    rgValueBlob[iValue].cbData = 0;
                }
                continue;
            }
        }

        lTagLength = Asn1UtilExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength || (DWORD) lTagLength > cb)
            goto InvalidTagOrLength;

        if (CMSG_INDEFINITE_LENGTH == cbContent) {
            if (ASN1UTIL_STEP_INTO_VALUE_OP != dwOp)
                goto UnsupportedIndefiniteLength;
            else if (fValueBlob && (dwFlags & ASN1UTIL_DEFINITE_LENGTH_FLAG))
                goto NotAllowedIndefiniteLength;
            cbValue = CMSG_INDEFINITE_LENGTH;
        } else {
            cbValue = cbContent + lTagLength;
            if (cbValue > cb)
                goto TooLittleData;
        }

        if (fValueBlob) {
            if (dwParaFlags & ASN1UTIL_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pbContent;
                rgValueBlob[iValue].cbData = cbContent;
            } else if (dwParaFlags & ASN1UTIL_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pb;
                rgValueBlob[iValue].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case ASN1UTIL_STEP_INTO_VALUE_OP:
                pb += lTagLength;
                cb -= lTagLength;
                break;
            case ASN1UTIL_STEP_OVER_VALUE_OP:
            case ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;

        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValue = iValue;
    return lAllValues;

ErrorReturn:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;

SET_ERROR(TooLittleData, ERROR_INVALID_DATA)
SET_ERROR(InvalidTag, ERROR_INVALID_DATA)
SET_ERROR(InvalidTagOrLength, ERROR_INVALID_DATA)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
SET_ERROR(NotAllowedIndefiniteLength, ERROR_INVALID_DATA)
}

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBitStringTag[] = {ASN1UTIL_TAG_BITSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractSignedDataContentPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
    //     3 - SignedData ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       4 - version             INTEGER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //       5 - digestAlgorithms    DigestAlgorithmIdentifiers,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
    //       6 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       7 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //       8 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
};

#define SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX   1
#define SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX     4
#define SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX   7
#define SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX    6
#define SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX   8
#define SIGNED_DATA_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractSignedDataContentPara) / \
        sizeof(rgExtractSignedDataContentPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertSignedContent[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - toBeSigned          NOCOPYANY,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, NULL,
    //   2 - algorithm           AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - signature           BITSTRING
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbBitStringTag,
};

#define CERT_TO_BE_SIGNED_VALUE_INDEX               1
#define CERT_SIGNED_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractCertSignedContent) / \
        sizeof(rgExtractCertSignedContent[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertPublicKeyInfo[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - CertificateToBeSigned ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //      2 - version                 [0] CertificateVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
    //      3 - serialNumber            CertificateSerialNumber,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //      4 - signature               AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      5 - issuer                  NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      6 - validity                Validity,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      7 - subject                 NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      8 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag
};

#define CERT_PUBLIC_KEY_INFO_VALUE_INDEX    8
#define CERT_PUBLIC_KEY_INFO_VALUE_COUNT        \
    (sizeof(rgExtractCertPublicKeyInfo) / \
        sizeof(rgExtractCertPublicKeyInfo[0]))


// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
static const BYTE rgbOIDSignedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

static const CRYPT_DER_BLOB EncodedOIDSignedData = {
    sizeof(rgbOIDSignedData), (BYTE *) rgbOIDSignedData
};

#ifdef CMS_PKCS7

// #define szOID_RSA_Data    "1.2.840.113549.1.7.1"
static const BYTE rgbOIDData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01};

static const CRYPT_DER_BLOB EncodedOIDData = {
    sizeof(rgbOIDData), (BYTE *) rgbOIDData
};

#endif // CMS_PKCS7


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
static BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    LONG lSkipped;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[SIGNED_DATA_CONTENT_VALUE_COUNT];

    DWORD cbContent;
    const BYTE *pbContent;
    DWORD cbSeq;
    const BYTE *pbSeq;

    cValue = SIGNED_DATA_CONTENT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &cValue,
            rgExtractSignedDataContentPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    pbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].pbData;
    cbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].cbData;

    // For definite-length encoded, check that the content wasn't
    // omitted.
    //
    // Note, for indefinite-length encoding, if the content was omitted,
    // we would have had a 0 tag instead of the CONTEXT_0 tag.
    cbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].cbData;
    pbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].pbData;
    if (CMSG_INDEFINITE_LENGTH != cbSeq && pbContent >= (pbSeq + cbSeq))
        goto NoSignedDataError;

#ifdef CMS_PKCS7
    // For V3 SignedData, non Data types are wrapped, encapsulated with a
    // OCTET string
    if (1 == rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].cbData &&
            CMSG_SIGNED_DATA_V3 <=
                *(rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].pbData)
                        &&
            !CompareEncodedOID(
                &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
                &EncodedOIDData)
                        &&
            0 != cbContent && ASN1UTIL_TAG_OCTETSTRING == *pbContent
            ) {
        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        // Advance past the outer OCTET wrapper
        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength) {
            lSkipped += lTagLength;
            cbContent = cbInner;
            pbContent = pbInner;
        }
    }
#endif

    if (CMSG_INDEFINITE_LENGTH == cbContent) {
        // Extract the pbContent and attempt to get its definite length

        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength && CMSG_INDEFINITE_LENGTH != cbInner)
            cbContent = cbInner + lTagLength;
    }

    // Verify that the outer ContentType is SignedData and the inner
    // ContentType is the specified type
    if (!CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX],
            &EncodedOIDSignedData
            ))
        goto NotSignedDataContentType;
    if (pEncodedInnerOID && !CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
            pEncodedInnerOID
            ))
        goto UnexpectedInnerContentTypeError;

    *pcbContent = cbContent;
    *ppbContent = pbContent;

CommonReturn:
    return lSkipped;

ErrorReturn:
    if (0 <= lSkipped)
        lSkipped = -lSkipped - 1;
    *pcbContent = 0;
    *ppbContent = NULL;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSignedDataError, ERROR_INVALID_DATA)
SET_ERROR(NotSignedDataContentType, ERROR_INVALID_DATA)
SET_ERROR(UnexpectedInnerContentTypeError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_SIGNED_CONTENT_VALUE_COUNT];

    cValue = CERT_SIGNED_CONTENT_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertSignedContent,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].pbData;
    *pcbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbContent = NULL;
    *pcbContent = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_COUNT];

    cValue = CERT_PUBLIC_KEY_INFO_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertPublicKeyInfo,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].pbData;
    *pcbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbPublicKeyInfo = NULL;
    *pcbPublicKeyInfo = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}


// Special RDN containing the KEY_ID. Its value type is CERT_RDN_OCTET_STRING.
//#define szOID_KEYID_RDN                     "1.3.6.1.4.1.311.10.7.1"
static const BYTE rgbOIDKeyIdRDN[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x07, 0x01};

static const CRYPT_DER_BLOB EncodedOIDKeyIdRDN = {
    sizeof(rgbOIDKeyIdRDN), (BYTE *) rgbOIDKeyIdRDN
};

static const BYTE rgbOctetStringTag[] = {ASN1UTIL_TAG_OCTETSTRING, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractNameKeyIdRDNPara[] = {
    // 0 - Name ::= SEQUENCE OF RelativeDistinguishedName
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - RelativeDistinguishedName ::= SET OF AttributeTypeValue
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSetTag,
    //     2 - AttributeTypeValue ::= SEQUENCE
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       3 - type       EncodedObjectID,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //       4 - value      NOCOPYANY 
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
};

#define NAME_KEYID_RDN_OID_VALUE_INDEX              3
#define NAME_KEYID_RDN_OCTET_VALUE_INDEX            4
#define NAME_KEYID_RDN_VALUE_COUNT                  \
    (sizeof(rgExtractNameKeyIdRDNPara) / \
        sizeof(rgExtractNameKeyIdRDNPara[0]))


//+-------------------------------------------------------------------------
//  If the Issuer and SerialNumber in the CERT_INFO contains a special
//  KeyID RDN attribute returns TRUE with pKeyId's cbData and pbData updated
//  with the RDN attribute's OCTET_STRING value. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractKeyIdFromCertInfo(
    IN PCERT_INFO pCertInfo,
    OUT PCRYPT_HASH_BLOB pKeyId
    )
{
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[NAME_KEYID_RDN_VALUE_COUNT];

    if (0 == pCertInfo->SerialNumber.cbData ||
            0 != *pCertInfo->SerialNumber.pbData)
        goto NoKeyId;

    cValue = NAME_KEYID_RDN_VALUE_COUNT;
    if (0 > Asn1UtilExtractValues(
            pCertInfo->Issuer.pbData,
            pCertInfo->Issuer.cbData,
            0,                  // dwFlags
            &cValue,
            rgExtractNameKeyIdRDNPara,
            rgValueBlob
            ))
        goto NoKeyId;

    if (!CompareEncodedOID(
            &rgValueBlob[NAME_KEYID_RDN_OID_VALUE_INDEX],
            &EncodedOIDKeyIdRDN))
        goto NoKeyId;

    if (CMSG_INDEFINITE_LENGTH ==
            rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].cbData)
        goto NoKeyId;

    pKeyId->pbData = rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].pbData;
    pKeyId->cbData = rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].cbData;
    return TRUE;

NoKeyId:
    pKeyId->pbData = NULL;
    pKeyId->cbData = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\catutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catutil.cpp
//
//  Contents:   catalog database common functions
//
//  History:    01-may-2000 reidk created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "catutil.h"


//---------------------------------------------------------------------------------------
//
//  CatUtil_CreateCTLContextFromFileName
//
//---------------------------------------------------------------------------------------
BOOL
CatUtil_CreateCTLContextFromFileName(
    LPCWSTR         pwszFileName,
    HANDLE          *phMappedFile,
    BYTE            **ppbMappedFile,
    PCCTL_CONTEXT   *ppCTLContext,
    BOOL            fCreateSorted)
{
    BOOL    fRet = TRUE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   cbFile = 0;
    HANDLE  hMappedFile = NULL;
    BYTE    *pbMappedFile = NULL;

    //
    // Initialize out params
    //
    *phMappedFile = NULL;
    *ppbMappedFile = NULL;
    *ppCTLContext = NULL;

    //
    // Open the existing catalog file 
    //
    hFile = CreateFileW(
                    pwszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {    
        goto ErrorCreateFile;
    }

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        goto ErrorGetFileSize;
    }

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL);
    if (hMappedFile == NULL)
    {
        goto ErrorCreateFileMapping;
    }
    
    pbMappedFile = (BYTE *) MapViewOfFile(
                                hMappedFile, 
                                FILE_MAP_READ, 
                                0, 
                                0, 
                                cbFile);
    if (pbMappedFile == NULL)
    {
        goto ErrorMapViewOfFile;
    }

    //
    // Don't need the file handle since we have a mapped file handle
    //
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    if (NULL == (*ppCTLContext = (PCCTL_CONTEXT) 
                                    CertCreateContext(
                                        CERT_STORE_CTL_CONTEXT,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        pbMappedFile,
                                        cbFile,
                                        fCreateSorted ?
                                            CERT_CREATE_CONTEXT_NOCOPY_FLAG | CERT_CREATE_CONTEXT_SORTED_FLAG :
                                            CERT_CREATE_CONTEXT_NOCOPY_FLAG,
                                        NULL)))
    {
        goto ErrorCertCreateContect;
    }

    *phMappedFile = hMappedFile;
    *ppbMappedFile = pbMappedFile;

CommonReturn:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return fRet;

ErrorReturn:

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCreateFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetFileSize)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCreateFileMapping)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMapViewOfFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCertCreateContect)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkifmt\hex.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        hex.cpp
//
// Contents:    hex encode/decode implementation
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdio.h>

#include <dbgdef.h>
#include "pkifmt.h"

#include <tchar.h>  // must be included after dbgdef.h


__inline BOOL
_IsWhiteSpaceChar(
    TCHAR ch)
{
    return(
    TEXT(' ') == ch ||
    TEXT('\t') == ch ||
    TEXT('\r') == ch);
}


DWORD
_DigToHex(
    IN TCHAR ch,
    OUT BYTE *pb)
{
    BYTE b;
    DWORD dwErr = ERROR_SUCCESS;

    if (!_istxdigit(ch))
    {
        dwErr = ERROR_INVALID_DATA;
#if DBG
    DbgPrintf(DBG_SS_TRACE, "bad hex data: %02x\n", ch);
#endif //DBG
        goto BadHexDataError;
    }
    if (_istdigit(ch))
    {
    b = ch - TEXT('0');
    }
    else
    if (_istupper(ch))
    {
    b = ch - TEXT('A') + 10;
    }
    else
    {
    b = ch - TEXT('a') + 10;
    }
    *pb = b;

ErrorReturn:
    return (dwErr);

SET_ERROR(BadHexDataError, dwErr)
}


__inline BOOL
_IsSkipChar(
    TCHAR ch)
{
    return(
    TEXT(' ') == ch ||
    TEXT('\t') == ch ||
    TEXT('\r') == ch ||
    TEXT('\n') == ch ||
    TEXT(',') == ch ||
    TEXT('-') == ch);
}


DWORD
_HexDecodeSimple(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR const *pch = pchIn;
    TCHAR const *pchEnd;
    DWORD cb = 0;
    BOOL fOverFlow = FALSE;

    pchEnd = &pchIn[cchIn];
    while (pch < pchEnd)
    {
    BYTE blo;
    BYTE bhi;

    if (_IsSkipChar(*pch))
    {
        pch++;
        continue;
    }

    dwErr = _DigToHex(*pch, &bhi);
        if (ERROR_SUCCESS != dwErr)
        {
            goto _DigToHexError;
        }

    pch++;
    if (pch >= pchEnd)
    {
        dwErr = ERROR_INVALID_DATA;
        goto BadHexDataError;
    }
    dwErr = _DigToHex(*pch, &blo);
        if (ERROR_SUCCESS != dwErr)
        {
            goto _DigToHexError;
        }

    pch++;
    if (NULL != pbOut)
    {
        if (cb >= *pcbOut)
        {
        fOverFlow = TRUE;
        pbOut = NULL;
        }
        else
        {
        *pbOut++ = blo | (bhi << 4);
        }
    }
    cb++;
    }
    *pcbOut = cb;

    if (fOverFlow)
    {
        dwErr = ERROR_MORE_DATA;
    goto MoreDataError;
    }

ErrorReturn:
    return (dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(BadHexDataError, dwErr)
TRACE_ERROR(_DigToHexError)
}


DWORD
_HexParse(
    IN OUT TCHAR const **ppch,
    IN TCHAR const *pchEnd,
    IN DWORD cDigitMin,
    IN DWORD cDigitMax,
    OUT DWORD *pdwValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR const *pch = *ppch;
    DWORD Value = 0;
    DWORD cDigit = 0;
    BYTE b;

    *pdwValue = 0;

    while (pch < pchEnd && cDigit <= cDigitMax)
    {
    //printf("HexParse %u/%u-%u, ch=%02x\n", cDigit, cDigitMin, cDigitMax, *pch);
    dwErr = _DigToHex(*pch, &b);
    if (ERROR_SUCCESS != dwErr)
    {
        break;
    }
    Value = b | (Value << 4);
    pch++;
    cDigit++;

    }
    //printf("HexParse %u/%u-%u, val=%x\n", cDigit, cDigitMin, cDigitMax, Value);
    if (cDigit < cDigitMin || cDigit > cDigitMax)
    {
        dwErr = ERROR_INVALID_DATA;
    goto BadHexDataError;
    }
    *pdwValue = Value;
    *ppch = pch;
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return (dwErr);

SET_ERROR(BadHexDataError, dwErr)
}


#define HS_ADDRESS  0
#define HS_HEXDATA  1
#define HS_ASCIIDATA    2
#define HS_NEWLINE  3

DWORD
_HexDecodeComplex(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    TCHAR const *pch = pchIn;
    TCHAR const *pchEnd;
    DWORD cb = 0;
    DWORD dwErr;
    DWORD LastAddress = 0;
    DWORD Address;
    DWORD i;
    BOOL fOverFlow = FALSE;
    BOOL fPartialLastLine = FALSE;
    int *pStateBase;
    int *pState;

    int s_aASCIIADDRState[] = { HS_ADDRESS, HS_HEXDATA, HS_ASCIIDATA, HS_NEWLINE };
    int s_aASCIIState[] = { HS_HEXDATA, HS_ASCIIDATA, HS_NEWLINE };
    int s_aADDRState[] = { HS_ADDRESS, HS_HEXDATA, HS_NEWLINE };


    switch (Flags)
    {
        case CRYPT_STRING_HEXASCII:     // 5
        pStateBase = s_aASCIIState;
        break;

        case CRYPT_STRING_HEXADDR:      // 0xa
        pStateBase = s_aADDRState;
        break;

    case CRYPT_STRING_HEXASCIIADDR:     // 0xb
        pStateBase = s_aASCIIADDRState;
        break;

    default:
        dwErr = ERROR_INVALID_DATA; //hr = E_INVALIDARG;
        goto FlagsError;
    }
    pState = pStateBase;

    pchEnd = &pchIn[cchIn];
    while (pch < pchEnd)
    {
    //printf("f=%x: *pState: %u  ch=%02x\n", Flags, *pState, *pch);
    switch (*pState++)
    {
        case HS_ADDRESS:
        // decode 4 to 8 digit address:

        while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
        {
            pch++;
        }
        if (pch >= pchEnd)
        {
            continue;   // Done: no more data
        }
        dwErr = _HexParse(&pch, pchEnd, 4, 8, &Address);
                if (ERROR_SUCCESS != dwErr)
                {
            goto _HexParseError;
                }

        //printf("f=%x: Address: %x\n", Flags, Address);
        if (!fPartialLastLine &&
            0 != LastAddress &&
            LastAddress + 16 != Address)
        {
            dwErr = ERROR_INVALID_DATA;
            goto BadHexDataError;
        }
        LastAddress = Address;
        break;

        case HS_HEXDATA:
        // decode up to 16 bytes of hex data
        for (i = 0; i < 16; i++)
        {
            DWORD Data;

            // decode 2 digit byte value:

            while (pch < pchEnd && _IsSkipChar(*pch))
            {
            pch++;
            }
            if (pch >= pchEnd)
            {
            break;  // Done: no more data
            }
            if (fPartialLastLine)
            {
            //printf("f=%x: fPartialLastLine extra data: %02x\n", Flags, *pch);
            dwErr = ERROR_INVALID_DATA;
            goto DataAfterEndError;
            }
            dwErr = _HexParse(&pch, pchEnd, 2, 2, &Data);
            if (ERROR_SUCCESS != dwErr)
            {
            // Must be a partial last line.  The only additional
            // data should be an optional partial ascii display on
            // the right, a newline, and possibly one more address
            // line.

            //printf("f=%x: fPartialLastLine = TRUE: %02x\n", Flags, *pch);
            fPartialLastLine = TRUE;
            break;
            }

            //printf("f=%x: Data[%u]: %02x\n", Flags, i, Data);
            if (NULL != pbOut)
            {
            if (cb >= *pcbOut)
            {
                fOverFlow = TRUE;
                pbOut = NULL;
            }
            else
            {
                *pbOut++ = (BYTE) Data;
            }
            }
            cb++;
        }
        break;

        case HS_ASCIIDATA:
        // skip up to 16 non-whitespace characters

        while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
        {
            pch++;
        }
        for (i = 0; i < 16; i++)
        {
            if (pch >= pchEnd || TEXT(' ') > *pch || TEXT('~') < *pch)
            {
            break;
            }
            //printf("f=%x: Ascii[%u]: %c\n", Flags, i, *pch);
            pch++;
        }
        break;

        case HS_NEWLINE:
        // skip whitespace characters and a newline

        while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
        {
            //printf("f=%x: NL skip: %02x\n", Flags, *pch);
            pch++;
        }
        //printf("f=%x: NL: %02x\n", Flags, *pch);
        if (pch >= pchEnd)
        {
            continue;   // Done: no more data
        }
        if (TEXT('\n') != *pch)
        {
            //printf("f=%x: Extra Data: %02x\n", Flags, *pch);
            dwErr = ERROR_INVALID_DATA;
            goto ExtraDataOnLineError;
        }
        //printf("f=%x: NewLine\n", Flags);
        pch++;
        pState = pStateBase;
        break;

        default:
        assert(!"Bad *pState");
    }
    }
    *pcbOut = cb;
    if (fOverFlow)
    {
    dwErr = ERROR_MORE_DATA;
    goto MoreDataError;
    }

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return(dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(ExtraDataOnLineError, dwErr)
SET_ERROR(BadHexDataError, dwErr)
TRACE_ERROR(_HexParseError)
SET_ERROR(DataAfterEndError, dwErr)
SET_ERROR(FlagsError, dwErr)
}


DWORD
HexDecode(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    DWORD dwErr;

    if (CRYPT_STRING_HEX == Flags)
    {
    dwErr = _HexDecodeSimple(pchIn, cchIn, pbOut, pcbOut);
        if (ERROR_SUCCESS != dwErr)
        {
#if DBG
            //skip ERROR_INVALID_DATA dbg print
            if (ERROR_INVALID_DATA == dwErr)
            {
                SetLastError(dwErr);
                goto ErrorReturn;
            }
#endif
            goto _HexDecodeSimpleError;
        }
    }
    else
    {
    dwErr = _HexDecodeComplex(pchIn, cchIn, Flags, pbOut, pcbOut);
        if (ERROR_SUCCESS != dwErr)
        {
#if DBG
            //skip ERROR_INVALID_DATA dbg print
            if (ERROR_INVALID_DATA == dwErr)
            {
                SetLastError(dwErr);
                goto ErrorReturn;
            }
#endif
            goto _HexDecodeComplexError;
        }
    }

ErrorReturn:
    return(dwErr);

TRACE_ERROR(_HexDecodeSimpleError)
TRACE_ERROR(_HexDecodeComplexError)
}

TCHAR
_IsPrintableChar(TCHAR ch)
{
    if (ch < TEXT(' ') || ch > TEXT('~'))
    {
        ch = TEXT('.');
    }
    return(ch);
}


// Encode a BYTE array into text as a hex dump.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.

DWORD
HexEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    TCHAR const *pszsep;
    TCHAR const *psznl;
    DWORD r;
    DWORD i;
    DWORD cbremain;
    DWORD cchOut = 0;
    DWORD cch;
    TCHAR *pch = pchOut;
    DWORD dwErr = ERROR_MORE_DATA;
    BOOL fAscii = FALSE;
    BOOL fAddress = FALSE;
    TCHAR szAddress[32];
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    switch (~CRYPT_STRING_NOCR & Flags)
    {
    case CRYPT_STRING_HEX:
        break;

    case CRYPT_STRING_HEXASCII:
        fAscii = TRUE;
        break;

    case CRYPT_STRING_HEXADDR:
        fAddress = TRUE;
        break;

    case CRYPT_STRING_HEXASCIIADDR:
        fAscii = TRUE;
        fAddress = TRUE;
        break;

    default:
        dwErr = ERROR_INVALID_DATA; //hr = E_INVALIDARG;
        goto FlagsError;
    }
    for (r = 0; r < cbIn; r += 16)
    {
    DWORD iEnd;

        cbremain = cbIn - r;
    iEnd = min(cbremain, 16);

        for (i = 0; i < iEnd; i++)
        {
            psznl = TEXT("");
        szAddress[0] = TEXT('\0');
            pszsep = TEXT(" ");
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = TEXT("  ");
                if (i == 0)             // 0
                {
            if (fAddress)
            {
            _stprintf(szAddress, TEXT("%04x"), r);
            }
                    pszsep = TEXT("\t");
                    if (r != 0)         // starting new line
                    {
            psznl = fNoCR? TEXT("\n") : TEXT("\r\n");
                        pszsep = TEXT("\t");
                    }
                }
            }
        cch = _tcslen(psznl) + _tcslen(szAddress) + _tcslen(pszsep) + 2;
        if (NULL != pchOut)
        {
        if (cchOut + cch + 1 > *pcchOut)
        {
            goto MoreDataError;
        }
        _stprintf(
            pch,
            TEXT("%s%s%s%02x"),
            psznl,
            szAddress,
            pszsep,
            pbIn[r + i]);
        pch += cch;
        assert(TEXT('\0') == *pch);
        assert(pch == &pchOut[cchOut + cch]);
        }
        cchOut += cch;
        }
        if (fAscii && 0 != i)
        {
        cch = 3 + (16 - i)*3 + ((i <= 8)? 1 : 0);

        if (NULL != pchOut)
        {
        if (cchOut + cch + iEnd + 1 > *pcchOut)
        {
            goto MoreDataError;
        }
        _stprintf(pch, TEXT("%*s"), cch, TEXT(""));
        pch += cch;
        assert(TEXT('\0') == *pch);
        assert(pch == &pchOut[cchOut + cch]);

        for (i = 0; i < iEnd; i++)
        {
            *pch++ = _IsPrintableChar(pbIn[r + i]);
            assert(pch == &pchOut[cchOut + cch + i + 1]);
        }
            }
        cchOut += cch + iEnd;
        }
    }
    if (r != 0)
    {
    DWORD cchnl = fNoCR? 1 : 2;

    if (NULL != pchOut)
    {
        if (cchOut + cchnl > *pcchOut)
        {
        goto MoreDataError;
        }
        if (!fNoCR)
        {
        *pch++ = TEXT('\r');
        }
        *pch++ = TEXT('\n');
        assert(pch == &pchOut[cchOut + cchnl]);
    }
    cchOut += cchnl;
    }
    *pcchOut = cchOut;

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return(dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(FlagsError, dwErr)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkifmt\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <dbgdef.h>
#include "pkifmt.h"

//#define BASE64_STRICT		// enforce syntax check on input data
#undef BASE64_STRICT		// enforce syntax check on input data


// The following table translates an ascii subset to 6 bit values as follows
// (see RFC 1421 and/or RFC 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";

#define MOD4(x) ((x) & 3)

__inline BOOL
_IsBase64WhiteSpace(
    IN TCHAR const ch)
{
    return(
	ch == TEXT(' ') ||
	ch == TEXT('\t') ||
	ch == TEXT('\r') ||
	ch == TEXT('\n'));
}


DWORD
Base64DecodeA(
    IN TCHAR const     *pchIn,
    IN DWORD           cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD      *pcbOut)
{
    DWORD dwErr;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    dwErr = ERROR_INVALID_DATA;
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // Found a non-base64 character.  Decide what to do.

	    DWORD cch;

	    if (_IsBase64WhiteSpace(*pchInT))
	    {
		continue;		// skip all whitespace
	    }

	    // The length calculation may stop in the middle of the last
	    // translation quantum, because the equal sign padding characters
	    // are treated as invalid input.  If the last translation quantum
	    // is not 4 bytes long, there must be 3, 2 or 1 equal sign(s).

	    if (0 != cchInDecode)
	    {
		cch = MOD4(cchInDecode);
		if (0 != cch)
		{
		    cch = 4 - cch;
		    while (0 != cch && pchInT < pchInEnd && '=' == *pchInT)
		    {
			pchInT++;
			cch--;
		    }
		}
//#ifdef BASE64_STRICT
		if (0 == cch)
//#endif
		{
		    break;
		}
	    }
#if DBG
            DbgPrintf(
                DBG_SS_TRACE,
                "Bad base64 data: \"%.*" szFMTTSTR "...\"\n",
                min(16, SAFE_SUBTRACT_POINTERS(pchInEnd, pchInT)),
                pchInT);
#endif //DBG
	    goto BadBase64Data;
	}
	cchInDecode++;			// only count valid base64 chars
    }
    assert(pchInT <= pchInEnd);
#ifdef BASE64_STRICT
    if (pchInT < pchInEnd)
    {
	TCHAR const *pch;
	DWORD cchEqual = 0;

	for (pch = pchInT; pch < pchInEnd; pch++)
	{
	    if (!_IsBase64WhiteSpace(*pch))
	    {
		// Allow up to 3 extra trailing equal signs.
		if (TEXT('=') == *pch && 3 > cchEqual)
		{
		    cchEqual++;
		    continue;
		}
#if DBG
		DbgPrintf(DBG_SS_TRACE,
		    "Bad trailing base64 data: \"%.*" szFMTTSTR "...\"\n",
		    min(16, SAFE_SUBTRACT_POINTERS(pchInEnd, pch)),
		    pch);
#endif //DBG
		goto BadTrailingBase64Data;
	    }
	}
#if DBG
	if (0 != cchEqual)
	{
	    DbgPrintf(DBG_SS_TRACE,
		"Ignored trailing base64 data: \"%.*" szFMTTSTR "\"\n",
		cchEqual,
		TEXT("==="));
	}
#endif //DBG
    }
#endif
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.  Compensate for a fractional translation quantum.

    cbOutDecode = ((cchInDecode + 3) >> 2) * 3;
    switch (cchInDecode % 4)
    {
	case 1:
	case 2:
	    cbOutDecode -= 2;
	    break;

	case 3:
	    cbOutDecode--;
	    break;
    }

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	//assert(cbOutDecode <= *pcbOut);
        if (cbOutDecode > *pcbOut)
        {
            *pcbOut = cbOutDecode;
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
        }

	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    ZeroMemory(ab4, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		assert(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	assert((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = SAFE_SUBTRACT_POINTERS(pbOutT, pbOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(BadBase64Data, dwErr)
#ifdef BASE64_STRICT
SET_ERROR(BadTrailingBase64Data, dwErr)
#endif
}


// Encode a BYTE array into a Base64 text string.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.
// Do not add -----BEGIN/END headers -- that's also handled by the caller.

DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    DWORD dwErr;
    TCHAR *pchOutT;
    DWORD cchOutEncode;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	(fNoCR? 1 : 2) *
	((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
	//printf("cchOut:       =%x Computed=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode);
    }
    else
    {
	DWORD cCol;

	if (cchOutEncode > *pcchOut)
	{
            *pcchOut = cchOutEncode;
	    dwErr = ERROR_MORE_DATA;
	    goto MoreDataError;
	}

	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		if (!fNoCR)
		{
		    *pchOutT++ = '\r';
		}
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    ZeroMemory(ab3, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}

	// Append CR-LF only if there was input data

	if (pchOutT != pchOut)
	{
	    if (!fNoCR)
	    {
		*pchOutT++ = '\r';
	    }
	    *pchOutT++ = '\n';
	}
	//printf("cchOut: Actual=%x Computed=%x Buffer=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode, *pcchOut);
	assert((DWORD) (pchOutT - pchOut) == cchOutEncode);
    }
    *pcchOut = SAFE_SUBTRACT_POINTERS(pchOutT, pchOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;

SET_ERROR(MoreDataError, dwErr)
}


DWORD
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *wszOut,
    OUT DWORD *pcchOut)
{

    DWORD   cchOut;
    CHAR   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    assert(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if (wszOut == NULL)
    {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(pbIn, cbIn, Flags, NULL, pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        pch = (CHAR *) malloc(cchOut);
        if (NULL != pch)
	{
            err = Base64EncodeA(pbIn, cbIn, Flags, pch, &cchOut);
	    if (ERROR_SUCCESS == err)
	    {
		// should not fail!
		cch = MultiByteToWideChar(0, 0, pch, cchOut, wszOut, *pcchOut);

		// check to make sure we did not fail
		assert(*pcchOut == 0 || cch != 0);
	    }
	}
    }

    if(pch != NULL)
        free(pch);

    return(err);
}


DWORD
Base64DecodeW(
    IN const WCHAR * wszIn,
    IN DWORD cch,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    CHAR *pch;
    DWORD err = ERROR_SUCCESS;

    // in all cases we need to convert to an ascii string
    // we know the ascii string is less

    if ((pch = (CHAR *) malloc(cch)) == NULL)
    {
        err = ERROR_OUTOFMEMORY;
    }

    // we know no base64 wide char map to more than 1 ascii char
    else if (WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, NULL, NULL) == 0)
    {
        err = ERROR_NO_DATA;
    }

    // get the length of the buffer
    else if (pbOut == NULL)
    {
        *pcbOut = 0;
        err = Base64Decode(pch, cch, NULL, pcbOut);
    }

    // otherwise fill in the buffer
    else {
        err = Base64Decode(pch, cch, pbOut, pcbOut);
    }

    if(pch != NULL)
        free(pch);

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\dir.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dir.cpp
//
//  Contents:   Directory functions
//
//  Functions:  I_RecursiveCreateDirectory
//
//  History:    06-Aug-99   reidk   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "crypthlp.h"
#include "unicode.h"
#include <dbgdef.h>


BOOL I_RecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    BOOL fResult;

    DWORD dwAttr;
    DWORD dwErr;
    LPCWSTR pwsz;
    DWORD cch;
    WCHAR wch;
    LPWSTR pwszParent = NULL;

    dwAttr = GetFileAttributesU(pwszDir);

    if (0xFFFFFFFF != dwAttr) {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
            return TRUE;
        goto InvalidDirectoryAttr;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto GetFileAttrError;

    if (CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes
            )) {
        SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);
        return TRUE;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto CreateDirectoryError;

    // Peal off the last path name component
    cch = wcslen(pwszDir);
    pwsz = pwszDir + cch;

    while (L'\\' != *pwsz) {
        if (pwsz == pwszDir)
            // Path didn't have a \.
            goto BadDirectoryPath;
        pwsz--;
    }

    cch = (DWORD)(pwsz - pwszDir);
    if (0 == cch)
        // Detected leading \Path
        goto BadDirectoryPath;


    // Check for leading \\ or x:\.
    wch = *(pwsz - 1);
    if ((1 == cch && L'\\' == wch) || (2 == cch && L':' == wch))
        goto BadDirectoryPath;

    if (NULL == (pwszParent = (LPWSTR) PkiNonzeroAlloc((cch + 1) *
            sizeof(WCHAR))))
        goto OutOfMemory;
    memcpy(pwszParent, pwszDir, cch * sizeof(WCHAR));
    pwszParent[cch] = L'\0';

    if (!I_RecursiveCreateDirectory(pwszParent, lpSecurityAttributes))
        goto ErrorReturn;
    if (!CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes
            )) {
        dwErr = GetLastError();
        goto CreateDirectory2Error;
    }
    SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszParent);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidDirectoryAttr, ERROR_FILE_INVALID)
SET_ERROR_VAR(GetFileAttrError, dwErr)
SET_ERROR_VAR(CreateDirectoryError, dwErr)
SET_ERROR(BadDirectoryPath, ERROR_BAD_PATHNAME)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateDirectory2Error, dwErr)
}


BOOL 
I_RecursiveDeleteDirectory(
    IN LPCWSTR pwszDelete
    )
{
    BOOL                fResult = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    LPWSTR              pwszSearch = NULL;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszDirOrFileDelete = NULL;
    DWORD               dwErr = 0;
    
    //
    // Create search string
    //
    pwszSearch = (LPWSTR) malloc((wcslen(pwszDelete) + 3) * sizeof(WCHAR));// length + '\' + '*' + '/0'
    if (pwszSearch == NULL)
    {
        goto ErrorMemory;
    }
    wcscpy(pwszSearch, pwszDelete);

    if ((pwszSearch[wcslen(pwszSearch) - 1] != L'\\'))
    {
        wcscat(pwszSearch, L"\\");
    }
    wcscat(pwszSearch, L"*");

    //
    // Loop for each item (file or dir) in pwszDelete, and delete/remove it 
    //
    hFindHandle = FindFirstFileU(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        // nothing found, get out
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            SetFileAttributesU(pwszDelete, FILE_ATTRIBUTE_NORMAL);
            RemoveDirectoryW(pwszDelete);
            goto CommonReturn;
        }
        else
        {
            goto ErrorFindFirstFile;
        }
    }    

    while (1)
    {
        if ((wcscmp(FindData.cFileName, L".") != 0) &&
            (wcscmp(FindData.cFileName, L"..") != 0))
        {
            //
            // name of dir or file to delete
            //
            pwszDirOrFileDelete = (LPWSTR) malloc((wcslen(pwszDelete) + 
                                                   wcslen(FindData.cFileName) + 
                                                   2) * sizeof(WCHAR)); 
            if (pwszDirOrFileDelete == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileDelete, pwszDelete);
            if ((pwszDirOrFileDelete[wcslen(pwszDirOrFileDelete) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileDelete, L"\\");
            }
            wcscat(pwszDirOrFileDelete, FindData.cFileName);

            //
            // check to see if this is a dir or a file
            //
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //
                // Recursive delete
                //
                if (!I_RecursiveDeleteDirectory(pwszDirOrFileDelete))
                {
                    goto ErrorReturn;
                }
            }
            else
            {
                SetFileAttributesU(pwszDirOrFileDelete, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFileU(pwszDirOrFileDelete))
                {
                    //goto ErrorReturn;
                }
            }

            free(pwszDirOrFileDelete);
            pwszDirOrFileDelete = NULL;
        }

        if (!FindNextFileU(hFindHandle, &FindData))            
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                goto ErrorFindNextFile;
            }
        }
    }

    SetFileAttributesU(pwszDelete, FILE_ATTRIBUTE_NORMAL);
    RemoveDirectoryW(pwszDelete);
    
CommonReturn:

    dwErr = GetLastError();
    
    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszDirOrFileDelete != NULL)
    {
        free(pwszDirOrFileDelete);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    SetLastError(dwErr);

    return (fResult);

ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_EX(DBG_SS_TRUST, ErrorMemory, ERROR_NOT_ENOUGH_MEMORY)

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


BOOL 
I_RecursiveCopyDirectory(
    IN LPCWSTR pwszDirFrom,
    IN LPCWSTR pwszDirTo
    )
{
    BOOL                fResult = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    LPWSTR              pwszSearch = NULL;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszDirOrFileFrom = NULL;
    LPWSTR              pwszDirOrFileTo = NULL;
    DWORD               dwErr = 0;

    //
    // Create search string
    //
    pwszSearch = (LPWSTR) malloc((wcslen(pwszDirFrom) + 3) * sizeof(WCHAR)); // length + '\' + '*' + '/0'
    if (pwszSearch == NULL)
    {
        goto ErrorMemory;
    }
    wcscpy(pwszSearch, pwszDirFrom);

    if ((pwszSearch[wcslen(pwszSearch) - 1] != L'\\'))
    {
        wcscat(pwszSearch, L"\\");
    }
    wcscat(pwszSearch, L"*");

    //
    // Loop for each item (file or dir) in pwszDirFrom, and
    // copy it to pwszDirTo
    //
    hFindHandle = FindFirstFileU(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        // nothing found, get out
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            goto CommonReturn;
        }
        else
        {
            goto ErrorFindFirstFile;
        }
    }    

    while (1)
    {
        if ((wcscmp(FindData.cFileName, L".") != 0) &&
            (wcscmp(FindData.cFileName, L"..") != 0))
        {
            //
            // name of dir or file to copy from 
            //
            pwszDirOrFileFrom = (LPWSTR) malloc((wcslen(pwszDirFrom) + wcslen(FindData.cFileName) + 2) * sizeof(WCHAR)); 
            if (pwszDirOrFileFrom == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileFrom, pwszDirFrom);
            if ((pwszDirOrFileFrom[wcslen(pwszDirOrFileFrom) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileFrom, L"\\");
            }
            wcscat(pwszDirOrFileFrom, FindData.cFileName);

            //
            // name of dir or file to copy to
            //
            pwszDirOrFileTo = (LPWSTR) malloc((wcslen(pwszDirTo) + wcslen(FindData.cFileName) + 2) * sizeof(WCHAR));
            if (pwszDirOrFileTo == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileTo, pwszDirTo);
            if ((pwszDirOrFileTo[wcslen(pwszDirOrFileTo) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileTo, L"\\");
            }
            wcscat(pwszDirOrFileTo, FindData.cFileName);

            //
            // check to see if this is a dir or a file
            //
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //
                // Create new dir then recursive copy
                //
                if (!I_RecursiveCreateDirectory(pwszDirOrFileTo, NULL))
                {
                    goto ErrorReturn;
                }

                if (!I_RecursiveCopyDirectory(pwszDirOrFileFrom, pwszDirOrFileTo))
                {
                    goto ErrorReturn;
                }
            }
            else
            {
                if (!CopyFileU(pwszDirOrFileFrom, pwszDirOrFileTo, TRUE))
                {
                    goto ErrorCopyFile;
                }
            }

            free(pwszDirOrFileFrom);
            pwszDirOrFileFrom = NULL;
            free(pwszDirOrFileTo);
            pwszDirOrFileTo = NULL;
        }

        if (!FindNextFileU(hFindHandle, &FindData))            
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                goto CommonReturn;
            }
            else
            {
                goto ErrorFindNextFile;
            }
        }
    }
    
CommonReturn:

    dwErr = GetLastError();
    
    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszDirOrFileFrom != NULL)
    {
        free(pwszDirOrFileFrom);
    }

    if (pwszDirOrFileTo != NULL)
    {
        free(pwszDirOrFileTo);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    SetLastError(dwErr);

    return (fResult);

ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ErrorMemory, ERROR_NOT_ENOUGH_MEMORY)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCopyFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\filever.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       filever.cpp
//
//  Contents:   Get file version
//
//  Functions:  I_CryptGetFileVersion
//
//  History:    22-Oct-97   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "crypthlp.h"
#include "unicode.h"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    )
{
    BOOL fResult;
    DWORD dwExceptionCode;
    BYTE rgb1[_MAX_PATH];
    LPSTR pszFilename = NULL;

    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (!MkMBStr(rgb1, _MAX_PATH, pwszFilename, &pszFilename))
        goto OutOfMemory;

    // The following APIs are in DELAYLOAD'ed version.dll. If the DELAYLOAD
    // fails an exception is raised. 
    __try {
        if (0 == (cbInfo = GetFileVersionInfoSizeA(pszFilename, &dwHandle)))
            goto GetFileVersionInfoSizeError;

        if (NULL == (pvInfo = malloc(cbInfo)))
            goto OutOfMemory;

        if (!GetFileVersionInfoA(
                pszFilename,
                0,          // dwHandle, ignored
                cbInfo,
                pvInfo
                ))
            goto GetFileVersionInfoError;

        if (!VerQueryValueA(
                pvInfo,
                "\\",       // VS_FIXEDFILEINFO
                (void **) &pFixedFileInfo,
                &ccFixedFileInfo
                ))
            goto VerQueryValueError;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto GetFileVersionException;
    }

    *pdwFileVersionMS = pFixedFileInfo->dwFileVersionMS;
    *pdwFileVersionLS = pFixedFileInfo->dwFileVersionLS;

    fResult = TRUE;
CommonReturn:
    FreeMBStr(rgb1, pszFilename);
    if (pvInfo)
        free(pvInfo);
    return fResult;

ErrorReturn:
    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetFileVersionInfoSizeError)
TRACE_ERROR(GetFileVersionInfoError)
TRACE_ERROR(VerQueryValueError)
SET_ERROR_VAR(GetFileVersionException, dwExceptionCode)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\list.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       list.cpp
//
//  Contents:   list helper functions.
//
//  History:    27-Nov-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"



//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertHead( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( NULL);
    pn->SetNext( m_pnHead);
    if (m_pnHead)
        m_pnHead->SetPrev( pn);
    else
        m_pnTail = pn;              // list was empty
    m_pnHead = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertTail( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( m_pnTail);
    pn->SetNext( NULL);
    if (m_pnTail)
        m_pnTail->SetNext( pn);
    else
        m_pnHead = pn;              // list was empty
    m_pnTail = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
// Remove node from the list. Do not delete the node.
//--------------------------------------------------------------------------
BOOL CList::Remove( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    CNode *pnPrev = pn->Prev();
    CNode *pnNext = pn->Next();

    if (pnPrev)
        pnPrev->SetNext( pnNext);

    if (pnNext)
        pnNext->SetPrev( pnPrev);

    if (pn == m_pnHead)
        m_pnHead = pnNext;

    if (pn == m_pnTail)
        m_pnTail = pnPrev;

    m_cNode--;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
CNode * CList::Nth( DWORD i)
{
    CNode *pn;

    if (i >= m_cNode)
        return NULL;

    for (pn = m_pnHead;
            (i>0) && pn;
            i--, pn=pn->Next())
        ;

    return pn;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\new.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       new.cpp
//
//  Contents:   new and delete operators.
//
//  History:    16-Jan-97   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
extern void * __cdecl operator new(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,ERROR_NOT_ENOUGH_MEMORY)
}

void __cdecl operator delete(
    IN void *pv)
{
    if (pv)
        free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = malloc(cbBytes)))
#else
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    else
        memset(pv, 0, cbBytes);
#else
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
#endif
    return pv;
}

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
#else
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
#endif
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
#else
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
#if DBG
        free(pv);
#else
        LocalFree((HLOCAL)pv);
#endif
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  According to the <draft-ietf-pkix-ipki-part1-10.txt> :
//      For UTCTime. Where YY is greater than or equal to 50, the year shall
//      be interpreted as 19YY. Where YY is less than
//      50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define MSASN1_SUPPORTS_NOCOPY  1


//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater or equal than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1950
#define YEARLAST                2049
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    if (0 == cbIn)
        return;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)PkiAsn1Alloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1Length;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) Asn1Length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1Value, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  For PkiAsn1SetHugeInteger, PkiAsn1FreeHugeInteger must be called to free
//  the allocated Asn1Value.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppAsn1Value = PkiAsn1AllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pAsn1Length = 0;
            return FALSE;
        }
    } else
        *ppAsn1Value = NULL;
    *pAsn1Length = pInfo->cbData;
    return TRUE;
}

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        )
{
    // Only for BYTE reversal
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    PkiAsn1GetOctetString(Asn1Length, pAsn1Value, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        PkiAsn1ReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by ASN1 before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated Asn1Value.
//  PkiAsn1FreeHugeUINT has been #define'd to PkiAsn1FreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) PkiAsn1Alloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pAsn1Length = cb;
    *ppAsn1Value = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (Asn1Length > 1 && *pAsn1Value == 0) {
        pAsn1Value++;
        Asn1Length--;
    }
    PkiAsn1GetHugeInteger(
        Asn1Length,
        pAsn1Value,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData) {
        *ppAsn1Value = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pAsn1BitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (Asn1BitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1BitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) Asn1BitLength / 8;
        cUnusedBits = Asn1BitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pAsn1Value, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    DWORD cbData;
    DWORD cUnusedBits;

    cbData = pInfo->cbData;
    cUnusedBits = pInfo->cUnusedBits;
    assert(cUnusedBits <= 7);

    if (cbData) {
        BYTE *pb;

        // Until we find a nonzero byte (starting with the last byte),
        // decrement cbData. For the last byte don't look at any unused bits.
        pb = pInfo->pbData + cbData - 1;
        if (0 == (*pb & rgbUnusedAndMask[cUnusedBits])) {
            cUnusedBits = 0;
            cbData--;
            pb--;

            for ( ; 0 < cbData && 0 == *pb; cbData--, pb--)
                ;
        }
    }

    if (cbData) {
        BYTE b;

        // Determine the number of unused bits in the last byte. Treat any
        // trailing zeroes as unused.
        b = *(pInfo->pbData + cbData - 1);
        assert(b);
        if (cUnusedBits)
            b = (BYTE) (b >> cUnusedBits);
        
        for (; 7 > cUnusedBits && 0 == (b & 0x01); cUnusedBits++) {
            b = b >> 1;
        }
        assert(b & 0x01);
        assert(cUnusedBits <= 7);

        *ppAsn1Value = pInfo->pbData;
        *pAsn1BitLength = cbData * 8 - cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pAsn1Length = 0;
        *ppAsn1Value = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pAsn1Length = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) PkiAsn1Alloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppAsn1Value = psz;
    *pAsn1Length = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pAsn1Length = 0;
InvalidIA5:
    *ppAsn1Value = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        )
{
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pAsn1Value,
        Asn1Length,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pAsn1Value, Asn1Length,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->encoded = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pAsn1->length;
            pInfo->pbData = (BYTE *) pAsn1->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pAsn1->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1DecodeError)
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (ASN1uint32_t)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN ASN1int16_t mindiff,
    IN ASN1bool_t utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = (short)( mindiff > 0 ? mindiff : -mindiff );
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pAsn1Time->year   = (ASN1uint8_t) (t.wYear % 100);
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->universal = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = (WORD)( pAsn1Time->year >= MAGICYEAR ?
                    (1900 + pAsn1Time->year) : (2000 + pAsn1Time->year) );
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pAsn1Time->year   = t.wYear;
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->millisecond = t.wMilliseconds;
    pAsn1Time->universal    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year;
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;
    t.wMilliseconds = pAsn1Time->millisecond;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = PKI_ASN1_GENERALIZED_TIME_CHOICE;
        memset(pGeneralTime, 0, sizeof(*pGeneralTime));
        pGeneralTime->year   = t.wYear;
        pGeneralTime->month  = (ASN1uint8_t) t.wMonth;
        pGeneralTime->day    = (ASN1uint8_t) t.wDay;
        pGeneralTime->hour   = (ASN1uint8_t) t.wHour;
        pGeneralTime->minute = (ASN1uint8_t) t.wMinute;
        pGeneralTime->second = (ASN1uint8_t) t.wSecond;
        pGeneralTime->universal    = TRUE;
    } else {
        *pwChoice = PKI_ASN1_UTC_TIME_CHOICE;
        memset(pUtcTime, 0, sizeof(*pUtcTime));
        pUtcTime->year = (ASN1uint8_t) (t.wYear % 100);
        pUtcTime->month  = (ASN1uint8_t) t.wMonth;
        pUtcTime->day    = (ASN1uint8_t) t.wDay;
        pUtcTime->hour   = (ASN1uint8_t) t.wHour;
        pUtcTime->minute = (ASN1uint8_t) t.wMinute;
        pUtcTime->second = (ASN1uint8_t) t.wSecond;
        pUtcTime->universal    = TRUE;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    memset(pGeneralTime, 0, sizeof(*pGeneralTime));
    memset(pUtcTime, 0, sizeof(*pUtcTime));
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    if (PKI_ASN1_UTC_TIME_CHOICE == wChoice) {
        return PkiAsn1FromUTCTime(pUtcTime, pFileTime);
    } else
        return PkiAsn1FromGeneralizedTime(pGeneralTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\utf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//              28-Aug-99   philh   added surrogate support. Copied from
//                                  nt\private\windows\winnls\utf.c or
//                                  \\rastaman\ntwin\src\winnls\utf.c.
//                                  
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "utf8.h"

#if 1

// NEW SURROGATE VERSION

//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
//  03-20-99    SamerA    Surrogate support.
////////////////////////////////////////////////////////////////////////////

int
WINAPI
UTF8ToWideChar(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;     // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

// BEGIN ADDED CHECKS
    if (cchDest < 0)
        goto InvalidParameter;

    if (cchSrc < 0)
        cchSrc = strlen(lpSrcStr) + 1;
// END ADDED CHECKS

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {

// BEGIN FIX
            if (nTB != 0)
                goto InvalidParameter;
// END FIX

            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
// BEGIN FIX
                            else
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }
// END FIX
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
// BEGIN FIX
//                bSurrogatePair = FALSE;

                goto InvalidParameter;
// END FIX
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
// BEGIN FIX
//                nTB = 0;
//                bSurrogatePair = FALSE;
//                cchWC++;

                goto InvalidParameter;
// END FIX
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }
// BEGIN FIX
                else if (nTB >= 5)
                {
                    goto InvalidParameter;
                }
// END FIX

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR) (UTF8 >> nTB);
                }
                nTB--;
            }
        }

        pUTF8++;
    }

// BEGIN FIX
    if (nTB != 0)
        goto InvalidParameter;
// END FIX

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);

// BEGIN FIX
InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
// END FIX
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
//  03-20-99    SamerA    Surrogate support.
////////////////////////////////////////////////////////////////////////////

int
WINAPI
WideCharToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;

// BEGIN ADDED CHECKS
    if (cchDest < 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    if (cchSrc < 0)
        cchSrc = wcslen(lpSrcStr) + 1;
// END ADDED CHECKS

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_2 | (*lpWC >> 6));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}

#else

// OLD IMPLEMENTATION NOT SUPPORTING SURROGATE PAIRS

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    )
{
    int cchRemainUTF8;

    if (cchUTF8 < 0)
        goto InvalidParameter;
    cchRemainUTF8 = cchUTF8;

    if (cchWideChar < 0)
        cchWideChar = wcslen(lpWideCharStr) + 1;

    while (cchWideChar--) {
        WCHAR wch = *lpWideCharStr++;
        if (wch <= 0x7F) {
            // 7 bits
            cchRemainUTF8 -= 1;
            if (cchRemainUTF8 >= 0)
                *lpUTF8Str++ = (char) wch;
        } else if (wch <= 0x7FF) {
            // 11 bits
            cchRemainUTF8 -= 2;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xC0 | ((wch >> 6) & 0x1F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        } else {
            // 16 bits
            cchRemainUTF8 -= 3;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xE0 | ((wch >> 12) & 0x0F));
                *lpUTF8Str++ = (char) (0x80 | ((wch >> 6) & 0x3F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        }
    }

    if (cchRemainUTF8 >= 0)
        cchUTF8 = cchUTF8 - cchRemainUTF8;
    else if (cchUTF8 == 0)
        cchUTF8 = -cchRemainUTF8;
    else {
        cchUTF8 = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchUTF8;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchRemainWideChar;

    if (cchWideChar < 0)
        goto InvalidParameter;
    cchRemainWideChar = cchWideChar;

    if (cchUTF8 < 0)
        cchUTF8 = strlen(lpUTF8Str) + 1;

    while (cchUTF8--) {
        char ch = *lpUTF8Str++;
        WCHAR wch;
        if (0 == (ch & 0x80))
            // 7 bits, 1 byte
            wch = (WCHAR) ch;
        else if (0xC0 == (ch & 0xE0)) {
            // 11 bits, 2 bytes
            char ch2;

            if (--cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x1F) << 6) | ((WCHAR) ch2 & 0x3F);
        } else if (0xE0 == (ch & 0xF0)) {
            // 16 bits, 3 bytes
            char ch2;
            char ch3;
            cchUTF8 -= 2;
            if (cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            ch3 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0) || 0x80 != (ch3 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x0F) << 12) | (((WCHAR) ch2 & 0x3F) << 6) |
                ((WCHAR) ch3 & 0x3F);
        } else
            goto InvalidParameter;

        if (--cchRemainWideChar >= 0)
            *lpWideCharStr++ = wch;
    }

    if (cchRemainWideChar >= 0)
        cchWideChar = cchWideChar - cchRemainWideChar;
    else if (cchWideChar == 0)
        cchWideChar = -cchRemainWideChar;
    else {
        cchWideChar = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchWideChar;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\pkicrit.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkicrit.cpp
//
//  Contents:   PKI CriticalSection Functions
//
//  Functions:  Pki_InitializeCriticalSection
//
//  History:    23-Aug-99    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

BOOL
WINAPI
Pki_InitializeCriticalSection(
    OUT LPCRITICAL_SECTION lpCriticalSection
    )
{
    __try {
        InitializeCriticalSection(lpCriticalSection);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        memset(lpCriticalSection, 0, sizeof(*lpCriticalSection));
        SetLastError(GetExceptionCode());
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\pkistr.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkistr.cpp
//
//  Contents:   PKI String Functions
//
//  Functions:  Pki_wcsicmp
//              Pki_wcsnicmp
//              Pki_stricmp
//              Pki_strnicmp
//
//  History:    21-May-99    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)


//+-------------------------------------------------------------------------
//  CompareString is called with the following locale:
//      MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
//--------------------------------------------------------------------------
int __cdecl Pki_wcsicmp(const wchar_t *pwsz1, const wchar_t *pwsz2)
{
    return CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwsz1,
            -1,
            pwsz2,
            -1) - CSTR_EQUAL;
}

int __cdecl Pki_wcsnicmp(const wchar_t *pwsz1, const wchar_t *pwsz2,
                    size_t cch)
{
    const wchar_t *pwsz;

    size_t cch1;
    size_t cch2;


    for (cch1 = 0, pwsz = pwsz1; cch1 < cch && L'\0' != *pwsz; cch1++, pwsz++)
        ;
    for (cch2 = 0, pwsz = pwsz2; cch2 < cch && L'\0' != *pwsz; cch2++, pwsz++)
        ;

    return CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwsz1,
            (int) cch1,
            pwsz2,
            (int) cch2) - CSTR_EQUAL;
}

int __cdecl Pki_stricmp(const char *psz1, const char *psz2)
{
    return CompareStringA(
            NO_LOCALE,
            NORM_IGNORECASE,
            psz1,
            -1,
            psz2,
            -1) - CSTR_EQUAL;
}

int __cdecl Pki_strnicmp(const char *psz1, const char *psz2,
                    size_t cch)
{
    const char *psz;

    size_t cch1;
    size_t cch2;


    for (cch1 = 0, psz = psz1; cch1 < cch && '\0' != *psz; cch1++, psz++)
        ;
    for (cch2 = 0, psz = psz2; cch2 < cch && '\0' != *psz; cch2++, psz++)
        ;

    return CompareStringA(
            NO_LOCALE,
            NORM_IGNORECASE,
            psz1,
            (int) cch1,
            psz2,
            (int) cch2) - CSTR_EQUAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pvkhlpr\pvk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvk.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    12-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVK_H__
#define __PVK_H__

#include "pvkhlpr.h"
#include "pvkdlgs.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Pvk allocation and free routines
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    );
void PvkFree(
    IN void *pv
    );


//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
enum PASSWORD_TYPE {
    ENTER_PASSWORD = 0,
    CREATE_PASSWORD
};

int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pvkhlpr\pvkdlgs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvkdlgs.h
//
//--------------------------------------------------------------------------

#define IDC_PASSWORD0               501
#define IDC_PASSWORD1               502
#define IDC_KEY                     504
#define IDC_NONE                    505
#define IDD_ENTERKEYPASSWORD        530
#define IDD_CREATEKEYPASSWORD       540
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pkiutil\voidlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       voidlist.cpp
//
//  Contents:   list functions
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "voidlist.h"


void
LIST_Initialize(LIST *pList)
{
    pList->pHead = NULL;
    pList->pTail = NULL;
    pList->dwNumNodes = 0;
}


PLIST_NODE
LIST_AddHead(LIST *pList, void *pElement)
{
    LIST_NODE *pListNode = NULL;

    if (NULL == (pListNode = (PLIST_NODE) malloc(sizeof(LIST_NODE))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // empty list
    if (pList->pHead == NULL)
    {
        pList->pHead = pList->pTail = pListNode;
        pListNode->pNext = NULL;
    }
    else
    {
        pListNode->pNext = pList->pHead;
        pList->pHead = pListNode;
    }

    pList->dwNumNodes++;
    
    pListNode->pElement = pElement;
    
    return(pListNode);
}

PLIST_NODE
LIST_AddTail(LIST *pList, void *pElement)
{
    LIST_NODE *pListNode = NULL;

    if (NULL == (pListNode = (PLIST_NODE) malloc(sizeof(LIST_NODE))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // empty list
    if (pList->pTail == NULL)
    {
        pList->pHead = pList->pTail = pListNode;
    }
    else
    {
        pList->pTail->pNext = pListNode;
        pList->pTail = pListNode;
    }

    pList->dwNumNodes++;
    
    pListNode->pNext = NULL;
    pListNode->pElement = pElement;
    
    return(pListNode);
}


BOOL
LIST_RemoveElement(LIST *pList, void *pElement)
{
    LIST_NODE *pListNodeToDelete = pList->pHead;
    LIST_NODE *pPrevListNode = pList->pHead;

    // empty list
    if (pListNodeToDelete == NULL)
    {
        return FALSE;
    }

    // remove head
    if (pListNodeToDelete->pElement == pElement)
    {
        // one element
        if (pList->pHead == pList->pTail)
        {
            pList->pHead = pList->pTail = NULL;
        }
        else
        {
            pList->pHead = (PLIST_NODE) pListNodeToDelete->pNext;
        }
    }
    else
    {
        pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;

        while ( (pListNodeToDelete != NULL) && 
                (pListNodeToDelete->pElement != pElement))
        {
            pPrevListNode = pListNodeToDelete;
            pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;            
        }

        if (pListNodeToDelete == NULL)
        {
            return FALSE;
        }

        pPrevListNode->pNext = pListNodeToDelete->pNext;

        // removing tail
        if (pList->pTail == pListNodeToDelete)
        {
            pList->pTail = pPrevListNode;
        }
    }

    pList->dwNumNodes--;

    free(pListNodeToDelete);

    return(TRUE);
}


BOOL
LIST_RemoveAll(LIST *pList)
{
    LIST_NODE *pListNodeToDelete = pList->pHead;
    LIST_NODE *pNextListNode = NULL;

    while (pListNodeToDelete != NULL)
    {
        pNextListNode = (PLIST_NODE) pListNodeToDelete->pNext;
        free(pListNodeToDelete);
        pListNodeToDelete = pNextListNode;
    }

    pList->pHead = pList->pTail = NULL;
    pList->dwNumNodes = 0;

    return(TRUE);
}


PLIST_NODE
LIST_GetFirst(LIST *pList)
{
    return(pList->pHead);
}


PLIST_NODE
LIST_GetNext(PLIST_NODE pNode)
{
    return((PLIST_NODE) pNode->pNext);
}


void *
LIST_GetElement(PLIST_NODE pNode)
{
    return(pNode->pElement);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pvkhlpr\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "pvk.h"
#include "unicode.h"

#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbDefPw []    = { 0x43, 0x52, 0x41, 0x50 };
    DWORD cbDefPw       = sizeof(rgbDefPw);

    if (fNoPassDlg) {
        pbPassword = rgbDefPw;
        cbPassword = cbDefPw;
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword)
        PvkFree(pbAllocPassword);
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey))
            goto ErrorReturn;

        fResult = TRUE;
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL SaveKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKey(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKey(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKey(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKey(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


static BOOL AcquireKeyContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;
    DWORD dwKeySpec;
    RPC_STATUS RpcStatus;

    // Create a temporary keyset to load the private key into
    RpcStatus = UuidCreate(&TmpContainerUuid);
    if (!(RPC_S_OK == RpcStatus || RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
        // Use stack randomness
        ;
    }

    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKey(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            PrvKeyLen,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            if ((fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ))) {
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pvkhlpr\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"


// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from
static HINSTANCE hPvkInst;

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

extern
BOOL
WINAPI
UnicodeDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hPvkInst = hInstDLL;
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return UnicodeDllMain( hInstDLL, fdwReason, lpvReserved);
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        hPvkInst,
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    LPSTR rgpszPassword[2] = {NULL, NULL};

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    char szMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowText(hwndDlg, szMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {
        // Didn't enter a password
        nResult = MessageBox(
            hwndDlg,
            "Without password protection ?",
            szMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {
        // Confirmed password didn't match
        nResult = MessageBox(
            hwndDlg,
            "Confirm password doesn't match",
            szMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (ULONG_PTR)pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\pvkhlpr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pvkdlg.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\capi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       capi.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>

#include "crtem.h"
#include "redir.h"
#include "unicode.h"

#ifndef _M_IX86
BOOL
WINAPI
UnicodeDllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved
    )
{
    return TRUE;
}


#else

#ifdef LINK_REDIR
#define pfnAcquireContextW      CryptAcquireContextW
#define pfnSignHashW            CryptSignHashW
#define pfnVerifySignatureW     CryptVerifySignatureW
#define pfnSetProviderW         CryptSetProviderW
#define pfnEnumProvidersW       CryptEnumProvidersW
#else
static HINSTANCE                hCrypt                  = NULL;
static LPSTR                    pszCryptName            = "advapi32.dll";
static CRYPTACQUIRECONTEXTW     *pfnAcquireContextW     = NULL;
static CRYPTSIGNHASHW           *pfnSignHashW           = NULL;
static CRYPTVERIFYSIGNATUREW    *pfnVerifySignatureW    = NULL;
static CRYPTSETPROVIDERW        *pfnSetProviderW        = NULL;

typedef WINADVAPI BOOL WINAPI CRYPTENUMPROVIDERSW(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR szTypeName,
    DWORD *pcbTypeName
    );

static CRYPTENUMPROVIDERSW      *pfnEnumProvidersW      = NULL;
#endif

BOOL
WINAPI
UnicodeDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
#ifndef LINK_REDIR
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hCrypt = LoadLibraryA(pszCryptName);

        pfnAcquireContextW = (CRYPTACQUIRECONTEXTW*)GetProcAddress(
                                    hCrypt,
                                    "CryptAcquireContextW");
        pfnSignHashW = (CRYPTSIGNHASHW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSignHashW");
        pfnVerifySignatureW = (CRYPTVERIFYSIGNATUREW*)GetProcAddress(
                                    hCrypt,
                                    "CryptVerifySignatureW");
        pfnSetProviderW = (CRYPTSETPROVIDERW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSetProviderW");
        pfnEnumProvidersW = (CRYPTENUMPROVIDERSW*)GetProcAddress(
                                    hCrypt,
                                    "CryptEnumProvidersW");
        break;

    case DLL_PROCESS_DETACH:
        FreeLibrary( hCrypt);
        pfnAcquireContextW  = NULL;
        pfnSignHashW        = NULL;
        pfnVerifySignatureW = NULL;
        pfnSetProviderW     = NULL;
        pfnEnumProvidersW   = NULL;
        break;

    default:
        break;
    }
#endif

    return TRUE;
}


BOOL WINAPI CryptAcquireContext9x(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    )
        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    // Bug in CyptAcquireContextW for NT4
    if(FIsWinNT5() && pfnAcquireContextW)
        return( pfnAcquireContextW (
            phProv,
            lpContainer,
            lpProvider,
            dwProvType,
            dwFlags
            ));
    else
        return( CryptAcquireContext9x (
            phProv,
            lpContainer,
            lpProvider,
            dwProvType,
            dwFlags
            ));
}


BOOL WINAPI CryptSignHash9x(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptSignHashA (
                hHash,
                dwKeySpec,
                szDescription,
                dwFlags,
                pbSignature,
                pdwSigLen
            );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen) {

    if(FIsWinNT())
        return(pfnSignHashW (
            hHash,
            dwKeySpec,
            lpDescription,
            dwFlags,
            pbSignature,
            pdwSigLen
            ));
    else
        return(CryptSignHash9x (
            hHash,
            dwKeySpec,
            lpDescription,
            dwFlags,
            pbSignature,
            pdwSigLen
            ));
}


BOOL WINAPI CryptVerifySignature9x(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptVerifySignatureA (
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                szDescription,
                dwFlags
             );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    if(FIsWinNT())
        return(pfnVerifySignatureW (
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            lpDescription,
            dwFlags
            ));
    else
        return(CryptVerifySignature9x (
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            lpDescription,
            dwFlags
            ));
}


BOOL WINAPI CryptSetProvider9x(
    LPCWSTR lpProvName,
    DWORD dwProvType) {

    BYTE rgb[_MAX_PATH];
    char *  szProvName;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpProvName, &szProvName))
        err = CryptSetProviderA (
                szProvName,
                dwProvType
            );

    FreeMBStr(rgb, szProvName);

    return(err);
}

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType) {

    if(FIsWinNT())
        return(pfnSetProviderW (
            lpProvName,
            dwProvType
            ));
    else
        return(CryptSetProvider9x (
            lpProvName,
            dwProvType
            ));
}




/*
 -      CryptEnumProvidersU
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pwszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */

#define PROVREG L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"
#define PROVTYPEREG L"Type"

BOOL
WINAPI CryptEnumProviders9x(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pwszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPWSTR      pwszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    if (NULL != pdwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (0 != dwFlags)
    {
        SetLastError((DWORD)NTE_BAD_FLAGS);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                             PROVREG,
                                             0L, KEY_READ, &hRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                NULL,
                                                &cbClass,
                                                NULL,
                                                &cSubKeys,
                                                &cbMaxKeyName,
                                                &cbMaxClass,
                                                &cValues,
                                                &cbMaxValName,
                                                &cbMaxValData,
                                                NULL,
                                                &ft)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }
    cbMaxKeyName += sizeof(CHAR);

    if (NULL == (pwszTmpProvName = (LPWSTR) _alloca(cbMaxKeyName * sizeof(WCHAR))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegEnumKeyExU(hRegKey, dwIndex, pwszTmpProvName,
                                             &cbMaxKeyName, NULL,
                                             NULL, &cbClass, &ft)))
    {
        SetLastError((DWORD)err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(hRegKey,
                                             pwszTmpProvName,
                                             0L, KEY_READ, &hProvRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    cbProvType = sizeof(dw);
    if (ERROR_SUCCESS != (err = RegQueryValueExU(hProvRegKey,
                                                PROVTYPEREG,
                                                NULL, &dwKeyType, (BYTE*)&dw,
                                                &cbProvType)))
    {
	    SetLastError((DWORD) NTE_PROV_TYPE_ENTRY_BAD);
        goto Ret;
    }
    *pdwProvType = dw;

    cbTmpProvName = (wcslen(pwszTmpProvName) + 1) * sizeof(WCHAR);

    if (NULL != pwszProvName)
    {
        if (*pcbProvName < cbTmpProvName)
        {
            *pcbProvName = cbTmpProvName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }
        wcscpy(pwszProvName, pwszTmpProvName);
    }

    *pcbProvName = cbTmpProvName;

    fRet = CRYPT_SUCCEED;

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
}

BOOL
WINAPI CryptEnumProvidersU(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pwszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    if(FIsWinNT5() && pfnEnumProvidersW)
        return(pfnEnumProvidersW (
            dwIndex,
            pdwReserved,
            dwFlags,
            pdwProvType,
            pwszProvName,
            pcbProvName
            ));
    else
        return(CryptEnumProviders9x (
            dwIndex,
            pdwReserved,
            dwFlags,
            pdwProvType,
            pwszProvName,
            pcbProvName
            ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\trans\cliiis\httptran.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httptran.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "GTTran.h"
#include "IHGTTran.h"
#include "httptran.hxx"

DWORD __stdcall SendExp(HUTTRAN hTran, DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {
    return( ((CHttpTran *) hTran)->Send(dwEncodeType, cbSendBuff, pbSendBuff));
}

DWORD __stdcall ReceiveExp(HUTTRAN hTran, DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {
    return( ((CHttpTran *) hTran)->Receive(pdwEncodeType, pcbReceiveBuff, ppbReceiveBuff));
}

DWORD __stdcall CloseExp(HUTTRAN hTran) {
    return(((CHttpTran *) hTran)->Close());
}

DWORD __stdcall FreeExp(HUTTRAN hTran, BYTE * pb) {
    return(((CHttpTran *) hTran)->Free(pb));
}

DWORD __stdcall OpenExp(HUTTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen) {

    DWORD   err;

    assert(phTran != NULL);

    if( (*phTran = (HUTTRAN) new CHttpTran(tszBinding)) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    err = ((CHttpTran *) *phTran)->Open(tszBinding, fOpen);

    if(err != ERROR_SUCCESS)
        delete (CHttpTran *) (*phTran);

    return(err);
}

DWORD CHttpTran::Open(const TCHAR * tszURL, DWORD fOpenT) {

    TCHAR   tszDomanName[_MAX_PATH];
    TCHAR   tszPort[12];
    TCHAR * ptch;
    TCHAR * ptchT;
    DWORD   err;

    // did we get a flag?
    if(  (fOpenT & (GTREAD | GTWRITE)) == 0 )
        return(ERROR_INVALID_PARAMETER);

    // is it a readonly flag, then do gets
    fOpen = fOpenT;

    assert(tszURL != NULL);

    // we must have http://
    assert(_tcslen(tszURL) > 7);
    assert(_tcsnicmp(tszURL, TEXT("http://"), 7) == 0);

    // copy the Doman Name
    ptch = (TCHAR *) &tszURL[7];
    ptchT = tszDomanName;
    while(*ptch != _T('/')  && *ptch != _T(':') &&  *ptch != 0)
        *ptchT++ = *ptch++;
    *ptchT = 0;

    // parse out the port number
    tszPort[0] = 0;
    if(*ptch == _T(':')) {
        ptchT = tszPort;
        while(*ptch != _T('/') && *ptch != 0)
            *ptchT++ = *ptch++;
        *ptchT = 0;
    }

    // Note, we don't support port numbers
    assert(tszPort[0] == 0);

    // save away what to look up.
    tszPartURL = new TCHAR[(_tcslen(ptch) + 1)];
    if (NULL == tszPartURL) {
        delete this;
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    _tcscpy(tszPartURL, ptch);

    //                        INTERNET_OPEN_TYPE_DIRECT,
    if( (hIOpen = InternetOpen( TEXT("Transport"),
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

        (hIConnect = InternetConnect(hIOpen,
                                    tszDomanName,
                                    INTERNET_INVALID_PORT_NUMBER,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0)) == NULL     ) {
        err = GetLastError();
        delete this;
        return(err);
    }

    // If this is a GET, do a dummy send
    if( fOpen == GTREAD  &&
        ((hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("GET"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
        HttpSendRequest(hIHttp, TEXT("Accept: */*\r\n"), (DWORD) -1, NULL, 0) == FALSE) ) {
        err = GetLastError();
        delete this;
        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Send(DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {

    TCHAR       tszBuff[1024];
    DWORD       err;
    TCHAR *     tszContentType;


    if( pbRecBuf != NULL || (fOpen & GTWRITE) != GTWRITE)
        return(ERROR_INVALID_PARAMETER);

    switch( dwEncodeType ) {
        case ASN_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-asn");
            break;
        case TLV_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-tlv");
            break;
        case IDL_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-idl");
            break;
        case OCTET_ENCODING:
            tszContentType = TEXT("application/octet-stream");
            break;
        default:
            tszContentType = TEXT("text/*");
            break;
    }

    // say how long the buffer is
    _stprintf(tszBuff, TEXT("Content-Type: %s\r\nContent-Length: %d\r\nAccept: %s\r\n"), tszContentType, cbSendBuff,tszContentType);

    if( (hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("POST"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL ) {
        return(GetLastError());
    }

    // send of the request, this will wait for a response
    if( HttpSendRequest(hIHttp, tszBuff, (DWORD) -1, (LPVOID) pbSendBuff, cbSendBuff) == FALSE ) {

        err = GetLastError();
        // close out the handle
        assert(hIHttp != NULL);
        InternetCloseHandle(hIHttp);
        hIHttp = NULL;

        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Receive(DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

    TCHAR       tszBuff[1024];
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD       err;


    assert(pcbReceiveBuff != NULL && ppbReceiveBuff != NULL);
    *ppbReceiveBuff = NULL;
    *pcbReceiveBuff = 0;

    if( pbRecBuf != NULL  || (fOpen & GTREAD) != GTREAD || hIHttp == NULL)
        return(ERROR_INVALID_PARAMETER);

    // get the content type
    if( pdwEncodeType != NULL) {

        cbBuff = sizeof(tszBuff);
        if(HttpQueryInfo(   hIHttp,
                            HTTP_QUERY_CONTENT_TYPE,
                            tszBuff,
                            &cbBuff,
                            NULL) == FALSE)
            return(GetLastError());

        assert(cbBuff > 0);

        if(!_tcscmp(TEXT("application/x-octet-stream-asn"), tszBuff))
            *pdwEncodeType = ASN_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), tszBuff))
            *pdwEncodeType = IDL_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), tszBuff))
            *pdwEncodeType = TLV_ENCODING;
        else if(!_tcscmp(TEXT("application/octet-stream"), tszBuff))
            *pdwEncodeType = OCTET_ENCODING;
        else
            *pdwEncodeType = ASCII_ENCODING;

    }

    // now get the length of the buffer returned
    cbBuff = sizeof(tszBuff);
    if(HttpQueryInfo(   hIHttp,
                        HTTP_QUERY_CONTENT_LENGTH,
                        tszBuff,
                        &cbBuff,
                        NULL) == FALSE)
        return(GetLastError());

    assert(cbBuff > 0);
    cbBuff = _ttol(tszBuff);

    // allocate a buffer
    if( (pbRecBuf = new BYTE[cbBuff]) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    // read the data
    cbBuffRead = 0;
    while(cbBuffRead < cbBuff) {
        cbBuffT = 0;
        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) {
            err = GetLastError();
            delete [] pbRecBuf;
            pbRecBuf = NULL;
            return(err);
        }
        cbBuffRead += cbBuffT;
    }

    // close out the handle
    InternetCloseHandle(hIHttp);
    hIHttp = NULL;

    // pass back the info
    *ppbReceiveBuff = pbRecBuf;
    *pcbReceiveBuff = cbBuff;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Free(BYTE * pb) {
    assert(pb == pbRecBuf);
    delete [] pbRecBuf;
    pbRecBuf = NULL;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Close(void) {
    delete this;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\trans\srviis\bgihttp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bgihttp.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include "httpext.h"
#include "gttran.h"

typedef struct _GPT {
    HINSTANCE       hLib;
    PFNGTRecSend    PfnRecSend;
    PFNGTFree       PfnFree;
} GPT;

static GPT  gpt;

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO  *pVer )
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );
    lstrcpyn( pVer->lpszExtensionDesc,
              "This is a sample Web Server Application",
               HSE_MAX_EXT_DLL_NAME_LEN );
    return TRUE;
}

DWORD WINAPI   HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB) {

    DWORD   cb = 0;
    BYTE *  pb = NULL;
    TCHAR   tszBuff[1024];
    DWORD   cbBuff;
    DWORD   dwEncodingType;
    TCHAR * tszContentType;

    // assume an error
    pECB->dwHttpStatusCode = 500;

    if(!_tcscmp(TEXT("application/x-octet-stream-asn"), pECB->lpszContentType))
        dwEncodingType = ASN_ENCODING;
    else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), pECB->lpszContentType))
        dwEncodingType = IDL_ENCODING;
    else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), pECB->lpszContentType))
        dwEncodingType = TLV_ENCODING;
    else if(!_tcscmp(TEXT("application/octet-stream"), pECB->lpszContentType))
        dwEncodingType = OCTET_ENCODING;
    else
        dwEncodingType = ASCII_ENCODING;

    if(dwEncodingType == ASCII_ENCODING)
        tszContentType = TEXT("text/html");
    else
        tszContentType = pECB->lpszContentType;
    
    // only do it if we can.
    if(gpt.PfnRecSend == NULL || gpt.PfnFree == NULL)
        return(HSE_STATUS_ERROR);

    // call the user dlls with the data
    if( gpt.PfnRecSend(dwEncodingType, pECB->cbTotalBytes, pECB->lpbData, &cb, &pb) != ERROR_SUCCESS)
        return(HSE_STATUS_ERROR);

    // we are ok now
    pECB->dwHttpStatusCode = 200;

    // write any return data
    if( cb > 0 ) {
        assert( pb != NULL);

        // write headers
        // we assume the only type of content type we support
        _stprintf(tszBuff, TEXT("Content-Length: %d\r\nContent-Type: %s\r\n\r\n"), cb, tszContentType);
        cbBuff = _tcslen(tszBuff);
        pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, &cbBuff, (LPDWORD) tszBuff);

        // write users data
        pECB->WriteClient(pECB->ConnID, pb, &cb, 0);

        // free the users data
        gpt.PfnFree(pb);
    }

    // just write out the headers if no data returned
    else {

        // write headers
        pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, NULL, NULL);
    }

    return(HSE_STATUS_SUCCESS);
}

// SHOULD ONLY BE CALLED DURING PROCESS ATTACH
DWORD __stdcall GTInitSrv(TCHAR * tszLibrary) {

    // this is only called on process attach
    // there is only one process attach
    assert(gpt.hLib == NULL);

    memset(&gpt, 0, sizeof(gpt));
    if( (gpt.hLib = LoadLibrary(tszLibrary)) == NULL )
        return(ERROR_DLL_NOT_FOUND);

    gpt.PfnRecSend = (PFNGTRecSend) GetProcAddress(gpt.hLib, TEXT("GTRecSend"));
    gpt.PfnFree    = (PFNGTFree) GetProcAddress(gpt.hLib, TEXT("GTFree"));

    if( gpt.PfnRecSend == NULL || gpt.PfnFree == NULL )  {
        FreeLibrary(gpt.hLib);
        memset(&gpt, 0, sizeof(GPT));
        return(ERROR_PROC_NOT_FOUND);
    }

    return(ERROR_SUCCESS);
}

// SHOULD ONLY BE CALLED DURING PROCESS DETACH
DWORD __stdcall GTUnInitSrv(void) {

    if(gpt.hLib != NULL)
        FreeLibrary(gpt.hLib);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\trans\gen\hgttran.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hgttran.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <memory.h>
#include <assert.h>
#include <malloc.h>
#include "gttran.h"
#include "ihgttran.h"

DWORD __stdcall GTOpen(HGT * phTran, const TCHAR * szLibrary, const TCHAR * tszBinding, DWORD fOpen) {

	IGTS *	pIGTS;
	DWORD	err = ERROR_SUCCESS;

	assert(phTran != NULL);
	assert(szLibrary != NULL);

	// initialize the return handle
	*phTran = 0;

	// make a data structure for the handle
	if( (pIGTS = (IGTS *) malloc(sizeof(IGTS))) == NULL)
		return(ERROR_NOT_ENOUGH_MEMORY);
	memset(pIGTS, 0, sizeof(IGTS));

	// load the dynamic library
	if( (pIGTS->hLib = LoadLibrary(szLibrary)) == NULL ) {
		free(pIGTS);
		return(ERROR_DLL_NOT_FOUND);
	}

	// now get all of the proc addres
	if( (pIGTS->PfnOpen = (PFNOpen) GetProcAddress(pIGTS->hLib, "Open")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnSend = (PFNSend) GetProcAddress(pIGTS->hLib, "Send")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnFree = (PFNFree) GetProcAddress(pIGTS->hLib, "Free")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnReceive = (PFNReceive) GetProcAddress(pIGTS->hLib, "Receive")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnClose = (PFNClose) GetProcAddress(pIGTS->hLib, "Close")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if(err != ERROR_SUCCESS) {
		FreeLibrary(pIGTS->hLib );
		free(pIGTS);
		return(err);
	}

	// ok, open the file
	err = pIGTS->PfnOpen(&pIGTS->hTran, tszBinding, fOpen);

	if(err != ERROR_SUCCESS) {
		FreeLibrary(pIGTS->hLib );
		free(pIGTS);
		return(err);
	}

	// return the handle
	*phTran = (HGT) pIGTS;

	return(err);
}

DWORD __stdcall GTSend(HGT hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;


	return(pIGTS->PfnSend(pIGTS->hTran, dwEncoding, cbSendBuff, pbSendBuff));
}

DWORD __stdcall GTFree(HGT hTran, BYTE * pb) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	return(pIGTS->PfnFree(pIGTS->hTran, pb));
}

DWORD __stdcall GTReceive(HGT hTran,  DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	return(pIGTS->PfnReceive(pIGTS->hTran, pdwEncoding, pcbReceiveBuff, ppbReceiveBuff));
}

DWORD __stdcall GTClose(HGT hTran) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	// close and free all ofthe junk
	pIGTS->PfnClose(pIGTS->hTran);
	FreeLibrary(pIGTS->hLib );
	free(pIGTS);

	return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\trans\cliiis\httptran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httptran.h
//
//--------------------------------------------------------------------------


#define TRANREAD	1
#define TRANWRITE	2

typedef DWORD	HTRAN;

extern "C" STTERR HttpOpen(HTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen);
extern "C" STTERR HttpSend(HTRAN hTran, DWORD cbSendBuff, const BYTE * pbSendBuff);
extern "C" STTERR HttpFree(HTRAN hTran, BYTE * pb);
extern "C" STTERR HttpReceive(HTRAN hTran, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
extern "C" STTERR HttpClose(HTRAN hTran);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\commctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       commctrl.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h"


HTREEITEM WINAPI TreeView_InsertItem9x(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    )
{
    TVINSERTSTRUCTA   tvItem;
    HTREEITEM           hTreeItem;
    int                 cb;

    memcpy(&tvItem, lpis, sizeof(LPTVINSERTSTRUCTA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            lpis->item.pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (tvItem.item.pszText = (LPSTR) malloc(cb))) 
    {
        return NULL;  // this is the unsuccessful return code for this call 
    }

    WideCharToMultiByte(
            0, 
            0, 
            lpis->item.pszText, 
            -1, 
            tvItem.item.pszText,
            cb,
            NULL,
            NULL);

    hTreeItem = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEMA, 0, (LPARAM) &tvItem);

    free(tvItem.item.pszText);
    return hTreeItem;
}

HTREEITEM WINAPI TreeView_InsertItemU(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    )
{
    if (FIsWinNT())
    {
        return((HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEMW, 0, (LPARAM) lpis));
    }
    else
    {
        return (TreeView_InsertItem9x(hwndTV, lpis));
    }
}


int WINAPI ListView_InsertItem9x(
    HWND hwnd, 		
    const LPLVITEMW pitem		
    )
{
    LVITEMA lvItem;
    int     iRet;
    int     cb;

    memcpy(&lvItem, pitem, sizeof(LVITEMA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            pitem->pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (lvItem.pszText = (LPSTR) malloc(cb))) 
    {
        return -1;  // this is the unsuccessful return code for this call 
    }

    WideCharToMultiByte(
            0, 
            0, 
            pitem->pszText, 
            -1, 
            lvItem.pszText,
            cb,
            NULL,
            NULL);

    iRet = (int)SendMessage(hwnd, LVM_INSERTITEMA, 0, (LPARAM) &lvItem);

    free(lvItem.pszText);
    return iRet;
}

int WINAPI ListView_InsertItemU(
    HWND hwnd, 		
    const LPLVITEMW pitem		
    )
{
    if (FIsWinNT())
    {
        return ((int)SendMessage(hwnd, LVM_INSERTITEMW, 0, (LPARAM) pitem));
    }
    else
    {
        return (ListView_InsertItem9x(hwnd, pitem));
    }
}


void WINAPI ListView_SetItemTextU(
    HWND hwnd, 		
    int i, 		
    int iSubItem, 		
    LPCWSTR pszText		
    )
{
    LVITEMA lvItemA;
    LVITEMW lvItemW;
    int     cb;

    if ((ULONG_PTR) pszText == (ULONG_PTR) LPSTR_TEXTCALLBACK)
    {
        memset(&lvItemA, 0, sizeof(lvItemA));
        lvItemA.iSubItem = iSubItem;
        lvItemA.pszText = (LPSTR) LPSTR_TEXTCALLBACK;
        SendMessage(hwnd, LVM_SETITEMTEXTA, i, (LPARAM) &lvItemA);
        return;
    }

    if (FIsWinNT())
    {
        memset(&lvItemW, 0, sizeof(lvItemW));
        lvItemW.iSubItem = iSubItem;
        lvItemW.pszText = (LPWSTR) pszText;
        SendMessage(hwnd, LVM_SETITEMTEXTW, i, (LPARAM) &lvItemW);
        return;
    }

    memset(&lvItemA, 0, sizeof(lvItemA));
    lvItemA.iSubItem = iSubItem;
    
    cb = WideCharToMultiByte(
            0, 
            0, 
            pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (lvItemA.pszText = (LPSTR) malloc(cb)))
    {
        return;
    }

    WideCharToMultiByte(
            0, 
            0, 
            pszText, 
            -1, 
            lvItemA.pszText,
            cb,
            NULL,
            NULL);
    
    SendMessage(hwnd, LVM_SETITEMTEXTA, i, (LPARAM) &lvItemA);
    free(lvItemA.pszText);
}


int WINAPI ListView_InsertColumn9x(
    HWND hwnd, 
    int i, 
    const LPLVCOLUMNW plvC)
{
    LVCOLUMNA   lvCA;
    int         iRet;
    int         cb;

    memcpy(&lvCA, plvC, sizeof(LVCOLUMNA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            plvC->pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);

    if (NULL == (lvCA.pszText = (LPSTR) malloc(cb)))
    {
        return -1; // failure code for this call
    }

    WideCharToMultiByte(
            0, 
            0, 
            plvC->pszText, 
            -1, 
            lvCA.pszText, 
            cb, 
            NULL, 
            NULL);
    
    iRet = (int)SendMessage(hwnd, LVM_INSERTCOLUMNA, i, (LPARAM) &lvCA);
    
    free(lvCA.pszText);
    return iRet;
}

int WINAPI ListView_InsertColumnU(
    HWND hwnd, 
    int i, 
    const LPLVCOLUMNW plvC)
{
    if (FIsWinNT())
    {   
        return ((int)SendMessage(hwnd, LVM_INSERTCOLUMNW, i, (LPARAM) plvC));
    }
    else
    {
        return (ListView_InsertColumn9x(hwnd, i, plvC));
    }
}


BOOL WINAPI ListView_GetItem9x(
    HWND hwnd, 		
    LPLVITEMW pitem		
    )
{
    LVITEMA lvItemA;
    BOOL    fRet;

    memcpy(&lvItemA, pitem, sizeof(lvItemA));
    if (NULL == (lvItemA.pszText = (LPSTR) malloc(lvItemA.cchTextMax)))
    {
        return FALSE;
    }
    
    fRet = (BOOL)SendMessage(hwnd, LVM_GETITEMA, 0, (LPARAM) &lvItemA);

    if (fRet)
    {
        pitem->state = lvItemA.state; 
        pitem->iImage = lvItemA.iImage; 
        pitem->lParam = lvItemA.lParam;
        pitem->iIndent = lvItemA.iIndent;

        if (pitem->mask & LVIF_TEXT)
        {
            MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    lvItemA.pszText, 
                    -1, 
                    pitem->pszText,
                    pitem->cchTextMax);
        }
    }

    free(lvItemA.pszText);
    return fRet;
}

BOOL WINAPI ListView_GetItemU(
    HWND hwnd, 		
    LPLVITEMW pitem		
    )
{
    if (FIsWinNT())
    {
        return ((BOOL)SendMessage(hwnd, LVM_GETITEMW, 0, (LPARAM) pitem));
    }
    else
    {
        return (ListView_GetItem9x(hwnd, pitem));
    }
}


#ifdef _M_IX86

HFONT
WINAPI
CreateFontIndirect9x(CONST LOGFONTW *lplf)
{
    LOGFONTA    lfa;
    
    memcpy(&lfa, lplf, sizeof(LOGFONTA));

    WideCharToMultiByte(
            0,
            0,
            lplf->lfFaceName,
            -1,
            lfa.lfFaceName,
            LF_FACESIZE,
            NULL,
            NULL);

    return (CreateFontIndirectA(&lfa));
}

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf)
{
    if (FIsWinNT())
    {
        return (CreateFontIndirectW(lplf));
    }
    else
    {
        return (CreateFontIndirect9x(lplf));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\file.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       file.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "crtem.h"
#include "unicode.h"


#ifdef _M_IX86
HANDLE WINAPI CreateFile9x (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    HANDLE  hFile;

    hFile = INVALID_HANDLE_VALUE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        hFile = CreateFileA (
            szFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            );

    FreeMBStr(rgb, szFileName);

    return(hFile);
}

HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    if(FIsWinNT())
        return( CreateFileW (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));
    else
        return( CreateFile9x (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));
}


BOOL
WINAPI
DeleteFile9x(
    LPCWSTR lpFileName
    )
{
    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        fResult = DeleteFileA (
            szFileName
            );
    FreeMBStr(rgb, szFileName);
    return(fResult);
}

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    )
{
    if(FIsWinNT())
        return( DeleteFileW (lpFileName) );
    else
        return( DeleteFile9x (lpFileName) );
}


BOOL
WINAPI
CopyFile9x(LPCWSTR lpwExistingFileName, LPCWSTR lpwNewFileName, BOOL bFailIfExists)
{
    BYTE rgbexist[_MAX_PATH];
    BYTE rgbnew[_MAX_PATH];
    char *  szFileNameExist;
    char *  szFileNameNew;
    BOOL fResult;

    fResult = FALSE;

    if (!(MkMBStr(rgbexist, _MAX_PATH, lpwExistingFileName, &szFileNameExist)))
    {
        return(FALSE);
    }

    if (!(MkMBStr(rgbnew, _MAX_PATH, lpwNewFileName, &szFileNameNew)))
    {
        FreeMBStr(rgbexist, szFileNameExist);
        return(FALSE);
    }

    fResult = CopyFileA(szFileNameExist, szFileNameNew, bFailIfExists);

    FreeMBStr(rgbexist, szFileNameExist);
    FreeMBStr(rgbnew, szFileNameNew);

    return(fResult);
}

BOOL
WINAPI
CopyFileU(LPCWSTR lpwExistingFileName, LPCWSTR lpwNewFileName, BOOL bFailIfExists)
{
    if (FIsWinNT())
        return( CopyFileW(lpwExistingFileName, lpwNewFileName, bFailIfExists) );
    else
        return( CopyFile9x(lpwExistingFileName, lpwNewFileName, bFailIfExists) );
}


BOOL
WINAPI
MoveFileEx9x(
	LPCWSTR lpExistingFileName, // address of name of the existing file
	LPCWSTR lpNewFileName,		// address of new name for the file
	DWORD dwFlags)				// flag to determine how to move file
{
	BYTE rgbExisting[_MAX_PATH];
	BYTE rgbNew[_MAX_PATH];
	char * szExisting = NULL;
	char * szNew = NULL;
	BOOL bResult = FALSE;

	if ((MkMBStr(rgbExisting, _MAX_PATH, lpExistingFileName, &szExisting)) &&
		(MkMBStr(rgbNew, _MAX_PATH, lpNewFileName, &szNew)))
	{
		bResult = MoveFileExA(szExisting, szNew, dwFlags);
	}

	FreeMBStr(rgbExisting, szExisting);
	FreeMBStr(rgbNew, szNew);

	return (bResult);
}

BOOL
WINAPI
MoveFileExU(
	LPCWSTR lpExistingFileName, // address of name of the existing file
	LPCWSTR lpNewFileName,		// address of new name for the file
	DWORD dwFlags)				// flag to determine how to move file
{
	if (FIsWinNT())
		return(MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
    else
        return(MoveFileEx9x(lpExistingFileName, lpNewFileName, dwFlags));
}


DWORD
WINAPI
GetFileAttributes9x(
    LPCWSTR lpFileName
    )
{
    if (lpFileName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0xFFFFFFFF);
    }

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    DWORD dwAttr;

    dwAttr = 0xFFFFFFFF;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        dwAttr = GetFileAttributesA (
            szFileName
            );
    FreeMBStr(rgb, szFileName);
    return(dwAttr);
}

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    )
{
    if(FIsWinNT())
        return( GetFileAttributesW (lpFileName) );
    else
        return( GetFileAttributes9x (lpFileName) );
}


BOOL
WINAPI
SetFileAttributes9x(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    if (lpFileName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        fResult = SetFileAttributesA (
            szFileName,
            dwFileAttributes
            );
    FreeMBStr(rgb, szFileName);
    return(fResult);
}

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    if(FIsWinNT())
        return( SetFileAttributesW (lpFileName, dwFileAttributes) );
    else
        return( SetFileAttributes9x (lpFileName, dwFileAttributes) );
}


DWORD
WINAPI
GetCurrentDirectory9x(
	DWORD nBufferLength, // size, in characters, of directory buffer
	LPWSTR lpBuffer)	 // address of buffer for current directory
{
	BYTE rgb[_MAX_PATH];
	char * szDir = NULL;
	DWORD dwResult = 0;

	if (nBufferLength == 0)
    {
        return(GetCurrentDirectoryA(0, NULL));
    }
    else
    {
	    szDir = (char *) malloc(nBufferLength);
        if (szDir == NULL)
        {
            SetLastError(E_OUTOFMEMORY);
            return 0;
        }
        dwResult = GetCurrentDirectoryA(nBufferLength, szDir);

        if (dwResult == 0)
        {
            return 0;
        }

        MultiByteToWideChar(
            0,
            0,
            szDir,
            -1,
            lpBuffer,
            nBufferLength);
    }

    free(szDir);
	return (dwResult);
}

DWORD
WINAPI
GetCurrentDirectoryU(
	DWORD nBufferLength, // size, in characters, of directory buffer
	LPWSTR lpBuffer)	 // address of buffer for current directory
{
	if (FIsWinNT())
		return(GetCurrentDirectoryW(nBufferLength, lpBuffer));
    else
        return(GetCurrentDirectory9x(nBufferLength, lpBuffer));
}


BOOL
WINAPI
CreateDirectory9x(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    if (lpPathName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szPathName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpPathName, &szPathName))
        fResult = CreateDirectoryA (
            szPathName,
            lpSecurityAttributes
            );
    FreeMBStr(rgb, szPathName);
    return(fResult);
}

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    if(FIsWinNT())
        return( CreateDirectoryW (lpPathName, lpSecurityAttributes) );
    else
        return( CreateDirectory9x (lpPathName, lpSecurityAttributes) );
}


BOOL
WINAPI
RemoveDirectory9x(
    LPCWSTR lpPathName
    )
{
    if (lpPathName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szPathName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpPathName, &szPathName))
        fResult = RemoveDirectoryA (
            szPathName
            );
    FreeMBStr(rgb, szPathName);
    return(fResult);
}

BOOL
WINAPI
RemoveDirectoryU(
    LPCWSTR lpPathName
    )
{
    if(FIsWinNT())
        return( RemoveDirectoryW (lpPathName) );
    else
        return( RemoveDirectory9x (lpPathName) );
}


UINT
WINAPI
GetWindowsDirectory9x(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    char rgch[_MAX_PATH];
    char *  szDir = NULL;
    UINT cchDir;

    int cchConverted;
    UINT cch;

    szDir = rgch;
    cchDir = sizeof(rgch);
    if (0 == (cchDir = GetWindowsDirectoryA (
            szDir,
            cchDir))) goto ErrorReturn;

    // bump to include null terminator
    cchDir++;

    if (cchDir > sizeof(rgch)) {
        szDir = (char *) malloc(cchDir);
        if(!szDir) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
        if (0 == (cchDir = GetWindowsDirectoryA (
                szDir,
                cchDir))) goto ErrorReturn;
        cchDir++;
    }

    // how long is the unicode string
    if (0 >= (cchConverted = MultiByteToWideChar(
            0,
            0,
            szDir,
            cchDir,
            NULL,
            0)))
        goto ErrorReturn;
    if ((UINT) cchConverted <= uSize) {
        if (0 >= (cchConverted = MultiByteToWideChar(
                0,
                0,
                szDir,
                cchDir,
                lpBuffer,
                (int) uSize)))
            goto ErrorReturn;
        else
            // Don't include null terminating char if input buffer was large
            // enough
            cch = (UINT) cchConverted - 1;
    } else
        // Include null terminating if input buffer wasn't large enough
        cch = (UINT) cchConverted;

CommonReturn:
    if (szDir != rgch && szDir)
        free(szDir);
    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;
}

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    if(FIsWinNT())
        return( GetWindowsDirectoryW (lpBuffer, uSize));
    else
        return( GetWindowsDirectory9x (lpBuffer, uSize));
}


UINT WINAPI GetTempFileName9x(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    )
{
    UINT uResult = 0;

    BYTE rgbPathName[_MAX_PATH];
    BYTE rgbPrefixString[_MAX_PATH];

    char* szPathName = NULL;
    char* szPrefixString = NULL;

    char szTempFileName[_MAX_PATH];

	if ((MkMBStr(rgbPathName, _MAX_PATH, lpPathName, &szPathName)) &&
		(MkMBStr(rgbPrefixString, _MAX_PATH, lpPrefixString, &szPrefixString)))
	{
		if ( ( uResult = GetTempFileNameA(
                            szPathName,
                            szPrefixString,
                            uUnique,
                            szTempFileName
                            ) != 0 ) )
        {
            MultiByteToWideChar(
                 CP_ACP,
                 0,
                 szTempFileName,
                 -1,
                 lpTempFileName,
                 MAX_PATH
                 );
        }
	}

	FreeMBStr(rgbPathName, szPathName);
	FreeMBStr(rgbPrefixString, szPrefixString);

    return( uResult );
}

UINT WINAPI GetTempFileNameU(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    )
{
    if(FIsWinNT())
        return( GetTempFileNameW(
                   lpPathName,
                   lpPrefixString,
                   uUnique,
                   lpTempFileName
                   ) );
    else
        return( GetTempFileName9x(
                   lpPathName,
                   lpPrefixString,
                   uUnique,
                   lpTempFileName
                   ) );
}


HINSTANCE WINAPI LoadLibrary9x(
    LPCWSTR lpLibFileName
    )
{
    BYTE rgb[_MAX_PATH];
    char *  szLibFileName;
    HINSTANCE hInst;

    hInst = NULL;
    if(MkMBStr(rgb, _MAX_PATH, lpLibFileName, &szLibFileName))
        hInst = LoadLibraryA (
            szLibFileName
            );

    FreeMBStr(rgb, szLibFileName);

    return(hInst);
}

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    )
{
    if(FIsWinNT())
        return( LoadLibraryW(lpLibFileName) );
    else
        return( LoadLibrary9x(lpLibFileName) );

}


HINSTANCE WINAPI LoadLibraryEx9x(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    ){

    BYTE rgb[_MAX_PATH];
    char *  szLibFileName;
    HINSTANCE hInst;

    hInst = NULL;
    if(MkMBStr(rgb, _MAX_PATH, lpLibFileName, &szLibFileName))
        hInst = LoadLibraryExA (
            szLibFileName,
            hFile,
            dwFlags
            );

    FreeMBStr(rgb, szLibFileName);

    return(hInst);
}

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    ){

    if(FIsWinNT())
        return( LoadLibraryExW (
            lpLibFileName,
            hFile,
            dwFlags
            ));
    else
        return( LoadLibraryEx9x (
            lpLibFileName,
            hFile,
            dwFlags
            ));
}


DWORD
WINAPI
ExpandEnvironmentStrings9x(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    BYTE rgb1[_MAX_PATH];
    char *  szSrc = NULL;

    char rgch[_MAX_PATH];
    char *  szDst = NULL;
    DWORD cchDst;

    int cbConverted;
    DWORD cch;

    if(!MkMBStr(rgb1, _MAX_PATH, lpSrc, &szSrc))
        goto ErrorReturn;

    szDst = rgch;
    cchDst = sizeof(rgch);
    if (0 == (cchDst = ExpandEnvironmentStringsA(
            szSrc,
            szDst,
            cchDst))) goto ErrorReturn;

    if (cchDst > sizeof(rgch)) {
        szDst = (char *) malloc(cchDst);
        if(!szDst) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
        if (0 == (cchDst = ExpandEnvironmentStringsA(
                szSrc,
                szDst,
                cchDst))) goto ErrorReturn;
    }

    // how long is the unicode string
    if (0 >= (cbConverted = MultiByteToWideChar(
            0,
            0,
            szDst,
            cchDst,
            NULL,
            0)))
        goto ErrorReturn;
    if ((DWORD) cbConverted <= nSize) {
        if (0 >= (cbConverted = MultiByteToWideChar(
                0,
                0,
                szDst,
                cchDst,
                lpDst,
                nSize)))
            goto ErrorReturn;
    }

    cch = (DWORD) cbConverted;

CommonReturn:
    FreeMBStr(rgb1, szSrc);
    if (szDst != rgch && szDst)
        free(szDst);
    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;
}

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    if (lpSrc == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    if(FIsWinNT())
        return( ExpandEnvironmentStringsW(
            lpSrc,
            lpDst,
            nSize
            ));
    else
        return( ExpandEnvironmentStrings9x(
            lpSrc,
            lpDst,
            nSize
            ));
}


void
ConvertFindDataAToFindDataW(
    IN LPWIN32_FIND_DATAA pFindFileDataA,
    OUT LPWIN32_FIND_DATAW pFindFileDataW
    )
{
    DWORD cchFilename;

    memset(pFindFileDataW, 0, sizeof(*pFindFileDataW));
    pFindFileDataW->dwFileAttributes    = pFindFileDataA->dwFileAttributes;
    pFindFileDataW->ftCreationTime      = pFindFileDataA->ftCreationTime;
    pFindFileDataW->ftLastAccessTime    = pFindFileDataA->ftLastAccessTime;
    pFindFileDataW->ftLastWriteTime     = pFindFileDataA->ftLastWriteTime;
    pFindFileDataW->nFileSizeHigh       = pFindFileDataA->nFileSizeHigh;
    pFindFileDataW->nFileSizeLow        = pFindFileDataA->nFileSizeLow;
    // pFindFileDataW->dwReserved0         = pFindFileDataA->dwReserved0;
    // pFindFileDataW->dwReserved1         = pFindFileDataA->dwReserved1;
    // CHAR   cFileName[ MAX_PATH ];
    // pFindFileDataW->cAlternateFileName  = pFindFileDataA->cAlternateFileName;


    cchFilename = strlen(pFindFileDataA->cFileName);
    if (0 != cchFilename && MAX_PATH > cchFilename)
        MultiByteToWideChar(
            CP_ACP,
            0,                      // dwFlags
            pFindFileDataA->cFileName,
            cchFilename + 1,
            pFindFileDataW->cFileName,
            MAX_PATH
            );
}


HANDLE
WINAPI
FindFirstFile9x(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile;
    BYTE rgb[_MAX_PATH];
    WIN32_FIND_DATAA FindFileDataA;
    LPSTR pszDir;

    if (pwszDir == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(INVALID_HANDLE_VALUE);
    }

    if (!MkMBStr(rgb, _MAX_PATH, pwszDir, &pszDir))
        return INVALID_HANDLE_VALUE;

    hFindFile = FindFirstFileA(pszDir, &FindFileDataA);
    if (INVALID_HANDLE_VALUE != hFindFile)
        ConvertFindDataAToFindDataW(&FindFileDataA, lpFindFileData);
    FreeMBStr(rgb, pszDir);
    return hFindFile;
}

HANDLE
WINAPI
FindFirstFileU(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (FIsWinNT())
        return FindFirstFileW(pwszDir, lpFindFileData);
    else
        return FindFirstFile9x(pwszDir, lpFindFileData);
}


BOOL
WINAPI
FindNextFile9x(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    BOOL fResult;
    WIN32_FIND_DATAA FindFileDataA;

    fResult = FindNextFileA(hFindFile, &FindFileDataA);
    if (fResult)
        ConvertFindDataAToFindDataW(&FindFileDataA, lpFindFileData);
    return fResult;
}

BOOL
WINAPI
FindNextFileU(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (FIsWinNT())
        return FindNextFileW(hFindFile, lpFindFileData);
    else
        return FindNextFile9x(hFindFile, lpFindFileData);
}


HANDLE
WINAPI
FindFirstChangeNotification9x(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )
{
    HANDLE hChange;
    BYTE rgb[_MAX_PATH];
    LPSTR pszPath;

    if (pwszPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (!MkMBStr(rgb, _MAX_PATH, pwszPath, &pszPath))
        return INVALID_HANDLE_VALUE;

    hChange = FindFirstChangeNotificationA(pszPath, bWatchSubtree,
        dwNotifyFilter);
    FreeMBStr(rgb, pszPath);
    return hChange;
}

HANDLE
WINAPI
FindFirstChangeNotificationU(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )
{
    if (FIsWinNT())
        return FindFirstChangeNotificationW(
            pwszPath, 
            bWatchSubtree, 
            dwNotifyFilter);
    else
        return FindFirstChangeNotification9x(
            pwszPath, 
            bWatchSubtree, 
            dwNotifyFilter);
}
#endif      // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\event.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       event.cpp
//
//--------------------------------------------------------------------------


#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "crtem.h"
#include "unicode.h"

#ifdef _M_IX86

HANDLE 
WINAPI
CreateEvent9x(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hEvent = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hEvent = CreateEventA(	lpEventAttributes,
								bManualReset,
								bInitialState,
								sz);
		FreeMBStr(rgb, sz);
	}

	return hEvent;
}

HANDLE 
WINAPI
CreateEventU(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName)
{
	if (FIsWinNT())
		return CreateEventW(lpEventAttributes,
							bManualReset,
							bInitialState,
							lpName);
    else
        return CreateEvent9x(lpEventAttributes,
							bManualReset,
							bInitialState,
							lpName);
}


HANDLE 
WINAPI
RegisterEventSource9x(
                    LPCWSTR lpUNCServerName,
					LPCWSTR lpSourceName)
{
	BYTE rgb[_MAX_PATH];
	BYTE rgb2[_MAX_PATH];
	char *sz = NULL;
	char *sz2 = NULL;
	HANDLE hEvent = NULL;

	if ((MkMBStr(rgb, _MAX_PATH, lpUNCServerName, &sz)) &&
		(MkMBStr(rgb2, _MAX_PATH, lpSourceName, &sz2)))
	{
		hEvent = RegisterEventSourceA(	sz,
										sz2);
		FreeMBStr(rgb, sz);
		FreeMBStr(rgb2, sz2);
	}

	return hEvent;
}

HANDLE 
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
					LPCWSTR lpSourceName)
{
	if (FIsWinNT())
		return RegisterEventSourceW(lpUNCServerName,
									lpSourceName);
    else
        return RegisterEventSource9x(lpUNCServerName,
									lpSourceName);
}


HANDLE 
WINAPI
OpenEvent9x(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hEvent = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hEvent = OpenEventA(dwDesiredAccess,
							bInheritHandle,
							sz);
		FreeMBStr(rgb, sz);
	}

	return hEvent;
}

HANDLE 
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	if (FIsWinNT())
		return OpenEventW(	dwDesiredAccess,
							bInheritHandle,
							lpName);
    else
        return OpenEvent9x(	dwDesiredAccess,
							bInheritHandle,
							lpName);
}


HANDLE 
WINAPI
CreateMutex9x(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hMutex = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hMutex = CreateMutexA(	lpMutexAttributes,
								bInitialOwner,
								sz);
		FreeMBStr(rgb, sz);
	}

	return hMutex;
}

HANDLE 
WINAPI
CreateMutexU(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName)
{
	if (FIsWinNT())
		return CreateMutexW(lpMutexAttributes,
							bInitialOwner,
							lpName);
    else
        return CreateMutex9x(lpMutexAttributes,
							bInitialOwner,
							lpName);
}


HANDLE 
WINAPI
OpenMutex9x(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hMutex = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hMutex = OpenMutexA(dwDesiredAccess,
							bInheritHandle,
							sz);
		FreeMBStr(rgb, sz);
	}

	return hMutex;
}

HANDLE 
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	if (FIsWinNT())
		return OpenMutexW(	dwDesiredAccess,
							bInheritHandle,
							lpName);
    else
        return OpenMutex9x(	dwDesiredAccess,
							bInheritHandle,
							lpName);
}


#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\guid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       guid.cpp
//
//  Contents:   Microsoft Internet Security Guid functions
//
//  Functions:  wstr2guid
//              guid2wstr
//
//  History:    05-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>

#include "crtem.h"
#include "unicode.h"


static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";


static BOOL HexStringToDword(LPCWSTR FAR& pwsz, DWORD FAR& Value,
                             int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, pwsz++)
    {
        if (*pwsz >= '0' && *pwsz <= '9')
        {
            Value = (Value << 4) + *pwsz - '0';
        }
        else if (*pwsz >= 'A' && *pwsz <= 'F')
        {
            Value = (Value << 4) + *pwsz - 'A' + 10;
        }
        else if (*pwsz >= 'a' && *pwsz <= 'f')
        {
            Value = (Value << 4) + *pwsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }

    if (chDelim != 0)
    {
        return *pwsz++ == chDelim;
    }
    else
    {
        return(TRUE);
    }
}

BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut)
{
    WCHAR   wsz[9];

    if (!(pwszIn) || !(pgOut))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pwszIn != '{') // only support v2 guids!
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (wcslen(pwszIn) != 38)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    WCHAR   *pwsz;

    pwsz = (WCHAR *)&pwszIn[1];  // pass the first {

    memset(pgOut, 0x00, sizeof(GUID));

    DWORD dw;

    if (!(HexStringToDword(pwsz, pgOut->Data1, sizeof(DWORD)*2, '-')))
    {
        return(FALSE);
    }

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data2 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data3 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[0] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data4[1] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[2] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[3] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[4] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[5] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[6] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[7] = (BYTE)dw;

    return(TRUE);
}

BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut)
{
    if (!(pwszOut) || !(pgIn))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    const BYTE  *pBytes;
    int         i;
    LPWSTR      p;

    p       = pwszOut;
    pBytes  = (const BYTE *)pgIn;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = L'}';
    *p   = L'\0';

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\ole.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ole.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include "unicode.h"

#ifdef _M_IX86

// note: unlike UUidToString, always must LocalFree() returned memory
RPC_STATUS RPC_ENTRY UuidToStringU( 
    UUID *  Uuid, 	
    WCHAR * *  StringUuid	
   ) {

    char *  pszUuid = NULL;
    LONG    err;

    err = FALSE;
    if(RPC_S_OK == 
        (err = UuidToStringA(
               Uuid,
               (unsigned char * *)&pszUuid
               )) )
    {
        // convert A output to W
        LPWSTR sz = MkWStr(pszUuid);
        RpcStringFree((unsigned char * *)&pszUuid);
	if( sz == NULL )
	    return(ERROR_OUTOFMEMORY);

        // copy into output pointer
	*StringUuid = (WCHAR*) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(sz)+1));

	if(*StringUuid != NULL)
	    wcscpy(*StringUuid, sz);
	else
	    err = ERROR_OUTOFMEMORY;
        
        // Do nice free of other buffer
        FreeWStr(sz);
    }

    return(err);
}

#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\redir.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       redir.h
//
//--------------------------------------------------------------------------

#ifndef _REDIR_H_
#define _REDIR_H_

/* 

  Dev Notes:
  To define a redirected provider, call FDefineProvTypeFuncPointers(...).
  Any hProv, hKey, or hHash created using that dwProvType after will 
  be redirected. Any provider not in the list of redirected providers
  will fall through to CAPI. ReDir's handles are fully compatible with 
  direct calls to CAPI.
  
  You are not required to undefine a provider you define -- ReDir will 
  clean up the table during PROCESS_DETACH. However, if you 
  wish to clean up a dwProvType you previously defined, call 
  FUndefineProvTypeFuncPointers(...). 



  WARNING: 
  Reference counting is not applied to the defined providers. That
  is, if you remove a provider definition and then attempt to use 
  an {hKey, hProv, hHash} that was used with that provider, ReDir will
  not have a valid function table.
  


  MultiThreading:
  Critical sections are applied to all functions where necessary, and
  this library should be fully multithread-safe.



  CryptSetProvider availability:
  CryptSetProvider{A,W} is not available to non-CAPI providers. The 
  functions return FALSE if not pointing to AdvAPI's CAPI.



  Wide char APIs:
  Win95 doesn't support Wide APIs, and real ADVAPI doesn't export them.
  Thus, the easiest thing to do was to not try an load them, in any case.
  This means ReDir doesn't support the Wide APIs, even on NT. Could change
  to use an OS check before loading...?

*/

// to allow us to see both W and A versions of APIs, don't
// force us away from either just yet...
#ifndef _ADVAPI32_
#define WINADVAPI DECLSPEC_IMPORT
#endif
			 
// wincrypt func prototypes; other func prototypes at EOF
#include "wincrypt.h"


// Some CryptoAPI typedefs
typedef WINADVAPI BOOL WINAPI CRYPTACQUIRECONTEXTW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
typedef WINADVAPI BOOL WINAPI CRYPTACQUIRECONTEXTA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTW
#else
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTRELEASECONTEXT(
    HCRYPTPROV hProv,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGENKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTDERIVEKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTDESTROYKEY(
    HCRYPTKEY hKey);

typedef WINADVAPI BOOL WINAPI CRYPTSETKEYPARAM(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETKEYPARAM(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTSETHASHPARAM(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETHASHPARAM(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTSETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTGENRANDOM(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

typedef WINADVAPI BOOL WINAPI CRYPTGETUSERKEY(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

typedef WINADVAPI BOOL WINAPI CRYPTEXPORTKEY(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef WINADVAPI BOOL WINAPI CRYPTIMPORTKEY(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef WINADVAPI BOOL WINAPI CRYPTENCRYPT(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

typedef WINADVAPI BOOL WINAPI CRYPTDECRYPT(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef WINADVAPI BOOL WINAPI CRYPTCREATEHASH(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

typedef WINADVAPI BOOL WINAPI CRYPTHASHDATA(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTHASHSESSIONKEY(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

typedef WINADVAPI BOOL WINAPI CRYPTDESTROYHASH(
    HCRYPTHASH hHash);

typedef WINADVAPI BOOL WINAPI CRYPTSIGNHASHA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);
typedef WINADVAPI BOOL WINAPI CRYPTSIGNHASHW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);
#ifdef UNICODE
#define CRYPTSIGNHASH  CRYPTSIGNHASHW
#else
#define CRYPTSIGNHASH  CRYPTSIGNHASHA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTVERIFYSIGNATUREA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);
typedef WINADVAPI BOOL WINAPI CRYPTVERIFYSIGNATUREW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);
#ifdef UNICODE
#define CRYPTVERIFYSIGNATURE  CRYPTVERIFYSIGNATUREW
#else
#define CRYPTVERIFYSIGNATURE  CRYPTVERIFYSIGNATUREA
#endif // !UNICODE

typedef WINADVAPI BOOL WINAPI CRYPTSETPROVIDERA(
    LPCSTR pszProvName,
    DWORD dwProvType);
typedef WINADVAPI BOOL WINAPI CRYPTSETPROVIDERW(
    LPCWSTR pszProvName,
    DWORD dwProvType);
#ifdef UNICODE
#define CRYPTSETPROVIDER  CRYPTSETPROVIDERW
#else
#define CRYPTSETPROVIDER  CRYPTSETPROVIDERA
#endif // !UNICODE



// a structure with a bunch of 

typedef	struct FuncList
{
	CRYPTACQUIRECONTEXTA	*pfnAcquireContextA;
	CRYPTACQUIRECONTEXTW	*pfnAcquireContextW;
	CRYPTRELEASECONTEXT		*pfnReleaseContext;
	CRYPTGENKEY				*pfnGenKey;
	CRYPTDERIVEKEY			*pfnDeriveKey;
	CRYPTDESTROYKEY			*pfnDestroyKey;
	CRYPTSETKEYPARAM		*pfnSetKeyParam;
	CRYPTGETKEYPARAM		*pfnGetKeyParam;
	CRYPTSETHASHPARAM		*pfnSetHashParam;
	CRYPTGETHASHPARAM		*pfnGetHashParam;
	CRYPTSETPROVPARAM		*pfnSetProvParam;
	CRYPTGETPROVPARAM		*pfnGetProvParam;
	CRYPTGENRANDOM			*pfnGenRandom;
	CRYPTGETUSERKEY			*pfnGetUserKey;
	CRYPTEXPORTKEY			*pfnExportKey;
	CRYPTIMPORTKEY			*pfnImportKey;
	CRYPTENCRYPT			*pfnEncrypt;
	CRYPTDECRYPT			*pfnDecrypt;
	CRYPTCREATEHASH			*pfnCreateHash;
	CRYPTHASHDATA			*pfnHashData;
	CRYPTHASHSESSIONKEY		*pfnHashSessionKey;
	CRYPTDESTROYHASH		*pfnDestroyHash;
	CRYPTSIGNHASHA			*pfnSignHashA;
	CRYPTSIGNHASHW			*pfnSignHashW;
	CRYPTVERIFYSIGNATUREA	*pfnVerifySignatureA;
	CRYPTVERIFYSIGNATUREW	*pfnVerifySignatureW;
	CRYPTSETPROVIDERA		*pfnSetProviderA;
	CRYPTSETPROVIDERW		*pfnSetProviderW;

} FUNCLIST, *PFUNCLIST;


// other func prototypes
BOOL WINAPI	FDefineProvTypeFuncPointers(DWORD dwProvType, PFUNCLIST psFuncList);
BOOL WINAPI	FUndefineProvTypeFuncPointers(DWORD dwProvType);


#endif // _REDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\nt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nt.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h" // bring in malloc+free definitions


#ifdef _M_IX86

BOOL WINAPI GetUserName9x(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    char rgch[_MAX_PATH];
    char *szBuffer;
    DWORD cbBuffer;

    int     cchW;
    BOOL fResult;

    szBuffer = rgch;
    cbBuffer = sizeof(rgch);
    fResult = GetUserNameA(
           szBuffer,
           &cbBuffer);

    if (!fResult)
        return FALSE;

    cbBuffer++;                      // count the NULL terminator
    if (sizeof(rgch) < cbBuffer)
    {
        szBuffer = (char *) malloc(cbBuffer);
        if(!szBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        fResult = GetUserNameA(
               szBuffer,
               &cbBuffer);
        cbBuffer++;                    // count the NULL terminator
    }

    if(fResult)
    {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            cbBuffer,
                            lpBuffer,
                            *nSize);
        if(cchW == 0)
            fResult = FALSE;
        else
            *nSize = cchW - 1; // does not include NULL
    }

    if(szBuffer != rgch)
        free(szBuffer);

    return(fResult);
}

BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    if(FIsWinNT())
        return( GetUserNameW(lpBuffer, nSize));
    else
        return( GetUserName9x(lpBuffer, nSize));
}


BOOL WINAPI GetComputerName9x(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    char rgch[_MAX_PATH];
    char *szBuffer;
    DWORD cbBuffer;

    int     cchW;
    BOOL fResult;

    szBuffer = rgch;
    cbBuffer = sizeof(rgch);
    fResult = GetComputerNameA(
           szBuffer,
           &cbBuffer);

    if (!fResult)
        return fResult;

    cbBuffer++;                      // count the NULL terminator
    if (sizeof(rgch) < cbBuffer)
    {
        szBuffer = (char *) malloc(cbBuffer);
        if(!szBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        fResult = GetComputerNameA(
               szBuffer,
               &cbBuffer);
        cbBuffer++;                    // count the NULL terminator
    }

    if(fResult)
    {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            cbBuffer,
                            lpBuffer,
                            *nSize);
        if(cchW == 0)
            fResult = FALSE;
        else
            *nSize = cchW - 1; // does not include NULL
    }

    if(szBuffer != rgch)
        free(szBuffer);

    return(fResult);
}

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    if(FIsWinNT())
        return( GetComputerNameW(lpBuffer, nSize));
    else
        return( GetComputerName9x(lpBuffer, nSize));
}


DWORD WINAPI GetModuleFileName9x(
    HMODULE hModule,    // handle to module to find filename for
    LPWSTR lpFilename,  // pointer to buffer for module path
    DWORD nSize     // size of buffer, in characters
   ) {

    char rgch[_MAX_PATH];
    DWORD cbBuffer;

    DWORD    cch;

    cbBuffer = sizeof(rgch);
    cch = GetModuleFileNameA(
           hModule,
           rgch,
           cbBuffer);

    if(cch == 0)
        return 0;

    return MultiByteToWideChar(
                        0,                      // codepage
                        0,                      // dwFlags
                        rgch,
                        cbBuffer,
                        lpFilename,
                        nSize);
}

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,    // handle to module to find filename for
    LPWSTR lpFilename,  // pointer to buffer for module path
    DWORD nSize     // size of buffer, in characters
   ) {

    if(FIsWinNT())
        return( GetModuleFileNameW(hModule, lpFilename, nSize));
    else
        return( GetModuleFileName9x(hModule, lpFilename, nSize));
}


HMODULE WINAPI GetModuleHandle9x(
    LPCWSTR lpModuleName    // address of module name to return handle for
   ) {

    char *  szBuffer = NULL;
    BYTE    rgb1[_MAX_PATH];
    DWORD   cbBuffer;

    HMODULE hModule;

    hModule = NULL;
    if(MkMBStr(rgb1, _MAX_PATH, lpModuleName, &szBuffer) )
        hModule = GetModuleHandleA(
            szBuffer);

    FreeMBStr(rgb1, szBuffer);

    return hModule;
}

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   ) {

    if(FIsWinNT())
        return( GetModuleHandleW(lpModuleName));
    else
        return( GetModuleHandle9x(lpModuleName));
}

#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\reghkcu.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    reghkcu.c

Abstract:

    This module implements functionality to correctly access the pre-defined
    registry key HKEY_CURRENT_USER.

Author:

    Scott Field (sfield)    03-Jul-97

--*/

#include <windows.h>

#include "crtem.h"
#include "unicode.h"

#define TEXTUAL_SID_LOCAL_SYSTEM    L"S-1-5-18"

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    );

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    );


static LONG GetStatus()
{
    DWORD dwErr = GetLastError();
    if (ERROR_SUCCESS == dwErr)
        return ERROR_INVALID_DATA;
    else
        return (LONG) dwErr;
}

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    )
{
    return RegOpenHKCUEx(phKeyCurrentUser, 0);
}

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    )
{
    WCHAR wszFastBuffer[256];
    LPWSTR wszSlowBuffer = NULL;
    LPWSTR wszTextualSid;
    DWORD cchTextualSid;

    LONG lRet = ERROR_SUCCESS;

    *phKeyCurrentUser = NULL;

    //
    // Win95: just return HKEY_CURRENT_USER, as we don't have
    // multiple security contexts on that platform.
    //

    if(!FIsWinNT()) {
        *phKeyCurrentUser = HKEY_CURRENT_USER;
        return ERROR_SUCCESS;
    }

    //
    // WinNT: first, map the binary Sid associated with the
    // current security context to an textual Sid.
    //

    wszTextualSid = wszFastBuffer;
    cchTextualSid = sizeof(wszFastBuffer) / sizeof(WCHAR);

    if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            return GetStatus();

        //
        // try again with larger buffer.
        //

        wszSlowBuffer = (LPWSTR)malloc(cchTextualSid * sizeof(WCHAR));
        if(wszSlowBuffer == NULL)
            return GetStatus();

        wszTextualSid = wszSlowBuffer;
        if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
            free(wszSlowBuffer);
            return GetStatus();
        }
    }

    //
    // next, try to open the registry key below HKEY_USERS
    // that corresponds to the textual Sid.
    //

    lRet = RegOpenKeyExW(
                    HKEY_USERS,
                    wszTextualSid,
                    0,      // dwOptions
                    MAXIMUM_ALLOWED,
                    phKeyCurrentUser
                    );

    if(lRet != ERROR_SUCCESS) {

        if (dwFlags & REG_HKCU_DISABLE_DEFAULT_FLAG)
            lRet = ERROR_FILE_NOT_FOUND;
        else if (0 == (dwFlags & REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG) ||
                0 == wcscmp(TEXTUAL_SID_LOCAL_SYSTEM, wszTextualSid)) {
            //
            // If that failed, fall back to HKEY_USERS\.Default.
            // Note: this is correct behavior with respect to the
            // rest of the system, eg, Local System security context
            // has no registry hive loaded by default
            //

            lRet = RegOpenKeyExW(
                            HKEY_USERS,
                            L".Default",
                            0,      // dwOptions
                            MAXIMUM_ALLOWED,
                            phKeyCurrentUser
                            );
        }
    }


    if(wszSlowBuffer)
        free(wszSlowBuffer);

    return lRet;
}


LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    )
{
    LONG lRet = ERROR_SUCCESS;

    if( hKeyCurrentUser != NULL && hKeyCurrentUser != HKEY_CURRENT_USER )
        lRet = RegCloseKey( hKeyCurrentUser );

    return lRet;
}



BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken
                ))
    {
        if(GetLastError() != ERROR_NO_TOKEN)
            return FALSE;

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            return FALSE;
    }

    fSuccess = GetTokenUserSidHKCU(hToken, &pSidUser);

    CloseHandle(hToken);

    if(fSuccess) {

        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSidHKCU(
                        pSidUser,       // user binary Sid
                        wszTextualSid,  // buffer for TextualSid
                        pcchTextualSid  // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        free(pSidUser);

    return fSuccess;
}

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidSize;


    //
    // validate Sid validity
    //

    if(!IsValidSid(pSid))
        return FALSE;

    //
    // obtain SidIdentifierAuthority
    //

    psia = GetSidIdentifierAuthority(pSid);

    //
    // obtain sidsubauthority count
    //

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length in chars (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*pcchTextualSid < cchSidSize) {
        *pcchTextualSid = cchSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell caller how many chars copied, including terminal NULL
    //

    *pcchTextualSid = cchSidSize + 1;

    return TRUE;
}

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to free().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;

    *ppUserSid = NULL;

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)malloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = malloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            free(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        free(SlowBuffer);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       reg.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
//#include <assert.h>

#include "crtem.h"
#include "unicode.h"

//
// FIsWinNT: check OS type on x86.  On non-x86, assume WinNT
//

#ifdef _M_IX86

BOOL WINAPI FIsWinNTCheck(void) {

    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        return (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
    else
        return (FALSE);
}

BOOL WINAPI FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    if(fIKnow)
        return(fIsWinNT);

    fIsWinNT = FIsWinNTCheck();    

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}

#else

BOOL WINAPI FIsWinNT(void) {
    return(TRUE);
}

#endif

BOOL
WINAPI
FIsWinNT5Check(
    VOID
    )
{
    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        return ( osVer.dwMajorVersion >= 5 );
    else
        return (FALSE);
}

BOOL
WINAPI
FIsWinNT5(
    VOID
    )
{
    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT5 = FALSE;

    if(!FIsWinNT())
        return FALSE;

    if(fIKnow)
        return(fIsWinNT5);

    fIsWinNT5 = FIsWinNT5Check();

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return(fIsWinNT5);
}

// make MBCS from Unicode string
//
// Include parameters specifying the length of the input wide character
// string and return number of bytes converted. An input length of -1 indicates
// null terminated.
//
// This extended version was added to handle REG_MULTI_SZ which contains
// multiple null terminated strings.
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW,
    char ** pszMB, int *pcbConverted) {

    int   cbConverted;

    // sfield: don't bring in crt for assert.  you get free assert via
    // an exception if these are null
//    assert(pszMB != NULL);
    *pszMB = NULL;
//    assert(pcbConverted != NULL);
    *pcbConverted = 0;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        cchW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
    if (cbConverted <= 0)
        return(FALSE);

    // get a buffer long enough
    if(pbBuff != NULL  &&  (DWORD) cbConverted <= cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) malloc(cbConverted);

    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    *pcbConverted = WideCharToMultiByte(0,
                        0,
                        wsz,
                        cchW,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

// make MBCS from Unicode string
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {
    int cbConverted;
    return MkMBStrEx(pbBuff, cbBuff, wsz, -1, pszMB, &cbConverted);
}

void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        free(szMB);
}

// #endif      // _M_IX86

// make Unicode string from MBCS
LPWSTR WINAPI MkWStr(char * szMB) {

    LPWSTR wsz = NULL;
    int   cbConverted;

    if(szMB == NULL)
        goto Ret;

    // how long is the unicode string
    if (0 >= (cbConverted = MultiByteToWideChar(  0,
                                        0,
                                        szMB,
                                        -1,
                                        NULL,
                                        0)))
        goto Ret;

    // get a buffer long enough
    wsz = (LPWSTR) malloc(cbConverted * sizeof(WCHAR));

    if(wsz == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Ret;
    }

    // now convert to MB
    MultiByteToWideChar(0,
                        0,
                        szMB,
                        -1,
                        wsz,
                        cbConverted);
Ret:
    return(wsz);
}

void WINAPI FreeWStr(LPWSTR wsz) {

    if(wsz != NULL)
        free(wsz);
}

#ifdef _M_IX86

LONG WINAPI RegCreateKeyEx9x (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szSubKey = NULL;
    char *  szClass = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey)    &&
        MkMBStr(rgb2, _MAX_PATH, lpClass,  &szClass)     )
        err = RegCreateKeyExA (
               hKey,
               szSubKey,
               Reserved,
               szClass,
               dwOptions,
               samDesired,
               lpSecurityAttributes,
               phkResult,
               lpdwDisposition
               );

    FreeMBStr(rgb1, szSubKey);
    FreeMBStr(rgb2, szClass);

    return(err);
}

LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    if(FIsWinNT())
        return( RegCreateKeyExW (
            hKey,
            lpSubKey,
            Reserved,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition
            ));
    else
        return( RegCreateKeyEx9x (
            hKey,
            lpSubKey,
            Reserved,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition
            ));   
}


LONG WINAPI RegDeleteKey9x (
    HKEY hKey,
    LPCWSTR lpSubKey
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey))
        err = RegDeleteKeyA (
               hKey,
               szSubKey
               );

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegDeleteKeyU (
    HKEY hKey,
    LPCWSTR lpSubKey
    ) {

    if(FIsWinNT())
        return( RegDeleteKeyW (
            hKey,
            lpSubKey
            ));
    else
        return( RegDeleteKey9x (
            hKey,
            lpSubKey
            ));
}


LONG WINAPI RegEnumKeyEx9x (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   ) {

    char rgch[_MAX_PATH];
    char *  szKeyName;
    DWORD cbKeyName;

    char rgch1[_MAX_PATH];
    char *  szClassName;
    DWORD cbClassName;

    int     cchW;
    LONG    err;

    szKeyName = rgch;
    cbKeyName = sizeof(rgch);
    szClassName = rgch1;
    cbClassName = sizeof(rgch1);

    err = RegEnumKeyExA (
        hKey,
        dwIndex,
        szKeyName,
        &cbKeyName,
        lpReserved,
        szClassName,
        &cbClassName,
        lpftLastWriteTime
        );
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER))
        return err;
    err = ERROR_SUCCESS;

    cbKeyName++;                      // count the NULL terminator
    cbClassName++;                    // count the NULL terminator
    if ((sizeof(rgch) < cbKeyName) || (sizeof(rgch1) < cbClassName)) {
        szKeyName = (char *) malloc(cbKeyName);
        if(!szKeyName)
            return ERROR_OUTOFMEMORY;

        szClassName = (char *) malloc(cbClassName);
	if(!szClassName) {
	    free(szKeyName);
	    return ERROR_OUTOFMEMORY;
	}

        err = RegEnumKeyExA (
            hKey,
            dwIndex,
            szKeyName,
            &cbKeyName,
            lpReserved,
            szClassName,
            &cbClassName,
            lpftLastWriteTime
            );
        cbKeyName++;                    // count the NULL terminator
        cbClassName++;                  // count the NULL terminator
    }

    if(err == ERROR_SUCCESS) {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szKeyName,
                            cbKeyName,
                            lpName,
                            *lpcbName);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcbName = cchW - 1; // does not include NULL
    }

    if(szKeyName != rgch)
        free(szKeyName);

    if(err == ERROR_SUCCESS) {

        //
        // it's legal for lpClass/lpcbClass to be NULL, so only copy if they are not NOT
        //

        if(lpClass != NULL) {
            // note: RegEnumKeyEx specifies that lpcbClass can only be NULL
            // if lpClass is NULL, so the correct behavior is to fault if
            // lpClass is non-null and lpcbClass is NULL; this behavior is
            // does happen here.
            //
            cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szClassName,
                            cbClassName,
                            lpClass,
                            *lpcbClass);
            if(cchW == 0)
                err = GetLastError();
        }

        if(lpcbClass != NULL)
            *lpcbClass = cbClassName - 1; // does not include NULL
    }

    if(szClassName != rgch1)
        free(szClassName);

    return err;
}

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   ) {

    if(FIsWinNT())
        return( RegEnumKeyExW (
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                lpReserved,
                lpClass,
                lpcbClass,
                lpftLastWriteTime
                ));
    else
        return( RegEnumKeyEx9x (
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                lpReserved,
                lpClass,
                lpcbClass,
                lpftLastWriteTime
                ));
}

static LONG WINAPI ConvertRegValue (
    DWORD dwType,
    LPBYTE pbInData,
    DWORD cbInData,
    LPBYTE pbOutData,
    LPDWORD pcbOutData
    ) {

    LONG err = ERROR_SUCCESS;
    DWORD cbOrigOutData;

    if (NULL == pcbOutData)
        return ERROR_SUCCESS;

    cbOrigOutData = *pcbOutData;

    if (0 == cbInData)
        *pcbOutData = 0;
    else if (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
            REG_MULTI_SZ == dwType) {
        int cchW;
        // First get length needed for wide characters
        cchW = MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    NULL,                   // lpWideCharStr
                    0);                     // cchWideChar
        *pcbOutData = cchW * sizeof(WCHAR);
        if(cchW == 0)
            err = GetLastError();
        else if (pbOutData) {
            if (cbOrigOutData < *pcbOutData)
                err = ERROR_MORE_DATA;
            else
                // Convert to Unicode data
                MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    (LPWSTR) pbOutData,
                    cchW);
        }
    } else {
        // Copy to output
        *pcbOutData = cbInData;
        if (pbOutData) {
            if (cbOrigOutData < cbInData)
                err = ERROR_MORE_DATA;
            else
                memcpy(pbOutData, pbInData, cbInData);
        }
    }

    return err;
}

#define MAX_REG_VALUE_DATA  256

LONG WINAPI RegEnumValue9x (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    char rgch[_MAX_PATH];
    char *  szValueName;
    DWORD   cbValueName;
    DWORD   dwType;
    LONG    err;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    szValueName = rgch;
    cbValueName = sizeof(rgch);
    pbData = rgbData;
    cbData = sizeof(rgbData);
    err = RegEnumValueA (
        hKey,
        dwIndex,
        szValueName,
        &cbValueName,
        lpReserved,
        &dwType,
        pbData,
        &cbData
        );
    if (lpType)
        *lpType = dwType;
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;

    err = ERROR_SUCCESS;

    cbValueName++;                      // count the NULL terminator
    if (sizeof(rgch) < cbValueName || sizeof(rgbData) < cbData) {
        if (sizeof(rgch) < cbValueName) {
            szValueName = (char *) malloc( cbValueName);
            if(!szValueName) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        if (sizeof(rgbData) < cbData) {
            pbData = (BYTE *) malloc(cbData);
            if(!pbData) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        err = RegEnumValueA (
            hKey,
            dwIndex,
            szValueName,
            &cbValueName,
            lpReserved,
            lpType,
            pbData,
            &cbData
            );
        cbValueName++;                  // count the NULL terminator
    }

    if (err == ERROR_SUCCESS) {
        int     cchW;
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szValueName,
                            cbValueName,
                            lpValueName,
                            lpValueName ? *lpcchValueName : 0);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcchValueName = cchW - 1; // does not include NULL
    } else
        *lpcchValueName = 0;

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else if (lpcbData)
        *lpcbData = 0;

CommonReturn:
    if(szValueName != rgch && szValueName)
        free(szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    *lpcchValueName = 0;
    if (lpcbData)
        *lpcbData = 0;
    goto CommonReturn;
}

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    if(FIsWinNT())
        return( RegEnumValueW (
                hKey,
                dwIndex,
                lpValueName,
                lpcchValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
    else
        return( RegEnumValue9x (
                hKey,
                dwIndex,
                lpValueName,
                lpcchValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
}


LONG RegDeleteValue9x (
    HKEY hKey,
    LPCWSTR lpValueName
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegDeleteValueA (
            hKey,
            szValueName
            );

    FreeMBStr(rgb, szValueName);

    return(err);
}

LONG RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    ) {

    if(FIsWinNT())
        return(RegDeleteValueW (
            hKey,
            lpValueName
            ));
    else
        return(RegDeleteValue9x (
            hKey,
            lpValueName
            ));
}


LONG RegQueryValueEx9x(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    BYTE    rgb[_MAX_PATH];
    char *  szValueName = NULL;
    LONG    err;
    DWORD   dwType;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    pbData = rgbData;
    cbData = sizeof(rgbData);

    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    else {
        err = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }


    if (lpType)
        *lpType = dwType;

    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;
    err = ERROR_SUCCESS;

    if (sizeof(rgbData) < cbData) {
        pbData = (BYTE *) malloc(cbData);
        if(!pbData) {
            err = ERROR_OUTOFMEMORY;
            goto ErrorReturn;
        }
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    }

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else if (lpcbData)
        *lpcbData = 0;

CommonReturn:
    FreeMBStr(rgb, szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    if (lpcbData)
        *lpcbData = 0;
    goto CommonReturn;
}

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    if (lpReserved != NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    if(FIsWinNT())
        return(RegQueryValueExW (
                hKey,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
    else
        return(RegQueryValueEx9x (
                hKey,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
}


LONG WINAPI RegSetValueEx9x (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    err = ERROR_OUTOFMEMORY;
    if(MkMBStr(rgb1, _MAX_PATH, lpValueName, &szValueName))
    {
        // convert the data to ascii if necessary
        if (0 != cbData / sizeof(WCHAR) &&
                (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
                    REG_MULTI_SZ == dwType))
        {
            char *  szData;
            int cbConverted;

            if(MkMBStrEx(NULL, 0, (LPWSTR)lpData, cbData/sizeof(WCHAR),
                &szData, &cbConverted))
            {
                err = RegSetValueExA (
                    hKey,
                    szValueName,
                    Reserved,
                    dwType,
                    (BYTE*)szData,
                    cbConverted
                    );
                FreeMBStr(NULL, szData);
            }
        }
        else
        {
            err = RegSetValueExA (
                hKey,
                szValueName,
                Reserved,
                dwType,
                lpData,
                cbData
                );
        }
        FreeMBStr(rgb1, szValueName);
    }


    return(err);
}

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    ) {

    if(FIsWinNT())
        return(RegSetValueExW (
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData
            ));
    else
        return(RegSetValueEx9x (
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData
            ));
}


LONG WINAPI RegQueryInfoKey9x (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szClass;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpClass, &szClass))
        err =  RegQueryInfoKeyA (
            hKey,
            szClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            );
    if (lpcbMaxValueLen)
        // Need to double for converting to unicode characters.
        *lpcbMaxValueLen = *lpcbMaxValueLen * 2;

    FreeMBStr(rgb, szClass);

    return(err);
}

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    ) {

    if(FIsWinNT())
        return( RegQueryInfoKeyW (
            hKey,
            lpClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            ));
    else
        return( RegQueryInfoKey9x (
            hKey,
            lpClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            ));
}


LONG WINAPI RegOpenKeyEx9x(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey) )
        err = RegOpenKeyExA(
            hKey,
            szSubKey,
            ulOptions,
            samDesired,
            phkResult);

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if(FIsWinNT())
        return( RegOpenKeyExW(
            hKey,
            lpSubKey,
            ulOptions,
            samDesired,
            phkResult
            ));
    else
        return( RegOpenKeyEx9x(
            hKey,
            lpSubKey,
            ulOptions,
            samDesired,
            phkResult
            ));
}


LONG WINAPI RegConnectRegistry9x (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szMachineName = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpMachineName, &szMachineName) )
        err = RegConnectRegistryA(
            szMachineName,
            hKey,
            phkResult);

    FreeMBStr(rgb1, szMachineName);

    return(err);
}

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    ) {

    if(FIsWinNT())
        return( RegConnectRegistryW(
            lpMachineName,
            hKey,
            phkResult
            ));
    else
        return( RegConnectRegistry9x(
            lpMachineName,
            hKey,
            phkResult
            ));
}


#endif      // _M_IX86


LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExU(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExW(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExA(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}


LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExU(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }


    err = RegOpenKeyExW(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}

LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExA(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegOpenKeyExA(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\unicode\user.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       user.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h"
#include <stddef.h>

#ifdef _M_IX86

#define MAX_STRING_RSC_SIZE 512

int WINAPI LoadString9x(
    HINSTANCE hInstance,	// handle of module containing string resource 
    UINT uID,	// resource identifier 
    LPWSTR lpBuffer,	// address of buffer for resource 
    int nBufferMax 	// size of buffer 
   ) {
    
    char rgch[MAX_STRING_RSC_SIZE];
    int     cchW;
    LONG    err;

    err = LoadStringA(
        hInstance,
        uID,
        rgch,
        MAX_STRING_RSC_SIZE);

    if (err == 0)
        return err;

    return MultiByteToWideChar(
                        0,                      // codepage
                        0,                      // dwFlags
                        rgch,
                        err + 1,
                        lpBuffer,
                        nBufferMax);
}

int WINAPI LoadStringU(
    HINSTANCE hInstance,	// handle of module containing string resource 
    UINT uID,	// resource identifier 
    LPWSTR lpBuffer,	// address of buffer for resource 
    int nBufferMax 	// size of buffer 
   ) {
    
    if(FIsWinNT())
        return( LoadStringW(
            hInstance,
            uID,
            lpBuffer,
            nBufferMax
            ));
    else
        return( LoadString9x(
            hInstance,
            uID,
            lpBuffer,
            nBufferMax
            ));
}


BOOL
WINAPI
InsertMenu9x(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    )
{

    LPSTR       pszNewItem=NULL;
    BOOL        fReturn=FALSE;

    if( (0 == (uFlags & MF_BITMAP)) &&
        (0 == (uFlags & MF_OWNERDRAW))
      )
    {

        if(!MkMBStr(NULL, 0, lpNewItem, &pszNewItem))
            return FALSE;

        fReturn=InsertMenuA(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                (LPCSTR)pszNewItem);
    }
    else
    {
        fReturn=InsertMenuA(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                (LPCSTR)lpNewItem);
    }

    if(pszNewItem)
         FreeMBStr(NULL, pszNewItem);

    return fReturn;
}

BOOL
WINAPI
InsertMenuU(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    )
{
    if(FIsWinNT())
        return InsertMenuW(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                lpNewItem);
    else
        return InsertMenu9x(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                lpNewItem);
}


//-------------------------------------------------------------------------
//
//  FormatMessageU 
//      This function assume any patten of !S! or !s! in lpSource are used for 
//  formatting purpose only.
//
//--------------------------------------------------------------------------
DWORD WINAPI FormatMessage9x(
    DWORD dwFlags,	    // source and processing options 
    LPCVOID lpSource,	// pointer to  message source 
    DWORD dwMessageId,	// requested message identifier 
    DWORD dwLanguageId,	// language identifier for requested message 
    LPWSTR lpBuffer,	// pointer to message buffer 
    DWORD nSize,	    // maximum size of message buffer 
    va_list *Arguments 	// address of array of message inserts 
   )
{
    
    DWORD   cb=0;
    LPSTR   pChar=NULL;
    DWORD   dwSize=0;

    LPSTR   pszSource=NULL;
    LPSTR   pszBuffer=NULL;
    LPWSTR  pwszBuffer=NULL;

    //we need to change the lpSource
    if((dwFlags & FORMAT_MESSAGE_FROM_STRING) && 
       (0 == (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS))
      )
    {
        //get the ascii version of the string
         if((lpSource == NULL) || !MkMBStr(NULL, 0, (LPWSTR)lpSource, &pszSource))
            goto CLEANUP;
         
         //we change "!S!" to "!s!" and "!s!" to "!S!"
         pChar = pszSource;

         while((*pChar) != '\0')
         {
            if((*pChar) == '!')
            {
                if((*(pChar+1)) == 's')
                {
                    if((*(pChar+2)) == '!')
                        *(pChar+1)='S';
                }
                else
                {
                    if((*(pChar+1)) == 'S')
                    {
                        if((*(pChar+2)) == '!')
                           *(pChar+1)='s';
                    }
                }
            }

            pChar++;
         }

    }

    if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        cb = FormatMessageA(
            dwFlags,
            pszSource,
            dwMessageId,
            dwLanguageId,
            (LPSTR)&pszBuffer,
            nSize,
            Arguments);

        if(cb)
        {
            if(NULL == (pwszBuffer=MkWStr(pszBuffer)))
            {
                cb=0;
                goto CLEANUP;
            }

            dwSize=sizeof(WCHAR)*(wcslen(pwszBuffer) +1);

            *((LPWSTR *)lpBuffer)=(LPWSTR)LocalAlloc(LPTR, dwSize);

            if(NULL == (*lpBuffer))
            {
                cb=0;
                goto CLEANUP;
            }

            wcscpy((*((LPWSTR *)lpBuffer)), pwszBuffer);

            cb=wcslen(pwszBuffer);
        }

    }
    else
    {   

        pszBuffer=(LPSTR)LocalAlloc(LPTR, sizeof(CHAR) * nSize);

        if (NULL == pszBuffer)
            goto CLEANUP;

        cb = FormatMessageA(
            dwFlags,
            pszSource,
            dwMessageId,
            dwLanguageId,
            pszBuffer,
            nSize,
            Arguments);
       
        if(cb)
        {
            if(NULL == (pwszBuffer=MkWStr(pszBuffer)))
            {
                cb=0;
                goto CLEANUP;
            }

            wcscpy((LPWSTR)lpBuffer, pwszBuffer);

            cb=wcslen(pwszBuffer);
        }
    }   

CLEANUP:

    if(pszSource)
         FreeMBStr(NULL,pszSource);

    if(pszBuffer)
         LocalFree((HLOCAL)pszBuffer);

    if(pwszBuffer)
         FreeWStr(pwszBuffer);

    return(cb);
}

DWORD WINAPI FormatMessageU(
    DWORD dwFlags,	    // source and processing options 
    LPCVOID lpSource,	// pointer to  message source 
    DWORD dwMessageId,	// requested message identifier 
    DWORD dwLanguageId,	// language identifier for requested message 
    LPWSTR lpBuffer,	// pointer to message buffer 
    DWORD nSize,	    // maximum size of message buffer 
    va_list *Arguments 	// address of array of message inserts 
   )
{
    if(FIsWinNT())
        return( FormatMessageW(
            dwFlags,
            lpSource,
            dwMessageId,
            dwLanguageId,
            lpBuffer,
            nSize,
            Arguments
            ));
    else
        return( FormatMessage9x(
            dwFlags,
            lpSource,
            dwMessageId,
            dwLanguageId,
            lpBuffer,
            nSize,
            Arguments
            ));
}


//-------------------------------------------------------------------------
//
//  CompareStringU 
//      This function only handles the case where cchCount1==-1 and cchCount==-1.
//
//--------------------------------------------------------------------------
int
WINAPI
CompareString9x(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2)
{
	int		iReturn=0;
	int     cb1=0;
	int     cb2=0;

	LPSTR	psz1=NULL;
	LPSTR	psz2=NULL;

    cb1 = WideCharToMultiByte(
            0, 
            0, 
            lpString1, 
            cchCount1, 
            NULL,
            0,
            NULL,
			NULL);

	if(NULL==(psz1=(LPSTR)malloc(cb1)))
	{
		SetLastError(E_OUTOFMEMORY);
		goto CLEANUP;
	}

    if(0 == (cb1 = WideCharToMultiByte(
            0, 
            0, 
            lpString1, 
            cchCount1, 
            psz1,
            cb1,
            NULL,
			NULL)))
		goto CLEANUP;

	 
    cb2 = WideCharToMultiByte(
            0, 
            0, 
            lpString2, 
            cchCount2, 
            NULL,
            0,
            NULL,
			NULL);

	if(NULL == (psz2=(LPSTR)malloc(cb2)))
	{
		SetLastError(E_OUTOFMEMORY);
		goto CLEANUP;
	}

    if(0 == (cb2 = WideCharToMultiByte(
            0, 
            0, 
            lpString2, 
            cchCount2, 
            psz2,
            cb2,
            NULL,
			NULL)))
		goto CLEANUP;

	iReturn = CompareStringA(Locale,
								dwCmpFlags,
								psz1,
								cb1,
								psz2,
								cb2);


CLEANUP:
	
	if(psz1)
		free(psz1);

	if(psz2)
		free(psz2);

	return iReturn;

}

int
WINAPI
CompareStringU(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2)
{
	if(FIsWinNT())
        return CompareStringW(
                    Locale,
					dwCmpFlags,
					lpString1,
					cchCount1,
					lpString2,
					cchCount2);
	else
        return CompareString9x(
                    Locale,
					dwCmpFlags,
					lpString1,
					cchCount1,
					lpString2,
					cchCount2);
}


//-------------------------------------------------------------------------
//
//  PropertySheetU
//
//--------------------------------------------------------------------------
typedef   INT_PTR   (WINAPI *PFPropertySheetA)(LPCPROPSHEETHEADERA);
typedef   INT_PTR   (WINAPI *PFPropertySheetW)(LPCPROPSHEETHEADERW);

INT_PTR WINAPI PropertySheet9x(
    LPPROPSHEETHEADERW  lppsph)
{
    PROPSHEETHEADERA        PropHeaderA;
    INT_PTR                 iReturn=-1;
    DWORD                   dwIndex=0;
    UINT                    nPages=0; 
    DWORD                   dwSize=0;
 
    LPPROPSHEETPAGEA        pPropSheetA=NULL;
    LPSTR                   pszCaption=NULL;
    LPSTR                   pszTitle=NULL;

    HMODULE                 hModule=NULL;  
    PFPropertySheetA        pfPropertySheetA=NULL;
    
    
    //load the comctl.32 since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("comctl32.dll")))
        return iReturn;

    memcpy(&PropHeaderA, lppsph, sizeof(PROPSHEETHEADERA));

    if(lppsph->pszCaption)
    {
         if(!MkMBStr(NULL, 0, (LPWSTR)(lppsph->pszCaption), &pszCaption))
            goto CLEANUP;

         PropHeaderA.pszCaption=pszCaption;
    }

    //convert the property sheets
    if(PSH_PROPSHEETPAGE & lppsph->dwFlags)
    {
        nPages = lppsph->nPages;

        if(nPages)
        {
            dwSize=sizeof(PROPSHEETPAGEA) * nPages;

            pPropSheetA=(LPPROPSHEETPAGEA)LocalAlloc(LPTR, dwSize);

            if(NULL == pPropSheetA)
                goto CLEANUP;

            memcpy(pPropSheetA, lppsph->ppsp, dwSize);

            //pre-set the title
            for(dwIndex=0; dwIndex < (DWORD)nPages; dwIndex++)
            {
                pPropSheetA[dwIndex].pszTitle=NULL;
            }

            for(dwIndex=0; dwIndex < (DWORD)nPages; dwIndex++)
            {
                if((lppsph->ppsp)[dwIndex].pszTitle)
                {
                     if(!MkMBStr(NULL, 0, (LPWSTR)((lppsph->ppsp)[dwIndex].pszTitle), 
                                &pszTitle))
                        goto CLEANUP;

                     pPropSheetA[dwIndex].pszTitle=pszTitle;
                }

            }

            PropHeaderA.ppsp=pPropSheetA;
        }
    }

    if(NULL != (pfPropertySheetA=(PFPropertySheetA)GetProcAddress(hModule, "PropertySheetA")))
    {
        iReturn=pfPropertySheetA(&PropHeaderA);
    }


CLEANUP:

    if(pszCaption)
        FreeMBStr(NULL, pszCaption);

    //free the title
    if(PropHeaderA.nPages)
    {
        for(dwIndex=0; dwIndex < PropHeaderA.nPages; dwIndex++)
        {
            if(pPropSheetA[dwIndex].pszTitle)
                FreeMBStr(NULL, (LPSTR)((pPropSheetA[dwIndex]).pszTitle));
        }

    }

    if(pPropSheetA)
        LocalFree((HLOCAL)pPropSheetA);


    if(hModule)
        FreeLibrary(hModule);

    return iReturn;
}

INT_PTR WINAPI PropertySheetU(
    LPPROPSHEETHEADERW  lppsph)
{
    INT_PTR             iReturn=-1;
    HMODULE             hModule=NULL; 
    PFPropertySheetW    pfPropertySheetW=NULL;
    
    if(FIsWinNT())
    {
        //load the comctl.32 since many dlls in ispu project
        //use unicode.lib, just do not link to comctl32.dll
        if(NULL == (hModule=LoadLibrary("comctl32.dll")))
            return iReturn;

        if(NULL != (pfPropertySheetW=(PFPropertySheetW)GetProcAddress(hModule, "PropertySheetW")))
        {
            iReturn=pfPropertySheetW(lppsph);
        } 
        
        FreeLibrary(hModule);
    }
    else
    {
        iReturn=PropertySheet9x(lppsph);
    }

    return iReturn;
}

//-------------------------------------------------------------------------
//
//  DragQueryFileU
//
//--------------------------------------------------------------------------
typedef UINT (WINAPI *PFDragQueryFileA)(HDROP,UINT,LPSTR,UINT);
typedef UINT (WINAPI *PFDragQueryFileW)(HDROP,UINT,LPWSTR,UINT);


UINT WINAPI     DragQueryFileU(
    HDROP   hDrop,
    UINT    iFile,
    LPWSTR  lpwszFile,
    UINT    cch)
{
    PFDragQueryFileA        pfA=NULL;
    PFDragQueryFileW        pfW=NULL;
    HMODULE                 hModule=NULL; 
    UINT                    iReturn=0;

    LPSTR                   psz=NULL;


    //load the shell32.dll since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("shell32.dll")))
        return iReturn;


    if(FIsWinNT())
    {

        if(NULL != (pfW=(PFDragQueryFileW)GetProcAddress(hModule, "DragQueryFileW")))
        {
            iReturn=pfW(hDrop, iFile, lpwszFile, cch);
        }

        FreeLibrary(hModule);

        return iReturn;
    }

    //allocate memory
    if(0xFFFFFFFF != iFile)
    {
        if(lpwszFile)
        {
            //allocate a big enough buffer
            psz=(LPSTR)malloc(sizeof(WCHAR) * cch);
            if(NULL == psz)
                goto CLEANUP;
        }
    }

    if(NULL == (pfA=(PFDragQueryFileA)GetProcAddress(hModule, "DragQueryFileA")))
        goto CLEANUP;

    iReturn=pfA(hDrop, iFile, psz, cch);

    if(0 != iReturn)
    {
        if(0xFFFFFFFF != iFile)
        {
            if(lpwszFile && psz)
            {
                iReturn = MultiByteToWideChar(
                                    0,                      // codepage
                                    0,                      // dwFlags
                                    psz,
                                    iReturn+1,
                                    lpwszFile,
                                    cch);

                //we should return the # of characters excluding the NULL terminator
                if(0 != iReturn)
                    iReturn--;
            }
        }
    }


CLEANUP:

    if(psz)
        free(psz);

    return iReturn;

}

//-------------------------------------------------------------------------
//
//  CreatePropertySheetPageU
//
//      Notice: This function assumes that the LPCPROPSHEETPAGEW and 
//      LPCPROPSHEETPAGEA are equivalent.
//
//--------------------------------------------------------------------------
typedef   HPROPSHEETPAGE   (WINAPI *PFCreatePropertySheetPageA)(LPCPROPSHEETPAGEA);
typedef   HPROPSHEETPAGE   (WINAPI *PFCreatePropertySheetPageW)(LPCPROPSHEETPAGEW);

HPROPSHEETPAGE WINAPI CreatePropertySheetPageU(LPCPROPSHEETPAGEW    pPage)
{
    PFCreatePropertySheetPageA      pfA=NULL;
    PFCreatePropertySheetPageW      pfW=NULL;
    HMODULE                         hModule=NULL; 
    HPROPSHEETPAGE                  hPage=NULL;

    //load the comctl.32 since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("comctl32.dll")))
        return hPage;


    if(FIsWinNT())
    {

        if(NULL != (pfW=(PFCreatePropertySheetPageW)GetProcAddress(hModule, "CreatePropertySheetPageW")))
        {
            hPage=pfW(pPage);
        }

        FreeLibrary(hModule);

        return hPage;
    }


    if(NULL != (pfA=(PFCreatePropertySheetPageA)GetProcAddress(hModule, "CreatePropertySheetPageA")))
    {
        hPage=pfA((LPCPROPSHEETPAGEA)pPage);
    }

    FreeLibrary(hModule);

    return hPage;
}


BOOL WINAPI SetWindowText9x(
    HWND hWnd,	// handle of window or control
    LPCWSTR lpString 	// address of string
   ) {
    BYTE rgb1[_MAX_PATH];
    char *  szString = NULL;
    LONG    err = 0;

    if (lpString == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    if( MkMBStr(rgb1, _MAX_PATH, lpString, &szString) &&
        (szString != NULL)) {
        err = SetWindowTextA(
                    hWnd,
                    szString);
    }

    if (szString != NULL)
        FreeMBStr(rgb1, szString);

    return(err);
}

BOOL WINAPI SetWindowTextU(
    HWND hWnd,	// handle of window or control
    LPCWSTR lpString 	// address of string
   ) {
    
    if(FIsWinNT())
        return( SetWindowTextW(hWnd, lpString));
    else
        return( SetWindowText9x(hWnd, lpString));
}


int WINAPI GetWindowText9x(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   )
{
    LPSTR   psz;
    int     ret;

    psz = (LPSTR) malloc(nMaxCount);

    if (psz == NULL)
    {
        return (0);
    }   

    ret = GetWindowTextA(hWnd, psz, nMaxCount);

    if (ret != 0)
    {
        MultiByteToWideChar(0, 0, psz, -1, lpString, nMaxCount);
    }
    else
    {
        free(psz);
        return (0);
    }

    free(psz);

    return (ret);
}

int WINAPI GetWindowTextU(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   )
{
    if (FIsWinNT())
        return (GetWindowTextW(hWnd, lpString, nMaxCount));
    else
        return (GetWindowText9x(hWnd, lpString, nMaxCount));
    
}


UINT WINAPI GetDlgItemText9x(
    HWND hDlg,	// handle of dialog box
    int nIDDlgItem,	// identifier of control
    LPWSTR lpString,	// address of buffer for text
    int nMaxCount 	// maximum size of string
   ) {

    char *szBuffer;
    int     cchW;
    LONG    err;

    szBuffer = (char *) malloc(nMaxCount);
    if(!szBuffer)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return 0;
    }

    err = GetDlgItemTextA(
        hDlg,
        nIDDlgItem,
        szBuffer,
        nMaxCount);

    if (err != 0)
    {
        err = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            err+1,
                            lpString,
                            nMaxCount);
    }
    else if (nMaxCount >= 1)
    {
        lpString[0] = 0;
    }

    free(szBuffer);

    return(err);
}

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,	// handle of dialog box
    int nIDDlgItem,	// identifier of control
    LPWSTR lpString,	// address of buffer for text
    int nMaxCount 	// maximum size of string
   ) {

    if(FIsWinNT())
        return( GetDlgItemTextW(
            hDlg,
            nIDDlgItem,
            lpString,
            nMaxCount
            ));
    else
        return( GetDlgItemText9x(
            hDlg,
            nIDDlgItem,
            lpString,
            nMaxCount
            ));
}


BOOL WINAPI SetDlgItemText9x(
    HWND hDlg, 
    int nIDDlgItem, 
    LPCWSTR lpString 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    BOOL  fRet;
    
    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpString,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpString,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    fRet = SetDlgItemTextA(
                    hDlg,
                    nIDDlgItem,
                    szString
                    );
    
    free(szString);
        
    return (fRet);
}

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg, 
    int nIDDlgItem, 
    LPCWSTR lpString 
    )
{
    if(FIsWinNT()) 
        return(SetDlgItemTextW(
                    hDlg,
                    nIDDlgItem,
                    lpString
                    ));
    else
        return(SetDlgItemText9x(
                    hDlg,
                    nIDDlgItem,
                    lpString
                    ));
}


int WINAPI DialogBoxParam9x(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    int  iRet;
    
    //now, lpTemplateName can either be a WORD from MAKEINTRESOURCE(..)
    //or a NULL terminated string
    if (0xFFFF >= ((DWORD_PTR)lpTemplateName)) 
    {
        return(DialogBoxParamA(
                    hInstance,
                    (LPCSTR)lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
    }


    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    iRet = DialogBoxParamA(
                hInstance,
                szString,
                hWndParent,
                lpDialogFunc,
                dwInitParam
                );
    
    free(szString);
        
    return (iRet);
}

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam 
    )
{
    if(FIsWinNT()) 
        return(DialogBoxParamW(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
    else
        return(DialogBoxParam9x(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
}



int WINAPI DialogBox9x(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    int  iRet;
    
    //now, lpTemplateName can either be a WORD from MAKEINTRESOURCE(..)
    //or a NULL terminated string
    if (0xFFFF >= ((DWORD_PTR)lpTemplateName)) 
    {
        return(DialogBoxA(
                    hInstance,
                    (LPCSTR)lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
    }


    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    iRet = DialogBoxA(
                hInstance,
                szString,
                hWndParent,
                lpDialogFunc
                );
    
    free(szString);
        
    return (iRet);

}

int WINAPI DialogBoxU(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc 
    )
{
    if(FIsWinNT()) 
        return(DialogBoxW(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
    else
        return(DialogBox9x(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
}


int WINAPI MessageBox9x(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    ) {
    BYTE rgb1[_MAX_PATH];
    char *  szString1 = NULL;
    BYTE rgb2[_MAX_PATH];
    char *  szString2 = NULL;
    int    err;

    if (lpText == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    err = 0;
    if(MkMBStr(rgb1, _MAX_PATH, lpText, &szString1))
    {
        MkMBStr(rgb2, _MAX_PATH, lpCaption, &szString2);

        err = MessageBoxA(
				    hWnd,
				    szString1,
				    szString2,
				    uType);
    }
				    
    if (szString1 != NULL)
        FreeMBStr(rgb1, szString1);

    if (szString2 != NULL)
        FreeMBStr(rgb2, szString2);

    return(err);
}

int WINAPI MessageBoxU(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    ) {
    
    if(FIsWinNT())
        return( MessageBoxW(
				    hWnd,
				    lpText,
				    lpCaption,
				    uType));
    else
        return( MessageBox9x(
				    hWnd,
				    lpText,
				    lpCaption,
				    uType));
}


int WINAPI LCMapString9x(
    LCID Locale,	// locale identifier 
    DWORD dwMapFlags,	// mapping transformation type 
    LPCWSTR lpSrcStr,	// address of source string 
    int cchSrc,	// number of characters in source string 
    LPWSTR lpDestStr,	// address of destination buffer 
    int cchDest 	// size of destination buffer 
   ) {
    BYTE rgb1[_MAX_PATH];
    char *  szBuffer = NULL;
    LPSTR   szBuffer1 = NULL;
    int cbConverted;
    
    LONG    err = GetLastError();
    LONG    cb = 0;

    SetLastError(ERROR_OUTOFMEMORY);

    // translate lpSrcStr to src ANSI szBuffer
    if(MkMBStrEx(rgb1, _MAX_PATH, lpSrcStr, cchSrc, &szBuffer, &cbConverted) )
    {
        // Malloc the intermediate ANSI buf
	if( NULL != (szBuffer1 = (LPSTR) malloc(cchDest)) ) {

	    // do translation from szBuffer into lpDestStr
	    cb = LCMapStringA(
		Locale,
		dwMapFlags,
		szBuffer,
		cbConverted,
		szBuffer1,
		cchDest);
	}
    }

    // free src ANSI szBuffer, handles NULLs
    FreeMBStr(rgb1, szBuffer);

    if(cb != 0) {

	// translate resultant ANSI szBuffer1 to UNICODE
	cb = MultiByteToWideChar(
			    0,			    // codepage
			    0,			    // dwFlags
			    szBuffer1,		    // src (ANSI)
			    cb,		    // already incl NULL
			    lpDestStr,		    // dest (UNICODE)
			    cchDest);
    }

    if(szBuffer1 != NULL)
	free(szBuffer1);

    if(cb != 0)
	SetLastError(err);

    return(cb);
}

int WINAPI LCMapStringU(
    LCID Locale,	// locale identifier 
    DWORD dwMapFlags,	// mapping transformation type 
    LPCWSTR lpSrcStr,	// address of source string 
    int cchSrc,	// number of characters in source string 
    LPWSTR lpDestStr,	// address of destination buffer 
    int cchDest 	// size of destination buffer 
   ) {
    
    if(FIsWinNT())
        return( LCMapStringW(
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest));
    else
        return( LCMapString9x(
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest));
}


int WINAPI GetDateFormat9x( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpDate, 
    LPCWSTR lpFormat, 
    LPWSTR lpDateStr, 
    int cchDate
    )
{
    LPSTR szFormatString = NULL;
    LPSTR szDateString  = NULL;
    DWORD cbszFormatString = 0;
    DWORD cbszDateString = 0;
    int  iRet;
    
    if (lpFormat != NULL)
    {
        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL);
    
        if (cbszFormatString == 0)
        {
            return FALSE;
        }

        if (NULL == (szFormatString = (LPSTR) malloc(cbszFormatString)))
        {
            return FALSE;
        }

        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            szFormatString,
                            cbszFormatString,
                            NULL,
                            NULL);

        if (cbszFormatString == 0)
        {
            free(szFormatString);
            return FALSE;
        }
    }

    if (cchDate == 0)
    {
        iRet = GetDateFormatA( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    szFormatString, 
                    NULL, 
                    0
                    );
    }
    else
    {
        szDateString = (LPSTR) malloc(cchDate);
        if (szDateString == NULL)
        {
            if (szFormatString)
                free(szFormatString);
            return FALSE; 
        }

        iRet = GetDateFormatA( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    szFormatString, 
                    szDateString, 
                    cchDate
                    );

        MultiByteToWideChar(
                        0,
                        0,
                        szDateString,
                        -1,
                        lpDateStr,
                        cchDate
                        );
    }

    if (szFormatString)
        free(szFormatString);
    
    if (szDateString)
        free(szDateString);
        
    return (iRet);
}

int WINAPI GetDateFormatU( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpDate, 
    LPCWSTR lpFormat, 
    LPWSTR lpDateStr, 
    int cchDate
    )
{
    if(FIsWinNT()) 
        return(GetDateFormatW( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    lpFormat, 
                    lpDateStr, 
                    cchDate
                    ));
    else
        return(GetDateFormat9x( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    lpFormat, 
                    lpDateStr, 
                    cchDate
                    ));
}


int WINAPI GetTimeFormat9x( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpTime, 
    LPCWSTR lpFormat, 
    LPWSTR lpTimeStr, 
    int cchTime 
    )
{
    LPSTR szFormatString = NULL;
    LPSTR szTimeString  = NULL;
    DWORD cbszFormatString = 0;
    DWORD cbszTimeString = 0;
    int  iRet;
    
    if (lpFormat != NULL)
    {
        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL);
    
        if (cbszFormatString == 0)
        {
            return FALSE;
        }

        if (NULL == (szFormatString = (LPSTR) malloc(cbszFormatString)))
        {
            return FALSE;
        }

        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            szFormatString,
                            cbszFormatString,
                            NULL,
                            NULL);

        if (cbszFormatString == 0)
        {
            free(szFormatString);
            return FALSE;
        }
    }

    if (cchTime == 0)
    {
        iRet = GetTimeFormatA( 
                        Locale, 
                        dwFlags, 
                        lpTime, 
                        szFormatString, 
                        NULL, 
                        0
                        );
    }
    else
    {
        szTimeString = (LPSTR) malloc(cchTime);
        if (szTimeString == NULL)
        {
            if (szFormatString)
                free(szFormatString);
            return FALSE; 
        }

        iRet = GetTimeFormatA( 
                        Locale, 
                        dwFlags, 
                        lpTime, 
                        szFormatString, 
                        szTimeString, 
                        cchTime
                        );

        MultiByteToWideChar(
                        0,
                        0,
                        szTimeString,
                        -1,
                        lpTimeStr,
                        cchTime
                        );
    }

    if (szFormatString != NULL)
        free(szFormatString);

    if (szTimeString != NULL)
        free(szTimeString);
        
    return (iRet);
}

int WINAPI GetTimeFormatU( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpTime, 
    LPCWSTR lpFormat, 
    LPWSTR lpTimeStr, 
    int cchTime 
    )
{
    if(FIsWinNT()) 
        return(GetTimeFormatW( 
                    Locale, 
                    dwFlags, 
                    lpTime, 
                    lpFormat, 
                    lpTimeStr, 
                    cchTime
                    ));
    else
        return(GetTimeFormat9x( 
                    Locale, 
                    dwFlags, 
                    lpTime, 
                    lpFormat, 
                    lpTimeStr, 
                    cchTime
                    ));
}


BOOL WINAPI WinHelp9x( 
    HWND hWndMain, 
    LPCWSTR lpszHelp, 
    UINT uCommand, 
    DWORD dwData 
    )
{
    LPSTR szHelpString = NULL;
    DWORD cbszHelpString = 0;
    BOOL  bRet;
    
    cbszHelpString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpszHelp,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszHelpString == 0)
    {
        return FALSE;
    }

    if (NULL == (szHelpString = (LPSTR) malloc(cbszHelpString)))
    {
        return FALSE;
    }

    cbszHelpString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpszHelp,
                        -1,
                        szHelpString,
                        cbszHelpString,
                        NULL,
                        NULL);

    if (cbszHelpString == 0)
    {
        free(szHelpString);
        return FALSE;
    }

    bRet = WinHelpA( 
                hWndMain, 
                szHelpString, 
                uCommand, 
                dwData 
                );
    
    free(szHelpString);
        
    return (bRet);
}

BOOL WINAPI WinHelpU( 
    HWND hWndMain, 
    LPCWSTR lpszHelp, 
    UINT uCommand, 
    DWORD dwData 
    )
{
    if(FIsWinNT()) 
        return(WinHelpW( 
                    hWndMain, 
                    lpszHelp, 
                    uCommand, 
                    dwData 
                    ));
    else
        return(WinHelp9x( 
                    hWndMain, 
                    lpszHelp, 
                    uCommand, 
                    dwData 
                    ));
}


LRESULT WINAPI SendMessageU( 
    HWND hWnd, 
    UINT Msg, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    if(FIsWinNT()) 
    {
        return(SendMessageW( 
                    hWnd, 
                    Msg, 
                    wParam, 
                    lParam 
                    ));
    }
    else 
    {
        return(SendMessageA( 
                    hWnd, 
                    Msg, 
                    wParam, 
                    lParam 
                    ));
    }
}


LONG 
WINAPI
SendDlgItemMessageU( 
    HWND hDlg, 
    int nIDDlgItem, 
    UINT Msg, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    LONG  lRet;

    // only do string conversion for string type messages
    if (Msg != LB_ADDSTRING && 
        Msg != CB_INSERTSTRING &&
        Msg != WM_SETTEXT &&
        Msg != CB_FINDSTRINGEXACT &&
        Msg != CB_ADDSTRING)
    {
        return(SendDlgItemMessageA( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    lParam
                    ));
    }

    if(FIsWinNT()) 
    {
        return(SendDlgItemMessageW( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    lParam
                    ));
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        (LPWSTR) lParam,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return LB_ERR;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return LB_ERR;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        (LPWSTR) lParam,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return LB_ERR;
    }

    lRet = SendDlgItemMessageA( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    (LPARAM) szString
                    );
    
    free(szString);
        
    return (lRet);
}

LPWSTR 
WINAPI
GetCommandLineU(void)
{
	LPSTR szCmdLine = NULL;
	LPWSTR wszCmdLine = NULL;

	if (FIsWinNT())
		return (GetCommandLineW());

	szCmdLine = GetCommandLineA();

	wszCmdLine = MkWStr(szCmdLine);
	return (wszCmdLine);
}

BOOL 
WINAPI
IsBadStringPtr9x(IN LPWSTR lpsz, UINT ucchMax)
{
	BYTE rgb[2048];
	char *sz = NULL;
	BOOL bResult = FALSE;

	if (MkMBStr(rgb, _MAX_PATH, lpsz, &sz))
		bResult = IsBadStringPtrA(sz, ucchMax);

	FreeMBStr(rgb, sz);

	return (bResult);
}

BOOL 
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax)
{
	if (FIsWinNT())
		return (IsBadStringPtrW(lpsz, ucchMax));
    else
        return (IsBadStringPtr9x(lpsz, ucchMax));
}


void 
WINAPI
OutputDebugString9x(IN LPWSTR lpwsz)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;

    if (MkMBStr(rgb, _MAX_PATH, lpwsz, &sz))
		OutputDebugStringA(sz);

	FreeMBStr(rgb, sz);

	return;
}

void 
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz)
{
	//DSIE: bug 171074.
    if (!lpwsz)
        return;

	if (FIsWinNT())
	    OutputDebugStringW(lpwsz);
	else
        OutputDebugString9x(lpwsz);
}

int 
WINAPI
DrawText9x(
    HDC     hDC, 
    LPCWSTR lpString, 
    int     nCount, 
    LPRECT  lpRect, 
    UINT    uFormat  
)
{
    LPSTR   pszText;
    int     ret;

    if (NULL == (pszText = (LPSTR) malloc(wcslen(lpString)+1)))
    {
	SetLastError(ERROR_OUTOFMEMORY);
	return(0);
    }

    WideCharToMultiByte(
            0,
            0, 
            lpString,
            -1,
            pszText,
            wcslen(lpString)+1,
            NULL,
            NULL);

    ret = DrawTextA(hDC, pszText, nCount, lpRect, uFormat);

    free(pszText);
    return ret;
}

int 
WINAPI
DrawTextU(
    HDC     hDC, 
    LPCWSTR lpString, 
    int     nCount, 
    LPRECT  lpRect, 
    UINT    uFormat  
)
{
    if (FIsWinNT())
    	return (DrawTextW(hDC, lpString, nCount, lpRect, uFormat));
	else
        return (DrawText9x(hDC, lpString, nCount, lpRect, uFormat));
}


void CleanUpOpenFileNameA(LPOPENFILENAMEA pOpenFileNameA)
{
    if (pOpenFileNameA->lpstrFilter != NULL)
        free((void *) pOpenFileNameA->lpstrFilter);

    if (pOpenFileNameA->lpstrCustomFilter != NULL)
        free((void *) pOpenFileNameA->lpstrCustomFilter);

    if (pOpenFileNameA->lpstrFile != NULL)
        free((void *) pOpenFileNameA->lpstrFile);

    if (pOpenFileNameA->lpstrFileTitle)
        free((void *) pOpenFileNameA->lpstrFileTitle);

    if (pOpenFileNameA->lpstrInitialDir)
        free((void *) pOpenFileNameA->lpstrInitialDir);

    if (pOpenFileNameA->lpstrTitle)
        free((void *) pOpenFileNameA->lpstrTitle);

    if (pOpenFileNameA->lpstrDefExt)
        free((void *) pOpenFileNameA->lpstrDefExt);
}

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL ConvertToOpenFileNameA(LPOPENFILENAMEW pOpenFileNameW, LPOPENFILENAMEA pOpenFileNameA)
{
    int     i;
    int     cb, cb1, cb2;
    LPSTR   pszTemp;
    BOOL    fResult = TRUE;
    
    memset(pOpenFileNameA, 0, sizeof(OPENFILENAMEA));
    pOpenFileNameA->lStructSize = offsetof(OPENFILENAMEA, lpTemplateName) + sizeof(LPCSTR);
    pOpenFileNameA->hwndOwner = pOpenFileNameW->hwndOwner;
    pOpenFileNameA->hInstance = pOpenFileNameW->hInstance;
    
    //
    // the lpstrFilter field is a list of pairs of NULL terminated strings
    //
    if (pOpenFileNameW->lpstrFilter != NULL)
    {
        i = 0;
        cb = 0;
        while (pOpenFileNameW->lpstrFilter[i] != L'\0')
        {
            cb += WideCharToMultiByte(
                    0,
                    0, 
                    &(pOpenFileNameW->lpstrFilter[i]),
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
            i += wcslen(&(pOpenFileNameW->lpstrFilter[i])) + 1;
        }

        pOpenFileNameA->lpstrFilter = (LPSTR) malloc(cb + 1);
        if (pOpenFileNameA->lpstrFilter == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                    0,
                    0, 
                    pOpenFileNameW->lpstrFilter,
                    i + 1,
                    (LPSTR)pOpenFileNameA->lpstrFilter,
                    cb + 1,
                    NULL,
                    NULL);
    }
    else
    {
        pOpenFileNameA->lpstrFilter = NULL;
    }

    //
    // the lpstrCustomFilter field is a pair of NULL terminated strings
    //
    if (pOpenFileNameW->lpstrCustomFilter != NULL)
    {
        cb1 = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrCustomFilter,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        cb2 = WideCharToMultiByte(
                0,
                0, 
                &(pOpenFileNameW->lpstrCustomFilter[wcslen(pOpenFileNameW->lpstrCustomFilter)+1]),
                -1,
                NULL,
                0,
                NULL,
                NULL);
        
        pOpenFileNameA->lpstrCustomFilter = (LPSTR) malloc(cb1 + cb2);
        if (pOpenFileNameA->lpstrCustomFilter == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrCustomFilter,
                -1,
                pOpenFileNameA->lpstrCustomFilter,
                cb1,
                NULL,
                NULL);
        WideCharToMultiByte(
                0,
                0, 
                &(pOpenFileNameW->lpstrCustomFilter[wcslen(pOpenFileNameW->lpstrCustomFilter)+1]),
                -1,
                &(pOpenFileNameA->lpstrCustomFilter[cb1]),
                cb2,
                NULL,
                NULL);

        pOpenFileNameA->nMaxCustFilter = cb1 + cb2;
    }
    else
    {
        pOpenFileNameA->lpstrCustomFilter = NULL;
        pOpenFileNameA->nMaxCustFilter = 0;
    }
    
    pOpenFileNameA->nFilterIndex = pOpenFileNameW->nFilterIndex;
    
    pOpenFileNameA->lpstrFile = (LPSTR) malloc(pOpenFileNameW->nMaxFile);
    if (pOpenFileNameA->lpstrFile == NULL)
    {
        goto OutOfMemory;
    }
    WideCharToMultiByte(
            0,
            0, 
            pOpenFileNameW->lpstrFile,
            -1,
            pOpenFileNameA->lpstrFile,
            pOpenFileNameW->nMaxFile,
            NULL,
            NULL);
    pOpenFileNameA->nMaxFile = pOpenFileNameW->nMaxFile;

    if (pOpenFileNameW->lpstrFileTitle != NULL)
    {
        pOpenFileNameA->lpstrFileTitle = (LPSTR) malloc(pOpenFileNameW->nMaxFileTitle);
        if (pOpenFileNameA->lpstrFileTitle == NULL)
        {
            goto OutOfMemory;
        }
    }
    else
    {
        pOpenFileNameA->lpstrFileTitle = NULL;
    }
    pOpenFileNameA->nMaxFileTitle = pOpenFileNameW->nMaxFileTitle;

    if (pOpenFileNameW->lpstrInitialDir != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrInitialDir,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrInitialDir = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrInitialDir == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrInitialDir,
                -1,
                (LPSTR) pOpenFileNameA->lpstrInitialDir,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrInitialDir = NULL;
    }

    if (pOpenFileNameW->lpstrTitle != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrTitle,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrTitle = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrTitle == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrTitle,
                -1,
                (LPSTR) pOpenFileNameA->lpstrTitle,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrTitle = NULL;
    }

    pOpenFileNameA->Flags = pOpenFileNameW->Flags;
    pOpenFileNameA->nFileOffset = 0;
    pOpenFileNameA->nFileExtension = 0;

    if (pOpenFileNameW->lpstrDefExt != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrDefExt,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrDefExt = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrDefExt == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrDefExt,
                -1,
                (LPSTR) pOpenFileNameA->lpstrDefExt,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrDefExt = NULL;
    }

    pOpenFileNameA->lCustData = pOpenFileNameW->lCustData;
    pOpenFileNameA->lpfnHook = pOpenFileNameW->lpfnHook;
    pOpenFileNameA->lpTemplateName = NULL;


    goto Return;

OutOfMemory:
    
    CleanUpOpenFileNameA(pOpenFileNameA);
    SetLastError(E_OUTOFMEMORY);
    fResult = FALSE;

Return:
    
    return (fResult);
}


typedef BOOL (WINAPI * PFNCGETSAVEFILENAMEW)(LPOPENFILENAMEW pOpenFileName);
typedef BOOL (WINAPI * PFNCGETSAVEFILENAMEA)(LPOPENFILENAMEA pOpenFileName);

BOOL 
GetSaveFileName9x(
    LPOPENFILENAMEW pOpenFileName
)
{
    OPENFILENAMEA           OpenFileNameA;
    HINSTANCE               h_module;
    PFNCGETSAVEFILENAMEA    pfncGetSaveFileNameA;
    BOOL                    fRet;

    h_module = LoadLibraryA("comdlg32.dll");
    if (h_module == NULL)
    {
        return FALSE;
    }
        
    if (!ConvertToOpenFileNameA(pOpenFileName, &OpenFileNameA))
    {
        return FALSE;
    }

    pfncGetSaveFileNameA = (PFNCGETSAVEFILENAMEA) GetProcAddress(h_module, "GetSaveFileNameA");
    if (pfncGetSaveFileNameA == NULL)
    {
        CleanUpOpenFileNameA(&OpenFileNameA);
        return FALSE;
    }
    fRet = pfncGetSaveFileNameA(&OpenFileNameA);
    DWORD dwErr = GetLastError();
    
    if (fRet)
    {
        MultiByteToWideChar(
                0,
                0,
                OpenFileNameA.lpstrFile,
                -1,
                pOpenFileName->lpstrFile,
                pOpenFileName->nMaxFile);
    }

    CleanUpOpenFileNameA(&OpenFileNameA);


    FreeLibrary(h_module);
    return fRet;
}

BOOL 
GetSaveFileNameU(
    LPOPENFILENAMEW pOpenFileName
)
{
    HINSTANCE               h_module;
    PFNCGETSAVEFILENAMEW    pfncGetSaveFileNameW;
    BOOL                    fRet;
    
    if (FIsWinNT())
	{
		h_module = LoadLibraryA("comdlg32.dll");
        if (h_module == NULL)
        {
            return FALSE;
        }

        pfncGetSaveFileNameW = (PFNCGETSAVEFILENAMEW) GetProcAddress(h_module, "GetSaveFileNameW");
        if (pfncGetSaveFileNameW == NULL)
        {
            fRet = FALSE;
        }
        else
        {
            fRet = pfncGetSaveFileNameW(pOpenFileName);
        }

        FreeLibrary(h_module);
	}
    else
    {
        fRet = GetSaveFileName9x(pOpenFileName);
    }

    return fRet;
}


typedef BOOL (WINAPI * PFNCGETOPENFILENAMEW)(LPOPENFILENAMEW pOpenFileName);
typedef BOOL (WINAPI * PFNCGETOPENFILENAMEA)(LPOPENFILENAMEA pOpenFileName);

BOOL 
GetOpenFileName9x(
    LPOPENFILENAMEW pOpenFileName
)
{
    OPENFILENAMEA           OpenFileNameA;
    HINSTANCE               h_module;
    PFNCGETOPENFILENAMEA    pfncGetOpenFileNameA;
    BOOL                    fRet;

    h_module = LoadLibraryA("comdlg32.dll");
    if (h_module == NULL)
    {
        return FALSE;
    }
    
    if (!ConvertToOpenFileNameA(pOpenFileName, &OpenFileNameA))
    {
        return FALSE;
    }

    pfncGetOpenFileNameA = (PFNCGETOPENFILENAMEA) GetProcAddress(h_module, "GetOpenFileNameA");
    if (pfncGetOpenFileNameA == NULL)
    {
        return FALSE;
    }
    fRet = pfncGetOpenFileNameA(&OpenFileNameA);
    DWORD dwErr = GetLastError();
    
    MultiByteToWideChar(
            0,
            0,
            OpenFileNameA.lpstrFile,
            -1,
            pOpenFileName->lpstrFile,
            pOpenFileName->nMaxFile);

    CleanUpOpenFileNameA(&OpenFileNameA);

    FreeLibrary(h_module);
    return fRet;
}

BOOL 
GetOpenFileNameU(
    LPOPENFILENAMEW pOpenFileName
)
{
    HINSTANCE               h_module;
    PFNCGETOPENFILENAMEW    pfncGetOpenFileNameW;
    BOOL                    fRet;

    if (FIsWinNT())
	{
        h_module = LoadLibraryA("comdlg32.dll");
        if (h_module == NULL)
        {
            return FALSE;
        }

		pfncGetOpenFileNameW = (PFNCGETOPENFILENAMEW) GetProcAddress(h_module, "GetOpenFileNameW");
        if (pfncGetOpenFileNameW == NULL)
        {
            fRet = FALSE;
        }
        else
        {
            fRet = pfncGetOpenFileNameW(pOpenFileName);
        }

        FreeLibrary(h_module);
	}
    else
    {
        fRet = GetOpenFileName9x(pOpenFileName);
    }

    return fRet;
}



#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\common\waitsvc\waitsvc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wiatsvc.cpp
//
//  Contents:   wait for service to start
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "errlog.h"
#include "waitsvc.h"

#include <assert.h>

#define WAITSVC_LOGERR_LASTERR(x)   if (x) \
                                    { \
                                        ErrLog_LogError(NULL, \
                                                ERRLOG_CLIENT_ID_WAITSVC, \
                                                __LINE__, \
                                                0, \
                                                FALSE, \
                                                FALSE); \
                                    }

BOOL
WaitForCryptService(
    IN      LPWSTR  pwszService,
    IN      BOOL    *pfDone,
    IN      BOOL    fLogErrors
    )
/*++

    This routine determines if the protected storage service is
    pending start.  If the service is pending start, this routine
    waits until the service is running before returning to the
    caller.

    If the Service is running when this routine returns, the
    return value is TRUE.

    If the service is not running, or an error occurred, the
    return value is FALSE.

    When the return value is FALSE, the value is only advisory, and may not
    indicate the current state of the service.  The reasoning here is that
    if the service did not start the first time this call is made, is will
    not likely be running the next time around, and hence we avoid checking
    on subsequent calls.

    For current situations, the caller should ignore the return value; when
    the return value is FALSE, the caller should just try making the call
    into the service.  If the service is still down, the call into it will fail
    appropriately.

--*/
{
    SC_HANDLE   schSCM;
    SC_HANDLE   schService          = NULL;
    DWORD       dwStopCount         = 0;
    static BOOL fSuccess            = FALSE;
    BOOL        fCheckDisabled      = TRUE;
    HANDLE      hToken              = NULL;
    BOOL        fSystemAccount      = FALSE;
    BOOL        fStartServiceCalled = FALSE;
    DWORD       dwErr               = ERROR_SUCCESS;

    if( !FIsWinNT() )
        return TRUE;

    if( *pfDone )
        return fSuccess;

    schSCM = OpenSCManagerW( NULL, NULL, SC_MANAGER_CONNECT );
    if(schSCM == NULL)
    {
        assert(0);
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        return FALSE;
    }

    //
    // open the protected storage service so we can query it's
    // current state.
    //

    schService = OpenServiceW(schSCM, pwszService, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);
    if(schService == NULL)
    {
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        fCheckDisabled = FALSE;
        schService = OpenServiceW(schSCM, pwszService, SERVICE_QUERY_STATUS);
    }

    if(schService == NULL)
    {
        assert(0);
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        goto cleanup;
    }

    //
    // check if the service is disabled.  If it is, bailout.
    //

    if( fCheckDisabled ) {
        LPQUERY_SERVICE_CONFIG pServiceConfig;
        BYTE TempBuffer[ 1024 ];
        DWORD cbServiceConfig;

        pServiceConfig = (LPQUERY_SERVICE_CONFIG)TempBuffer;
        cbServiceConfig = sizeof(TempBuffer);

        if(QueryServiceConfig( schService, pServiceConfig, cbServiceConfig, &cbServiceConfig )) {

            if( pServiceConfig->dwStartType == SERVICE_DISABLED )
            {
                SetLastError(ERROR_SERVICE_DISABLED);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }
        }
        else
        {
            assert(0);
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            goto cleanup;
        }
    }


    //
    // check if calling process is SYSTEM account.
    // if it is, use a larger timeout value.
    //

    if( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) ) {

        do {

            BYTE FastBuffer[ 256 ];
            PTOKEN_USER TokenInformation;
            DWORD cbTokenInformation;
            SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
            PSID psidLocalSystem;

            TokenInformation = (PTOKEN_USER)FastBuffer;
            cbTokenInformation = sizeof(FastBuffer);

            if(!GetTokenInformation(
                                hToken,
                                TokenUser,
                                TokenInformation,
                                cbTokenInformation,
                                &cbTokenInformation
                                ))
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                break;
            }

            if(!AllocateAndInitializeSid(
                                &sia,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &psidLocalSystem
                                ))
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                break;
            }

            fSystemAccount = EqualSid(
                                psidLocalSystem,
                                TokenInformation->User.Sid
                                );

            FreeSid( psidLocalSystem );

        } while (FALSE);

        CloseHandle( hToken );
    }



//
// number of seconds to Sleep per loop interation.
//

#define SLEEP_SECONDS (5)


    if( fSystemAccount ) {

        //
        // 15 minutes for SYSTEM account.
        //

        dwStopCount = 900 / SLEEP_SECONDS;

    } else {

        //
        //
        // loop checking the service status every 5 seconds, for up to 2 minutes
        // total (120 seconds, 5*24=120)
        //

        dwStopCount = 120 / SLEEP_SECONDS;
    }


    for( ; dwStopCount != 0 ; dwStopCount--, Sleep(SLEEP_SECONDS*1000) ) {
        SERVICE_STATUS sServiceStatus;
        DWORD dwWaitForStatus = 0;

        //
        // find out current service status
        //

        if(!QueryServiceStatus( schService, &sServiceStatus ))
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            break;
        }

        //
        // if service is running, indicate success
        //

        if( sServiceStatus.dwCurrentState == SERVICE_RUNNING ) {

            if (fStartServiceCalled)
            {
                ErrLog_LogString(
                        NULL,
                        L"WAITSVC: Service is running: ",
                        pwszService,
                        TRUE);
            }

            fSuccess = TRUE;
            break;
        }


        if( sServiceStatus.dwCurrentState == SERVICE_STOP_PENDING )
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            // Wait until stopped
            continue;
        }

        if( sServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING )
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            // Wait until paused
            continue;
        }

        //
        // if start pending, wait and re-query.
        //

        if( sServiceStatus.dwCurrentState == SERVICE_START_PENDING )
        {
            // Wait until started
            continue;
        }

        if(SERVICE_STOPPED == sServiceStatus.dwCurrentState)
        {
            // Attempt to start the service


            SC_HANDLE schManualStartService = NULL;
            DWORD dwError  = ERROR_SUCCESS;

            // The service is manual start
            // so attempt to start it.

            schManualStartService = OpenServiceW(schSCM,
                                                 pwszService,
                                                  SERVICE_START);
            if(NULL == schManualStartService)
            {
                assert(0);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }


            ErrLog_LogString(
                    NULL,
                    L"WAITSVC: Calling StartService(): ",
                    pwszService,
                    TRUE);
            fStartServiceCalled = TRUE;


            if(!StartService(schManualStartService, 0, NULL))
            {
                dwError  = GetLastError();
            }
            if(ERROR_SERVICE_ALREADY_RUNNING == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            CloseServiceHandle(schManualStartService);
            if(ERROR_SUCCESS != dwError)
            {
                assert(0);
                SetLastError(dwError);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }
            continue;

        }

        if(SERVICE_PAUSED == sServiceStatus.dwCurrentState)
        {
            // Attempt to start the service


            SC_HANDLE schManualStartService = NULL;
            DWORD dwError  = ERROR_SUCCESS;

            // The service is manual start
            // so attempt to start it.

            schManualStartService = OpenServiceW(schSCM,
                                                 pwszService,
                                                  SERVICE_PAUSE_CONTINUE);
            if(NULL == schManualStartService)
            {
                assert(0);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }


            if(!ControlService(schManualStartService, SERVICE_CONTROL_CONTINUE, &sServiceStatus))
            {
                dwError  = GetLastError();

            }
            if(ERROR_SERVICE_ALREADY_RUNNING == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            CloseServiceHandle(schManualStartService);
            if(ERROR_SUCCESS != dwError)
            {
                assert(0);
                SetLastError(dwError);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }

            continue;

        }


        //
        // bail out on any other dwCurrentState
        // eg: service stopped, error condition, etc.
        //

        break;
    }

    *pfDone = TRUE;

cleanup:

    dwErr = GetLastError();

    if(schService)
        CloseServiceHandle(schService);

    CloseServiceHandle(schSCM);

    SetLastError(dwErr);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\cryptsvc\catdbsvc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    catdbsvc.cpp

Abstract:

    This module contains routines associated with the service
    side of the catalog database

Author:

    Reid Kuhn (reidk)     19-Nov-97

--*/

/*

This comment section gives a picture of an example catalog database,
with example catalog files added and the resulting database tables.
The database schema can be seen clearly by looking at the picture of
the database tables.  This comment section also contains psuedo code
for the add catalog algorithm.


Catalogs added to the catalog database are stored in the FILE SYSTEM
--------------------------------------------------------------------

            --------    --------    --------    --------    --------    --------
Catname:    | CatA |    | CatB |    | CatC |    | CatD |    | CatE |    | CatF |
            --------    --------    --------    --------    --------    --------
HashList:   | 111  |    | 111  |    | 444  |    | 333  |    | 333  |    | 555  |
            | 222  |    | 222  |    |      |    |      |    | 555  |    |      |
            | 333  |    |      |    |      |    |      |    |      |    |      |
            --------    --------    --------    --------    --------    --------


Resulting Database Tables (above catalogs where added in order)
--------------------------------------------------------------------

    HashCatNameTable
    ----------------------------------
    | HashCol   | CatNameListCol     |
    |-----------|--------------------|
    | 111       | CatA - CatB        |
    | 222       | CatA - CatB        |
    | 333       | CatA - CatD - CatE |
    | 444       | CatC               |
    | 555       | CatE - CatF        |
    ----------------------------------

    CatNameBuddyTable
    ---------------------------------------------
    | CatNameCol    | BuddyListCol              |
    ---------------------------------------------
    | CatA          | CatB - CatD - CatE        |
    | CatB          | CatA                      |
    | CatD          | CatA - CatB - CatE        |
    | CatE          | CatA - CatB - CatD - CatF |
    | CatF          | CatE - CatA - CatB - CatD |
    ---------------------------------------------



Add Catalog Algorithm
---------------------

AddCat(<CatToAdd>)
{
    For each hash <i> contained in catalog <CatToAdd>
    {
        if (<i> is not contained in HashCol of HashCatNameTable)
        {
            add row to HashCatNameTable with <i> in HashCol and <CatToAdd> in CatNameListCol
        }
        else
        {
            create row in CatNameBuddyTable with <CatToAdd> in CatNameCol

            for each CatName <CatNameIn-CatNameListCol> contained in <i>'s CatNameListCol
            {
                if (<CatNameIn-CatNameListCol> is not contained in CatNameCol of CatNameBuddyTable
                {
                    create row in CatNameBuddyTable with <CatNameIn-CatNameListCol> in CatNameCol
                }

                add <CatNameIn-CatNameListCol> to <CatToAdd>'s BuddyListCol

                for each CatName <CatNameIn-BuddyListCol> contained in <CatNameIn-CatNameListCol>'s BuddyListCol - (may be empty)
                {
                    add <CatNameIn-BuddyListCol> to <CatToAdd>'s BuddyListCol
                }

                add <CatToAdd> to <CatNameIn-CatNameListCol>'s BuddyListCol
            }

            add <CatToAdd> to <i>'s CatNameListCol
        }
    }
}

*/

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <dbgdef.h>
#include <esent.h>
#include <assert.h>
#include <stdio.h>

#include "catdb.h" // header file generated by MIDL compiler
#include "dbutils.h"
#include "voidlist.h"
#include "catutil.h"
#include "resource.h"
#include "errlog.h"
#include "mscat.h"
#include "keysvr.h"
#include "cryptmsg.h"


#define CATDB_MAX_CATNAME_LENGTH    255

#define WSZ_REG_TEMP_FILES_KEY              L"Software\\Microsoft\\Cryptography\\CatDBTempFiles"
#define WSZ_REG_CATALOGDB_VALUES            L"Software\\Microsoft\\Cryptography\\CatalogDB"
#define WSZ_REG_CALLBACK_TIMER              L"CallbackTime"
#define WSZ_REG_DATABASE_TIMEOUT            L"DatabaseTimeout"

#define SZ_CATALOG_FILE_BASE_DIRECTORY     "CatRoot"
#define WSZ_CATALOG_FILE_BASE_DIRECTORY     L"CatRoot"
#define SZ_DATABASE_FILE_BASE_DIRECTORY     "CatRoot2"
#define WSZ_DATABASE_FILE_BASE_DIRECTORY    L"CatRoot2"

#define SZ_DBFILE_NAME                      "catdb"
#define WSZ_DBFILE_NAME                      L"catdb"
#define SZ_CATALOG_DATABASE                 "Catalog Database"

#define WSZ_TIME_STAMP_FILE                  L"TimeStamp"

#define CATDBSVC_LOGERR_LASTERR()           ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBSVC_SETERR_LOG_RETURN(x, y)    SetLastError(x); \
                                            ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE); \
                                            goto y;

#define CATDBSVC_LOGERR(x)                  ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            x, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBSVC_LOGWARN(x)                 ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            x, \
                                                            TRUE, \
                                                            FALSE);

#define ALLOCATION_BLOCK_SIZE  8

typedef struct _JET_DB_STRUCT
{
    LPSTR           pszDBFileName;

    JET_SESID       JetSesID;
    JET_DBID        JetDBID;

    // Hash-CatName Table
    JET_TABLEID     JetHashCatNameTableID;
    JET_COLUMNID    JetHashCatNameTable_HashColumnID;
    JET_COLUMNID    JetHashCatNameTable_CatNameColumnID;

    // CatName Buddy Table
    JET_TABLEID     JetCatNameBuddyTableID;
    JET_COLUMNID    JetCatNameBuddyTable_CatNameColumnID;
    JET_COLUMNID    JetCatNameBuddyTable_BuddyColumnID;

} JET_DB_STRUCT, *PJET_DB_STRUCT;

typedef struct _CATALOG_DIR_CACHE_STRUCT
{
    JET_DB_STRUCT   JetDBStruct;
    LPWSTR          pwszSubSysGUID;
    HANDLE          hDBNotInUse;
    BOOL            fReadOnly;
    DWORD           dwTimeLastTouched;

} CATALOG_DIR_CACHE_STRUCT, *PCATALOG_DIR_CACHE_STRUCT;

typedef struct _NOTIFICATION_STRUCT
{
    DWORD   ProcessID;
    HANDLE  hClientProcess;
    HANDLE  hRegisterWaitFor;
    HANDLE  hNotificationHandle;
    HANDLE  hDuplicatedNotificationHandle;
    LONG    lNotificationID;

} NOTIFICATION_STRUCT, *PNOTIFICATION_STRUCT;


//
// Global variables
//
extern HINSTANCE            g_hInst;
BOOL                        g_fDBSvcInitialized                 = FALSE;
CRITICAL_SECTION            g_CatDBAddDeleteCS;
CRITICAL_SECTION            g_CatDBRegisterNotifyCS;
CRITICAL_SECTION            g_CatDirCashCS;
CRITICAL_SECTION            g_CatClientCountCS;
CRITICAL_SECTION            g_InitializeJetCS;
CRITICAL_SECTION            g_WaitOrTimerCallbackCS;
LONG                        g_lOpenedDBCount                    = 0;
BOOL                        g_fJetInitialized                   = FALSE;
JET_INSTANCE                g_JetInstance                       = 0;
NOTIFICATION_STRUCT         *g_rgNotificationStructs            = NULL;
DWORD                       g_NumNotificationStructs            = 0;
LIST                        g_CatalogDBCacheList;
HANDLE                      g_hCatalogCacheCallbackEvent        = NULL;
BOOL                        g_fShuttingDown                     = FALSE;
DWORD                       g_dwClientCount                     = 0;
LONG                        g_lNotificationID                   = 0;
LPWSTR                      g_pwszCatalogFileBaseDirectory      = NULL;
LPWSTR                      g_pwszDatabaseFileBaseDirectory     = NULL;
DWORD                       g_dwCatalogDatabaseCacheTimeout     = (1000 * 60); // default one minute
DWORD                       g_dwCatalogDatabaseCacheCallbackTime= (1000 * 60 * 5); // default five minutes
HANDLE                      g_hRegisterWaitForServiceShutdown   = NULL;
HANDLE                      g_hNotFrozen                        = NULL;


//
// Forward declarations
//

//
// General supporting DB file functions
//

BOOL
_CatDBClientEnter(void);

void
_CatDBClientExit(void);

void
_CatDBTouchTimeStampFile(
    LPCWSTR             pwszSubSysGUID);

BOOL
_CatDBInitializeJet(
    BOOL                fInRecursiveCall);

BOOL
_CatDBTermJet();

BOOL
_CatDBAcquireOpenDatabaseFromCache(
    PJET_DB_STRUCT      *ppJetDBStruct,
    LPCWSTR             pwszSubSysGUID,
    BOOL                fReadOnly,
    BOOL                fInRecursiveCall
    );

BOOL
_CatDBReleaseDatabaseToCache(
    PJET_DB_STRUCT      pJetDBStruct
    );

BOOL
_CatDBCloseCachedDatabases(
    BOOL fForceClose);

VOID CALLBACK
_CatDBWaitOrTimerCallback(
    PVOID lpParameter,
    BOOLEAN fTimedOut
    );


//
// Supporting functions for s_SSCatDBAddCatalog
//
DWORD _CatDBAddCatalog(
    handle_t            h,
    DWORD               dwFlags,
    LPCWSTR             pwszSubSysGUID,
    LPCWSTR             pwszCatalogFile,
    LPCWSTR             pwszCatName,
    BOOL                fInRecursiveCall,
    LPWSTR __RPC_FAR    *ppwszCatalogNameUsed);

BOOL
_CatDBAddCatalogEntriesToDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    PCCTL_CONTEXT       pCTLContext,
    LPWSTR              pwszNewCatalogName
    );

BOOL
_CatDBAddHashCatNamePair(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddValueToExistingHashCatNameRow(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBCatnameAlreadyInHashesListOfCats(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNameToBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszNameToAdd,
    LPWSTR              pwszListToAddTo
    );

BOOL
_CatDBAddWholeBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyToAddTo,
    LPWSTR              pwszBuddyListName
    );

BOOL
_CatDBMoveInUseFileToTempLocation(
    LPWSTR              pwszFile
    );

void
_CatDBCleanupTempFiles();


//
// Supporting functions for s_SSCatDBDeleteCatalog
//

BOOL
_CatDBDeleteCatalogEntriesFromDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatalogName
    );

BOOL
_CatDBRemoveCatNameFromHashesListOfCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromMultiValuedColumn(
    PJET_DB_STRUCT      pJetDBStruct,
    JET_TABLEID         jetTableID,
    JET_COLUMNID        jetColumnID,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );


//
// Supporting functions for s_SSCatDBEnumCatalogs
//

BOOL
_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatName,
    DWORD __RPC_FAR     *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames,
    BOOL                fRecursiveCall);


BOOL
_CatDBAddCatNameToReturnBuddyListIfNotExist(
    LPWSTR                      pwszBuddy,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames
    );


//
// More general supporting functions
//

JET_ERR
_CatDBSeekInCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyRow
    );

JET_ERR
_CatDBSeekInHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob
    );

void
_CatDBNotifyClients(void);

void
_CatDBCleanupClientNotifications(void);

LPWSTR
_CatDBCreateNewCatalogFileName(
    LPCWSTR             pwszCatalogFileDir,
    LPCWSTR             pwszCatName,
    BOOL                *pfFileAlreadyExists
    );

BOOL
_CatDBFindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectDat