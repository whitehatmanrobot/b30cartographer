aseEvent
{
}


[InstrumentationClass(InstrumentationType.Instance)]
public class NestedTestOuter
{
    public string Name;
    [InstrumentationClass(InstrumentationType.Instance)]
    public class NestedTestt
    {
        public string name = "Jeff";
        public DateTime dt = DateTime.Now;
    }
}

public class Evt3126 : BaseEvent
{
    public string [] rg;
}


class App
{
    static void TestSetToZero(PropertyData prop, object[] test)
    {
        string name = prop.Name + new String(' ', 10-prop.Name.Length);
        Console.Write("{0}, {1} , ", name, test[0]);
        try
        {
            prop.Value = test[1];
            Console.WriteLine("OK, {0,20}, {1}", prop.Value, prop.Value.GetType());
        }
        catch(Exception e)
        {
            Console.WriteLine(e.Message);
        }
    }

    static object[] tests = new object[] {
        new object[] {"byte   0", (byte)0},
        new object[] {"short  0", (short)0},
        new object[] {"int    0", (int)0},
        new object[] {"\"0\"     ", "0"},
        new object[] {"float  0", (float)0},
        new object[] {"double 0", (double)0},
        new object[] {"sbyte  0", (sbyte)0},
        new object[] {"ushort 0", (ushort)0},
        new object[] {"uint   0", (uint)0},
        new object[] {"long   0", (long)0},
        new object[] {"ulong  0", (ulong)0},
        new object[] {"char   0", (char)0},
        new object[] {"byte   1", (byte)1},
        new object[] {"short  1", (short)1},
        new object[] {"int    1", (int)1},
        new object[] {"\"1\"     ", "1"},
        new object[] {"float  1", (float)1},
        new object[] {"double 1", (double)1},
        new object[] {"sbyte  1", (sbyte)1},
        new object[] {"ushort 1", (ushort)1},
        new object[] {"uint   1", (uint)1},
        new object[] {"long   1", (long)1},
        new object[] {"ulong  1", (ulong)1},
        new object[] {"char   1", (char)1},
        new object[] {"byte 255", (byte)255},
        new object[] {"short -1", (short)-1},
        new object[] {"int   -1", (int)-1},
        new object[] {"\"-1\"     ", "-1"},
        new object[] {"float -1", (float)-1},
        new object[] {"double -1", (double)-1},
        new object[] {"sbyte -1", (sbyte)-1},
        new object[] {"ushort 65536", (ushort)UInt16.MaxValue},
        new object[] {"uint   4294967295", (uint)UInt32.MaxValue},
        new object[] {"long   -1", (long)-1},
        new object[] {"ulong  18446744073709551615", (ulong)UInt64.MaxValue},
        new object[] {"char   1", (char)1},
        new object[] {"float  1.1", (float)1.1},
        new object[] {"double 1.1", (double)1.1},
        new object[] {"\"1.1\"     ", "1.1"},
        new object[] {"float  -1.1", (float)-1.1},
        new object[] {"double -1.1", (double)-1.1},
        new object[] {"\"-1.1\"     ", "-1.1"},
    };

    //[STAThread]
    static void Mainx(string[] args)
    {
        ManagementClass newClass = new ManagementClass(@"root\default", "", null);
        newClass.SystemProperties ["__CLASS"].Value = "Bug3126";
        PropertyDataCollection props = newClass.Properties;
        props.Add("sint8", CimType.SInt8, false);
        props.Add("uint8", CimType.UInt8, false);
        props.Add("sint16", CimType.SInt16, false);
        props.Add("uint16", CimType.UInt16, false);
        props.Add("sint32", CimType.SInt32, false);
        props.Add("uint32", CimType.UInt32, false);
        props.Add("sint64", CimType.SInt64, false);
        props.Add("uint64", CimType.UInt64, false);
        props.Add("char16", CimType.Char16, false);
        props.Add("real32", CimType.Real32, false);
        props.Add("real64", CimType.Real64, false);
        props.Add("string", CimType.String, false);
        foreach(object[] test in tests)
        {
            foreach(PropertyData prop in props)
                TestSetToZero(prop, test);
        }

        return;
        Console.WriteLine(Thread.CurrentThread.Name);
        bool b = Instrumentation.IsAssemblyRegistered(typeof(App).Assembly);

        Instrumentation.RegisterAssembly(typeof(App).Assembly);

        b = Instrumentation.IsAssemblyRegistered(typeof(App).Assembly);


        ManagementClass cls = new ManagementClass();
        Console.WriteLine(cls.GetHashCode());
        cls = new ManagementClass();
        Console.WriteLine(cls.GetHashCode());
        cls = new ManagementClass();
        Console.WriteLine(cls.GetHashCode());

        Console.WriteLine("ready");
        Console.ReadLine();
        new evt2().Fire();
        Console.WriteLine("done");
        return;
        
        Instrumentation.Publish(typeof(inst2));
        inst2 i = new inst2();
        i.name = "jeff";
        i.Published = true;
        Console.WriteLine("done");
        Console.ReadLine();
//        EventQueryLeak();
    }
    static void TestSetToZero2(PropertyData prop)
    {
        string name = prop.Name;
        Console.Write("{0}, byte  , ", name); try { prop.Value = (byte)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, short , ", name); try { prop.Value = (short)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, int   , ", name); try { prop.Value = (int)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, \"0\"   , ", name); try { prop.Value = "0";Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, float , ", name); try { prop.Value = (float)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, double, ", name); try { prop.Value = (double)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, sbyte , ", name); try { prop.Value = (sbyte)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, ushort, ", name); try { prop.Value = (ushort)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, uint  , ", name); try { prop.Value = (uint)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, long  , ", name); try { prop.Value = (long)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, ulong , ", name); try { prop.Value = (ulong)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
        Console.Write("{0}, char  , ", name); try { prop.Value = (char)0;Console.WriteLine("OK");} catch(Exception e) {Console.WriteLine(e.Message);}
    }
    static void Bug89742()
    {
        WqlEventQuery query = new WqlEventQuery("select * from __TimerEvent where TimerID='MyEvent'");
        ManagementScope scope = new ManagementScope("root\\default");
        ManagementEventWatcher watcher = new ManagementEventWatcher(scope, query);	
        for(int i=0;i<5000;i++)
        {           
            ManagementBaseObject e = watcher.WaitForNextEvent();
            Console.WriteLine("{0}. {1}", i, e["TimerID"]);
            watcher.Stop();		// leaks winmgmt.exe if uncommented
        }
    }
    static void Bug91502()
    {
        int i;
        DateTime startTime = DateTime.Now;
        for (i=0;i<10000;i++)
        {
            inst insta = new inst();
            Instrumentation.Publish(insta);
        }
        Console.ReadLine();
        Console.WriteLine("Check your instances");
        Console.ReadLine();
        DateTime endTime = DateTime.Now;
        Console.WriteLine("Elapsed Time = {0}", endTime-startTime);
    }
    static void EventQueryLeak()
    {
        for(int i=0;true;i++)
        {
            WqlEventQuery query = new WqlEventQuery("select * from testbeeper");
            ManagementScope scope = new ManagementScope("root\\default");
            ManagementEventWatcher watcher = new ManagementEventWatcher(scope, query);
            ManagementBaseObject e = watcher.WaitForNextEvent();
            watcher.Stop();
            Console.WriteLine(i);
        }
    }
    static void EventQueryLeak2()
    {
        for(int i=0;true;i++)
        {
            WqlEventQuery query = new WqlEventQuery("select * from __instancemodificationevent within 1.0 where targetinstance isa 'Win32_Process'");
            ManagementScope scope = new ManagementScope("root\\cimv2");
            ManagementEventWatcher watcher = new ManagementEventWatcher(scope, query);
            ManagementBaseObject e = watcher.WaitForNextEvent();
            watcher.Stop();
            Console.WriteLine(i);
        }
    }
    static void InvokeLeak()
    {
//        object oz = new ManagementClass();
        for(int i=0;true;i++)
        {
            ManagementObject o = new ManagementObject(@"root\cimv2:Win32_Process='2716'");
            object[] arguments = new object[] {null, null};
            o.InvokeMethod("GetOwner", arguments);
//            arguments = null;
        }
    }
    static void InvokeLeak2()
    {
        GC.Collect(0);
        GC.Collect(1);
        GC.Collect(2);
        GC.Collect();
        Console.ReadLine();
        Console.WriteLine();
//        object[] arguments = new object[] {null, null};
//        ManagementObject o = new ManagementObject(@"root\cimv2:Win32_Process='2716'");
        KiloObject[] rg = new KiloObject[7*1024];
        for(int i=0;i<(7*1024);i++)
            rg[i] = new KiloObject();
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        GC.WaitForPendingFinalizers();
        rg = null;
        for(int i=0;true;i++)
        {
            new KiloObject();
            if(i%20 == 0)
                Thread.Sleep(1);
            //arguments[0] = null;
            //arguments[1] = null;
//            object o2 = o.InvokeMethod("GetOwner", arguments);
            if(i==10000)
                GC.Collect();
        }
    }
    static void NewLeak()
    {
        ManagementClass c = new ManagementClass("root:__Win32Provider");
        ManagementObject o = c.CreateInstance();
        PropertyData data = o.Properties["CLSID"];		
        while(true)
        {
            object temp = o.Properties["CLSID"];
            //Console.WriteLine(temp.GetType());
            //data.Value = "jeff";
        }
    }
    static void NewLeak2()
    {
        ManagementClass c = new ManagementClass("root:__Win32Provider");
        ManagementObject i = c.CreateInstance();
        while(true)
        {
            object o = i.Properties["__RELPATH"];
        }
    }

    static void QualifierSetLeakBug()
    {
        ManagementClass cls = new ManagementClass("Win32_Process");
        for(int i=0;true;i++)
        {
            cls.Get();
            int count=cls.Qualifiers.Count;
            if(i%1000==0)
                Console.WriteLine(i);
        }

    }

    static void DualNamespaceBug()
    {
        ManagementObject inst2 = new ManagementObject(@"ROOT\NS_TWO:NS_TWO_Class.key=""NS_TWO_Class_Inst2""");
        ManagementObjectCollection related = inst2.GetRelated();
        foreach(ManagementObject obj in related)
        {
            Console.WriteLine(obj.GetText(TextFormat.Mof));
            Console.WriteLine(obj.Path.NamespacePath);
            Console.WriteLine(obj.Scope.Path.NamespacePath);
            Debug.Assert(obj.Path.NamespacePath == obj.Scope.Path.NamespacePath);

            try
            {
                obj.Get();
            }
            catch(Exception e)
            {
                Debug.Assert(false, e.ToString());
            }
        }
    }

    static void Bug86688()
    {
        try 
        {
            ManagementClass newClass = new ManagementClass();
            newClass.Properties["__CLASS"].Value = "Blah";
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
            newClass.Options.UseAmendedQualifiers = true;
//            newClass.Scope = new ManagementScope("root/default");
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
            Console.WriteLine(newClass.Properties["__CLASS"].Value.ToString());
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }    
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\nullcontext\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace nullcontext
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ConnectionOptions con = new ConnectionOptions( );
		con.Locale = null;
		con.Username = null;
		con.Password = null;
		con.Authority = null;
		con.Impersonation  = ImpersonationLevel.Impersonate;
		con.Authentication = AuthenticationLevel.Connect; 
		con.EnablePrivileges = false;
		Console.WriteLine(con.Context); 
		con.Context = null;
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\privilegetest\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\nspath\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace nspath
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementPath path = new ManagementPath();
		path.NamespacePath = "root/cimv2";		// throw exception here
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\propertycopyto\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\marioh\attributes.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Management;
    using System.Globalization;

    /// <summary>
    ///    <para>Specifies that this assembly provides management instrumentation. This attribute should appear one time per assembly.</para>
    /// </summary>
    /// <remarks>
    /// <para>For more information about using attributes, see <see topic="cpconExtendingMetadataUsingAttributes" title="Extending Metadata Using Attributes"/> .</para>
    /// </remarks>
    [AttributeUsage(AttributeTargets.Assembly)]
    public class InstrumentedAttribute : Attribute
    {
        string namespaceName;
        string securityDescriptor;

        /// <overload>
        ///    Initializes a new instance
        ///    of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class.
        /// </overload>
        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> 
        /// class that is set for the root\default namespace. This is the default constructor.</para>
        /// </summary>
        public InstrumentedAttribute() : this(null, null) {}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class that is set to the specified namespace for instrumentation within this assembly.</para>
        /// </summary>
        /// <param name='namespaceName'>The namespace for instrumentation instances and events.</param>
        public InstrumentedAttribute(string namespaceName) : this(namespaceName, null) {}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class that is set to the specified namespace and security settings for instrumentation within this assembly.</para>
        /// </summary>
        /// <param name='namespaceName'>The namespace for instrumentation instances and events.</param>
        /// <param name='securityDescriptor'> A security descriptor that allows only the specified users or groups to run applications that provide the instrumentation supported by this assembly.</param>
        public InstrumentedAttribute(string namespaceName, string securityDescriptor)
        {
            // TODO: Do we need validation
            // bug#62511 - always use backslash in name
            if(namespaceName != null)
                namespaceName = namespaceName.Replace('/', '\\');

            if(namespaceName == null || namespaceName.Length == 0)
                namespaceName = "root\\default"; // bug#60933 Use a default namespace if null


            bool once = true;
            foreach(string namespacePart in namespaceName.Split('\\'))
            {
                if(     namespacePart.Length == 0
                    ||  (once && namespacePart.ToLower(CultureInfo.InvariantCulture) != "root")  // Must start with 'root'
                    ||  !Regex.Match(namespacePart, @"^[a-z,A-Z]").Success // All parts must start with letter
                    ||  Regex.Match(namespacePart, @"_$").Success // Must not end with an underscore
                    ||  Regex.Match(namespacePart, @"[^a-z,A-Z,0-9,_,\u0080-\uFFFF]").Success) // Only letters, digits, or underscores
                {
                    ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
                }
                once = false;
            }

            this.namespaceName = namespaceName;
            this.securityDescriptor = securityDescriptor;
        }

        /// <summary>
        ///    <para>Gets or sets the namespace for instrumentation instances and events in this assembly.</para>
        /// </summary>
        /// <value>
        ///    <para>If not specified, the default namespace will be set as "\\.\root\default". 
        ///       Otherwise, a string indicating the name of the namespace for instrumentation
        ///       instances and events in this assembly.</para>
        /// </value>
        /// <remarks>
        ///    It is highly recommended that the namespace name be specified by the
        ///    assembly, and that it should be a unique namespace per assembly, or per
        ///    application. Having a specific namespace for each assembly or
        ///    application instrumentation allows more granularity for securing access to
        ///    instrumentation provided by different assemblies or applications.
        /// </remarks>
        public string NamespaceName 
        {
            get { return namespaceName == null ? string.Empty : namespaceName; }
        }
        
        /// <summary>
        ///    <para> Gets or sets a security descriptor that allows only the specified users or groups to run
        ///       applications that provide the instrumentation supported by this assembly.</para>
        /// </summary>
        /// <value>
        ///    If null, the default value is defined as the Local Administrators Group. This
        ///    will only allow members of the local administrators group to publish data and
        ///    fire events from this assembly. Otherwise, this is a string in SDDL format
        ///    representing the security descriptor that defines which users and groups can
        ///    provide instrumentation data and events from this application.
        /// </value>
        /// <remarks>
        ///    <para>Users or groups not specified in this
        ///       security descriptor may still run the application, but cannot provide
        ///       instrumentation from this assembly.</para>
        /// </remarks>
        public string SecurityDescriptor
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == securityDescriptor || securityDescriptor.Length == 0)
                    return null;
                return securityDescriptor;
            }
        }

        internal static InstrumentedAttribute GetAttribute(Assembly assembly)
        {
            Object [] rg = assembly.GetCustomAttributes(typeof(InstrumentedAttribute), false);
            if(rg.Length > 0)
                return ((InstrumentedAttribute)rg[0]);
            return new InstrumentedAttribute();
        }

        
		internal static Type[] GetInstrumentedTypes(Assembly assembly)
        {
            ArrayList types = new ArrayList();
			
			//
			// [RAID#: 145574 marioh]
			// The recursion has been moved to the parent level to avoid ineffiency of wading through all types
			// at each stage of recursion. Also, the recursive method has been replaced with the more correct:
			// GetInstrumentedParentTypes method (see comments on header).
			//
			foreach ( Type type in assembly.GetTypes() )
			{
				if ( IsInstrumentationClass(type) )
				{
					GetInstrumentedParentTypes(types, type);
				}
			}
            return (Type[])types.ToArray(typeof(Type));
        }

		//
		// [RAID#: 145574 marioh]
		// Recursive function that adds the type to the array and recurses on the parent type. The end condition
		// is either no parent type or a parent type which is not marked as instrumented.
		//
		static void GetInstrumentedParentTypes(ArrayList types, Type childType )
		{
			if ( types.Contains ( childType ) == false )
			{
				types.Add(childType) ;
				Type parentType = InstrumentationClassAttribute.GetBaseInstrumentationType(childType) ;

				//
				// If we have a instrumented base type and it has not already been included in the list of instrumented types
				// traverse the inheritance hierarchy.
				//
				if ( ( parentType ) != null )
				{
					GetInstrumentedParentTypes ( types, parentType ) ;
				}
			}
		}

        static bool IsInstrumentationClass(Type type)
        {
            return (null != InstrumentationClassAttribute.GetAttribute(type));
        }

    }
    
    /// <summary>
    ///    <para>Specifies the type of instrumentation provided by a class.</para>
    /// </summary>
    /// <example>
    ///    <code lang='C#'>using System;
    /// using System.Management;
    /// using System.Configuration.Install;
    /// using System.Management.Instrumentation;
    /// 
    /// // This example demonstrates how to create a Management Event class by using
    /// // the InstrumentationClass attribute and to fire a Management Event from
    /// // managed code.
    /// 
    /// // Specify which namespace the Management Event class is created in
    /// [assembly:Instrumented("Root/Default")]
    /// 
    /// // Let the system know you will run InstallUtil.exe utility against
    /// // this assembly
    /// [System.ComponentModel.RunInstaller(true)]
    /// public class MyInstaller : DefaultManagementProjectInstaller {}
    /// 
    /// // Create a Management Instrumentation Event class
    /// [InstrumentationClass(InstrumentationType.Event)]
    /// public class MyEvent
    /// {
    ///     public string EventName;
    /// }
    /// 
    /// public class WMI_InstrumentedEvent_Example
    /// {
    ///     public static void Main() {
    ///         MyEvent e = new MyEvent();
    ///         e.EventName = "Hello";
    ///         
    ///         // Fire a Management Event
    ///         Instrumentation.Fire(e);
    ///         
    ///         return;
    ///     }
    /// }
    ///    </code>
    ///    <code lang='VB'>Imports System
    /// Imports System.Management
    /// Imports System.Configuration.Install
    /// Imports System.Management.Instrumentation
    /// 
    /// ' This sample demonstrates how to create a Management Event class by using
    /// ' the InstrumentationClass attribute and to fire a Management Event from
    /// ' managed code.
    /// 
    /// ' Specify which namespace the Manaegment Event class is created in
    /// &lt;assembly: Instrumented("Root/Default")&gt;
    /// 
    /// ' Let the system know InstallUtil.exe utility will be run against
    /// ' this assembly
    /// &lt;System.ComponentModel.RunInstaller(True)&gt; _
    /// Public Class MyInstaller
    ///     Inherits DefaultManagementProjectInstaller
    /// End Class 'MyInstaller
    /// 
    /// ' Create a Management Instrumentation Event class
    /// &lt;InstrumentationClass(InstrumentationType.Event)&gt; _ 
    /// Public Class MyEvent
    ///     Public EventName As String
    /// End Class
    /// 
    /// Public Class Sample_EventProvider
    ///     Public Shared Function Main(args() As String) As Integer
    ///         Dim e As New MyEvent()
    ///         e.EventName = "Hello"
    ///         
    ///         ' Fire a Management Event
    ///         Instrumentation.Fire(e)
    ///         
    ///         Return 0
    ///     End Function
    /// End Class
    ///    </code>
    /// </example>
    public enum InstrumentationType
    {
        /// <summary>
        ///    <para>Specifies that the class provides instances for management instrumentation.</para>
        /// </summary>
        Instance,
        /// <summary>
        ///    <para>Specifies that the class provides events for management instrumentation.</para>
        /// </summary>
        Event,
        /// <summary>
        ///    <para>Specifies that the class defines an abstract class for management instrumentation.</para>
        /// </summary>
        Abstract
    }

    /// <summary>
    /// Specifies that a class provides event or instance instrumentation.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class InstrumentationClassAttribute : Attribute
    {
        InstrumentationType instrumentationType;
        string managedBaseClassName;

        /// <overload>
        ///    Initializes a new instance
        ///    of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class.
        /// </overload>
        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class that is used if this type is derived from another type that has the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> attribute, or if this is a 
        ///    top-level instrumentation class (for example, an instance or abstract class
        ///    without a base class, or an event derived from <see langword='__ExtrinsicEvent'/>).</para>
        /// </summary>
        /// <param name='instrumentationType'>The type of instrumentation provided by this class.</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType)
        {
            this.instrumentationType = instrumentationType;
        }

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class that
        ///    has schema for an existing base class. The class must contain
        ///    proper member definitions for the properties of the existing
        ///    WMI base class.</para>
        /// </summary>
        /// <param name='instrumentationType'>The type of instrumentation provided by this class.</param>
        /// <param name='managedBaseClassName'>The name of the base class.</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType, string managedBaseClassName)
        {
            this.instrumentationType = instrumentationType;
            this.managedBaseClassName = managedBaseClassName;
        }

        /// <summary>
        ///    <para>Gets or sets the type of instrumentation provided by this class.</para>
        /// </summary>
        /// <value>
        ///    Contains an <see cref='System.Management.Instrumentation.InstrumentationType'/> value that
        ///    indicates whether this is an instrumented event, instance or abstract class.
        /// </value>
        public InstrumentationType InstrumentationType
        {
            get { return instrumentationType; }
        }

        /// <summary>
        ///    <para>Gets or sets the name of the base class of this instrumentation class.</para>
        /// </summary>
        /// <value>
        ///    <para>If not null, this string indicates the WMI baseclass that this class inherits
        ///       from in the CIM schema.</para>
        /// </value>
        public string ManagedBaseClassName
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == managedBaseClassName || managedBaseClassName.Length == 0)
                    return null;

                return managedBaseClassName;
            }
        }

        internal static InstrumentationClassAttribute GetAttribute(Type type)
        {
            // We don't want BaseEvent or Instance to look like that have an 'InstrumentedClass' attribute
            if(type == typeof(BaseEvent) || type == typeof(Instance))
                return null;

            // We will inherit the 'InstrumentedClass' attribute from a base class
            Object [] rg = type.GetCustomAttributes(typeof(InstrumentationClassAttribute), true);
            if(rg.Length > 0)
                return ((InstrumentationClassAttribute)rg[0]);
            return null;
        }

		/// <summary>
		/// <para>Displays the <see langword='Type'/> of the base class.</para>
		/// </summary>
		/// <param name='type'></param>
		/// <returns>
		/// <para>The <see langword='Type'/> of the base class, if this class is derived from another 
		///    instrumentation class; otherwise, null.</para>
		/// </returns>
		internal static Type GetBaseInstrumentationType(Type type)
        {
            // If the BaseType has a InstrumentationClass attribute,
            // we return the BaseType
            if(GetAttribute(type.BaseType) != null)
                return type.BaseType;
            return null;
        }
    }

    /// <summary>
    ///    <para>Allows an instrumented class, or member of an instrumented class,
    ///       to present an alternate name through management instrumentation.</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class ManagedNameAttribute : Attribute
    {
        string name;

		/// <summary>
		/// <para>Gets the name of the managed entity.</para>
		/// </summary>
		/// <value>
		/// Contains the name of the managed entity.
		/// </value>
		public string Name
		{
			get { return name ; }
		}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.ManagedNameAttribute'/> class that allows the alternate name to be specified
        ///    for the type, field, property, method, or parameter to which this attribute is applied.</para>
        /// </summary>
        /// <param name='name'>The alternate name for the type, field, property, method, or parameter to which this attribute is applied.</param>
        public ManagedNameAttribute(string name)
        {
            this.name = name;
        }

        internal static string GetMemberName(MemberInfo member)
        {
            // This works for all sorts of things: Type, MethodInfo, PropertyInfo, FieldInfo
            Object [] rg = member.GetCustomAttributes(typeof(ManagedNameAttribute), false);
            if(rg.Length > 0)
            {
                // bug#69115 - if null or empty string are passed, we just ignore this attribute
                ManagedNameAttribute attr = (ManagedNameAttribute)rg[0];
                if(attr.name != null && attr.name.Length != 0)
                    return attr.name;
            }

            return member.Name;
        }

        internal static string GetBaseClassName(Type type)
        {
            InstrumentationClassAttribute attr = InstrumentationClassAttribute.GetAttribute(type);
            string name = attr.ManagedBaseClassName;
            if(name != null)
                return name;
            
            // Get managed base type's attribute
            InstrumentationClassAttribute attrParent = InstrumentationClassAttribute.GetAttribute(type.BaseType);

            // If the base type does not have a InstrumentationClass attribute,
            // return a base type based on the InstrumentationType
            if(null == attrParent)
            {
                switch(attr.InstrumentationType)
                {
                    case InstrumentationType.Abstract:
                        return null;
                    case InstrumentationType.Instance:
                        return null;
                    case InstrumentationType.Event:
                        return "__ExtrinsicEvent";
                    default:
                        break;
                }
            }

            // Our parent was also a managed provider type.  Use it's managed name.
            return GetMemberName(type.BaseType);
        }
    }

    /// <summary>
    ///    <para>Allows a particular member of an instrumented class to be ignored
    ///       by management instrumentation</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class IgnoreMemberAttribute : Attribute
    {
    }

#if REQUIRES_EXPLICIT_DECLARATION_OF_INHERITED_PROPERTIES
    /// <summary>
    ///    <para>[To be supplied.]</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class InheritedPropertyAttribute : Attribute
    {
        internal static InheritedPropertyAttribute GetAttribute(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(InheritedPropertyAttribute), false);
            if(rg.Length > 0)
                return ((InheritedPropertyAttribute)rg[0]);
            return null;
        }
    }
#endif

#if SUPPORTS_WMI_DEFAULT_VAULES
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedDefaultValueAttribute : Attribute
    {
        Object defaultValue;
        public ManagedDefaultValueAttribute(Object defaultValue)
        {
            this.defaultValue = defaultValue;
        }

        public static Object GetManagedDefaultValue(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedDefaultValueAttribute), false);
            if(rg.Length > 0)
                return ((ManagedDefaultValueAttribute)rg[0]).defaultValue;

            return null;
        }
    }
#endif

#if SUPPORTS_ALTERNATE_WMI_PROPERTY_TYPE
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedTypeAttribute : Attribute
    {
        Type type;
        public ManagedTypeAttribute(Type type)
        {
            this.type = type;
        }

        public static Type GetManagedType(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedTypeAttribute), false);
            if(rg.Length > 0)
                return ((ManagedTypeAttribute)rg[0]).type;

            return field.FieldType;
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\propertyqualifiersets\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\pathtest\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace PathTest
{
using System;
using System.Collections;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementPath path = new ManagementPath ("\\\\products1\\root\\cimv2:Win32_Something.A=10,B='haha'");
		Console.WriteLine (path.ToString());
		Console.WriteLine ("Path[" + path.Path + "]");
		Console.WriteLine ("Server[" + path.Server + "]");
		Console.WriteLine ("ClassName[" + path.ClassName + "]");
		Console.WriteLine ("RelativePath[" + path.RelativePath + "]");
		Console.WriteLine ("NamespacePath[" + path.NamespacePath + "]");
		
		ManagementPath path2 = new ManagementPath();
		path2.ClassName = "Fred";
		Console.WriteLine ("Path[" + path2.Path + "]");
		path2.SetAsSingletion ();
		Console.WriteLine ("Path[" + path2.Path + "]");
		
		path2.SetAsClass ();
		Console.WriteLine ("Path[" + path2.Path + "]");

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\priv2\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace priv2
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
       		string mylocale="ms_409";
			int count = 0;
		
			// Setting the ManagementObject with the ConnectionOptions
			ConnectionOptions con = new ConnectionOptions(mylocale,null,null,null,ImpersonationLevel.Impersonate,AuthenticationLevel.Connect,
				false,null);
			ManagementPath mypath = new ManagementPath("Win32_LogicalDisk='c:'");
			ManagementScope myscope = new ManagementScope("\\\\.\\root\\cimv2",con);
			// Query for different folders seems to wait for a while.
			ObjectQuery myquery = new ObjectQuery("WQL","Select * from Win32_NtLogevent Where logfile='Security'");
			ManagementObjectSearcher pobj = new ManagementObjectSearcher(myscope,myquery);
			pobj.Options.ReturnImmediately = true;
			pobj.Options.Rewindable = false;
			ManagementObjectCollection SecurityLogCollection = pobj.Get();
			foreach(ManagementObject SecurityLog in SecurityLogCollection)
			{
				count++;
				Console.WriteLine(SecurityLog["Logfile"] + " [" + count + "]");
			}
			

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\propertycopyto\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace PropertyCopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject("Win32_logicalDisk='C:'");
		Property[] properties = new Property [100];

		System.Management.PropertyCollection c = disk.Properties;
		c.CopyTo (properties, 0);
		
		for (int i = 0; i < properties.Length; i++)
			if (null != properties[i])
				Console.WriteLine (properties[i].Name + " " + properties[i].Type);

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\queryinstances\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\scopechange\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\privilegetest\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace PrivilegeTest
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s = new ManagementObjectSearcher ("root/cimv2", 
			"select Message from Win32_NTLogEvent where LogFile='Security'");

		if ((null != args) && (0 < args.Length))
		{ 
			if ("p" == args[0])
				s.Scope.Options.EnablePrivileges = true;
		}

		s.Options.Rewindable = false;
		s.Options.ReturnImmediately = true;
		
		try {
			foreach (ManagementBaseObject o in s.Get())
				Console.WriteLine (o["Message"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Call returned {0:x} - {1}", (UInt32)e.ErrorCode, e.Message);
		}

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\setvolumename\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\stopevents\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\sysprop\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\propertyqualifiersets\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Project1
{
using System;
using System.Management;
using System.Collections;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        //
        // TODO: Add code to start application here
        //
   		ManagementObject o = new ManagementObject("Win32_LogicalDisk=\"C:\"");
		Console.WriteLine("Object path is : {0}", o["__PATH"]);
		PropertySet s = o.Properties;
		Console.WriteLine("Object has {0} properties", s.Count);
		Console.WriteLine("Key property value is : {0}", s["DeviceID"].Value);

		foreach (Property p in s)
			Console.WriteLine("Property {0} = {1}", p.Name, p.Type);

		foreach (Qualifier q in o.Qualifiers)
			Console.WriteLine("Qualifier {0} = {1}", q.Name, q.Value);

		o.Qualifiers.Add("myQual", "myVal");
		o.Qualifiers["myQual"].Value = "myNewVal";

		Console.WriteLine("Qualifier : {0} = {1}", o.Qualifiers["myQual"].Name, o.Qualifiers["myQual"].Value);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\test1\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\queryinstances\queryinstances.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace QueryInstances
{
using System;
using System.Management;

/// <summary>
///    ManagementObjectSearcher Example 2 : query for environment vars for certain user
/// </summary>
public class QueryInstances
{
    public QueryInstances()
    {
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s;
		SelectQuery q;

		//Create a query for system environment variables only
		q = new SelectQuery("Win32_Environment", "UserName=\"<SYSTEM>\"");

		//Initialize a searcher with this query
		s = new ManagementObjectSearcher(q);

		//Get the resulting collection and loop through it
		foreach (ManagementBaseObject o in s.Get())
			Console.WriteLine("System environment variable {0} = {1}", o["Name"], o["VariableValue"]);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\scopechange\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace ScopeChange
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		// Simple example of how the ManagementScope object deals with
		// changes to its properties
		ManagementClass sysClass = new ManagementClass ("root/cimv2:__SystemClass");
		Console.WriteLine (sysClass["__PATH"]);

		sysClass.Scope.Path.NamespacePath = "root/default";
		Console.WriteLine (sysClass["__PATH"]);

		sysClass.Scope.Options.Impersonation = System.Management.ImpersonationLevel.Identify;
		Console.WriteLine (sysClass["__PATH"]);

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\timeout\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\traverserelations\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\stopevents\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace stopevents
{
using System;
using System.Management;


/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        // Create a timer event instance
			ManagementClass timerClass = new ManagementClass("root/default",
				"__IntervalTimerInstruction",
				null);
			ManagementObject timerObj = timerClass.CreateInstance();
			timerObj["IntervalBetweenEvents"] = 500;	//fire every half a second
			timerObj["TimerID"] = "Timer62";		
			timerObj.Put();

			// Create an EventWatcherOptions
          		  EventWatcherOptions options = new EventWatcherOptions();
			options.Timeout = new TimeSpan(0,0,0,5,0);	// timeout in 5 secs
			options.BlockSize = 2;
            
			// Create an event query
			WQLEventQuery query = new WQLEventQuery("__TimerEvent", "TimerID='Timer62'");

			// Create an event watcher and subscribe the events that matches the event query
			ManagementEventWatcher watcher = new ManagementEventWatcher(
				new ManagementScope("root/default"),
				query,
				options);

			// Create a Stopped handler
			EventStoppedHandler stopHandlerObj = new EventStoppedHandler();
			watcher.Stopped += new StoppedEventHandler(stopHandlerObj.Stopped);

          		// Block until next event arrives or throw a ManagementException:TimedOut
			ManagementBaseObject e = watcher.WaitForNextEvent(); 
			
			// Assertion: Event was received.
			// Cancel subscription
			watcher.Stop();
			while (!stopHandlerObj.IsStopped)
			{
				System.Threading.Thread.Sleep(1000);
			}
		return 0;
    }
}

public class EventStoppedHandler
{
	private bool isStopped = false;

	internal void Stopped (object sender, StoppedEventArgs args)
	{
		isStopped = true;
	}

	public bool IsStopped { get { return isStopped; } }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\setvolumename\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace SetVolumeName
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject ("Win32_LogicalDisk=\"C:\"");
		disk["VolumeName"] = "Stimpy";
		ManagementPath path = disk.Put ();
		Console.WriteLine (path.Path);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\test1\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Test1
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject disk = new ManagementObject ("win32_logicaldisk");
		Console.WriteLine ("Class name is " + disk.SystemProperties ["__CLASS"]);

		ManagementObject diskC = new ManagementObject ("win32_logicaldisk='C:'");
		Console.WriteLine ("Freespace is " + diskC["FreeSpace"]);

		ManagementObject process0 = new ManagementObject ("Win32_Process='0'");
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();

		CompletionHandler completionHandler = new CompletionHandler ();
		watcher.Completed += new CompletedEventHandler (completionHandler.Done);

		process0.Get (watcher);

		while (!completionHandler.IsComplete) {
			System.Threading.Thread.Sleep (1000);
		}

		Console.WriteLine (process0["Name"]);

        return 0;
    }
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\sysprop\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Sysprop
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
       try
		{
			// Create a class with a NULL key and five instances
			// Create class
			ManagementClass mClass = new ManagementClass("root/default","",null);
 			mClass.SystemProperties["__Class"].Value = "test";
			mClass.Properties.Add("foo",CIMType.Uint16,false);	 // Create a NULL
			mClass.Properties["foo"].Qualifiers.Add("key",true); // key
			mClass.Put();

			ManagementObject mObj = mClass.CreateInstance();
			mObj["foo"] = 10;
			mObj.Put();	

			ManagementObject m = new ManagementObject("root/cimv2:Win32_process");
			Console.WriteLine("RELPATH is " + m["__RELPATH"]);
			Console.WriteLine("PATH is " + m["__PATH"]); // nothing displayed
			Console.WriteLine("PATH is " + m.Path.ToString());		// InvalidCastException

			// Attempt to display info from newly created ManagementObject
			Console.WriteLine("RELPATH is " + mObj["__RELPATH"]);
			Console.WriteLine("PATH is " + mObj["__PATH"]); // nothing displayed
			Console.WriteLine("PATH is " + mObj.Path.Path);		// InvalidCastException

			// Attempt to display info from newly created ManagementClass 
			//Console.WriteLine("RELPATH is " + mClass["__RELPATH"]);
			//Console.WriteLine("PATH is " + mClass.Path);	// compile error: lacks get accessor
			Console.Read();
			mClass.Delete();
			return 0;
		}
		catch (Exception e)
		{
			Console.WriteLine("Test : " + e.GetType().ToString());
			Console.WriteLine(e.Message + e.StackTrace);
			return 0 ;
		}
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\timeout\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace timeout
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try
		{
			// Create a timer event instance
			ManagementClass timerClass = new ManagementClass("root/default",
				"__IntervalTimerInstruction",
				null);
			ManagementObject timerObj = timerClass.CreateInstance();
			timerObj["IntervalBetweenEvents"] = 5000;	//fire every ten seconds
			timerObj["TimerID"] = "Timer612";		
			timerObj.Put(); 

			// Create an EventWatcherOptions
            EventWatcherOptions options = new EventWatcherOptions();
			options.Timeout = new TimeSpan(0,0,0,2,0);	// time out in 2 secs
			options.BlockSize = 2;
            
			// Create an event query
			WQLEventQuery query = new WQLEventQuery("__TimerEvent", 
													"TimerID='Timer612'");

			// Create an event watcher and subscribe the events that matches the event query
			ManagementEventWatcher watcher = new ManagementEventWatcher(
				new ManagementScope("root/default"),
				query,
				options);

            // Block until next event arrives or throw a ManagementException:TimedOut
			ManagementBaseObject e = watcher.WaitForNextEvent(); 
			
			// Assertion: Event was received.
            Console.WriteLine("Unable to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
			return 1;
		}
		catch (ManagementException e)
		{
			Console.WriteLine("Error Message is " + e.Message);
			Console.WriteLine("Error Code is " + e.ErrorCode);
            Console.WriteLine("Status.Timedout is " + ManagementStatus.Timedout);
			if (ManagementStatus.Timedout == e.ErrorCode)
			{
				// Assertion: Event was not received within time out period
				// Clean up -
				ManagementObject timerObj = new ManagementObject("root/default:__IntervalTimerInstruction.TimerID='Timer612'");
				timerObj.Delete();
				Console.WriteLine("Test6.1.2: Able to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
				return 0;
			}
			else
			{
				Console.WriteLine("Test6.1.2: Unable to specify Timeout for an event when calling ManagementEventWatcher.WaitForNextEvent().");
				return 1;
			}
		}
		catch (Exception e)
		{
			Console.WriteLine("Test6.1.2: " + e.GetType());
			Console.WriteLine(e.Message + e.StackTrace);
			return 1;
		}
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\traverserelations\traverserelations.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace TraverseRelations
{
using System;
using System.Management;
using System.Threading;

/// <summary>
///    ManagementObject Example 2 : Traverse associations & invoke methods
/// </summary>
public class TraverseRelations
{
    public TraverseRelations()
    {
    }

    public static int Main(string[] args)
    {
		ManagementObject myService;
		ManagementObjectCollection relatedServices;

		//Get the W3SVC service object
		myService = new ManagementObject("Win32_Service=\"W3SVC\"");

		//Find all services that it depends on
		relatedServices = myService.GetRelated("Win32_Service");
		
		//Loop through and start all these services
		foreach (ManagementObject service in relatedServices)
		{
			Console.WriteLine("This service depends on {0}, we'll start it...", service["Name"]);
			try {
				service.InvokeMethod("StartService", null);
			} catch (ManagementException) {
				Console.WriteLine("Couldn't start the service !!");
			}
			
			//Poll for the service having started (note: we could use event notifications here...)
			while ((string)service["State"] != "Running")
			{
				Console.WriteLine(service["State"]);
				Thread.Sleep(1000);
				service.Get(); //refresh the data in this object
			}

			Console.WriteLine("Service is {0} !!!", service["State"]);
		}

		Console.ReadLine();

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\useridnullref\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\useridnullref\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace UserIDNullRef
{
    using System;
	using System.Management;

    /// <summary>
    ///    Summary description for Class1.
    /// </summary>
    public class Class1
    {
        public Class1()
        {
            //
            // TODO: Add Constructor Logic here
            //
        }

        public static int Main(string[] args)
        {
		try 
		{
			ManagementClass userid = new ManagementClass ("root/default:userid");
			string[] privilegesArray = null;
			string impersonationLevel = null;
			String domain = null;
			String user = null;
			bool[] enableArray = null;
			object [] mArgs = 
			{
				domain,
				user,
				impersonationLevel,
				privilegesArray,
				enableArray,
			};

			userid.InvokeMethod ("GetUserID", mArgs);
			Console.WriteLine ("User is " + mArgs[0] + "\\" + mArgs[1]);
			Console.WriteLine ("Impersonation level is: " + mArgs[2]);
			

			Console.WriteLine ("Privileges:");

			foreach (String privilege in (string[])mArgs[3])
			{
				Console.WriteLine (privilege);
			}

			foreach (bool en in (bool[])mArgs[4])
			{
				Console.WriteLine (en);
			}
			
		    } //end of try
		catch (ManagementException e)
			    {	
				Console.WriteLine("ManagementExecption" + e.Message);
			}
		
		catch (Exception e)
		{
			Console.WriteLine("Exception" + e.Message); 
		}

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\cachedbitmap.cs ===
//------------------------------------------------------------------------------
// <copyright file="CachedBitmap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CachedBitmap.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ cached bitmap object
*
* Revision History:
*
*   05/01/2000 ericvan
*       Code review.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.ComponentModel;    
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Internal;

    /**
     * Represent a Cached Bitmap object
     */
    internal abstract class CachedBitmap : IDisposable {

#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        /*
         * handle to native cached bitmap object
         */
        internal IntPtr nativeCachedBitmap;

        public CachedBitmap(Bitmap bitmap,
                            Graphics graphics) 
        {
            if (bitmap == null)
                throw new ArgumentNullException("image");
            
            if (graphics == null)
                throw new ArgumentNullException("graphics");
            
            IntPtr cachedbitmap = IntPtr.Zero;
            
            int status =  SafeNativeMethods.GdipCreateCachedBitmap(new HandleRef(bitmap, bitmap.nativeImage),
                                                         new HandleRef(graphics, graphics.nativeGraphics),
                                                         out cachedbitmap);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            nativeCachedBitmap = cachedbitmap;                                                         
        }
                
        /**
         * Dispose of resource associated with the cached bitmap object
         */
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        internal virtual void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeCachedBitmap != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif

            if (nativeCachedBitmap != IntPtr.Zero) {
                SafeNativeMethods.GdipDeleteCachedBitmap(new HandleRef(this, nativeCachedBitmap));
                nativeCachedBitmap = IntPtr.Zero;
            }
        }

        internal void SetNativeCachedBitmap(IntPtr cachedBitmap) {
            if (nativeCachedBitmap == IntPtr.Zero)
                throw new ArgumentNullException("cachedBitmap");

            this.nativeCachedBitmap = nativeCachedBitmap;
        }

        /**
         * Object cleanup
         */
        ~CachedBitmap() {
            Dispose(false);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\brush.cs ===
//------------------------------------------------------------------------------
// <copyright file="Brush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Brush.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ brush objects
*
* Revision History:
*
*   01/11/1999 davidx
*       Code review.
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.ComponentModel;    
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Internal;

    /**
     * Represent a Brush object
     */
    /// <include file='doc\Brush.uex' path='docs/doc[@for="Brush"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Classes derrived from this abstract base
    ///       class define objects used to fill the interiors of graphical shapes such as
    ///       rectangles, ellipses, pies, polygons, and paths.
    ///    </para>
    /// </devdoc>
    public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable {

#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        /*
         * handle to native brush object
         */
        internal IntPtr nativeBrush;

        /**
         * Create a copy of the brush object
         */
        /// <include file='doc\Brush.uex' path='docs/doc[@for="Brush.Clone"]/*' />
        /// <devdoc>
        ///    When overriden in a derived class, creates
        ///    an exact copy of this <see cref='System.Drawing.Brush'/>.
        /// </devdoc>
        public abstract object Clone();

        internal Brush() { nativeBrush = IntPtr.Zero; }
        
        /**
         * Dispose of resource associated with the brush object
         */
        /// <include file='doc\Brush.uex' path='docs/doc[@for="Brush.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deletes this <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\Brush.uex' path='docs/doc[@for="Brush.Dispose1"]/*' />
        protected virtual void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeBrush != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif
            if (nativeBrush != IntPtr.Zero) {
                SafeNativeMethods.GdipDeleteBrush(new HandleRef(this, nativeBrush));
                nativeBrush = IntPtr.Zero;
            }
        }

        internal void SetNativeBrush(IntPtr nativeBrush) {
            if (nativeBrush == IntPtr.Zero)
                throw new ArgumentNullException("nativeBrush");

            this.nativeBrush = nativeBrush;
        }

        /**
         * Object cleanup
         */
        /// <include file='doc\Brush.uex' path='docs/doc[@for="Brush.Finalize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Releases memory allocated for this <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        ~Brush() {
            Dispose(false);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\bitmap.cs ===
//------------------------------------------------------------------------------
// <copyright file="Bitmap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Bitmap.cs
* Abstract:
*
*   COM+ wrapper for GDI+ Bitmap objects
*
* Revision History:
*
*   01/12/1999 davidx
*       Code review changes.
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing.Design;    
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Imaging;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap"]/*' />
    /// <devdoc>
    ///    Encapsultates a GDI+ bitmap.
    /// </devdoc>
    /**
     * Represent a bitmap image
     */
    [
    Editor("System.Drawing.Design.BitmapEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
    Serializable,
    ComVisible(true)
    ]
    public sealed class Bitmap : Image {
        private static Color defaultTransparentColor = Color.LightGray;

        /*
         * Predefined bitmap data formats
         */

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class from the specified file.
        /// </devdoc>
        /**
         * Create a new bitmap object from URL
         */
        public Bitmap(String filename) {
            IntSecurity.DemandReadFileIO(filename);

            //GDI+ will read this file multiple times.  Get the fully qualified path
            //so if our app changes default directory we won't get an error
            //
            filename = Path.GetFullPath(filename);

            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromFile(filename, out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, bitmap));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, bitmap));
                throw SafeNativeMethods.StatusException(status);
            }

            SetNativeImage(bitmap);

            EnsureSave(this, filename, null);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Bitmap'/> class from the specified
        ///       file.
        ///    </para>
        /// </devdoc>
        public Bitmap(String filename, bool useIcm) {
            IntSecurity.DemandReadFileIO(filename);

            //GDI+ will read this file multiple times.  Get the fully qualified path
            //so if our app changes default directory we won't get an error
            //
            filename = Path.GetFullPath(filename);

            IntPtr bitmap = IntPtr.Zero;
            int status;

            if (useIcm) {
                status = SafeNativeMethods.GdipCreateBitmapFromFileICM(filename, out bitmap);
            }
            else {
                status = SafeNativeMethods.GdipCreateBitmapFromFile(filename, out bitmap);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, bitmap));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, bitmap));
                throw SafeNativeMethods.StatusException(status);
            }

            SetNativeImage(bitmap);

            EnsureSave(this, filename, null);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Bitmap'/> class from a specified resource.
        ///    </para>
        /// </devdoc>
        public Bitmap(Type type, string resource) {
            Stream stream = type.Module.Assembly.GetManifestResourceStream(type, resource);
            if (stream == null)
                throw new ArgumentException(SR.GetString(SR.ResourceNotFound, type, resource));

            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, bitmap));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, bitmap));
                throw SafeNativeMethods.StatusException(status);
            }

            SetNativeImage(bitmap);

            EnsureSave(this, null, stream);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap3"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class from the specified data stream.
        /// </devdoc>
        /**
         * Create a new bitmap object from a stream
         */
        public Bitmap(Stream stream) {

            if (stream == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));

            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, bitmap));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, bitmap));
                throw SafeNativeMethods.StatusException(status);
            }

            SetNativeImage(bitmap);

            EnsureSave(this, null, stream);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Bitmap'/> class from the specified data
        ///       stream.
        ///    </para>
        /// </devdoc>
        public Bitmap(Stream stream, bool useIcm) {

            if (stream == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));

            IntPtr bitmap = IntPtr.Zero;
            int status;

            if (useIcm) {
                status = SafeNativeMethods.GdipCreateBitmapFromStreamICM(new GPStream(stream), out bitmap);
            }
            else {
                status = SafeNativeMethods.GdipCreateBitmapFromStream(new GPStream(stream), out bitmap);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, bitmap));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, bitmap));
                throw SafeNativeMethods.StatusException(status);
            }

            SetNativeImage(bitmap);

            EnsureSave(this, null, stream);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the
        ///       Bitmap class with the specified size, pixel format, and pixel data.
        ///    </para>
        /// </devdoc>
        public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromScan0(width, height, stride, (int) format, new HandleRef(null, scan0), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(bitmap);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the Bitmap class with the specified
        ///       size and format.
        ///    </para>
        /// </devdoc>
        public Bitmap(int width, int height, PixelFormat format) {
            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromScan0(width, height, 0, (int) format, NativeMethods.NullHandleRef, out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(bitmap);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap7"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class with the specified size.
        /// </devdoc>
        public Bitmap(int width, int height) : this(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb) {
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap8"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class with the specified size and target <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        public Bitmap(int width, int height, Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");
            
            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromGraphics(width, height, new HandleRef(g, g.nativeGraphics), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(bitmap);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap9"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class, from the specified existing image, with the specified size.
        /// </devdoc>
        public Bitmap(Image original) : this(original, original.Width, original.Height) {
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap10"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the
        /// <see cref='System.Drawing.Bitmap'/> 
        /// class, from the specified existing image, with the specified size.
        /// </devdoc>
        public Bitmap(Image original, int width, int height) : this(width, height) {
            Graphics g = Graphics.FromImage(this);
            g.Clear(Color.Transparent);
            g.DrawImage(original, 0, 0, width, height);
            g.Dispose();
        }

        /**
         * Constructor used in deserialization
         */
        private Bitmap(SerializationInfo info, StreamingContext context) : base(info, context) {
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.FromHicon"]/*' />
        /// <devdoc>
        ///    Creates a <see cref='System.Drawing.Bitmap'/> from a Windows handle to an
        ///    Icon.
        /// </devdoc>
        public static Bitmap FromHicon(IntPtr hicon) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr bitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateBitmapFromHICON(new HandleRef(null, hicon), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return Bitmap.FromGDIplus(bitmap);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.FromResource"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static Bitmap FromResource(IntPtr hinstance, String bitmapName) 
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr bitmap;

            IntPtr name = Marshal.StringToHGlobalUni(bitmapName);

            int status = SafeNativeMethods.GdipCreateBitmapFromResource(new HandleRef(null, hinstance),
                                                              new HandleRef(null, name),
                                                              out bitmap); 
            Marshal.FreeHGlobal(name);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return Bitmap.FromGDIplus(bitmap);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.GetHbitmap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a Win32 HBITMAP out of the image. You are responsible for
        ///       de-allocating the HBITMAP with Windows.DeleteObject(handle). If the image uses
        ///       transparency, the background will be filled with the specified background
        ///       color.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IntPtr GetHbitmap() {
            return GetHbitmap(Color.LightGray);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.GetHbitmap1"]/*' />
        /// <devdoc>
        ///     Creates a Win32 HBITMAP out of the image.  You are responsible for
        ///     de-allocating the HBITMAP with Windows.DeleteObject(handle).
        ///     If the image uses transparency, the background will be filled with the specified background color.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IntPtr GetHbitmap(Color background) {
            IntPtr hBitmap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateHBITMAPFromBitmap(new HandleRef(this, nativeImage), out hBitmap, 
                                                             background.ToArgb());
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return hBitmap;
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.GetHicon"]/*' />
        /// <devdoc>
        ///    Returns the handle to an icon.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IntPtr GetHicon() {
            IntPtr hIcon = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateHICONFromBitmap(new HandleRef(this, nativeImage), out hIcon);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return hIcon;
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Bitmap11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Bitmap'/> class, from the specified
        ///       existing image, with the specified size.
        ///    </para>
        /// </devdoc>
        public Bitmap(Image original, Size newSize) : 
        this(original, (object) newSize != null ? newSize.Width : 0, (object) newSize != null ? newSize.Height : 0) {
        }

        // for use with CreateFromGDIplus
        private Bitmap() {
        }

        /*
         * Create a new bitmap object from a native bitmap handle.
         * This is only for internal purpose.
         */
        internal static Bitmap FromGDIplus(IntPtr handle) {
            Bitmap result = new Bitmap();
            result.SetNativeImage(handle);
            return result;
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Clone"]/*' />
        /// <devdoc>
        ///    Creates a copy of the section of this
        ///    Bitmap defined by <paramref term="rect"/> with a specified <see cref='System.Drawing.Imaging.PixelFormat'/>.
        /// </devdoc>
        // int version
        public Bitmap Clone(Rectangle rect, PixelFormat format) {
            IntPtr dstHandle = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBitmapAreaI(
                                                     rect.X,
                                                     rect.Y,
                                                     rect.Width,
                                                     rect.Height,
                                                     (int) format,
                                                     new HandleRef(this, nativeImage),
                                                     out dstHandle);

            if (status != SafeNativeMethods.Ok || dstHandle == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(status);

            return Bitmap.FromGDIplus(dstHandle);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.Clone1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of the section of this
        ///       Bitmap defined by <paramref term="rect"/> with a specified <see cref='System.Drawing.Imaging.PixelFormat'/>.
        ///    </para>
        /// </devdoc>
        // float version
        public Bitmap Clone(RectangleF rect, PixelFormat format) {
            IntPtr dstHandle = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBitmapArea(
                                                    rect.X,
                                                    rect.Y,
                                                    rect.Width,
                                                    rect.Height,
                                                    (int) format,
                                                    new HandleRef(this, nativeImage),
                                                    out dstHandle);

            if (status != SafeNativeMethods.Ok || dstHandle == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(status);

            return Bitmap.FromGDIplus(dstHandle);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.MakeTransparent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Makes the default transparent color transparent for this <see cref='System.Drawing.Bitmap'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public void MakeTransparent() {
            Color transparent = defaultTransparentColor;
            if (Height > 0 && Width > 0)
                transparent = GetPixel(0, Size.Height - 1);
            if (transparent.A < 255) {
                // It's already transparent, and if we proceeded, we will do something
                // unintended like making black transparent
                return;
            }
            MakeTransparent(transparent);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.MakeTransparent1"]/*' />
        /// <devdoc>
        ///    Makes the specified color transparent
        ///    for this <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public void MakeTransparent(Color transparentColor) {
            if (RawFormat.Guid == ImageFormat.Icon.Guid) {
                throw new InvalidOperationException(SR.GetString(SR.CantMakeIconTransparent));
            }

            Size size = Size;
            PixelFormat format = PixelFormat;

            // The new bitmap must be in 32bppARGB  format, because that's the only
            // thing that supports alpha.  (And that's what the image is initialized to -- transparent)
            Bitmap result = new Bitmap(size.Width, size.Height, PixelFormat.Format32bppArgb);
            Graphics graphics = Graphics.FromImage(result);
            graphics.Clear(Color.Transparent);
            Rectangle rectangle = new Rectangle(0,0, size.Width, size.Height);

            ImageAttributes attributes = new ImageAttributes();
            attributes.SetColorKey(transparentColor, transparentColor);
            graphics.DrawImage(this, rectangle,
                               0,0, size.Width, size.Height,
                               GraphicsUnit.Pixel, attributes, null, IntPtr.Zero);
            attributes.Dispose();
            graphics.Dispose();

            // Swap nativeImage pointers to make it look like we modified the image in place
            IntPtr temp = this.nativeImage;
            this.nativeImage = result.nativeImage;
            result.nativeImage = temp;
            result.Dispose();
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.LockBits"]/*' />
        /// <devdoc>
        ///    Locks a Bitmap into system memory.
        /// </devdoc>
        public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format) {
            BitmapData bitmapdata = new BitmapData();

            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipBitmapLockBits(new HandleRef(this, nativeImage), ref gprect,
                                                    flags, format, bitmapdata);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return bitmapdata;
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.UnlockBits"]/*' />
        /// <devdoc>
        ///    Unlocks this <see cref='System.Drawing.Bitmap'/> from system memory.
        /// </devdoc>
        public void UnlockBits(BitmapData bitmapdata) {
            int status = SafeNativeMethods.GdipBitmapUnlockBits(new HandleRef(this, nativeImage), bitmapdata);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.GetPixel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the color of the specified pixel
        ///       in this <see cref='System.Drawing.Bitmap'/>.
        ///    </para>
        /// </devdoc>
        public Color GetPixel(int x, int y) {

            int color = 0;

            int status = SafeNativeMethods.GdipBitmapGetPixel(new HandleRef(this, nativeImage), x, y, out color);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return Color.FromArgb(color);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.SetPixel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the color of the specified pixel in this <see cref='System.Drawing.Bitmap'/> .
        ///    </para>
        /// </devdoc>
        public void SetPixel(int x, int y, Color color) {
            if ((PixelFormat & PixelFormat.Indexed) != 0) {
                throw new Exception(SR.GetString(SR.GdiplusCannotSetPixelFromIndexedPixelFormat));
            }

            int status = SafeNativeMethods.GdipBitmapSetPixel(new HandleRef(this, nativeImage), x, y, color.ToArgb());

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Bitmap.uex' path='docs/doc[@for="Bitmap.SetResolution"]/*' />
        /// <devdoc>
        ///    Sets the resolution for this <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public void SetResolution(float xDpi, float yDpi) {
            int status = SafeNativeMethods.GdipBitmapSetResolution(new HandleRef(this, nativeImage), xDpi, yDpi);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\contentalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContentAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing.Design;

    /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies alignment of content on the drawing surface.
    ///    </para>
    /// </devdoc>
    [Editor("System.Drawing.Design.ContentAlignmentEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor))]
    public enum ContentAlignment {

        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.TopLeft"]/*' />
        /// <devdoc>
        ///    Content is vertically aligned at the top, and horizontally
        ///    aligned on the left.
        /// </devdoc>
        TopLeft = 0x001,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.TopCenter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned at the top, and
        ///       horizontally aligned at the center.
        ///    </para>
        /// </devdoc>
        TopCenter = 0x002,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.TopRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned at the top, and
        ///       horizontally aligned on the right.
        ///    </para>
        /// </devdoc>
        TopRight = 0x004,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.MiddleLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned in the middle, and
        ///       horizontally aligned on the left.
        ///    </para>
        /// </devdoc>
        MiddleLeft = 0x010,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.MiddleCenter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned in the middle, and
        ///       horizontally aligned at the center.
        ///    </para>
        /// </devdoc>
        MiddleCenter = 0x020,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.MiddleRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned in the middle, and horizontally aligned on the
        ///       right.
        ///    </para>
        /// </devdoc>
        MiddleRight = 0x040,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.BottomLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned at the bottom, and horizontally aligned on the
        ///       left.
        ///    </para>
        /// </devdoc>
        BottomLeft = 0x100,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.BottomCenter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned at the bottom, and horizontally aligned at the
        ///       center.
        ///    </para>
        /// </devdoc>
        BottomCenter = 0x200,
        /// <include file='doc\ContentAlignment.uex' path='docs/doc[@for="ContentAlignment.BottomRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Content is vertically aligned at the bottom, and horizontally aligned on the
        ///       right.
        ///    </para>
        /// </devdoc>
        BottomRight = 0x400,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\colorconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;
    using System.Threading;

    /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter"]/*' />
    /// <devdoc>
    ///      ColorConverter is a class that can be used to convert
    ///      colors from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class ColorConverter : TypeConverter {
        private static string ColorConstantsLock = "colorConstants";
        private static Hashtable colorConstants;
        private static string SystemColorConstantsLock = "systemColorConstants";
        private static Hashtable systemColorConstants;        
        private static string ValuesLock = "values";
        private static StandardValuesCollection values;        

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.ColorConverter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ColorConverter() {
        }               
               
        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.Colors"]/*' />
        /// <devdoc>
        ///      Hashtable of color / value pairs (color name is key)
        ///      for standard colors.
        /// </devdoc>
        private static Hashtable Colors {
            get {
                if (colorConstants == null) {
                    lock(ColorConstantsLock) {                        
                        if (colorConstants == null) {
                            Hashtable tempHash = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                            FillConstants(tempHash, typeof(Color));
                            colorConstants = tempHash;
                        }                            
                    }
                }
                
                return colorConstants;                
            }
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.SystemColors"]/*' />
        /// <devdoc>
        ///      Hashtable of color / value pairs (color name is key)
        ///      for system colors.
        /// </devdoc>
        private static Hashtable SystemColors {
            get {                
                if (systemColorConstants == null) {
                    lock (SystemColorConstantsLock) {
                        if (systemColorConstants == null) {                                                            
                            Hashtable tempHash = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                            FillConstants(tempHash, typeof(System.Drawing.SystemColors));
                            systemColorConstants = tempHash;
                        }                                
                    }                            
                }

                return systemColorConstants;                
            }
        }
               
        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        internal static object GetNamedColor(string name) {
            object color = null;
            // First, check to see if this is a standard name.
            //
            color = Colors[name];
            if (color != null) {
                return color;
            }
            // Ok, how about a system color?
            //
            color = SystemColors[name];
            return color;
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {

                object obj = null;
                string text = ((string)value).Trim();

                if (text.Length == 0) {
                    obj = Color.Empty;
                }
                else {
                    // First, check to see if this is a standard name.
                    //
                    obj = GetNamedColor(text);

                    if (obj == null) {
                        if (culture == null) {
                            culture = CultureInfo.CurrentCulture;
                        }
                                                
                        char sep = culture.TextInfo.ListSeparator[0];
                        bool tryMappingToKnownColor = true;
                        
                        TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));

                        // If the value is a 6 digit hex number only, then
                        // we want to treat the Alpha as 255, not 0
                        //
                        if (text.IndexOf(sep) == -1) {

                            if (text.Length > 2 && (text[0] == '\'' || text[0] == '"') && text[0] == text[text.Length -1]) {
                                // In quotes means a named value
                                string colorName = text.Substring(1, text.Length - 2);
                                obj = Color.FromName(colorName);
                                tryMappingToKnownColor = false;
                            }
                            else if (text.Length == 7 && text[0] == '#') {
                                obj = Color.FromArgb(unchecked((int)(0xFF000000 | (uint)(int)intConverter.ConvertFromString(context, culture, text))));
                            }
                            else if (text.Length == 8 && (text.StartsWith("0x") || text.StartsWith("0X"))) {
                                obj = Color.FromArgb(unchecked((int)(0xFF000000 | (uint)(int)intConverter.ConvertFromString(context, culture, text))));
                            }
                            else if (text.Length == 8 && (text.StartsWith("&h") || text.StartsWith("&H"))) {
                                obj = Color.FromArgb(unchecked((int)(0xFF000000 | (uint)(int)intConverter.ConvertFromString(context, culture, text))));
                            }
                        }

                        // Nope.  Parse the RGBA from the text.
                        //
                        if (obj == null) {
                            string[] tokens = text.Split(new char[] {sep});
                            int[] values = new int[tokens.Length];
                            for (int i = 0; i < values.Length; i++) {
                                values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                            }

                            // We should now have a number of parsed integer values.
                            // We support 1, 3, or 4 arguments:
                            //
                            // 1 -- full ARGB encoded
                            // 3 -- RGB
                            // 4 -- ARGB
                            //
                            switch (values.Length) {
                                case 1:
                                    obj = Color.FromArgb(values[0]);
                                    break;

                                case 3:
                                    obj = Color.FromArgb(values[0], values[1], values[2]);
                                    break;

                                case 4:
                                    obj = Color.FromArgb(values[0], values[1], values[2], values[3]);
                                    break;
                            }
                            tryMappingToKnownColor = true;
                        }

                        if ((obj != null) && tryMappingToKnownColor) {

                            // Now check to see if this color matches one of our known colors.
                            // If it does, then substitute it.  We can only do this for "Colors"
                            // because system colors morph with user settings.
                            //
                            int targetARGB = ((Color)obj).ToArgb();

                            foreach (Color c in Colors.Values) {
                                if (c.ToArgb() == targetARGB) {
                                    obj = c;
                                    break;
                                }
                            }
                        }
                    }

                    if (obj == null) {
                        throw new ArgumentException(SR.GetString(SR.InvalidColor, text));
                    }
                }
                return obj;
            }
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is Color) {
                Color c = (Color)value;

                if (c == Color.Empty) {
                    return string.Empty;
                }
                else {
                    // If this is a known color, then Color can provide its own
                    // name.  Otherwise, we fabricate an ARGB value for it.
                    //
                    if (c.IsKnownColor) {
                        return c.Name;
                    }
                    else if (c.IsNamedColor) {
                        return "'" + c.Name + "'";
                    }
                    else {
                        if (culture == null) {
                            culture = CultureInfo.CurrentCulture;
                        }
                        string sep = culture.TextInfo.ListSeparator + " ";
                        TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                        string[] args;
                        int nArg = 0;

                        if (c.A < 255) {
                            args = new string[4];
                            args[nArg++] = intConverter.ConvertToString(context, culture, (object)c.A);
                        }
                        else {
                            args = new string[3];
                        }

                        args[nArg++] = intConverter.ConvertToString(context, culture, (object)c.R);
                        args[nArg++] = intConverter.ConvertToString(context, culture, (object)c.G);
                        args[nArg++] = intConverter.ConvertToString(context, culture, (object)c.B);

                        // Now slam all of these together with the fantastic Join 
                        // method.
                        //
                        return string.Join(sep, args);
                    }
                }
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Color) {
                MemberInfo member = null;
                object[] args = null;
                
                Color c = (Color)value;

                if (c.IsEmpty) {
                    member = typeof(Color).GetField("Empty");
                }
                else if (c.IsSystemColor) {
                    member = typeof(SystemColors).GetProperty(c.Name);
                }
                else if (c.IsKnownColor) {
                    member = typeof(Color).GetProperty(c.Name);
                }
                else if (c.A != 255) {
                    member = typeof(Color).GetMethod("FromArgb", new Type[] {typeof(int), typeof(int), typeof(int), typeof(int)});
                    args = new object[] {c.A, c.R, c.G, c.B};
                }
                else if (c.IsNamedColor) {
                    member = typeof(Color).GetMethod("FromName", new Type[] {typeof(string)});
                    args = new object[] {c.Name};
                }
                else {
                    member = typeof(Color).GetMethod("FromArgb", new Type[] {typeof(int), typeof(int), typeof(int)});
                    args = new object[] {c.R, c.G, c.B};
                }
                
                Debug.Assert(member != null, "Could not convert color to member.  Did someone change method name / signature and not update Colorconverter?");
                if (member != null) {
                    return new InstanceDescriptor(member, args);
                }
                else {
                    return null;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.FillConstants"]/*' />
        /// <devdoc>
        ///      Fills the given hashtable with field name / value pairs.  It walks all public static
        ///      properties of enumType that have a property type of Color.
        /// </devdoc>
        private static void FillConstants(Hashtable hash, Type enumType) {
            MethodAttributes attrs = MethodAttributes.Public | MethodAttributes.Static;
            PropertyInfo[] props = enumType.GetProperties();

            for (int i = 0; i < props.Length; i++) {
                PropertyInfo prop = props[i];
                if (prop.PropertyType == typeof(Color)) {
                    MethodInfo method = prop.GetGetMethod();
                    if (method != null && (method.Attributes & attrs) == attrs) {
                        object[] tempIndex = null;
                        hash[prop.Name] = prop.GetValue(null, tempIndex);
                    }
                }
            }            
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {                            
                lock (ValuesLock) {
                    if (values == null) {
   
                       // We must take the value from each hashtable and combine them.
                       //
                       ArrayList arrayValues = new ArrayList();
                       arrayValues.AddRange(Colors.Values);
                       arrayValues.AddRange(SystemColors.Values);
       
                       // Now, we have a couple of colors that have the same names but
                       // are identical values.  Look for these and remove them.  Too
                       // bad this is n^2.
                       //
                       int count = arrayValues.Count;
                       for (int i = 0; i < count - 1; i++) {
                           for (int j = i + 1; j < count; j++) {
                               if (arrayValues[i].Equals(arrayValues[j])) {
                                   // Remove this item!
                                   //
                                   arrayValues.RemoveAt(j);
                                   count--;
                                   j--;
                               }
                           }
                       }
       
                       // Sort the array.
                       //
                       arrayValues.Sort(0, arrayValues.Count, new ColorComparer());
                       values = new StandardValuesCollection(arrayValues.ToArray());
                    }                       
                }
            }

            return values;
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\ColorConverter.uex' path='docs/doc[@for="ColorConverter.ColorComparer"]/*' />
        /// <devdoc>
        ///      IComparer for color values.  This takes color values but compares their
        ///      names.
        /// </devdoc>
        private class ColorComparer : IComparer {

            public int Compare(object left, object right) {
                Color cLeft = (Color)left;
                Color cRight = (Color)right;
                return string.Compare(cLeft.Name, cRight.Name, false, CultureInfo.InvariantCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\color.cs ===
//------------------------------------------------------------------------------
// <copyright file="Color.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\Color.uex' path='docs/doc[@for="Color"]/*' />
    /// <devdoc>
    ///    Represents an ARGB color.
    /// </devdoc>
    [
    Serializable(),
    TypeConverter(typeof(ColorConverter)),
    Editor("System.Drawing.Design.ColorEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
    StructLayout(LayoutKind.Explicit, CharSet=CharSet.Auto),
    ComVisible(true)
    ]
    public struct Color {
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Color Empty = new Color();

        // -------------------------------------------------------------------
        //  static list of "web" colors...
        //
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Transparent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Transparent {
            get {
                return new Color(KnownColor.Transparent);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.AliceBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color AliceBlue {
            get {
                return new Color(KnownColor.AliceBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.AntiqueWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color AntiqueWhite {
            get {
                return new Color(KnownColor.AntiqueWhite);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Aqua"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Aqua {
            get {
                return new Color(KnownColor.Aqua);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Aquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Aquamarine {
            get {
                return new Color(KnownColor.Aquamarine);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Azure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Azure {
            get {
                return new Color(KnownColor.Azure);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Beige"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Beige {
            get {
                return new Color(KnownColor.Beige);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Bisque"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Bisque {
            get {
                return new Color(KnownColor.Bisque);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Black"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Black {
            get {
                return new Color(KnownColor.Black);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.BlanchedAlmond"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color BlanchedAlmond {
            get {
                return new Color(KnownColor.BlanchedAlmond);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Blue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Blue {
            get {
                return new Color(KnownColor.Blue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.BlueViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color BlueViolet {
            get {
                return new Color(KnownColor.BlueViolet);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Brown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Brown {
            get {
                return new Color(KnownColor.Brown);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.BurlyWood"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color BurlyWood {
            get {
                return new Color(KnownColor.BurlyWood);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.CadetBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color CadetBlue {
            get {
                return new Color(KnownColor.CadetBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Chartreuse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Chartreuse {
            get {
                return new Color(KnownColor.Chartreuse);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Chocolate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Chocolate {
            get {
                return new Color(KnownColor.Chocolate);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Coral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Coral {
            get {
                return new Color(KnownColor.Coral);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.CornflowerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color CornflowerBlue {
            get {
                return new Color(KnownColor.CornflowerBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Cornsilk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Cornsilk {
            get {
                return new Color(KnownColor.Cornsilk);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Crimson"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Crimson {
            get {
                return new Color(KnownColor.Crimson);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Cyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Cyan {
            get {
                return new Color(KnownColor.Cyan);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkBlue {
            get {
                return new Color(KnownColor.DarkBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkCyan {
            get {
                return new Color(KnownColor.DarkCyan);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkGoldenrod {
            get {
                return new Color(KnownColor.DarkGoldenrod);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkGray {
            get {
                return new Color(KnownColor.DarkGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkGreen {
            get {
                return new Color(KnownColor.DarkGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkKhaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkKhaki {
            get {
                return new Color(KnownColor.DarkKhaki);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkMagenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkMagenta {
            get {
                return new Color(KnownColor.DarkMagenta);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkOliveGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkOliveGreen {
            get {
                return new Color(KnownColor.DarkOliveGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkOrange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkOrange {
            get {
                return new Color(KnownColor.DarkOrange);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkOrchid {
            get {
                return new Color(KnownColor.DarkOrchid);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkRed {
            get {
                return new Color(KnownColor.DarkRed);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkSalmon {
            get {
                return new Color(KnownColor.DarkSalmon);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkSeaGreen {
            get {
                return new Color(KnownColor.DarkSeaGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkSlateBlue {
            get {
                return new Color(KnownColor.DarkSlateBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkSlateGray {
            get {
                return new Color(KnownColor.DarkSlateGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkTurquoise {
            get {
                return new Color(KnownColor.DarkTurquoise);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DarkViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DarkViolet {
            get {
                return new Color(KnownColor.DarkViolet);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DeepPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DeepPink {
            get {
                return new Color(KnownColor.DeepPink);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DeepSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DeepSkyBlue {
            get {
                return new Color(KnownColor.DeepSkyBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DimGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DimGray {
            get {
                return new Color(KnownColor.DimGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.DodgerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color DodgerBlue {
            get {
                return new Color(KnownColor.DodgerBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Firebrick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Firebrick {
            get {
                return new Color(KnownColor.Firebrick);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FloralWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color FloralWhite {
            get {
                return new Color(KnownColor.FloralWhite);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.ForestGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color ForestGreen {
            get {
                return new Color(KnownColor.ForestGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Fuchsia"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Fuchsia {
            get {
                return new Color(KnownColor.Fuchsia);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Gainsboro"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Gainsboro {
            get {
                return new Color(KnownColor.Gainsboro);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GhostWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color GhostWhite {
            get {
                return new Color(KnownColor.GhostWhite);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Gold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Gold {
            get {
                return new Color(KnownColor.Gold);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Goldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Goldenrod {
            get {
                return new Color(KnownColor.Goldenrod);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Gray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Gray {
            get {
                return new Color(KnownColor.Gray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Green"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Green {
            get {
                return new Color(KnownColor.Green);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GreenYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color GreenYellow {
            get {
                return new Color(KnownColor.GreenYellow);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Honeydew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Honeydew {
            get {
                return new Color(KnownColor.Honeydew);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.HotPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color HotPink {
            get {
                return new Color(KnownColor.HotPink);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.IndianRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color IndianRed {
            get {
                return new Color(KnownColor.IndianRed);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Indigo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Indigo {
            get {
                return new Color(KnownColor.Indigo);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Ivory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Ivory {
            get {
                return new Color(KnownColor.Ivory);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Khaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Khaki {
            get {
                return new Color(KnownColor.Khaki);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Lavender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Lavender {
            get {
                return new Color(KnownColor.Lavender);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LavenderBlush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LavenderBlush {
            get {
                return new Color(KnownColor.LavenderBlush);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LawnGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LawnGreen {
            get {
                return new Color(KnownColor.LawnGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LemonChiffon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LemonChiffon {
            get {
                return new Color(KnownColor.LemonChiffon);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightBlue {
            get {
                return new Color(KnownColor.LightBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightCoral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightCoral {
            get {
                return new Color(KnownColor.LightCoral);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightCyan {
            get {
                return new Color(KnownColor.LightCyan);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightGoldenrodYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightGoldenrodYellow {
            get {
                return new Color(KnownColor.LightGoldenrodYellow);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightGreen {
            get {
                return new Color(KnownColor.LightGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightGray {
            get {
                return new Color(KnownColor.LightGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightPink {
            get {
                return new Color(KnownColor.LightPink);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightSalmon {
            get {
                return new Color(KnownColor.LightSalmon);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightSeaGreen {
            get {
                return new Color(KnownColor.LightSeaGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightSkyBlue {
            get {
                return new Color(KnownColor.LightSkyBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightSlateGray {
            get {
                return new Color(KnownColor.LightSlateGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightSteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightSteelBlue {
            get {
                return new Color(KnownColor.LightSteelBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LightYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LightYellow {
            get {
                return new Color(KnownColor.LightYellow);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Lime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Lime {
            get {
                return new Color(KnownColor.Lime);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.LimeGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color LimeGreen {
            get {
                return new Color(KnownColor.LimeGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Linen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Linen {
            get {
                return new Color(KnownColor.Linen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Magenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Magenta {
            get {
                return new Color(KnownColor.Magenta);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Maroon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Maroon {
            get {
                return new Color(KnownColor.Maroon);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumAquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumAquamarine {
            get {
                return new Color(KnownColor.MediumAquamarine);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumBlue {
            get {
                return new Color(KnownColor.MediumBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumOrchid {
            get {
                return new Color(KnownColor.MediumOrchid);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumPurple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumPurple {
            get {
                return new Color(KnownColor.MediumPurple);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumSeaGreen {
            get {
                return new Color(KnownColor.MediumSeaGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumSlateBlue {
            get {
                return new Color(KnownColor.MediumSlateBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumSpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumSpringGreen {
            get {
                return new Color(KnownColor.MediumSpringGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumTurquoise {
            get {
                return new Color(KnownColor.MediumTurquoise);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MediumVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MediumVioletRed {
            get {
                return new Color(KnownColor.MediumVioletRed);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MidnightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MidnightBlue {
            get {
                return new Color(KnownColor.MidnightBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MintCream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MintCream {
            get {
                return new Color(KnownColor.MintCream);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MistyRose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color MistyRose {
            get {
                return new Color(KnownColor.MistyRose);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Moccasin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Moccasin {
            get {
                return new Color(KnownColor.Moccasin);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.NavajoWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color NavajoWhite {
            get {
                return new Color(KnownColor.NavajoWhite);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Navy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Navy {
            get {
                return new Color(KnownColor.Navy);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.OldLace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color OldLace {
            get {
                return new Color(KnownColor.OldLace);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Olive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Olive {
            get {
                return new Color(KnownColor.Olive);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.OliveDrab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color OliveDrab {
            get {
                return new Color(KnownColor.OliveDrab);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Orange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Orange {
            get {
                return new Color(KnownColor.Orange);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.OrangeRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color OrangeRed {
            get {
                return new Color(KnownColor.OrangeRed);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Orchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Orchid {
            get {
                return new Color(KnownColor.Orchid);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PaleGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PaleGoldenrod {
            get {
                return new Color(KnownColor.PaleGoldenrod);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PaleGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PaleGreen {
            get {
                return new Color(KnownColor.PaleGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PaleTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PaleTurquoise {
            get {
                return new Color(KnownColor.PaleTurquoise);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PaleVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PaleVioletRed {
            get {
                return new Color(KnownColor.PaleVioletRed);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PapayaWhip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PapayaWhip {
            get {
                return new Color(KnownColor.PapayaWhip);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PeachPuff"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PeachPuff {
            get {
                return new Color(KnownColor.PeachPuff);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Peru"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Peru {
            get {
                return new Color(KnownColor.Peru);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Pink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Pink {
            get {
                return new Color(KnownColor.Pink);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Plum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Plum {
            get {
                return new Color(KnownColor.Plum);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.PowderBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color PowderBlue {
            get {
                return new Color(KnownColor.PowderBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Purple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Purple {
            get {
                return new Color(KnownColor.Purple);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Red"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Red {
            get {
                return new Color(KnownColor.Red);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.RosyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color RosyBrown {
            get {
                return new Color(KnownColor.RosyBrown);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.RoyalBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color RoyalBlue {
            get {
                return new Color(KnownColor.RoyalBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SaddleBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SaddleBrown {
            get {
                return new Color(KnownColor.SaddleBrown);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Salmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Salmon {
            get {
                return new Color(KnownColor.Salmon);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SandyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SandyBrown {
            get {
                return new Color(KnownColor.SandyBrown);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SeaGreen {
            get {
                return new Color(KnownColor.SeaGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SeaShell"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SeaShell {
            get {
                return new Color(KnownColor.SeaShell);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Sienna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Sienna {
            get {
                return new Color(KnownColor.Sienna);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Silver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Silver {
            get {
                return new Color(KnownColor.Silver);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SkyBlue {
            get {
                return new Color(KnownColor.SkyBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SlateBlue {
            get {
                return new Color(KnownColor.SlateBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SlateGray {
            get {
                return new Color(KnownColor.SlateGray);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Snow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Snow {
            get {
                return new Color(KnownColor.Snow);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SpringGreen {
            get {
                return new Color(KnownColor.SpringGreen);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.SteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color SteelBlue {
            get {
                return new Color(KnownColor.SteelBlue);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Tan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Tan {
            get {
                return new Color(KnownColor.Tan);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Teal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Teal {
            get {
                return new Color(KnownColor.Teal);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Thistle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Thistle {
            get {
                return new Color(KnownColor.Thistle);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Tomato"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Tomato {
            get {
                return new Color(KnownColor.Tomato);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Turquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Turquoise {
            get {
                return new Color(KnownColor.Turquoise);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Violet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Violet {
            get {
                return new Color(KnownColor.Violet);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Wheat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Wheat {
            get {
                return new Color(KnownColor.Wheat);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.White"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color White {
            get {
                return new Color(KnownColor.White);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.WhiteSmoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color WhiteSmoke {
            get {
                return new Color(KnownColor.WhiteSmoke);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Yellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color Yellow {
            get {
                return new Color(KnownColor.Yellow);
            }
        }
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.YellowGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Color YellowGreen {
            get {
                return new Color(KnownColor.YellowGreen);
            }
        }
        //
        //  end "web" colors
        // -------------------------------------------------------------------

        // NOTE : The "zero" pattern (all members being 0) must represent
        //      : "not set". This allows "Color c;" to be correct.

        private static short StateKnownColorValid   = 0x0001;
        private static short StateARGBValueValid    = 0x0002;
        private static short StateValueMask         = (short)(StateARGBValueValid);
        private static short StateNameValid         = 0x0008;
        private static long NotDefinedValue = 0;

        /**
         * Shift count and bit mask for A, R, G, B components in ARGB mode!
         */
        private const int ARGBAlphaShift  = 24;
        private const int ARGBRedShift    = 16;
        private const int ARGBGreenShift  = 8;
        private const int ARGBBlueShift   = 0;

        ///    WARNING!!! WARNING!!! WARNING!!! WARNING!!! 
        ///    WARNING!!! WARNING!!! WARNING!!! WARNING!!!
        ///    We can never change the layout of this class (adding or removing or changing the 
        ///    order of member variables) if you want to be compatible v1.0 version of the runtime.
        ///    This is so that we can push into the runtime a custom marshaller for OLE_COLOR to Color.

        // will contain standard 32bit sRGB (ARGB)
        //
        [System.Runtime.InteropServices.FieldOffset(0)]
        private readonly long value;

        // ignored, unless "state" says it is valid
        //
        [System.Runtime.InteropServices.FieldOffset(8)]
        private readonly short knownColor;

        // implementation specific information
        //
        [System.Runtime.InteropServices.FieldOffset(10)]
        private readonly short state;

        // user supplied name of color. Will not be filled in if
        // we map to a "knowncolor"
        //
        [System.Runtime.InteropServices.FieldOffset(12)]
        private readonly string name;

        internal Color(KnownColor knownColor) {
            value = 0;
            state = StateKnownColorValid;
            name = null;
            this.knownColor = (short)knownColor;
        }

        private Color(long value, short state, string name, KnownColor knownColor) {
            this.value = value;
            this.state = state;
            this.name = name;
            this.knownColor = (short)knownColor;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.R"]/*' />
        /// <devdoc>
        ///    Gets the red component value for this <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public byte R {
            get {
                return(byte)((Value >> ARGBRedShift) & 0xFF);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.G"]/*' />
        /// <devdoc>
        ///    Gets the green component value for this <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public byte G {
            get {
                return(byte)((Value >> ARGBGreenShift) & 0xFF);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.B"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the blue component value for this <see cref='System.Drawing.Color'/>.
        ///    </para>
        /// </devdoc>
        public byte B {
            get {
                return(byte)((Value >> ARGBBlueShift) & 0xFF);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.A"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the alpha component value for this <see cref='System.Drawing.Color'/>.
        ///    </para>
        /// </devdoc>
        public byte A {
            get {
                return(byte)((Value >> ARGBAlphaShift) & 0xFF);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.IsKnownColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies whether this <see cref='System.Drawing.Color'/> is a known (predefined) color.
        ///       Predefined colors are defined in the <see cref='System.Drawing.KnownColor'/>
        ///       enum.
        ///    </para>
        /// </devdoc>
        public bool IsKnownColor {
            get {
                return((state & StateKnownColorValid) != 0);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.IsEmpty"]/*' />
        /// <devdoc>
        ///    Specifies whether this <see cref='System.Drawing.Color'/> is uninitialized.
        /// </devdoc>
        public bool IsEmpty {
            get {
                return state == 0;
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.IsNamedColor"]/*' />
        /// <devdoc>
        ///    Specifies whether this <see cref='System.Drawing.Color'/> has a name or is a <see cref='System.Drawing.KnownColor'/>.
        /// </devdoc>
        public bool IsNamedColor {
            get {
                return ((state & StateNameValid) != 0) || IsKnownColor;
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.IsSystemColor"]/*' />
        /// <devdoc>
        ///     Determines if this color is a system color.
        /// </devdoc>
        public bool IsSystemColor {
            get {
                return IsKnownColor && ((KnownColor) knownColor) <= KnownColor.WindowText;
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of this <see cref='System.Drawing.Color'/> . This will either return the user
        ///       defined name of the color, if the color was created from a name, or
        ///       the name of the known color. For custom colors, the RGB value will
        ///       be returned.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                if ((state & StateNameValid) != 0) {
                    return name;
                }

                if (IsKnownColor) {
                    // first try the table so we can avoid the (slow!) .ToString()
                    string tablename = KnownColorTable.KnownColorToName((KnownColor) knownColor);
                    if (tablename != null)
                        return tablename;

                    Debug.Assert(false, "Could not find known color '" + ((KnownColor) knownColor) + "' in the KnownColorTable");
                    
                    return ((KnownColor)knownColor).ToString();
                }

                // if we reached here, just encode the value
                //
                return Convert.ToString(value, 16);
            }
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Value"]/*' />
        /// <devdoc>
        ///     Actual color to be rendered.
        /// </devdoc>
        private long Value {
            get {
                if ((state & StateValueMask) != 0) {
                    return value;
                }
                if (IsKnownColor) {
                    return(int)KnownColorTable.KnownColorToArgb((KnownColor)knownColor);
                }

                return NotDefinedValue;
            }
        }

        private static void CheckByte(int value, string name) {
            if (value < 0 || value > 255)
                throw new ArgumentException(SR.GetString(SR.InvalidEx2BoundArgument, name, value, 0, 255));
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.MakeArgb"]/*' />
        /// <devdoc>
        ///     Encodes the four values into ARGB (32 bit) format.
        /// </devdoc>
        private static long MakeArgb(byte alpha, byte red, byte green, byte blue) {
            return(long)((uint)(red << ARGBRedShift |
                         green << ARGBGreenShift | 
                         blue << ARGBBlueShift | 
                         alpha << ARGBAlphaShift)) & 0xffffffff;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a Color from its 32-bit component
        ///       (alpha, red, green, and blue) values.
        ///    </para>
        /// </devdoc>
        public static Color FromArgb(int argb) {
            return new Color((long)argb & 0xffffffff, StateARGBValueValid, null, (KnownColor)0);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromArgb1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a Color from its 32-bit component (alpha, red,
        ///       green, and blue) values.
        ///    </para>
        /// </devdoc>
        public static Color FromArgb(int alpha, int red, int green, int blue) {
            CheckByte(alpha, "alpha");
            CheckByte(red, "red");
            CheckByte(green, "green");
            CheckByte(blue, "blue");
            return new Color(MakeArgb((byte) alpha, (byte) red, (byte) green, (byte) blue), StateARGBValueValid, null, (KnownColor)0);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromArgb2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Drawing.Color'/> from the specified <see cref='System.Drawing.Color'/>, but with
        ///       the new specified alpha value.
        ///    </para>
        /// </devdoc>
        public static Color FromArgb(int alpha, Color baseColor) {
            CheckByte(alpha, "alpha");
            return new Color(MakeArgb((byte) alpha, baseColor.R, baseColor.G, baseColor.B), StateARGBValueValid, null, (KnownColor)0);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromArgb3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Color'/> from the specified red, green, and
        ///       blue values.
        ///    </para>
        /// </devdoc>
        public static Color FromArgb(int red, int green, int blue) {
            return FromArgb(255, red, green, blue);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromKnownColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Color'/> from the specified <see cref='System.Drawing.KnownColor'/> .
        ///    </para>
        /// </devdoc>
        public static Color FromKnownColor(KnownColor color) {
            return new Color(color);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.FromName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Color'/> with the specified name.
        ///    </para>
        /// </devdoc>
        public static Color FromName(string name) {
            // try to get a known color first
            object color = ColorConverter.GetNamedColor(name);
            if (color != null) {
                return (Color)color;
            }
            // otherwise treat it as a named color
            return new Color(NotDefinedValue, StateNameValid, name, (KnownColor)0);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GetBrightness"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the Hue-Saturation-Brightness (HSB) brightness
        ///       for this <see cref='System.Drawing.Color'/> .
        ///    </para>
        /// </devdoc>
        public float GetBrightness() {
            float r = (float)R / 255.0f;
            float g = (float)G / 255.0f;
            float b = (float)B / 255.0f;

            float max, min;

            max = r; min = r;

            if (g > max) max = g;
            if (b > max) max = b;

            if (g < min) min = g;
            if (b < min) min = b;

            return(max + min) / 2;
        }


        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GetHue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the Hue-Saturation-Brightness (HSB) hue
        ///       value, in degrees, for this <see cref='System.Drawing.Color'/> .  
        ///       If R == G == B, the hue is meaningless, and the return value is 0.
        ///    </para>
        /// </devdoc>
        public Single GetHue() {
            if (R == G && G == B)
                return 0; // 0 makes as good an UNDEFINED value as any
            
            float r = (float)R / 255.0f;
            float g = (float)G / 255.0f;
            float b = (float)B / 255.0f;

            float max, min;
            float delta;
            float hue = 0.0f;

            max = r; min = r;

            if (g > max) max = g;
            if (b > max) max = b;

            if (g < min) min = g;
            if (b < min) min = b;

            delta = max - min;

            if (r == max) {
                hue = (g - b) / delta;
            }
            else if (g == max) {
                hue = 2 + (b - r) / delta;
            }
            else if (b == max) {
                hue = 4 + (r - g) / delta;
            }
            hue *= 60;

            if (hue < 0.0f) {
                hue += 360.0f;
            }
            return hue;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GetSaturation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The Hue-Saturation-Brightness (HSB) saturation for this
        ///    <see cref='System.Drawing.Color'/>
        ///    .
        /// </para>
        /// </devdoc>
        public float GetSaturation() {
            float r = (float)R / 255.0f;
            float g = (float)G / 255.0f;
            float b = (float)B / 255.0f;

            float max, min;
            float l, s = 0;

            max = r; min = r;

            if (g > max) max = g;
            if (b > max) max = b;

            if (g < min) min = g;
            if (b < min) min = b;

            // if max == min, then there is no color and
            // the saturation is zero.
            //
            if (max != min) {
                l = (max + min) / 2;

                if (l <= .5) {
                    s = (max - min)/(max + min);
                }
                else {
                    s = (max - min)/(2 - max - min);
                }
            }
            return s;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.ToArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the ARGB value of this <see cref='System.Drawing.Color'/> .
        ///    </para>
        /// </devdoc>
        public int ToArgb() {
            return(int)Value;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.ToKnownColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.KnownColor'/> value for this color, if it is
        ///       based on a <see cref='System.Drawing.KnownColor'/> .
        ///    </para>
        /// </devdoc>
        public KnownColor ToKnownColor() {
            return(KnownColor)knownColor;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.ToString"]/*' />
        /// <devdoc>
        ///    Converts this <see cref='System.Drawing.Color'/> to a human-readable
        ///    string.
        /// </devdoc>
        public override string ToString() {
            StringBuilder sb = new StringBuilder(32);
            sb.Append(GetType().Name);
            sb.Append(" [");

            if ((state & StateNameValid) != 0) {
                sb.Append(Name);
            }
            else if ((state & StateKnownColorValid) != 0) {
                sb.Append(Name);
            }
            else if ((state & StateValueMask) != 0) {
                sb.Append("A=");
                sb.Append(A);
                sb.Append(", R=");
                sb.Append(R);
                sb.Append(", G=");
                sb.Append(G);
                sb.Append(", B=");
                sb.Append(B);
            }
            else {
                sb.Append("Empty");
            }


            sb.Append("]");

            return sb.ToString();
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two specified <see cref='System.Drawing.Color'/> objects
        ///       are equivalent.
        ///    </para>
        /// </devdoc>
        public static bool operator ==(Color left, Color right) {
            if (left.value == right.value
                && left.state == right.state
                && left.knownColor == right.knownColor) {

                if (left.name == right.name) {
                    return true;
                }

                if (left.name == (object) null || right.name == (object) null) {
                    return false;
                }

                return left.name.Equals(right.name);
            }

            return false;
        }
        
        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two specified <see cref='System.Drawing.Color'/> objects
        ///       are equivalent.
        ///    </para>
        /// </devdoc>
        public static bool operator !=(Color left, Color right) {
            return !(left == right);
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.Equals"]/*' />
        /// <devdoc>
        ///    Tests whether the specified object is a
        /// <see cref='System.Drawing.Color'/> 
        /// and is equivalent to this <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj is Color) {
                Color right = (Color)obj;
                if (value == right.value
                    && state == right.state
                    && knownColor == right.knownColor) {

                    if (name == right.name) {
                        return true;
                    }

                    if (name == (object) null || right.name == (object) null) {
                        return false;
                    }

                    return name.Equals(name);
                }
            }
            return false;
        }

        /// <include file='doc\Color.uex' path='docs/doc[@for="Color.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return  value.GetHashCode() ^
                    state.GetHashCode() ^
                    knownColor.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\graphics.cs ===
//------------------------------------------------------------------------------
// <copyright file="Graphics.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//#define FINALIZATION_WATCH

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   graphics.cs
*
* Abstract:
*
*   Wrapper class for graphics context in GDI+
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Drawing.Internal;
    using System.Drawing.Imaging;
    using System.Drawing.Text;
    using System.Drawing.Drawing2D;

    /**
     * Represent a graphics drawing context
     */
    /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics"]/*' />
    /// <devdoc>
    ///    Encapsulates a GDI+ drawing surface.
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public sealed class Graphics : MarshalByRefObject, IDisposable {

#if FINALIZATION_WATCH
        static readonly TraceSwitch GraphicsFinalization = new TraceSwitch("GraphicsFinalization", "Tracks the creation and destruction of finalization");
        internal static string GetAllocationStack() {
            if (GraphicsFinalization.TraceVerbose) {
                return Environment.StackTrace;
            }
            else {
                return "Enabled 'GraphicsFinalization' switch to see stack of allocation";
            }
        }
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        /**
        * Handle to native Graphics context
        */
        internal IntPtr nativeGraphics;

         // GDI+'s preferred HPALETTE.  Since GDI+ gave it to us, I guess they get to free it.
        private static IntPtr halftonePalette;

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImageAbort"]/*' />
        /// <devdoc>
        /// </devdoc>
#if !CPB        // cpb 50004
        [ComVisible(false)]
#endif
        public delegate bool DrawImageAbort(IntPtr callbackdata);

        // Callback for EnumerateMetafile methods.  The parameters are:

        //      recordType      (if >= MinRecordType, it's an EMF+ record)
        //      flags           (always 0 for EMF records)
        //      dataSize        size of the data, or 0 if no data
        //      data            pointer to the data, or NULL if no data (UINT32 aligned)
        //      callbackData    pointer to callbackData, if any

        // This method can then call Metafile.PlayRecord to play the
        // record that was just enumerated.  If this method  returns
        // FALSE, the enumeration process is aborted.  Otherwise, it continues.        

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafileProc"]/*' />
        /// <devdoc>
        /// </devdoc>
#if !CPB        // cpb 50004
        [ComVisible(false)]
#endif
        public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, 
                                                   int flags,
                                                   int dataSize,
                                                   IntPtr data,
                                                   PlayRecordCallback callbackData);

        private Graphics(IntPtr nativeGraphics) {
            this.nativeGraphics = nativeGraphics;

            if (nativeGraphics == IntPtr.Zero)
                throw new ArgumentNullException("nativeGraphics");

            
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromHdc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Drawing.Graphics'/> class from the specified
        ///       handle to a device context.
        ///    </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Graphics FromHdc(IntPtr hdc) {
            IntSecurity.ObjectFromWin32Handle.Demand();
            return FromHdcInternal(hdc);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromHdcInternal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Graphics FromHdcInternal(IntPtr hdc) {
            Debug.Assert(hdc != IntPtr.Zero, "Must pass in a valid DC");
            IntPtr nativeGraphics = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateFromHDC(new HandleRef(null, hdc), out nativeGraphics);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Graphics(nativeGraphics);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromHdc1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the Graphics class from the
        ///       specified handle to
        ///       a device context and handle to a device.
        ///    </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            Debug.Assert(hdc != IntPtr.Zero, "Must pass in a valid DC");
            Debug.Assert(hdevice != IntPtr.Zero, "Must pass in a valid device");
            IntPtr nativeGraphics = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateFromHDC2(new HandleRef(null, hdc), new HandleRef(null, hdevice), out nativeGraphics);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);


            return new Graphics(nativeGraphics);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromHwnd"]/*' />
        /// <devdoc>
        ///    Creates a new instance of the <see cref='System.Drawing.Graphics'/> class
        ///    from a window handle.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Graphics FromHwnd(IntPtr hwnd) {
            IntSecurity.ObjectFromWin32Handle.Demand();
            return FromHwndInternal(hwnd);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromHwndInternal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Graphics FromHwndInternal(IntPtr hwnd) {
            IntPtr nativeGraphics = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateFromHWND(new HandleRef(null, hwnd), out nativeGraphics);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Graphics(nativeGraphics);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FromImage"]/*' />
        /// <devdoc>
        ///    Creates an instance of the <see cref='System.Drawing.Graphics'/> class
        ///    from an existing <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public static Graphics FromImage(Image image) {
            if (image == null)
                throw new ArgumentNullException("image");

            if ((image.PixelFormat & PixelFormat.Indexed) != 0) {
                throw new Exception(SR.GetString(SR.GdiplusCannotCreateGraphicsFromIndexedPixelFormat));
            }

            IntPtr nativeGraphics = IntPtr.Zero;

            int status = SafeNativeMethods.GdipGetImageGraphicsContext(new HandleRef(image, image.nativeImage),
                                                             out nativeGraphics);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Graphics(nativeGraphics);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.GetHdc"]/*' />
        /// <devdoc>
        ///    Gets the handle for the device context
        ///    associated with this <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IntPtr GetHdc() {
            IntPtr hdc = IntPtr.Zero;

            int status = SafeNativeMethods.GdipGetDC(new HandleRef(this, nativeGraphics), out hdc);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return hdc;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ReleaseHdc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Releases the memory allocated for the handle to a device context.
        ///    </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void ReleaseHdc(IntPtr hdc) {
            IntSecurity.Win32HandleManipulation.Demand();
            ReleaseHdcInternal(hdc);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ReleaseHdcInternal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void ReleaseHdcInternal(IntPtr hdc) {
            int status = SafeNativeMethods.GdipReleaseDC(new HandleRef(this, nativeGraphics), new HandleRef(null, hdc));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Flush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Forces immediate execution of all
        ///       operations currently on the stack.
        ///    </para>
        /// </devdoc>
        public void Flush() {
            Flush(FlushIntention.Flush);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Flush1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Forces execution of all operations
        ///       currently on the stack.
        ///    </para>
        /// </devdoc>
        public void Flush(FlushIntention intention) {
            int status = SafeNativeMethods.GdipFlush(new HandleRef(this, nativeGraphics), intention);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Dispose of resources associated with the graphics context
         *
         * @notes How do we set up delegates to notice others
         *  when a Graphics object is disposed.
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Dispose"]/*' />
        /// <devdoc>
        ///    Deletes this <see cref='System.Drawing.Graphics'/>, and
        ///    frees the memory allocated for it.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Dispose2"]/*' />
        void Dispose(bool disposing) {
#if DEBUG
            if (!disposing && nativeGraphics != IntPtr.Zero) {
                // Recompile commonUI\\system\\Drawing\\Graphics.cs with FINALIZATION_WATCH on to find who allocated it.
#if FINALIZATION_WATCH
                //Debug.Fail("Graphics object Disposed through finalization:\n" + allocationSite);
                Debug.WriteLine("System.Drawing.Graphics: ***************************************************");
                Debug.WriteLine("System.Drawing.Graphics: Object Disposed through finalization:\n" + allocationSite);
#else
                //Debug.Fail("A Graphics object was not Dispose()'d.  Please make sure it's not your code that should be calling Dispose().");
#endif
            }
#endif

            if (nativeGraphics != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeleteGraphics(new HandleRef(this, nativeGraphics));
                nativeGraphics = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Finalize"]/*' />
        /// <devdoc>
        ///    Deletes this <see cref='System.Drawing.Graphics'/>, and
        ///    frees the memory allocated for it.
        /// </devdoc>
        ~Graphics() {
            Dispose(false);
        }

        /*
         * Methods for setting/getting:
         *  compositing mode
         *  rendering quality hint
         *
         * @notes We should probably separate rendering hints
         *  into several categories, e.g. antialiasing, image
         *  filtering, etc.
         */

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.CompositingMode"]/*' />
        /// <devdoc>
        ///    Gets or sets the <see cref='System.Drawing.Drawing2D.CompositingMode'/> associated with this <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        public CompositingMode CompositingMode {
            get {
                int mode = 0;

                int status = SafeNativeMethods.GdipGetCompositingMode(new HandleRef(this, nativeGraphics), out mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(CompositingMode)mode;
            }
            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(CompositingMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingMode));
                }

                int status = SafeNativeMethods.GdipSetCompositingMode(new HandleRef(this, nativeGraphics), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.RenderingOrigin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Point RenderingOrigin {
            get {
                int x, y;

                int status = SafeNativeMethods.GdipGetRenderingOrigin(new HandleRef(this, nativeGraphics), out x, out y);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return new Point(x, y);
            }
            set {
                int status = SafeNativeMethods.GdipSetRenderingOrigin(new HandleRef(this, nativeGraphics), value.X, value.Y);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }   

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.CompositingQuality"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CompositingQuality CompositingQuality {
            get {
                CompositingQuality cq;

                int status = SafeNativeMethods.GdipGetCompositingQuality(new HandleRef(this, nativeGraphics), out cq);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return cq;
            }
            set {
                if (!Enum.IsDefined(typeof(CompositingQuality), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(CompositingQuality));
                }

                int status = SafeNativeMethods.GdipSetCompositingQuality(new HandleRef(this, nativeGraphics), 
                                                               value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TextRenderingHint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the rendering mode for text associated with
        ///       this <see cref='System.Drawing.Graphics'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public TextRenderingHint TextRenderingHint {
            get {
                TextRenderingHint hint = 0;

                int status = SafeNativeMethods.GdipGetTextRenderingHint(new HandleRef(this, nativeGraphics), out hint);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return hint;
            }
            set {
                if (!Enum.IsDefined(typeof(TextRenderingHint), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(TextRenderingHint));
                }

                int status = SafeNativeMethods.GdipSetTextRenderingHint(new HandleRef(this, nativeGraphics), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TextContrast"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int TextContrast {
            get {
                int tgv = 0;

                int status = SafeNativeMethods.GdipGetTextContrast(new HandleRef(this, nativeGraphics), out tgv);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return tgv;
            }
            set {
                int status = SafeNativeMethods.GdipSetTextContrast(new HandleRef(this, nativeGraphics), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SmoothingMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public SmoothingMode SmoothingMode {
            get {
                SmoothingMode mode = 0;

                int status = SafeNativeMethods.GdipGetSmoothingMode(new HandleRef(this, nativeGraphics), out mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return mode;
            }
            set {
                if (!Enum.IsDefined(typeof(SmoothingMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(SmoothingMode));
                }

                int status = SafeNativeMethods.GdipSetSmoothingMode(new HandleRef(this, nativeGraphics), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.PixelOffsetMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PixelOffsetMode PixelOffsetMode {
            get {
                PixelOffsetMode mode = 0;

                int status = SafeNativeMethods.GdipGetPixelOffsetMode(new HandleRef(this, nativeGraphics), out mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return mode;
            }
            set {
                if (!Enum.IsDefined(typeof(PixelOffsetMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PixelOffsetMode));
                }

                int status = SafeNativeMethods.GdipSetPixelOffsetMode(new HandleRef(this, nativeGraphics), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.InterpolationMode"]/*' />
        /// <devdoc>
        ///    Gets or sets the interpolation mode
        ///    associated with this Graphics.
        /// </devdoc>
        public InterpolationMode InterpolationMode {
            get {
                int mode = 0;

                int status = SafeNativeMethods.GdipGetInterpolationMode(new HandleRef(this, nativeGraphics), out mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(InterpolationMode)mode;
            }
            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(InterpolationMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(InterpolationMode));
                }

                int status = SafeNativeMethods.GdipSetInterpolationMode(new HandleRef(this, nativeGraphics), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Return the current world transform
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Transform"]/*' />
        /// <devdoc>
        ///    Gets or sets the world transform
        ///    for this <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        public Matrix Transform {
            get {
                Matrix matrix = new Matrix();

                int status = SafeNativeMethods.GdipGetWorldTransform(new HandleRef(this, nativeGraphics),
                                                           new HandleRef(matrix, matrix.nativeMatrix));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return matrix;
            }
            set {
                int status = SafeNativeMethods.GdipSetWorldTransform(new HandleRef(this, nativeGraphics),
                                                           new HandleRef(value, value.nativeMatrix));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }


        /**
         * Retrieve the current page transform information
         * notes @ these are atomic
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.PageUnit"]/*' />
        /// <devdoc>
        /// </devdoc>
        public GraphicsUnit PageUnit {
            get {
                int unit = 0;

                int status = SafeNativeMethods.GdipGetPageUnit(new HandleRef(this, nativeGraphics), out unit);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(GraphicsUnit) unit;
            }
            set {
                if (!Enum.IsDefined(typeof(GraphicsUnit), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(GraphicsUnit));
                }

                int status = SafeNativeMethods.GdipSetPageUnit(new HandleRef(this, nativeGraphics), (int) value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.PageScale"]/*' />
        /// <devdoc>
        /// </devdoc>
        public float PageScale {
            get {
                float[] scale = new float[] { 0.0f};

                int status = SafeNativeMethods.GdipGetPageScale(new HandleRef(this, nativeGraphics), scale);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return scale[0];
            }
            set
            {
                int status = SafeNativeMethods.GdipSetPageScale(new HandleRef(this, nativeGraphics), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DpiX"]/*' />
        /// <devdoc>
        /// </devdoc>
        public float DpiX {
            get {
                float[] dpi = new float[] { 0.0f};

                int status = SafeNativeMethods.GdipGetDpiX(new HandleRef(this, nativeGraphics), dpi);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return dpi[0];
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DpiY"]/*' />
        /// <devdoc>
        /// </devdoc>
        public float DpiY {
            get {
                float[] dpi = new float[] { 0.0f};

                int status = SafeNativeMethods.GdipGetDpiY(new HandleRef(this, nativeGraphics), dpi);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return dpi[0];
            }
        }

        /*
         * Manipulate the current transform
         *
         * @notes For get methods, we return copies of our internal objects.
         *  For set methods, we make copies of the objects passed in.
         */

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ResetTransform"]/*' />
        /// <devdoc>
        ///    Resets the world transform to identity.
        /// </devdoc>
        public void ResetTransform() {
            int status = SafeNativeMethods.GdipResetWorldTransform(new HandleRef(this, nativeGraphics));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MultiplyTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that
        ///       represents the world transform and <paramref term="matrix"/>.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix) {
            MultiplyTransform(matrix, MatrixOrder.Prepend);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MultiplyTransform1"]/*' />
        /// <devdoc>
        ///    Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that
        ///    represents the world transform and <paramref term="matrix"/>.
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix, MatrixOrder order) {
            int status = SafeNativeMethods.GdipMultiplyWorldTransform(new HandleRef(this, nativeGraphics),
                                                            new HandleRef(matrix, matrix.nativeMatrix),
                                                            order);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TranslateTransform"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy) {
            TranslateTransform(dx, dy, MatrixOrder.Prepend);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TranslateTransform1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy, MatrixOrder order) {
            int status = SafeNativeMethods.GdipTranslateWorldTransform(new HandleRef(this, nativeGraphics), dx, dy, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ScaleTransform"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy) {
            ScaleTransform(sx, sy, MatrixOrder.Prepend);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ScaleTransform1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy, MatrixOrder order) {
            int status = SafeNativeMethods.GdipScaleWorldTransform(new HandleRef(this, nativeGraphics), sx, sy, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.RotateTransform"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void RotateTransform(float angle) {
            RotateTransform(angle, MatrixOrder.Prepend);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.RotateTransform1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void RotateTransform(float angle, MatrixOrder order) {
            int status = SafeNativeMethods.GdipRotateWorldTransform(new HandleRef(this, nativeGraphics), angle, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Transform points in the current graphics context
         */
        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TransformPoints"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TransformPoints (CoordinateSpace destSpace,
                                     CoordinateSpace srcSpace,
                                     PointF[] pts) {

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipTransformPoints(new HandleRef(this, nativeGraphics), (int) destSpace,
                                                     (int) srcSpace, buf, pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            // must do an in-place copy because we only have a reference
            PointF[] newPts = SafeNativeMethods.ConvertGPPOINTFArrayF(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TransformPoints1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TransformPoints(CoordinateSpace destSpace, 
                                    CoordinateSpace srcSpace, 
                                    Point[] pts) {
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipTransformPointsI(new HandleRef(this, nativeGraphics), (int)destSpace,
                                                      (int)srcSpace, buf, pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            Point[] newPts = SafeNativeMethods.ConvertGPPOINTArray(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.GetNearestColor"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Color GetNearestColor(Color color) {
            int nearest = color.ToArgb();

            int status = SafeNativeMethods.GdipGetNearestColor(new HandleRef(this, nativeGraphics), ref nearest);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return Color.FromArgb(nearest);
        }

        /*
         * Vector drawing methods
         *
         * @notes Do we need a set of methods that take
         *  integer coordinate parameters?
         */

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a line connecting the two
        ///       specified points.
        ///    </para>
        /// </devdoc>
        public void DrawLine(Pen pen, float x1, float y1, float x2, float y2) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawLine(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x1, y1, x2, y2);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLine1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a line connecting the two
        ///       specified points.
        ///    </para>
        /// </devdoc>
        public void DrawLine(Pen pen, PointF pt1, PointF pt2) {
            DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLines"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a series of line segments that
        ///       connect an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawLines(Pen pen, PointF[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawLines(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                               new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }


        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLine2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a line connecting the two
        ///       specified points.
        ///    </para>
        /// </devdoc>
        public void DrawLine(Pen pen, int x1, int y1, int x2, int y2) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawLineI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x1, y1, x2, y2);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLine3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a line connecting the two
        ///       specified points.
        ///    </para>
        /// </devdoc>
        public void DrawLine(Pen pen, Point pt1, Point pt2) {
            DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawLines1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a series of line segments that connect an array of
        ///       points.
        ///    </para>
        /// </devdoc>
        public void DrawLines(Pen pen, Point[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawLinesI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawArc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws an arc from the specified ellipse.
        ///    </para>
        /// </devdoc>
        public void DrawArc(Pen pen, float x, float y, float width, float height,
                            float startAngle, float sweepAngle) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawArc(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                             width, height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawArc1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws an arc from the specified
        ///       ellipse.
        ///    </para>
        /// </devdoc>
        public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle) {
            DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawArc2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws an arc from the specified ellipse.
        ///    </para>
        /// </devdoc>
        public void DrawArc(Pen pen, int x, int y, int width, int height,
                            int startAngle, int sweepAngle) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawArcI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                              width, height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawArc3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws an arc from the specified ellipse.
        ///    </para>
        /// </devdoc>
        public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle) {
            DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawBezier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a cubic bezier curve defined by
        ///       four ordered pairs that represent points.
        ///    </para>
        /// </devdoc>
        public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2,
                               float x3, float y3, float x4, float y4) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawBezier(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x1, y1,
                                                x2, y2, x3, y3, x4, y4);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawBezier1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a cubic bezier curve defined by
        ///       four points.
        ///    </para>
        /// </devdoc>
        public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4) {
            DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawBeziers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a series of cubic Bezier curves
        ///       from an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawBeziers(Pen pen, PointF[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawBeziers(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                 new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawBezier2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a cubic bezier curve defined by four points.
        ///    </para>
        /// </devdoc>
        public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4) {
            DrawBezier(pen, pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawBeziers1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a series of cubic Bezier curves from an array of
        ///       points.
        ///    </para>
        /// </devdoc>
        public void DrawBeziers(Pen pen, Point[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawBeziersI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                  new HandleRef(this, buf), points.Length);
            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawRectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of a rectangle specified by
        ///    <paramref term="rect"/>.
        ///    </para>
        /// </devdoc>
        public void DrawRectangle(Pen pen, Rectangle rect) {
            DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawRectangle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of the specified
        ///       rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawRectangle(Pen pen, float x, float y, float width, float height) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawRectangle(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                                   width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawRectangles"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outlines of a series of
        ///       rectangles.
        ///    </para>
        /// </devdoc>
        public void DrawRectangles(Pen pen, RectangleF[] rects) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (rects == null)
                throw new ArgumentNullException("pen");

            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipDrawRectangles(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                    new HandleRef(this, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawRectangle2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of the specified rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawRectangle(Pen pen, int x, int y, int width, int height) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawRectangleI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                                    width, height);


            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawRectangles1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outlines of a series of rectangles.
        ///    </para>
        /// </devdoc>
        public void DrawRectangles(Pen pen, Rectangle[] rects) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipDrawRectanglesI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                     new HandleRef(this, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawEllipse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of an
        ///       ellipse defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawEllipse(Pen pen, RectangleF rect) {
            DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawEllipse1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of an
        ///       ellipse defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawEllipse(Pen pen, float x, float y, float width, float height) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawEllipse(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                                 width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawEllipse2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of an ellipse specified by a bounding
        ///       rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawEllipse(Pen pen, Rectangle rect) {
            DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawEllipse3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of an ellipse defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void DrawEllipse(Pen pen, int x, int y, int width, int height) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawEllipseI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y,
                                                  width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPie"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of a pie section
        ///       defined by an ellipse and two radial lines.
        ///    </para>
        /// </devdoc>
        public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle) {
            DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                    sweepAngle);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPie1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of a pie section
        ///       defined by an ellipse and two radial lines.
        ///    </para>
        /// </devdoc>
        public void DrawPie(Pen pen, float x, float y, float width,
                            float height, float startAngle, float sweepAngle) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawPie(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y, width,
                                             height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPie2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of a pie section defined by an ellipse
        ///       and two radial lines.
        ///    </para>
        /// </devdoc>
        public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle) {
            DrawPie(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                    sweepAngle);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPie3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the outline of a pie section defined by an ellipse and two radial
        ///       lines.
        ///    </para>
        /// </devdoc>
        public void DrawPie(Pen pen, int x, int y, int width, int height,
                            int startAngle, int sweepAngle) {
            if (pen == null)
                throw new ArgumentNullException("pen");

            int status = SafeNativeMethods.GdipDrawPieI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), x, y, width,
                                              height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPolygon"]/*' />
        /// <devdoc>
        ///    Draws the outline of a polygon defined
        ///    by an array of points.
        /// </devdoc>
        public void DrawPolygon(Pen pen, PointF[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawPolygon(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                 new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPolygon1"]/*' />
        /// <devdoc>
        ///    Draws the outline of a polygon defined
        ///    by an array of points.
        /// </devdoc>
        public void DrawPolygon(Pen pen, Point[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawPolygonI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                                  new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the lines and curves defined by a
        ///    <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public void DrawPath(Pen pen, GraphicsPath path) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (path == null)
                throw new ArgumentNullException("path");

            int status = SafeNativeMethods.GdipDrawPath(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen),
                                              new HandleRef(path, path.nativePath));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of
        ///       points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, PointF[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurve(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                               points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of
        ///       points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, PointF[] points, float tension) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurve2(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                points.Length, tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments) {
            DrawCurve(pen, points, offset, numberOfSegments, 0.5f);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of
        ///       points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments,
                              float tension) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurve3(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                points.Length, offset, numberOfSegments,
                                                tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, Point[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurveI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, Point[] points, float tension) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurve2I(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                 points.Length, tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawCurve6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments,
                              float tension) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawCurve3I(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                 points.Length, offset, numberOfSegments,
                                                 tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawClosedCurve"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a closed curve defined by an
        ///       array of points.
        ///    </para>
        /// </devdoc>
        public void DrawClosedCurve(Pen pen, PointF[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawClosedCurve(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                     points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawClosedCurve1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a closed curve defined by an
        ///       array of points.
        ///    </para>
        /// </devdoc>
        public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawClosedCurve2(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                      points.Length, tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawClosedCurve2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a closed curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawClosedCurve(Pen pen, Point[] points) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawClosedCurveI(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                      points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawClosedCurve3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a closed curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode) {
            if (pen == null)
                throw new ArgumentNullException("pen");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipDrawClosedCurve2I(new HandleRef(this, nativeGraphics), new HandleRef(pen, pen.nativePen), new HandleRef(this, buf),
                                                       points.Length, tension);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Clear"]/*' />
        /// <devdoc>
        ///    Fills the entire drawing surface with the
        ///    specified color.
        /// </devdoc>
        public void Clear(Color color) {
            int status = SafeNativeMethods.GdipGraphicsClear(new HandleRef(this, nativeGraphics), color.ToArgb());

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a rectangle with a <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangle(Brush brush, RectangleF rect) {
            FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a rectangle with a
        ///    <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangle(Brush brush, float x, float y, float width, float height) {
            if (brush == null)
                throw new ArgumentNullException("brush");

           
            int status = SafeNativeMethods.GdipFillRectangle(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                                   width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangles"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interiors of a series of
        ///       rectangles with a <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangles(Brush brush, RectangleF[] rects) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipFillRectangles(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                    new HandleRef(this, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangle2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a rectangle with a <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangle(Brush brush, Rectangle rect) {
            FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangle3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a rectangle with a <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangle(Brush brush, int x, int y, int width, int height) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipFillRectangleI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                                    width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRectangles1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interiors of a series of rectangles with a <see cref='System.Drawing.Brush'/>.
        ///    </para>
        /// </devdoc>
        public void FillRectangles(Brush brush, Rectangle[] rects) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipFillRectanglesI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                     new HandleRef(this, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPolygon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a polygon defined
        ///       by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillPolygon(Brush brush, PointF[] points) {
            FillPolygon(brush, points, FillMode.Alternate);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPolygon1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a polygon defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillPolygon(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                 new HandleRef(this, buf), points.Length, (int) fillMode);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPolygon2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a polygon defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillPolygon(Brush brush, Point[] points) {
            FillPolygon(brush, points, FillMode.Alternate);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPolygon3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a polygon defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillPolygon(Brush brush, Point[] points, FillMode fillMode) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillPolygonI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                  new HandleRef(this, buf), points.Length, (int) fillMode);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillEllipse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of an ellipse
        ///       defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void FillEllipse(Brush brush, RectangleF rect) {
            FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillEllipse1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of an ellipse defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void FillEllipse(Brush brush, float x, float y, float width,
                                float height) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipFillEllipse(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                                 width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillEllipse2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of an ellipse defined by a bounding rectangle.
        ///    </para>
        /// </devdoc>
        public void FillEllipse(Brush brush, Rectangle rect) {
            FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillEllipse3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of an ellipse defined by a bounding
        ///       rectangle.
        ///    </para>
        /// </devdoc>
        public void FillEllipse(Brush brush, int x, int y, int width, int height) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipFillEllipseI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                                  width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPie"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a pie section defined by an ellipse and two radial
        ///       lines.
        ///    </para>
        /// </devdoc>
        public void FillPie(Brush brush, Rectangle rect, float startAngle,
                            float sweepAngle) {
            FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                    sweepAngle);
        }

        // float verison
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPie1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a pie section defined by an ellipse and two radial
        ///       lines.
        ///    </para>
        /// </devdoc>
        public void FillPie(Brush brush, float x, float y, float width,
                            float height, float startAngle, float sweepAngle) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipFillPie(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                             width, height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int verison
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPie2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a pie section defined by an ellipse
        ///       and two radial lines.
        ///    </para>
        /// </devdoc>
        public void FillPie(Brush brush, int x, int y, int width,
                            int height, int startAngle, int sweepAngle) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipFillPieI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush), x, y,
                                              width, height, startAngle, sweepAngle);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a path.
        ///    </para>
        /// </devdoc>
        public void FillPath(Brush brush, GraphicsPath path) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (path == null)
                throw new ArgumentNullException("path");

            int status = SafeNativeMethods.GdipFillPath(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                              new HandleRef(path, path.nativePath));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior a closed
        ///       curve defined by an
        ///       array of points.
        ///    </para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, PointF[] points) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillClosedCurve(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                               new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the
        ///       interior of a closed curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode) {
            FillClosedCurve(brush, points, fillmode, 0.5f);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillClosedCurve2(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                      new HandleRef(this, buf), points.Length,
                                                      tension, (int) fillmode);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior a closed curve defined by an array of points.
        ///    </para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, Point[] points) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillClosedCurveI(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                     new HandleRef(this, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode) {
            FillClosedCurve(brush, points, fillmode, 0.5f); 
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillClosedCurve5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension) {
            if (brush == null)
                throw new ArgumentNullException("brush");
            if (points == null)
                throw new ArgumentNullException("points");

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipFillClosedCurve2I(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                      new HandleRef(this, buf), points.Length,
                                                      tension, (int) fillmode);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.FillRegion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the interior of a <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public void FillRegion(Brush brush, Region region) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            if (region == null)
                throw new ArgumentNullException("region");

            int status = SafeNativeMethods.GdipFillRegion(new HandleRef(this, nativeGraphics), new HandleRef(brush, brush.nativeBrush),
                                                new HandleRef(region, region.nativeRegion));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /*
         * Text drawing methods
         *
         * @notes Should there be integer versions, also?
         */

        // Without clipping rectangle
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws a string with the specified font.
        ///    </para>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, float x, float y) {
            DrawString(s, font, brush, new RectangleF(x, y, 0, 0), null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, PointF point) {
            DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0, 0), null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, float x, float y, StringFormat format) {
            DrawString(s, font, brush, new RectangleF(x, y, 0, 0), format);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, PointF point, StringFormat format) {
            DrawString(s, font, brush, new RectangleF(point.X, point.Y, 0, 0), format);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, RectangleF layoutRectangle) {
            DrawString(s, font, brush, layoutRectangle, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawString5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawString(String s, Font font, Brush brush, 
                               RectangleF layoutRectangle, StringFormat format) {
            if (brush == null)
                throw new ArgumentNullException("brush");

            if (s == null || s.Length == 0) return;
            if (font == null)
                throw new ArgumentNullException("font");

            GPRECTF grf = new GPRECTF(layoutRectangle);

            IntPtr nativeStringFormat = (format == null) ? IntPtr.Zero : format.nativeFormat;
            int status = SafeNativeMethods.GdipDrawString(new HandleRef(this, nativeGraphics), s, s.Length, new HandleRef(font, font.NativeFont), ref grf, new HandleRef(format, nativeStringFormat), new HandleRef(brush, brush.nativeBrush));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // MeasureString

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, SizeF layoutArea, StringFormat stringFormat,
                                   out int charactersFitted, out int linesFilled) {
            if (text == null || text.Length == 0) {
                charactersFitted = 0;
                linesFilled = 0;
                return new SizeF(0, 0);
            }
            if (font == null)
                throw new ArgumentNullException("font");

            GPRECTF grfLayout = new GPRECTF(0, 0, layoutArea.Width, layoutArea.Height);
            GPRECTF grfboundingBox = new GPRECTF();

            int status = SafeNativeMethods.GdipMeasureString(new HandleRef(this, nativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref grfLayout,
                                                   new HandleRef(stringFormat, (stringFormat == null) ? IntPtr.Zero : stringFormat.nativeFormat), 
                                                   ref grfboundingBox,
                                                   out charactersFitted, out linesFilled);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return grfboundingBox.SizeF;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, PointF origin, StringFormat stringFormat) {
            if (text == null || text.Length == 0)
                return new SizeF(0, 0);
            if (font == null)
                throw new ArgumentNullException("font");

            GPRECTF grf = new GPRECTF();
            GPRECTF grfboundingBox = new GPRECTF();

            grf.X = origin.X;
            grf.Y = origin.Y;
            grf.Width = 0;
            grf.Height = 0;

            int a, b;
            int status = SafeNativeMethods.GdipMeasureString(new HandleRef(this, nativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont),
                                                   ref grf, 
                                                   new HandleRef(stringFormat, (stringFormat == null) ? IntPtr.Zero : stringFormat.nativeFormat), 
                                                   ref grfboundingBox, out a, out b);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return grfboundingBox.SizeF;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, SizeF layoutArea) {
            return MeasureString(text, font, layoutArea, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, SizeF layoutArea, StringFormat stringFormat) {
            if (text == null || text.Length == 0) return new SizeF(0, 0);

            if (font == null)
                throw new ArgumentNullException("font");

            GPRECTF grfLayout = new GPRECTF(0, 0, layoutArea.Width, layoutArea.Height);
            GPRECTF grfboundingBox = new GPRECTF();

            int a, b;
            int status = SafeNativeMethods.GdipMeasureString(new HandleRef(this, nativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), 
                                                   ref grfLayout, 
                                                   new HandleRef(stringFormat, (stringFormat == null) ? IntPtr.Zero : stringFormat.nativeFormat), 
                                                   ref grfboundingBox, out a, out b);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return grfboundingBox.SizeF;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font) {
            return MeasureString(text, font, new SizeF(0,0));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, int width) {
            return MeasureString(text, font, new SizeF(width, 999999));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureString6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public SizeF MeasureString(String text, Font font, int width, StringFormat format) {
            return MeasureString(text, font, new SizeF(width, 999999), format);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.MeasureCharacterRanges"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Region[] MeasureCharacterRanges(String text, Font font, RectangleF layoutRect, 
                                          StringFormat stringFormat ) {
            int count;
            int status = SafeNativeMethods.GdipGetStringFormatMeasurableCharacterRangeCount(new HandleRef(stringFormat, (stringFormat == null) ? IntPtr.Zero : stringFormat.nativeFormat)
                                                                                    , out count);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // This should be IntPtr
            int[] gpRegions = new int[count];

            GPRECTF grf = new GPRECTF(layoutRect);
                                          
            Region[] regions = new Region[count];

            for (int f = 0; f < count; f++) {
                regions[f] = new Region();
                gpRegions[f] = (int)regions[f].nativeRegion;
            }

            status = SafeNativeMethods.GdipMeasureCharacterRanges(new HandleRef(this, nativeGraphics), text, text.Length, new HandleRef(font, font.NativeFont), ref grf, 
                                                         new HandleRef(stringFormat, (stringFormat == null) ? IntPtr.Zero : stringFormat.nativeFormat),
                                                         count, gpRegions);


            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return regions;
        }
        
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawIcon"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawIcon(Icon icon, int x, int y) {
            icon.Draw(this, x, y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawIcon1"]/*' />
        /// <devdoc>
        ///    Draws this image to a graphics object.  The drawing command originates on the graphics
        ///    object, but a graphics object generally has no idea how to render a given image.  So,
        ///    it passes the call to the actual image.  This version crops the image to the given
        ///    dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        public void DrawIcon(Icon icon, Rectangle targetRect) {
            icon.Draw(this, targetRect);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawIconUnstretched"]/*' />
        /// <devdoc>
        ///    Draws this image to a graphics object.  The drawing command originates on the graphics
        ///    object, but a graphics object generally has no idea how to render a given image.  So,
        ///    it passes the call to the actual image.  This version stretches the image to the given
        ///    dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        public void DrawIconUnstretched(Icon icon, Rectangle targetRect) {
            icon.DrawUnstretched(this, targetRect);
        }

        /**
         * Draw images (both bitmap and vector)
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws the specified image at the
        ///       specified location.
        ///    </para>
        /// </devdoc>
        public void DrawImage(Image image, PointF point) {
            DrawImage(image, point.X, point.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, float x, float y) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImage(new HandleRef(this, nativeGraphics), new HandleRef(image, image.nativeImage),
                                               x, y);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }
        
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, RectangleF rect) {
            DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, float x, float y, float width,
                              float height) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageRect(new HandleRef(this, nativeGraphics),
                                                   new HandleRef(image, image.nativeImage),
                                                   x, y,
                                                   width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }
        
        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point point) {
            DrawImage(image, point.X, point.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, int x, int y) {
            if (this == null)
                throw new ArgumentNullException("this");
            
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageI(new HandleRef(this, nativeGraphics), new HandleRef(image, image.nativeImage),
                                                x, y);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }
        
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle rect) {
            DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage7"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, int x, int y, int width, int height) {
            int status = SafeNativeMethods.GdipDrawImageRectI(new HandleRef(this, nativeGraphics),
                                                    new HandleRef(image, image.nativeImage),
                                                    x, y,
                                                    width, height);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        
        
        // unscaled versions
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImageUnscaled"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImageUnscaled(Image image, Point point) {
            DrawImage(image, point.X, point.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImageUnscaled1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImageUnscaled(Image image, int x, int y) {
            DrawImage(image, x, y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImageUnscaled2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImageUnscaled(Image image, Rectangle rect) {
            DrawImage(image, rect.X, rect.Y);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImageUnscaled3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImageUnscaled(Image image, int x, int y, int width, int height) {
            DrawImage(image, x, y);
        }

        /*
         * Affine or perspective blt
         *  destPoints.Length = 3: rect => parallelogram
         *      destPoints[0] <=> top-left corner of the source rectangle
         *      destPoints[1] <=> top-right corner
         *       destPoints[2] <=> bottom-left corner
         *  destPoints.Length = 4: rect => quad
         *      destPoints[3] <=> bottom-right corner
         *
         *  @notes Perspective blt only works for bitmap images.
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage8"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, PointF[] destPoints) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (image == null)
                throw new ArgumentNullException("image");

            int count = destPoints.Length;

            if (count != 3 && count != 4)
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidLength));

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);
            int status = SafeNativeMethods.GdipDrawImagePoints(new HandleRef(this, nativeGraphics),
                                                     new HandleRef(image, image.nativeImage),
                                                     new HandleRef(this, buf), count);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage9"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point[] destPoints) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (image == null)
                throw new ArgumentNullException("image");

            int count = destPoints.Length;

            if (count != 3 && count != 4)
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidLength));

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);
            int status = SafeNativeMethods.GdipDrawImagePointsI(new HandleRef(this, nativeGraphics),
                                                      new HandleRef(image, image.nativeImage),
                                                      new HandleRef(this, buf), count);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /*
         * We need another set of methods similar to the ones above
         * that take an additional Rectangle parameter to specify the
         * portion of the source image to be drawn.
         */
        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage10"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, float x, float y, RectangleF srcRect,
                              GraphicsUnit srcUnit) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImagePointRect(
                                                       new HandleRef(this, nativeGraphics),
                                                       new HandleRef(image, image.nativeImage),
                                                       x,
                                                       y,
                                                       srcRect.X,
                                                       srcRect.Y,
                                                       srcRect.Width,
                                                       srcRect.Height,
                                                       (int) srcUnit);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage11"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, int x, int y, Rectangle srcRect,
                              GraphicsUnit srcUnit) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImagePointRectI(
                                                        new HandleRef(this, nativeGraphics),
                                                        new HandleRef(image, image.nativeImage),
                                                        x,
                                                        y,
                                                        srcRect.X,
                                                        srcRect.Y,
                                                        srcRect.Width,
                                                        srcRect.Height,
                                                        (int) srcUnit);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage12"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect,
                              GraphicsUnit srcUnit) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageRectRect(
                                                      new HandleRef(this, nativeGraphics),
                                                      new HandleRef(image, image.nativeImage),
                                                      destRect.X,
                                                      destRect.Y,
                                                      destRect.Width,
                                                      destRect.Height,
                                                      srcRect.X,
                                                      srcRect.Y,
                                                      srcRect.Width,
                                                      srcRect.Height,
                                                      (int) srcUnit,
                                                      NativeMethods.NullHandleRef,
                                                      null,
                                                      NativeMethods.NullHandleRef
                                                      );

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage13"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect,
                              GraphicsUnit srcUnit) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageRectRectI(
                                                       new HandleRef(this, nativeGraphics),
                                                       new HandleRef(image, image.nativeImage),
                                                       destRect.X,
                                                       destRect.Y,
                                                       destRect.Width,
                                                       destRect.Height,
                                                       srcRect.X,
                                                       srcRect.Y,
                                                       srcRect.Width,
                                                       srcRect.Height,
                                                       (int) srcUnit,
                                                       NativeMethods.NullHandleRef,
                                                       null,
                                                       NativeMethods.NullHandleRef);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage14"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect,
                              GraphicsUnit srcUnit) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (image == null)
                throw new ArgumentNullException("image");

            int count = destPoints.Length;

            if (count != 3 && count != 4)
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidLength));

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);

            int status = SafeNativeMethods.GdipDrawImagePointsRect(
                                                        new HandleRef(this, nativeGraphics),
                                                        new HandleRef(image, image.nativeImage),
                                                        new HandleRef(this, buf),
                                                        destPoints.Length,
                                                        srcRect.X,
                                                        srcRect.Y,
                                                        srcRect.Width,
                                                        srcRect.Height,
                                                        (int) srcUnit,
                                                        NativeMethods.NullHandleRef,
                                                        null,
                                                        NativeMethods.NullHandleRef);

            Marshal.FreeHGlobal(buf);

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage15"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr) {
            DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage16"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr,
                              DrawImageAbort callback) {
            DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
        }
        
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage17"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr,
                              DrawImageAbort callback, int callbackData) {

            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (image == null)
                throw new ArgumentNullException("image");
            
            int count = destPoints.Length;
            
            if (count != 3 && count != 4)
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidLength));
            
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);
            
            int status = SafeNativeMethods.GdipDrawImagePointsRect(
                                                        new HandleRef(this, nativeGraphics),
                                                        new HandleRef(image, image.nativeImage),
                                                        new HandleRef(this, buf),
                                                        destPoints.Length,
                                                        srcRect.X,
                                                        srcRect.Y,
                                                        srcRect.Width,
                                                        srcRect.Height,
                                                        (int) srcUnit,
                                                        new HandleRef(imageAttr, (imageAttr != null ? imageAttr.nativeImageAttributes : IntPtr.Zero)),
                                                        callback,
                                                        new HandleRef(null, (IntPtr)callbackData));
            
            Marshal.FreeHGlobal(buf);
            
            //check error status sensitive to TS problems
            CheckErrorStatus(status);

        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage18"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit) {
            DrawImage(image, destPoints, srcRect, srcUnit, null, null, 0);

        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage19"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr) {
            DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, null, 0);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage20"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr,
                              DrawImageAbort callback) {
            DrawImage(image, destPoints, srcRect, srcUnit, imageAttr, callback, 0);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage21"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect,
                              GraphicsUnit srcUnit, ImageAttributes imageAttr,
                              DrawImageAbort callback, int callbackData) {

            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (image == null)
                throw new ArgumentNullException("image");
            
            int count = destPoints.Length;
            
            if (count != 3 && count != 4)
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidLength));
            
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);
            
            int status = SafeNativeMethods.GdipDrawImagePointsRectI(
                                                        new HandleRef(this, nativeGraphics),
                                                        new HandleRef(image, image.nativeImage),
                                                        new HandleRef(this, buf),
                                                        destPoints.Length,
                                                        srcRect.X,
                                                        srcRect.Y,
                                                        srcRect.Width,
                                                        srcRect.Height,
                                                        (int) srcUnit,
                                                        new HandleRef(imageAttr, (imageAttr != null ? imageAttr.nativeImageAttributes : IntPtr.Zero)),
                                                        callback,
                                                        new HandleRef(null, (IntPtr)callbackData));
            
            Marshal.FreeHGlobal(buf);
            
            //check error status sensitive to TS problems
            CheckErrorStatus(status);

        }

        // float version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage22"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY,
                              float srcWidth, float srcHeight, GraphicsUnit srcUnit) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage23"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY,
                              float srcWidth, float srcHeight, GraphicsUnit srcUnit,
                              ImageAttributes imageAttrs) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage24"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY,
                              float srcWidth, float srcHeight, GraphicsUnit srcUnit,
                              ImageAttributes imageAttrs, DrawImageAbort callback) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage25"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY,
                              float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs,
                              DrawImageAbort callback, IntPtr callbackData) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageRectRect(
                                                       new HandleRef(this, nativeGraphics),
                                                       new HandleRef(image, image.nativeImage),
                                                       destRect.X,
                                                       destRect.Y,
                                                       destRect.Width,
                                                       destRect.Height,
                                                       srcX,
                                                       srcY,
                                                       srcWidth,
                                                       srcHeight,
                                                       (int) srcUnit,
                                                       new HandleRef(imageAttrs, (imageAttrs != null ? imageAttrs.nativeImageAttributes : IntPtr.Zero)),
                                                       callback,
                                                       new HandleRef(null, callbackData));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage26"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY,
                              int srcWidth, int srcHeight, GraphicsUnit srcUnit) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage27"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY,
                              int srcWidth, int srcHeight, GraphicsUnit srcUnit,
                              ImageAttributes imageAttr) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage28"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY,
                              int srcWidth, int srcHeight, GraphicsUnit srcUnit,
                              ImageAttributes imageAttr, DrawImageAbort callback) {
            DrawImage(image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.DrawImage29"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY,
                              int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs,
                              DrawImageAbort callback, IntPtr callbackData) {
            if (image == null)
                throw new ArgumentNullException("image");

            int status = SafeNativeMethods.GdipDrawImageRectRectI(
                                                       new HandleRef(this, nativeGraphics),
                                                       new HandleRef(image, image.nativeImage),
                                                       destRect.X,
                                                       destRect.Y,
                                                       destRect.Width,
                                                       destRect.Height,
                                                       srcX,
                                                       srcY,
                                                       srcWidth,
                                                       srcHeight,
                                                       (int) srcUnit,
                                                       new HandleRef(imageAttrs, (imageAttrs != null ? imageAttrs.nativeImageAttributes : IntPtr.Zero)),
                                                       callback,
                                                       new HandleRef(null, callbackData));

            //check error status sensitive to TS problems
            CheckErrorStatus(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint, 
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint, 
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile2"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint, 
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            int status = SafeNativeMethods.GdipEnumerateMetafileDestPoint(new HandleRef(this, nativeGraphics),
                                                                new HandleRef(metafile, mf),
                                                                new GPPOINTF(destPoint),
                                                                callback,
                                                                new HandleRef(null, callbackData),
                                                                new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile3"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint, 
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoint, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile4"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint, 
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoint, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile5"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint, 
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            int status = SafeNativeMethods.GdipEnumerateMetafileDestPointI(new HandleRef(this, nativeGraphics),
                                                                 new HandleRef(metafile, mf),
                                                                 new GPPOINT(destPoint),
                                                                 callback,
                                                                 new HandleRef(null, callbackData),
                                                                 new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile6"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, 
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile7"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, 
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destRect, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile8"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, 
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPRECTF grf = new GPRECTF(destRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileDestRect(new HandleRef(this, nativeGraphics),
                                                               new HandleRef(metafile, mf),
                                                               ref grf,
                                                               callback,
                                                               new HandleRef(null, callbackData),
                                                               new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile9"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, 
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destRect, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile10"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, 
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destRect, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile11"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, 
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPRECT gprect = new GPRECT(destRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileDestRectI(new HandleRef(this, nativeGraphics),
                                                                new HandleRef(metafile, mf),
                                                                ref gprect,
                                                                callback,
                                                                new HandleRef(null, callbackData),
                                                                new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile12"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile13"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile14"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (destPoints.Length != 3) {
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidParallelogram));
            }

            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            IntPtr points = SafeNativeMethods.ConvertPointToMemory(destPoints);

            int status = SafeNativeMethods.GdipEnumerateMetafileDestPoints(new HandleRef(this, nativeGraphics),
                                                                 new HandleRef(metafile, mf),
                                                                 points,
                                                                 destPoints.Length,
                                                                 callback,
                                                                 new HandleRef(null, callbackData),
                                                                 new HandleRef(imageAttr, ia));
            Marshal.FreeHGlobal(points);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }


        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile15"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoints, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile16"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoints, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile17"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (destPoints.Length != 3) {
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidParallelogram));
            }

            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            IntPtr points = SafeNativeMethods.ConvertPointToMemory(destPoints);

            int status = SafeNativeMethods.GdipEnumerateMetafileDestPointsI(new HandleRef(this, nativeGraphics),
                                                                  new HandleRef(metafile, mf),
                                                                  points,
                                                                  destPoints.Length,
                                                                  callback,
                                                                  new HandleRef(null, callbackData),
                                                                  new HandleRef(imageAttr, ia));
            Marshal.FreeHGlobal(points);                        

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile18"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile19"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile20"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF destPoint,
                                      RectangleF srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPRECTF grf = new GPRECTF(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestPoint(new HandleRef(this, nativeGraphics),
                                                                       new HandleRef(metafile, mf),
                                                                       new GPPOINTF(destPoint),
                                                                       ref grf,
                                                                       (int) unit,
                                                                       callback,
                                                                       new HandleRef(null, callbackData),
                                                                       new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile21"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile22"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoint, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile23"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point destPoint,
                                      Rectangle srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPPOINT gppoint = new GPPOINT(destPoint);
            GPRECT gprect = new GPRECT(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestPointI(new HandleRef(this, nativeGraphics),
                                                                        new HandleRef(metafile, mf),
                                                                        gppoint,
                                                                        ref gprect,
                                                                        (int) unit,
                                                                        callback,
                                                                        new HandleRef(null, callbackData),
                                                                        new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile24"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile25"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile26"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, RectangleF destRect,
                                      RectangleF srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPRECTF grfdest = new GPRECTF(destRect);
            GPRECTF grfsrc = new GPRECTF(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestRect(new HandleRef(this, nativeGraphics),
                                                                      new HandleRef(metafile, mf),
                                                                      ref grfdest,
                                                                      ref grfsrc,
                                                                      (int) unit,
                                                                      callback,
                                                                      new HandleRef(null, callbackData),
                                                                      new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile27"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile28"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destRect, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile29"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Rectangle destRect,
                                      Rectangle srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            GPRECT gpDest = new GPRECT(destRect);
            GPRECT gpSrc = new GPRECT(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestRectI(new HandleRef(this, nativeGraphics),
                                                                       new HandleRef(metafile, mf),
                                                                       ref gpDest,
                                                                       ref gpSrc,
                                                                       (int) unit,
                                                                       callback,
                                                                       new HandleRef(null, callbackData),
                                                                       new HandleRef(imageAttr, ia));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile30"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile31"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      RectangleF srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints,
                                      RectangleF srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (destPoints.Length != 3) {
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidParallelogram));
            }

            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            IntPtr buffer = SafeNativeMethods.ConvertPointToMemory(destPoints);

            GPRECTF grf = new GPRECTF(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestPoints(new HandleRef(this, nativeGraphics),
                                                                        new HandleRef(metafile, mf),
                                                                        buffer,
                                                                        destPoints.Length,
                                                                        ref grf,
                                                                        (int) unit,
                                                                        callback,
                                                                        new HandleRef(null, callbackData),
                                                                        new HandleRef(imageAttr, ia));
            Marshal.FreeHGlobal(buffer);                                                                     

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }


        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile33"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback) {
            EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, IntPtr.Zero);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile34"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      Rectangle srcRect, GraphicsUnit srcUnit,
                                      EnumerateMetafileProc callback, IntPtr callbackData) {
            EnumerateMetafile(metafile, destPoints, srcRect, srcUnit, callback, callbackData, null);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EnumerateMetafile35"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EnumerateMetafile(Metafile metafile, Point[] destPoints,
                                      Rectangle srcRect, GraphicsUnit unit,
                                      EnumerateMetafileProc callback, IntPtr callbackData,
                                      ImageAttributes imageAttr) {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            if (destPoints.Length != 3) {
                throw new ArgumentException(SR.GetString(SR.GdiplusDestPointsInvalidParallelogram));
            }

            IntPtr mf = (metafile == null ? IntPtr.Zero : metafile.nativeImage);
            IntPtr ia = (imageAttr == null ? IntPtr.Zero : imageAttr.nativeImageAttributes);

            IntPtr buffer = SafeNativeMethods.ConvertPointToMemory(destPoints);

            GPRECT gpSrc = new GPRECT(srcRect);
            int status = SafeNativeMethods.GdipEnumerateMetafileSrcRectDestPointsI(new HandleRef(this, nativeGraphics),
                                                                         new HandleRef(metafile, mf),
                                                                         buffer,
                                                                         destPoints.Length,
                                                                         ref gpSrc,
                                                                         (int) unit,
                                                                         callback,
                                                                         new HandleRef(null, callbackData),
                                                                         new HandleRef(imageAttr, ia));
            Marshal.FreeHGlobal(buffer);                                                                     

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }


        /*
         * Clipping region operations
         *
         * @notes Simply incredible redundancy here.
         */

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(Graphics g) {
            SetClip(g, CombineMode.Replace);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(Graphics g, CombineMode combineMode) {
            int status = SafeNativeMethods.GdipSetClipGraphics(new HandleRef(this, nativeGraphics), new HandleRef(g, g.nativeGraphics), combineMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(Rectangle rect) {
            SetClip(rect, CombineMode.Replace);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(Rectangle rect, CombineMode combineMode) {
            int status = SafeNativeMethods.GdipSetClipRectI(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                  rect.Width, rect.Height, combineMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(RectangleF rect) {
            SetClip(rect, CombineMode.Replace);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(RectangleF rect, CombineMode combineMode) {
            int status = SafeNativeMethods.GdipSetClipRect(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                 rect.Width, rect.Height, combineMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(GraphicsPath path) {
            SetClip(path, CombineMode.Replace);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip7"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(GraphicsPath path, CombineMode combineMode) {
            if (path == null)
                throw new ArgumentNullException("path");

            int status = SafeNativeMethods.GdipSetClipPath(new HandleRef(this, nativeGraphics), new HandleRef(path, path.nativePath), combineMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.SetClip8"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void SetClip(Region region, CombineMode combineMode) {
            if (region == null)
                throw new ArgumentNullException("region");

            int status = SafeNativeMethods.GdipSetClipRegion(new HandleRef(this, nativeGraphics), new HandleRef(region, region.nativeRegion), combineMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IntersectClip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void IntersectClip(Rectangle rect) {
            int status = SafeNativeMethods.GdipSetClipRectI(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                  rect.Width, rect.Height, CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
            //            OldGraphics.Clip = OldGraphics.Clip.AndWith(Region.CreateRectangular(rect));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IntersectClip1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void IntersectClip(RectangleF rect) {
            int status = SafeNativeMethods.GdipSetClipRect(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                 rect.Width, rect.Height, CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IntersectClip2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void IntersectClip(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");

            int status = SafeNativeMethods.GdipSetClipRegion(new HandleRef(this, nativeGraphics), new HandleRef(region, region.nativeRegion),
                                                   CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ExcludeClip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ExcludeClip(Rectangle rect) {
            int status = SafeNativeMethods.GdipSetClipRectI(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                  rect.Width, rect.Height, CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
            //            OldGraphics.Clip = OldGraphics.Clip.DiffWith(Region.CreateRectangular(rect));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ExcludeClip1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ExcludeClip(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");

            int status = SafeNativeMethods.GdipSetClipRegion(new HandleRef(this, nativeGraphics),
                                                   new HandleRef(region, region.nativeRegion),
                                                   CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ResetClip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void ResetClip() {
            int status = SafeNativeMethods.GdipResetClip(new HandleRef(this, nativeGraphics));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TranslateClip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TranslateClip(float dx, float dy) {
            int status = SafeNativeMethods.GdipTranslateClip(new HandleRef(this, nativeGraphics), dx, dy);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.TranslateClip1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void TranslateClip(int dx, int dy) {
            int status = SafeNativeMethods.GdipTranslateClip(new HandleRef(this, nativeGraphics), dx, dy);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         *  GetClip region from graphics context
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Clip"]/*' />
        /// <devdoc>
        /// </devdoc>
        public Region Clip {
            get {
                Region region = new Region();

                int status = SafeNativeMethods.GdipGetClip(new HandleRef(this, nativeGraphics), new HandleRef(region, region.nativeRegion));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return region;
            }
            set {
                SetClip(value, CombineMode.Replace);
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.ClipBounds"]/*' />
        /// <devdoc>
        /// </devdoc>
        public RectangleF ClipBounds {
            get {
                GPRECTF rect = new GPRECTF();
                int status = SafeNativeMethods.GdipGetClipBounds(new HandleRef(this, nativeGraphics), ref rect);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return rect.ToRectangleF();
            }
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsClipEmpty"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsClipEmpty {
            get {
                int isEmpty;

                int status = SafeNativeMethods.GdipIsClipEmpty(new HandleRef(this, nativeGraphics), out isEmpty);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return isEmpty != 0;
            }
        }

        /**
         * Hit testing operations
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.VisibleClipBounds"]/*' />
        /// <devdoc>
        /// </devdoc>
        public RectangleF VisibleClipBounds {
            get {
                GPRECTF rect = new GPRECTF();
                int status = SafeNativeMethods.GdipGetVisibleClipBounds(new HandleRef(this, nativeGraphics), ref rect);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return rect.ToRectangleF();
            }
        }

        /**
          * @notes atomic operation?  status needed?
          */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisibleClipEmpty"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisibleClipEmpty {
            get {
                int isEmpty;

                int status = SafeNativeMethods.GdipIsVisibleClipEmpty(new HandleRef(this, nativeGraphics), out isEmpty);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return isEmpty != 0;
            }
        }


        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(int x, int y) {
            return IsVisible(new Point(x,y));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(Point point) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisiblePointI(new HandleRef(this, nativeGraphics), point.X, point.Y, out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(float x, float y) {
            return IsVisible(new PointF(x,y));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(PointF point) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisiblePoint(new HandleRef(this, nativeGraphics), point.X, point.Y, out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(int x, int y, int width, int height) {
            return IsVisible(new Rectangle(x, y, width, height));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(Rectangle rect) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisibleRectI(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                    rect.Width, rect.Height, out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(float x, float y, float width, float height) {
            return IsVisible(new RectangleF(x, y, width, height));
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.IsVisible7"]/*' />
        /// <devdoc>
        /// </devdoc>
        public bool IsVisible(RectangleF rect) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisibleRect(new HandleRef(this, nativeGraphics), rect.X, rect.Y,
                                                   rect.Width, rect.Height, out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /**
         * Save/restore graphics state
         */
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Save"]/*' />
        /// <devdoc>
        /// </devdoc>
        public GraphicsState Save() {
            int state = 0;

            int status = SafeNativeMethods.GdipSaveGraphics(new HandleRef(this, nativeGraphics), out state);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new GraphicsState(state);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.Restore"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Restore(GraphicsState gstate) {
            int status = SafeNativeMethods.GdipRestoreGraphics(new HandleRef(this, nativeGraphics), gstate.nativeState);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Begin and end container drawing
         */
        // float version

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.BeginContainer"]/*' />
        /// <devdoc>
        /// </devdoc>
        public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit) {
            int state = 0;

            GPRECTF dstf = dstrect.ToGPRECTF();
            GPRECTF srcf = srcrect.ToGPRECTF();
            int status = SafeNativeMethods.GdipBeginContainer(new HandleRef(this, nativeGraphics), ref dstf,
                                                    ref srcf, (int) unit, out state);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new GraphicsContainer(state);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.BeginContainer1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public GraphicsContainer BeginContainer() {
            int state = 0;

            int status = SafeNativeMethods.GdipBeginContainer2(new HandleRef(this, nativeGraphics), out state);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new GraphicsContainer(state);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.EndContainer"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void EndContainer(GraphicsContainer container) {
            int status = SafeNativeMethods.GdipEndContainer(new HandleRef(this, nativeGraphics), container.nativeGraphicsContainer);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.BeginContainer2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit) {
            int state = 0;

            GPRECT gpDest = new GPRECT(dstrect);
            GPRECT gpSrc = new GPRECT(srcrect);

            int status = SafeNativeMethods.GdipBeginContainerI(new HandleRef(this, nativeGraphics), ref gpDest,
                                                     ref gpSrc, (int) unit, out state);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new GraphicsContainer(state);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.AddMetafileComment"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void AddMetafileComment(byte[] data) {

            int status = SafeNativeMethods.GdipComment(new HandleRef(this, nativeGraphics), data.Length, data);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Graphics.uex' path='docs/doc[@for="Graphics.GetHalftonePalette"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static IntPtr GetHalftonePalette() {
            if (halftonePalette == IntPtr.Zero) {
                lock(typeof(Graphics)) {
                    if (halftonePalette == IntPtr.Zero) {
                        if (!(Environment.OSVersion.Platform == System.PlatformID.Win32Windows)) {
                           AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnDomainUnload);
                        }
                        AppDomain.CurrentDomain.ProcessExit += new EventHandler(OnDomainUnload);

                        halftonePalette = SafeNativeMethods.GdipCreateHalftonePalette();
                    }
                }
            }
            return halftonePalette;
        }

        //This will get called for ProcessExit in case for WinNT..
        //This will get called for ProcessExit AND DomainUnLoad for Win9X...
        //
        private static void OnDomainUnload(object sender, EventArgs e) {
            if (halftonePalette != IntPtr.Zero) {
                SafeNativeMethods.DeleteObject(new HandleRef(null, halftonePalette));
                halftonePalette = IntPtr.Zero;
            }
        }


        /// <devdoc>
        ///     GDI+ will return a 'generic error' with specific win32 last error codes when
        ///     a terminal server session has been closed, minimized, etc...  We don't want 
        ///     to throw when this happens, so we'll guard against this by looking at the
        ///     'last win32 error code' and checking to see if it is either 1) access denied
        ///     or 2) proc not found and then ignore it.
        /// </devdoc>
        private void CheckErrorStatus(int status) {
            if (status != SafeNativeMethods.Ok) {
                if (status == SafeNativeMethods.GenericError) {
                    int error = SafeNativeMethods.GetLastError();
                    if (error == SafeNativeMethods.ERROR_ACCESS_DENIED || error == SafeNativeMethods.ERROR_PROC_NOT_FOUND) {
                        return;
                    }
                }
                //legitimate error, throw our status exception
                throw SafeNativeMethods.StatusException(status);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\dashcap.cs ===
//------------------------------------------------------------------------------
// <copyright file="DashCap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DashCap.cs
*
* Abstract:
*
*   Line cap constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Line cap constants
     */
    /// <include file='doc\DashCap.uex' path='docs/doc[@for="DashCap"]/*' />
    /// <devdoc>
    ///    Specifies the available dash cap
    ///    styles with which a <see cref='System.Drawing.Pen'/> can end a line.
    /// </devdoc>
    public enum DashCap
    {
        /// <include file='doc\DashCap.uex' path='docs/doc[@for="DashCap.Flat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Flat        = 0,
        /// <include file='doc\DashCap.uex' path='docs/doc[@for="DashCap.Round"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Round       = 2,
        /// <include file='doc\DashCap.uex' path='docs/doc[@for="DashCap.Triangle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Triangle    = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\brushes.cs ===
//------------------------------------------------------------------------------
// <copyright file="Brushes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes"]/*' />
    /// <devdoc>
    ///     Brushes for all the standard colors.
    /// </devdoc>
    public sealed class Brushes {
        static readonly object TransparentKey = new object();
        static readonly object AliceBlueKey = new object();
        static readonly object AntiqueWhiteKey = new object();
        static readonly object AquaKey = new object();
        static readonly object AquamarineKey = new object();
        static readonly object AzureKey = new object();
        static readonly object BeigeKey = new object();
        static readonly object BisqueKey = new object();
        static readonly object BlackKey = new object();
        static readonly object BlanchedAlmondKey = new object();
        static readonly object BlueKey = new object();
        static readonly object BlueVioletKey = new object();
        static readonly object BrownKey = new object();
        static readonly object BurlyWoodKey = new object();
        static readonly object CadetBlueKey = new object();
        static readonly object ChartreuseKey = new object();
        static readonly object ChocolateKey = new object();
        static readonly object ChoralKey = new object();
        static readonly object CornflowerBlueKey = new object();
        static readonly object CornsilkKey = new object();
        static readonly object CrimsonKey = new object();
        static readonly object CyanKey = new object();
        static readonly object DarkBlueKey = new object();
        static readonly object DarkCyanKey = new object();
        static readonly object DarkGoldenrodKey = new object();
        static readonly object DarkGrayKey = new object();
        static readonly object DarkGreenKey = new object();
        static readonly object DarkKhakiKey = new object();
        static readonly object DarkMagentaKey = new object();
        static readonly object DarkOliveGreenKey = new object();
        static readonly object DarkOrangeKey = new object();
        static readonly object DarkOrchidKey = new object();
        static readonly object DarkRedKey = new object();
        static readonly object DarkSalmonKey = new object();
        static readonly object DarkSeaGreenKey = new object();
        static readonly object DarkSlateBlueKey = new object();
        static readonly object DarkSlateGrayKey = new object();
        static readonly object DarkTurquoiseKey = new object();
        static readonly object DarkVioletKey = new object();
        static readonly object DeepPinkKey = new object();
        static readonly object DeepSkyBlueKey = new object();
        static readonly object DimGrayKey = new object();
        static readonly object DodgerBlueKey = new object();
        static readonly object FirebrickKey = new object();
        static readonly object FloralWhiteKey = new object();
        static readonly object ForestGreenKey = new object();
        static readonly object FuchiaKey = new object();
        static readonly object GainsboroKey = new object();
        static readonly object GhostWhiteKey = new object();
        static readonly object GoldKey = new object();
        static readonly object GoldenrodKey = new object();
        static readonly object GrayKey = new object();
        static readonly object GreenKey = new object();
        static readonly object GreenYellowKey = new object();
        static readonly object HoneydewKey = new object();
        static readonly object HotPinkKey = new object();
        static readonly object IndianRedKey = new object();
        static readonly object IndigoKey = new object();
        static readonly object IvoryKey = new object();
        static readonly object KhakiKey = new object();
        static readonly object LavenderKey = new object();
        static readonly object LavenderBlushKey = new object();
        static readonly object LawnGreenKey = new object();
        static readonly object LemonChiffonKey = new object();
        static readonly object LightBlueKey = new object();
        static readonly object LightCoralKey = new object();
        static readonly object LightCyanKey = new object();
        static readonly object LightGoldenrodYellowKey = new object();
        static readonly object LightGreenKey = new object();
        static readonly object LightGrayKey = new object();
        static readonly object LightPinkKey = new object();
        static readonly object LightSalmonKey = new object();
        static readonly object LightSeaGreenKey = new object();
        static readonly object LightSkyBlueKey = new object();
        static readonly object LightSlateGrayKey = new object();
        static readonly object LightSteelBlueKey = new object();
        static readonly object LightYellowKey = new object();
        static readonly object LimeKey = new object();
        static readonly object LimeGreenKey = new object();
        static readonly object LinenKey = new object();
        static readonly object MagentaKey = new object();
        static readonly object MaroonKey = new object();
        static readonly object MediumAquamarineKey = new object();
        static readonly object MediumBlueKey = new object();
        static readonly object MediumOrchidKey = new object();
        static readonly object MediumPurpleKey = new object();
        static readonly object MediumSeaGreenKey = new object();
        static readonly object MediumSlateBlueKey = new object();
        static readonly object MediumSpringGreenKey = new object();
        static readonly object MediumTurquoiseKey = new object();
        static readonly object MediumVioletRedKey = new object();
        static readonly object MidnightBlueKey = new object();
        static readonly object MintCreamKey = new object();
        static readonly object MistyRoseKey = new object();
        static readonly object MoccasinKey = new object();
        static readonly object NavajoWhiteKey = new object();
        static readonly object NavyKey = new object();
        static readonly object OldLaceKey = new object();
        static readonly object OliveKey = new object();
        static readonly object OliveDrabKey = new object();
        static readonly object OrangeKey = new object();
        static readonly object OrangeRedKey = new object();
        static readonly object OrchidKey = new object();
        static readonly object PaleGoldenrodKey = new object();
        static readonly object PaleGreenKey = new object();
        static readonly object PaleTurquoiseKey = new object();
        static readonly object PaleVioletRedKey = new object();
        static readonly object PapayaWhipKey = new object();
        static readonly object PeachPuffKey = new object();
        static readonly object PeruKey = new object();
        static readonly object PinkKey = new object();
        static readonly object PlumKey = new object();
        static readonly object PowderBlueKey = new object();
        static readonly object PurpleKey = new object();
        static readonly object RedKey = new object();
        static readonly object RosyBrownKey = new object();
        static readonly object RoyalBlueKey = new object();
        static readonly object SaddleBrownKey = new object();
        static readonly object SalmonKey = new object();
        static readonly object SandyBrownKey = new object();
        static readonly object SeaGreenKey = new object();
        static readonly object SeaShellKey = new object();
        static readonly object SiennaKey = new object();
        static readonly object SilverKey = new object();
        static readonly object SkyBlueKey = new object();
        static readonly object SlateBlueKey = new object();
        static readonly object SlateGrayKey = new object();
        static readonly object SnowKey = new object();
        static readonly object SpringGreenKey = new object();
        static readonly object SteelBlueKey = new object();
        static readonly object TanKey = new object();
        static readonly object TealKey = new object();
        static readonly object ThistleKey = new object();
        static readonly object TomatoKey = new object();
        static readonly object TurquoiseKey = new object();
        static readonly object VioletKey = new object();
        static readonly object WheatKey = new object();
        static readonly object WhiteKey = new object();
        static readonly object WhiteSmokeKey = new object();
        static readonly object YellowKey = new object();
        static readonly object YellowGreenKey = new object();

        private Brushes() {
        }

        /// <object fileKey='new object()\Brushes.uex' path='docs/doc[@for="Brushes.Transparent"]/*' />
        /// <devdoc>
        ///    <para>[object beKey new object().]</para>
        /// </devdoc>
        public static Brush Transparent {
            get {
                Brush transparent = (Brush)SafeNativeMethods.ThreadData[TransparentKey];
                if (transparent == null) {
                    transparent = new SolidBrush(Color.Transparent);
                    SafeNativeMethods.ThreadData[TransparentKey] = transparent;
                }
                return transparent;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.AliceBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush AliceBlue {
            get {
                Brush aliceBlue = (Brush)SafeNativeMethods.ThreadData[AliceBlueKey];
                if (aliceBlue == null) {
                    aliceBlue = new SolidBrush(Color.AliceBlue);
                    SafeNativeMethods.ThreadData[AliceBlueKey] = aliceBlue;
                }
                return aliceBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.AntiqueWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush AntiqueWhite {
            get {
                Brush antiqueWhite = (Brush)SafeNativeMethods.ThreadData[AntiqueWhiteKey];
                if (antiqueWhite == null) {
                    antiqueWhite = new SolidBrush(Color.AntiqueWhite);
                    SafeNativeMethods.ThreadData[AntiqueWhiteKey] = antiqueWhite;
                }
                return antiqueWhite;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Aqua"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Aqua {
            get {
                Brush aqua = (Brush)SafeNativeMethods.ThreadData[AquaKey];
                if (aqua == null) {
                    aqua = new SolidBrush(Color.Aqua);
                    SafeNativeMethods.ThreadData[AquaKey] = aqua;
                }
                return aqua;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Aquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Aquamarine {
            get {
                Brush aquamarine = (Brush)SafeNativeMethods.ThreadData[AquamarineKey];
                if (aquamarine == null) {
                    aquamarine = new SolidBrush(Color.Aquamarine);
                    SafeNativeMethods.ThreadData[AquamarineKey] = aquamarine;
                }
                return aquamarine;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Azure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Azure {
            get {
                Brush azure = (Brush)SafeNativeMethods.ThreadData[AzureKey];
                if (azure == null) {
                    azure = new SolidBrush(Color.Azure);
                    SafeNativeMethods.ThreadData[AzureKey] = azure;
                }
                return azure;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Beige"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Beige {
            get {
                Brush beige = (Brush)SafeNativeMethods.ThreadData[BeigeKey];
                if (beige == null) {
                    beige = new SolidBrush(Color.Beige);
                    SafeNativeMethods.ThreadData[BeigeKey] = beige;
                }
                return beige;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Bisque"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Bisque {
            get {
                Brush bisque = (Brush)SafeNativeMethods.ThreadData[BisqueKey];
                if (bisque == null) {
                    bisque = new SolidBrush(Color.Bisque);
                    SafeNativeMethods.ThreadData[BisqueKey] = bisque;
                }
                return bisque;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Black"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Black {
            get {
                Brush black = (Brush)SafeNativeMethods.ThreadData[BlackKey];
                if (black == null) {
                    black = new SolidBrush(Color.Black);
                    SafeNativeMethods.ThreadData[BlackKey] = black;
                }
                return black;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.BlanchedAlmond"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush BlanchedAlmond {
            get {
                Brush blanchedAlmond = (Brush)SafeNativeMethods.ThreadData[BlanchedAlmondKey];
                if (blanchedAlmond == null) {
                    blanchedAlmond = new SolidBrush(Color.BlanchedAlmond);
                    SafeNativeMethods.ThreadData[BlanchedAlmondKey] = blanchedAlmond;
                }
                return blanchedAlmond;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Blue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Blue {
            get {
                Brush blue = (Brush)SafeNativeMethods.ThreadData[BlueKey];
                if (blue == null) {
                    blue = new SolidBrush(Color.Blue);
                    SafeNativeMethods.ThreadData[BlueKey] = blue;
                }
                return blue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.BlueViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush BlueViolet {
            get {
                Brush blueViolet = (Brush)SafeNativeMethods.ThreadData[BlueVioletKey];
                if (blueViolet == null) {
                    blueViolet = new SolidBrush(Color.BlueViolet);
                    SafeNativeMethods.ThreadData[BlueVioletKey] = blueViolet;
                }
                return blueViolet;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Brown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Brown {
            get {
                Brush brown = (Brush)SafeNativeMethods.ThreadData[BrownKey];
                if (brown == null) {
                    brown = new SolidBrush(Color.Brown);
                    SafeNativeMethods.ThreadData[BrownKey] = brown;
                }
                return brown;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.BurlyWood"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush BurlyWood {
            get {
                Brush burlyWood = (Brush)SafeNativeMethods.ThreadData[BurlyWoodKey];
                if (burlyWood == null) {
                    burlyWood = new SolidBrush(Color.BurlyWood);
                    SafeNativeMethods.ThreadData[BurlyWoodKey] = burlyWood;
                }
                return burlyWood;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.CadetBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush CadetBlue {
            get {
                Brush cadetBlue = (Brush)SafeNativeMethods.ThreadData[CadetBlueKey];
                if (cadetBlue == null) {
                    cadetBlue = new SolidBrush(Color.CadetBlue);
                    SafeNativeMethods.ThreadData[CadetBlueKey] = cadetBlue;
                }
                return cadetBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Chartreuse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Chartreuse {
            get {
                Brush chartreuse = (Brush)SafeNativeMethods.ThreadData[ChartreuseKey];
                if (chartreuse == null) {
                    chartreuse = new SolidBrush(Color.Chartreuse);
                    SafeNativeMethods.ThreadData[ChartreuseKey] = chartreuse;
                }
                return chartreuse;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Chocolate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Chocolate {
            get {
                Brush chocolate = (Brush)SafeNativeMethods.ThreadData[ChocolateKey];
                if (chocolate == null) {
                    chocolate = new SolidBrush(Color.Chocolate);
                    SafeNativeMethods.ThreadData[ChocolateKey] = chocolate;
                }
                return chocolate;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Coral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Coral {
            get {
                Brush choral = (Brush)SafeNativeMethods.ThreadData[ChoralKey];
                if (choral == null) {
                    choral = new SolidBrush(Color.Coral);
                    SafeNativeMethods.ThreadData[ChoralKey] = choral;
                }
                return choral;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.CornflowerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush CornflowerBlue {
            get {
                Brush cornflowerBlue = (Brush)SafeNativeMethods.ThreadData[CornflowerBlueKey];
                if (cornflowerBlue== null) {
                    cornflowerBlue = new SolidBrush(Color.CornflowerBlue);
                    SafeNativeMethods.ThreadData[CornflowerBlueKey] = cornflowerBlue;
                }
                return cornflowerBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Cornsilk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Cornsilk {
            get {
                Brush cornsilk = (Brush)SafeNativeMethods.ThreadData[CornsilkKey];
                if (cornsilk == null) {
                    cornsilk = new SolidBrush(Color.Cornsilk);
                    SafeNativeMethods.ThreadData[CornsilkKey] = cornsilk;
                }
                return cornsilk;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Crimson"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Crimson {
            get {
                Brush crimson = (Brush)SafeNativeMethods.ThreadData[CrimsonKey];
                if (crimson == null) {
                    crimson = new SolidBrush(Color.Crimson);
                    SafeNativeMethods.ThreadData[CrimsonKey] = crimson;
                }
                return crimson;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Cyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Cyan {
            get {
                Brush cyan = (Brush)SafeNativeMethods.ThreadData[CyanKey];
                if (cyan == null) {
                    cyan = new SolidBrush(Color.Cyan);
                    SafeNativeMethods.ThreadData[CyanKey] = cyan;
                }
                return cyan;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkBlue {
            get {
                Brush darkBlue = (Brush)SafeNativeMethods.ThreadData[DarkBlueKey];
                if (darkBlue == null) {
                    darkBlue = new SolidBrush(Color.DarkBlue);
                    SafeNativeMethods.ThreadData[DarkBlueKey] = darkBlue;
                }
                return darkBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkCyan {
            get {
                Brush darkCyan = (Brush)SafeNativeMethods.ThreadData[DarkCyanKey];
                if (darkCyan == null) {
                    darkCyan = new SolidBrush(Color.DarkCyan);
                    SafeNativeMethods.ThreadData[DarkCyanKey] = darkCyan;
                }
                return darkCyan;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkGoldenrod {
            get {
                Brush darkGoldenrod = (Brush)SafeNativeMethods.ThreadData[DarkGoldenrodKey];
                if (darkGoldenrod == null) {
                    darkGoldenrod = new SolidBrush(Color.DarkGoldenrod);
                    SafeNativeMethods.ThreadData[DarkGoldenrodKey] = darkGoldenrod;
                }
                return darkGoldenrod;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkGray {
            get {
                Brush darkGray = (Brush)SafeNativeMethods.ThreadData[DarkGrayKey];
                if (darkGray == null) {
                    darkGray = new SolidBrush(Color.DarkGray);
                    SafeNativeMethods.ThreadData[DarkGrayKey] = darkGray;
                }
                return darkGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkGreen {
            get {
                Brush darkGreen = (Brush)SafeNativeMethods.ThreadData[DarkGreenKey];
                if (darkGreen == null) {
                    darkGreen = new SolidBrush(Color.DarkGreen);
                    SafeNativeMethods.ThreadData[DarkGreenKey] = darkGreen;
                }
                return darkGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkKhaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkKhaki {
            get {
                Brush darkKhaki = (Brush)SafeNativeMethods.ThreadData[DarkKhakiKey];
                if (darkKhaki == null) {
                    darkKhaki = new SolidBrush(Color.DarkKhaki);
                    SafeNativeMethods.ThreadData[DarkKhakiKey] = darkKhaki;
                }
                return darkKhaki;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkMagenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkMagenta {
            get {
                Brush darkMagenta = (Brush)SafeNativeMethods.ThreadData[DarkMagentaKey];
                if (darkMagenta == null) {
                    darkMagenta = new SolidBrush(Color.DarkMagenta);
                    SafeNativeMethods.ThreadData[DarkMagentaKey] = darkMagenta;
                }
                return darkMagenta;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkOliveGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkOliveGreen {
            get {
                Brush darkOliveGreen = (Brush)SafeNativeMethods.ThreadData[DarkOliveGreenKey];
                if (darkOliveGreen == null) {
                    darkOliveGreen = new SolidBrush(Color.DarkOliveGreen);
                    SafeNativeMethods.ThreadData[DarkOliveGreenKey] = darkOliveGreen;
                }
                return darkOliveGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkOrange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkOrange {
            get {
                Brush darkOrange = (Brush)SafeNativeMethods.ThreadData[DarkOrangeKey];
                if (darkOrange == null) {
                    darkOrange = new SolidBrush(Color.DarkOrange);
                    SafeNativeMethods.ThreadData[DarkOrangeKey] = darkOrange;
                }
                return darkOrange;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkOrchid {
            get {
                Brush darkOrchid = (Brush)SafeNativeMethods.ThreadData[DarkOrchidKey];
                if (darkOrchid == null) {
                    darkOrchid = new SolidBrush(Color.DarkOrchid);
                    SafeNativeMethods.ThreadData[DarkOrchidKey] = darkOrchid;
                }
                return darkOrchid;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkRed {
            get {
                Brush darkRed = (Brush)SafeNativeMethods.ThreadData[DarkRedKey];
                if (darkRed == null) {
                    darkRed = new SolidBrush(Color.DarkRed);
                    SafeNativeMethods.ThreadData[DarkRedKey] = darkRed;
                }
                return darkRed;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkSalmon {
            get {
                Brush darkSalmon = (Brush)SafeNativeMethods.ThreadData[DarkSalmonKey];
                if (darkSalmon == null) {
                    darkSalmon = new SolidBrush(Color.DarkSalmon);
                    SafeNativeMethods.ThreadData[DarkSalmonKey] = darkSalmon;
                }
                return darkSalmon;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkSeaGreen {
            get {
                Brush darkSeaGreen = (Brush)SafeNativeMethods.ThreadData[DarkSeaGreenKey];
                if (darkSeaGreen == null) {
                    darkSeaGreen = new SolidBrush(Color.DarkSeaGreen);
                    SafeNativeMethods.ThreadData[DarkSeaGreenKey] = darkSeaGreen;
                }
                return darkSeaGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkSlateBlue {
            get {
                Brush darkSlateBlue = (Brush)SafeNativeMethods.ThreadData[DarkSlateBlueKey];
                if (darkSlateBlue == null) {
                    darkSlateBlue = new SolidBrush(Color.DarkSlateBlue);
                    SafeNativeMethods.ThreadData[DarkSlateBlueKey] = darkSlateBlue;
                }
                return darkSlateBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkSlateGray {
            get {
                Brush darkSlateGray = (Brush)SafeNativeMethods.ThreadData[DarkSlateGrayKey];
                if (darkSlateGray == null) {
                    darkSlateGray = new SolidBrush(Color.DarkSlateGray);
                    SafeNativeMethods.ThreadData[DarkSlateGrayKey] = darkSlateGray;
                }
                return darkSlateGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkTurquoise {
            get {
                Brush darkTurquoise = (Brush)SafeNativeMethods.ThreadData[DarkTurquoiseKey];
                if (darkTurquoise == null) {
                    darkTurquoise = new SolidBrush(Color.DarkTurquoise);
                    SafeNativeMethods.ThreadData[DarkTurquoiseKey] = darkTurquoise;
                }
                return darkTurquoise;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DarkViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DarkViolet {
            get {
                Brush darkViolet = (Brush)SafeNativeMethods.ThreadData[DarkVioletKey];
                if (darkViolet == null) {
                    darkViolet = new SolidBrush(Color.DarkViolet);
                    SafeNativeMethods.ThreadData[DarkVioletKey] = darkViolet;
                }
                return darkViolet;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DeepPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DeepPink {
            get {
                Brush deepPink = (Brush)SafeNativeMethods.ThreadData[DeepPinkKey];
                if (deepPink == null) {
                    deepPink = new SolidBrush(Color.DeepPink);
                    SafeNativeMethods.ThreadData[DeepPinkKey] = deepPink;
                }
                return deepPink;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DeepSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DeepSkyBlue {
            get {
                Brush deepSkyBlue = (Brush)SafeNativeMethods.ThreadData[DeepSkyBlueKey];
                if (deepSkyBlue == null) {
                    deepSkyBlue = new SolidBrush(Color.DeepSkyBlue);
                    SafeNativeMethods.ThreadData[DeepSkyBlueKey] = deepSkyBlue;
                }
                return deepSkyBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DimGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DimGray {
            get {
                Brush dimGray = (Brush)SafeNativeMethods.ThreadData[DimGrayKey];
                if (dimGray == null) {
                    dimGray = new SolidBrush(Color.DimGray);
                    SafeNativeMethods.ThreadData[DimGrayKey] = dimGray;
                }
                return dimGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.DodgerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush DodgerBlue {
            get {
                Brush dodgerBlue = (Brush)SafeNativeMethods.ThreadData[DodgerBlueKey];
                if (dodgerBlue == null) {
                    dodgerBlue = new SolidBrush(Color.DodgerBlue);
                    SafeNativeMethods.ThreadData[DodgerBlueKey] = dodgerBlue;
                }
                return dodgerBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Firebrick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Firebrick {
            get {
                Brush firebrick = (Brush)SafeNativeMethods.ThreadData[FirebrickKey];
                if (firebrick == null) {
                    firebrick = new SolidBrush(Color.Firebrick);
                    SafeNativeMethods.ThreadData[FirebrickKey] = firebrick;
                }
                return firebrick;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.FloralWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush FloralWhite {
            get {
                Brush floralWhite = (Brush)SafeNativeMethods.ThreadData[FloralWhiteKey];
                if (floralWhite == null) {
                    floralWhite = new SolidBrush(Color.FloralWhite);
                    SafeNativeMethods.ThreadData[FloralWhiteKey] = floralWhite;
                }
                return floralWhite;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.ForestGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush ForestGreen {
            get {
                Brush forestGreen = (Brush)SafeNativeMethods.ThreadData[ForestGreenKey];
                if (forestGreen == null) {
                    forestGreen = new SolidBrush(Color.ForestGreen);
                    SafeNativeMethods.ThreadData[ForestGreenKey] = forestGreen;
                }
                return forestGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Fuchsia"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Fuchsia {
            get {
                Brush fuchia = (Brush)SafeNativeMethods.ThreadData[FuchiaKey];
                if (fuchia == null) {
                    fuchia = new SolidBrush(Color.Fuchsia);
                    SafeNativeMethods.ThreadData[FuchiaKey] = fuchia;
                }
                return fuchia;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Gainsboro"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Gainsboro {
            get {
                Brush gainsboro = (Brush)SafeNativeMethods.ThreadData[GainsboroKey];
                if (gainsboro == null) {
                    gainsboro = new SolidBrush(Color.Gainsboro);
                    SafeNativeMethods.ThreadData[GainsboroKey] = gainsboro;
                }
                return gainsboro;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.GhostWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush GhostWhite {
            get {
                Brush ghostWhite = (Brush)SafeNativeMethods.ThreadData[GhostWhiteKey];
                if (ghostWhite == null) {
                    ghostWhite = new SolidBrush(Color.GhostWhite);
                    SafeNativeMethods.ThreadData[GhostWhiteKey] = ghostWhite;
                }
                return ghostWhite;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Gold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Gold {
            get {
                Brush gold = (Brush)SafeNativeMethods.ThreadData[GoldKey];
                if (gold == null) {
                    gold = new SolidBrush(Color.Gold);
                    SafeNativeMethods.ThreadData[GoldKey] = gold;
                }
                return gold;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Goldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Goldenrod {
            get {
                Brush goldenrod = (Brush)SafeNativeMethods.ThreadData[GoldenrodKey];
                if (goldenrod == null) {
                    goldenrod = new SolidBrush(Color.Goldenrod);
                    SafeNativeMethods.ThreadData[GoldenrodKey] = goldenrod;
                }
                return goldenrod;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Gray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Gray {
            get {
                Brush gray = (Brush)SafeNativeMethods.ThreadData[GrayKey];
                if (gray == null) {
                    gray = new SolidBrush(Color.Gray);
                    SafeNativeMethods.ThreadData[GrayKey] = gray;
                }
                return gray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Green"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Green {
            get {
                Brush green = (Brush)SafeNativeMethods.ThreadData[GreenKey];
                if (green == null) {
                    green = new SolidBrush(Color.Green);
                    SafeNativeMethods.ThreadData[GreenKey] = green;
                }
                return green;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.GreenYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush GreenYellow {
            get {
                Brush greenYellow = (Brush)SafeNativeMethods.ThreadData[GreenYellowKey];
                if (greenYellow == null) {
                    greenYellow = new SolidBrush(Color.GreenYellow);
                    SafeNativeMethods.ThreadData[GreenYellowKey] = greenYellow;
                }
                return greenYellow;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Honeydew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Honeydew {
            get {
                Brush honeydew = (Brush)SafeNativeMethods.ThreadData[HoneydewKey];
                if (honeydew == null) {
                    honeydew = new SolidBrush(Color.Honeydew);
                    SafeNativeMethods.ThreadData[HoneydewKey] = honeydew;
                }
                return honeydew;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.HotPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush HotPink {
            get {
                Brush hotPink = (Brush)SafeNativeMethods.ThreadData[HotPinkKey];
                if (hotPink == null) {
                    hotPink = new SolidBrush(Color.HotPink);
                    SafeNativeMethods.ThreadData[HotPinkKey] = hotPink;
                }
                return hotPink;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.IndianRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush IndianRed {
            get {
                Brush indianRed = (Brush)SafeNativeMethods.ThreadData[IndianRedKey];
                if (indianRed == null) {
                    indianRed = new SolidBrush(Color.IndianRed);
                    SafeNativeMethods.ThreadData[IndianRedKey] = indianRed;
                }
                return indianRed;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Indigo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Indigo {
            get {
                Brush indigo = (Brush)SafeNativeMethods.ThreadData[IndigoKey];
                if (indigo == null) {
                    indigo = new SolidBrush(Color.Indigo);
                    SafeNativeMethods.ThreadData[IndigoKey] = indigo;
                }
                return indigo;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Ivory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Ivory {
            get {
                Brush ivory = (Brush)SafeNativeMethods.ThreadData[IvoryKey];
                if (ivory == null) {
                    ivory = new SolidBrush(Color.Ivory);
                    SafeNativeMethods.ThreadData[IvoryKey] = ivory;
                }
                return ivory;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Khaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Khaki {
            get {
                Brush khaki = (Brush)SafeNativeMethods.ThreadData[KhakiKey];
                if (khaki == null) {
                    khaki = new SolidBrush(Color.Khaki);
                    SafeNativeMethods.ThreadData[KhakiKey] = khaki;
                }
                return khaki;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Lavender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Lavender {
            get {
                Brush lavender = (Brush)SafeNativeMethods.ThreadData[LavenderKey];
                if (lavender == null) {
                    lavender = new SolidBrush(Color.Lavender);
                    SafeNativeMethods.ThreadData[LavenderKey] = lavender;
                }
                return lavender;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LavenderBlush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LavenderBlush {
            get {
                Brush lavenderBlush = (Brush)SafeNativeMethods.ThreadData[LavenderBlushKey];
                if (lavenderBlush == null) {
                    lavenderBlush = new SolidBrush(Color.LavenderBlush);
                    SafeNativeMethods.ThreadData[LavenderBlushKey] = lavenderBlush;
                }
                return lavenderBlush;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LawnGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LawnGreen {
            get {
                Brush lawnGreen = (Brush)SafeNativeMethods.ThreadData[LawnGreenKey];
                if (lawnGreen == null) {
                    lawnGreen = new SolidBrush(Color.LawnGreen);
                    SafeNativeMethods.ThreadData[LawnGreenKey] = lawnGreen;
                }
                return lawnGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LemonChiffon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LemonChiffon {
            get {
                Brush lemonChiffon = (Brush)SafeNativeMethods.ThreadData[LemonChiffonKey];
                if (lemonChiffon == null) {
                    lemonChiffon = new SolidBrush(Color.LemonChiffon);
                    SafeNativeMethods.ThreadData[LemonChiffonKey] = lemonChiffon;
                }
                return lemonChiffon;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightBlue {
            get {
                Brush lightBlue = (Brush)SafeNativeMethods.ThreadData[LightBlueKey];
                if (lightBlue == null) {
                    lightBlue = new SolidBrush(Color.LightBlue);
                    SafeNativeMethods.ThreadData[LightBlueKey] = lightBlue;
                }
                return lightBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightCoral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightCoral {
            get {
                Brush lightCoral = (Brush)SafeNativeMethods.ThreadData[LightCoralKey];
                if (lightCoral == null) {
                    lightCoral = new SolidBrush(Color.LightCoral);
                    SafeNativeMethods.ThreadData[LightCoralKey] = lightCoral;
                }
                return lightCoral;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightCyan {
            get {
                Brush lightCyan = (Brush)SafeNativeMethods.ThreadData[LightCyanKey];
                if (lightCyan == null) {
                    lightCyan = new SolidBrush(Color.LightCyan);
                    SafeNativeMethods.ThreadData[LightCyanKey] = lightCyan;
                }
                return lightCyan;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightGoldenrodYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightGoldenrodYellow {
            get {
                Brush lightGoldenrodYellow = (Brush)SafeNativeMethods.ThreadData[LightGoldenrodYellowKey];
                if (lightGoldenrodYellow == null) {
                    lightGoldenrodYellow = new SolidBrush(Color.LightGoldenrodYellow);
                    SafeNativeMethods.ThreadData[LightGoldenrodYellowKey] = lightGoldenrodYellow;
                }
                return lightGoldenrodYellow;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightGreen {
            get {
                Brush lightGreen = (Brush)SafeNativeMethods.ThreadData[LightGreenKey];
                if (lightGreen == null) {
                    lightGreen = new SolidBrush(Color.LightGreen);
                    SafeNativeMethods.ThreadData[LightGreenKey] = lightGreen;
                }
                return lightGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightGray {
            get {
                Brush lightGray = (Brush)SafeNativeMethods.ThreadData[LightGrayKey];
                if (lightGray == null) {
                    lightGray = new SolidBrush(Color.LightGray);
                    SafeNativeMethods.ThreadData[LightGrayKey] = lightGray;
                }
                return lightGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightPink {
            get {
                Brush lightPink = (Brush)SafeNativeMethods.ThreadData[LightPinkKey];
                if (lightPink == null) {
                    lightPink = new SolidBrush(Color.LightPink);
                    SafeNativeMethods.ThreadData[LightPinkKey] = lightPink;
                }
                return lightPink;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightSalmon {
            get {
                Brush lightSalmon = (Brush)SafeNativeMethods.ThreadData[LightSalmonKey];
                if (lightSalmon == null) {
                    lightSalmon = new SolidBrush(Color.LightSalmon);
                    SafeNativeMethods.ThreadData[LightSalmonKey] = lightSalmon;
                }
                return lightSalmon;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightSeaGreen {
            get {
                Brush lightSeaGreen = (Brush)SafeNativeMethods.ThreadData[LightSeaGreenKey];
                if (lightSeaGreen == null) {
                    lightSeaGreen = new SolidBrush(Color.LightSeaGreen);
                    SafeNativeMethods.ThreadData[LightSeaGreenKey] = lightSeaGreen;
                }
                return lightSeaGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightSkyBlue {
            get {
                Brush lightSkyBlue = (Brush)SafeNativeMethods.ThreadData[LightSkyBlueKey];
                if (lightSkyBlue == null) {
                    lightSkyBlue = new SolidBrush(Color.LightSkyBlue);
                    SafeNativeMethods.ThreadData[LightSkyBlueKey] = lightSkyBlue;
                }
                return lightSkyBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightSlateGray {
            get {
                Brush lightSlateGray = (Brush)SafeNativeMethods.ThreadData[LightSlateGrayKey];
                if (lightSlateGray == null) {
                    lightSlateGray = new SolidBrush(Color.LightSlateGray);
                    SafeNativeMethods.ThreadData[LightSlateGrayKey] = lightSlateGray;
                }
                return lightSlateGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightSteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightSteelBlue {
            get {
                Brush lightSteelBlue = (Brush)SafeNativeMethods.ThreadData[LightSteelBlueKey];
                if (lightSteelBlue == null) {
                    lightSteelBlue = new SolidBrush(Color.LightSteelBlue);
                    SafeNativeMethods.ThreadData[LightSteelBlueKey] = lightSteelBlue;
                }
                return lightSteelBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LightYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LightYellow {
            get {
                Brush lightYellow = (Brush)SafeNativeMethods.ThreadData[LightYellowKey];
                if (lightYellow == null) {
                    lightYellow = new SolidBrush(Color.LightYellow);
                    SafeNativeMethods.ThreadData[LightYellowKey] = lightYellow;
                }
                return lightYellow;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Lime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Lime {
            get {
                Brush lime = (Brush)SafeNativeMethods.ThreadData[LimeKey];
                if (lime == null) {
                    lime = new SolidBrush(Color.Lime);
                    SafeNativeMethods.ThreadData[LimeKey] = lime;
                }
                return lime;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.LimeGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush LimeGreen {
            get {
                Brush limeGreen = (Brush)SafeNativeMethods.ThreadData[LimeGreenKey];
                if (limeGreen == null) {
                    limeGreen = new SolidBrush(Color.LimeGreen);
                    SafeNativeMethods.ThreadData[LimeGreenKey] = limeGreen;
                }
                return limeGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Linen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Linen {
            get {
                Brush linen = (Brush)SafeNativeMethods.ThreadData[LinenKey];
                if (linen == null) {
                    linen = new SolidBrush(Color.Linen);
                    SafeNativeMethods.ThreadData[LinenKey] = linen;
                }
                return linen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Magenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Magenta {
            get {
                Brush magenta = (Brush)SafeNativeMethods.ThreadData[MagentaKey];
                if (magenta == null) {
                    magenta = new SolidBrush(Color.Magenta);
                    SafeNativeMethods.ThreadData[MagentaKey] = magenta;
                }
                return magenta;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Maroon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Maroon {
            get {
                Brush maroon = (Brush)SafeNativeMethods.ThreadData[MaroonKey];
                if (maroon == null) {
                    maroon = new SolidBrush(Color.Maroon);
                    SafeNativeMethods.ThreadData[MaroonKey] = maroon;
                }
                return maroon;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumAquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumAquamarine {
            get {
                Brush mediumAquamarine = (Brush)SafeNativeMethods.ThreadData[MediumAquamarineKey];
                if (mediumAquamarine == null) {
                    mediumAquamarine = new SolidBrush(Color.MediumAquamarine);
                    SafeNativeMethods.ThreadData[MediumAquamarineKey] = mediumAquamarine;
                }
                return mediumAquamarine;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumBlue {
            get {
                Brush mediumBlue = (Brush)SafeNativeMethods.ThreadData[MediumBlueKey];
                if (mediumBlue == null) {
                    mediumBlue = new SolidBrush(Color.MediumBlue);
                    SafeNativeMethods.ThreadData[MediumBlueKey] = mediumBlue;
                }
                return mediumBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumOrchid {
            get {
                Brush mediumOrchid = (Brush)SafeNativeMethods.ThreadData[MediumOrchidKey];
                if (mediumOrchid == null) {
                    mediumOrchid = new SolidBrush(Color.MediumOrchid);
                    SafeNativeMethods.ThreadData[MediumOrchidKey] = mediumOrchid;
                }
                return mediumOrchid;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumPurple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumPurple {
            get {
                Brush mediumPurple = (Brush)SafeNativeMethods.ThreadData[MediumPurpleKey];
                if (mediumPurple == null) {
                    mediumPurple = new SolidBrush(Color.MediumPurple);
                    SafeNativeMethods.ThreadData[MediumPurpleKey] = mediumPurple;
                }
                return mediumPurple;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumSeaGreen {
            get {
                Brush mediumSeaGreen = (Brush)SafeNativeMethods.ThreadData[MediumSeaGreenKey];
                if (mediumSeaGreen == null) {
                    mediumSeaGreen = new SolidBrush(Color.MediumSeaGreen);
                    SafeNativeMethods.ThreadData[MediumSeaGreenKey] = mediumSeaGreen;
                }
                return mediumSeaGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumSlateBlue {
            get {
                Brush mediumSlateBlue = (Brush)SafeNativeMethods.ThreadData[MediumSlateBlueKey];
                if (mediumSlateBlue == null) {
                    mediumSlateBlue = new SolidBrush(Color.MediumSlateBlue);
                    SafeNativeMethods.ThreadData[MediumSlateBlueKey] = mediumSlateBlue;
                }
                return mediumSlateBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumSpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumSpringGreen {
            get {
                Brush mediumSpringGreen = (Brush)SafeNativeMethods.ThreadData[MediumSpringGreenKey];
                if (mediumSpringGreen == null) {
                    mediumSpringGreen = new SolidBrush(Color.MediumSpringGreen);
                    SafeNativeMethods.ThreadData[MediumSpringGreenKey] = mediumSpringGreen;
                }
                return mediumSpringGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumTurquoise {
            get {
                Brush mediumTurquoise = (Brush)SafeNativeMethods.ThreadData[MediumTurquoiseKey];
                if (mediumTurquoise == null) {
                    mediumTurquoise = new SolidBrush(Color.MediumTurquoise);
                    SafeNativeMethods.ThreadData[MediumTurquoiseKey] = mediumTurquoise;
                }
                return mediumTurquoise;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MediumVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MediumVioletRed {
            get {
                Brush mediumVioletRed = (Brush)SafeNativeMethods.ThreadData[MediumVioletRedKey];
                if (mediumVioletRed == null) {
                    mediumVioletRed = new SolidBrush(Color.MediumVioletRed);
                    SafeNativeMethods.ThreadData[MediumVioletRedKey] = mediumVioletRed;
                }
                return mediumVioletRed;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MidnightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MidnightBlue {
            get {
                Brush midnightBlue = (Brush)SafeNativeMethods.ThreadData[MidnightBlueKey];
                if (midnightBlue == null) {
                    midnightBlue = new SolidBrush(Color.MidnightBlue);
                    SafeNativeMethods.ThreadData[MidnightBlueKey] = midnightBlue;
                }
                return midnightBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MintCream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MintCream {
            get {
                Brush mintCream = (Brush)SafeNativeMethods.ThreadData[MintCreamKey];
                if (mintCream == null) {
                    mintCream = new SolidBrush(Color.MintCream);
                    SafeNativeMethods.ThreadData[MintCreamKey] = mintCream;
                }
                return mintCream;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.MistyRose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush MistyRose {
            get {
                Brush mistyRose = (Brush)SafeNativeMethods.ThreadData[MistyRoseKey];
                if (mistyRose == null) {
                    mistyRose = new SolidBrush(Color.MistyRose);
                    SafeNativeMethods.ThreadData[MistyRoseKey] = mistyRose;
                }
                return mistyRose;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Moccasin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Moccasin {
            get {
                Brush moccasin = (Brush)SafeNativeMethods.ThreadData[MoccasinKey];
                if (moccasin == null) {
                    moccasin = new SolidBrush(Color.Moccasin);
                    SafeNativeMethods.ThreadData[MoccasinKey] = moccasin;
                }
                return moccasin;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.NavajoWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush NavajoWhite {
            get {
                Brush navajoWhite = (Brush)SafeNativeMethods.ThreadData[NavajoWhiteKey];
                if (navajoWhite == null) {
                    navajoWhite = new SolidBrush(Color.NavajoWhite);
                    SafeNativeMethods.ThreadData[NavajoWhiteKey] = navajoWhite;
                }
                return navajoWhite;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Navy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Navy {
            get {
                Brush navy = (Brush)SafeNativeMethods.ThreadData[NavyKey];
                if (navy == null) {
                    navy = new SolidBrush(Color.Navy);
                    SafeNativeMethods.ThreadData[NavyKey] = navy;
                }
                return navy;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.OldLace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush OldLace {
            get {
                Brush oldLace = (Brush)SafeNativeMethods.ThreadData[OldLaceKey];
                if (oldLace == null) {
                    oldLace = new SolidBrush(Color.OldLace);
                    SafeNativeMethods.ThreadData[OldLaceKey] = oldLace;
                }
                return oldLace;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Olive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Olive {
            get {
                Brush olive = (Brush)SafeNativeMethods.ThreadData[OliveKey];
                if (olive == null) {
                    olive = new SolidBrush(Color.Olive);
                    SafeNativeMethods.ThreadData[OliveKey] = olive;
                }
                return olive;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.OliveDrab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush OliveDrab {
            get {
                Brush oliveDrab = (Brush)SafeNativeMethods.ThreadData[OliveDrabKey];
                if (oliveDrab == null) {
                    oliveDrab = new SolidBrush(Color.OliveDrab);
                    SafeNativeMethods.ThreadData[OliveDrabKey] = oliveDrab;
                }
                return oliveDrab;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Orange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Orange {
            get {
                Brush orange = (Brush)SafeNativeMethods.ThreadData[OrangeKey];
                if (orange == null) {
                    orange = new SolidBrush(Color.Orange);
                    SafeNativeMethods.ThreadData[OrangeKey] = orange;
                }
                return orange;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.OrangeRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush OrangeRed {
            get {
                Brush orangeRed = (Brush)SafeNativeMethods.ThreadData[OrangeRedKey];
                if (orangeRed == null) {
                    orangeRed = new SolidBrush(Color.OrangeRed);
                    SafeNativeMethods.ThreadData[OrangeRedKey] = orangeRed;
                }
                return orangeRed;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Orchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Orchid {
            get {
                Brush orchid = (Brush)SafeNativeMethods.ThreadData[OrchidKey];
                if (orchid == null) {
                    orchid = new SolidBrush(Color.Orchid);
                    SafeNativeMethods.ThreadData[OrchidKey] = orchid;
                }
                return orchid;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PaleGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PaleGoldenrod {
            get {
                Brush paleGoldenrod = (Brush)SafeNativeMethods.ThreadData[PaleGoldenrodKey];
                if (paleGoldenrod == null) {
                    paleGoldenrod = new SolidBrush(Color.PaleGoldenrod);
                    SafeNativeMethods.ThreadData[PaleGoldenrodKey] = paleGoldenrod;
                }
                return paleGoldenrod;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PaleGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PaleGreen {
            get {
                Brush paleGreen = (Brush)SafeNativeMethods.ThreadData[PaleGreenKey];
                if (paleGreen == null) {
                    paleGreen = new SolidBrush(Color.PaleGreen);
                    SafeNativeMethods.ThreadData[PaleGreenKey] = paleGreen;
                }
                return paleGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PaleTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PaleTurquoise {
            get {
                Brush paleTurquoise = (Brush)SafeNativeMethods.ThreadData[PaleTurquoiseKey];
                if (paleTurquoise == null) {
                    paleTurquoise = new SolidBrush(Color.PaleTurquoise);
                    SafeNativeMethods.ThreadData[PaleTurquoiseKey] = paleTurquoise;
                }
                return paleTurquoise;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PaleVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PaleVioletRed {
            get {
                Brush paleVioletRed = (Brush)SafeNativeMethods.ThreadData[PaleVioletRedKey];
                if (paleVioletRed == null) {
                    paleVioletRed = new SolidBrush(Color.PaleVioletRed);
                    SafeNativeMethods.ThreadData[PaleVioletRedKey] = paleVioletRed;
                }
                return paleVioletRed;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PapayaWhip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PapayaWhip {
            get {
                Brush papayaWhip = (Brush)SafeNativeMethods.ThreadData[PapayaWhipKey];
                if (papayaWhip == null) {
                    papayaWhip = new SolidBrush(Color.PapayaWhip);
                    SafeNativeMethods.ThreadData[PapayaWhipKey] = papayaWhip;
                }
                return papayaWhip;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PeachPuff"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PeachPuff {
            get {
                Brush peachPuff = (Brush)SafeNativeMethods.ThreadData[PeachPuffKey];
                if (peachPuff == null) {
                    peachPuff = new SolidBrush(Color.PeachPuff);
                    SafeNativeMethods.ThreadData[PeachPuffKey] = peachPuff;
                }
                return peachPuff;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Peru"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Peru {
            get {
                Brush peru = (Brush)SafeNativeMethods.ThreadData[PeruKey];
                if (peru == null) {
                    peru = new SolidBrush(Color.Peru);
                    SafeNativeMethods.ThreadData[PeruKey] = peru;
                }
                return peru;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Pink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Pink {
            get {
                Brush pink = (Brush)SafeNativeMethods.ThreadData[PinkKey];
                if (pink == null) {
                    pink = new SolidBrush(Color.Pink);
                    SafeNativeMethods.ThreadData[PinkKey] = pink;
                }
                return pink;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Plum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Plum {
            get {
                Brush plum = (Brush)SafeNativeMethods.ThreadData[PlumKey];
                if (plum == null) {
                    plum = new SolidBrush(Color.Plum);
                    SafeNativeMethods.ThreadData[PlumKey] = plum;
                }
                return plum;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.PowderBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush PowderBlue {
            get {
                Brush powderBlue = (Brush)SafeNativeMethods.ThreadData[PowderBlueKey];
                if (powderBlue == null) {
                    powderBlue = new SolidBrush(Color.PowderBlue);
                    SafeNativeMethods.ThreadData[PowderBlueKey] = powderBlue;
                }
                return powderBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Purple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Purple {
            get {
                Brush purple = (Brush)SafeNativeMethods.ThreadData[PurpleKey];
                if (purple == null) {
                    purple = new SolidBrush(Color.Purple);
                    SafeNativeMethods.ThreadData[PurpleKey] = purple;
                }
                return purple;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Red"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Red {
            get {
                Brush red = (Brush)SafeNativeMethods.ThreadData[RedKey];
                if (red == null) {
                    red = new SolidBrush(Color.Red);
                    SafeNativeMethods.ThreadData[RedKey] = red;
                }
                return red;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.RosyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush RosyBrown {
            get {
                Brush rosyBrown = (Brush)SafeNativeMethods.ThreadData[RosyBrownKey];
                if (rosyBrown == null) {
                    rosyBrown = new SolidBrush(Color.RosyBrown);
                    SafeNativeMethods.ThreadData[RosyBrownKey] = rosyBrown;
                }
                return rosyBrown;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.RoyalBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush RoyalBlue {
            get {
                Brush royalBlue = (Brush)SafeNativeMethods.ThreadData[RoyalBlueKey];
                if (royalBlue == null) {
                    royalBlue = new SolidBrush(Color.RoyalBlue);
                    SafeNativeMethods.ThreadData[RoyalBlueKey] = royalBlue;
                }
                return royalBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SaddleBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SaddleBrown {
            get {
                Brush saddleBrown = (Brush)SafeNativeMethods.ThreadData[SaddleBrownKey];
                if (saddleBrown == null) {
                    saddleBrown = new SolidBrush(Color.SaddleBrown);
                    SafeNativeMethods.ThreadData[SaddleBrownKey] = saddleBrown;
                }
                return saddleBrown;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Salmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Salmon {
            get {
                Brush salmon = (Brush)SafeNativeMethods.ThreadData[SalmonKey];
                if (salmon == null) {
                    salmon = new SolidBrush(Color.Salmon);
                    SafeNativeMethods.ThreadData[SalmonKey] = salmon;
                }
                return salmon;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SandyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SandyBrown {
            get {
                Brush sandyBrown = (Brush)SafeNativeMethods.ThreadData[SandyBrownKey];
                if (sandyBrown == null) {
                    sandyBrown = new SolidBrush(Color.SandyBrown);
                    SafeNativeMethods.ThreadData[SandyBrownKey] = sandyBrown;
                }
                return sandyBrown;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SeaGreen {
            get {
                Brush seaGreen = (Brush)SafeNativeMethods.ThreadData[SeaGreenKey];
                if (seaGreen == null) {
                    seaGreen = new SolidBrush(Color.SeaGreen);
                    SafeNativeMethods.ThreadData[SeaGreenKey] = seaGreen;
                }
                return seaGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SeaShell"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SeaShell {
            get {
                Brush seaShell = (Brush)SafeNativeMethods.ThreadData[SeaShellKey];
                if (seaShell == null) {
                    seaShell = new SolidBrush(Color.SeaShell);
                    SafeNativeMethods.ThreadData[SeaShellKey] = seaShell;
                }
                return seaShell;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Sienna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Sienna {
            get {
                Brush sienna = (Brush)SafeNativeMethods.ThreadData[SiennaKey];
                if (sienna == null) {
                    sienna = new SolidBrush(Color.Sienna);
                    SafeNativeMethods.ThreadData[SiennaKey] = sienna;
                }
                return sienna;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Silver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Silver {
            get {
                Brush silver = (Brush)SafeNativeMethods.ThreadData[SilverKey];
                if (silver == null) {
                    silver = new SolidBrush(Color.Silver);
                    SafeNativeMethods.ThreadData[SilverKey] = silver;
                }
                return silver;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SkyBlue {
            get {
                Brush skyBlue = (Brush)SafeNativeMethods.ThreadData[SkyBlueKey];
                if (skyBlue == null) {
                    skyBlue = new SolidBrush(Color.SkyBlue);
                    SafeNativeMethods.ThreadData[SkyBlueKey] = skyBlue;
                }
                return skyBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SlateBlue {
            get {
                Brush slateBlue = (Brush)SafeNativeMethods.ThreadData[SlateBlueKey];
                if (slateBlue == null) {
                    slateBlue = new SolidBrush(Color.SlateBlue);
                    SafeNativeMethods.ThreadData[SlateBlueKey] = slateBlue;
                }
                return slateBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SlateGray {
            get {
                Brush slateGray = (Brush)SafeNativeMethods.ThreadData[SlateGrayKey];
                if (slateGray == null) {
                    slateGray = new SolidBrush(Color.SlateGray);
                    SafeNativeMethods.ThreadData[SlateGrayKey] = slateGray;
                }
                return slateGray;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Snow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Snow {
            get {
                Brush snow = (Brush)SafeNativeMethods.ThreadData[SnowKey];
                if (snow == null) {
                    snow = new SolidBrush(Color.Snow);
                    SafeNativeMethods.ThreadData[SnowKey] = snow;
                }
                return snow;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SpringGreen {
            get {
                Brush springGreen = (Brush)SafeNativeMethods.ThreadData[SpringGreenKey];
                if (springGreen == null) {
                    springGreen = new SolidBrush(Color.SpringGreen);
                    SafeNativeMethods.ThreadData[SpringGreenKey] = springGreen;
                }
                return springGreen;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.SteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush SteelBlue {
            get {
                Brush steelBlue = (Brush)SafeNativeMethods.ThreadData[SteelBlueKey];
                if (steelBlue == null) {
                    steelBlue = new SolidBrush(Color.SteelBlue);
                    SafeNativeMethods.ThreadData[SteelBlueKey] = steelBlue;
                }
                return steelBlue;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Tan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Tan {
            get {
                Brush tan = (Brush)SafeNativeMethods.ThreadData[TanKey];
                if (tan == null) {
                    tan = new SolidBrush(Color.Tan);
                    SafeNativeMethods.ThreadData[TanKey] = tan;
                }
                return tan;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Teal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Teal {
            get {
                Brush teal = (Brush)SafeNativeMethods.ThreadData[TealKey];
                if (teal == null) {
                    teal = new SolidBrush(Color.Teal);
                    SafeNativeMethods.ThreadData[TealKey] = teal;
                }
                return teal;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Thistle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Thistle {
            get {
                Brush thistle = (Brush)SafeNativeMethods.ThreadData[ThistleKey];
                if (thistle == null) {
                    thistle = new SolidBrush(Color.Thistle);
                    SafeNativeMethods.ThreadData[ThistleKey] = thistle;
                }
                return thistle;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Tomato"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Tomato {
            get {
                Brush tomato = (Brush)SafeNativeMethods.ThreadData[TomatoKey];
                if (tomato == null) {
                    tomato = new SolidBrush(Color.Tomato);
                    SafeNativeMethods.ThreadData[TomatoKey] = tomato;
                }
                return tomato;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Turquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Turquoise {
            get {
                Brush turquoise = (Brush)SafeNativeMethods.ThreadData[TurquoiseKey];
                if (turquoise == null) {
                    turquoise = new SolidBrush(Color.Turquoise);
                    SafeNativeMethods.ThreadData[TurquoiseKey] = turquoise;
                }
                return turquoise;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Violet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Violet {
            get {
                Brush violet = (Brush)SafeNativeMethods.ThreadData[VioletKey];
                if (violet == null) {
                    violet = new SolidBrush(Color.Violet);
                    SafeNativeMethods.ThreadData[VioletKey] = violet;
                }
                return violet;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Wheat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Wheat {
            get {
                Brush wheat = (Brush)SafeNativeMethods.ThreadData[WheatKey];
                if (wheat == null) {
                    wheat = new SolidBrush(Color.Wheat);
                    SafeNativeMethods.ThreadData[WheatKey] = wheat;
                }
                return wheat;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.White"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush White {
            get {
                Brush white = (Brush)SafeNativeMethods.ThreadData[WhiteKey];
                if (white == null) {
                    white = new SolidBrush(Color.White);
                    SafeNativeMethods.ThreadData[WhiteKey] = white;
                }
                return white;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.WhiteSmoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush WhiteSmoke {
            get {
                Brush whiteSmoke = (Brush)SafeNativeMethods.ThreadData[WhiteSmokeKey];
                if (whiteSmoke == null) {
                    whiteSmoke = new SolidBrush(Color.WhiteSmoke);
                    SafeNativeMethods.ThreadData[WhiteSmokeKey] = whiteSmoke;
                }
                return whiteSmoke;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.Yellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush Yellow {
            get {
                Brush yellow = (Brush)SafeNativeMethods.ThreadData[YellowKey];
                if (yellow == null) {
                    yellow = new SolidBrush(Color.Yellow);
                    SafeNativeMethods.ThreadData[YellowKey] = yellow;
                }
                return yellow;
            }
        }

        /// <include file='doc\Brushes.uex' path='docs/doc[@for="Brushes.YellowGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Brush YellowGreen {
            get {
                Brush yellowGreen = (Brush)SafeNativeMethods.ThreadData[YellowGreenKey];
                if (yellowGreen == null) {
                    yellowGreen = new SolidBrush(Color.YellowGreen);
                    SafeNativeMethods.ThreadData[YellowGreenKey] = yellowGreen;
                }
                return yellowGreen;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\imageanimator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageAnimator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Drawing {
    using System.Threading;

    using System;
    using System.ComponentModel;
    using System.Collections;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing.Imaging;

    /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator"]/*' />
    /// <devdoc>        
    /// </devdoc>                                
    public sealed class ImageAnimator {

        static Thread timerThread;
        static ArrayList images;
        static bool anyFrameDirty;
        static ReaderWriterLock rwlock = new ReaderWriterLock();

        // Prevent instantiation of this class
        private ImageAnimator() {
        }

        /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator.UpdateFrames"]/*' />
        public static void UpdateFrames(Image image) {
            if (!anyFrameDirty || image == null || images == null) {
                return;
            }

            rwlock.AcquireReaderLock(-1);
            try {
                bool foundDirty = false;
                bool foundImage = false;

                foreach (ImageInfo info in images) {
                    if (info.Image == image) {
                        info.UpdateFrame();
                        foundImage = true;
                    }

                    if (info.FrameDirty) {
                        foundDirty = true;
                    }

                    if (foundDirty && foundImage) {
                        break;
                    }
                }

                anyFrameDirty = foundDirty;
            }
            finally {
                rwlock.ReleaseReaderLock();
            }
        }

        /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator.UpdateFrames1"]/*' />
        public static void UpdateFrames() {
            if (!anyFrameDirty || images == null) {
                return;
            }

            rwlock.AcquireReaderLock(-1);
            try {
                foreach (ImageInfo info in images) {
                    info.UpdateFrame();
                }
                anyFrameDirty = false;
            }
            finally {
                rwlock.ReleaseReaderLock();
            }
        }

        /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator.Animate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an image to the image manager.  If the image does not support animation,
        ///       this method does nothing.
        ///    </para>
        /// </devdoc>
        public static void Animate(Image image, EventHandler onFrameChangedHandler) {

            // could we avoid creating an ImageInfo object if FrameCount == 1 ?
            ImageInfo newImage = new ImageInfo(image);

            // If the image is already animating, stop animating it
            StopAnimate(image, onFrameChangedHandler);                              

            if (newImage.Animated) {

                // we are going to have to take the lock to add the
                // item... lets do it just once...
                //

                LockCookie toDowngrade = rwlock.UpgradeToWriterLock(-1);
                try {
                    // Construct the image array
                    //                               
                    if (images == null) {
                        images = new ArrayList();
                    }
    
                    // Add the new image
                    //
                    newImage.FrameChangedHandler = onFrameChangedHandler;
                    images.Add(newImage);                            


                    // Construct a new timer thread if we haven't already
                    //
                    if (timerThread == null) {
                        timerThread = new Thread(new ThreadStart(ThreadProcImpl));
                        timerThread.Name = typeof(ImageAnimator).Name;
                        timerThread.IsBackground = true;
                        timerThread.Start();
                    }
                }
                finally {
                    rwlock.DowngradeFromWriterLock(ref toDowngrade);
                }
            }
        }

        /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator.CanAnimate"]/*' />
        /// <devdoc>
        ///    Whether or not the image has multiple frames.
        /// </devdoc>
        public static bool CanAnimate(Image image) {
            Guid[] dimensions = image.FrameDimensionsList;
            foreach (Guid guid in dimensions) {
                FrameDimension dimension = new FrameDimension(guid);
                if (dimension.Equals(FrameDimension.Time)) {
                    return image.GetFrameCount(FrameDimension.Time) > 1;
                }
            }
            return false;
        }

        /// <include file='doc\ImageAnimator.uex' path='docs/doc[@for="ImageAnimator.StopAnimate"]/*' />
        /// <devdoc>
        ///    Removes an image from the image manager.
        /// </devdoc>
        public static void StopAnimate(Image image, EventHandler onFrameChangedHandler) {

            // Make sure we have a list of images                       
            if (images == null) {
                return;
            }

            LockCookie toDowngrade = rwlock.UpgradeToWriterLock(-1);
            try {
                // Find the corresponding weak reference and remove it
                for (int i=0; i < images.Count; i++) {

                    ImageInfo imageInfo = (ImageInfo)images[i];

                    if (image == imageInfo.Image && onFrameChangedHandler.Equals(imageInfo.FrameChangedHandler)) {
                        images.Remove(imageInfo);
                        break;
                    }
                }
            }
            finally {
                rwlock.DowngradeFromWriterLock(ref toDowngrade);
            }
        }

        static void AnimateImages50ms() {
            for (int i=0;i < images.Count; i++) {
                ImageInfo image = (ImageInfo)images[i];

                // Frame delay is measured in 1/100ths of a second. This thread
                // sleeps for 50 ms = 5/100ths of a second between frame updates,
                // so we increase the frame delay count 5/100ths of a second
                // at a time.
                //
                image.FrameTimer += 5;
                if (image.FrameTimer >= image.FrameDelay(image.Frame)) {
                    image.FrameTimer = 0;

                    if (image.Frame + 1 < image.FrameCount) {
                        image.Frame++;
                    }
                    else {
                        image.Frame = 0;
                    }
                }
            }
        }

        /// <devdoc>
        ///    The main animation loop.
        /// </devdoc>
        static void ThreadProcImpl() {

            Debug.Assert(images != null, "Null images list");

            while (true) {
                rwlock.AcquireReaderLock(-1);
                try {
                    AnimateImages50ms();
                }
                finally {
                    rwlock.ReleaseReaderLock();
                }
                Thread.Sleep(50);

            }

        }

        // We wrap each image in an ImageInfo, to store some extra state.                
        //                
        private class ImageInfo {

            Image image;
            int frame;
            int frameCount;
            bool frameDirty;
            bool animated;
            EventHandler onFrameChangedHandler;
            int[] frameDelay;
            int frameTimer;

            public ImageInfo(Image image) {
                this.image = image;
                animated = ImageAnimator.CanAnimate(image);
                if (animated) {
                    frameCount = Image.GetFrameCount(FrameDimension.Time);

                    int PropertyTagFrameDelay = 0x5100; // should prolly use an ENUM
                    PropertyItem frameDelayItem = Image.GetPropertyItem(PropertyTagFrameDelay);

                    // If the image does not have a frame delay, we just return 0.                                     
                    //
                    if (frameDelayItem != null) {
                        // Convert the frame delay from byte[] to int
                        //
                        byte[] values = frameDelayItem.Value;
                        Debug.Assert(values.Length == 4 * FrameCount, "PropertyItem has invalid value byte array");
                        frameDelay = new int[FrameCount];
                        for (int i=0; i < FrameCount; ++i) {
                            frameDelay[i] = values[i * 4] + 256 * values[i * 4 + 1] + 256 * 256 * values[i * 4 + 2] + 256 * 256 * 256 * values[i * 4 + 3];
                        }
                    }
                }
                else {
                    frameCount = 1;
                }
                if (frameDelay == null) {
                    frameDelay = new int[FrameCount];
                }
            }                                               

            // Whether the image supports animation
            public bool Animated {
                get {
                    return animated;
                }
            }

            // The current frame                          
            public int Frame {
                get {
                    return frame;
                }
                set {
                    if (frame != value) {
                        if (value < 0 || value >= FrameCount) {
                            throw new ArgumentException(SR.GetString(SR.InvalidFrame), "value");
                        }

                        if (Animated) {
                            lock(typeof(ImageAnimator)) {
                                lock(this) {
                                    frame = value;
                                    frameDirty = true;
                                    ImageAnimator.anyFrameDirty = true;
                                }
                            }
                            // don't fire OnFrameChanged inside the lock to avoid
                            // any race condition...
                            //
                            OnFrameChanged(EventArgs.Empty);
                        }
                    }
                }
            }

            public bool FrameDirty {
                get {
                    return frameDirty;
                }
            }

            public EventHandler FrameChangedHandler {
                get {
                    return onFrameChangedHandler;
                }
                set {
                    onFrameChangedHandler = value;
                }
            }

            public int FrameCount {
                get {
                    return frameCount;
                }
            }

            public int FrameDelay(int frame) {
                return frameDelay[frame];
            }

            internal int FrameTimer {
                get {
                    return frameTimer;
                }
                set {
                    frameTimer = value;
                }
            }

            internal Image Image {
                get {
                    return image;                
                }
            }

            internal void UpdateFrame() {
                if (frameDirty) {
                    lock(this) {
                        if (frameDirty) {
                            Image.SelectActiveFrame(FrameDimension.Time, Frame);
                            frameDirty = false;
                        }
                    }
                }
            }

            protected void OnFrameChanged(EventArgs e) {
                this.onFrameChangedHandler(image, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\fontconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter"]/*' />
    /// <devdoc>
    ///      FontConverter is a class that can be used to convert
    ///      fonts from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class FontConverter : TypeConverter {

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {

                string text = ((string)value).Trim();

                if (text.Length == 0) {
                    return null;
                }
                else {
                    // Parse an array of values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                                        
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});

                    string name;
                    float size = 8;
                    FontStyle style = FontStyle.Regular;
                    GraphicsUnit units =  GraphicsUnit.Point;

                    if (tokens.Length < 1) {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  text,
                                                                  "name, size[units[, style]]"));
                    }

                    name = tokens[0];

                    if (tokens.Length > 1) {
                        string[] unitTokens = ParseSizeTokens(tokens[1]);

                        if (unitTokens[0] != null) {
                            size = (float)TypeDescriptor.GetConverter(typeof(float)).ConvertFromString(context, culture, unitTokens[0]); 
                        }

                        if (unitTokens[1] != null) {
                            units = ParseGraphicsUnits(unitTokens[1]);
                        }
                    }

                    if (tokens.Length > 2) {
                        string styleText = string.Join(",", tokens, 2, tokens.Length - 2);
                        styleText = styleText.Trim();
                        if (!styleText.StartsWith("style") || styleText.IndexOf('=') == -1)
                            throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                      text,
                                                                      "name, size[units[, style]]"));
                        styleText = styleText.Substring(styleText.IndexOf('=') + 1);
                        styleText = styleText.Trim();
                        style = (FontStyle)Enum.Parse(typeof(FontStyle), styleText, true);
                        
                        // Enum.IsDefined doesn't do what we want on flags enums...
                        FontStyle validBits = FontStyle.Regular | FontStyle.Bold | FontStyle.Italic | FontStyle.Underline | FontStyle.Strikeout;
                        if ((style | validBits) != validBits)
                            throw new InvalidEnumArgumentException("style", (int)style, typeof(FontStyle));
                    }
                    
                    // should get cached version from TypeDescriptor                                                                                                
                    name = (string)(new FontNameConverter().ConvertFrom(context, culture, name));
                    
                    return new Font(name, size, style, units);
                }
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                Font font = (Font)value;

                if (font == null) {
                    return SR.GetString(SR.toStringNone);
                }
                else {
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                                        
                    string sep = culture.TextInfo.ListSeparator + " ";
                    
                    int argCount = 2;
                    if (font.Style != FontStyle.Regular)
                        argCount++;
                    string[] args = new string[argCount];
                    int nArg = 0;

                    // should go through type converters here -- we already need
                    // converts for Name, Size and Units.
                    //
                    args[nArg++] = font.Name;
                    args[nArg++] = TypeDescriptor.GetConverter(font.Size).ConvertToString(context, culture, font.Size) + GetGraphicsUnitText(font.Unit);
                    if (font.Style != FontStyle.Regular)
                        args[nArg++] = "style=" + font.Style.ToString("G");

                    return string.Join(sep, args);
                }
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Font) {
                
                Font font = (Font)value;
                
                // Custom font, not derived from any stock font
                //
                int argCount = 2;

                if (font.GdiVerticalFont) {
                    argCount = 6;
                }
                else if (font.GdiCharSet != Font.DEFAULT_CHARSET) {
                    argCount = 5;
                }
                else if (font.Unit != GraphicsUnit.Point) {
                    argCount = 4;
                }
                else if (font.Style != FontStyle.Regular) {
                    argCount++;
                }

                object[] args = new object[argCount];
                Type[] types = new Type[argCount];

                // Always specifying the eight parameter constructor is nastily confusing.
                // Use as simple a constructor as possible.
                //
                args[0] = font.Name; types[0] = typeof(string);
                args[1] = font.Size; types[1] = typeof(float);
                
                if (argCount > 2) {
                    args[2] = font.Style; types[2] = typeof(FontStyle);
                }

                if (argCount > 3) {
                    args[3] = font.Unit; types[3] = typeof(GraphicsUnit);
                }
                
                if (argCount > 4) {
                    args[4] = font.GdiCharSet; types[4] = typeof(byte);
                }
                
                if (argCount > 5) {
                    args[5] = font.GdiVerticalFont; types[5] = typeof(bool);
                }
                
                MemberInfo ctor = typeof(Font).GetConstructor(types);
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, args);
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            object name       = propertyValues["Name"];
            object size       = propertyValues["Size"];
            object units      = propertyValues["Unit"];
            object bold       = propertyValues["Bold"];
            object italic     = propertyValues["Italic"];
            object strikeout  = propertyValues["Strikeout"];
            object underline  = propertyValues["Underline"];
            object gdiCharSet = propertyValues["GdiCharSet"];
            object gdiVerticalFont = propertyValues["GdiVerticalFont"];

            // If any of these properties are null, it may indicate a change in font that
            // was not propgated to FontConverter.
            //
            Debug.Assert(name != null && size != null && units != null && 
                         bold != null && italic != null && strikeout != null && gdiCharSet != null && 
                         underline != null, "Missing font properties.  Did Font change without FontConverter getting updated?");

            if (name == null)       name = "Tahoma";
            if (size == null)       size = 8.0f;
            if (units == null)      units = GraphicsUnit.Point;
            if (gdiCharSet == null) gdiCharSet = 0;
            if (gdiVerticalFont == null) gdiVerticalFont = false;

            FontStyle style = 0;
            if (bold != null && ((bool)bold)) style |= FontStyle.Bold;
            if (italic != null && ((bool)italic)) style |= FontStyle.Italic;
            if (strikeout != null && ((bool)strikeout)) style |= FontStyle.Strikeout;
            if (underline != null && ((bool)underline)) style |= FontStyle.Underline;

            return new Font((string)name,
                            (float)size,
                            style,
                            (GraphicsUnit)units,
                            (byte)gdiCharSet,
                            (bool)gdiVerticalFont);
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetGraphicsUnitText"]/*' />
        /// <devdoc>
        ///     Returns a text description for the font units
        /// </devdoc>
        private string GetGraphicsUnitText(GraphicsUnit units) {
            string unitStr = "";

            for (int i = 0; i < UnitName.names.Length; i++) {
                if (UnitName.names[i].unit == units) {
                    unitStr = UnitName.names[i].name;
                    break;
                }
            }
            return unitStr;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(Font), attributes);
            return props.Sort(new string[] {"Name", "Size", "Unit", "Weight"});
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ParseSizeTokens"]/*' />
        /// <devdoc>
        ///      Takes a string of the format ####.##CC and parses it into two 
        ///      strings.
        /// </devdoc>
        private string[] ParseSizeTokens(string text) {
            text = text.Trim();
            int length = text.Length;
            int splitPoint;


            for (splitPoint = 0; splitPoint < length; splitPoint++) {
                if (Char.IsLetter(text[splitPoint])) {
                    break;
                }
            }

            string size = null;
            string units = null;

            if (length > 0 && splitPoint > 0) {
                size = text.Substring(0, splitPoint);
            }

            if (splitPoint < length) {
                units = text.Substring(splitPoint);
            }

            return new string[] {size, units};
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.ParseGraphicsUnits"]/*' />
        /// <devdoc>
        ///     Parses the font units from the given text.
        /// </devdoc>
        private GraphicsUnit ParseGraphicsUnits(string units) {
            UnitName unitName = null;

            for (int i = 0; i < UnitName.names.Length; i++) {
                if (String.Compare(UnitName.names[i].name, units, true, CultureInfo.InvariantCulture) == 0) {
                    unitName = UnitName.names[i];
                    break;
                }
            }

            if (unitName == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "units", units));
            }
            return unitName.unit;
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.UnitName"]/*' />
        /// <devdoc>
        ///     Simple private class to associate a font size unit with a text name.
        /// </devdoc>
        internal class UnitName {

            internal string name; 

            internal GraphicsUnit unit;

            internal static readonly UnitName[] names = new UnitName[] {
                    new UnitName("world", GraphicsUnit.World), // made up
                    new UnitName("display", GraphicsUnit.Display), // made up
                    new UnitName("px", GraphicsUnit.Pixel),
                    new UnitName("pt", GraphicsUnit.Point),
                    new UnitName("in", GraphicsUnit.Inch),
                    new UnitName("doc", GraphicsUnit.Document), // made up
                    new UnitName("mm", GraphicsUnit.Millimeter),
                };


            internal UnitName(string name, GraphicsUnit unit) {
                this.name = name;
                this.unit = unit;
            }
        }

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter"]/*' />
        /// <devdoc>
        ///      FontNameConverter is a type converter that is used to convert
        ///      a font name to and from various other representations.
        /// </devdoc>
        /// <internalonly/>
        public sealed class FontNameConverter : TypeConverter {

            private StandardValuesCollection values;

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.FontNameConverter"]/*' />
            /// <devdoc>
            ///      Creates a new font name converter.
            /// </devdoc>
            public FontNameConverter() {

                // Sink an event to let us know when the installed
                // set of fonts changes.
                //
                SystemEvents.InstalledFontsChanged += new EventHandler(this.OnInstalledFontsChanged);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.CanConvertFrom"]/*' />
            /// <devdoc>
            ///      Determines if this converter can convert an object in the given source
            ///      type to the native type of the converter.
            /// </devdoc>
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
                if (sourceType == typeof(string)) {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.ConvertFrom"]/*' />
            /// <devdoc>
            ///      Converts the given object to the converter's native type.
            /// </devdoc>
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
                if (value is string) {
                    return MatchFontName((string)value, context);
                }
                return base.ConvertFrom(context, culture, value);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.Finalize"]/*' />
            /// <devdoc>
            ///      We need to know when we're finalized.
            /// </devdoc>
            ~FontNameConverter() {
                SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnInstalledFontsChanged);
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValues"]/*' />
            /// <devdoc>
            ///      Retrieves a collection containing a set of standard values
            ///      for the data type this validator is designed for.  This
            ///      will return null if the data type does not support a
            ///      standard set of values.
            /// </devdoc>
            public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
                if (values == null) {
                    FontFamily[] fonts =  FontFamily.Families;

                    Hashtable hash = new Hashtable();
                    for (int i = 0; i < fonts.Length; i++) {
                            string name = fonts[i].Name;
                            hash[name.ToLower(CultureInfo.InvariantCulture)] = name;
                    }

                    object[] array = new object[hash.Values.Count];
                    hash.Values.CopyTo(array, 0);

                    Array.Sort(array, Comparer.Default);
                    values = new StandardValuesCollection(array);
                }

                return values;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValuesExclusive"]/*' />
            /// <devdoc>
            ///      Determines if the list of standard values returned from
            ///      GetStandardValues is an exclusive list.  If the list
            ///      is exclusive, then no other values are valid, such as
            ///      in an enum data type.  If the list is not exclusive,
            ///      then there are other valid values besides the list of
            ///      standard values GetStandardValues provides.
            /// </devdoc>
            public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
                return false;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.GetStandardValuesSupported"]/*' />
            /// <devdoc>
            ///      Determines if this object supports a standard set of values
            ///      that can be picked from a list.
            /// </devdoc>
            public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
                return true;
            }
            
            private string MatchFontName(string name, ITypeDescriptorContext context) {
                Debug.Assert(name != null, "Expected an actual font name to match in FontNameConverter::MatchFontName.");
                
                // Try a partial match
                //
                string bestMatch = null;
                name = name.ToLower(CultureInfo.InvariantCulture);
                IEnumerator e = GetStandardValues(context).GetEnumerator();
                while (e.MoveNext()) {
                    string fontName = e.Current.ToString().ToLower(CultureInfo.InvariantCulture);
                    if (fontName.Equals(name)) {
                        // For an exact match, return immediately
                        //
                        return e.Current.ToString();
                    }
                    else if (fontName.StartsWith(name)) {
                        if (bestMatch == null || fontName.Length <= bestMatch.Length) {
                            bestMatch = e.Current.ToString();
                        }
                    }
                }
                
                if (bestMatch == null) {
                    // no match... fall back on whatever was provided
                    bestMatch = name;
                }
                return bestMatch;
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontNameConverter.OnInstalledFontsChanged"]/*' />
            /// <devdoc>
            ///      Called by system events when someone adds or removes a font.  Here
            ///      we invalidate our font name collection.
            /// </devdoc>
            private void OnInstalledFontsChanged(object sender, EventArgs e) {
                values = null;
            }
        }    

        /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter"]/*' />
        /// <devdoc>
        ///      FontUnitConverter strips out the members of GraphicsUnit that are invalid for fonts.
        /// </devdoc>
        /// <internalonly/>
        public class FontUnitConverter : EnumConverter {
            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter.FontUnitConverter"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public FontUnitConverter() : base(typeof(GraphicsUnit)) {
            }

            /// <include file='doc\FontConverter.uex' path='docs/doc[@for="FontConverter.FontUnitConverter.GetStandardValues"]/*' />
            /// <internalonly/>
            public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
                if (Values == null) {
                    base.GetStandardValues(context); // sets "values"
                    ArrayList filteredValues = new ArrayList(Values);
                    filteredValues.Remove(GraphicsUnit.Display);
                    Values = new StandardValuesCollection(filteredValues);
                }
                return Values;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\image.cs ===
//------------------------------------------------------------------------------
// <copyright file="Image.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ Image objects
*
* Revision History:
*
*   09/28/1999 nkramer
*       Implement ISerializable
*       Change GUID's to ImageFormat
*
*   01/12/1999 davidx
*       Code review changes.
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Drawing.Design;
    using System.IO;    
    using System.Reflection;    
    using System.ComponentModel;
    using ArrayList = System.Collections.ArrayList;
    using Microsoft.Win32;
    using System.Drawing.Imaging;
    using System.Drawing.Internal;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;

    /**
     * Represent an image object (could be bitmap or vector)
     */
    /// <include file='doc\Image.uex' path='docs/doc[@for="Image"]/*' />
    /// <devdoc>
    ///    An abstract base class that provides
    ///    functionality for 'Bitmap', 'Icon', 'Cursor', and 'Metafile' descended classes.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(ImageConverter)),
    Editor("System.Drawing.Design.ImageEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
    ImmutableObject(true)
    ]
    [Serializable]
    [ComVisible(true)]
    public abstract class Image : MarshalByRefObject, ISerializable, ICloneable, IDisposable {

#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif


        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetThumbnailImageAbort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public delegate bool GetThumbnailImageAbort();

        /*
         * Handle to native image object
         */
        internal IntPtr nativeImage;

        // used to work around lack of animated gif encoder... rarely set...
        //
        byte[] rawData;

        /**
         * Constructor can't be invoked directly
         */
        internal Image() {
        }

        /**
         * Constructor used in deserialization
         */
        internal Image(SerializationInfo info, StreamingContext context) {
            SerializationInfoEnumerator sie = info.GetEnumerator();
            if (sie == null) {
                return;
            }
            for (; sie.MoveNext();) {
                if (String.Compare(sie.Name, "Data", true, CultureInfo.InvariantCulture) == 0) {
                    try {
                        byte[] dat = (byte[])sie.Value;
                        if (dat != null) {
                            InitializeFromStream(new MemoryStream(dat));
                        }

                    }
                    catch (Exception e) {
                        Debug.Fail("failure: " + e.ToString());
                    }
                }
            }
        }

        /**
        * Create an image object from a URL
        */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromFile"]/*' />
        /// <devdoc>
        ///    Creates an <see cref='System.Drawing.Image'/> from the specified file.
        /// </devdoc>
        // [Obsolete("Use Image.FromFile(string, useEmbeddedColorManagement)")]
        public static Image FromFile(String filename) {
            return Image.FromFile(filename, false);
        }
        
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromFile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Image FromFile(String filename,
                                     bool useEmbeddedColorManagement) {
            
            // The File.Exists() below will do the demand for the FileIOPermission
            // for us. So, we do not need an additional demand anymore.
            //
            if (!File.Exists(filename)) {
                // I have to do this so I can give a meaningful
                // error back to the user. File.Exists() cal fail because of either
                // a failure to demand security or because the file does not exist.
                // Always telling the user that the file does not exist is not a good
                // choice. So, we demand the permission again. This means that we are
                // going to demand the permission twice for the failure case, but that's
                // better than always demanding the permission twice.
                //
                IntSecurity.DemandReadFileIO(filename);

                throw new FileNotFoundException(filename);
            }

            //GDI+ will read this file multiple times.  Get the fully qualified path
            //so if our app changes default directory we won't get an error
            //
            filename = Path.GetFullPath(filename);

            IntPtr image = IntPtr.Zero;
            int status;
            
            if (useEmbeddedColorManagement) {
                status = SafeNativeMethods.GdipLoadImageFromFileICM(filename, out image);
            }
            else {
                status = SafeNativeMethods.GdipLoadImageFromFile(filename, out image);
            }
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, image));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, image));
                throw SafeNativeMethods.StatusException(status);
            }

            Image img = CreateImageObject(image);

            EnsureSave(img, filename, null);

            return img;
        }


        /**
         * Create an image object from a data stream
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromStream"]/*' />
        /// <devdoc>
        ///    Creates an <see cref='System.Drawing.Image'/> from the specified data
        ///    stream.
        /// </devdoc>
        // [Obsolete("Use Image.FromStream(stream, useEmbeddedColorManagement)")]
        public static Image FromStream(Stream stream) {
            return Image.FromStream(stream, false);
        }
        
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromStream1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Image FromStream(Stream stream,
                                       bool useEmbeddedColorManagement) 
        {
            if (stream == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));

            IntPtr image = IntPtr.Zero;
            int status;
            
            if (useEmbeddedColorManagement)
            {
                status = SafeNativeMethods.GdipLoadImageFromStreamICM(new GPStream(stream), out image);
            }
            else
            {
                status = SafeNativeMethods.GdipLoadImageFromStream(new GPStream(stream), out image);
            }
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, image));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, image));
                throw SafeNativeMethods.StatusException(status);
            }

            Image img = CreateImageObject(image);

            EnsureSave(img, null, stream);

            return img;
        }

        // Used for serialization
        private void InitializeFromStream(Stream stream) {
            IntPtr image = IntPtr.Zero;

            int status = SafeNativeMethods.GdipLoadImageFromStream(new GPStream(stream), out image);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, image));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, image));
                throw SafeNativeMethods.StatusException(status);
            }

            this.nativeImage = image;

            int type = -1;

            status = SafeNativeMethods.GdipGetImageType(new HandleRef(this, nativeImage), out type);

            EnsureSave(this, null, stream);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        internal Image(IntPtr nativeImage) {
            SetNativeImage(nativeImage);
        }

        /**
         * Make a copy of the image object
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public object Clone() {
            IntPtr cloneImage = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneImage(new HandleRef(this, nativeImage), out cloneImage);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            status = SafeNativeMethods.GdipImageForceValidation(new HandleRef(null, cloneImage));

            if (status != SafeNativeMethods.Ok) {
                SafeNativeMethods.GdipDisposeImage(new HandleRef(null, cloneImage));
                throw SafeNativeMethods.StatusException(status);
            }

            return CreateImageObject(cloneImage);
        }

        /**
         * Dispose of resources associated with the Image object
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeImage != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif
            if (nativeImage != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDisposeImage(new HandleRef(this, nativeImage));

                nativeImage = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        ~Image() {
            Dispose(false);
        }

        internal static void EnsureSave(Image image, string filename, Stream dataStream) {

            if (image.RawFormat.Equals(ImageFormat.Gif)) {
                bool animatedGif = false;

                Guid[] dimensions = image.FrameDimensionsList;
                foreach (Guid guid in dimensions) {
                    FrameDimension dimension = new FrameDimension(guid);
                    if (dimension.Equals(FrameDimension.Time)) {
                        animatedGif = image.GetFrameCount(FrameDimension.Time) > 1;
                        break;
                    }
                }


                if (animatedGif) {
                    try {
                        Stream created = null;
                        long lastPos = 0;
                        if (dataStream != null) {
                            lastPos = dataStream.Position;
                            dataStream.Position = 0;
                        }

                        try {
                            if (dataStream == null) {
                                created = dataStream = File.OpenRead(filename);
                            }

                            image.rawData = new byte[(int)dataStream.Length];
                            dataStream.Read(image.rawData, 0, (int)dataStream.Length);
                        }
                        finally {
                            if (created != null) {
                                created.Close();
                            }
                            else {
                                dataStream.Position = lastPos;
                            }
                        }
                    }
                    catch (Exception) {
                        // ignore any exceptions...
                        //
                    }
                }
            }
        }

        private enum ImageTypeEnum  {
            Bitmap = 1,
            Metafile = 2,
        }

        private ImageTypeEnum ImageType
        {
            get { 
                int type = -1;

                int status = SafeNativeMethods.GdipGetImageType(new HandleRef(this, nativeImage), out type);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(ImageTypeEnum) type;
            }
        }

        internal static Image CreateImageObject(IntPtr nativeImage) {
            Image image;

            int type = -1;

            int status = SafeNativeMethods.GdipGetImageType(new HandleRef(null, nativeImage), out type);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            switch ((ImageTypeEnum)type) {
                case ImageTypeEnum.Bitmap:     
                    image = Bitmap.FromGDIplus(nativeImage);
                    break;

                case ImageTypeEnum.Metafile:
                    image = Metafile.FromGDIplus(nativeImage);
                    break;

                default:
                    throw new ArgumentException(SR.GetString(SR.InvalidImage));
            }

            return image;
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        ///     ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            MemoryStream stream = new MemoryStream();

            Save(stream);
            si.AddValue("Data", stream.ToArray(), typeof(byte[]));
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetEncoderParameterList"]/*' />
        /// <devdoc>
        ///    Returns information about the codecs used
        ///    for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public EncoderParameters GetEncoderParameterList(Guid encoder) {
            int size;

            int status = SafeNativeMethods.GdipGetEncoderParameterListSize(new HandleRef(this, nativeImage), 
                                                                 ref encoder, 
                                                                 out size);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            if (size <= 0)
                return null;

            IntPtr buffer = Marshal.AllocHGlobal(size);

            status = SafeNativeMethods.GdipGetEncoderParameterList(new HandleRef(this, nativeImage),
                                                         ref encoder, 
                                                         size,
                                                         buffer);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buffer);
                throw SafeNativeMethods.StatusException(status);
            }

            EncoderParameters p = EncoderParameters.ConvertFromMemory(buffer);

            Marshal.FreeHGlobal(buffer);

            return p;  
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Save"]/*' />
        /// <devdoc>
        ///    Saves this <see cref='System.Drawing.Image'/> to the specified file.
        /// </devdoc>
        public void Save(string filename) {
            Save(filename, RawFormat);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Save1"]/*' />
        /// <devdoc>
        ///    Saves this <see cref='System.Drawing.Image'/> to the specified file in the
        ///    specified format.
        /// </devdoc>
        public void Save(string filename, ImageFormat format) {
            if (format == null)
                throw new ArgumentNullException("format");

            ImageCodecInfo codec = format.FindEncoder();

            if (codec == null)
                codec = ImageFormat.Png.FindEncoder();

            Save(filename, codec, null);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Save2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves this <see cref='System.Drawing.Image'/> to the specified file in the specified format
        ///       and with the specified encoder parameters.
        ///    </para>
        /// </devdoc>
        public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams) {
            if (filename == null)
                throw new ArgumentNullException("filename");
            if (encoder == null)
                throw new ArgumentNullException("encoder");

            IntSecurity.DemandWriteFileIO(filename);

            IntPtr encoderParamsMemory = IntPtr.Zero;

            if (encoderParams != null) {
                rawData = null;
                encoderParamsMemory = encoderParams.ConvertToMemory();
            }
            int status = SafeNativeMethods.Ok;

            try {
                Guid g = encoder.Clsid;
                bool saved = false;

                if (rawData != null) {
                    ImageCodecInfo rawEncoder = RawFormat.FindEncoder();
                    if (rawEncoder.Clsid == g) {
                        using (FileStream fs = File.OpenWrite(filename)) {
                            fs.Write(rawData, 0, rawData.Length);
                            saved = true;
                        }
                    }
                }

                if (!saved) {
                    status = SafeNativeMethods.GdipSaveImageToFile(new HandleRef(this, nativeImage),
                                                             filename,
                                                             ref g,
                                                             new HandleRef(encoderParams, encoderParamsMemory));
                }
            }
            finally {
                if (encoderParamsMemory != IntPtr.Zero) {
                    Marshal.FreeHGlobal(encoderParamsMemory);
                }
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        internal void Save(MemoryStream stream) {
            // Jpeg looses data, so we don't want to use it to serialize...
            //
            ImageFormat dest = RawFormat;
            if (dest == ImageFormat.Jpeg) {
                dest = ImageFormat.Png;
            }
            ImageCodecInfo codec = dest.FindEncoder();

            // If we don't find an Encoder (for things like Icon), we
            // just switch back to PNG...
            //
            if (codec == null) {
                codec = ImageFormat.Png.FindEncoder();
            }
            Save(stream, codec, null);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Save3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves this <see cref='System.Drawing.Image'/> to the specified stream in the specified
        ///       format.
        ///    </para>
        /// </devdoc>
        public void Save(Stream stream, ImageFormat format) {
            if (format == null)
                throw new ArgumentNullException("format");

            ImageCodecInfo codec = format.FindEncoder();
            Save(stream, codec, null);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Save4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves this <see cref='System.Drawing.Image'/> to the specified stream in the specified
        ///       format.
        ///    </para>
        /// </devdoc>
        public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams) {
            if (stream == null)
                throw new ArgumentNullException("stream");
            if (encoder == null)
                throw new ArgumentNullException("encoder");

            IntPtr encoderParamsMemory = IntPtr.Zero;

            if (encoderParams != null) {
                rawData = null;
                encoderParamsMemory = encoderParams.ConvertToMemory();
            }
            int status = SafeNativeMethods.Ok;

            try {
                Guid g = encoder.Clsid;
                bool saved = false;

                if (rawData != null) {
                    ImageCodecInfo rawEncoder = RawFormat.FindEncoder();
                    if (rawEncoder.Clsid == g) {
                        stream.Write(rawData, 0, rawData.Length);
                        saved = true;
                    }
                }

                if (!saved) {
                    status = SafeNativeMethods.GdipSaveImageToStream(new HandleRef(this, nativeImage),
                                                                     new UnsafeNativeMethods.ComStreamFromDataStream(stream),
                                                                     ref g,
                                                                     new HandleRef(encoderParams, encoderParamsMemory));
                }
            }
            finally {
                if (encoderParamsMemory != IntPtr.Zero) {
                    Marshal.FreeHGlobal(encoderParamsMemory);
                }
            }
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.SaveAdd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an <see cref='System.Drawing.Imaging.EncoderParameters'/> to this
        ///    <see cref='System.Drawing.Image'/>.
        ///    </para>
        /// </devdoc>
        public void SaveAdd(EncoderParameters encoderParams) {
            IntPtr encoder = IntPtr.Zero;
            if (encoderParams != null)
                encoder = encoderParams.ConvertToMemory();

            rawData = null;
            int status = SafeNativeMethods.GdipSaveAdd(new HandleRef(this, nativeImage), new HandleRef(encoderParams, encoder));

            if (encoder != IntPtr.Zero)
                Marshal.FreeHGlobal(encoder);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.SaveAdd1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an <see cref='System.Drawing.Imaging.EncoderParameters'/> to the
        ///       specified <see cref='System.Drawing.Image'/>.
        ///    </para>
        /// </devdoc>
        public void SaveAdd(Image image, EncoderParameters encoderParams) {
            IntPtr encoder = IntPtr.Zero;

            if (image == null)
                throw new ArgumentNullException("image");

            if (encoderParams != null)
                encoder = encoderParams.ConvertToMemory();

            rawData = null;
            int status = SafeNativeMethods.GdipSaveAddImage(new HandleRef(this, nativeImage), new HandleRef(image, image.nativeImage), new HandleRef(encoderParams, encoder));

            if (encoder != IntPtr.Zero)
                Marshal.FreeHGlobal(encoder);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Return; image size information
         */
        private SizeF _GetPhysicalDimension() {
            float width;
            float height;

            int status = SafeNativeMethods.GdipGetImageDimension(new HandleRef(this, nativeImage), out width, out height);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new SizeF(width, height);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.PhysicalDimension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width and height of this
        ///    <see cref='System.Drawing.Image'/>.
        ///    </para>
        /// </devdoc>
        public SizeF PhysicalDimension {
            get { return _GetPhysicalDimension();}
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width and height of this <see cref='System.Drawing.Image'/>.
        ///    </para>
        /// </devdoc>
        public Size Size {
            get {
                return new Size(Width, Height);
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Width"]/*' />
        /// <devdoc>
        ///    Gets the width of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [
        DefaultValue(false),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Width {
            get {
                int width; 

                int status = SafeNativeMethods.GdipGetImageWidth(new HandleRef(this, nativeImage), out width);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return width;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Height"]/*' />
        /// <devdoc>
        ///    Gets the height of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [
        DefaultValue(false),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int Height {
            get {
                int height; 

                int status = SafeNativeMethods.GdipGetImageHeight(new HandleRef(this, nativeImage), out height);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return height;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.HorizontalResolution"]/*' />
        /// <devdoc>
        ///    Gets the horizontal resolution, in
        ///    pixels-per-inch, of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public float HorizontalResolution {
            get {
                float horzRes; 

                int status = SafeNativeMethods.GdipGetImageHorizontalResolution(new HandleRef(this, nativeImage), out horzRes);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return horzRes;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.VerticalResolution"]/*' />
        /// <devdoc>
        ///    Gets the vertical resolution, in
        ///    pixels-per-inch, of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public float VerticalResolution {
            get {
                float vertRes; 

                int status = SafeNativeMethods.GdipGetImageVerticalResolution(new HandleRef(this, nativeImage), out vertRes);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return vertRes;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Flags"]/*' />
        /// <devdoc>
        ///    Gets attribute flags for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [Browsable(false)]
        public int Flags {
            get {
                int flags; 

                int status = SafeNativeMethods.GdipGetImageFlags(new HandleRef(this, nativeImage), out flags);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return flags;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.RawFormat"]/*' />
        /// <devdoc>
        ///    Gets the format of this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public ImageFormat RawFormat {
            get {
                Guid guid = new Guid();

                int status = SafeNativeMethods.GdipGetImageRawFormat(new HandleRef(this, nativeImage), ref guid);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);


                return new ImageFormat(guid);
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.PixelFormat"]/*' />
        /// <devdoc>
        ///    Gets the pixel format for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public PixelFormat PixelFormat {
            get {
                int format;

                int status = SafeNativeMethods.GdipGetImagePixelFormat(new HandleRef(this, nativeImage), out format);

                if (status != SafeNativeMethods.Ok)
                    return PixelFormat.Undefined;
                else
                    return(PixelFormat)format;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetBounds"]/*' />
        /// <devdoc>
        ///    Gets a bounding rectangle in
        ///    the specified units for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public RectangleF GetBounds(ref GraphicsUnit pageUnit) {
            GPRECTF gprectf = new GPRECTF();

            int status = SafeNativeMethods.GdipGetImageBounds(new HandleRef(this, nativeImage), ref gprectf, out pageUnit);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return gprectf.ToRectangleF();
        }

        private ColorPalette _GetColorPalette() {
            int size = -1;

            int status = SafeNativeMethods.GdipGetImagePaletteSize(new HandleRef(this, nativeImage), out size);
            // "size" is total byte size:
            // sizeof(ColorPalette) + (pal->Count-1)*sizeof(ARGB)

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            ColorPalette palette = new ColorPalette(size);

            // Memory layout is:
            //    UINT Flags
            //    UINT Count
            //    ARGB Entries[size]

            IntPtr memory = Marshal.AllocHGlobal(size);

            status = SafeNativeMethods.GdipGetImagePalette(new HandleRef(this, nativeImage), memory, size);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(memory);
                throw SafeNativeMethods.StatusException(status);
            }

            palette.ConvertFromMemory(memory);

            Marshal.FreeHGlobal(memory);

            return palette;
        }

        private void _SetColorPalette(ColorPalette palette) {
            IntPtr memory = palette.ConvertToMemory();

            int status = SafeNativeMethods.GdipSetImagePalette(new HandleRef(this, nativeImage), memory);

            if (memory != IntPtr.Zero)
                Marshal.FreeHGlobal(memory);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.Palette"]/*' />
        /// <devdoc>
        ///    Gets or sets the color
        ///    palette used for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [Browsable(false)]
        public ColorPalette Palette
        {
            get {
                return _GetColorPalette();
            }
            set {
                _SetColorPalette(value);
            }
        }

        // Thumbnail support

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetThumbnailImage"]/*' />
        /// <devdoc>
        ///    Returns the thumbnail for this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public Image GetThumbnailImage(int thumbWidth, int thumbHeight, 
                                       GetThumbnailImageAbort callback, IntPtr callbackData) {
            IntPtr thumbImage = IntPtr.Zero;

            int status = SafeNativeMethods.GdipGetImageThumbnail(new HandleRef(this, nativeImage), thumbWidth, thumbHeight, out thumbImage,
                                                       callback, callbackData);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return CreateImageObject(thumbImage);
        }

        // Multi-frame support

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FrameDimensionsList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an array of GUIDs that represent the
        ///       dimensions of frames within this <see cref='System.Drawing.Image'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public Guid[] FrameDimensionsList {

            get {
                int count;

                int status = SafeNativeMethods.GdipImageGetFrameDimensionsCount(new HandleRef(this, nativeImage), out count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                Debug.Assert(count >= 0, "FrameDimensionsList returns bad count");                    
                if (count <= 0)
                    return new Guid[0];

                int size = (int) Marshal.SizeOf(typeof(Guid));

                IntPtr buffer = Marshal.AllocHGlobal(size*count);
                if (buffer == IntPtr.Zero)
                    throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

                status = SafeNativeMethods.GdipImageGetFrameDimensionsList(new HandleRef(this, nativeImage), buffer, count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                Guid[] guids = new Guid[count];
                for (int i=0; i<count; i++) {
                    guids[i] = (Guid) UnsafeNativeMethods.PtrToStructure((IntPtr)((long)buffer + size*i), typeof(Guid));
                }

                Marshal.FreeHGlobal(buffer);

                return guids;
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetFrameCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the number of frames of the given
        ///       dimension.
        ///    </para>
        /// </devdoc>
        public int GetFrameCount(FrameDimension dimension) {
            int[] count = new int[] { 0};

            Guid dimensionID = dimension.Guid;
            int status = SafeNativeMethods.GdipImageGetFrameCount(new HandleRef(this, nativeImage), ref dimensionID, count);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return count[0];
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.SelectActiveFrame"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects the frame specified by the given
        ///       dimension and index.
        ///    </para>
        /// </devdoc>
        public int SelectActiveFrame(FrameDimension dimension, int frameIndex) {
            int[] count = new int[] { 0};

            Guid dimensionID = dimension.Guid;
            int status = SafeNativeMethods.GdipImageSelectActiveFrame(new HandleRef(this, nativeImage), ref dimensionID, frameIndex);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return count[0];
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.RotateFlip"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        public void RotateFlip(RotateFlipType rotateFlipType) {

            int status = SafeNativeMethods.GdipImageRotateFlip(new HandleRef(this, nativeImage), (int) rotateFlipType);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.PropertyIdList"]/*' />
        /// <devdoc>
        ///    Gets an array of the property IDs stored in
        ///    this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [Browsable(false)]
        public int[] PropertyIdList
        {
            get {
                int count;

                int status = SafeNativeMethods.GdipGetPropertyCount(new HandleRef(this, nativeImage), out count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                int[] propid = new int[count];

                //if we have a 0 count, just return our empty array
                if (count == 0)
                    return propid;

                status = SafeNativeMethods.GdipGetPropertyIdList(new HandleRef(this, nativeImage), count, propid);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return propid;    
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetPropertyItem"]/*' />
        /// <devdoc>
        ///    Gets the specified property item from this
        /// <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public PropertyItem GetPropertyItem(int propid) {

            int size;

            int status = SafeNativeMethods.GdipGetPropertyItemSize(new HandleRef(this, nativeImage), propid, out size);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            if (size == 0)
                return null;

            IntPtr propdata = Marshal.AllocHGlobal(size);

            if (propdata == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

            status = SafeNativeMethods.GdipGetPropertyItem(new HandleRef(this, nativeImage), propid, size, propdata);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(propdata);
                throw SafeNativeMethods.StatusException(status);
            }

            PropertyItem propitem = PropertyItemInternal.ConvertFromMemory(propdata, 1)[0];

            Marshal.FreeHGlobal(propdata);
            return propitem;
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.RemovePropertyItem"]/*' />
        /// <devdoc>
        ///    Removes the specified property item from
        ///    this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        public void RemovePropertyItem(int propid) {
            int status = SafeNativeMethods.GdipRemovePropertyItem(new HandleRef(this, nativeImage), propid);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.SetPropertyItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the specified property item to the
        ///       specified value.
        ///    </para>
        /// </devdoc>
        public void SetPropertyItem(PropertyItem propitem) {
            PropertyItemInternal propItemInternal = PropertyItemInternal.ConvertFromPropertyItem(propitem);

            using (propItemInternal) {
                int status = SafeNativeMethods.GdipSetPropertyItem(new HandleRef(this, nativeImage), propItemInternal);
                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.PropertyItems"]/*' />
        /// <devdoc>
        ///    Gets an array of <see cref='System.Drawing.Imaging.PropertyItem'/> objects that describe this <see cref='System.Drawing.Image'/>.
        /// </devdoc>
        [Browsable(false)]
        public PropertyItem[] PropertyItems
        {
            get {
                int size;
                int count;

                int status = SafeNativeMethods.GdipGetPropertyCount(new HandleRef(this, nativeImage), out count);               

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                status = SafeNativeMethods.GdipGetPropertySize(new HandleRef(this, nativeImage), out size, ref count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                if (size == 0 || count == 0)
                    return new PropertyItem[0];

                IntPtr propdata = Marshal.AllocHGlobal(size);

                status = SafeNativeMethods.GdipGetAllPropertyItems(new HandleRef(this, nativeImage), size, count, propdata);

                if (status != SafeNativeMethods.Ok) {
                    Marshal.FreeHGlobal(propdata);
                    throw SafeNativeMethods.StatusException(status);
                }

                PropertyItem[] props = PropertyItemInternal.ConvertFromMemory(propdata, count);

                Marshal.FreeHGlobal(propdata);

                return props;
            }
        }

        internal void SetNativeImage(IntPtr handle) {
            if (handle == IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.NativeHandle0), "handle");

            nativeImage = handle;
        }

        // !! Ambiguous to offer constructor for 'FromHbitmap'
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromHbitmap"]/*' />
        /// <devdoc>
        ///    Creates a <see cref='System.Drawing.Bitmap'/> from a Windows handle.
        /// </devdoc>
        public static Bitmap FromHbitmap(IntPtr hbitmap) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            return FromHbitmap(hbitmap, IntPtr.Zero);
        }

        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.FromHbitmap1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Bitmap'/> from the specified Windows
        ///       handle with the specified color palette.
        ///    </para>
        /// </devdoc>
        public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr bitmap = IntPtr.Zero;
            int status = SafeNativeMethods.GdipCreateBitmapFromHBITMAP(new HandleRef(null, hbitmap), new HandleRef(null, hpalette), out bitmap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return Bitmap.FromGDIplus(bitmap);
        }

        /*
         * Return the pixel size for the specified format (in bits)
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.GetPixelFormatSize"]/*' />
        /// <devdoc>
        ///    Returns the size of the specified pixel
        ///    format.
        /// </devdoc>
        public static int GetPixelFormatSize(PixelFormat pixfmt) {
            return((int)pixfmt >> 8) & 0xFF;
        }

        /*
         * Determine if the pixel format can have alpha channel
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.IsAlphaPixelFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a value indicating whether the
        ///       pixel format contains alpha information.
        ///    </para>
        /// </devdoc>
        public static bool IsAlphaPixelFormat(PixelFormat pixfmt) {
            return(pixfmt & PixelFormat.Alpha) != 0;
        }

        /*
         * Determine if the pixel format is an extended format,
         * i.e. supports 16-bit per channel
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.IsExtendedPixelFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a value indicating whether the pixel format is extended.
        ///    </para>
        /// </devdoc>
        public static bool IsExtendedPixelFormat(PixelFormat pixfmt) {
            return(pixfmt & PixelFormat.Extended) != 0;
        }

        /*
         * Determine if the pixel format is canonical format:
         *   PixelFormat32bppARGB
         *   PixelFormat32bppPARGB
         *   PixelFormat64bppARGB
         *   PixelFormat64bppPARGB
         */
        /// <include file='doc\Image.uex' path='docs/doc[@for="Image.IsCanonicalPixelFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a value indicating whether the pixel format is canonical.
        ///    </para>
        /// </devdoc>
        public static bool IsCanonicalPixelFormat(PixelFormat pixfmt) {
            return(pixfmt & PixelFormat.Canonical) != 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\iconconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IconConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\IconConverter.uex' path='docs/doc[@for="IconConverter"]/*' />
    /// <devdoc>
    ///      IconConverter is a class that can be used to convert
    ///      Icon from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class IconConverter : ExpandableObjectConverter {

        /// <include file='doc\IconConverter.uex' path='docs/doc[@for="IconConverter.CanConvertFrom1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(byte[])) {
                return true;
            }
            
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\IconConverter.uex' path='docs/doc[@for="IconConverter.CanConvertTo1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(byte[])) {
                return true;
            }

            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\IconConverter.uex' path='docs/doc[@for="IconConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given object to the converter's native type.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is byte[]) {
                MemoryStream ms = new MemoryStream((byte[])value);
                return new Icon(ms);
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\IconConverter.uex' path='docs/doc[@for="IconConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    // should do something besides ToString() the image...go get
                    // the filename
                    Icon image = (Icon) value;
                    return image.ToString();
                }
                else
                    return SR.GetString(SR.toStringNone);
            }
            else if (destinationType == typeof(byte[])) {
                if (value != null) {
                    MemoryStream ms = new MemoryStream();
                    Icon icon = (Icon)value;
                    icon.Save(ms);
                    ms.Close();
                    return ms.ToArray();
                }
                else 
                    return new byte[0];
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\imageconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Reflection;
    using System.Drawing.Imaging;

    /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter"]/*' />
    /// <devdoc>
    ///      ImageConverter is a class that can be used to convert
    ///      Image from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class ImageConverter : TypeConverter {

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.CanConvertFrom1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(byte[])) {
                return true;
            }
            
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.CanConvertTo1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(byte[])) {
                return true;
            }

            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given object to the converter's native type.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is byte[]) {
                MemoryStream ms = new MemoryStream((byte[])value);
                return Image.FromStream(ms);
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    // should do something besides ToString() the image...go get the filename
                    Image image = (Image)value;
                    return image.ToString();
                }
                else
                    return SR.GetString(SR.toStringNone);
            }
            else if (destinationType == typeof(byte[])) {
                if (value != null) {
                    bool createdNewImage = false;
                    MemoryStream ms = new MemoryStream();
                    
                    Image image = (Image) value;
                    
                    //We don't want to serialize an icon - since we're not really working with
                    //icons, these are "Images".  So, we'll force a new and valid bitmap to be
                    //created around our icon with the ideal size.
                    if (image.RawFormat.Equals(ImageFormat.Icon)) {
                        image = new Bitmap(image, image.Width, image.Height);
                        createdNewImage = true;
                    }
                    
                    image.Save(ms);
                    ms.Close();

                    if (createdNewImage) {
                        image.Dispose();
                    }

                    return ms.ToArray();
                }
                else 
                    return new byte[0];
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            return TypeDescriptor.GetProperties(typeof(Image), attributes);
        }

        /// <include file='doc\ImageConverter.uex' path='docs/doc[@for="ImageConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\pen.cs ===
//------------------------------------------------------------------------------
// <copyright file="Pen.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Pen.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ path objects
*
* Revision History:
*
*   01/11/1999 davidx
*       Code review changes.
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Drawing2D;
    using System.Drawing.Internal;

    /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines an object used to draw
    ///       lines and curves.
    ///    </para>
    /// </devdoc>
    public sealed class Pen : MarshalByRefObject, ISystemColorTracker, ICloneable, IDisposable {

#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        /*
         * handle to native pen object
         */
        internal IntPtr nativePen;

        // GDI+ doesn't understand system colors, so we need to cache the value here
        private Color color;
        private bool immutable = false;

        private Pen(IntPtr nativePen) {
            SetNativePen(nativePen);
        }

        internal Pen(Color color, bool immutable) : this(color) {
            this.immutable = immutable;
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Pen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the Pen
        ///       class with the specified coor.
        ///       
        ///    </para>
        /// </devdoc>
        public Pen(Color color) : this(color, (float)1.0) {
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Pen1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the
        ///    <see cref='System.Drawing.Pen'/> 
        ///    class with the specified <see cref='System.Drawing.Pen.Color'/> and <see cref='System.Drawing.Pen.Width'/>.
        /// </para>
        /// </devdoc>
        public Pen(Color color, float width) {
            this.color = color;

            IntPtr pen = IntPtr.Zero;
            int status = SafeNativeMethods.GdipCreatePen1(color.ToArgb(), 
                                                width, 
                                                (int)GraphicsUnit.World, 
                                                out pen);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativePen(pen);

            if (color.IsSystemColor)
                SystemColorTracker.Add(this);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Pen2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the Pen class with the
        ///       specified <see cref='System.Drawing.Pen.Brush'/>
        ///       .
        ///       
        ///    </para>
        /// </devdoc>
        public Pen(Brush brush) : this(brush, (float)1.0) {
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Pen3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Pen'/> class with
        ///       the specified <see cref='System.Drawing.Brush'/> and width.
        ///    </para>
        /// </devdoc>
        public Pen(Brush brush, float width) {
            IntPtr pen = IntPtr.Zero;

            if (brush == null)
                throw new ArgumentNullException("brush");

            int status = SafeNativeMethods.GdipCreatePen2(new HandleRef(brush, brush.nativeBrush), 
                                                width, 
                                                (int)GraphicsUnit.World,
                                                out pen); 

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativePen(pen);
        }

        /**
         * Create a copy of the pen object
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public object Clone() {
            IntPtr clonePen = IntPtr.Zero;

            int status = SafeNativeMethods.GdipClonePen(new HandleRef(this, nativePen), out clonePen);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Pen(clonePen);
        }

        /**
         * Dispose of resources associated with the Pen object
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativePen != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif

            if (!disposing) {
                // If we are finalizing, then we will be unreachable soon.  Finalize calls dispose to
                // release resources, so we must make sure that during finalization we are
                // not immutable.
                //
                immutable = false;
            }
            else if (immutable) {
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Brush"));
            }
        
            if (nativePen != IntPtr.Zero) {
                SafeNativeMethods.GdipDeletePen(new HandleRef(this, nativePen));
                nativePen = IntPtr.Zero;
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        ~Pen() {
            Dispose(false);
        }

        internal void SetNativePen(IntPtr nativePen) {
            if (nativePen == IntPtr.Zero)
                throw new ArgumentNullException("nativePen");

            this.nativePen = nativePen;
        }

        /**
         * Set/get pen width
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Width"]/*' />
        /// <devdoc>
        ///    Gets or sets the width of this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public float Width
        {
            get {
                float[] width = new float[] { 0};

                int status = SafeNativeMethods.GdipGetPenWidth(new HandleRef(this, nativePen), width);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return width[0];
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenWidth(new HandleRef(this, nativePen), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Set/get line caps: start, end, and dash
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.SetLineCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the values that determine the style of
        ///       cap used to end lines drawn by this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap) {
            if (immutable)
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));
            int status = SafeNativeMethods.GdipSetPenLineCap197819(new HandleRef(this, nativePen), (int)startCap, (int)endCap, (int)dashCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.StartCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the cap style used at the
        ///       beginning of lines drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public LineCap StartCap
        {
            get {
                int startCap = 0;
                int status = SafeNativeMethods.GdipGetPenStartCap(new HandleRef(this, nativePen), out startCap);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(LineCap) startCap;
            }

            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(LineCap), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenStartCap(new HandleRef(this, nativePen), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.EndCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the cap style used at the end of
        ///       lines drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public LineCap EndCap
        {
            get {
                int endCap = 0;
                int status = SafeNativeMethods.GdipGetPenEndCap(new HandleRef(this, nativePen), out endCap);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(LineCap) endCap;
            }

            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(LineCap), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(LineCap));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenEndCap(new HandleRef(this, nativePen), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.DashCap"]/*' />
        /// <devdoc>
        ///    Gets or sets the cap style used at the
        ///    beginning or end of dashed lines drawn with this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public DashCap DashCap
        {
            get {
                int dashCap = 0;
                int status = SafeNativeMethods.GdipGetPenDashCap197819(new HandleRef(this, nativePen), out dashCap);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(DashCap)dashCap;
            }

            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(DashCap), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DashCap));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenDashCap197819(new HandleRef(this, nativePen), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
        * Set/get line join
        */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.LineJoin"]/*' />
        /// <devdoc>
        ///    Gets or sets the join style for the ends of
        ///    two overlapping lines drawn with this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public LineJoin LineJoin
        {
            get {
                int lineJoin = 0;
                int status = SafeNativeMethods.GdipGetPenLineJoin(new HandleRef(this, nativePen), out lineJoin);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(LineJoin)lineJoin;
            }

            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(LineJoin), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(LineJoin));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenLineJoin(new HandleRef(this, nativePen), (int)value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Set/get custom start line cap
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.CustomStartCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a custom cap style to use at the beginning of lines
        ///       drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public CustomLineCap CustomStartCap
        {
            get {
                IntPtr lineCap = IntPtr.Zero;
                int status = SafeNativeMethods.GdipGetPenCustomStartCap(new HandleRef(this, nativePen), out lineCap);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return CustomLineCap.CreateCustomLineCapObject(lineCap);
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));


                int status = SafeNativeMethods.GdipSetPenCustomStartCap(new HandleRef(this, nativePen), 
                                                              new HandleRef(value, (value == null) ? IntPtr.Zero : value.nativeCap));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Set/get custom end line cap
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.CustomEndCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a custom cap style to use at the end of lines
        ///       drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public CustomLineCap CustomEndCap
        {
            get {
                IntPtr lineCap = IntPtr.Zero;
                int status = SafeNativeMethods.GdipGetPenCustomEndCap(new HandleRef(this, nativePen), out lineCap);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return CustomLineCap.CreateCustomLineCapObject(lineCap);
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenCustomEndCap(new HandleRef(this, nativePen), 
                                                            new HandleRef(value, (value == null) ? IntPtr.Zero : value.nativeCap));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.MiterLimit"]/*' />
        /// <devdoc>
        ///    Gets or sets the limit of the thickness of
        ///    the join on a mitered corner.
        /// </devdoc>
        public float MiterLimit
        {
            get {
                float[] miterLimit = new float[] { 0};
                int status = SafeNativeMethods.GdipGetPenMiterLimit(new HandleRef(this, nativePen), miterLimit);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return miterLimit[0];
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenMiterLimit(new HandleRef(this, nativePen), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Pen Mode
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Alignment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the alignment for objects drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public PenAlignment Alignment
        {
            get {
                PenAlignment penMode = 0;

                int status = SafeNativeMethods.GdipGetPenMode(new HandleRef(this, nativePen), out penMode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(PenAlignment) penMode;
            }
            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(PenAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PenAlignment));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenMode(new HandleRef(this, nativePen), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Set/get pen transform
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Transform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the geometrical transform for objects drawn with this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public Matrix Transform
        {
            get {
                Matrix matrix = new Matrix();

                int status = SafeNativeMethods.GdipGetPenTransform(new HandleRef(this, nativePen), new HandleRef(matrix, matrix.nativeMatrix));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return matrix;
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                if (value == null) {
                    throw new ArgumentNullException("value");
                }

                int status = SafeNativeMethods.GdipSetPenTransform(new HandleRef(this, nativePen), new HandleRef(value, value.nativeMatrix));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.ResetTransform"]/*' />
        /// <devdoc>
        ///    Resets the geometric transform for this
        /// <see cref='System.Drawing.Pen'/> to 
        ///    identity.
        /// </devdoc>
        public void ResetTransform() {
            int status = SafeNativeMethods.GdipResetPenTransform(new HandleRef(this, nativePen));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.MultiplyTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the transform matrix for this
        ///    <see cref='System.Drawing.Pen'/> by 
        ///       the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix) {
            MultiplyTransform(matrix, MatrixOrder.Prepend);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.MultiplyTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the transform matrix for this
        ///    <see cref='System.Drawing.Pen'/> by 
        ///       the specified <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix, MatrixOrder order) {
            int status = SafeNativeMethods.GdipMultiplyPenTransform(new HandleRef(this, nativePen),
                                                          new HandleRef(matrix, matrix.nativeMatrix),
                                                          order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.TranslateTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the local geometrical transform
        ///       by the specified dimmensions. This method prepends the translation to the
        ///       transform.
        ///    </para>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy) {
            TranslateTransform(dx, dy, MatrixOrder.Prepend);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.TranslateTransform1"]/*' />
        /// <devdoc>
        ///    Translates the local geometrical transform
        ///    by the specified dimmensions in the specified order.
        /// </devdoc>
        public void TranslateTransform(float dx, float dy, MatrixOrder order) {
            int status = SafeNativeMethods.GdipTranslatePenTransform(new HandleRef(this, nativePen),
                                                           dx, dy, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.ScaleTransform"]/*' />
        /// <devdoc>
        ///    Scales the local geometric transform by the
        ///    specified amounts. This method prepends the scaling matrix to the transform.
        /// </devdoc>
        public void ScaleTransform(float sx, float sy) {
            ScaleTransform(sx, sy, MatrixOrder.Prepend);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.ScaleTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the
        ///       specified amounts in the specified order.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy, MatrixOrder order) {
            int status = SafeNativeMethods.GdipScalePenTransform(new HandleRef(this, nativePen),
                                                       sx, sy, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.RotateTransform"]/*' />
        /// <devdoc>
        ///    Rotates the local geometric transform by the
        ///    specified amount. This method prepends the rotation to the transform.
        /// </devdoc>
        public void RotateTransform(float angle) {
            RotateTransform(angle, MatrixOrder.Prepend);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.RotateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified
        ///       amount in the specified order.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle, MatrixOrder order) {
            int status = SafeNativeMethods.GdipRotatePenTransform(new HandleRef(this, nativePen),
                                                        angle, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Set/get pen type (color, line texture, or brush)
         *
         * @notes GetLineFill returns either a Brush object
         *  or a LineTexture object.
         */

        private void InternalSetColor(Color value) {
            int status = SafeNativeMethods.GdipSetPenColor(new HandleRef(this, nativePen),
                                                 color.ToArgb());
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.PenType"]/*' />
        /// <devdoc>
        ///    Gets the style of lines drawn with this
        /// <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public PenType PenType
        {
            get {
                int type = -1;

                int status = SafeNativeMethods.GdipGetPenFillType(new HandleRef(this, nativePen), out type);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(PenType)type;
            }                
        }

        private void _SetBrush(Brush brush) {
            if (immutable)
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

            int status = SafeNativeMethods.GdipSetPenBrushFill(new HandleRef(this, nativePen),
                                                     new HandleRef(brush, brush.nativeBrush));
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Color"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the color of this <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public Color Color {
            get {
                if (color == Color.Empty) {
                    int colorARGB = 0;
                    int status = SafeNativeMethods.GdipGetPenColor(new HandleRef(this, nativePen), out colorARGB);

                    if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);

                    this.color = Color.FromArgb(colorARGB);
                }

                // GDI+ doesn't understand system colors, so we can't use GdipGetPenColor in the general case
                return color;
            }
            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                Color oldColor = this.color;
                this.color = value;
                InternalSetColor(value);

                // CONSIDER: We never remove pens from the active list, so if someone is
                // changing their pen colors a lot, this could be a problem.
                if (value.IsSystemColor && !oldColor.IsSystemColor)
                    SystemColorTracker.Add(this);
            }
        }

        private void _SetColor(Color value) {
            if (immutable)
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

            Color oldColor = this.color;
            this.color = value;
            InternalSetColor(value);

            // CONSIDER: We never remove pens from the active list, so if someone is
            // changing their pen colors a lot, this could be a problem.
            if (value.IsSystemColor && !oldColor.IsSystemColor)
                SystemColorTracker.Add(this);
        }

        private Brush _GetBrush() {
            if (immutable)
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

            Brush brush = null;

            switch (PenType) {
                case PenType.SolidColor:
                    brush = new SolidBrush();
                    break;

                case PenType.HatchFill:
                    brush = new HatchBrush();
                    break;

                case PenType.TextureFill:
                    brush = new TextureBrush();
                    break;

                case PenType.PathGradient:
                    brush = new PathGradientBrush();
                    break;

                case PenType.LinearGradient:
                    brush = new LinearGradientBrush();
                    break;

                default:
                    break;
            }                                                 

            if (brush != null) {
                IntPtr nativeBrush = IntPtr.Zero;

                int status = SafeNativeMethods.GdipGetPenBrushFill(new HandleRef(this, nativePen), out nativeBrush);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                brush.SetNativeBrush(nativeBrush);
            }

            return brush;
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.Brush"]/*' />
        /// <devdoc>
        ///    Gets or sets the <see cref='System.Drawing.Brush'/> that
        ///    determines attributes of this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public Brush Brush {
            get {
                return _GetBrush();
            }
            set {
                _SetBrush(value);
            }
        }

        /**
         * Set/get dash attributes
         */
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.DashStyle"]/*' />
        /// <devdoc>
        ///    Gets or sets the style used for dashed
        ///    lines drawn with this <see cref='System.Drawing.Pen'/>.
        /// </devdoc>
        public DashStyle DashStyle
        {
            get {
                int dashstyle = 0;

                int status = SafeNativeMethods.GdipGetPenDashStyle(new HandleRef(this, nativePen), out dashstyle);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(DashStyle) dashstyle;
            }

            set {
                //validate the enum value
                if (!Enum.IsDefined(typeof(DashStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DashStyle));
                }

                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenDashStyle(new HandleRef(this, nativePen), (int)value);

                if (status != SafeNativeMethods.Ok) {
                    throw SafeNativeMethods.StatusException(status);
                }

                //if we just set pen style to "custom" without defining the custom dash pattern,
                //lets make sure we can return a valid value...
                //
                if (value == DashStyle.Custom) {
                    EnsureValidDashPattern();
                }
            }
        }
        
        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.EnsureValidDashPattern"]/*' />
        /// <devdoc>
        ///    This method is called after the user sets the pen's dash style to custom.
        ///    Here, we make sure that there is a default value set for the custom pattern.
        /// </devdoc>
        private void EnsureValidDashPattern() {
            int retval = 0;
            int status = SafeNativeMethods.GdipGetPenDashCount(new HandleRef(this, nativePen), out retval);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            if (retval == 0) {
                //just set to a solid pattern
                DashPattern = new float[]{1};
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.DashOffset"]/*' />
        /// <devdoc>
        ///    Gets or sets the distance from the start of
        ///    a line to the beginning of a dash pattern.
        /// </devdoc>
        public float DashOffset
        {
            get {
                float[] dashoffset = new float[] { 0};

                int status = SafeNativeMethods.GdipGetPenDashOffset(new HandleRef(this, nativePen), dashoffset);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return dashoffset[0];
            }
            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenDashOffset(new HandleRef(this, nativePen), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.DashPattern"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets an array of cutom dashes and
        ///       spaces. The dashes are made up of line segments.
        ///    </para>
        /// </devdoc>
        public float[] DashPattern
        {
            get {
                // Figure out how many dash elements we have

                int retval = 0;
                int status = SafeNativeMethods.GdipGetPenDashCount(new HandleRef(this, nativePen), out retval);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                int count = retval;

                // Allocate temporary native memory buffer
                // and pass it to GDI+ to retrieve dash array elements

                IntPtr buf = Marshal.AllocHGlobal(4 * count);
                status = SafeNativeMethods.GdipGetPenDashArray(new HandleRef(this, nativePen), buf, count);

                if (status != SafeNativeMethods.Ok) {
                    Marshal.FreeHGlobal(buf);
                    throw SafeNativeMethods.StatusException(status);
                }

                float[] dashArray = new float[count];

                Marshal.Copy(buf, dashArray, 0, count);
                Marshal.FreeHGlobal(buf);

                return dashArray;
            }

            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                
                //validate the DashPattern value being set
                if (value ==  null || value.Length == 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidDashPattern));
                }

                int count = value.Length;

                IntPtr buf = Marshal.AllocHGlobal(4 * count);

                Marshal.Copy(value, 0, buf, count);

                int status = SafeNativeMethods.GdipSetPenDashArray(new HandleRef(this, nativePen), new HandleRef(buf, buf), count);

                Marshal.FreeHGlobal(buf);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.CompoundArray"]/*' />
        /// <devdoc>
        ///    Gets or sets an array of cutom dashes and
        ///    spaces. The dashes are made up of line segments.
        /// </devdoc>
        public float[] CompoundArray
        {
            get {
                int count = 0;

                int status = SafeNativeMethods.GdipGetPenCompoundCount(new HandleRef(this, nativePen), out count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                float[] array = new float[count];

                status = SafeNativeMethods.GdipGetPenCompoundArray(new HandleRef(this, nativePen), array, count);
                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return array;
            }
            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Pen"));

                int status = SafeNativeMethods.GdipSetPenCompoundArray(new HandleRef(this, nativePen), value, value.Length);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Pen.uex' path='docs/doc[@for="Pen.ISystemColorTracker.OnSystemColorChanged"]/*' />
        /// <internalonly/>
        void ISystemColorTracker.OnSystemColorChanged() {
            if (nativePen != IntPtr.Zero)
                InternalSetColor(color);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\intsecurity.cs ===
//------------------------------------------------------------------------------
// <copyright file="IntSecurity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IntSecurity.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Drawing {
    using System;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Drawing.Printing;

    internal class IntSecurity {
        private static readonly UIPermission AllWindows = new UIPermission(UIPermissionWindow.AllWindows);
        private static readonly UIPermission SafeSubWindows = new UIPermission(UIPermissionWindow.SafeSubWindows);

        public static readonly CodeAccessPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

        public static readonly CodeAccessPermission ObjectFromWin32Handle = UnmanagedCode;
        public static readonly CodeAccessPermission Win32HandleManipulation = UnmanagedCode;

        public static readonly PrintingPermission NoPrinting = new PrintingPermission(PrintingPermissionLevel.NoPrinting);
        public static readonly PrintingPermission SafePrinting = new PrintingPermission(PrintingPermissionLevel.SafePrinting);
        public static readonly PrintingPermission DefaultPrinting = new PrintingPermission(PrintingPermissionLevel.DefaultPrinting);
        public static readonly PrintingPermission AllPrinting = new PrintingPermission(PrintingPermissionLevel.AllPrinting);

        internal static void DemandReadFileIO(string fileName) {
            string full = fileName;
            
            FileIOPermission fiop = new FileIOPermission(PermissionState.None);
            fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
            fiop.Assert();
            try {
                full = Path.GetFullPath(fileName);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            new FileIOPermission(FileIOPermissionAccess.Read, full).Demand();
        }

        internal static void DemandWriteFileIO(string fileName) {
            string full = fileName;
            new EnvironmentPermission(PermissionState.Unrestricted).Assert();
            try {
                full = Path.GetFullPath(fileName);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            new FileIOPermission(FileIOPermissionAccess.Write, full).Demand();
        }

        static PermissionSet allPrintingAndUnmanagedCode;
        public static PermissionSet AllPrintingAndUnmanagedCode {
            get {
                if (allPrintingAndUnmanagedCode == null) {
                    PermissionSet temp = new PermissionSet(PermissionState.None);
                    temp.SetPermission(IntSecurity.UnmanagedCode);
                    temp.SetPermission(IntSecurity.AllPrinting);
                    allPrintingAndUnmanagedCode = temp;
                }
                return allPrintingAndUnmanagedCode;
            }
        }

        internal static bool HasPermission(PrintingPermission permission) {
            try {
                permission.Demand();
                return true;
            }
            catch (SecurityException) {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   NativeMethods.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;
    using Microsoft.Win32;

    internal class NativeMethods {
        public static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\icon.cs ===
// #define CUSTOM_MARSHALING_ISTREAM

//------------------------------------------------------------------------------
// <copyright file="Icon.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing.Design;    
    using System.Drawing.Imaging;    
    using System.IO;
    using System.Reflection;    

    /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon"]/*' />
    /// <devdoc>
    ///     This class represents a Windows icon, which is a small bitmap image used to
    ///     represent an object.  Icons can be thought of as transparent bitmaps, although
    ///     their size is determined by the system.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(IconConverter)),
    Editor("System.Drawing.Design.IconEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor))
    ]
    [Serializable]
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public sealed class Icon : MarshalByRefObject, ISerializable, ICloneable, IDisposable {
#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        private static int bitDepth;

        // Icon data
        //
        private byte[] iconData;
        private Size   iconSize = System.Drawing.Size.Empty;
        private IntPtr handle = IntPtr.Zero;
        private bool   ownHandle = true;

        private Icon() {
        }

        internal Icon(IntPtr handle) {
            if (handle == IntPtr.Zero) {
                throw new ArgumentException(SR.GetString(SR.InvalidGDIHandle, (typeof(Icon)).Name));
            }

            this.handle = handle;
            this.ownHandle = false;
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon"]/*' />
        /// <devdoc>
        ///     Loads an icon object from the given filename.
        /// </devdoc>
        public Icon(string fileName) : this() {
            using (FileStream f = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) {
                Debug.Assert(f != null, "File.OpenRead returned null instead of throwing an exception");
                iconData = new byte[(int)f.Length];
                f.Read(iconData, 0, iconData.Length);
            }
            
            Initialize(0, 0);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon1"]/*' />
        /// <devdoc>
        ///     Duplicates the given icon, attempting to find a version of the icon
        ///     that matches the requested size.  If a version cannot be found that
        ///     exactally matches the size, the closest match will be used.  Note
        ///     that if original is an icon with a single size, this will
        ///     merely create a dupicate icon.  You can use the stretching modes
        ///     of drawImage to force the icon to the size you want.
        /// </devdoc>
        public Icon(Icon original, Size size) : this(original, size.Width, size.Height) {
        }
        
        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon2"]/*' />
        /// <devdoc>
        ///     Duplicates the given icon, attempting to find a version of the icon
        ///     that matches the requested size.  If a version cannot be found that
        ///     exactally matches the size, the closest match will be used.  Note
        ///     that if original is an icon with a single size, this will
        ///     merely create a dupicate icon.  You can use the stretching modes
        ///     of drawImage to force the icon to the size you want.
        /// </devdoc>
        public Icon(Icon original, int width, int height) : this() {
            if (original == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "original", "null"));
            }
            
            iconData = original.iconData;
            
            if (iconData == null) {
                iconSize = original.Size;
                handle = SafeNativeMethods.CopyImage(new HandleRef(original, original.Handle), SafeNativeMethods.IMAGE_ICON, iconSize.Width, iconSize.Height, 0);
            }
            else {
                Initialize(width, height);
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon3"]/*' />
        /// <devdoc>
        ///     Loads an icon object from the given resource.
        /// </devdoc>
        public Icon(Type type, string resource) : this() {
            Stream stream = type.Module.Assembly.GetManifestResourceStream(type, resource);
            if (stream == null) {
                throw new ArgumentException(SR.GetString(SR.ResourceNotFound, type, resource));
            }

            iconData = new byte[(int)stream.Length];
            stream.Read(iconData, 0, iconData.Length);
            Initialize(0, 0);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon4"]/*' />
        /// <devdoc>
        ///     Loads an icon object from the given data stream.
        /// </devdoc>
        public Icon(Stream stream) : this() {
            if (stream == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));
            }

            iconData = new byte[(int)stream.Length];
            stream.Read(iconData, 0, iconData.Length);
            Initialize(0, 0);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Icon(Stream stream, int width, int height) : this() {
            if (stream == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));
            }

            iconData = new byte[(int)stream.Length];
            stream.Read(iconData, 0, iconData.Length);
            Initialize(width, height);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Icon6"]/*' />
        /// <devdoc>
        ///     Constructor used in deserialization
        /// </devdoc>
        /// <internalonly/>
        private Icon(SerializationInfo info, StreamingContext context) {
            iconData = (byte[])info.GetValue("IconData", typeof(byte[]));
            iconSize = (Size)info.GetValue("IconSize", typeof(Size));
            
            if (iconSize.IsEmpty) {
                Initialize(0, 0);
            }
            else {
                Initialize(iconSize.Width, iconSize.Height);
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Handle"]/*' />
        /// <devdoc>
        ///     The Win32 handle for this object.  This is not a copy of the handle; do
        ///     not free it.
        /// </devdoc>
        [Browsable(false)]
        public IntPtr Handle {
            get {
                if (handle == IntPtr.Zero) {
                    throw new ObjectDisposedException(GetType().Name);
                }
                return handle;
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Height"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public int Height {
            get { return Size.Height;}
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Size"]/*' />
        /// <devdoc>
        ///     The size of this icon object.
        /// </devdoc>
        public Size Size {
            get {
                if (iconSize.IsEmpty) {
                    SafeNativeMethods.ICONINFO info = new SafeNativeMethods.ICONINFO();
                    SafeNativeMethods.GetIconInfo(new HandleRef(this, Handle), info);
                    SafeNativeMethods.BITMAP bmp = new SafeNativeMethods.BITMAP();

                    if (info.hbmColor != IntPtr.Zero) {
                        SafeNativeMethods.GetObject(new HandleRef(null, info.hbmColor), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bmp);
                        SafeNativeMethods.DeleteObject(new HandleRef(null, info.hbmColor));
                    }
                    else if (info.hbmMask != IntPtr.Zero) {
                        SafeNativeMethods.GetObject(new HandleRef(null, info.hbmMask), Marshal.SizeOf(typeof(SafeNativeMethods.BITMAP)), bmp);
                    }
                    
                    if (info.hbmMask != IntPtr.Zero) {
                        SafeNativeMethods.DeleteObject(new HandleRef(null, info.hbmMask));
                    }

                    iconSize = new Size(bmp.bmWidth, bmp.bmHeight);
                }

                return iconSize;
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Width"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public int Width {
            get { return Size.Width;}
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Clone"]/*' />
        /// <devdoc>
        ///     Clones the icon object, creating a duplicate image.
        /// </devdoc>
        public object Clone() {
            return new Icon(this, Size.Width, Size.Height);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.DestroyHandle"]/*' />
        /// <devdoc>
        ///     Called when this object is going to destroy it's Win32 handle.  You
        ///     may override this if there is something special you need to do to
        ///     destroy the handle.  This will be called even if the handle is not
        ///     owned by this object, which is handy if you want to create a
        ///     derived class that has it's own create/destroy semantics.
        ///
        ///     The default implementation will call the appropriate Win32
        ///     call to destroy the handle if this object currently owns the
        ///     handle.  It will do nothing if the object does not currently
        ///     own the handle.
        /// </devdoc>
        internal void DestroyHandle() {
            if (ownHandle) {
                SafeNativeMethods.DestroyIcon(new HandleRef(this, handle));
                handle = IntPtr.Zero;
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Dispose"]/*' />
        /// <devdoc>
        ///     Cleans up the resources allocated by this object.  Once called, the cursor
        ///     object is no longer useful.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            if (handle != IntPtr.Zero) {
#if FINALIZATION_WATCH
                if (!disposing) {
                    Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
                }
#endif
                DestroyHandle();
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.DrawIcon"]/*' />
        /// <devdoc>
        ///     Draws this image to a graphics object.  The drawing command originates on the graphics
        ///     object, but a graphics object generally has no idea how to render a given image.  So,
        ///     it passes the call to the actual image.  This version crops the image to the given
        ///     dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        // This method is way more powerful than what we expose, but I'll leave it in place.
        private void DrawIcon(IntPtr dc, Rectangle imageRect, Rectangle targetRect, bool stretch) {
            int imageX = 0;
            int imageY = 0;
            int imageWidth;
            int imageHeight;
            int targetX = 0;
            int targetY = 0;
            int targetWidth = 0;
            int targetHeight = 0;

            Size cursorSize = Size;

            // compute the dimensions of the icon, if needed
            //
            if (!imageRect.IsEmpty) {
                imageX = imageRect.X;
                imageY = imageRect.Y;
                imageWidth = imageRect.Width;
                imageHeight = imageRect.Height;
            }
            else {
                imageWidth = cursorSize.Width;
                imageHeight = cursorSize.Height;
            }

            if (!targetRect.IsEmpty) {
                targetX = targetRect.X;
                targetY = targetRect.Y;
                targetWidth = targetRect.Width;
                targetHeight = targetRect.Height;
            }
            else {
                targetWidth = cursorSize.Width;
                targetHeight = cursorSize.Height;
            }

            int drawWidth, drawHeight;
            int clipWidth, clipHeight;

            if (stretch) {
                drawWidth = cursorSize.Width * targetWidth / imageWidth;
                drawHeight = cursorSize.Height * targetHeight / imageHeight;
                clipWidth = targetWidth;
                clipHeight = targetHeight;
            }
            else {
                drawWidth = cursorSize.Width;
                drawHeight = cursorSize.Height;
                clipWidth = targetWidth < imageWidth ? targetWidth : imageWidth;
                clipHeight = targetHeight < imageHeight ? targetHeight : imageHeight;
            }

            // The ROP is SRCCOPY, so we can be simple here and take
            // advantage of clipping regions.  Drawing the cursor
            // is merely a matter of offsetting and clipping.
            //
            SafeNativeMethods.IntersectClipRect(new HandleRef(this, Handle), targetX, targetY, targetX+clipWidth, targetY+clipHeight);
            SafeNativeMethods.DrawIconEx(new HandleRef(null, dc), 
                                         targetX - imageX, 
                                         targetY - imageY,
                                         new HandleRef(this, handle), 
                                         drawWidth, 
                                         drawHeight, 
                                         0, 
                                         NativeMethods.NullHandleRef, 
                                         SafeNativeMethods.DI_NORMAL);
            // Let GDI+ restore clipping
        }

        internal void Draw(Graphics graphics, int x, int y) {
            Size size = Size;
            Draw(graphics, new Rectangle(x, y, size.Width, size.Height));
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Draw"]/*' />
        /// <devdoc>
        ///     Draws this image to a graphics object.  The drawing command originates on the graphics
        ///     object, but a graphics object generally has no idea how to render a given image.  So,
        ///     it passes the call to the actual image.  This version stretches the image to the given
        ///     dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        internal void Draw(Graphics graphics, Rectangle targetRect) {
            Rectangle copy = targetRect;
            copy.X += (int) graphics.Transform.OffsetX;
            copy.Y += (int) graphics.Transform.OffsetY;

            IntPtr dc = graphics.GetHdc();
            try {
                DrawIcon(dc, Rectangle.Empty, copy, true);
            }
            finally {
                graphics.ReleaseHdcInternal(dc);
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.DrawUnstretched"]/*' />
        /// <devdoc>
        ///     Draws this image to a graphics object.  The drawing command originates on the graphics
        ///     object, but a graphics object generally has no idea how to render a given image.  So,
        ///     it passes the call to the actual image.  This version crops the image to the given
        ///     dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        internal void DrawUnstretched(Graphics graphics, Rectangle targetRect) {
            Rectangle copy = targetRect;
            copy.X += (int) graphics.Transform.OffsetX;
            copy.Y += (int) graphics.Transform.OffsetY;

            IntPtr dc = graphics.GetHdc();
            try {
                DrawIcon(dc, Rectangle.Empty, copy, false);
            }
            finally {
                graphics.ReleaseHdcInternal(dc);
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Finalize"]/*' />
        /// <devdoc>
        ///     Cleans up Windows resources for this object.
        /// </devdoc>
        ~Icon() {
            Dispose(false);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.FromHandle"]/*' />
        /// <devdoc>
        ///     Creates an icon object from a given Win32 icon handle.  The Icon object
        ///     does not claim ownership of the icon handle; you must free it when you are
        ///     done.
        /// </devdoc>
        public static Icon FromHandle(IntPtr handle) {
            IntSecurity.ObjectFromWin32Handle.Demand();
            return new Icon(handle);
        }
        
        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes this Image object.  This is identical to calling the image's
        ///     constructor with picture, but this allows non-constructor initialization,
        ///     which may be necessary in some instances.
        /// </devdoc>
        private unsafe void Initialize(int width, int height) {
            if (iconData == null || handle != IntPtr.Zero) {
                throw new InvalidOperationException(SR.GetString(SR.IllegalState, GetType().Name));
            }
            
            if (iconData.Length < Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIR))) {
                throw new ArgumentException(SR.GetString(SR.InvalidPictureType, "picture", "Icon"));
            }
            
            // Get the correct width / height
            //
            if (width == 0) {
                width = UnsafeNativeMethods.GetSystemMetrics(SafeNativeMethods.SM_CXICON);
            }
            
            if (height == 0) {
                height = UnsafeNativeMethods.GetSystemMetrics(SafeNativeMethods.SM_CYICON);
            }
            
            
            if (bitDepth == 0) {
                IntPtr dc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                bitDepth = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.BITSPIXEL);
                bitDepth *= UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.PLANES);
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));
                
                // If the bitdepth is 8, make it 4.  Why?  Because windows does not
                // choose a 256 color icon if the display is running in 256 color mode
                // because of palette flicker.  
                //
                if (bitDepth == 8) bitDepth = 4;
            }
            
            fixed(byte *pbIconData = iconData) {
                
                SafeNativeMethods.ICONDIR *pIconDir = (SafeNativeMethods.ICONDIR *)pbIconData;
                
                if (pIconDir->idReserved != 0 || pIconDir->idType != 1 || pIconDir->idCount == 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidPictureType, "picture", "Icon"));
                }
                
                SafeNativeMethods.ICONDIRENTRY *pIconDirEntry = &pIconDir->idEntries;
                SafeNativeMethods.ICONDIRENTRY *pBestFit = null;
                int bestBitDepth = 0;

                int icondirEntrySize = Marshal.SizeOf(typeof(SafeNativeMethods.ICONDIRENTRY));
                
                Debug.Assert((icondirEntrySize * pIconDir->idCount) < iconData.Length, "Illegal number of ICONDIRENTRIES");

                if ((icondirEntrySize * pIconDir->idCount) >= iconData.Length) {
                    throw new ArgumentException(SR.GetString(SR.InvalidPictureType, "picture", "Icon"));
                }

                for (int i = 0; i < pIconDir->idCount; i++) {
                
                    int iconBitDepth = pIconDirEntry->wPlanes * pIconDirEntry->wBitCount;
                    
                    if (iconBitDepth == 0) {
                        if (pIconDirEntry->bColorCount == 0) {
                            iconBitDepth = 16;
                        }
                        else {
                            iconBitDepth = 8;
                            if (pIconDirEntry->bColorCount < 0xFF) iconBitDepth = 4;
                            if (pIconDirEntry->bColorCount < 0x10) iconBitDepth = 2;
                        }
                    }
                    
                    //  Windows rules for specifing an icon:
                    //
                    //  1.  The icon with the closest size match.
                    //  2.  For matching sizes, the image with the closest bit depth.
                    //  3.  If there is no color depth match, the icon with the closest color depth that does not exceed the display.
                    //  4.  If all icon color depth > display, lowest color depth is chosen.
                    //  5.  color depth of > 8bpp are all equal.
                    //  6.  Never choose an 8bpp icon on an 8bpp system.
                    //
                    
                    if (pBestFit == null) {
                        pBestFit = pIconDirEntry;
                        bestBitDepth = iconBitDepth;
                    }
                    else {
                        int bestDelta = Math.Abs(pBestFit->bWidth - width) + Math.Abs(pBestFit->bHeight - height);
                        int thisDelta = Math.Abs(pIconDirEntry->bWidth - width) + Math.Abs(pIconDirEntry->bHeight - height);
                        
                        if (thisDelta < bestDelta) {
                            pBestFit = pIconDirEntry;
                            bestBitDepth = iconBitDepth;
                        }
                        else if (thisDelta == bestDelta && (iconBitDepth <= bitDepth && iconBitDepth > bestBitDepth || bestBitDepth > bitDepth && iconBitDepth < bestBitDepth)) {
                            pBestFit = pIconDirEntry;
                            bestBitDepth = iconBitDepth;
                        }
                    }
                    
                    pIconDirEntry++;
                }
                
                Debug.Assert(pBestFit->dwImageOffset >= 0 && (pBestFit->dwImageOffset + pBestFit->dwBytesInRes) <= iconData.Length, "Illegal offset/length for the Icon data");

                if (pBestFit->dwImageOffset < 0 || (pBestFit->dwImageOffset + pBestFit->dwBytesInRes) > iconData.Length) {
                    throw new ArgumentException(SR.GetString(SR.InvalidPictureType, "picture", "Icon"));
                }

                handle = SafeNativeMethods.CreateIconFromResourceEx(pbIconData + pBestFit->dwImageOffset, pBestFit->dwBytesInRes, true, 0x00030000, 0, 0, 0);
                if (handle == IntPtr.Zero) {
                    throw new Win32Exception();
                }
            }
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.Save"]/*' />
        /// <devdoc>
        ///     Saves this image to the given output stream.
        /// </devdoc>
        public void Save(Stream outputStream) {
            if (iconData != null) {
                outputStream.Write(iconData, 0, iconData.Length);
            }
            else {
                // Ideally, we would pick apart the icon using 
                // GetIconInfo, and then pull the individual bitmaps out,
                // converting them to DIBS and saving them into the file.
                // But, in the interest of simplicity, we just call to 
                // OLE to do it for us.
                //
                SafeNativeMethods.IPicture picture;
                SafeNativeMethods.PICTDESC pictdesc = SafeNativeMethods.PICTDESC.CreateIconPICTDESC(Handle);
                Guid g = typeof(SafeNativeMethods.IPicture).GUID;
                picture = SafeNativeMethods.OleCreatePictureIndirect(pictdesc, ref g, false);
                
                if (picture != null) {
                    int temp;
                    picture.SaveAsFile(new UnsafeNativeMethods.ComStreamFromDataStream(outputStream), -1, out temp);
                    Marshal.ReleaseComObject(picture);
                }
            }
        }

        // CONSIDER: if you're concerned about performance, you probably shouldn't call this method,
        // since you will probably turn it into an HBITMAP sooner or later anyway
        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.ToBitmap"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Bitmap ToBitmap() {
            Size size = Size;
            Bitmap bitmap = new Bitmap(size.Width, size.Height); // initialized to transparent
            Graphics graphics = Graphics.FromImage(bitmap);
            graphics.DrawIcon(this, new Rectangle(0, 0, size.Width, size.Height));
            graphics.Dispose();

            // gpr: GDI+ is filling the surface with a sentinel color for GetDC,
            // but is not correctly cleaning it up again, so we have to for it.
            Color fakeTransparencyColor = Color.FromArgb(0x0d, 0x0b, 0x0c);
            bitmap.MakeTransparent(fakeTransparencyColor);
            return bitmap;

#if false
            Size size = Size;
            OldBitmap old = new OldBitmap(size.Width, size.Height);
            OldBrush brush = new OldBrush(fakeTransparencyColor);
            old.GetGraphics().Fill(new Rectangle(0, 0, size.Width, size.Height), brush);
            brush.Dispose();

            IntPtr dc = old.GetGraphics().Handle;
            int rop = RasterOp.SOURCE.GetRop();
            DrawIcon(dc, null, new Rectangle(0, 0, size.Width, size.Height), rop, true);

            Bitmap bitmap = Image.FromHbitmap(old.Handle);
            old.Dispose();
            bitmap.MakeTransparent(/*fakeTransparencyColor*/);
            return bitmap;
#endif
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.ToString"]/*' />
        /// <devdoc>
        ///     Retrieves a human readable string representing the cursor.
        /// </devdoc>
        public override string ToString() {
            return SR.GetString(SR.toStringIcon);
        }

        /// <include file='doc\Icon.uex' path='docs/doc[@for="Icon.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        ///     ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            if (iconData != null) {
                si.AddValue("IconData", iconData, typeof(byte[]));
            }
            else {
                MemoryStream stream = new MemoryStream();
                Save(stream);
                si.AddValue("IconData", stream.ToArray(), typeof(byte[]));
            }
            si.AddValue("IconSize", iconSize, typeof(Size));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\knowncolor.cs ===
//------------------------------------------------------------------------------
// <copyright file="KnownColor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    


    /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor"]/*' />
    /// <devdoc>
    ///    Specifies the known system colors.
    /// </devdoc>
    public enum KnownColor {
        // This enum is order dependant!!!
        //
        // The value of these known colors are indexes into a color array.
        // Do not modify this enum without updating KnownColorTable.
        //


        // 0 - reserved for "not a known color"

        // "System" colors
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ActiveBorder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ActiveBorder = 1,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ActiveCaption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ActiveCaption,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ActiveCaptionText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ActiveCaptionText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.AppWorkspace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AppWorkspace,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Control"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Control,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ControlDark"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ControlDark,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ControlDarkDark"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ControlDarkDark,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ControlLight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ControlLight,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ControlLightLight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ControlLightLight,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ControlText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ControlText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Desktop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Desktop,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.GrayText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GrayText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Highlight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Highlight,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.HighlightText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HighlightText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.HotTrack"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HotTrack,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.InactiveBorder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InactiveBorder,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.InactiveCaption"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InactiveCaption,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.InactiveCaptionText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InactiveCaptionText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Info"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Info,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.InfoText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InfoText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Menu"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Menu,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MenuText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MenuText,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ScrollBar"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ScrollBar,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Window"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Window,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.WindowFrame"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WindowFrame,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.WindowText"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WindowText,

        // "Web" Colors
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Transparent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Transparent,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.AliceBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AliceBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.AntiqueWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AntiqueWhite,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Aqua"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Aqua,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Aquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Aquamarine,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Azure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Azure,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Beige"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Beige,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Bisque"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bisque,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Black"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Black,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.BlanchedAlmond"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BlanchedAlmond,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Blue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Blue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.BlueViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BlueViolet,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Brown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Brown,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.BurlyWood"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BurlyWood,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.CadetBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CadetBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Chartreuse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Chartreuse,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Chocolate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Chocolate,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Coral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Coral,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.CornflowerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CornflowerBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Cornsilk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cornsilk,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Crimson"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Crimson,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Cyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Cyan,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkCyan,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkGoldenrod,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkKhaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkKhaki,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkMagenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkMagenta,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkOliveGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkOliveGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkOrange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkOrange,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkOrchid,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkRed,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkSalmon,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkSeaGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkSlateBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkSlateGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkTurquoise,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DarkViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DarkViolet,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DeepPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeepPink,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DeepSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeepSkyBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DimGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DimGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.DodgerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DodgerBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Firebrick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Firebrick,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.FloralWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FloralWhite,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.ForestGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ForestGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Fuchsia"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Fuchsia,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Gainsboro"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Gainsboro,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.GhostWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GhostWhite,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Gold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Gold,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Goldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Goldenrod,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Gray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Gray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Green"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Green,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.GreenYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GreenYellow,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Honeydew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Honeydew,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.HotPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HotPink,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.IndianRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IndianRed,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Indigo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Indigo,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Ivory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ivory,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Khaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Khaki,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Lavender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Lavender,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LavenderBlush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LavenderBlush,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LawnGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LawnGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LemonChiffon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LemonChiffon,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightCoral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightCoral,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightCyan,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightGoldenrodYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightGoldenrodYellow,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightPink,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightSalmon,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightSeaGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightSkyBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightSlateGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightSteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightSteelBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LightYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LightYellow,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Lime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Lime,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.LimeGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LimeGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Linen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Linen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Magenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Magenta,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Maroon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Maroon,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumAquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumAquamarine,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumOrchid,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumPurple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumPurple,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumSeaGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumSlateBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumSpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumSpringGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumTurquoise,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MediumVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MediumVioletRed,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MidnightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MidnightBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MintCream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MintCream,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.MistyRose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MistyRose,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Moccasin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Moccasin,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.NavajoWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NavajoWhite,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Navy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Navy,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.OldLace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OldLace,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Olive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Olive,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.OliveDrab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OliveDrab,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Orange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Orange,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.OrangeRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OrangeRed,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Orchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Orchid,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PaleGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PaleGoldenrod,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PaleGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PaleGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PaleTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PaleTurquoise,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PaleVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PaleVioletRed,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PapayaWhip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PapayaWhip,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PeachPuff"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PeachPuff,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Peru"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Peru,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Pink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Pink,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Plum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Plum,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.PowderBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PowderBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Purple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Purple,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Red"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Red,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.RosyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RosyBrown,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.RoyalBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RoyalBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SaddleBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SaddleBrown,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Salmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Salmon,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SandyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SandyBrown,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SeaGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SeaShell"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SeaShell,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Sienna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Sienna,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Silver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Silver,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SkyBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SlateBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SlateGray,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Snow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Snow,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SpringGreen,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.SteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SteelBlue,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Tan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tan,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Teal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Teal,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Thistle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Thistle,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Tomato"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Tomato,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Turquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Turquoise,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Violet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Violet,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Wheat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Wheat,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.White"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        White,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.WhiteSmoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WhiteSmoke,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.Yellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Yellow,
        /// <include file='doc\KnownColor.uex' path='docs/doc[@for="KnownColor.YellowGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        YellowGreen,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\knowncolortable.cs ===
//------------------------------------------------------------------------------
// <copyright file="KnownColorTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {

    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Drawing.Internal;
    
    internal class KnownColorTable {
        private static int[] colorTable = null;
        private static string[] colorNameTable = null;
        
        /**
         * Shift count and bit mask for A, R, G, B components
         */
        private const int AlphaShift  = 24;
        private const int RedShift    = 16;
        private const int GreenShift  = 8;
        private const int BlueShift   = 0;

        private const int Win32RedShift    = 0;
        private const int Win32GreenShift  = 8;
        private const int Win32BlueShift   = 16;

        public static Color ArgbToKnownColor(int targetARGB) {
            EnsureColorTable();
            for(int index = 0; index < colorTable.Length; ++index) {
                int argb = colorTable[index];
                if (argb == targetARGB) {
                    Color color = Color.FromKnownColor((KnownColor)index);
                    if (!color.IsSystemColor)
                        return color;
                }
            }

            return Color.FromArgb(targetARGB);
        }

        private static void EnsureColorTable() {
            // no need to lock... worse case is a double create of the table...
            //
            if (colorTable == null) {
                InitColorTable();
            }
        }

        private static void InitColorTable() {
            int[] values = new int[((int)KnownColor.YellowGreen) + 1];

            // system
            //
            SystemEvents.UserPreferenceChanging += new UserPreferenceChangingEventHandler(OnUserPreferenceChanging);
            UpdateSystemColors(values);

            // just consts...
            //
            values[(int)KnownColor.Transparent] = 0x00FFFFFF;
            values[(int)KnownColor.AliceBlue] = unchecked((int)0xFFF0F8FF);
            values[(int)KnownColor.AntiqueWhite] = unchecked((int)0xFFFAEBD7);
            values[(int)KnownColor.Aqua] = unchecked((int)0xFF00FFFF);
            values[(int)KnownColor.Aquamarine] = unchecked((int)0xFF7FFFD4);
            values[(int)KnownColor.Azure] = unchecked((int)0xFFF0FFFF);
            values[(int)KnownColor.Beige] = unchecked((int)0xFFF5F5DC);
            values[(int)KnownColor.Bisque] = unchecked(unchecked((int)0xFFFFE4C4));
            values[(int)KnownColor.Black] = unchecked((int)0xFF000000);
            values[(int)KnownColor.BlanchedAlmond] = unchecked((int)0xFFFFEBCD);
            values[(int)KnownColor.Blue] = unchecked((int)0xFF0000FF);
            values[(int)KnownColor.BlueViolet] = unchecked((int)0xFF8A2BE2);
            values[(int)KnownColor.Brown] = unchecked((int)0xFFA52A2A);
            values[(int)KnownColor.BurlyWood] = unchecked((int)0xFFDEB887);
            values[(int)KnownColor.CadetBlue] = unchecked((int)0xFF5F9EA0);
            values[(int)KnownColor.Chartreuse] = unchecked((int)0xFF7FFF00);
            values[(int)KnownColor.Chocolate] = unchecked((int)0xFFD2691E);
            values[(int)KnownColor.Coral] = unchecked((int)0xFFFF7F50);
            values[(int)KnownColor.CornflowerBlue] = unchecked((int)0xFF6495ED);
            values[(int)KnownColor.Cornsilk] = unchecked((int)0xFFFFF8DC);
            values[(int)KnownColor.Crimson] = unchecked((int)0xFFDC143C);
            values[(int)KnownColor.Cyan] = unchecked((int)0xFF00FFFF);
            values[(int)KnownColor.DarkBlue] = unchecked((int)0xFF00008B);
            values[(int)KnownColor.DarkCyan] = unchecked((int)0xFF008B8B);
            values[(int)KnownColor.DarkGoldenrod] = unchecked((int)0xFFB8860B);
            values[(int)KnownColor.DarkGray] = unchecked((int)0xFFA9A9A9);
            values[(int)KnownColor.DarkGreen] = unchecked((int)0xFF006400);
            values[(int)KnownColor.DarkKhaki] = unchecked((int)0xFFBDB76B);
            values[(int)KnownColor.DarkMagenta] = unchecked((int)0xFF8B008B);
            values[(int)KnownColor.DarkOliveGreen] = unchecked((int)0xFF556B2F);
            values[(int)KnownColor.DarkOrange] = unchecked((int)0xFFFF8C00);
            values[(int)KnownColor.DarkOrchid] = unchecked((int)0xFF9932CC);
            values[(int)KnownColor.DarkRed] = unchecked((int)0xFF8B0000);
            values[(int)KnownColor.DarkSalmon] = unchecked((int)0xFFE9967A);
            values[(int)KnownColor.DarkSeaGreen] = unchecked((int)0xFF8FBC8B);
            values[(int)KnownColor.DarkSlateBlue] = unchecked((int)0xFF483D8B);
            values[(int)KnownColor.DarkSlateGray] = unchecked((int)0xFF2F4F4F);
            values[(int)KnownColor.DarkTurquoise] = unchecked((int)0xFF00CED1);
            values[(int)KnownColor.DarkViolet] = unchecked((int)0xFF9400D3);
            values[(int)KnownColor.DeepPink] = unchecked((int)0xFFFF1493);
            values[(int)KnownColor.DeepSkyBlue] = unchecked((int)0xFF00BFFF);
            values[(int)KnownColor.DimGray] = unchecked((int)0xFF696969);
            values[(int)KnownColor.DodgerBlue] = unchecked((int)0xFF1E90FF);
            values[(int)KnownColor.Firebrick] = unchecked((int)0xFFB22222);
            values[(int)KnownColor.FloralWhite] = unchecked((int)0xFFFFFAF0);
            values[(int)KnownColor.ForestGreen] = unchecked((int)0xFF228B22);
            values[(int)KnownColor.Fuchsia] = unchecked((int)0xFFFF00FF);
            values[(int)KnownColor.Gainsboro] = unchecked((int)0xFFDCDCDC);
            values[(int)KnownColor.GhostWhite] = unchecked((int)0xFFF8F8FF);
            values[(int)KnownColor.Gold] = unchecked((int)0xFFFFD700);
            values[(int)KnownColor.Goldenrod] = unchecked((int)0xFFDAA520);
            values[(int)KnownColor.Gray] = unchecked((int)0xFF808080);
            values[(int)KnownColor.Green] = unchecked((int)0xFF008000);
            values[(int)KnownColor.GreenYellow] = unchecked((int)0xFFADFF2F);
            values[(int)KnownColor.Honeydew] = unchecked((int)0xFFF0FFF0);
            values[(int)KnownColor.HotPink] = unchecked((int)0xFFFF69B4);
            values[(int)KnownColor.IndianRed] = unchecked((int)0xFFCD5C5C);
            values[(int)KnownColor.Indigo] = unchecked((int)0xFF4B0082);
            values[(int)KnownColor.Ivory] = unchecked((int)0xFFFFFFF0);
            values[(int)KnownColor.Khaki] = unchecked((int)0xFFF0E68C);
            values[(int)KnownColor.Lavender] = unchecked((int)0xFFE6E6FA);
            values[(int)KnownColor.LavenderBlush] = unchecked((int)0xFFFFF0F5);
            values[(int)KnownColor.LawnGreen] = unchecked((int)0xFF7CFC00);
            values[(int)KnownColor.LemonChiffon] = unchecked((int)0xFFFFFACD);
            values[(int)KnownColor.LightBlue] = unchecked((int)0xFFADD8E6);
            values[(int)KnownColor.LightCoral] = unchecked((int)0xFFF08080);
            values[(int)KnownColor.LightCyan] = unchecked((int)0xFFE0FFFF);
            values[(int)KnownColor.LightGoldenrodYellow] = unchecked((int)0xFFFAFAD2);
            values[(int)KnownColor.LightGray] = unchecked((int)0xFFD3D3D3);
            values[(int)KnownColor.LightGreen] = unchecked((int)0xFF90EE90);
            values[(int)KnownColor.LightPink] = unchecked((int)0xFFFFB6C1);
            values[(int)KnownColor.LightSalmon] = unchecked((int)0xFFFFA07A);
            values[(int)KnownColor.LightSeaGreen] = unchecked((int)0xFF20B2AA);
            values[(int)KnownColor.LightSkyBlue] = unchecked((int)0xFF87CEFA);
            values[(int)KnownColor.LightSlateGray] = unchecked((int)0xFF778899);
            values[(int)KnownColor.LightSteelBlue] = unchecked((int)0xFFB0C4DE);
            values[(int)KnownColor.LightYellow] = unchecked((int)0xFFFFFFE0);
            values[(int)KnownColor.Lime] = unchecked((int)0xFF00FF00);
            values[(int)KnownColor.LimeGreen] = unchecked((int)0xFF32CD32);
            values[(int)KnownColor.Linen] = unchecked((int)0xFFFAF0E6);
            values[(int)KnownColor.Magenta] = unchecked((int)0xFFFF00FF);
            values[(int)KnownColor.Maroon] = unchecked((int)0xFF800000);
            values[(int)KnownColor.MediumAquamarine] = unchecked((int)0xFF66CDAA);
            values[(int)KnownColor.MediumBlue] = unchecked((int)0xFF0000CD);
            values[(int)KnownColor.MediumOrchid] = unchecked((int)0xFFBA55D3);
            values[(int)KnownColor.MediumPurple] = unchecked((int)0xFF9370DB);
            values[(int)KnownColor.MediumSeaGreen] = unchecked((int)0xFF3CB371);
            values[(int)KnownColor.MediumSlateBlue] = unchecked((int)0xFF7B68EE);
            values[(int)KnownColor.MediumSpringGreen] = unchecked((int)0xFF00FA9A);
            values[(int)KnownColor.MediumTurquoise] = unchecked((int)0xFF48D1CC);
            values[(int)KnownColor.MediumVioletRed] = unchecked((int)0xFFC71585);
            values[(int)KnownColor.MidnightBlue] = unchecked((int)0xFF191970);
            values[(int)KnownColor.MintCream] = unchecked((int)0xFFF5FFFA);
            values[(int)KnownColor.MistyRose] = unchecked((int)0xFFFFE4E1);
            values[(int)KnownColor.Moccasin] = unchecked((int)0xFFFFE4B5);
            values[(int)KnownColor.NavajoWhite] = unchecked((int)0xFFFFDEAD);
            values[(int)KnownColor.Navy] = unchecked((int)0xFF000080);
            values[(int)KnownColor.OldLace] = unchecked((int)0xFFFDF5E6);
            values[(int)KnownColor.Olive] = unchecked((int)0xFF808000);
            values[(int)KnownColor.OliveDrab] = unchecked((int)0xFF6B8E23);
            values[(int)KnownColor.Orange] = unchecked((int)0xFFFFA500);
            values[(int)KnownColor.OrangeRed] = unchecked((int)0xFFFF4500);
            values[(int)KnownColor.Orchid] = unchecked((int)0xFFDA70D6);
            values[(int)KnownColor.PaleGoldenrod] = unchecked((int)0xFFEEE8AA);
            values[(int)KnownColor.PaleGreen] = unchecked((int)0xFF98FB98);
            values[(int)KnownColor.PaleTurquoise] = unchecked((int)0xFFAFEEEE);
            values[(int)KnownColor.PaleVioletRed] = unchecked((int)0xFFDB7093);
            values[(int)KnownColor.PapayaWhip] = unchecked((int)0xFFFFEFD5);
            values[(int)KnownColor.PeachPuff] = unchecked((int)0xFFFFDAB9);
            values[(int)KnownColor.Peru] = unchecked((int)0xFFCD853F);
            values[(int)KnownColor.Pink] = unchecked((int)0xFFFFC0CB);
            values[(int)KnownColor.Plum] = unchecked((int)0xFFDDA0DD);
            values[(int)KnownColor.PowderBlue] = unchecked((int)0xFFB0E0E6);
            values[(int)KnownColor.Purple] = unchecked((int)0xFF800080);
            values[(int)KnownColor.Red] = unchecked((int)0xFFFF0000);
            values[(int)KnownColor.RosyBrown] = unchecked((int)0xFFBC8F8F);
            values[(int)KnownColor.RoyalBlue] = unchecked((int)0xFF4169E1);
            values[(int)KnownColor.SaddleBrown] = unchecked((int)0xFF8B4513);
            values[(int)KnownColor.Salmon] = unchecked((int)0xFFFA8072);
            values[(int)KnownColor.SandyBrown] = unchecked((int)0xFFF4A460);
            values[(int)KnownColor.SeaGreen] = unchecked((int)0xFF2E8B57);
            values[(int)KnownColor.SeaShell] = unchecked((int)0xFFFFF5EE);
            values[(int)KnownColor.Sienna] = unchecked((int)0xFFA0522D);
            values[(int)KnownColor.Silver] = unchecked((int)0xFFC0C0C0);
            values[(int)KnownColor.SkyBlue] = unchecked((int)0xFF87CEEB);
            values[(int)KnownColor.SlateBlue] = unchecked((int)0xFF6A5ACD);
            values[(int)KnownColor.SlateGray] = unchecked((int)0xFF708090);
            values[(int)KnownColor.Snow] = unchecked((int)0xFFFFFAFA);
            values[(int)KnownColor.SpringGreen] = unchecked((int)0xFF00FF7F);
            values[(int)KnownColor.SteelBlue] = unchecked((int)0xFF4682B4);
            values[(int)KnownColor.Tan] = unchecked((int)0xFFD2B48C);
            values[(int)KnownColor.Teal] = unchecked((int)0xFF008080);
            values[(int)KnownColor.Thistle] = unchecked((int)0xFFD8BFD8);
            values[(int)KnownColor.Tomato] = unchecked((int)0xFFFF6347);
            values[(int)KnownColor.Turquoise] = unchecked((int)0xFF40E0D0);
            values[(int)KnownColor.Violet] = unchecked((int)0xFFEE82EE);
            values[(int)KnownColor.Wheat] = unchecked((int)0xFFF5DEB3);
            values[(int)KnownColor.White] = unchecked((int)0xFFFFFFFF);
            values[(int)KnownColor.WhiteSmoke] = unchecked((int)0xFFF5F5F5);
            values[(int)KnownColor.Yellow] = unchecked((int)0xFFFFFF00);
            values[(int)KnownColor.YellowGreen] = unchecked((int)0xFF9ACD32);
            colorTable = values;
        }

        private static void EnsureColorNameTable() {
            // no need to lock... worse case is a double create of the table...
            //
            if (colorNameTable == null) {
                InitColorNameTable();
            }
        }
        
        private static void InitColorNameTable() {
            string[] values = new string[((int)KnownColor.YellowGreen) + 1];

            // just consts...
            //
            values[(int)KnownColor.ActiveBorder] = "ActiveBorder";
            values[(int)KnownColor.ActiveCaption] = "ActiveCaption";
            values[(int)KnownColor.ActiveCaptionText] = "ActiveCaptionText";
            values[(int)KnownColor.AppWorkspace] = "AppWorkspace";
            values[(int)KnownColor.Control] = "Control";
            values[(int)KnownColor.ControlDark] = "ControlDark";
            values[(int)KnownColor.ControlDarkDark] = "ControlDarkDark";
            values[(int)KnownColor.ControlLight] = "ControlLight";
            values[(int)KnownColor.ControlLightLight] = "ControlLightLight";
            values[(int)KnownColor.ControlText] = "ControlText";
            values[(int)KnownColor.Desktop] = "Desktop";
            values[(int)KnownColor.GrayText] = "GrayText";
            values[(int)KnownColor.Highlight] = "Highlight";
            values[(int)KnownColor.HighlightText] = "HighlightText";
            values[(int)KnownColor.HotTrack] = "HotTrack";
            values[(int)KnownColor.InactiveBorder] = "InactiveBorder";
            values[(int)KnownColor.InactiveCaption] = "InactiveCaption";
            values[(int)KnownColor.InactiveCaptionText] = "InactiveCaptionText";
            values[(int)KnownColor.Info] = "Info";
            values[(int)KnownColor.InfoText] = "InfoText";
            values[(int)KnownColor.Menu] = "Menu";
            values[(int)KnownColor.MenuText] = "MenuText";
            values[(int)KnownColor.ScrollBar] = "ScrollBar";
            values[(int)KnownColor.Window] = "Window";
            values[(int)KnownColor.WindowFrame] = "WindowFrame";
            values[(int)KnownColor.WindowText] = "WindowText";
            
            values[(int)KnownColor.Transparent] = "Transparent";
            values[(int)KnownColor.AliceBlue] = "AliceBlue";
            values[(int)KnownColor.AntiqueWhite] = "AntiqueWhite";
            values[(int)KnownColor.Aqua] = "Aqua";
            values[(int)KnownColor.Aquamarine] = "Aquamarine";
            values[(int)KnownColor.Azure] = "Azure";
            values[(int)KnownColor.Beige] = "Beige";
            values[(int)KnownColor.Bisque] = "Bisque";
            values[(int)KnownColor.Black] = "Black";
            values[(int)KnownColor.BlanchedAlmond] = "BlanchedAlmond";
            values[(int)KnownColor.Blue] = "Blue";
            values[(int)KnownColor.BlueViolet] = "BlueViolet";
            values[(int)KnownColor.Brown] = "Brown";
            values[(int)KnownColor.BurlyWood] = "BurlyWood";
            values[(int)KnownColor.CadetBlue] = "CadetBlue";
            values[(int)KnownColor.Chartreuse] = "Chartreuse";
            values[(int)KnownColor.Chocolate] = "Chocolate";
            values[(int)KnownColor.Coral] = "Coral";
            values[(int)KnownColor.CornflowerBlue] = "CornflowerBlue";
            values[(int)KnownColor.Cornsilk] = "Cornsilk";
            values[(int)KnownColor.Crimson] = "Crimson";
            values[(int)KnownColor.Cyan] = "Cyan";
            values[(int)KnownColor.DarkBlue] = "DarkBlue";
            values[(int)KnownColor.DarkCyan] = "DarkCyan";
            values[(int)KnownColor.DarkGoldenrod] = "DarkGoldenrod";
            values[(int)KnownColor.DarkGray] = "DarkGray";
            values[(int)KnownColor.DarkGreen] = "DarkGreen";
            values[(int)KnownColor.DarkKhaki] = "DarkKhaki";
            values[(int)KnownColor.DarkMagenta] = "DarkMagenta";
            values[(int)KnownColor.DarkOliveGreen] = "DarkOliveGreen";
            values[(int)KnownColor.DarkOrange] = "DarkOrange";
            values[(int)KnownColor.DarkOrchid] = "DarkOrchid";
            values[(int)KnownColor.DarkRed] = "DarkRed";
            values[(int)KnownColor.DarkSalmon] = "DarkSalmon";
            values[(int)KnownColor.DarkSeaGreen] = "DarkSeaGreen";
            values[(int)KnownColor.DarkSlateBlue] = "DarkSlateBlue";
            values[(int)KnownColor.DarkSlateGray] = "DarkSlateGray";
            values[(int)KnownColor.DarkTurquoise] = "DarkTurquoise";
            values[(int)KnownColor.DarkViolet] = "DarkViolet";
            values[(int)KnownColor.DeepPink] = "DeepPink";
            values[(int)KnownColor.DeepSkyBlue] = "DeepSkyBlue";
            values[(int)KnownColor.DimGray] = "DimGray";
            values[(int)KnownColor.DodgerBlue] = "DodgerBlue";
            values[(int)KnownColor.Firebrick] = "Firebrick";
            values[(int)KnownColor.FloralWhite] = "FloralWhite";
            values[(int)KnownColor.ForestGreen] = "ForestGreen";
            values[(int)KnownColor.Fuchsia] = "Fuchsia";
            values[(int)KnownColor.Gainsboro] = "Gainsboro";
            values[(int)KnownColor.GhostWhite] = "GhostWhite";
            values[(int)KnownColor.Gold] = "Gold";
            values[(int)KnownColor.Goldenrod] = "Goldenrod";
            values[(int)KnownColor.Gray] = "Gray";
            values[(int)KnownColor.Green] = "Green";
            values[(int)KnownColor.GreenYellow] = "GreenYellow";
            values[(int)KnownColor.Honeydew] = "Honeydew";
            values[(int)KnownColor.HotPink] = "HotPink";
            values[(int)KnownColor.IndianRed] = "IndianRed";
            values[(int)KnownColor.Indigo] = "Indigo";
            values[(int)KnownColor.Ivory] = "Ivory";
            values[(int)KnownColor.Khaki] = "Khaki";
            values[(int)KnownColor.Lavender] = "Lavender";
            values[(int)KnownColor.LavenderBlush] = "LavenderBlush";
            values[(int)KnownColor.LawnGreen] = "LawnGreen";
            values[(int)KnownColor.LemonChiffon] = "LemonChiffon";
            values[(int)KnownColor.LightBlue] = "LightBlue";
            values[(int)KnownColor.LightCoral] = "LightCoral";
            values[(int)KnownColor.LightCyan] = "LightCyan";
            values[(int)KnownColor.LightGoldenrodYellow] = "LightGoldenrodYellow";
            values[(int)KnownColor.LightGray] = "LightGray";
            values[(int)KnownColor.LightGreen] = "LightGreen";
            values[(int)KnownColor.LightPink] = "LightPink";
            values[(int)KnownColor.LightSalmon] = "LightSalmon";
            values[(int)KnownColor.LightSeaGreen] = "LightSeaGreen";
            values[(int)KnownColor.LightSkyBlue] = "LightSkyBlue";
            values[(int)KnownColor.LightSlateGray] = "LightSlateGray";
            values[(int)KnownColor.LightSteelBlue] = "LightSteelBlue";
            values[(int)KnownColor.LightYellow] = "LightYellow";
            values[(int)KnownColor.Lime] = "Lime";
            values[(int)KnownColor.LimeGreen] = "LimeGreen";
            values[(int)KnownColor.Linen] = "Linen";
            values[(int)KnownColor.Magenta] = "Magenta";
            values[(int)KnownColor.Maroon] = "Maroon";
            values[(int)KnownColor.MediumAquamarine] = "MediumAquamarine";
            values[(int)KnownColor.MediumBlue] = "MediumBlue";
            values[(int)KnownColor.MediumOrchid] = "MediumOrchid";
            values[(int)KnownColor.MediumPurple] = "MediumPurple";
            values[(int)KnownColor.MediumSeaGreen] = "MediumSeaGreen";
            values[(int)KnownColor.MediumSlateBlue] = "MediumSlateBlue";
            values[(int)KnownColor.MediumSpringGreen] = "MediumSpringGreen";
            values[(int)KnownColor.MediumTurquoise] = "MediumTurquoise";
            values[(int)KnownColor.MediumVioletRed] = "MediumVioletRed";
            values[(int)KnownColor.MidnightBlue] = "MidnightBlue";
            values[(int)KnownColor.MintCream] = "MintCream";
            values[(int)KnownColor.MistyRose] = "MistyRose";
            values[(int)KnownColor.Moccasin] = "Moccasin";
            values[(int)KnownColor.NavajoWhite] = "NavajoWhite";
            values[(int)KnownColor.Navy] = "Navy";
            values[(int)KnownColor.OldLace] = "OldLace";
            values[(int)KnownColor.Olive] = "Olive";
            values[(int)KnownColor.OliveDrab] = "OliveDrab";
            values[(int)KnownColor.Orange] = "Orange";
            values[(int)KnownColor.OrangeRed] = "OrangeRed";
            values[(int)KnownColor.Orchid] = "Orchid";
            values[(int)KnownColor.PaleGoldenrod] = "PaleGoldenrod";
            values[(int)KnownColor.PaleGreen] = "PaleGreen";
            values[(int)KnownColor.PaleTurquoise] = "PaleTurquoise";
            values[(int)KnownColor.PaleVioletRed] = "PaleVioletRed";
            values[(int)KnownColor.PapayaWhip] = "PapayaWhip";
            values[(int)KnownColor.PeachPuff] = "PeachPuff";
            values[(int)KnownColor.Peru] = "Peru";
            values[(int)KnownColor.Pink] = "Pink";
            values[(int)KnownColor.Plum] = "Plum";
            values[(int)KnownColor.PowderBlue] = "PowderBlue";
            values[(int)KnownColor.Purple] = "Purple";
            values[(int)KnownColor.Red] = "Red";
            values[(int)KnownColor.RosyBrown] = "RosyBrown";
            values[(int)KnownColor.RoyalBlue] = "RoyalBlue";
            values[(int)KnownColor.SaddleBrown] = "SaddleBrown";
            values[(int)KnownColor.Salmon] = "Salmon";
            values[(int)KnownColor.SandyBrown] = "SandyBrown";
            values[(int)KnownColor.SeaGreen] = "SeaGreen";
            values[(int)KnownColor.SeaShell] = "SeaShell";
            values[(int)KnownColor.Sienna] = "Sienna";
            values[(int)KnownColor.Silver] = "Silver";
            values[(int)KnownColor.SkyBlue] = "SkyBlue";
            values[(int)KnownColor.SlateBlue] = "SlateBlue";
            values[(int)KnownColor.SlateGray] = "SlateGray";
            values[(int)KnownColor.Snow] = "Snow";
            values[(int)KnownColor.SpringGreen] = "SpringGreen";
            values[(int)KnownColor.SteelBlue] = "SteelBlue";
            values[(int)KnownColor.Tan] = "Tan";
            values[(int)KnownColor.Teal] = "Teal";
            values[(int)KnownColor.Thistle] = "Thistle";
            values[(int)KnownColor.Tomato] = "Tomato";
            values[(int)KnownColor.Turquoise] = "Turquoise";
            values[(int)KnownColor.Violet] = "Violet";
            values[(int)KnownColor.Wheat] = "Wheat";
            values[(int)KnownColor.White] = "White";
            values[(int)KnownColor.WhiteSmoke] = "WhiteSmoke";
            values[(int)KnownColor.Yellow] = "Yellow";
            values[(int)KnownColor.YellowGreen] = "YellowGreen";
            colorNameTable = values;
        }
        
        public static int KnownColorToArgb(KnownColor color) {
            EnsureColorTable();
            if (color <= KnownColor.YellowGreen) {
                return colorTable[(int)color];
            }
            else {
                return 0;
            }
        }

        public static string KnownColorToName(KnownColor color) {
            EnsureColorNameTable();
            if (color <= KnownColor.YellowGreen) {
                return colorNameTable[(int)color];
            }
            else {
                return null;
            }
        }
        
        private static int SystemColorToArgb(int index) {
            return FromWin32Value(SafeNativeMethods.GetSysColor(index));
        }

        private static int Encode(int alpha, int red, int green, int blue) {
            return red << RedShift | green << GreenShift | blue << BlueShift | alpha << AlphaShift;
        }

        private static int FromWin32Value(int value) {
            return Encode(255,
                          (value >> Win32RedShift) & 0xFF,
                          (value >> Win32GreenShift) & 0xFF,
                          (value >> Win32BlueShift) & 0xFF);
        }
        
        private static void OnUserPreferenceChanging(object sender, UserPreferenceChangingEventArgs e) {
            if (e.Category == UserPreferenceCategory.Color && colorTable != null) {
                UpdateSystemColors(colorTable);
            }
        }

        private static void UpdateSystemColors(int[] colorTable) {
            colorTable[(int)KnownColor.ActiveBorder] = SystemColorToArgb((int)Win32SystemColors.ActiveBorder);
            colorTable[(int)KnownColor.ActiveCaption] = SystemColorToArgb((int)Win32SystemColors.ActiveCaption);
            colorTable[(int)KnownColor.ActiveCaptionText] = SystemColorToArgb((int)Win32SystemColors.ActiveCaptionText);
            colorTable[(int)KnownColor.AppWorkspace] = SystemColorToArgb((int)Win32SystemColors.AppWorkspace);
            colorTable[(int)KnownColor.Control] = SystemColorToArgb((int)Win32SystemColors.Control);
            colorTable[(int)KnownColor.ControlDark] = SystemColorToArgb((int)Win32SystemColors.ControlDark);
            colorTable[(int)KnownColor.ControlDarkDark] = SystemColorToArgb((int)Win32SystemColors.ControlDarkDark);
            colorTable[(int)KnownColor.ControlLight] = SystemColorToArgb((int)Win32SystemColors.ControlLight);
            colorTable[(int)KnownColor.ControlLightLight] = SystemColorToArgb((int)Win32SystemColors.ControlLightLight);
            colorTable[(int)KnownColor.ControlText] = SystemColorToArgb((int)Win32SystemColors.ControlText);
            colorTable[(int)KnownColor.Desktop] = SystemColorToArgb((int)Win32SystemColors.Desktop);
            colorTable[(int)KnownColor.GrayText] = SystemColorToArgb((int)Win32SystemColors.GrayText);
            colorTable[(int)KnownColor.Highlight] = SystemColorToArgb((int)Win32SystemColors.Highlight);
            colorTable[(int)KnownColor.HighlightText] = SystemColorToArgb((int)Win32SystemColors.HighlightText);
            colorTable[(int)KnownColor.HotTrack] = SystemColorToArgb((int)Win32SystemColors.HotTrack);
            colorTable[(int)KnownColor.InactiveBorder] = SystemColorToArgb((int)Win32SystemColors.InactiveBorder);
            colorTable[(int)KnownColor.InactiveCaption] = SystemColorToArgb((int)Win32SystemColors.InactiveCaption);
            colorTable[(int)KnownColor.InactiveCaptionText] = SystemColorToArgb((int)Win32SystemColors.InactiveCaptionText);
            colorTable[(int)KnownColor.Info] = SystemColorToArgb((int)Win32SystemColors.Info);
            colorTable[(int)KnownColor.InfoText] = SystemColorToArgb((int)Win32SystemColors.InfoText);
            colorTable[(int)KnownColor.Menu] = SystemColorToArgb((int)Win32SystemColors.Menu);
            colorTable[(int)KnownColor.MenuText] = SystemColorToArgb((int)Win32SystemColors.MenuText);
            colorTable[(int)KnownColor.ScrollBar] = SystemColorToArgb((int)Win32SystemColors.ScrollBar);
            colorTable[(int)KnownColor.Window] = SystemColorToArgb((int)Win32SystemColors.Window);
            colorTable[(int)KnownColor.WindowFrame] = SystemColorToArgb((int)Win32SystemColors.WindowFrame);
            colorTable[(int)KnownColor.WindowText] = SystemColorToArgb((int)Win32SystemColors.WindowText);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\propertyiteminternal.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyItemInternal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PropertyItem.cs
*
* Abstract:
*
*   Native GDI+ PropertyItem structure.
*
* Revision History:
*
*   3/3/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System;    
    using System.Drawing;

    // sdkinc\imaging.h
    [StructLayout(LayoutKind.Sequential)]
    internal sealed class PropertyItemInternal : IDisposable {
        public int id = 0;
        public int len = 0;
        public short type = 0;
        public IntPtr value = IntPtr.Zero;

        internal PropertyItemInternal() {
        }

        void IDisposable.Dispose() {
            if (value != IntPtr.Zero)
                Marshal.FreeHGlobal(value);
            value = IntPtr.Zero;
        }

        internal static PropertyItemInternal ConvertFromPropertyItem(PropertyItem propItem) {
            PropertyItemInternal propItemInternal = new PropertyItemInternal();
            propItemInternal.id = propItem.Id;
            propItemInternal.len = propItem.Len;
            propItemInternal.type = propItem.Type;

            byte[] propItemValue = propItem.Value;
            if (propItemValue != null) {
                propItemInternal.value = Marshal.AllocHGlobal(propItemValue.Length);
                Marshal.Copy(propItemValue, 0, propItemInternal.value, propItemValue.Length);
            }

            return propItemInternal;
        }

        internal static PropertyItem[] ConvertFromMemory(IntPtr propdata, int count) {
            PropertyItem[] props = new PropertyItem[count];

            for (int i=0; i<count; i++) {
                PropertyItemInternal propcopy = (PropertyItemInternal) UnsafeNativeMethods.PtrToStructure(propdata,
                                                  typeof(PropertyItemInternal));

                props[i] = new PropertyItem();
                props[i].Id = propcopy.id;
                props[i].Len = propcopy.len;
                props[i].Type = propcopy.type;
                props[i].Value = propcopy.Value;

                propdata = (IntPtr)((long)propdata + (int)Marshal.SizeOf(typeof(PropertyItemInternal)));
            }

            return props;
        }

        public byte[] Value {
            get {
                byte[] bytes = new byte[len];

                Marshal.Copy(value,
                             bytes, 
                             0, 
                             (int)len);
                return bytes;
            }                              
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\rectangle.cs ===
//------------------------------------------------------------------------------
// <copyright file="Rectangle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;


    /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Stores the location and size of a rectangular region. For
    ///       more advanced region functions use a <see cref='System.Drawing.Region'/>
    ///       object.
    ///    </para>
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(RectangleConverter)),
    ]
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(true)]
    public struct Rectangle {

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Empty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Stores the location and size of a rectangular region. For
        ///       more advanced region functions use a <see cref='System.Drawing.Region'/>
        ///       object.
        ///    </para>
        /// </devdoc>
        public static readonly Rectangle Empty = new Rectangle();

        private int x;
        private int y;
        private int width;
        private int height;

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Rectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Rectangle'/>
        ///       class with the specified location and size.
        ///    </para>
        /// </devdoc>
        public Rectangle(int x, int y, int width, int height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Rectangle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the Rectangle class with the specified location
        ///       and size.
        ///    </para>
        /// </devdoc>
        public Rectangle(Point location, Size size) {
            this.x = location.X;
            this.y = location.Y;
            this.width = size.Width;
            this.height = size.Height;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.FromLTRB"]/*' />
        /// <devdoc>
        ///    Creates a new <see cref='System.Drawing.Rectangle'/> with
        ///    the specified location and size.
        /// </devdoc>
        // !! Not in C++ version
        public static Rectangle FromLTRB(int left, int top, int right, int bottom) {
            return new Rectangle(left,
                                 top,
                                 right - left,
                                 bottom - top);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Location"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the coordinates of the
        ///       upper-left corner of the rectangular region represented by this <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public Point Location {
            get {
                return new Point(X, Y);
            }
            set {
                X = value.X;
                Y = value.Y;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Size"]/*' />
        /// <devdoc>
        ///    Gets or sets the size of this <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        [Browsable(false)]
        public Size Size {
            get {
                return new Size(Width, Height);
            }
            set {
                this.Width = value.Width;
                this.Height = value.Height;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.X"]/*' />
        /// <devdoc>
        ///    Gets or sets the x-coordinate of the
        ///    upper-left corner of the rectangular region defined by this <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public int X {
            get {
                return x;
            }
            set {
                x = value;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Y"]/*' />
        /// <devdoc>
        ///    Gets or sets the y-coordinate of the
        ///    upper-left corner of the rectangular region defined by this <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
            set {
                y = value;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Width"]/*' />
        /// <devdoc>
        ///    Gets or sets the width of the rectangular
        ///    region defined by this <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public int Width {
            get {
                return width;
            }
            set {
                width = value;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Height"]/*' />
        /// <devdoc>
        ///    Gets or sets the width of the rectangular
        ///    region defined by this <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public int Height {
            get {
                return height;
            }
            set {
                height = value;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the upper-left corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public int Left {
            get {
                return X;
            }
        }
        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the upper-left corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public int Top {
            get {       
                return Y;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the lower-right corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public int Right {
            get {
                return X + Width;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the lower-right corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public int Bottom {
            get {
                return Y + Height;
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether this <see cref='System.Drawing.Rectangle'/> has a <see cref='System.Drawing.Rectangle.Width'/>
        ///       or a <see cref='System.Drawing.Rectangle.Height'/> of 0.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return height == 0 && width == 0 && x == 0 && y == 0;
                // C++ uses this definition:
                // return(Width <= 0 )|| (Height <= 0);
            }
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether <paramref name="obj"/> is a <see cref='System.Drawing.Rectangle'/> with
        ///       the same location and size of this Rectangle.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is Rectangle))
                return false;

            Rectangle comp = (Rectangle)obj;

            return(comp.X == this.X) &&
            (comp.Y == this.Y) &&
            (comp.Width == this.Width) &&
            (comp.Height == this.Height);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.Rectangle'/>
        ///       objects have equal location and size.
        ///    </para>
        /// </devdoc>
        public static bool operator ==(Rectangle left, Rectangle right) {
            return (left.X == right.X
                    && left.Y == right.Y
                    && left.Width == right.Width
                    && left.Height == right.Height);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.Rectangle'/>
        ///       objects differ in location or size.
        ///    </para>
        /// </devdoc>
        public static bool operator !=(Rectangle left, Rectangle right) {
            return !(left == right);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Ceiling"]/*' />
        /// <devdoc>
        ///   Converts a RectangleF to a Rectangle by performing a ceiling operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Rectangle Ceiling(RectangleF value) {
            return new Rectangle((int)Math.Ceiling(value.X), 
                                 (int)Math.Ceiling(value.Y), 
                                 (int)Math.Ceiling(value.Width), 
                                 (int)Math.Ceiling(value.Height));
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Truncate"]/*' />
        /// <devdoc>
        ///   Converts a RectangleF to a Rectangle by performing a truncate operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Rectangle Truncate(RectangleF value) {
            return new Rectangle((int)value.X, 
                                 (int)value.Y, 
                                 (int)value.Width, 
                                 (int)value.Height);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Round"]/*' />
        /// <devdoc>
        ///   Converts a RectangleF to a Rectangle by performing a round operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Rectangle Round(RectangleF value) {
            return new Rectangle((int)Math.Round(value.X), 
                                 (int)Math.Round(value.Y), 
                                 (int)Math.Round(value.Width), 
                                 (int)Math.Round(value.Height));
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the specfied point is contained within the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(int x, int y) {
            return this.X <= x &&
            x < this.X + this.Width &&
            this.Y <= y &&
            y < this.Y + this.Height;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Contains1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the specfied point is contained within the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(Point pt) {
            return Contains(pt.X, pt.Y);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Contains2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the rectangular region represented by
        ///    <paramref name="rect"/> is entirely contained within the rectangular region represented by 
        ///       this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(Rectangle rect) {
            return(this.X <= rect.X) &&
            ((rect.X + rect.Width) <= (this.X + this.Width)) &&
            (this.Y <= rect.Y) &&
            ((rect.Y + rect.Height) <= (this.Y + this.Height));
        }

        // !! Not in C++ version
        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return(int)((UInt32)X ^
                        (((UInt32)Y << 13) | ((UInt32)Y >> 19)) ^
                        (((UInt32)Width << 26) | ((UInt32)Width >>  6)) ^
                        (((UInt32)Height <<  7) | ((UInt32)Height >> 25)));
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Inflate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inflates this <see cref='System.Drawing.Rectangle'/>
        ///       by the specified amount.
        ///    </para>
        /// </devdoc>
        public void Inflate(int width, int height) {
            this.X -= width;
            this.Y -= height;
            this.Width += 2*width;
            this.Height += 2*height;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Inflate1"]/*' />
        /// <devdoc>
        ///    Inflates this <see cref='System.Drawing.Rectangle'/> by the specified amount.
        /// </devdoc>
        public void Inflate(Size size) {
                
            Inflate(size.Width, size.Height);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Inflate2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Rectangle'/>
        ///       that is inflated by the specified amount.
        ///    </para>
        /// </devdoc>
        // !! Not in C++
        public static Rectangle Inflate(Rectangle rect, int x, int y) {
            Rectangle r = rect;
            r.Inflate(x, y);
            return r;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Intersect"]/*' />
        /// <devdoc> Creates a Rectangle that represents the intersection between this Rectangle and rect.
        /// </devdoc>
        public void Intersect(Rectangle rect) {
            Rectangle result = Rectangle.Intersect(rect, this);

            this.X = result.X;
            this.Y = result.Y;
            this.Width = result.Width;
            this.Height = result.Height;
        }
        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Intersect1"]/*' />
        /// <devdoc>
        ///    Creates a rectangle that represents the intersetion between a and
        ///    b. If there is no intersection, null is returned.
        /// </devdoc>
        public static Rectangle Intersect(Rectangle a, Rectangle b) {
            int x1 = Math.Max(a.X, b.X);
            int x2 = Math.Min(a.X + a.Width, b.X + b.Width);
            int y1 = Math.Max(a.Y, b.Y);
            int y2 = Math.Min(a.Y + a.Height, b.Y + b.Height);

            if (x2 >= x1
                && y2 >= y1) {

                return new Rectangle(x1, y1, x2 - x1, y2 - y1);
            }
            return Rectangle.Empty;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.IntersectsWith"]/*' />
        /// <devdoc>
        ///     Determines if this rectangle intersets with rect.
        /// </devdoc>
        public bool IntersectsWith(Rectangle rect) {
            return(rect.X < this.X + this.Width) && 
            (this.X < (rect.X + rect.Width)) &&
            (rect.Y < this.Y + this.Height) &&
            (this.Y < rect.Y + rect.Height);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Union"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a rectangle that represents the union between a and
        ///       b.
        ///    </para>
        /// </devdoc>
        public static Rectangle Union(Rectangle a, Rectangle b) {
            int x1 = Math.Min(a.X, b.X);
            int x2 = Math.Max(a.X + a.Width, b.X + b.Width);
            int y1 = Math.Min(a.Y, b.Y);
            int y2 = Math.Max(a.Y + a.Height, b.Y + b.Height);

            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Offset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adjusts the location of this rectangle by the specified amount.
        ///    </para>
        /// </devdoc>
        public void Offset(Point pos) {
            Offset(pos.X, pos.Y);
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.Offset1"]/*' />
        /// <devdoc>
        ///    Adjusts the location of this rectangle by the specified amount.
        /// </devdoc>
        public void Offset(int x, int y) {
            this.X += x;
            this.Y += y;
        }

        /// <include file='doc\Rectangle.uex' path='docs/doc[@for="Rectangle.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the attributes of this <see cref='System.Drawing.Rectangle'/> to a
        ///       human readable string.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "{X=" + X.ToString() + ",Y=" + Y.ToString() +
            ",Width=" + Width.ToString() +
            ",Height=" + Height.ToString() + "}";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\pointconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PointConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter"]/*' />
    /// <devdoc>
    ///      PointConverter is a class that can be used to convert
    ///      Point from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class PointConverter : TypeConverter {
    
        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
            
                string text = ((string)value).Trim();
            
                if (text.Length == 0) {
                    return null;
                }
                else {
                
                    // Parse 2 integer values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                    
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});
                    int[] values = new int[tokens.Length];
                    TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                    for (int i = 0; i < values.Length; i++) {
                        values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                    }
                    
                    if (values.Length == 2) {
                        return new Point(values[0], values[1]);
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  text,
                                                                  "x, y"));
                    }
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is Point) {
                Point pt = (Point)value;
                
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }
                string sep = culture.TextInfo.ListSeparator + " ";
                TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                string[] args = new string[2];
                int nArg = 0;
                
                args[nArg++] = intConverter.ConvertToString(context, culture, pt.X);
                args[nArg++] = intConverter.ConvertToString(context, culture, pt.Y);
                
                return string.Join(sep, args);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Point) {
                Point pt = (Point)value;

                ConstructorInfo ctor = typeof(Point).GetConstructor(new Type[] {typeof(int), typeof(int)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {pt.X, pt.Y});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new Point((int)propertyValues["X"],
                             (int)propertyValues["Y"]);
        }

        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
       
        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(Point), attributes);
            return props.Sort(new string[] {"X", "Y"});
        }

       
        /// <include file='doc\PointConverter.uex' path='docs/doc[@for="PointConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\point.cs ===
//------------------------------------------------------------------------------
// <copyright file="Point.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Internal;

    /// <include file='doc\Point.uex' path='docs/doc[@for="Point"]/*' />
    /// <devdoc>
    ///    Represents an ordered pair of x and y coordinates that
    ///    define a point in a two-dimensional plane.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(PointConverter)),
    ]
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(true)]
    public struct Point {

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Empty"]/*' />
        /// <devdoc>
        ///    Creates a new instance of the <see cref='System.Drawing.Point'/> class
        ///    with member data left uninitialized.
        /// </devdoc>
        public static readonly Point Empty = new Point();

        private int x;
        private int y;

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Point"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Point'/> class
        ///    with the specified coordinates.
        /// </devdoc>
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Point1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Point'/> class
        ///       from a <see cref='System.Drawing.Size'/> .
        ///    </para>
        /// </devdoc>
        public Point(Size sz) {
            this.x = sz.Width;
            this.y = sz.Height;
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Point2"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the Point class using
        ///    coordinates specified by an integer value.
        /// </devdoc>
        public Point(int dw) {
            this.x = (short)LOWORD(dw);
            this.y = (short)HIWORD(dw);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.Point'/> is empty.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return x == 0 && y == 0;
            }
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.X"]/*' />
        /// <devdoc>
        ///    Gets the x-coordinate of this <see cref='System.Drawing.Point'/>.
        /// </devdoc>
        public int X {
            get {
                return x;
            }
            set {
                x = value;
            }
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of this <see cref='System.Drawing.Point'/>.
        ///    </para>
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
            set {
                y = value;
            }
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operatorPointF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.PointF'/> with the coordinates of the specified
        ///    <see cref='System.Drawing.Point'/> 
        ///    .
        /// </para>
        /// </devdoc>
        public static implicit operator PointF(Point p) {
            return new PointF(p.X, p.Y);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operatorSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Size'/> with the coordinates of the specified <see cref='System.Drawing.Point'/> .
        ///    </para>
        /// </devdoc>
        public static explicit operator Size(Point p) {
            return new Size(p.X, p.Y);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operator+"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates a <see cref='System.Drawing.Point'/> by a given <see cref='System.Drawing.Size'/> .
        ///    </para>
        /// </devdoc>
        public static Point operator +(Point pt, Size sz) {
            return new Point(pt.X + sz.Width, pt.Y + sz.Height);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operator-"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates a <see cref='System.Drawing.Point'/> by the negative of a given <see cref='System.Drawing.Size'/> .
        ///    </para>
        /// </devdoc>
        public static Point operator -(Point pt, Size sz) {
            return new Point(pt.X - sz.Width, pt.Y - sz.Height);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two <see cref='System.Drawing.Point'/> objects. The result specifies
        ///       whether the values of the <see cref='System.Drawing.Point.X'/> and <see cref='System.Drawing.Point.Y'/> properties of the two <see cref='System.Drawing.Point'/>
        ///       objects are equal.
        ///    </para>
        /// </devdoc>
        public static bool operator ==(Point left, Point right) {
            return left.X == right.X && left.Y == right.Y;
        }
        
        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two <see cref='System.Drawing.Point'/> objects. The result specifies whether the values
        ///       of the <see cref='System.Drawing.Point.X'/> or <see cref='System.Drawing.Point.Y'/> properties of the two
        ///    <see cref='System.Drawing.Point'/> 
        ///    objects are unequal.
        /// </para>
        /// </devdoc>
        public static bool operator !=(Point left, Point right) {
            return !(left == right);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Ceiling"]/*' />
        /// <devdoc>
        ///   Converts a PointF to a Point by performing a ceiling operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Point Ceiling(PointF value) {
            return new Point((int)Math.Ceiling(value.X), (int)Math.Ceiling(value.Y));
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Truncate"]/*' />
        /// <devdoc>
        ///   Converts a PointF to a Point by performing a truncate operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Point Truncate(PointF value) {
            return new Point((int)value.X, (int)value.Y);
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Round"]/*' />
        /// <devdoc>
        ///   Converts a PointF to a Point by performing a round operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Point Round(PointF value) {
            return new Point((int)Math.Round(value.X), (int)Math.Round(value.Y));
        }


        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies whether this <see cref='System.Drawing.Point'/> contains
        ///       the same coordinates as the specified <see cref='System.Object'/>.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is Point)) return false;
            Point comp = (Point)obj;
            // Note value types can't have derived classes, so we don't need 
            // to check the types of the objects here.  -- BrianGru, 2/21/2001
            return comp.X == this.X && comp.Y == this.Y;
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a hash code.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return x ^ y;
        }
        
        /**
         * Offset the current Point object by the given amount
         */
        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.Offset"]/*' />
        /// <devdoc>
        ///    Translates this <see cref='System.Drawing.Point'/> by the specified amount.
        /// </devdoc>
        public void Offset(int dx, int dy) {
            X += dx;
            Y += dy;
        }

        /// <include file='doc\Point.uex' path='docs/doc[@for="Point.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts this <see cref='System.Drawing.Point'/>
        ///       to a human readable
        ///       string.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "{X=" + X.ToString() + ",Y=" + Y.ToString() + "}";
        }

        private static int HIWORD(int n) {
            return(n >> 16) & 0xffff;
        }

        private static int LOWORD(int n) {
            return n & 0xffff;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\rectangleconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="RectangleConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter"]/*' />
    /// <devdoc>
    ///      RectangleConverter is a class that can be used to convert
    ///      rectangles from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class RectangleConverter : TypeConverter {
    
        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
            
                string text = ((string)value).Trim();
            
                if (text.Length == 0) {
                    return null;
                }
                else {
                
                    // Parse 4 integer values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }                                        
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});
                    int[] values = new int[tokens.Length];
                    TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                    for (int i = 0; i < values.Length; i++) {
                        values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                    }
                    
                    if (values.Length == 4) {
                        return new Rectangle(values[0], values[1], values[2], values[3]);
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  "text",
                                                                  text,
                                                                  "x, y, width, height"));
                    }
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is Rectangle) {
                Rectangle rect = (Rectangle)value;
                
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }                                        
                string sep = culture.TextInfo.ListSeparator + " ";
                TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                string[] args = new string[4];
                int nArg = 0;
                
                args[nArg++] = intConverter.ConvertToString(context, culture, rect.X);
                args[nArg++] = intConverter.ConvertToString(context, culture, rect.Y);
                args[nArg++] = intConverter.ConvertToString(context, culture, rect.Width);
                args[nArg++] = intConverter.ConvertToString(context, culture, rect.Height);
                
                return string.Join(sep, args);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Rectangle) {
                Rectangle rect = (Rectangle)value;
                ConstructorInfo ctor = typeof(Rectangle).GetConstructor(new Type[] {
                    typeof(int), typeof(int), typeof(int), typeof(int)});
                    
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        rect.X, rect.Y, rect.Width, rect.Height});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new Rectangle((int)propertyValues["X"],
                                 (int)propertyValues["Y"],
                                 (int)propertyValues["Width"],
                                 (int)propertyValues["Height"]);
        }

        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(Rectangle), attributes);
                return props.Sort(new string[] {"X", "Y", "Width", "Height"});
        }
       
        /// <include file='doc\RectangleConverter.uex' path='docs/doc[@for="RectangleConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\rotatefliptype.cs ===
//------------------------------------------------------------------------------
// <copyright file="RotateFlipType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RotateFlipType.cs
*
* Abstract:
*
*   Rotate / Flip type for image object
*
* Revision History:
*
*   11/66/2000 YungT
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System;

    /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType"]/*' />
    /// <devdoc>
    ///    Specifies the different patterns available 'RotateFlipType' objects.
    /// </devdoc>

    public enum RotateFlipType {
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.RotateNoneFlipNone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RotateNoneFlipNone = 0,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate90FlipNone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate90FlipNone   = 1,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate180FlipNone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate180FlipNone  = 2,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate270FlipNone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate270FlipNone  = 3,

        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.RotateNoneFlipX"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RotateNoneFlipX    = 4,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate90FlipX"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate90FlipX      = 5,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate180FlipX"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate180FlipX     = 6,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate270FlipX"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate270FlipX     = 7,

        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.RotateNoneFlipY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RotateNoneFlipY    = Rotate180FlipX,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate90FlipY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate90FlipY      = Rotate270FlipX,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate180FlipY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate180FlipY     = RotateNoneFlipX,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate270FlipY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate270FlipY     = Rotate90FlipX,

        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.RotateNoneFlipXY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RotateNoneFlipXY   = Rotate180FlipNone,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate90FlipXY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate90FlipXY     = Rotate270FlipNone,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate180FlipXY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate180FlipXY    = RotateNoneFlipNone,
        /// <include file='doc\RotateFlipType.uex' path='docs/doc[@for="RotateFlipType.Rotate270FlipXY"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Rotate270FlipXY    = Rotate90FlipNone
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\region.cs ===
//------------------------------------------------------------------------------
// <copyright file="Region.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Region.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ region objects
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Drawing2D;
    using System.Drawing;
    using System.Drawing.Internal;


    /**
     * Represent a Region object
     */
    /// <include file='doc\Region.uex' path='docs/doc[@for="Region"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Describes the interior of a graphics shape
    ///       composed of rectangles and paths.
    ///    </para>
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public sealed class Region : MarshalByRefObject, IDisposable {
#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif

        // A random integer to distinguish between the Region(int hrgn) and Region(int native, int ignored) constructors
        private const int NativeRegionOverload = 42;

        /**
         * Construct a new region object
         */
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Region"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Region'/> class.
        ///    </para>
        /// </devdoc>
        public Region() {
            IntPtr region = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateRegion(out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeRegion(region);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Region1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Region'/> class from the specified <see cref='System.Drawing.RectangleF'/> .
        ///    </para>
        /// </devdoc>
        public Region(RectangleF rect) {
            IntPtr region = IntPtr.Zero;

            GPRECTF gprectf = rect.ToGPRECTF();

            int status = SafeNativeMethods.GdipCreateRegionRect(ref gprectf, out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeRegion(region);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Region2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Region'/> class from the specified <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        public Region(Rectangle rect) {
            IntPtr region = IntPtr.Zero;

            GPRECT gprect = new GPRECT(rect);

            int status = SafeNativeMethods.GdipCreateRegionRectI(ref gprect, out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeRegion(region);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Region3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Region'/> class
        ///       with the specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public Region(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            IntPtr region = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateRegionPath(new HandleRef(path, path.nativePath), out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeRegion(region);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Region4"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Region'/> class
        ///    from the specified data.
        /// </devdoc>
        public Region(RegionData rgnData) {
            if (rgnData == null)
                throw new ArgumentNullException("regionData");
            IntPtr region = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateRegionRgnData(rgnData.Data,
                                                         rgnData.Data.Length, 
                                                         out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeRegion(region);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.FromHrgn"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Region'/> class
        ///    from the specified existing <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public static Region FromHrgn(IntPtr hrgn) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr region = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateRegionHrgn(new HandleRef(null, hrgn), out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Region(region, NativeRegionOverload);
        }

        // We need this ignored parameter to distinguish from the hrgn constructor
        internal Region(IntPtr nativeRegion, int ignored) {
            SetNativeRegion(nativeRegion);
        }

        private void SetNativeRegion(IntPtr nativeRegion) {
            if (nativeRegion == IntPtr.Zero)
                throw new ArgumentNullException("nativeRegion");

            this.nativeRegion = nativeRegion;
        }

        /**
         * Make a copy of the region object
         */
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy if this <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public Region Clone() {
            IntPtr region = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneRegion(new HandleRef(this, nativeRegion), out region);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Region(region,0);
        }

        /**
         * Dispose of resources associated with the
         */
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Cleans up Windows resources for this
        ///    <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeRegion != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif
            if (nativeRegion != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeleteRegion(new HandleRef(this, nativeRegion));
                nativeRegion = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        ~Region() {
            Dispose(false);
        }

        /*
         * Region operations
         */

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.MakeInfinite"]/*' />
        /// <devdoc>
        ///    Initializes this <see cref='System.Drawing.Region'/> to an
        ///    infinite interior.
        /// </devdoc>
        public void MakeInfinite() {
            int status = SafeNativeMethods.GdipSetInfinite(new HandleRef(this, nativeRegion));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.MakeEmpty"]/*' />
        /// <devdoc>
        ///    Initializes this <see cref='System.Drawing.Region'/> to an
        ///    empty interior.
        /// </devdoc>
        public void MakeEmpty() {
            int status = SafeNativeMethods.GdipSetEmpty(new HandleRef(this, nativeRegion));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Intersect"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the intersection of itself
        ///    with the specified <see cref='System.Drawing.RectangleF'/>.
        /// </devdoc>
        public void Intersect(RectangleF rect) {
            GPRECTF gprectf = rect.ToGPRECTF();
            int status = SafeNativeMethods.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Intersect1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the intersection of itself with the specified
        ///    <see cref='System.Drawing.Rectangle'/>.
        ///    </para>
        /// </devdoc>
        public void Intersect(Rectangle rect) {
            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Intersect2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the intersection of itself with the specified
        ///    <see cref='System.Drawing.Drawing2D.GraphicsPath'/>. 
        ///    </para>
        /// </devdoc>
        public void Intersect(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            int status = SafeNativeMethods.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Intersect3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the intersection of itself with the specified
        ///    <see cref='System.Drawing.Region'/>. 
        ///    </para>
        /// </devdoc>
        public void Intersect(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");
                
            int status = SafeNativeMethods.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Intersect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Union"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the union of itself and the
        ///       specified <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public void Union(RectangleF rect) {
            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Union);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Union1"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union of itself and the
        ///    specified <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public void Union(Rectangle rect) {
            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Union);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Union2"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union of itself and the
        ///    specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Union(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            int status = SafeNativeMethods.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Union);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Union3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the union of itself and the specified <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public void Union(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");
                
            int status = SafeNativeMethods.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Union);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Xor"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union minus the
        ///    intersection of itself with the specified <see cref='System.Drawing.RectangleF'/>.
        /// </devdoc>
        public void Xor(RectangleF rect) {
            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Xor);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Xor1"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union minus the
        ///    intersection of itself with the specified <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public void Xor(Rectangle rect) {
            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Xor);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Xor2"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union minus the
        ///    intersection of itself with the specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Xor(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            int status = SafeNativeMethods.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Xor);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Xor3"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the union minus the
        ///    intersection of itself with the specified <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public void Xor(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");
            
            int status = SafeNativeMethods.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Xor);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Exclude"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of its interior
        ///    that does not intersect with the specified <see cref='System.Drawing.RectangleF'/>.
        /// </devdoc>
        public void Exclude(RectangleF rect) {
            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Exclude1"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of its interior
        ///    that does not intersect with the specified <see cref='System.Drawing.Rectangle'/>.
        /// </devdoc>
        public void Exclude(Rectangle rect) {
            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Exclude2"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of its interior
        ///    that does not intersect with the specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Exclude(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            int status = SafeNativeMethods.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath),
                                                       CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Exclude3"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of its interior
        ///    that does not intersect with the specified <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public void Exclude(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");
            
            int status = SafeNativeMethods.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion),
                                                         CombineMode.Exclude);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Complement"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of the
        ///    specified <see cref='System.Drawing.RectangleF'/> that does not intersect with this <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public void Complement(RectangleF rect) {
            GPRECTF gprectf = rect.ToGPRECTF();
            int status = SafeNativeMethods.GdipCombineRegionRect(new HandleRef(this, nativeRegion), ref gprectf, CombineMode.Complement);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Complement1"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of the
        ///    specified <see cref='System.Drawing.Rectangle'/> that does not intersect with this <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public void Complement(Rectangle rect) {
            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCombineRegionRectI(new HandleRef(this, nativeRegion), ref gprect, CombineMode.Complement);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Complement2"]/*' />
        /// <devdoc>
        ///    Updates this <see cref='System.Drawing.Region'/> to the portion of the
        ///    specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/> that does not intersect with this
        /// <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public void Complement(GraphicsPath path) {
            if (path == null)
                throw new ArgumentNullException("path");
            
            int status = SafeNativeMethods.GdipCombineRegionPath(new HandleRef(this, nativeRegion), new HandleRef(path, path.nativePath), CombineMode.Complement);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Complement3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates this <see cref='System.Drawing.Region'/> to the portion of the
        ///       specified <see cref='System.Drawing.Region'/> that does not intersect with this <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public void Complement(Region region) {
            if (region == null)
                throw new ArgumentNullException("region");
            
            int status = SafeNativeMethods.GdipCombineRegionRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), CombineMode.Complement);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Transform operations
         */
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Translate"]/*' />
        /// <devdoc>
        ///    Offsets the coordinates of this <see cref='System.Drawing.Region'/> by the
        ///    specified amount.
        /// </devdoc>
        public void Translate(float dx, float dy) {
            int status = SafeNativeMethods.GdipTranslateRegion(new HandleRef(this, nativeRegion), dx, dy);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Translate1"]/*' />
        /// <devdoc>
        ///    Offsets the coordinates of this <see cref='System.Drawing.Region'/> by the
        ///    specified amount.
        /// </devdoc>
        public void Translate(int dx, int dy) {
            int status = SafeNativeMethods.GdipTranslateRegionI(new HandleRef(this, nativeRegion), dx, dy);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Transform"]/*' />
        /// <devdoc>
        ///    Transforms this <see cref='System.Drawing.Region'/> by the
        ///    specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public void Transform(Matrix matrix) {
            if (matrix == null)
                throw new ArgumentNullException("matrix");
            
            int status = SafeNativeMethods.GdipTransformRegion(new HandleRef(this, nativeRegion),
                                                     new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Get region attributes
         */
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.GetBounds"]/*' />
        /// <devdoc>
        ///    Returns a <see cref='System.Drawing.RectangleF'/> that represents a rectangular
        ///    region that bounds this <see cref='System.Drawing.Region'/> on the drawing surface of a <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        public RectangleF GetBounds(Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");
            
            GPRECTF gprectf = new GPRECTF();

            int status = SafeNativeMethods.GdipGetRegionBounds(new HandleRef(this, nativeRegion), new HandleRef(g, g.nativeGraphics), ref gprectf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return gprectf.ToRectangleF();
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.GetHrgn"]/*' />
        /// <devdoc>
        ///    Returns a Windows handle to this <see cref='System.Drawing.Region'/> in the
        ///    specified graphics context.
        /// </devdoc>
        public IntPtr GetHrgn(Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");
            
            IntPtr hrgn = IntPtr.Zero;

            int status = SafeNativeMethods.GdipGetRegionHRgn(new HandleRef(this, nativeRegion), new HandleRef(g, g.nativeGraphics), out hrgn);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return hrgn;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether this <see cref='System.Drawing.Region'/> has an
        ///       empty interior on the specified drawing surface.
        ///    </para>
        /// </devdoc>
        public bool IsEmpty(Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");
            
            int isEmpty;
            int status = SafeNativeMethods.GdipIsEmptyRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.nativeGraphics), out isEmpty);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isEmpty != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsInfinite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether this <see cref='System.Drawing.Region'/> has
        ///       an infinite interior on the specified drawing surface.
        ///    </para>
        /// </devdoc>
        public bool IsInfinite(Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");

            int isInfinite;
            int status = SafeNativeMethods.GdipIsInfiniteRegion(new HandleRef(this, nativeRegion), new HandleRef(g, g.nativeGraphics), out isInfinite);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isInfinite != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.Region'/> is
        ///       identical to this <see cref='System.Drawing.Region'/>
        ///       on the specified drawing surface.
        ///    </para>
        /// </devdoc>
        public bool Equals(Region region, Graphics g) {
            if (g == null)
                throw new ArgumentNullException("graphics");
            
            if (region == null)
                throw new ArgumentNullException("region");

            int isEqual;
            int status = SafeNativeMethods.GdipIsEqualRegion(new HandleRef(this, nativeRegion), new HandleRef(region, region.nativeRegion), new HandleRef(g, g.nativeGraphics), out isEqual);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isEqual != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.GetRegionData"]/*' />
        /// <devdoc>
        ///    Returns a <see cref='System.Drawing.Drawing2D.RegionData'/> that represents the
        ///    information that describes this <see cref='System.Drawing.Region'/>.
        /// </devdoc>
        public RegionData GetRegionData() {

            int regionSize = 0;

            int status = SafeNativeMethods.GdipGetRegionDataSize(new HandleRef(this, nativeRegion), out regionSize);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            if (regionSize == 0)
                return null;

            byte[] regionData = new byte[regionSize];

            status = SafeNativeMethods.GdipGetRegionData(new HandleRef(this, nativeRegion), regionData, regionSize, out regionSize);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new RegionData(regionData);
        }

        /*
         * Hit testing operations
         */
        // float version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified point is
        ///       contained within this <see cref='System.Drawing.Region'/> in the specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y) {
            return IsVisible(new PointF(x, y), null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.PointF'/> is contained within this <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(PointF point) {
            return IsVisible(point, null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified point is contained within this <see cref='System.Drawing.Region'/> in the
        ///       specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y, Graphics g) {
            return IsVisible(new PointF(x, y), g);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.PointF'/> is
        ///       contained within this <see cref='System.Drawing.Region'/> in the specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(PointF point, Graphics g) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisibleRegionPoint(new HandleRef(this, nativeRegion), point.X, point.Y,
                                                          new HandleRef(g, (g==null) ? IntPtr.Zero : g.nativeGraphics), 
                                                          out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified rectangle is contained within this <see cref='System.Drawing.Region'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y, float width, float height) {
            return IsVisible(new RectangleF(x, y, width, height), null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.RectangleF'/> is contained within this
        ///    <see cref='System.Drawing.Region'/>. 
        ///    </para>
        /// </devdoc>
        public bool IsVisible(RectangleF rect) {
            return IsVisible(rect, null);
        }
            
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified rectangle is contained within this <see cref='System.Drawing.Region'/> in the
        ///       specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y, float width, float height, Graphics g) {
            return IsVisible(new RectangleF(x, y, width, height), g);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.RectangleF'/> is contained within this <see cref='System.Drawing.Region'/> in the specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(RectangleF rect, Graphics g) {
            
            int isVisible = 0;
            int status = SafeNativeMethods.GdipIsVisibleRegionRect(new HandleRef(this, nativeRegion), rect.X, rect.Y,
                                                         rect.Width, rect.Height,
                                                         new HandleRef(g, (g==null) ? IntPtr.Zero : g.nativeGraphics), 
                                                         out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        // int version
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified point is contained within this <see cref='System.Drawing.Region'/> in the
        ///       specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(int x, int y, Graphics g) {
            return IsVisible(new Point(x, y), g);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.Point'/> is contained within this <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(Point point) {
            return IsVisible(point, null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.Point'/> is contained within this
        ///    <see cref='System.Drawing.Region'/> in the specified 
        ///       graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(Point point, Graphics g) {
            int isVisible = 0;
            int status = SafeNativeMethods.GdipIsVisibleRegionPointI(new HandleRef(this, nativeRegion), point.X, point.Y,
                                                           new HandleRef(g, (g == null) ? IntPtr.Zero : g.nativeGraphics), 
                                                           out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified rectangle is contained within this <see cref='System.Drawing.Region'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public bool IsVisible(int x, int y, int width, int height) {
            return IsVisible(new Rectangle(x, y, width, height), null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.Rectangle'/> is contained within this
        ///    <see cref='System.Drawing.Region'/>. 
        ///    </para>
        /// </devdoc>
        public bool IsVisible(Rectangle rect) {
            return IsVisible(rect, null);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible13"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified rectangle is contained within this <see cref='System.Drawing.Region'/> in the
        ///       specified graphics context.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(int x, int y, int width, int height, Graphics g) {
            return IsVisible(new Rectangle(x, y, width, height), g);
        }
        
        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.IsVisible14"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified <see cref='System.Drawing.Rectangle'/> is contained within this
        ///    <see cref='System.Drawing.Region'/> 
        ///    in the specified graphics context.
        /// </para>
        /// </devdoc>
        public bool IsVisible(Rectangle rect, Graphics g) {
            
            int isVisible = 0;
            int status = SafeNativeMethods.GdipIsVisibleRegionRectI(new HandleRef(this, nativeRegion), rect.X, rect.Y,
                                                          rect.Width, rect.Height,
                                                          new HandleRef(g, (g == null) ? IntPtr.Zero : g.nativeGraphics), 
                                                          out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\Region.uex' path='docs/doc[@for="Region.GetRegionScans"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an array of <see cref='System.Drawing.RectangleF'/>
        ///       objects that approximate this Region on the specified
        ///    </para>
        /// </devdoc>
        public RectangleF[] GetRegionScans(Matrix matrix) {
            if (matrix == null)
                throw new ArgumentNullException("matrix");
            
            int count = 0;

            // call first time to get actual count of rectangles

            int status = SafeNativeMethods.GdipGetRegionScansCount(new HandleRef(this, nativeRegion),
                                                         out count,
                                                         new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            int rectsize = (int)Marshal.SizeOf(typeof(GPRECTF));
            IntPtr memoryRects = Marshal.AllocHGlobal(rectsize*count);

            status = SafeNativeMethods.GdipGetRegionScans(new HandleRef(this, nativeRegion),
                                                memoryRects,
                                                out count,
                                                new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(memoryRects);
                throw SafeNativeMethods.StatusException(status);
            }

            int index;
            GPRECTF gprectf = new GPRECTF();

            RectangleF[] rectangles = new RectangleF[count];

            for (index=0; index<count; index++) {
                gprectf = (GPRECTF) UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memoryRects + rectsize*index), typeof(GPRECTF));
                rectangles[index] = gprectf.ToRectangleF();
            }

            return rectangles;
        }

        /*
         * handle to native region object
         */
        internal IntPtr nativeRegion;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\pens.cs ===
//------------------------------------------------------------------------------
// <copyright file="Pens.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    


    /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens"]/*' />
    /// <devdoc>
    ///     Pens for all the standard colors.
    /// </devdoc>
    public sealed class Pens {
        static readonly object TransparentKey = new object();
        static readonly object AliceBlueKey = new object();
        static readonly object AntiqueWhiteKey = new object();
        static readonly object AquaKey = new object();
        static readonly object AquamarineKey = new object();
        static readonly object AzureKey = new object();
        static readonly object BeigeKey = new object();
        static readonly object BisqueKey = new object();
        static readonly object BlackKey = new object();
        static readonly object BlanchedAlmondKey = new object();
        static readonly object BlueKey = new object();
        static readonly object BlueVioletKey = new object();
        static readonly object BrownKey = new object();
        static readonly object BurlyWoodKey = new object();
        static readonly object CadetBlueKey = new object();
        static readonly object ChartreuseKey = new object();
        static readonly object ChocolateKey = new object();
        static readonly object ChoralKey = new object();
        static readonly object CornflowerBlueKey = new object();
        static readonly object CornsilkKey = new object();
        static readonly object CrimsonKey = new object();
        static readonly object CyanKey = new object();
        static readonly object DarkBlueKey = new object();
        static readonly object DarkCyanKey = new object();
        static readonly object DarkGoldenrodKey = new object();
        static readonly object DarkGrayKey = new object();
        static readonly object DarkGreenKey = new object();
        static readonly object DarkKhakiKey = new object();
        static readonly object DarkMagentaKey = new object();
        static readonly object DarkOliveGreenKey = new object();
        static readonly object DarkOrangeKey = new object();
        static readonly object DarkOrchidKey = new object();
        static readonly object DarkRedKey = new object();
        static readonly object DarkSalmonKey = new object();
        static readonly object DarkSeaGreenKey = new object();
        static readonly object DarkSlateBlueKey = new object();
        static readonly object DarkSlateGrayKey = new object();
        static readonly object DarkTurquoiseKey = new object();
        static readonly object DarkVioletKey = new object();
        static readonly object DeepPinkKey = new object();
        static readonly object DeepSkyBlueKey = new object();
        static readonly object DimGrayKey = new object();
        static readonly object DodgerBlueKey = new object();
        static readonly object FirebrickKey = new object();
        static readonly object FloralWhiteKey = new object();
        static readonly object ForestGreenKey = new object();
        static readonly object FuchiaKey = new object();
        static readonly object GainsboroKey = new object();
        static readonly object GhostWhiteKey = new object();
        static readonly object GoldKey = new object();
        static readonly object GoldenrodKey = new object();
        static readonly object GrayKey = new object();
        static readonly object GreenKey = new object();
        static readonly object GreenYellowKey = new object();
        static readonly object HoneydewKey = new object();
        static readonly object HotPinkKey = new object();
        static readonly object IndianRedKey = new object();
        static readonly object IndigoKey = new object();
        static readonly object IvoryKey = new object();
        static readonly object KhakiKey = new object();
        static readonly object LavenderKey = new object();
        static readonly object LavenderBlushKey = new object();
        static readonly object LawnGreenKey = new object();
        static readonly object LemonChiffonKey = new object();
        static readonly object LightBlueKey = new object();
        static readonly object LightCoralKey = new object();
        static readonly object LightCyanKey = new object();
        static readonly object LightGoldenrodYellowKey = new object();
        static readonly object LightGreenKey = new object();
        static readonly object LightGrayKey = new object();
        static readonly object LightPinkKey = new object();
        static readonly object LightSalmonKey = new object();
        static readonly object LightSeaGreenKey = new object();
        static readonly object LightSkyBlueKey = new object();
        static readonly object LightSlateGrayKey = new object();
        static readonly object LightSteelBlueKey = new object();
        static readonly object LightYellowKey = new object();
        static readonly object LimeKey = new object();
        static readonly object LimeGreenKey = new object();
        static readonly object LinenKey = new object();
        static readonly object MagentaKey = new object();
        static readonly object MaroonKey = new object();
        static readonly object MediumAquamarineKey = new object();
        static readonly object MediumBlueKey = new object();
        static readonly object MediumOrchidKey = new object();
        static readonly object MediumPurpleKey = new object();
        static readonly object MediumSeaGreenKey = new object();
        static readonly object MediumSlateBlueKey = new object();
        static readonly object MediumSpringGreenKey = new object();
        static readonly object MediumTurquoiseKey = new object();
        static readonly object MediumVioletRedKey = new object();
        static readonly object MidnightBlueKey = new object();
        static readonly object MintCreamKey = new object();
        static readonly object MistyRoseKey = new object();
        static readonly object MoccasinKey = new object();
        static readonly object NavajoWhiteKey = new object();
        static readonly object NavyKey = new object();
        static readonly object OldLaceKey = new object();
        static readonly object OliveKey = new object();
        static readonly object OliveDrabKey = new object();
        static readonly object OrangeKey = new object();
        static readonly object OrangeRedKey = new object();
        static readonly object OrchidKey = new object();
        static readonly object PaleGoldenrodKey = new object();
        static readonly object PaleGreenKey = new object();
        static readonly object PaleTurquoiseKey = new object();
        static readonly object PaleVioletRedKey = new object();
        static readonly object PapayaWhipKey = new object();
        static readonly object PeachPuffKey = new object();
        static readonly object PeruKey = new object();
        static readonly object PinkKey = new object();
        static readonly object PlumKey = new object();
        static readonly object PowderBlueKey = new object();
        static readonly object PurpleKey = new object();
        static readonly object RedKey = new object();
        static readonly object RosyBrownKey = new object();
        static readonly object RoyalBlueKey = new object();
        static readonly object SaddleBrownKey = new object();
        static readonly object SalmonKey = new object();
        static readonly object SandyBrownKey = new object();
        static readonly object SeaGreenKey = new object();
        static readonly object SeaShellKey = new object();
        static readonly object SiennaKey = new object();
        static readonly object SilverKey = new object();
        static readonly object SkyBlueKey = new object();
        static readonly object SlateBlueKey = new object();
        static readonly object SlateGrayKey = new object();
        static readonly object SnowKey = new object();
        static readonly object SpringGreenKey = new object();
        static readonly object SteelBlueKey = new object();
        static readonly object TanKey = new object();
        static readonly object TealKey = new object();
        static readonly object ThistleKey = new object();
        static readonly object TomatoKey = new object();
        static readonly object TurquoiseKey = new object();
        static readonly object VioletKey = new object();
        static readonly object WheatKey = new object();
        static readonly object WhiteKey = new object();
        static readonly object WhiteSmokeKey = new object();
        static readonly object YellowKey = new object();
        static readonly object YellowGreenKey = new object();

        private Pens() {
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Transparent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Transparent {
            get {
                Pen transparent = (Pen)SafeNativeMethods.ThreadData[TransparentKey];
                if (transparent == null) {
                    transparent = new Pen(Color.Transparent, true);
                    SafeNativeMethods.ThreadData[TransparentKey] = transparent;
                }
                return transparent;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.AliceBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen AliceBlue {
            get {
                Pen aliceBlue = (Pen)SafeNativeMethods.ThreadData[AliceBlueKey];
                if (aliceBlue == null) {
                    aliceBlue = new Pen(Color.AliceBlue, true);
                    SafeNativeMethods.ThreadData[AliceBlueKey] = aliceBlue;
                }
                return aliceBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.AntiqueWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen AntiqueWhite {
            get {
                Pen antiqueWhite = (Pen)SafeNativeMethods.ThreadData[AntiqueWhiteKey];
                if (antiqueWhite == null) {
                    antiqueWhite = new Pen(Color.AntiqueWhite, true);
                    SafeNativeMethods.ThreadData[AntiqueWhiteKey] = antiqueWhite;
                }
                return antiqueWhite;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Aqua"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Aqua {
            get {
                Pen aqua = (Pen)SafeNativeMethods.ThreadData[AquaKey];
                if (aqua == null) {
                    aqua = new Pen(Color.Aqua, true);
                    SafeNativeMethods.ThreadData[AquaKey] = aqua;
                }
                return aqua;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Aquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Aquamarine {
            get {
                Pen aquamarine = (Pen)SafeNativeMethods.ThreadData[AquamarineKey];
                if (aquamarine == null) {
                    aquamarine = new Pen(Color.Aquamarine, true);
                    SafeNativeMethods.ThreadData[AquamarineKey] = aquamarine;
                }
                return aquamarine;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Azure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Azure {
            get {
                Pen azure = (Pen)SafeNativeMethods.ThreadData[AzureKey];
                if (azure == null) {
                    azure = new Pen(Color.Azure, true);
                    SafeNativeMethods.ThreadData[AzureKey] = azure;
                }
                return azure;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Beige"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Beige {
            get {
                Pen beige = (Pen)SafeNativeMethods.ThreadData[BeigeKey];
                if (beige == null) {
                    beige = new Pen(Color.Beige, true);
                    SafeNativeMethods.ThreadData[BeigeKey] = beige;
                }
                return beige;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Bisque"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Bisque {
            get {
                Pen bisque = (Pen)SafeNativeMethods.ThreadData[BisqueKey];
                if (bisque == null) {
                    bisque = new Pen(Color.Bisque, true);
                    SafeNativeMethods.ThreadData[BisqueKey] = bisque;
                }
                return bisque;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Black"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Black {
            get {
                Pen black = (Pen)SafeNativeMethods.ThreadData[BlackKey];
                if (black == null) {
                    black = new Pen(Color.Black, true);
                    SafeNativeMethods.ThreadData[BlackKey] = black;
                }
                return black;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.BlanchedAlmond"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen BlanchedAlmond {
            get {
                Pen blanchedAlmond = (Pen)SafeNativeMethods.ThreadData[BlanchedAlmondKey];
                if (blanchedAlmond == null) {
                    blanchedAlmond = new Pen(Color.BlanchedAlmond, true);
                    SafeNativeMethods.ThreadData[BlanchedAlmondKey] = blanchedAlmond;
                }
                return blanchedAlmond;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Blue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Blue {
            get {
                Pen blue = (Pen)SafeNativeMethods.ThreadData[BlueKey];
                if (blue == null) {
                    blue = new Pen(Color.Blue, true);
                    SafeNativeMethods.ThreadData[BlueKey] = blue;
                }
                return blue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.BlueViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen BlueViolet {
            get {
                Pen blueViolet = (Pen)SafeNativeMethods.ThreadData[BlueVioletKey];
                if (blueViolet == null) {
                    blueViolet = new Pen(Color.BlueViolet, true);
                    SafeNativeMethods.ThreadData[BlueVioletKey] = blueViolet;
                }
                return blueViolet;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Brown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Brown {
            get {
                Pen brown = (Pen)SafeNativeMethods.ThreadData[BrownKey];
                if (brown == null) {
                    brown = new Pen(Color.Brown, true);
                    SafeNativeMethods.ThreadData[BrownKey] = brown;
                }
                return brown;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.BurlyWood"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen BurlyWood {
            get {
                Pen burlyWood = (Pen)SafeNativeMethods.ThreadData[BurlyWoodKey];
                if (burlyWood == null) {
                    burlyWood = new Pen(Color.BurlyWood, true);
                    SafeNativeMethods.ThreadData[BurlyWoodKey] = burlyWood;
                }
                return burlyWood;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.CadetBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen CadetBlue {
            get {
                Pen cadetBlue = (Pen)SafeNativeMethods.ThreadData[CadetBlueKey];
                if (cadetBlue == null) {
                    cadetBlue = new Pen(Color.CadetBlue, true);
                    SafeNativeMethods.ThreadData[CadetBlueKey] = cadetBlue;
                }
                return cadetBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Chartreuse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Chartreuse {
            get {
                Pen chartreuse = (Pen)SafeNativeMethods.ThreadData[ChartreuseKey];
                if (chartreuse == null) {
                    chartreuse = new Pen(Color.Chartreuse, true);
                    SafeNativeMethods.ThreadData[ChartreuseKey] = chartreuse;
                }
                return chartreuse;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Chocolate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Chocolate {
            get {
                Pen chocolate = (Pen)SafeNativeMethods.ThreadData[ChocolateKey];
                if (chocolate == null) {
                    chocolate = new Pen(Color.Chocolate, true);
                    SafeNativeMethods.ThreadData[ChocolateKey] = chocolate;
                }
                return chocolate;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Coral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Coral {
            get {
                Pen choral = (Pen)SafeNativeMethods.ThreadData[ChoralKey];
                if (choral == null) {
                    choral = new Pen(Color.Coral, true);
                    SafeNativeMethods.ThreadData[ChoralKey] = choral;
                }
                return choral;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.CornflowerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen CornflowerBlue {
            get {
                Pen cornflowerBlue = (Pen)SafeNativeMethods.ThreadData[CornflowerBlueKey];
                if (cornflowerBlue == null) {
                    cornflowerBlue = new Pen(Color.CornflowerBlue, true);
                    SafeNativeMethods.ThreadData[CornflowerBlueKey] = cornflowerBlue;
                }
                return cornflowerBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Cornsilk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Cornsilk {
            get {
                Pen cornsilk = (Pen)SafeNativeMethods.ThreadData[CornsilkKey];
                if (cornsilk == null) {
                    cornsilk = new Pen(Color.Cornsilk, true);
                    SafeNativeMethods.ThreadData[CornsilkKey] = cornsilk;
                }
                return cornsilk;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Crimson"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Crimson {
            get {
                Pen crimson = (Pen)SafeNativeMethods.ThreadData[CrimsonKey];
                if (crimson == null) {
                    crimson = new Pen(Color.Crimson, true);
                    SafeNativeMethods.ThreadData[CrimsonKey] = crimson;
                }
                return crimson;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Cyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Cyan {
            get {
                Pen cyan = (Pen)SafeNativeMethods.ThreadData[CyanKey];
                if (cyan == null) {
                    cyan = new Pen(Color.Cyan, true);
                    SafeNativeMethods.ThreadData[CyanKey] = cyan;
                }
                return cyan;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkBlue {
            get {
                Pen darkBlue = (Pen)SafeNativeMethods.ThreadData[DarkBlueKey];
                if (darkBlue == null) {
                    darkBlue = new Pen(Color.DarkBlue, true);
                    SafeNativeMethods.ThreadData[DarkBlueKey] = darkBlue;
                }
                return darkBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkCyan {
            get {
                Pen darkCyan = (Pen)SafeNativeMethods.ThreadData[DarkCyanKey];
                if (darkCyan == null) {
                    darkCyan = new Pen(Color.DarkCyan, true);
                    SafeNativeMethods.ThreadData[DarkCyanKey] = darkCyan;
                }
                return darkCyan;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkGoldenrod {
            get {
                Pen darkGoldenrod = (Pen)SafeNativeMethods.ThreadData[DarkGoldenrodKey];
                if (darkGoldenrod == null) {
                    darkGoldenrod = new Pen(Color.DarkGoldenrod, true);
                    SafeNativeMethods.ThreadData[DarkGoldenrodKey] = darkGoldenrod;
                }
                return darkGoldenrod;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkGray {
            get {
                Pen darkGray = (Pen)SafeNativeMethods.ThreadData[DarkGrayKey];
                if (darkGray == null) {
                    darkGray = new Pen(Color.DarkGray, true);
                    SafeNativeMethods.ThreadData[DarkGrayKey] = darkGray;
                }
                return darkGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkGreen {
            get {
                Pen darkGreen = (Pen)SafeNativeMethods.ThreadData[DarkGreenKey];
                if (darkGreen == null) {
                    darkGreen = new Pen(Color.DarkGreen, true);
                    SafeNativeMethods.ThreadData[DarkGreenKey] = darkGreen;
                }
                return darkGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkKhaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkKhaki {
            get {
                Pen darkKhaki = (Pen)SafeNativeMethods.ThreadData[DarkKhakiKey];
                if (darkKhaki == null) {
                    darkKhaki = new Pen(Color.DarkKhaki, true);
                    SafeNativeMethods.ThreadData[DarkKhakiKey] = darkKhaki;
                }
                return darkKhaki;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkMagenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkMagenta {
            get {
                Pen darkMagenta = (Pen)SafeNativeMethods.ThreadData[DarkMagentaKey];
                if (darkMagenta == null) {
                    darkMagenta = new Pen(Color.DarkMagenta, true);
                    SafeNativeMethods.ThreadData[DarkMagentaKey] = darkMagenta;
                }
                return darkMagenta;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkOliveGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkOliveGreen {
            get {
                Pen darkOliveGreen = (Pen)SafeNativeMethods.ThreadData[DarkOliveGreenKey];
                if (darkOliveGreen == null) {
                    darkOliveGreen = new Pen(Color.DarkOliveGreen, true);
                    SafeNativeMethods.ThreadData[DarkOliveGreenKey] = darkOliveGreen;
                }
                return darkOliveGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkOrange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkOrange {
            get {
                Pen darkOrange = (Pen)SafeNativeMethods.ThreadData[DarkOrangeKey];
                if (darkOrange == null) {
                    darkOrange = new Pen(Color.DarkOrange, true);
                    SafeNativeMethods.ThreadData[DarkOrangeKey] = darkOrange;
                }
                return darkOrange;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkOrchid {
            get {
                Pen darkOrchid = (Pen)SafeNativeMethods.ThreadData[DarkOrchidKey];
                if (darkOrchid == null) {
                    darkOrchid = new Pen(Color.DarkOrchid, true);
                    SafeNativeMethods.ThreadData[DarkOrchidKey] = darkOrchid;
                }
                return darkOrchid;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkRed {
            get {
                Pen darkRed = (Pen)SafeNativeMethods.ThreadData[DarkRedKey];
                if (darkRed == null) {
                    darkRed = new Pen(Color.DarkRed, true);
                    SafeNativeMethods.ThreadData[DarkRedKey] = darkRed;
                }
                return darkRed;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkSalmon {
            get {
                Pen darkSalmon = (Pen)SafeNativeMethods.ThreadData[DarkSalmonKey];
                if (darkSalmon == null) {
                    darkSalmon = new Pen(Color.DarkSalmon, true);
                    SafeNativeMethods.ThreadData[DarkSalmonKey] = darkSalmon;
                }
                return darkSalmon;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkSeaGreen {
            get {
                Pen darkSeaGreen = (Pen)SafeNativeMethods.ThreadData[DarkSeaGreenKey];
                if (darkSeaGreen == null) {
                    darkSeaGreen = new Pen(Color.DarkSeaGreen, true);
                    SafeNativeMethods.ThreadData[DarkSeaGreenKey] = darkSeaGreen;
                }
                return darkSeaGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkSlateBlue {
            get {
                Pen darkSlateBlue = (Pen)SafeNativeMethods.ThreadData[DarkSlateBlueKey];
                if (darkSlateBlue == null) {
                    darkSlateBlue = new Pen(Color.DarkSlateBlue, true);
                    SafeNativeMethods.ThreadData[DarkSlateBlueKey] = darkSlateBlue;
                }
                return darkSlateBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkSlateGray {
            get {
                Pen darkSlateGray = (Pen)SafeNativeMethods.ThreadData[DarkSlateGrayKey];
                if (darkSlateGray == null) {
                    darkSlateGray = new Pen(Color.DarkSlateGray, true);
                    SafeNativeMethods.ThreadData[DarkSlateGrayKey] = darkSlateGray;
                }
                return darkSlateGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkTurquoise {
            get {
                Pen darkTurquoise = (Pen)SafeNativeMethods.ThreadData[DarkTurquoiseKey];
                if (darkTurquoise == null) {
                    darkTurquoise = new Pen(Color.DarkTurquoise, true);
                    SafeNativeMethods.ThreadData[DarkTurquoiseKey] = darkTurquoise;
                }
                return darkTurquoise;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DarkViolet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DarkViolet {
            get {
                Pen darkViolet = (Pen)SafeNativeMethods.ThreadData[DarkVioletKey];
                if (darkViolet == null) {
                    darkViolet = new Pen(Color.DarkViolet, true);
                    SafeNativeMethods.ThreadData[DarkVioletKey] = darkViolet;
                }
                return darkViolet;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DeepPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DeepPink {
            get {
                Pen deepPink = (Pen)SafeNativeMethods.ThreadData[DeepPinkKey];
                if (deepPink == null) {
                    deepPink = new Pen(Color.DeepPink, true);
                    SafeNativeMethods.ThreadData[DeepPinkKey] = deepPink;
                }
                return deepPink;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DeepSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DeepSkyBlue {
            get {
                Pen deepSkyBlue = (Pen)SafeNativeMethods.ThreadData[DeepSkyBlueKey];
                if (deepSkyBlue == null) {
                    deepSkyBlue = new Pen(Color.DeepSkyBlue, true);
                    SafeNativeMethods.ThreadData[DeepSkyBlueKey] = deepSkyBlue;
                }
                return deepSkyBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DimGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DimGray {
            get {
                Pen dimGray = (Pen)SafeNativeMethods.ThreadData[DimGrayKey];
                if (dimGray == null) {
                    dimGray = new Pen(Color.DimGray, true);
                    SafeNativeMethods.ThreadData[DimGrayKey] = dimGray;
                }
                return dimGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.DodgerBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen DodgerBlue {
            get {
                Pen dodgerBlue = (Pen)SafeNativeMethods.ThreadData[DodgerBlueKey];
                if (dodgerBlue == null) {
                    dodgerBlue = new Pen(Color.DodgerBlue, true);
                    SafeNativeMethods.ThreadData[DodgerBlueKey] = dodgerBlue;
                }
                return dodgerBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Firebrick"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Firebrick {
            get {
                Pen firebrick = (Pen)SafeNativeMethods.ThreadData[FirebrickKey];
                if (firebrick == null) {
                    firebrick = new Pen(Color.Firebrick, true);
                    SafeNativeMethods.ThreadData[FirebrickKey] = firebrick;
                }
                return firebrick;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.FloralWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen FloralWhite {
            get {
                Pen floralWhite = (Pen)SafeNativeMethods.ThreadData[FloralWhiteKey];
                if (floralWhite == null) {
                    floralWhite = new Pen(Color.FloralWhite, true);
                    SafeNativeMethods.ThreadData[FloralWhiteKey] = floralWhite;
                }
                return floralWhite;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.ForestGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen ForestGreen {
            get {
                Pen forestGreen = (Pen)SafeNativeMethods.ThreadData[ForestGreenKey];
                if (forestGreen == null) {
                    forestGreen = new Pen(Color.ForestGreen, true);
                    SafeNativeMethods.ThreadData[ForestGreenKey] = forestGreen;
                }
                return forestGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Fuchsia"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Fuchsia {
            get {
                Pen fuchia = (Pen)SafeNativeMethods.ThreadData[FuchiaKey];
                if (fuchia == null) {
                    fuchia = new Pen(Color.Fuchsia, true);
                    SafeNativeMethods.ThreadData[FuchiaKey] = fuchia;
                }
                return fuchia;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Gainsboro"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Gainsboro {
            get {
                Pen gainsboro = (Pen)SafeNativeMethods.ThreadData[GainsboroKey];
                if (gainsboro == null) {
                    gainsboro = new Pen(Color.Gainsboro, true);
                    SafeNativeMethods.ThreadData[GainsboroKey] = gainsboro;
                }
                return gainsboro;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.GhostWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen GhostWhite {
            get {
                Pen ghostWhite = (Pen)SafeNativeMethods.ThreadData[GhostWhiteKey];
                if (ghostWhite == null) {
                    ghostWhite = new Pen(Color.GhostWhite, true);
                    SafeNativeMethods.ThreadData[GhostWhiteKey] = ghostWhite;
                }
                return ghostWhite;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Gold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Gold {
            get {
                Pen gold = (Pen)SafeNativeMethods.ThreadData[GoldKey];
                if (gold == null) {
                    gold = new Pen(Color.Gold, true);
                    SafeNativeMethods.ThreadData[GoldKey] = gold;
                }
                return gold;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Goldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Goldenrod {
            get {
                Pen goldenrod = (Pen)SafeNativeMethods.ThreadData[GoldenrodKey];
                if (goldenrod == null) {
                    goldenrod = new Pen(Color.Goldenrod, true);
                    SafeNativeMethods.ThreadData[GoldenrodKey] = goldenrod;
                }
                return goldenrod;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Gray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Gray {
            get {
                Pen gray = (Pen)SafeNativeMethods.ThreadData[GrayKey];
                if (gray == null) {
                    gray = new Pen(Color.Gray, true);
                    SafeNativeMethods.ThreadData[GrayKey] = gray;
                }
                return gray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Green"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Green {
            get {
                Pen green = (Pen)SafeNativeMethods.ThreadData[GreenKey];
                if (green == null) {
                    green = new Pen(Color.Green, true);
                    SafeNativeMethods.ThreadData[GreenKey] = green;
                }
                return green;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.GreenYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen GreenYellow {
            get {
                Pen greenYellow = (Pen)SafeNativeMethods.ThreadData[GreenYellowKey];
                if (greenYellow == null) {
                    greenYellow = new Pen(Color.GreenYellow, true);
                    SafeNativeMethods.ThreadData[GreenYellowKey] = greenYellow;
                }
                return greenYellow;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Honeydew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Honeydew {
            get {
                Pen honeydew = (Pen)SafeNativeMethods.ThreadData[HoneydewKey];
                if (honeydew == null) {
                    honeydew = new Pen(Color.Honeydew, true);
                    SafeNativeMethods.ThreadData[HoneydewKey] = honeydew;
                }
                return honeydew;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.HotPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen HotPink {
            get {
                Pen hotPink = (Pen)SafeNativeMethods.ThreadData[HotPinkKey];
                if (hotPink == null) {
                    hotPink = new Pen(Color.HotPink, true);
                    SafeNativeMethods.ThreadData[HotPinkKey] = hotPink;
                }
                return hotPink;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.IndianRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen IndianRed {
            get {
                Pen indianRed = (Pen)SafeNativeMethods.ThreadData[IndianRedKey];
                if (indianRed == null) {
                    indianRed = new Pen(Color.IndianRed, true);
                    SafeNativeMethods.ThreadData[IndianRedKey] = indianRed;
                }
                return indianRed;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Indigo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Indigo {
            get {
                Pen indigo = (Pen)SafeNativeMethods.ThreadData[IndigoKey];
                if (indigo == null) {
                    indigo = new Pen(Color.Indigo, true);
                    SafeNativeMethods.ThreadData[IndigoKey] = indigo;
                }
                return indigo;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Ivory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Ivory {
            get {
                Pen ivory = (Pen)SafeNativeMethods.ThreadData[IvoryKey];
                if (ivory == null) {
                    ivory = new Pen(Color.Ivory, true);
                    SafeNativeMethods.ThreadData[IvoryKey] = ivory;
                }
                return ivory;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Khaki"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Khaki {
            get {
                Pen khaki = (Pen)SafeNativeMethods.ThreadData[KhakiKey];
                if (khaki == null) {
                    khaki = new Pen(Color.Khaki, true);
                    SafeNativeMethods.ThreadData[KhakiKey] = khaki;
                }
                return khaki;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Lavender"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Lavender {
            get {
                Pen lavender = (Pen)SafeNativeMethods.ThreadData[LavenderKey];
                if (lavender == null) {
                    lavender = new Pen(Color.Lavender, true);
                    SafeNativeMethods.ThreadData[LavenderKey] = lavender;
                }
                return lavender;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LavenderBlush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LavenderBlush {
            get {
                Pen lavenderBlush = (Pen)SafeNativeMethods.ThreadData[LavenderBlushKey];
                if (lavenderBlush == null) {
                    lavenderBlush = new Pen(Color.LavenderBlush, true);
                    SafeNativeMethods.ThreadData[LavenderBlushKey] = lavenderBlush;
                }
                return lavenderBlush;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LawnGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LawnGreen {
            get {
                Pen lawnGreen = (Pen)SafeNativeMethods.ThreadData[LawnGreenKey];
                if (lawnGreen == null) {
                    lawnGreen = new Pen(Color.LawnGreen, true);
                    SafeNativeMethods.ThreadData[LawnGreenKey] = lawnGreen;
                }
                return lawnGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LemonChiffon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LemonChiffon {
            get {
                Pen lemonChiffon = (Pen)SafeNativeMethods.ThreadData[LemonChiffonKey];
                if (lemonChiffon == null) {
                    lemonChiffon = new Pen(Color.LemonChiffon, true);
                    SafeNativeMethods.ThreadData[LemonChiffonKey] = lemonChiffon;
                }
                return lemonChiffon;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightBlue {
            get {
                Pen lightBlue = (Pen)SafeNativeMethods.ThreadData[LightBlueKey];
                if (lightBlue == null) {
                    lightBlue = new Pen(Color.LightBlue, true);
                    SafeNativeMethods.ThreadData[LightBlueKey] = lightBlue;
                }
                return lightBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightCoral"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightCoral {
            get {
                Pen lightCoral = (Pen)SafeNativeMethods.ThreadData[LightCoralKey];
                if (lightCoral == null) {
                    lightCoral = new Pen(Color.LightCoral, true);
                    SafeNativeMethods.ThreadData[LightCoralKey] = lightCoral;
                }
                return lightCoral;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightCyan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightCyan {
            get {
                Pen lightCyan = (Pen)SafeNativeMethods.ThreadData[LightCyanKey];
                if (lightCyan == null) {
                    lightCyan = new Pen(Color.LightCyan, true);
                    SafeNativeMethods.ThreadData[LightCyanKey] = lightCyan;
                }
                return lightCyan;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightGoldenrodYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightGoldenrodYellow {
            get {
                Pen lightGoldenrodYellow = (Pen)SafeNativeMethods.ThreadData[LightGoldenrodYellowKey];
                if (lightGoldenrodYellow == null) {
                    lightGoldenrodYellow = new Pen(Color.LightGoldenrodYellow, true);
                    SafeNativeMethods.ThreadData[LightGoldenrodYellowKey] = lightGoldenrodYellow;
                }
                return lightGoldenrodYellow;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightGreen {
            get {
                Pen lightGreen = (Pen)SafeNativeMethods.ThreadData[LightGreenKey];
                if (lightGreen == null) {
                    lightGreen = new Pen(Color.LightGreen, true);
                    SafeNativeMethods.ThreadData[LightGreenKey] = lightGreen;
                }
                return lightGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightGray {
            get {
                Pen lightGray = (Pen)SafeNativeMethods.ThreadData[LightGrayKey];
                if (lightGray == null) {
                    lightGray = new Pen(Color.LightGray, true);
                    SafeNativeMethods.ThreadData[LightGrayKey] = lightGray;
                }
                return lightGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightPink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightPink {
            get {
                Pen lightPink = (Pen)SafeNativeMethods.ThreadData[LightPinkKey];
                if (lightPink == null) {
                    lightPink = new Pen(Color.LightPink, true);
                    SafeNativeMethods.ThreadData[LightPinkKey] = lightPink;
                }
                return lightPink;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightSalmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightSalmon {
            get {
                Pen lightSalmon = (Pen)SafeNativeMethods.ThreadData[LightSalmonKey];
                if (lightSalmon == null) {
                    lightSalmon = new Pen(Color.LightSalmon, true);
                    SafeNativeMethods.ThreadData[LightSalmonKey] = lightSalmon;
                }
                return lightSalmon;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightSeaGreen {
            get {
                Pen lightSeaGreen = (Pen)SafeNativeMethods.ThreadData[LightSeaGreenKey];
                if (lightSeaGreen == null) {
                    lightSeaGreen = new Pen(Color.LightSeaGreen, true);
                    SafeNativeMethods.ThreadData[LightSeaGreenKey] = lightSeaGreen;
                }
                return lightSeaGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightSkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightSkyBlue {
            get {
                Pen lightSkyBlue = (Pen)SafeNativeMethods.ThreadData[LightSkyBlueKey];
                if (lightSkyBlue == null) {
                    lightSkyBlue = new Pen(Color.LightSkyBlue, true);
                    SafeNativeMethods.ThreadData[LightSkyBlueKey] = lightSkyBlue;
                }
                return lightSkyBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightSlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightSlateGray {
            get {
                Pen lightSlateGray = (Pen)SafeNativeMethods.ThreadData[LightSlateGrayKey];
                if (lightSlateGray == null) {
                    lightSlateGray = new Pen(Color.LightSlateGray, true);
                    SafeNativeMethods.ThreadData[LightSlateGrayKey] = lightSlateGray;
                }
                return lightSlateGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightSteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightSteelBlue {
            get {
                Pen lightSteelBlue = (Pen)SafeNativeMethods.ThreadData[LightSteelBlueKey];
                if (lightSteelBlue == null) {
                    lightSteelBlue = new Pen(Color.LightSteelBlue, true);
                    SafeNativeMethods.ThreadData[LightSteelBlueKey] = lightSteelBlue;
                }
                return lightSteelBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LightYellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LightYellow {
            get {
                Pen lightYellow = (Pen)SafeNativeMethods.ThreadData[LightYellowKey];
                if (lightYellow == null) {
                    lightYellow = new Pen(Color.LightYellow, true);
                    SafeNativeMethods.ThreadData[LightYellowKey] = lightYellow;
                }
                return lightYellow;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Lime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Lime {
            get {
                Pen lime = (Pen)SafeNativeMethods.ThreadData[LimeKey];
                if (lime == null) {
                    lime = new Pen(Color.Lime, true);
                    SafeNativeMethods.ThreadData[LimeKey] = lime;
                }
                return lime;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.LimeGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen LimeGreen {
            get {
                Pen limeGreen = (Pen)SafeNativeMethods.ThreadData[LimeGreenKey];
                if (limeGreen == null) {
                    limeGreen = new Pen(Color.LimeGreen, true);
                    SafeNativeMethods.ThreadData[LimeGreenKey] = limeGreen;
                }
                return limeGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Linen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Linen {
            get {
                Pen linen = (Pen)SafeNativeMethods.ThreadData[LinenKey];
                if (linen == null) {
                    linen = new Pen(Color.Linen, true);
                    SafeNativeMethods.ThreadData[LinenKey] = linen;
                }
                return linen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Magenta"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Magenta {
            get {
                Pen magenta = (Pen)SafeNativeMethods.ThreadData[MagentaKey];
                if (magenta == null) {
                    magenta = new Pen(Color.Magenta, true);
                    SafeNativeMethods.ThreadData[MagentaKey] = magenta;
                }
                return magenta;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Maroon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Maroon {
            get {
                Pen maroon = (Pen)SafeNativeMethods.ThreadData[MaroonKey];
                if (maroon == null) {
                    maroon = new Pen(Color.Maroon, true);
                    SafeNativeMethods.ThreadData[MaroonKey] = maroon;
                }
                return maroon;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumAquamarine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumAquamarine {
            get {
                Pen mediumAquamarine = (Pen)SafeNativeMethods.ThreadData[MediumAquamarineKey];
                if (mediumAquamarine == null) {
                    mediumAquamarine = new Pen(Color.MediumAquamarine, true);
                    SafeNativeMethods.ThreadData[MediumAquamarineKey] = mediumAquamarine;
                }
                return mediumAquamarine;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumBlue {
            get {
                Pen mediumBlue = (Pen)SafeNativeMethods.ThreadData[MediumBlueKey];
                if (mediumBlue == null) {
                    mediumBlue = new Pen(Color.MediumBlue, true);
                    SafeNativeMethods.ThreadData[MediumBlueKey] = mediumBlue;
                }
                return mediumBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumOrchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumOrchid {
            get {
                Pen mediumOrchid = (Pen)SafeNativeMethods.ThreadData[MediumOrchidKey];
                if (mediumOrchid == null) {
                    mediumOrchid = new Pen(Color.MediumOrchid, true);
                    SafeNativeMethods.ThreadData[MediumOrchidKey] = mediumOrchid;
                }
                return mediumOrchid;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumPurple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumPurple {
            get {
                Pen mediumPurple = (Pen)SafeNativeMethods.ThreadData[MediumPurpleKey];
                if (mediumPurple == null) {
                    mediumPurple = new Pen(Color.MediumPurple, true);
                    SafeNativeMethods.ThreadData[MediumPurpleKey] = mediumPurple;
                }
                return mediumPurple;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumSeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumSeaGreen {
            get {
                Pen mediumSeaGreen = (Pen)SafeNativeMethods.ThreadData[MediumSeaGreenKey];
                if (mediumSeaGreen == null) {
                    mediumSeaGreen = new Pen(Color.MediumSeaGreen, true);
                    SafeNativeMethods.ThreadData[MediumSeaGreenKey] = mediumSeaGreen;
                }
                return mediumSeaGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumSlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumSlateBlue {
            get {
                Pen mediumSlateBlue = (Pen)SafeNativeMethods.ThreadData[MediumSlateBlueKey];
                if (mediumSlateBlue == null) {
                    mediumSlateBlue = new Pen(Color.MediumSlateBlue, true);
                    SafeNativeMethods.ThreadData[MediumSlateBlueKey] = mediumSlateBlue;
                }
                return mediumSlateBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumSpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumSpringGreen {
            get {
                Pen mediumSpringGreen = (Pen)SafeNativeMethods.ThreadData[MediumSpringGreenKey];
                if (mediumSpringGreen == null) {
                    mediumSpringGreen = new Pen(Color.MediumSpringGreen, true);
                    SafeNativeMethods.ThreadData[MediumSpringGreenKey] = mediumSpringGreen;
                }
                return mediumSpringGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumTurquoise {
            get {
                Pen mediumTurquoise = (Pen)SafeNativeMethods.ThreadData[MediumTurquoiseKey];
                if (mediumTurquoise == null) {
                    mediumTurquoise = new Pen(Color.MediumTurquoise, true);
                    SafeNativeMethods.ThreadData[MediumTurquoiseKey] = mediumTurquoise;
                }
                return mediumTurquoise;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MediumVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MediumVioletRed {
            get {
                Pen mediumVioletRed = (Pen)SafeNativeMethods.ThreadData[MediumVioletRedKey];
                if (mediumVioletRed == null) {
                    mediumVioletRed = new Pen(Color.MediumVioletRed, true);
                    SafeNativeMethods.ThreadData[MediumVioletRedKey] = mediumVioletRed;
                }
                return mediumVioletRed;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MidnightBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MidnightBlue {
            get {
                Pen midnightBlue = (Pen)SafeNativeMethods.ThreadData[MidnightBlueKey];
                if (midnightBlue == null) {
                    midnightBlue = new Pen(Color.MidnightBlue, true);
                    SafeNativeMethods.ThreadData[MidnightBlueKey] = midnightBlue;
                }
                return midnightBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MintCream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MintCream {
            get {
                Pen mintCream = (Pen)SafeNativeMethods.ThreadData[MintCreamKey];
                if (mintCream == null) {
                    mintCream = new Pen(Color.MintCream, true);
                    SafeNativeMethods.ThreadData[MintCreamKey] = mintCream;
                }
                return mintCream;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.MistyRose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen MistyRose {
            get {
                Pen mistyRose = (Pen)SafeNativeMethods.ThreadData[MistyRoseKey];
                if (mistyRose == null) {
                    mistyRose = new Pen(Color.MistyRose, true);
                    SafeNativeMethods.ThreadData[MistyRoseKey] = mistyRose;
                }
                return mistyRose;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Moccasin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Moccasin {
            get {
                Pen moccasin = (Pen)SafeNativeMethods.ThreadData[MoccasinKey];
                if (moccasin == null) {
                    moccasin = new Pen(Color.Moccasin, true);
                    SafeNativeMethods.ThreadData[MoccasinKey] = moccasin;
                }
                return moccasin;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.NavajoWhite"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen NavajoWhite {
            get {
                Pen navajoWhite = (Pen)SafeNativeMethods.ThreadData[NavajoWhiteKey];
                if (navajoWhite == null) {
                    navajoWhite = new Pen(Color.NavajoWhite, true);
                    SafeNativeMethods.ThreadData[NavajoWhiteKey] = navajoWhite;
                }
                return navajoWhite;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Navy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Navy {
            get {
                Pen navy = (Pen)SafeNativeMethods.ThreadData[NavyKey];
                if (navy == null) {
                    navy = new Pen(Color.Navy, true);
                    SafeNativeMethods.ThreadData[NavyKey] = navy;
                }
                return navy;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.OldLace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen OldLace {
            get {
                Pen oldLace = (Pen)SafeNativeMethods.ThreadData[OldLaceKey];
                if (oldLace == null) {
                    oldLace = new Pen(Color.OldLace, true);
                    SafeNativeMethods.ThreadData[OldLaceKey] = oldLace;
                }
                return oldLace;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Olive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Olive {
            get {
                Pen olive = (Pen)SafeNativeMethods.ThreadData[OliveKey];
                if (olive == null) {
                    olive = new Pen(Color.Olive, true);
                    SafeNativeMethods.ThreadData[OliveKey] = olive;
                }
                return olive;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.OliveDrab"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen OliveDrab {
            get {
                Pen oliveDrab = (Pen)SafeNativeMethods.ThreadData[OliveDrabKey];
                if (oliveDrab == null) {
                    oliveDrab = new Pen(Color.OliveDrab, true);
                    SafeNativeMethods.ThreadData[OliveDrabKey] = oliveDrab;
                }
                return oliveDrab;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Orange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Orange {
            get {
                Pen orange = (Pen)SafeNativeMethods.ThreadData[OrangeKey];
                if (orange == null) {
                    orange = new Pen(Color.Orange, true);
                    SafeNativeMethods.ThreadData[OrangeKey] = orange;
                }
                return orange;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.OrangeRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen OrangeRed {
            get {
                Pen orangeRed = (Pen)SafeNativeMethods.ThreadData[OrangeRedKey];
                if (orangeRed == null) {
                    orangeRed = new Pen(Color.OrangeRed, true);
                    SafeNativeMethods.ThreadData[OrangeRedKey] = orangeRed;
                }
                return orangeRed;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Orchid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Orchid {
            get {
                Pen orchid = (Pen)SafeNativeMethods.ThreadData[OrchidKey];
                if (orchid == null) {
                    orchid = new Pen(Color.Orchid, true);
                    SafeNativeMethods.ThreadData[OrchidKey] = orchid;
                }
                return orchid;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PaleGoldenrod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PaleGoldenrod {
            get {
                Pen paleGoldenrod = (Pen)SafeNativeMethods.ThreadData[PaleGoldenrodKey];
                if (paleGoldenrod == null) {
                    paleGoldenrod = new Pen(Color.PaleGoldenrod, true);
                    SafeNativeMethods.ThreadData[PaleGoldenrodKey] = paleGoldenrod;
                }
                return paleGoldenrod;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PaleGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PaleGreen {
            get {
                Pen paleGreen = (Pen)SafeNativeMethods.ThreadData[PaleGreenKey];
                if (paleGreen == null) {
                    paleGreen = new Pen(Color.PaleGreen, true);
                    SafeNativeMethods.ThreadData[PaleGreenKey] = paleGreen;
                }
                return paleGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PaleTurquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PaleTurquoise {
            get {
                Pen paleTurquoise = (Pen)SafeNativeMethods.ThreadData[PaleTurquoiseKey];
                if (paleTurquoise == null) {
                    paleTurquoise = new Pen(Color.PaleTurquoise, true);
                    SafeNativeMethods.ThreadData[PaleTurquoiseKey] = paleTurquoise;
                }
                return paleTurquoise;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PaleVioletRed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PaleVioletRed {
            get {
                Pen paleVioletRed = (Pen)SafeNativeMethods.ThreadData[PaleVioletRedKey];
                if (paleVioletRed == null) {
                    paleVioletRed = new Pen(Color.PaleVioletRed, true);
                    SafeNativeMethods.ThreadData[PaleVioletRedKey] = paleVioletRed;
                }
                return paleVioletRed;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PapayaWhip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PapayaWhip {
            get {
                Pen papayaWhip = (Pen)SafeNativeMethods.ThreadData[PapayaWhipKey];
                if (papayaWhip == null) {
                    papayaWhip = new Pen(Color.PapayaWhip, true);
                    SafeNativeMethods.ThreadData[PapayaWhipKey] = papayaWhip;
                }
                return papayaWhip;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PeachPuff"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PeachPuff {
            get {
                Pen peachPuff = (Pen)SafeNativeMethods.ThreadData[PeachPuffKey];
                if (peachPuff == null) {
                    peachPuff = new Pen(Color.PeachPuff, true);
                    SafeNativeMethods.ThreadData[PeachPuffKey] = peachPuff;
                }
                return peachPuff;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Peru"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Peru {
            get {
                Pen peru = (Pen)SafeNativeMethods.ThreadData[PeruKey];
                if (peru == null) {
                    peru = new Pen(Color.Peru, true);
                    SafeNativeMethods.ThreadData[PeruKey] = peru;
                }
                return peru;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Pink"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Pink {
            get {
                Pen pink = (Pen)SafeNativeMethods.ThreadData[PinkKey];
                if (pink == null) {
                    pink = new Pen(Color.Pink, true);
                    SafeNativeMethods.ThreadData[PinkKey] = pink;
                }
                return pink;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Plum"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Plum {
            get {
                Pen plum = (Pen)SafeNativeMethods.ThreadData[PlumKey];
                if (plum == null) {
                    plum = new Pen(Color.Plum, true);
                    SafeNativeMethods.ThreadData[PlumKey] = plum;
                }
                return plum;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.PowderBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen PowderBlue {
            get {
                Pen powderBlue = (Pen)SafeNativeMethods.ThreadData[PowderBlueKey];
                if (powderBlue == null) {
                    powderBlue = new Pen(Color.PowderBlue, true);
                    SafeNativeMethods.ThreadData[PowderBlueKey] = powderBlue;
                }
                return powderBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Purple"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Purple {
            get {
                Pen purple = (Pen)SafeNativeMethods.ThreadData[PurpleKey];
                if (purple == null) {
                    purple = new Pen(Color.Purple, true);
                    SafeNativeMethods.ThreadData[PurpleKey] = purple;
                }
                return purple;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Red"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Red {
            get {
                Pen red = (Pen)SafeNativeMethods.ThreadData[RedKey];
                if (red == null) {
                    red = new Pen(Color.Red, true);
                    SafeNativeMethods.ThreadData[RedKey] = red;
                }
                return red;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.RosyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen RosyBrown {
            get {
                Pen rosyBrown = (Pen)SafeNativeMethods.ThreadData[RosyBrownKey];
                if (rosyBrown == null) {
                    rosyBrown = new Pen(Color.RosyBrown, true);
                    SafeNativeMethods.ThreadData[RosyBrownKey] = rosyBrown;
                }
                return rosyBrown;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.RoyalBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen RoyalBlue {
            get {
                Pen royalBlue = (Pen)SafeNativeMethods.ThreadData[RoyalBlueKey];
                if (royalBlue == null) {
                    royalBlue = new Pen(Color.RoyalBlue, true);
                    SafeNativeMethods.ThreadData[RoyalBlueKey] = royalBlue;
                }
                return royalBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SaddleBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SaddleBrown {
            get {
                Pen saddleBrown = (Pen)SafeNativeMethods.ThreadData[SaddleBrownKey];
                if (saddleBrown == null) {
                    saddleBrown = new Pen(Color.SaddleBrown, true);
                    SafeNativeMethods.ThreadData[SaddleBrownKey] = saddleBrown;
                }
                return saddleBrown;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Salmon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Salmon {
            get {
                Pen salmon = (Pen)SafeNativeMethods.ThreadData[SalmonKey];
                if (salmon == null) {
                    salmon = new Pen(Color.Salmon, true);
                    SafeNativeMethods.ThreadData[SalmonKey] = salmon;
                }
                return salmon;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SandyBrown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SandyBrown {
            get {
                Pen sandyBrown = (Pen)SafeNativeMethods.ThreadData[SandyBrownKey];
                if (sandyBrown == null) {
                    sandyBrown = new Pen(Color.SandyBrown, true);
                    SafeNativeMethods.ThreadData[SandyBrownKey] = sandyBrown;
                }
                return sandyBrown;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SeaGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SeaGreen {
            get {
                Pen seaGreen = (Pen)SafeNativeMethods.ThreadData[SeaGreenKey];
                if (seaGreen == null) {
                    seaGreen = new Pen(Color.SeaGreen, true);
                    SafeNativeMethods.ThreadData[SeaGreenKey] = seaGreen;
                }
                return seaGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SeaShell"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SeaShell {
            get {
                Pen seaShell = (Pen)SafeNativeMethods.ThreadData[SeaShellKey];
                if (seaShell == null) {
                    seaShell = new Pen(Color.SeaShell, true);
                    SafeNativeMethods.ThreadData[SeaShellKey] = seaShell;
                }
                return seaShell;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Sienna"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Sienna {
            get {
                Pen sienna = (Pen)SafeNativeMethods.ThreadData[SiennaKey];
                if (sienna == null) {
                    sienna = new Pen(Color.Sienna, true);
                    SafeNativeMethods.ThreadData[SiennaKey] = sienna;
                }
                return sienna;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Silver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Silver {
            get {
                Pen silver = (Pen)SafeNativeMethods.ThreadData[SilverKey];
                if (silver == null) {
                    silver = new Pen(Color.Silver, true);
                    SafeNativeMethods.ThreadData[SilverKey] = silver;
                }
                return silver;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SkyBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SkyBlue {
            get {
                Pen skyBlue = (Pen)SafeNativeMethods.ThreadData[SkyBlueKey];
                if (skyBlue == null) {
                    skyBlue = new Pen(Color.SkyBlue, true);
                    SafeNativeMethods.ThreadData[SkyBlueKey] = skyBlue;
                }
                return skyBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SlateBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SlateBlue {
            get {
                Pen slateBlue = (Pen)SafeNativeMethods.ThreadData[SlateBlueKey];
                if (slateBlue == null) {
                    slateBlue = new Pen(Color.SlateBlue, true);
                    SafeNativeMethods.ThreadData[SlateBlueKey] = slateBlue;
                }
                return slateBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SlateGray"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SlateGray {
            get {
                Pen slateGray = (Pen)SafeNativeMethods.ThreadData[SlateGrayKey];
                if (slateGray == null) {
                    slateGray = new Pen(Color.SlateGray, true);
                    SafeNativeMethods.ThreadData[SlateGrayKey] = slateGray;
                }
                return slateGray;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Snow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Snow {
            get {
                Pen snow = (Pen)SafeNativeMethods.ThreadData[SnowKey];
                if (snow == null) {
                    snow = new Pen(Color.Snow, true);
                    SafeNativeMethods.ThreadData[SnowKey] = snow;
                }
                return snow;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SpringGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SpringGreen {
            get {
                Pen springGreen = (Pen)SafeNativeMethods.ThreadData[SpringGreenKey];
                if (springGreen == null) {
                    springGreen = new Pen(Color.SpringGreen, true);
                    SafeNativeMethods.ThreadData[SpringGreenKey] = springGreen;
                }
                return springGreen;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.SteelBlue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen SteelBlue {
            get {
                Pen steelBlue = (Pen)SafeNativeMethods.ThreadData[SteelBlueKey];
                if (steelBlue == null) {
                    steelBlue = new Pen(Color.SteelBlue, true);
                    SafeNativeMethods.ThreadData[SteelBlueKey] = steelBlue;
                }
                return steelBlue;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Tan"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Tan {
            get {
                Pen tan = (Pen)SafeNativeMethods.ThreadData[TanKey];
                if (tan == null) {
                    tan = new Pen(Color.Tan, true);
                    SafeNativeMethods.ThreadData[TanKey] = tan;
                }
                return tan;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Teal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Teal {
            get {
                Pen teal = (Pen)SafeNativeMethods.ThreadData[TealKey];
                if (teal == null) {
                    teal = new Pen(Color.Teal, true);
                    SafeNativeMethods.ThreadData[TealKey] = teal;
                }
                return teal;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Thistle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Thistle {
            get {
                Pen thistle = (Pen)SafeNativeMethods.ThreadData[ThistleKey];
                if (thistle == null) {
                    thistle = new Pen(Color.Thistle, true);
                    SafeNativeMethods.ThreadData[ThistleKey] = thistle;
                }
                return thistle;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Tomato"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Tomato {
            get {
                Pen tomato = (Pen)SafeNativeMethods.ThreadData[TomatoKey];
                if (tomato == null) {
                    tomato = new Pen(Color.Tomato, true);
                    SafeNativeMethods.ThreadData[TomatoKey] = tomato;
                }
                return tomato;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Turquoise"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Turquoise {
            get {
                Pen turquoise = (Pen)SafeNativeMethods.ThreadData[TurquoiseKey];
                if (turquoise == null) {
                    turquoise = new Pen(Color.Turquoise, true);
                    SafeNativeMethods.ThreadData[TurquoiseKey] = turquoise;
                }
                return turquoise;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Violet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Violet {
            get {
                Pen violet = (Pen)SafeNativeMethods.ThreadData[VioletKey];
                if (violet == null) {
                    violet = new Pen(Color.Violet, true);
                    SafeNativeMethods.ThreadData[VioletKey] = violet;
                }
                return violet;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Wheat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Wheat {
            get {
                Pen wheat = (Pen)SafeNativeMethods.ThreadData[WheatKey];
                if (wheat == null) {
                    wheat = new Pen(Color.Wheat, true);
                    SafeNativeMethods.ThreadData[WheatKey] = wheat;
                }
                return wheat;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.White"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen White {
            get {
                Pen white = (Pen)SafeNativeMethods.ThreadData[WhiteKey];
                if (white == null) {
                    white = new Pen(Color.White, true);
                    SafeNativeMethods.ThreadData[WhiteKey] = white;
                }
                return white;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.WhiteSmoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen WhiteSmoke {
            get {
                Pen whiteSmoke = (Pen)SafeNativeMethods.ThreadData[WhiteSmokeKey];
                if (whiteSmoke == null) {
                    whiteSmoke = new Pen(Color.WhiteSmoke, true);
                    SafeNativeMethods.ThreadData[WhiteSmokeKey] = whiteSmoke;
                }
                return whiteSmoke;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.Yellow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen Yellow {
            get {
                Pen yellow = (Pen)SafeNativeMethods.ThreadData[YellowKey];
                if (yellow == null) {
                    yellow = new Pen(Color.Yellow, true);
                    SafeNativeMethods.ThreadData[YellowKey] = yellow;
                }
                return yellow;
            }
        }

        /// <include file='doc\Pens.uex' path='docs/doc[@for="Pens.YellowGreen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen YellowGreen {
            get {
                Pen yellowGreen = (Pen)SafeNativeMethods.ThreadData[YellowGreenKey];
                if (yellowGreen == null) {
                    yellowGreen = new Pen(Color.YellowGreen, true);
                    SafeNativeMethods.ThreadData[YellowGreenKey] = yellowGreen;
                }
                return yellowGreen;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\sizeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SizeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter"]/*' />
    /// <devdoc>
    ///      SizeConverter is a class that can be used to convert
    ///      Size from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class SizeConverter : TypeConverter {
    
        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
            
                string text = ((string)value).Trim();
            
                if (text.Length == 0) {
                    return null;
                }
                else {
                
                    // Parse 2 integer values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});
                    int[] values = new int[tokens.Length];
                    TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                    for (int i = 0; i < values.Length; i++) {
                        values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                    }
                    
                    if (values.Length == 2) {
                        return new Size(values[0], values[1]);
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  text,
                                                                  "Width,Height"));
                    }
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is Size) {
                Size size = (Size)value;

                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }
                string sep = culture.TextInfo.ListSeparator + " ";
                TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                string[] args = new string[2];
                int nArg = 0;
                
                args[nArg++] = intConverter.ConvertToString(context, culture, size.Width);
                args[nArg++] = intConverter.ConvertToString(context, culture, size.Height);
                
                return string.Join(sep, args);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Size) {
                Size size = (Size)value;

                ConstructorInfo ctor = typeof(Size).GetConstructor(new Type[] {typeof(int), typeof(int)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {size.Width, size.Height});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new Size((int)propertyValues["Width"],
                            (int)propertyValues["Height"]);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(Size), attributes);
            return props.Sort(new string[] {"Width", "Height"});
        }

       
        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\solidbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="SolidBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   SolidBrush.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ SolidBrush objects
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;    
    using System.ComponentModel;
    using System.Drawing.Internal;

    /**
     * Represent a SolidBrush brush object
     */
    /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines a brush made up of a single color. Brushes are
    ///       used to fill graphics shapes such as rectangles, ellipses, pies, polygons, and paths.
    ///    </para>
    /// </devdoc>
    public sealed class SolidBrush : Brush, ISystemColorTracker {
        // GDI+ doesn't understand system colors, so we need to cache the value here
        private Color color;
        private bool immutable = false;

        internal SolidBrush() {
            nativeBrush = IntPtr.Zero;
        }

        /**
         * Create a new solid fill brush object
         */
        /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush.SolidBrush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.SolidBrush'/> class of the specified
        ///       color.
        ///    </para>
        /// </devdoc>
        public SolidBrush(Color color) {
            this.color = color;
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateSolidFill(color.ToArgb(), out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);

            if (color.IsSystemColor)
                SystemColorTracker.Add(this);
        }

        internal SolidBrush(Color color, bool immutable) : this(color) {
            this.immutable = immutable;
        }

        private SolidBrush(int argb) : this(System.Drawing.Color.FromArgb(argb)) {
        }

        private SolidBrush(IntPtr nativeBrush, int extra) {
            SetNativeBrush(nativeBrush);
        }

        /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.SolidBrush'/>.
        /// </devdoc>
        public override object Clone() {
            IntPtr cloneBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBrush(new HandleRef(this, nativeBrush), out cloneBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // We intentionally lose the "immutable" bit.

            return new SolidBrush(cloneBrush, 0);
        }
        
        /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (!disposing) {
                immutable = false;
            }
            else if (immutable) {
                throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Brush"));
            }
            
            base.Dispose(disposing);
        }
        
        /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush.Color"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The color of this <see cref='System.Drawing.SolidBrush'/>.
        ///    </para>
        /// </devdoc>
        public Color Color {
            get {
                if (color == Color.Empty) {
                    int colorARGB = 0;
                    int status = SafeNativeMethods.GdipGetSolidFillColor(new HandleRef(this, nativeBrush), out colorARGB);

                    if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);

                    this.color = Color.FromArgb(colorARGB);
                }

                // GDI+ doesn't understand system colors, so we can't use GdipGetSolidFillColor in the general case
                return color;
            }
            set {
                if (immutable)
                    throw new ArgumentException(SR.GetString(SR.CantChangeImmutableObjects, "Brush"));

                Color oldColor = this.color;
                InternalSetColor(value);

                // CONSIDER: We never remove brushes from the active list, so if someone is
                // changing their brush colors a lot, this could be a problem.
                if (value.IsSystemColor && !oldColor.IsSystemColor)
                    SystemColorTracker.Add(this);
            }
        }

        // Sets the color even if the brush is considered immutable
        private void InternalSetColor(Color value) {
            int status = SafeNativeMethods.GdipSetSolidFillColor(new HandleRef(this, nativeBrush), value.ToArgb());

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.color = value;
        }

        /// <include file='doc\SolidBrush.uex' path='docs/doc[@for="SolidBrush.ISystemColorTracker.OnSystemColorChanged"]/*' />
        /// <internalonly/>
        void ISystemColorTracker.OnSystemColorChanged() {
            if (nativeBrush != IntPtr.Zero)
                InternalSetColor(color);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Security;
    using System.Text;

    internal enum Win32SystemColors
    {
        ActiveBorder = 0x0A,
        ActiveCaption = 0x02,
        ActiveCaptionText = 0x09,
        AppWorkspace = 0x0C,
        Control = 0x0F,
        ControlDark = 0x10,
        ControlDarkDark = 0x15,
        ControlLight = 0x16,
        ControlLightLight = 0x14,
        ControlText = 0x12,
        Desktop = 0x01,
        GrayText = 0x11,
        Highlight = 0x0D,
        HighlightText = 0x0E,
        HotTrack = 0x1A,
        InactiveBorder = 0x0B,
        InactiveCaption = 0x03,
        InactiveCaptionText = 0x13,
        Info = 0x18,
        InfoText = 0x17,
        Menu = 0x04,
        MenuText = 0x07,
        ScrollBar = 0x00,
        Window = 0x05,
        WindowFrame = 0x06,
        WindowText = 0x08
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\systembrushes.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemBrushes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;
    using System;
    
    /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes"]/*' />
    /// <devdoc>
    ///     Brushes for select Windows system-wide colors.  Whenever possible, try to use
    ///     SystemPens and SystemBrushes rather than SystemColors.
    /// </devdoc>
    public sealed class SystemBrushes {
        static readonly object SystemBrushesKey = new object();

        private SystemBrushes() {
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ActiveBorder"]/*' />
        /// <devdoc>
        ///     Brush is the color of the active window border.
        /// </devdoc>
        public static Brush ActiveBorder {
            get {
                return FromSystemColor(SystemColors.ActiveBorder);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ActiveCaption"]/*' />
        /// <devdoc>
        ///     Brush is the color of the active caption bar.
        /// </devdoc>
        public static Brush ActiveCaption {
            get {
                return FromSystemColor(SystemColors.ActiveCaption);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ActiveCaptionText"]/*' />
        /// <devdoc>
        ///     Brush is the color of the active caption bar.
        /// </devdoc>
        public static Brush ActiveCaptionText {
            get {
                return FromSystemColor(SystemColors.ActiveCaptionText);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.AppWorkspace"]/*' />
        /// <devdoc>
        ///     Brush is the color of the app workspace window.
        /// </devdoc>
        public static Brush AppWorkspace {
            get {
                return FromSystemColor(SystemColors.AppWorkspace);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Desktop"]/*' />
        /// <devdoc>
        ///     Brush is the color of the desktop.
        /// </devdoc>
        public static Brush Desktop {
            get {
                return FromSystemColor(SystemColors.Desktop);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Control"]/*' />
        /// <devdoc>
        ///     Brush is the control color, which is the surface color for 3D elements.
        /// </devdoc>
        public static Brush Control {
            get {
                return FromSystemColor(SystemColors.Control);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ControlLightLight"]/*' />
        /// <devdoc>
        ///     Brush is the lighest part of a 3D element.
        /// </devdoc>
        public static Brush ControlLightLight {
            get {
                return FromSystemColor(SystemColors.ControlLightLight);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ControlLight"]/*' />
        /// <devdoc>
        ///     Brush is the highlight part of a 3D element.
        /// </devdoc>
        public static Brush ControlLight {
            get {
                return FromSystemColor(SystemColors.ControlLight);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ControlDark"]/*' />
        /// <devdoc>
        ///     Brush is the shadow part of a 3D element.
        /// </devdoc>
        public static Brush ControlDark {
            get {
                return FromSystemColor(SystemColors.ControlDark);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ControlDarkDark"]/*' />
        /// <devdoc>
        ///     Brush is the darkest part of a 3D element.
        /// </devdoc>
        public static Brush ControlDarkDark {
            get {
                return FromSystemColor(SystemColors.ControlDarkDark);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ControlText"]/*' />
        /// <devdoc>
        ///     Brush is the color of text on controls.
        /// </devdoc>
        public static Brush ControlText {
            get {
                return FromSystemColor(SystemColors.ControlText);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Highlight"]/*' />
        /// <devdoc>
        ///     Brush is the color of the background of highlighted elements.
        /// </devdoc>
        public static Brush Highlight {
            get {
                return FromSystemColor(SystemColors.Highlight);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.HighlightText"]/*' />
        /// <devdoc>
        ///     Brush is the color of the foreground of highlighted elements.
        /// </devdoc>
        public static Brush HighlightText {
            get {
                return FromSystemColor(SystemColors.HighlightText);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.HotTrack"]/*' />
        /// <devdoc>
        ///     Brush is the color used to represent hot tracking.
        /// </devdoc>
        public static Brush HotTrack {
            get {
                return FromSystemColor(SystemColors.HotTrack);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.InactiveCaption"]/*' />
        /// <devdoc>
        ///     Brush is the color of an inactive caption bar.
        /// </devdoc>
        public static Brush InactiveCaption {
            get {
                return FromSystemColor(SystemColors.InactiveCaption);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.InactiveBorder"]/*' />
        /// <devdoc>
        ///     Brush is the color if an inactive window border.
        /// </devdoc>
        public static Brush InactiveBorder {
            get {
                return FromSystemColor(SystemColors.InactiveBorder);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Info"]/*' />
        /// <devdoc>
        ///     Brush is the color of the background of the info tooltip.
        /// </devdoc>
        public static Brush Info {
            get {
                return FromSystemColor(SystemColors.Info);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Menu"]/*' />
        /// <devdoc>
        ///     Brush is the color of the menu background.
        /// </devdoc>
        public static Brush Menu {
            get {
                return FromSystemColor(SystemColors.Menu);
            }
        }
        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.ScrollBar"]/*' />
        /// <devdoc>
        ///     Brush is the color of a scroll bar background.
        /// </devdoc>
        public static Brush ScrollBar {
            get {
                return FromSystemColor(SystemColors.ScrollBar);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.Window"]/*' />
        /// <devdoc>
        ///     Brush is the color of the window background.
        /// </devdoc>
        public static Brush Window {
            get {
                return FromSystemColor(SystemColors.Window);
            }
        }
        
        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.WindowText"]/*' />
        /// <devdoc>
        ///     Brush is the color of text on controls.
        /// </devdoc>
        public static Brush WindowText {
            get {
                return FromSystemColor(SystemColors.WindowText);
            }
        }

        /// <include file='doc\SystemBrushes.uex' path='docs/doc[@for="SystemBrushes.FromSystemColor"]/*' />
        /// <devdoc>
        ///     Retrieves a brush given a system color.  An error will be raised
        ///     if the color provide is not a system color.
        /// </devdoc>
        public static Brush FromSystemColor(Color c) {
            if (!c.IsSystemColor) {
                throw new ArgumentException(SR.GetString(SR.ColorNotSystemColor, c.ToString()));
            }
            Brush[] systemBrushes = (Brush[])SafeNativeMethods.ThreadData[SystemBrushesKey];
            if (systemBrushes == null) {        
                systemBrushes = new Brush[(int)KnownColor.WindowText];
                SafeNativeMethods.ThreadData[SystemBrushesKey] = systemBrushes;
            }
            int idx = (int)c.ToKnownColor() - 1;
            Debug.Assert(idx >= 0 && idx < systemBrushes.Length, "System colors have been added but our system color array has not been expanded.");

            if (systemBrushes[idx] == null) {
                systemBrushes[idx] = new SolidBrush(c, true);
            }
            
            return systemBrushes[idx];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\size.cs ===
//------------------------------------------------------------------------------
// <copyright file="Size.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Size.cs
*
* Abstract:
*
*   Integer-point coordinate size class
*
* Revision History:
*
*   2/4/2k ericvan
*       Created it.
*
\**************************************************************************/
namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;
    

    /**
     * Represents a dimension in 2D coordinate space
     */
    /// <include file='doc\Size.uex' path='docs/doc[@for="Size"]/*' />
    /// <devdoc>
    ///    Represents the size of a rectangular region
    ///    with an ordered pair of width and height.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(SizeConverter)),
    ]
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(true)]
    public struct Size {

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Empty"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Size'/> class.
        /// </devdoc>
        public static readonly Size Empty = new Size();

        private int width;
        private int height;

        /**
         * Create a new Size object from a point
         */
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Size'/> class from
        ///       the specified <see cref='System.Drawing.Point'/>.
        ///    </para>
        /// </devdoc>
        public Size(Point pt) {
            width = pt.X;
            height = pt.Y;
        }

        /**
         * Create a new Size object of the specified dimension
         */
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Size1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Size'/> class from
        ///    the specified dimensions.
        /// </devdoc>
        public Size(int width, int height) {
            this.width = width;
            this.height = height;
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operatorSizeF"]/*' />
        /// <devdoc>
        ///    Converts the specified <see cref='System.Drawing.Size'/> to a
        /// <see cref='System.Drawing.SizeF'/>.
        /// </devdoc>
        public static implicit operator SizeF(Size p) {
            return new SizeF(p.Width, p.Height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operator+"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs vector addition of two <see cref='System.Drawing.Size'/> objects.
        ///    </para>
        /// </devdoc>
        public static Size operator +(Size sz1, Size sz2) {
            return new Size(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operator-"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contracts a <see cref='System.Drawing.Size'/> by another <see cref='System.Drawing.Size'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public static Size operator -(Size sz1, Size sz2) {
            return new Size(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operator=="]/*' />
        /// <devdoc>
        ///    Tests whether two <see cref='System.Drawing.Size'/> objects
        ///    are identical.
        /// </devdoc>
        public static bool operator ==(Size sz1, Size sz2) {
            return sz1.Width == sz2.Width && sz1.Height == sz2.Height;
        }
        
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.Size'/> objects are different.
        ///    </para>
        /// </devdoc>
        public static bool operator !=(Size sz1, Size sz2) {
            return !(sz1 == sz2);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.operatorPoint"]/*' />
        /// <devdoc>
        ///    Converts the specified <see cref='System.Drawing.Size'/> to a
        /// <see cref='System.Drawing.Point'/>.
        /// </devdoc>
        public static explicit operator Point(Size size) {
            return new Point(size.Width, size.Height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.IsEmpty"]/*' />
        /// <devdoc>
        ///    Tests whether this <see cref='System.Drawing.Size'/> has zero
        ///    width and height.
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return width == 0 && height == 0;
            }
        }
        
        /**
         * Horizontal dimension
         */
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the horizontal component of this
        ///    <see cref='System.Drawing.Size'/>.
        ///    </para>
        /// </devdoc>
        public int Width {
            get {
                return width;
            }
            set {
                width = value;
            }
        }

        /**
         * Vertical dimension
         */
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Height"]/*' />
        /// <devdoc>
        ///    Represents the vertical component of this
        /// <see cref='System.Drawing.Size'/>.
        /// </devdoc>
        public int Height {
            get {
                return height;
            }
            set {
                height = value;
            }
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Ceiling"]/*' />
        /// <devdoc>
        ///   Converts a SizeF to a Size by performing a ceiling operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Size Ceiling(SizeF value) {
            return new Size((int)Math.Ceiling(value.Width), (int)Math.Ceiling(value.Height));
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Truncate"]/*' />
        /// <devdoc>
        ///   Converts a SizeF to a Size by performing a truncate operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Size Truncate(SizeF value) {
            return new Size((int)value.Width, (int)value.Height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Round"]/*' />
        /// <devdoc>
        ///   Converts a SizeF to a Size by performing a round operation on
        ///   all the coordinates.
        /// </devdoc>
        public static Size Round(SizeF value) {
            return new Size((int)Math.Round(value.Width), (int)Math.Round(value.Height));
        }
        
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests to see whether the specified object is a
        ///    <see cref='System.Drawing.Size'/> 
        ///    with the same dimensions as this <see cref='System.Drawing.Size'/>.
        /// </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is Size)) 
                return false;
            
            Size comp = (Size)obj;
            // Note value types can't have derived classes, so we don't need to 
            // check the types of the objects here.  -- BrianGru, 2/21/2001
            return (comp.width == this.width) && 
                   (comp.height == this.height);
        }

        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a hash code.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return width ^ height;
        }
        
        /// <include file='doc\Size.uex' path='docs/doc[@for="Size.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a human-readable string that represents this
        ///    <see cref='System.Drawing.Size'/>.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "{Width=" + width.ToString() + ", Height=" + height.ToString() + "}";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\adjustablearrowcap.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdjustableArrowCap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AdjustableArrowCap.cs
*
* Abstract:
*
*   Native GDI+ AdjustableArrowCap structure.
*
* Revision History:
*
*   3/14/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;

    /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap"]/*' />
    /// <devdoc>
    ///    Represents an adjustable arrow-shaped line
    ///    cap.
    /// </devdoc>
    public sealed class AdjustableArrowCap : CustomLineCap {

        internal AdjustableArrowCap(IntPtr nativeCap) : 
            base(nativeCap) {}
                    
        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.AdjustableArrowCap"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.AdjustableArrowCap'/> class with the specified width and
        ///    height.
        /// </devdoc>
        public AdjustableArrowCap(float width,
                                  float height) :
            this(width, height, true) {}
            
        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.AdjustableArrowCap1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.AdjustableArrowCap'/> class with the specified width,
        ///       height, and fill property.
        ///    </para>
        /// </devdoc>
        public AdjustableArrowCap(float width,
                                  float height,
                                  bool isFilled)
        {
            IntPtr nativeCap = IntPtr.Zero;
            
            int status = SafeNativeMethods.GdipCreateAdjustableArrowCap(
                                height, width, isFilled, out nativeCap);
                                
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            SetNativeLineCap(nativeCap);
        }

        private void _SetHeight(float height)
        {
            int status = SafeNativeMethods.GdipSetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), height);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private float _GetHeight()
        {
            float height;
            int status = SafeNativeMethods.GdipGetAdjustableArrowCapHeight(new HandleRef(this, nativeCap), out height);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return height;
        }

        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.Height"]/*' />
        /// <devdoc>
        ///    Gets or sets the height of the arrow cap.
        /// </devdoc>
        public float Height
        {
            get { return _GetHeight(); }
            set { _SetHeight(value); }
        }
        
        private void _SetWidth(float width)
        {
            int status = SafeNativeMethods.GdipSetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), width);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private float _GetWidth()
        {
            float width;
            int status = SafeNativeMethods.GdipGetAdjustableArrowCapWidth(new HandleRef(this, nativeCap), out width);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return width;
        }

        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.Width"]/*' />
        /// <devdoc>
        ///    Gets or sets the width of the arrow cap.
        /// </devdoc>
        public float Width
        {
            get { return _GetWidth(); }
            set { _SetWidth(value); }
        }
        
        private void _SetMiddleInset(float middleInset)
        {
            int status = SafeNativeMethods.GdipSetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), middleInset);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
    
        private float _GetMiddleInset()
        {
            float middleInset;
            int status = SafeNativeMethods.GdipGetAdjustableArrowCapMiddleInset(new HandleRef(this, nativeCap), out middleInset);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return middleInset;
        }

        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.MiddleInset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or set the number of pixels between the outline of the arrow cap and the fill.
        ///    </para>
        /// </devdoc>
        public float MiddleInset
        {
            get { return _GetMiddleInset(); }
            set { _SetMiddleInset(value); }
        }
        
        private void _SetFillState(bool isFilled)
        {
            int status = SafeNativeMethods.GdipSetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), isFilled);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private bool _IsFilled()
        {
            bool isFilled = false;
            int status = SafeNativeMethods.GdipGetAdjustableArrowCapFillState(new HandleRef(this, nativeCap), out isFilled);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isFilled;
        }

        /// <include file='doc\AdjustableArrowCap.uex' path='docs/doc[@for="AdjustableArrowCap.Filled"]/*' />
        /// <devdoc>
        ///    Gets or sets a value indicating whether the
        ///    arrow cap is filled.
        /// </devdoc>
        public bool Filled
        {
            get { return _IsFilled(); }
            set { _SetFillState(value); }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\systemcolors.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemColors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;

    using System;
    

    /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors"]/*' />
    /// <devdoc>
    ///     Windows system-wide colors.  Whenever possible, try to use
    ///     SystemPens and SystemBrushes rather than SystemColors.
    /// </devdoc>
    public sealed class SystemColors {

        // not creatable...
        //
        private SystemColors() {
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ActiveBorder"]/*' />
        /// <devdoc>
        ///     The color of the filled area of an active window border.
        /// </devdoc>
        public static Color ActiveBorder {
            get {
                return new Color(KnownColor.ActiveBorder);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ActiveCaption"]/*' />
        /// <devdoc>
        ///     The color of the background of an active title bar caption.
        /// </devdoc>
        public static Color ActiveCaption {
            get {
                return new Color(KnownColor.ActiveCaption);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ActiveCaptionText"]/*' />
        /// <devdoc>
        ///     The color of the text of an active title bar caption.
        /// </devdoc>
        public static Color ActiveCaptionText {
            get {
                return new Color(KnownColor.ActiveCaptionText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.AppWorkspace"]/*' />
        /// <devdoc>
        ///     The color of the application workspace.  The application workspace
        ///     is the area in a multiple document view that is not being occupied
        ///     by documents.
        /// </devdoc>
        public static Color AppWorkspace {
            get {
                return new Color(KnownColor.AppWorkspace);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Control"]/*' />
        /// <devdoc>
        ///     The color of the background of push buttons and other 3D objects.
        /// </devdoc>
        public static Color Control {
            get {
                return new Color(KnownColor.Control);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ControlDark"]/*' />
        /// <devdoc>
        ///     The color of shadows on 3D objects.
        /// </devdoc>
        public static Color ControlDark {
            get {
                return new Color(KnownColor.ControlDark);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ControlDarkDark"]/*' />
        /// <devdoc>
        ///     The color of very dark shadows on 3D objects.
        /// </devdoc>
        public static Color ControlDarkDark {
            get {
                return new Color(KnownColor.ControlDarkDark);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ControlLight"]/*' />
        /// <devdoc>
        ///     The color of highlights on 3D objects.
        /// </devdoc>
        public static Color ControlLight {
            get {
                return new Color(KnownColor.ControlLight);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ControlLightLight"]/*' />
        /// <devdoc>
        ///     The color of very light highlights on 3D objects.
        /// </devdoc>
        public static Color ControlLightLight {
            get {
                return new Color(KnownColor.ControlLightLight);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ControlText"]/*' />
        /// <devdoc>
        ///     The color of the text of push buttons and other 3D objects
        /// </devdoc>
        public static Color ControlText {
            get {
                return new Color(KnownColor.ControlText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Desktop"]/*' />
        /// <devdoc>
        ///     This color is the user-defined color of the Windows desktop.
        /// </devdoc>
        public static Color Desktop {
            get {
                return new Color(KnownColor.Desktop);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.GrayText"]/*' />
        /// <devdoc>
        ///     The color of text that is being shown in a disabled, or grayed-out
        ///     state.
        /// </devdoc>
        public static Color GrayText {
            get {
                return new Color(KnownColor.GrayText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Highlight"]/*' />
        /// <devdoc>
        ///     The color of the background of highlighted text.  This includes
        ///     selected menu items as well as selected text.
        /// </devdoc>
        public static Color Highlight {
            get {
                return new Color(KnownColor.Highlight);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.HighlightText"]/*' />
        /// <devdoc>
        ///     The color of the text of highlighted text.  This includes
        ///     selected menu items as well as selected text.
        /// </devdoc>
        public static Color HighlightText {
            get {
                return new Color(KnownColor.HighlightText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.HotTrack"]/*' />
        /// <devdoc>
        ///     The hot track color.
        /// </devdoc>
        public static Color HotTrack {
            get {
                return new Color(KnownColor.HotTrack);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.InactiveBorder"]/*' />
        /// <devdoc>
        ///     The color of the filled area of an inactive window border.
        /// </devdoc>
        public static Color InactiveBorder {
            get {
                return new Color(KnownColor.InactiveBorder);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.InactiveCaption"]/*' />
        /// <devdoc>
        ///     The color of the background of an inactive title bar caption.
        /// </devdoc>
        public static Color InactiveCaption {
            get {
                return new Color(KnownColor.InactiveCaption);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.InactiveCaptionText"]/*' />
        /// <devdoc>
        ///     The color of the text of an inactive title bar caption.
        /// </devdoc>
        public static Color InactiveCaptionText {
            get {
                return new Color(KnownColor.InactiveCaptionText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Info"]/*' />
        /// <devdoc>
        ///     The color of the info/tool tip background.
        /// </devdoc>
        public static Color Info {
            get {
                return new Color(KnownColor.Info);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.InfoText"]/*' />
        /// <devdoc>
        ///     The color of the info/tool tip text.
        /// </devdoc>
        public static Color InfoText {
            get {
                return new Color(KnownColor.InfoText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Menu"]/*' />
        /// <devdoc>
        ///     The color of the background of a menu.
        /// </devdoc>
        public static Color Menu {
            get {
                return new Color(KnownColor.Menu);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.MenuText"]/*' />
        /// <devdoc>
        ///     The color of the text on a menu.
        /// </devdoc>
        public static Color MenuText {
            get {
                return new Color(KnownColor.MenuText);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.ScrollBar"]/*' />
        /// <devdoc>
        ///     The color of the scroll bar area that is not being used by the
        ///     thumb button.
        /// </devdoc>
        public static Color ScrollBar {
            get {
                return new Color(KnownColor.ScrollBar);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.Window"]/*' />
        /// <devdoc>
        ///     The color of the client area of a window.
        /// </devdoc>
        public static Color Window {
            get {
                return new Color(KnownColor.Window);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.WindowFrame"]/*' />
        /// <devdoc>
        ///     The color of the thin frame drawn around a window.
        /// </devdoc>
        public static Color WindowFrame {
            get {
                return new Color(KnownColor.WindowFrame);
            }
        }

        /// <include file='doc\SystemColors.uex' path='docs/doc[@for="SystemColors.WindowText"]/*' />
        /// <devdoc>
        ///     The color of the text in the client area of a window.
        /// </devdoc>
        public static Color WindowText {
            get {
                return new Color(KnownColor.WindowText);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr GetProcessWindowStation();
        [DllImport(ExternDll.User32, SetLastError=true)]
        public static extern bool GetUserObjectInformation(HandleRef hObj, int nIndex, [MarshalAs(UnmanagedType.LPStruct)] SafeNativeMethods.USEROBJECTFLAGS pvBuffer, int nLength, ref int lpnLengthNeeded);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref SafeNativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern bool PeekMessageA([In, Out] ref SafeNativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern bool PeekMessageW([In, Out] ref SafeNativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="GetDC", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntGetDC(HandleRef hWnd);
        public static IntPtr GetDC(HandleRef hWnd) {
            return HandleCollector.Add(IntGetDC(hWnd), SafeNativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="ReleaseDC", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);
        public static int ReleaseDC(HandleRef hWnd, HandleRef hDC) {
            HandleCollector.Remove((IntPtr)hDC, SafeNativeMethods.CommonHandles.HDC);
            return IntReleaseDC(hWnd, hDC);
        }

        [DllImport(ExternDll.Gdi32, EntryPoint="CreateDC", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef /*DEVMODE*/ lpInitData);
        public static IntPtr CreateDC(String lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef /*DEVMODE*/ lpInitData) {
            return HandleCollector.Add(IntCreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), SafeNativeMethods.CommonHandles.HDC);
        }

        [DllImport(ExternDll.Gdi32, EntryPoint="CreateIC", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef /*DEVMODE*/ lpInitData);
        public static IntPtr CreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, HandleRef /*DEVMODE*/ lpInitData) {
            return HandleCollector.Add(IntCreateIC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), SafeNativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetSystemMetrics(int nIndex);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);

        // SECUNDONE : For some reason "PtrToStructure" requires super high permission.. put this 
        //           : assert here until we can get a resolution on this.
        //
        [ReflectionPermission(SecurityAction.Assert, Unrestricted=true),
            SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static object PtrToStructure(IntPtr lparam, Type cls) {
            return Marshal.PtrToStructure(lparam, cls);
        }

        // SECUNDONE : For some reason "PtrToStructure" requires super high permission.. put this 
        //           : assert here until we can get a resolution on this.
        //
        [ReflectionPermission(SecurityAction.Assert, Unrestricted=true),
            SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public static void PtrToStructure(IntPtr lparam, object data) {
            Marshal.PtrToStructure(lparam, data);
        }



        [ComImport(), Guid("0000000C-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IStream {
             int Read(
                    [In] 
                     IntPtr buf,
                    [In] 
                     int len);

            
             int Write(
                    [In] 
                     IntPtr buf,
                    [In] 
                     int len);

            [return: MarshalAs(UnmanagedType.I8)]
             long Seek(
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long dlibMove,
                    [In] 
                     int dwOrigin);

            
             void SetSize(
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long libNewSize);

            [return: MarshalAs(UnmanagedType.I8)]
             long CopyTo(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                      UnsafeNativeMethods.IStream pstm,
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long cb,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     long[] pcbRead);

            
             void Commit(
                    [In] 
                     int grfCommitFlags);

            
             void Revert();

            
             void LockRegion(
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long libOffset,
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long cb,
                    [In] 
                     int dwLockType);

            
             void UnlockRegion(
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long libOffset,
                    [In, MarshalAs(UnmanagedType.I8)] 
                     long cb,
                    [In] 
                     int dwLockType);

            
             void Stat(
                    [In] 
                     IntPtr pStatstg,
                    [In] 
                     int grfStatFlag);

            [return: MarshalAs(UnmanagedType.Interface)]
              UnsafeNativeMethods.IStream Clone();
        }
        internal class ComStreamFromDataStream : IStream {
            protected Stream dataStream;

            // to support seeking ahead of the stream length...
            long virtualPosition = -1;

            internal ComStreamFromDataStream(Stream dataStream) {
                if (dataStream == null) throw new ArgumentNullException();
                this.dataStream = dataStream;
            }

            // Don't forget to set dataStream before using this object
            protected ComStreamFromDataStream() {
            }

            private void ActualizeVirtualPosition() {
                if (virtualPosition == -1) return;

                if (virtualPosition > dataStream.Length)
                    dataStream.SetLength(virtualPosition);

                dataStream.Position = virtualPosition;

                virtualPosition = -1;
            }

            public virtual IStream Clone() {
                NotImplemented();
                return null;
            }

            public virtual void Commit(int grfCommitFlags) {
                dataStream.Flush();
                // Extend the length of the file if needed.
                ActualizeVirtualPosition();
            }

            public virtual long CopyTo(IStream pstm, long cb, long[] pcbRead) {
                int bufsize = 4096; // one page
                IntPtr buffer = Marshal.AllocHGlobal(bufsize);
                if (buffer == IntPtr.Zero) throw new OutOfMemoryException();
                long written = 0;
                try {
                    while (written < cb) {
                        int toRead = bufsize;
                        if (written + toRead > cb) toRead  = (int) (cb - written);
                        int read = Read(buffer, toRead);
                        if (read == 0) break;
                        if (pstm.Write(buffer, read) != read) {
                            throw EFail("Wrote an incorrect number of bytes");
                        }
                        written += read;
                    }
                }
                finally {
                    Marshal.FreeHGlobal(buffer);
                }
                if (pcbRead != null && pcbRead.Length > 0) {
                    pcbRead[0] = written;
                }

                return written;
            }

            public virtual Stream GetDataStream() {
                return dataStream;
            }

            public virtual void LockRegion(long libOffset, long cb, int dwLockType) {
            }

            protected static ExternalException EFail(string msg) {
                ExternalException e = new ExternalException(msg, SafeNativeMethods.E_FAIL);
                throw e;
            }

            protected static void NotImplemented() {
                ExternalException e = new ExternalException("Not implemented.", SafeNativeMethods.E_NOTIMPL);
                throw e;
            }

            public virtual int Read(IntPtr buf, /* cpr: int offset,*/  int length) {
                //        System.Text.Out.WriteLine("IStream::Read(" + length + ")");
                byte[] buffer = new byte[length];
                int count = Read(buffer, length);
                Marshal.Copy(buffer, 0, buf, length);
                return count;
            }

            public virtual int Read(byte[] buffer, /* cpr: int offset,*/  int length) {
                ActualizeVirtualPosition();
                return dataStream.Read(buffer, 0, length);
            }

            public virtual void Revert() {
                NotImplemented();
            }

            public virtual long Seek(long offset, int origin) {
                // Console.WriteLine("IStream::Seek("+ offset + ", " + origin + ")");
                long pos = virtualPosition;
                if (virtualPosition == -1) {
                    pos = dataStream.Position;
                }
                long len = dataStream.Length;
                switch (origin) {
                    case SafeNativeMethods.StreamConsts.STREAM_SEEK_SET:
                        if (offset <= len) {
                            dataStream.Position = offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = offset;
                        }
                        break;
                    case SafeNativeMethods.StreamConsts.STREAM_SEEK_END:
                        if (offset <= 0) {
                            dataStream.Position = len + offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = len + offset;
                        }
                        break;
                    case SafeNativeMethods.StreamConsts.STREAM_SEEK_CUR:
                        if (offset+pos <= len) {
                            dataStream.Position = pos + offset;
                            virtualPosition = -1;
                        }
                        else {
                            virtualPosition = offset + pos;
                        }
                        break;
                }
                if (virtualPosition != -1) {
                    return virtualPosition;
                }
                else {
                    return dataStream.Position;
                }
            }

            public virtual void SetSize(long value) {
                dataStream.SetLength(value);
            }

            public virtual void Stat(IntPtr pstatstg, int grfStatFlag) {
                // GpStream has a partial implementation, but it's so partial rather 
                // restrict it to use with GDI+
                NotImplemented();
            }

            public virtual void UnlockRegion(long libOffset, long cb, int dwLockType) {
            }

            public virtual int Write(IntPtr buf, /* cpr: int offset,*/ int length) {
                byte[] buffer = new byte[length];
                Marshal.Copy(buf, buffer, 0, length);
                return Write(buffer, length);
            }

            public virtual int Write(byte[] buffer, /* cpr: int offset,*/ int length) {
                ActualizeVirtualPosition();
                dataStream.Write(buffer, 0, length);
                return length;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\toolboxbitmapattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxBitmapAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.IO;    
    using Microsoft.Win32;

    /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute"]/*' />
    /// <devdoc>
    ///     ToolboxBitmapAttribute defines the images associated with
    ///     a specified component. The component can offer a small
    ///     and large image (large is optional).
    ///
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public class ToolboxBitmapAttribute : Attribute {

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.smallImage"]/*' />
        /// <devdoc>
        ///     The small image for this component
        /// </devdoc>
        private Image smallImage;

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.largeImage"]/*' />
        /// <devdoc>
        ///     The large image for this component.
        /// </devdoc>
        private Image largeImage;

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.largeDim"]/*' />
        /// <devdoc>
        ///     The default size of the large image.
        /// </devdoc>
        private static readonly Point largeDim = new Point(32, 32);

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.ToolboxBitmapAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new ToolboxBitmapAttribute.
        /// </devdoc>
        public ToolboxBitmapAttribute(string imageFile) : this(Image.FromFile(imageFile), null) {
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.ToolboxBitmapAttribute1"]/*' />
        /// <devdoc>
        ///     Constructs a new ToolboxBitmapAttribute.
        /// </devdoc>
        public ToolboxBitmapAttribute(Type t) : this(GetImageFromResource(t, null, false), null) {
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.ToolboxBitmapAttribute2"]/*' />
        /// <devdoc>
        ///     Constructs a new ToolboxBitmapAttribute.
        /// </devdoc>
        public ToolboxBitmapAttribute(Type t, string name) : this(GetImageFromResource(t, name, false), null) {
        }


        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.ToolboxBitmapAttribute3"]/*' />
        /// <devdoc>
        ///     Constructs a new ToolboxBitmapAttribute.
        /// </devdoc>
        private ToolboxBitmapAttribute(Image smallImage, Image largeImage) {
            this.smallImage = smallImage;
            this.largeImage = largeImage;
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object value) {
            if (value == this) {
                return true;
            }

            ToolboxBitmapAttribute attr = value as ToolboxBitmapAttribute;
            if (attr != null) {
                return attr.smallImage == smallImage && attr.largeImage == attr.smallImage;
            }

            return false;
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }
        
        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Image GetImage(object component) {
            return GetImage(component, true);
        }
        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImage1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Image GetImage(object component, bool large) {
            if (component != null) {
                return GetImage(component.GetType(), large);
            }
            return null;
        }
        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImage2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Image GetImage(Type type) {
            return GetImage(type, false);
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImage3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Image GetImage(Type type, bool large) {
            return GetImage(type, null, large);
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImage4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Image GetImage(Type type, string imgName, bool large) {

            if ((large && largeImage == null) ||
                (!large && smallImage == null)) {

                Point largeDim = new Point(32, 32);
                Image img = null;
                if (large) {
                    if (img == largeImage && smallImage != null) {
                        img = new Bitmap((Bitmap)smallImage, largeDim.X, largeDim.Y);
                    }
                    else {
                        img = largeImage;
                    }
                }
                else {
                    img = smallImage;
                }

                if (img == null) {
                    img = GetImageFromResource(type, imgName, large);
                }    
                else if (img is Bitmap) {
                    MakeBackgroundAlphaZero((Bitmap)img);
                }

                if (img == null) {
                    img = DefaultComponent.GetImage(type, large);
                }

                if (large) {
                    largeImage = img;
                }
                else {
                    smallImage = img;
                }
            }

            Image toReturn = (large) ? largeImage : smallImage;

            if (this.Equals(Default)) {
                largeImage = null;
                smallImage = null;
            }

            return toReturn;

        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.GetImageFromResource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Image GetImageFromResource(Type t, string imageName, bool large) {
            Image img = null;
            try {

                string name = imageName;

                // if we didn't get a name, use the class name
                //
                if (name == null) {
                    name = t.FullName;
                    int indexDot = name.LastIndexOf('.');
                    if (indexDot != -1) {
                        name = name.Substring(indexDot+1);
                    }
                    name += ".bmp";
                }

                // load the image from the manifest resources. 
                //
                Stream stream = t.Module.Assembly.GetManifestResourceStream(t, name);
                if (stream != null) {
                    img = new Bitmap(stream);                    
                    MakeBackgroundAlphaZero((Bitmap)img);
                    if (large) {
                        img = new Bitmap((Bitmap)img, largeDim.X, largeDim.Y);
                    }
                }
            }
            catch (Exception e) {
                Debug.Fail("Failed to load toolbox image for " + t.FullName + " " + e.ToString());
            }
            return img;

        }        

        private static void MakeBackgroundAlphaZero(Bitmap img) {
            Color bottomLeft = img.GetPixel(0, img.Height - 1);
            img.MakeTransparent();

            Color newBottomLeft = Color.FromArgb(0, bottomLeft);
            img.SetPixel(0, img.Height - 1, newBottomLeft);
        }

        /// <include file='doc\ToolboxBitmapAttribute.uex' path='docs/doc[@for="ToolboxBitmapAttribute.Default"]/*' />
        /// <devdoc>
        ///     Default name is null
        /// </devdoc>
        public static readonly ToolboxBitmapAttribute Default = new ToolboxBitmapAttribute((Image)null, (Image)null);

        private static readonly ToolboxBitmapAttribute DefaultComponent;
        static ToolboxBitmapAttribute() {
            Bitmap bitmap = null;
            Stream stream = typeof(ToolboxBitmapAttribute).Module.Assembly.GetManifestResourceStream(typeof(ToolboxBitmapAttribute), "DefaultComponent.bmp");
            if (stream != null) {
                bitmap = new Bitmap(stream);
                MakeBackgroundAlphaZero(bitmap);
            }
            DefaultComponent = new ToolboxBitmapAttribute(bitmap, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\systemicons.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemIcons.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;
    using System;

    /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons"]/*' />
    /// <devdoc>
    ///     Icon objects for Windows system-wide icons.
    /// </devdoc>
    public sealed class SystemIcons {
        private static Icon _application = null;
        private static Icon _asterisk    = null;
        private static Icon _error       = null;
        private static Icon _exclamation = null;
        private static Icon _hand        = null;
        private static Icon _information = null;
        private static Icon _question    = null;
        private static Icon _warning     = null;
        private static Icon _winlogo     = null;
        
        // not creatable...
        //
        private SystemIcons() {
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Application"]/*' />
        /// <devdoc>
        ///     Icon is the default Application icon.  (WIN32:  IDI_APPLICATION)
        /// </devdoc>
        public static Icon Application {
            get {
                if (_application == null)
                    _application = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_APPLICATION ));
                return _application;
            }
        }
        
        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Asterisk"]/*' />
        /// <devdoc>
        ///     Icon is the system Asterisk icon.  (WIN32:  IDI_ASTERISK)
        /// </devdoc>
        public static Icon Asterisk {
            get {
                if (_asterisk== null)
                    _asterisk = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_ASTERISK ));
                return _asterisk;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Error"]/*' />
        /// <devdoc>
        ///     Icon is the system Error icon.  (WIN32:  IDI_ERROR)
        /// </devdoc>
        public static Icon Error {
            get {
                if (_error == null)
                    _error = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_ERROR ));
                return _error;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Exclamation"]/*' />
        /// <devdoc>
        ///     Icon is the system Exclamation icon.  (WIN32:  IDI_EXCLAMATION)
        /// </devdoc>
        public static Icon Exclamation {
            get {
                if (_exclamation == null)
                    _exclamation = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_EXCLAMATION ));
                return _exclamation;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Hand"]/*' />
        /// <devdoc>
        ///     Icon is the system Hand icon.  (WIN32:  IDI_HAND)
        /// </devdoc>
        public static Icon Hand {
            get {
                if (_hand == null)
                    _hand = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_HAND ));
                return _hand;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Information"]/*' />
        /// <devdoc>
        ///     Icon is the system Information icon.  (WIN32:  IDI_INFORMATION)
        /// </devdoc>
        public static Icon Information {
            get {
                if (_information == null)
                    _information = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_INFORMATION ));
                return _information;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Question"]/*' />
        /// <devdoc>
        ///     Icon is the system Question icon.  (WIN32:  IDI_QUESTION)
        /// </devdoc>
        public static Icon Question {
            get {
                if (_question== null)
                    _question = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_QUESTION ));
                return _question;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.Warning"]/*' />
        /// <devdoc>
        ///     Icon is the system Warning icon.  (WIN32:  IDI_WARNING)
        /// </devdoc>
        public static Icon Warning {
            get {
                if (_warning == null)
                    _warning = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_WARNING ));
                return _warning;
            }
        }

        /// <include file='doc\SystemIcons.uex' path='docs/doc[@for="SystemIcons.WinLogo"]/*' />
        /// <devdoc>
        ///     Icon is the Windows Logo icon.  (WIN32:  IDI_WINLOGO)
        /// </devdoc>
        public static Icon WinLogo {
            get {
                if (_winlogo == null)
                    _winlogo = new Icon( SafeNativeMethods.LoadIcon( NativeMethods.NullHandleRef, SafeNativeMethods.IDI_WINLOGO ));
                return _winlogo;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\bitmapdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="BitmapData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Marshal = System.Runtime.InteropServices.Marshal;
    using System.Runtime.InteropServices;

    /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData"]/*' />
    /// <devdoc>
    ///    Specifies the attributes of a bitmap image.
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class BitmapData {
        int width;
        int height;
        int stride;
        int pixelFormat;
        IntPtr scan0;
        int reserved;
        
        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.Width"]/*' />
        /// <devdoc>
        ///    Specifies the pixel width of the <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public int Width {
            get { return width; }
            set { width = value; }
        }

        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.Height"]/*' />
        /// <devdoc>
        ///    Specifies the pixel height of the <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public int Height {
            get { return height; }
            set { height = value; }
        }

        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.Stride"]/*' />
        /// <devdoc>
        ///    Specifies the stride width of the <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public int Stride {
            get { return stride; }
            set { stride = value; }
        }

        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.PixelFormat"]/*' />
        /// <devdoc>
        ///    Specifies the format of the pixel
        ///    information in this <see cref='System.Drawing.Bitmap'/>.
        /// </devdoc>
        public PixelFormat PixelFormat {
            get { return (PixelFormat) pixelFormat; }
            set { 
                if (!Enum.IsDefined(typeof(PixelFormat), value)) {
                    throw new System.ComponentModel.InvalidEnumArgumentException("value", (int)value, typeof(PixelFormat));
                }

                pixelFormat = (int) value;
            }
        }
        
        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.Scan0"]/*' />
        /// <devdoc>
        ///    Specifies the address of the pixel data.
        /// </devdoc>
        public IntPtr Scan0 {
            get { return scan0; }
            set { scan0 = value; }
        }

        /// <include file='doc\BitmapData.uex' path='docs/doc[@for="BitmapData.Reserved"]/*' />
        /// <devdoc>
        ///    Reserved. Do not use.
        /// </devdoc>
        public int Reserved {
            // why make public??
            //
            get { return reserved; }
            set { reserved = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\systempens.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemPens.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;
    using System;
    
    /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens"]/*' />
    /// <devdoc>
    ///     Pens for select Windows system-wide colors.  Whenever possible, try to use
    ///     SystemPens and SystemBrushes rather than SystemColors.
    /// </devdoc>
    public sealed class SystemPens {
        static readonly object SystemPensKey = new object();

        private SystemPens() {
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ActiveCaptionText"]/*' />
        /// <devdoc>
        ///     Pen is the color of the active window's caption text.
        /// </devdoc>
        public static Pen ActiveCaptionText {
            get {
                return FromSystemColor(SystemColors.ActiveCaptionText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.Control"]/*' />
        /// <devdoc>
        ///     Pen is the color of a button or control.
        /// </devdoc>
        public static Pen Control {
            get {
                return FromSystemColor(SystemColors.Control);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ControlText"]/*' />
        /// <devdoc>
        ///     Pen is the color of the text on a button or control.
        /// </devdoc>
        public static Pen ControlText {
            get {
                return FromSystemColor(SystemColors.ControlText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ControlDark"]/*' />
        /// <devdoc>
        ///     Pen is the color of the shadow part of a 3D element
        /// </devdoc>
        public static Pen ControlDark {
            get {
                return FromSystemColor(SystemColors.ControlDark);
            }
        }
        
        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ControlDarkDark"]/*' />
        /// <devdoc>
        ///     Pen is the color of the darkest part of a 3D element
        /// </devdoc>
        public static Pen ControlDarkDark {
            get {
                return FromSystemColor(SystemColors.ControlDarkDark);
            }
        }
        
        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ControlLight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Pen ControlLight {
            get {
                return FromSystemColor(SystemColors.ControlLight);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.ControlLightLight"]/*' />
        /// <devdoc>
        ///     Pen is the color of the lightest part of a 3D element
        /// </devdoc>
        public static Pen ControlLightLight {
            get {
                return FromSystemColor(SystemColors.ControlLightLight);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.GrayText"]/*' />
        /// <devdoc>
        ///     Pen is the color of disabled text.
        /// </devdoc>
        public static Pen GrayText {
            get {
                return FromSystemColor(SystemColors.GrayText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.Highlight"]/*' />
        /// <devdoc>
        ///     Pen is the color of a highlighted background.
        /// </devdoc>
        public static Pen Highlight {
            get {
                return FromSystemColor(SystemColors.Highlight);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.HighlightText"]/*' />
        /// <devdoc>
        ///     Pen is the color of highlighted text.
        /// </devdoc>
        public static Pen HighlightText {
            get {
                return FromSystemColor(SystemColors.HighlightText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.InactiveCaptionText"]/*' />
        /// <devdoc>
        ///     Pen is the color of an inactive window's caption text.
        /// </devdoc>
        public static Pen InactiveCaptionText {
            get {
                return FromSystemColor(SystemColors.InactiveCaptionText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.InfoText"]/*' />
        /// <devdoc>
        ///     Pen is the color of the info tooltip's text.
        /// </devdoc>
        public static Pen InfoText {
            get {
                return FromSystemColor(SystemColors.InfoText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.MenuText"]/*' />
        /// <devdoc>
        ///     Pen is the color of the menu text.
        /// </devdoc>
        public static Pen MenuText {
            get {
                return FromSystemColor(SystemColors.MenuText);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.WindowFrame"]/*' />
        /// <devdoc>
        ///     Pen is the color of the window frame.
        /// </devdoc>
        public static Pen WindowFrame {
            get {
                return FromSystemColor(SystemColors.WindowFrame);
            }
        }

        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.WindowText"]/*' />
        /// <devdoc>
        ///     Pen is the color of a window's text.
        /// </devdoc>
        public static Pen WindowText {
            get {
                return FromSystemColor(SystemColors.WindowText);
            }
        }
        
        /// <include file='doc\SystemPens.uex' path='docs/doc[@for="SystemPens.FromSystemColor"]/*' />
        /// <devdoc>
        ///     Retrieves a pen given a system color.  An error will be raised
        ///     if the color provide is not a system color.
        /// </devdoc>
        public static Pen FromSystemColor(Color c) {
            if (!c.IsSystemColor) {
                throw new ArgumentException(SR.GetString(SR.ColorNotSystemColor, c.ToString()));
            }
            
            Pen[] systemPens = (Pen[])SafeNativeMethods.ThreadData[SystemPensKey];
            if (systemPens == null) {        
                systemPens = new Pen[(int)KnownColor.WindowText];
                SafeNativeMethods.ThreadData[SystemPensKey] = systemPens;
            }

            int idx = (int)c.ToKnownColor() - 1;
            Debug.Assert(idx >= 0 && idx < systemPens.Length, "System colors have been added but our system color array has not been expanded.");
            
            if (systemPens[idx] == null) {
                systemPens[idx] = new Pen(c, true);
            }
            
            return systemPens[idx];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\blend.cs ===
//------------------------------------------------------------------------------
// <copyright file="Blend.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Blend.cs
*
* Abstract:
*
*   Native GDI+ Blend structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\Blend.uex' path='docs/doc[@for="Blend"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines a blend pattern for a <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/>
    ///       .
    ///    </para>
    /// </devdoc>
    public sealed class Blend {
        float[] factors;
        float[] positions;

        /// <include file='doc\Blend.uex' path='docs/doc[@for="Blend.Blend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.Blend'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public Blend() {
            factors = new float[1];
            positions = new float[1];
        }

        /// <include file='doc\Blend.uex' path='docs/doc[@for="Blend.Blend1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.Blend'/>
        ///       class with the specified number of factors and positions.
        ///    </para>
        /// </devdoc>
        public Blend(int count) {
            factors = new float[count];
            positions = new float[count];
        }
        /// <include file='doc\Blend.uex' path='docs/doc[@for="Blend.Factors"]/*' />
        /// <devdoc>
        ///    Specifies an array of blend factors for the
        ///    gradient.
        /// </devdoc>
        public float[] Factors { 
            get {
                return factors;
            }
            set {
                factors = value;
            }
        }

        /// <include file='doc\Blend.uex' path='docs/doc[@for="Blend.Positions"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies an array of blend positions for the gradient.
        ///    </para>
        /// </devdoc>
        public float[] Positions {
            get {
                return positions;
            }
            set {
                positions = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\brushtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="BrushType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   BrushType.cs
*
* Abstract:
*
*   Native GDI+ Brush Type constants
*
* Revision History:
*
*   3/1/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System;
    using System.Drawing;

    /**
     * BrushType Type
     */
    internal enum BrushType
    {
        SolidColor     = 0,
        HatchFill      = 1,
        TextureFill    = 2,
        PathGradient   = 3,
        LinearGradient = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\coloradjusttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorAdjustType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorAdjustType.cs
*
* Abstract:
*
*   Color Adjust Type constants
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color adjust type constants
     */
    /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType"]/*' />
    /// <devdoc>
    ///    Specifies which GDI+ objects use color
    ///    adjustment information.
    /// </devdoc>
    public enum ColorAdjustType
    {
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Default"]/*' />
        /// <devdoc>
        ///    Defines color adjustment information that is
        ///    used by all GDI+ objects that do not have their own color adjustment
        ///    information.
        /// </devdoc>
        Default = 0,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Bitmap"]/*' />
        /// <devdoc>
        ///    Defines color adjustment information for
        /// <see cref='System.Drawing.Bitmap'/> 
        /// objects.
        /// </devdoc>
        Bitmap,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Brush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines color adjustment information for <see cref='System.Drawing.Brush'/> objects.
        ///    </para>
        /// </devdoc>
        Brush,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Pen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines color adjustment information for <see cref='System.Drawing.Pen'/> objects.
        ///    </para>
        /// </devdoc>
        Pen,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Defines color adjustment information for text.
        ///    </para>
        /// </devdoc>
        Text,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Count"]/*' />
        /// <devdoc>
        ///    Specifies the number of types specified.
        /// </devdoc>
        Count,
        /// <include file='doc\ColorAdjustType.uex' path='docs/doc[@for="ColorAdjustType.Any"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the number of types specified.
        ///    </para>
        /// </devdoc>
        Any
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colorchannelflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorChannelFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorChannelFlags.cs
*
* Abstract:
*
*   ColorChannel flag constants
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color channel flag constants
     */
    /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag"]/*' />
    /// <devdoc>
    ///    Specifies a range of CMYK channels.
    /// </devdoc>
    public enum ColorChannelFlag {
        /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag.ColorChannelC"]/*' />
        /// <devdoc>
        ///    Specifies the Cyan color channel.
        /// </devdoc>
        ColorChannelC = 0,
        /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag.ColorChannelM"]/*' />
        /// <devdoc>
        ///    Specifies the Magenta color channel.
        /// </devdoc>
        ColorChannelM,
        /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag.ColorChannelY"]/*' />
        /// <devdoc>
        ///    Specifies the Yellow color channel.
        /// </devdoc>
        ColorChannelY,
        /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag.ColorChannelK"]/*' />
        /// <devdoc>
        ///    Specifies the Black color channel.
        /// </devdoc>
        ColorChannelK,
        /// <include file='doc\ColorChannelFlags.uex' path='docs/doc[@for="ColorChannelFlag.ColorChannelLast"]/*' />
        /// <devdoc>
        ///    <para>
        ///       This element specifies to leave the color
        ///       channel unchanged from the last selected channel.
        ///    </para>
        /// </devdoc>
        ColorChannelLast
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colorblend.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorBlend.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorBlend.cs
*
* Abstract:
*
*   Native GDI+ Color Blend structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\ColorBlend.uex' path='docs/doc[@for="ColorBlend"]/*' />
    /// <devdoc>
    ///    Defines arrays of colors and positions used
    ///    for interpolating color blending in a gradient.
    /// </devdoc>
    public sealed class ColorBlend {
        Color[] colors;
        float[] positions;

        /// <include file='doc\ColorBlend.uex' path='docs/doc[@for="ColorBlend.ColorBlend"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.ColorBlend'/> class.
        /// </devdoc>
        public ColorBlend() {
            colors = new Color[1];
            positions = new float[1];
        }

        /// <include file='doc\ColorBlend.uex' path='docs/doc[@for="ColorBlend.ColorBlend1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.ColorBlend'/> class with the specified number of
        ///       colors and positions.
        ///    </para>
        /// </devdoc>
        public ColorBlend(int count) {
            colors = new Color[count];
            positions = new float[count];
        }
        
        /// <include file='doc\ColorBlend.uex' path='docs/doc[@for="ColorBlend.Colors"]/*' />
        /// <devdoc>
        ///    Represents an array of colors.
        /// </devdoc>
        public Color[] Colors {
            get {
                return colors;
            }
            set {
                colors = value;
            }
        }

        /// <include file='doc\ColorBlend.uex' path='docs/doc[@for="ColorBlend.Positions"]/*' />
        /// <devdoc>
        ///    Represents the positions along a gradient
        ///    line.
        /// </devdoc>
        public float[] Positions {
            get {
                return positions;
            }
            set {
                positions = value;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormatrix.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMatrix.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorMatrix.cs
*
* Abstract:
*
*   Native GDI+ ColorMatrix structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;
    using System.Runtime.InteropServices;

    // CONSIDER: why is this a separate class from ImageAttributes?
    /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix"]/*' />
    /// <devdoc>
    ///    Defines a 5 x 5 matrix that that
    ///    contains the homogenous coordinates for the RGBA space.
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class ColorMatrix {
        float matrix00;
        float matrix01;
        float matrix02;
        float matrix03;
        float matrix04;
        float matrix10;
        float matrix11;
        float matrix12;
        float matrix13;
        float matrix14;
        float matrix20;
        float matrix21;
        float matrix22;
        float matrix23;
        float matrix24;
        float matrix30;
        float matrix31;
        float matrix32;
        float matrix33;
        float matrix34;
        float matrix40;
        float matrix41;
        float matrix42;
        float matrix43;
        float matrix44;

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.ColorMatrix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.ColorMatrix'/> class.
        ///    </para>
        /// </devdoc>
        public ColorMatrix() { 
            /*
             * Setup identity matrix by default
             */

            matrix00 = 1.0f;
            matrix01 = 0.0f;
            matrix02 = 0.0f;
            matrix03 = 0.0f;
            matrix04 = 0.0f;
            matrix10 = 0.0f;
            matrix11 = 1.0f;
            matrix12 = 0.0f;
            matrix13 = 0.0f;
            matrix14 = 0.0f;
            matrix20 = 0.0f;
            matrix21 = 0.0f;
            matrix22 = 1.0f;
            matrix23 = 0.0f;
            matrix24 = 0.0f;
            matrix30 = 0.0f;
            matrix31 = 0.0f;
            matrix32 = 0.0f;
            matrix33 = 1.0f;
            matrix34 = 0.0f;
            matrix40 = 0.0f;
            matrix41 = 0.0f;
            matrix42 = 0.0f;
            matrix43 = 0.0f;
            matrix44 = 1.0f;
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix00"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the
        ///       0th row and 0th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix00 {
            get { return matrix00; }
            set { matrix00 = value; }
        }
        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix01"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 0th row and 1st column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix01 {
            get { return matrix01; }
            set { matrix01 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix02"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 0th row and 2nd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix02 {
            get { return matrix02; }
            set { matrix02 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix03"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 0th row and 3rd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix03 {
            get { return matrix03; }
            set { matrix03 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix04"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 0th row and 4th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix04 {
            get { return matrix04; }
            set { matrix04 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 1st row and 0th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix10 {
            get { return matrix10; }
            set { matrix10 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix11"]/*' />
        /// <devdoc>
        ///    Represents the element at the 1st row and
        ///    1st column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        /// </devdoc>
        public float Matrix11 {
            get { return matrix11; }
            set { matrix11 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix12"]/*' />
        /// <devdoc>
        ///    Represents the element at the 1st row
        ///    and 2nd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        /// </devdoc>
        public float Matrix12 {
            get { return matrix12; }
            set { matrix12 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix13"]/*' />
        /// <devdoc>
        ///    Represents the element at the 1st row
        ///    and 3rd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        /// </devdoc>
        public float Matrix13 {
            get { return matrix13; }
            set { matrix13 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix14"]/*' />
        /// <devdoc>
        ///    Represents the element at the 1st row
        ///    and 4th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        /// </devdoc>
        public float Matrix14 {
            get { return matrix14; }
            set { matrix14 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix20"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 2nd row and
        ///       0th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix20 {
            get { return matrix20; }
            set { matrix20 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix21"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 2nd row and 1st column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix21 {
            get { return matrix21; }
            set { matrix21 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix22"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 2nd row and 2nd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix22 {
            get { return matrix22; }
            set { matrix22 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix23"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 2nd row and 3rd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix23 {
            get { return matrix23; }
            set { matrix23 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix24"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 2nd row and 4th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix24 {
            get { return matrix24; }
            set { matrix24 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix30"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 3rd row and 0th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix30 {
            get { return matrix30; }
            set { matrix30 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix31"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 3rd row and 1st column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix31 {
            get { return matrix31; }
            set { matrix31 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix32"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 3rd row and 2nd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix32 {
            get { return matrix32; }
            set { matrix32 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix33"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 3rd row and 3rd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix33 {
            get { return matrix33; }
            set { matrix33 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix34"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 3rd row and 4th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix34 {
            get { return matrix34; }
            set { matrix34 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix40"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 4th row and 0th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix40 {
            get { return matrix40; }
            set { matrix40 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix41"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 4th row and 1st column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix41 {
            get { return matrix41; }
            set { matrix41 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix42"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 4th row and 2nd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix42 {
            get { return matrix42; }
            set { matrix42 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix43"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 4th row and 3rd column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix43 {
            get { return matrix43; }
            set { matrix43 = value; }
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.Matrix44"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the element at the 4th row and 4th column of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float Matrix44 {
            get { return matrix44; }
            set { matrix44 = value; }
        }


        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.ColorMatrix1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.ColorMatrix'/> class with the
        ///       elements in the specified matrix.
        ///    </para>
        /// </devdoc>
        [CLSCompliant(false)]
        public ColorMatrix(float[][] newColorMatrix) {
            SetMatrix(newColorMatrix);
        }

        internal void SetMatrix(float[][] newColorMatrix) {
            matrix00 = newColorMatrix[0][0];
            matrix01 = newColorMatrix[0][1];
            matrix02 = newColorMatrix[0][2];
            matrix03 = newColorMatrix[0][3];
            matrix04 = newColorMatrix[0][4];
            matrix10 = newColorMatrix[1][0];
            matrix11 = newColorMatrix[1][1];
            matrix12 = newColorMatrix[1][2];
            matrix13 = newColorMatrix[1][3];
            matrix14 = newColorMatrix[1][4];
            matrix20 = newColorMatrix[2][0];
            matrix21 = newColorMatrix[2][1];
            matrix22 = newColorMatrix[2][2];
            matrix23 = newColorMatrix[2][3];
            matrix24 = newColorMatrix[2][4];
            matrix30 = newColorMatrix[3][0];
            matrix31 = newColorMatrix[3][1];
            matrix32 = newColorMatrix[3][2];
            matrix33 = newColorMatrix[3][3];
            matrix34 = newColorMatrix[3][4];
            matrix40 = newColorMatrix[4][0];
            matrix41 = newColorMatrix[4][1];
            matrix42 = newColorMatrix[4][2];
            matrix43 = newColorMatrix[4][3];
            matrix44 = newColorMatrix[4][4];
        }

        internal float[][] GetMatrix() {
            float[][] returnMatrix = new float[5][];

            for (int i = 0; i < 5; i++)
                returnMatrix[i] = new float[5];

            returnMatrix[0][0] = matrix00;
            returnMatrix[0][1] = matrix01;
            returnMatrix[0][2] = matrix02;
            returnMatrix[0][3] = matrix03;
            returnMatrix[0][4] = matrix04;
            returnMatrix[1][0] = matrix10;
            returnMatrix[1][1] = matrix11;
            returnMatrix[1][2] = matrix12;
            returnMatrix[1][3] = matrix13;
            returnMatrix[1][4] = matrix14;
            returnMatrix[2][0] = matrix20;
            returnMatrix[2][1] = matrix21;
            returnMatrix[2][2] = matrix22;
            returnMatrix[2][3] = matrix23;
            returnMatrix[2][4] = matrix24;
            returnMatrix[3][0] = matrix30;
            returnMatrix[3][1] = matrix31;
            returnMatrix[3][2] = matrix32;
            returnMatrix[3][3] = matrix33;
            returnMatrix[3][4] = matrix34;
            returnMatrix[4][0] = matrix40;
            returnMatrix[4][1] = matrix41;
            returnMatrix[4][2] = matrix42;
            returnMatrix[4][3] = matrix43;
            returnMatrix[4][4] = matrix44;

            return returnMatrix;
        }

        /// <include file='doc\ColorMatrix.uex' path='docs/doc[@for="ColorMatrix.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value of the specified element of this <see cref='System.Drawing.Imaging.ColorMatrix'/>.
        ///    </para>
        /// </devdoc>
        public float this[int row, int column] {
            get {
                return GetMatrix()[row][column];
            }

            set {
                float[][] tempMatrix = GetMatrix();

                tempMatrix[row][column] = value;

                SetMatrix(tempMatrix);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormatrix2.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMatrix2.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// Delete this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormap.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorMap.cs
*
* Abstract:
*
*   Native GDI+ ColorMap structure.
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\ColorMap.uex' path='docs/doc[@for="ColorMap"]/*' />
    /// <devdoc>
    ///    Defines a map for converting colors.
    /// </devdoc>
    public sealed class ColorMap {
        Color oldColor;
        Color newColor;
        
        /// <include file='doc\ColorMap.uex' path='docs/doc[@for="ColorMap.ColorMap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.ColorMap'/> class.
        ///    </para>
        /// </devdoc>
        public ColorMap() {
            oldColor = new Color();
            newColor = new Color();
        }
        
        /// <include file='doc\ColorMap.uex' path='docs/doc[@for="ColorMap.OldColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the existing <see cref='System.Drawing.Color'/> to be
        ///       converted.
        ///    </para>
        /// </devdoc>
        public Color OldColor {
            get { return oldColor; }
            set { oldColor = value; }
        }
        /// <include file='doc\ColorMap.uex' path='docs/doc[@for="ColorMap.NewColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifes the new <see cref='System.Drawing.Color'/> to which to convert.
        ///    </para>
        /// </devdoc>
        public Color NewColor {
            get { return newColor; }
            set { newColor = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormatrixflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMatrixFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorMatrixFlags.cs
*
* Abstract:
*
*   Color Matrix flag constants
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color matrix flag constants
     */
    /// <include file='doc\ColorMatrixFlags.uex' path='docs/doc[@for="ColorMatrixFlag"]/*' />
    /// <devdoc>
    ///    Specifies available options for
    ///    color-adjusting. GDI+ can adjust color data only, grayscale data only,
    ///    or both.
    /// </devdoc>
    public enum ColorMatrixFlag {
        /// <include file='doc\ColorMatrixFlags.uex' path='docs/doc[@for="ColorMatrixFlag.Default"]/*' />
        /// <devdoc>
        ///    Both colors and grayscale are
        ///    color-adjusted.
        /// </devdoc>
        Default = 0,
        /// <include file='doc\ColorMatrixFlags.uex' path='docs/doc[@for="ColorMatrixFlag.SkipGrays"]/*' />
        /// <devdoc>
        ///    Grascale values are not color-adjusted.
        /// </devdoc>
        SkipGrays = 1,
        /// <include file='doc\ColorMatrixFlags.uex' path='docs/doc[@for="ColorMatrixFlag.AltGrays"]/*' />
        /// <devdoc>
        ///    Only grascale values are color-adjusted.
        /// </devdoc>
        AltGrays = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colorpalette.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorPalette.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorPalette.cs
*
* Abstract:
*
*   Native GDI+ Color Palette structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;    

    /// <include file='doc\ColorPalette.uex' path='docs/doc[@for="ColorPalette"]/*' />
    /// <devdoc>
    ///    Defines an array of colors that make up a
    ///    color palette.
    /// </devdoc>
    public sealed class ColorPalette {
        private int flags;
        private Color[] entries;

        /// <include file='doc\ColorPalette.uex' path='docs/doc[@for="ColorPalette.Flags"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies how to interpret the color
        ///       information in the array of colors.
        ///    </para>
        /// </devdoc>
        public int Flags
        {
            get {
                return flags;
            }
        }
        
        /// <include file='doc\ColorPalette.uex' path='docs/doc[@for="ColorPalette.Entries"]/*' />
        /// <devdoc>
        ///    Specifies an array of <see cref='System.Drawing.Color'/> objects.
        /// </devdoc>
        public Color[] Entries
        {
            get {
                return entries;
            }
        }
        
        internal ColorPalette(int count) {
            flags = 0;
            entries = new Color[count];
        }

        internal ColorPalette() {
            flags = 0;
            entries = new Color[1];
        }

        internal void ConvertFromMemory(IntPtr memory)
        {
            // Memory layout is:
            //    UINT Flags
            //    UINT Count
            //    ARGB Entries[size]

            flags = Marshal.ReadInt32(memory);

            int size;

            size = Marshal.ReadInt32((IntPtr)((long)memory + 4));  // Marshal.SizeOf(size.GetType())

            entries = new Color[size];

            for (int i=0; i<size; i++)
            {
                // use Marshal.SizeOf()
                int argb = Marshal.ReadInt32((IntPtr)((long)memory + 8 + i*4));
                entries[i] = Color.FromArgb(argb);
            }    
        }
    
        internal IntPtr ConvertToMemory()
        {
            // Memory layout is:
            //    UINT Flags
            //    UINT Count
            //    ARGB Entries[size]

            // use Marshal.SizeOf()
            IntPtr memory = Marshal.AllocHGlobal(4*(2+entries.Length));
            
            Marshal.WriteInt32(memory, 0, flags);
            // use Marshal.SizeOf()
            Marshal.WriteInt32((IntPtr)((long)memory + 4), 0, entries.Length);
            
            for (int i=0; i<entries.Length; i++)
            {
                // use Marshal.SizeOf()
                Marshal.WriteInt32((IntPtr)((long)memory + 4*(i+2)), 0, entries[i].ToArgb());
            }
            
            return memory;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormaptype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMapType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorMapType.cs
*
* Abstract:
*
*   Color Map type constants
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color Map type constants
     */
    /// <include file='doc\ColorMapType.uex' path='docs/doc[@for="ColorMapType"]/*' />
    /// <devdoc>
    ///    Specifies the types of color maps.
    /// </devdoc>
    public enum ColorMapType
    {
        /// <include file='doc\ColorMapType.uex' path='docs/doc[@for="ColorMapType.Default"]/*' />
        /// <devdoc>
        ///    A default color map.
        /// </devdoc>
        Default = 0,
        /// <include file='doc\ColorMapType.uex' path='docs/doc[@for="ColorMapType.Brush"]/*' />
        /// <devdoc>
        ///    Specifies a color map for a <see cref='System.Drawing.Brush'/>.
        /// </devdoc>
        Brush
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colormode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ColorMode.cs
*
* Abstract:
*
*   Color mode constants
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color mode constants
     */
    /// <include file='doc\ColorMode.uex' path='docs/doc[@for="ColorMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies two modes for color component
    ///       values.
    ///    </para>
    /// </devdoc>
    public enum ColorMode
    {
        /// <include file='doc\ColorMode.uex' path='docs/doc[@for="ColorMode.Argb32Mode"]/*' />
        /// <devdoc>
        ///    Specifies that integer values supplied are
        ///    32-bit values.
        /// </devdoc>
        Argb32Mode = 0,
        /// <include file='doc\ColorMode.uex' path='docs/doc[@for="ColorMode.Argb64Mode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that integer values supplied are
        ///       64-bit values.
        ///    </para>
        /// </devdoc>
        Argb64Mode = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\compositingmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompositingMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CompositingMode.cs
*
* Abstract:
*
*   Compositing mode constants
*
* Revision History:
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /*
     * Alpha compositing mode constants
     *
     * @notes Should we scrap this for the first version
     *  and support only SrcOver instead?
     */

    /// <include file='doc\CompositingMode.uex' path='docs/doc[@for="CompositingMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines how the source image is composited with the background image.
    ///    </para>
    /// </devdoc>
    public enum CompositingMode
    {
        /// <include file='doc\CompositingMode.uex' path='docs/doc[@for="CompositingMode.SourceOver"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The source pixels overwrite the background pixels.
        ///    </para>
        /// </devdoc>
        SourceOver = 0,
        /// <include file='doc\CompositingMode.uex' path='docs/doc[@for="CompositingMode.SourceCopy"]/*' />
        /// <devdoc>
        ///    The source pixels are combined with the
        ///    background pixels.
        /// </devdoc>
        SourceCopy = 1
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\colortranslator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorTranslator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System.Collections;
    using System.ComponentModel;
    using System.Drawing;
    using System.Globalization;
    
    /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator"]/*' />
    /// <devdoc>
    ///    Translates colors to and from GDI+ <see cref='System.Drawing.Color'/> objects.
    /// </devdoc>
    public sealed class ColorTranslator {
        private const int Win32RedShift    = 0;
        private const int Win32GreenShift  = 8;
        private const int Win32BlueShift   = 16;

        private static Hashtable htmlSysColorTable;

        // not creatable...
        //
        private ColorTranslator() {
        }

        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.ToWin32"]/*' />
        /// <devdoc>
        ///    Translates the specified <see cref='System.Drawing.Color'/> to a
        ///    Win32 color.
        /// </devdoc>
        public static int ToWin32(Color c) {
            return c.R << Win32RedShift | c.G << Win32GreenShift | c.B << Win32BlueShift;
        }
        
        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.ToOle"]/*' />
        /// <devdoc>
        ///    Translates the specified <see cref='System.Drawing.Color'/> to
        ///    an Ole color.
        /// </devdoc>
        public static int ToOle(Color c) {
            //    WARNING!!! WARNING!!! WARNING!!! WARNING!!! 
            //    WARNING!!! WARNING!!! WARNING!!! WARNING!!!
            //    We must never have another method called ToOle() with a different signature.
            //    This is so that we can push into the runtime a custom marshaller for OLE_COLOR to Color.
            
            if (c.IsKnownColor) {
                switch (c.ToKnownColor()) {
                    case KnownColor.ActiveBorder:
                        return unchecked((int)0x8000000A);
                    case KnownColor.ActiveCaption:
                        return unchecked((int)0x80000002);
                    case KnownColor.ActiveCaptionText:
                        return unchecked((int)0x80000009);
                    case KnownColor.AppWorkspace:
                        return unchecked((int)0x8000000C);
                    case KnownColor.Control:
                        return unchecked((int)0x8000000F);
                    case KnownColor.ControlDark:
                        return unchecked((int)0x80000010);
                    case KnownColor.ControlDarkDark:
                        return unchecked((int)0x80000015);
                    case KnownColor.ControlLight:
                        return unchecked((int)0x80000016);
                    case KnownColor.ControlLightLight:
                        return unchecked((int)0x80000014);
                    case KnownColor.ControlText:
                        return unchecked((int)0x80000012);
                    case KnownColor.Desktop:
                        return unchecked((int)0x80000001);
                    case KnownColor.GrayText:
                        return unchecked((int)0x80000011);
                    case KnownColor.Highlight:
                        return unchecked((int)0x8000000D);
                    case KnownColor.HighlightText:
                        return unchecked((int)0x8000000E);
                    case KnownColor.HotTrack:
                        return unchecked((int)0x8000000D);
                    case KnownColor.InactiveBorder:
                        return unchecked((int)0x8000000B);
                    case KnownColor.InactiveCaption:
                        return unchecked((int)0x80000003);
                    case KnownColor.InactiveCaptionText:
                        return unchecked((int)0x80000013);
                    case KnownColor.Info:
                        return unchecked((int)0x80000018);
                    case KnownColor.InfoText:
                        return unchecked((int)0x80000017);
                    case KnownColor.Menu:
                        return unchecked((int)0x80000004);
                    case KnownColor.MenuText:
                        return unchecked((int)0x80000007);
                    case KnownColor.ScrollBar:
                        return unchecked((int)0x80000000);
                    case KnownColor.Window:
                        return unchecked((int)0x80000005);
                    case KnownColor.WindowFrame:
                        return unchecked((int)0x80000006);
                    case KnownColor.WindowText:
                        return unchecked((int)0x80000008);
                }
            }

            return ToWin32(c);
        }
        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.FromOle"]/*' />
        /// <devdoc>
        ///    Translates an Ole color value to a GDI+
        /// <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public static Color FromOle(int oleColor) {
            //    WARNING!!! WARNING!!! WARNING!!! WARNING!!! 
            //    WARNING!!! WARNING!!! WARNING!!! WARNING!!!
            //    We must never have another method called ToOle() with a different signature.
            //    This is so that we can push into the runtime a custom marshaller for OLE_COLOR to Color.

            // if system color
            // (the if < 0x18 check test whether it's a well-formed system color)
            if ((int)(oleColor & 0xFF000000) == unchecked((int)0x80000000)
                && (oleColor & 0xFFFFFF) <= 0x18) {

                switch (oleColor) {
                    case unchecked((int)0x8000000A):
                        return Color.FromKnownColor(KnownColor.ActiveBorder);
                    case unchecked((int)0x80000002):
                        return Color.FromKnownColor(KnownColor.ActiveCaption);
                    case unchecked((int)0x80000009):
                        return Color.FromKnownColor(KnownColor.ActiveCaptionText);
                    case unchecked((int)0x8000000C):
                        return Color.FromKnownColor(KnownColor.AppWorkspace);
                    case unchecked((int)0x8000000F):
                        return Color.FromKnownColor(KnownColor.Control);
                    case unchecked((int)0x80000010):
                        return Color.FromKnownColor(KnownColor.ControlDark);
                    case unchecked((int)0x80000015):
                        return Color.FromKnownColor(KnownColor.ControlDarkDark);
                    case unchecked((int)0x80000016):
                        return Color.FromKnownColor(KnownColor.ControlLight);
                    case unchecked((int)0x80000014):
                        return Color.FromKnownColor(KnownColor.ControlLightLight);
                    case unchecked((int)0x80000012):
                        return Color.FromKnownColor(KnownColor.ControlText);
                    case unchecked((int)0x80000001):
                        return Color.FromKnownColor(KnownColor.Desktop);
                    case unchecked((int)0x80000011):
                        return Color.FromKnownColor(KnownColor.GrayText);
                    case unchecked((int)0x8000000D):
                        return Color.FromKnownColor(KnownColor.Highlight);
                    case unchecked((int)0x8000000E):
                        return Color.FromKnownColor(KnownColor.HighlightText);
                    case unchecked((int)0x8000000B):
                        return Color.FromKnownColor(KnownColor.InactiveBorder);
                    case unchecked((int)0x80000003):
                        return Color.FromKnownColor(KnownColor.InactiveCaption);
                    case unchecked((int)0x80000013):
                        return Color.FromKnownColor(KnownColor.InactiveCaptionText);
                    case unchecked((int)0x80000018):
                        return Color.FromKnownColor(KnownColor.Info);
                    case unchecked((int)0x80000017):
                        return Color.FromKnownColor(KnownColor.InfoText);
                    case unchecked((int)0x80000004):
                        return Color.FromKnownColor(KnownColor.Menu);
                    case unchecked((int)0x80000007):
                        return Color.FromKnownColor(KnownColor.MenuText);
                    case unchecked((int)0x80000000):
                        return Color.FromKnownColor(KnownColor.ScrollBar);
                    case unchecked((int)0x80000005):
                        return Color.FromKnownColor(KnownColor.Window);
                    case unchecked((int)0x80000006):
                        return Color.FromKnownColor(KnownColor.WindowFrame);
                    case unchecked((int)0x80000008):
                        return Color.FromKnownColor(KnownColor.WindowText);
                }
            }

            Color color = Color.FromArgb((byte)((oleColor >> Win32RedShift) & 0xFF),
                                         (byte)((oleColor >> Win32GreenShift) & 0xFF),
                                         (byte)((oleColor >> Win32BlueShift) & 0xFF));
        
            return KnownColorTable.ArgbToKnownColor(color.ToArgb());
        }

        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.FromWin32"]/*' />
        /// <devdoc>
        ///    Translates an Win32 color value to a
        ///    GDI+ <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public static Color FromWin32(int win32Color) {
            return FromOle(win32Color);
        }

        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.FromHtml"]/*' />
        /// <devdoc>
        ///    Translates an Html color representation to
        ///    a GDI+ <see cref='System.Drawing.Color'/>.
        /// </devdoc>
        public static Color FromHtml(string htmlColor) {
            Color c = Color.Empty;

            // empty color
            if ((htmlColor == null) || (htmlColor.Length == 0))
                return c;

            // #RRGGBB or #RGB
            if ((htmlColor[0] == '#') &&
                ((htmlColor.Length == 7) || (htmlColor.Length == 4))) {

                if (htmlColor.Length == 7) {
                    c = Color.FromArgb(Convert.ToInt32(htmlColor.Substring(1, 2), 16),
                                       Convert.ToInt32(htmlColor.Substring(3, 2), 16),
                                       Convert.ToInt32(htmlColor.Substring(5, 2), 16));
                }
                else {
                    string r = Char.ToString(htmlColor[1]);
                    string g = Char.ToString(htmlColor[2]);
                    string b = Char.ToString(htmlColor[3]);

                    c = Color.FromArgb(Convert.ToInt32(r + r, 16),
                                       Convert.ToInt32(g + g, 16),
                                       Convert.ToInt32(b + b, 16));
                }
            }

            // special case. Html requires LightGrey, but .NET uses LightGray
            if (c.IsEmpty && String.Compare(htmlColor, "LightGrey", true, CultureInfo.InvariantCulture) == 0) {
                c = Color.LightGray;
            }

            // System color
            if (c.IsEmpty) {
                if (htmlSysColorTable == null) {
                    InitializeHtmlSysColorTable();
                }

                object o = htmlSysColorTable[htmlColor.ToLower(CultureInfo.InvariantCulture)];
                if (o != null) {
                    c = (Color)o;
                }
            }

            // resort to type converter which will handle named colors
            if (c.IsEmpty) {
                c = (Color)TypeDescriptor.GetConverter(typeof(Color)).ConvertFromString(htmlColor);
            }

            return c;
        }

        /// <include file='doc\ColorTranslator.uex' path='docs/doc[@for="ColorTranslator.ToHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the specified <see cref='System.Drawing.Color'/> to an Html string color representation.
        ///    </para>
        /// </devdoc>
        public static string ToHtml(Color c) {
            string colorString = String.Empty;

            if (c.IsEmpty)
                return colorString;

            if (c.IsSystemColor) {
                switch (c.ToKnownColor()) {
                    case KnownColor.ActiveBorder: colorString = "activeborder"; break;
                    case KnownColor.ActiveCaption: colorString = "activecaption"; break;
                    case KnownColor.AppWorkspace: colorString = "appworkspace"; break;
                    case KnownColor.Desktop: colorString = "background"; break;
                    case KnownColor.Control: colorString = "buttonface"; break;
                    case KnownColor.ControlLight: colorString = "buttonface"; break;
                    case KnownColor.ControlDark: colorString = "buttonshadow"; break;
                    case KnownColor.ControlText: colorString = "buttontext"; break;
                    case KnownColor.ActiveCaptionText: colorString = "captiontext"; break;
                    case KnownColor.GrayText: colorString = "graytext"; break;
                    case KnownColor.HotTrack:
                    case KnownColor.Highlight: colorString = "highlight"; break;
                    case KnownColor.HighlightText: colorString = "highlighttext"; break;
                    case KnownColor.InactiveBorder: colorString = "inactiveborder"; break;
                    case KnownColor.InactiveCaption: colorString = "inactivecaption"; break;
                    case KnownColor.InactiveCaptionText: colorString = "inactivecaptiontext"; break;
                    case KnownColor.Info: colorString = "infobackground"; break;
                    case KnownColor.InfoText: colorString = "infotext"; break;
                    case KnownColor.Menu: colorString = "menu"; break;
                    case KnownColor.MenuText: colorString = "menutext"; break;
                    case KnownColor.ScrollBar: colorString = "scrollbar"; break;
                    case KnownColor.ControlDarkDark: colorString = "threeddarkshadow"; break;
                    case KnownColor.ControlLightLight: colorString = "buttonhighlight"; break;
                    case KnownColor.Window: colorString = "window"; break;
                    case KnownColor.WindowFrame: colorString = "windowframe"; break;
                    case KnownColor.WindowText: colorString = "windowtext"; break;
                }
            }
            else if (c.IsNamedColor) {
                if (c == Color.LightGray) {
                    // special case due to mismatch between Html and enum spelling
                    colorString = "LightGrey";
                }
                else {
                    colorString = c.Name;
                }
            }
            else {
                colorString = "#" + c.R.ToString("X2", null) +
                                    c.G.ToString("X2", null) +
                                    c.B.ToString("X2", null);
            }

            return colorString;
        }

        private static void InitializeHtmlSysColorTable() {
            htmlSysColorTable = new Hashtable(26);
            htmlSysColorTable["activeborder"] = Color.FromKnownColor(KnownColor.ActiveBorder);
            htmlSysColorTable["activecaption"] = Color.FromKnownColor(KnownColor.ActiveCaption);
            htmlSysColorTable["appworkspace"] = Color.FromKnownColor(KnownColor.AppWorkspace);
            htmlSysColorTable["background"] = Color.FromKnownColor(KnownColor.Desktop);
            htmlSysColorTable["buttonface"] = Color.FromKnownColor(KnownColor.Control);
            htmlSysColorTable["buttonhighlight"] = Color.FromKnownColor(KnownColor.ControlLightLight);
            htmlSysColorTable["buttonshadow"] = Color.FromKnownColor(KnownColor.ControlDark);
            htmlSysColorTable["buttontext"] = Color.FromKnownColor(KnownColor.ControlText);
            htmlSysColorTable["captiontext"] = Color.FromKnownColor(KnownColor.ActiveCaptionText);
            htmlSysColorTable["graytext"] = Color.FromKnownColor(KnownColor.GrayText);
            htmlSysColorTable["highlight"] = Color.FromKnownColor(KnownColor.Highlight);
            htmlSysColorTable["highlighttext"] = Color.FromKnownColor(KnownColor.HighlightText);
            htmlSysColorTable["inactiveborder"] = Color.FromKnownColor(KnownColor.InactiveBorder);
            htmlSysColorTable["inactivecaption"] = Color.FromKnownColor(KnownColor.InactiveCaption);
            htmlSysColorTable["inactivecaptiontext"] = Color.FromKnownColor(KnownColor.InactiveCaptionText);
            htmlSysColorTable["infobackground"] = Color.FromKnownColor(KnownColor.Info);
            htmlSysColorTable["infotext"] = Color.FromKnownColor(KnownColor.InfoText);
            htmlSysColorTable["menu"] = Color.FromKnownColor(KnownColor.Menu);
            htmlSysColorTable["menutext"] = Color.FromKnownColor(KnownColor.MenuText);
            htmlSysColorTable["scrollbar"] = Color.FromKnownColor(KnownColor.ScrollBar);
            htmlSysColorTable["threeddarkshadow"] = Color.FromKnownColor(KnownColor.ControlDarkDark);
            htmlSysColorTable["threedface"] = Color.FromKnownColor(KnownColor.Control);
            htmlSysColorTable["threedhighlight"] = Color.FromKnownColor(KnownColor.ControlLight);
            htmlSysColorTable["threedlightshadow"] = Color.FromKnownColor(KnownColor.ControlLightLight);
            htmlSysColorTable["window"] = Color.FromKnownColor(KnownColor.Window);
            htmlSysColorTable["windowframe"] = Color.FromKnownColor(KnownColor.WindowFrame);
            htmlSysColorTable["windowtext"] = Color.FromKnownColor(KnownColor.WindowText);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\compositingquality.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompositingQuality.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CompositingQuality.cs
*
* Abstract:
*
*   Alpha compositing quality constants
*
* Revision History:
*
*   05/01/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality"]/*' />
    /// <devdoc>
    ///    Specifies the quality level to use during
    ///    compositing.
    /// </devdoc>
    public enum CompositingQuality
    {
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.Invalid"]/*' />
        /// <devdoc>
        ///    Invalid quality.
        /// </devdoc>
        Invalid = QualityMode.Invalid,
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.Default"]/*' />
        /// <devdoc>
        ///    Default quality.
        /// </devdoc>
        Default = QualityMode.Default,
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.HighSpeed"]/*' />
        /// <devdoc>
        ///    Low quality, high speed.
        /// </devdoc>
        HighSpeed = QualityMode.Low,
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.HighQuality"]/*' />
        /// <devdoc>
        ///    High quality, low speed.
        /// </devdoc>
        HighQuality = QualityMode.High,
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.GammaCorrected"]/*' />
        /// <devdoc>
        ///    Gamma correction is used.
        /// </devdoc>
        GammaCorrected,
        /// <include file='doc\CompositingQuality.uex' path='docs/doc[@for="CompositingQuality.AssumeLinear"]/*' />
        /// <devdoc>
        ///    Assume linear values.
        /// </devdoc>
        AssumeLinear
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\combinemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="CombineMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CombineMode.cs
*
* Abstract:
*
*   Combine mode constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Combine mode constants
     */
    /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode"]/*' />
    /// <devdoc>
    ///    Defines how different clipping regions can
    ///    be combined.
    /// </devdoc>
    public enum CombineMode
    {
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Replace"]/*' />
        /// <devdoc>
        ///    One clipping region is replaced by another.
        /// </devdoc>
        Replace     = 0,
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Intersect"]/*' />
        /// <devdoc>
        ///    The two clipping regions are combined by
        ///    taking their intersection.
        /// </devdoc>
        Intersect   = 1,
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Union"]/*' />
        /// <devdoc>
        ///    The two clipping regions are combined by
        ///    taking the union of both.
        /// </devdoc>
        Union       = 2,
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Xor"]/*' />
        /// <devdoc>
        ///    The two clipping regions are combined by
        ///    taking only the area enclosed by one or the other regions, but not both.
        /// </devdoc>
        Xor         = 3,
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Exclude"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Two clipping regions are combined by taking
        ///       the area of the first region that does not intersect with the second.
        ///    </para>
        /// </devdoc>
        Exclude     = 4,
        /// <include file='doc\CombineMode.uex' path='docs/doc[@for="CombineMode.Complement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Two clipping regions are combined by taking
        ///       the area of the second region that does not intersect with the first.
        ///    </para>
        /// </devdoc>
        Complement  = 5
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\coordinatespace.cs ===
//------------------------------------------------------------------------------
// <copyright file="CoordinateSpace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CoordinateSpace.cs
*
* Abstract:
*
*   Native GDI+ affine transformation co-ordinate space enums.
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Coordinate space identifiers
     */
    /// <include file='doc\CoordinateSpace.uex' path='docs/doc[@for="CoordinateSpace"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the system to use when evaluating coordinates.
    ///    </para>
    /// </devdoc>
    public enum CoordinateSpace
    {
        /// <include file='doc\CoordinateSpace.uex' path='docs/doc[@for="CoordinateSpace.World"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that coordinates are in the world coordinate context. World
        ///       coordinates are used in a non physical enviroment such as a modeling
        ///       environment.
        ///    </para>
        /// </devdoc>
        World = 0,
        /// <include file='doc\CoordinateSpace.uex' path='docs/doc[@for="CoordinateSpace.Page"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that coordinates are in the page coordinate context. Page
        ///       coordinates are typically used in a multiple page documents environment.
        ///    </para>
        /// </devdoc>
        Page = 1,
        /// <include file='doc\CoordinateSpace.uex' path='docs/doc[@for="CoordinateSpace.Device"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that coordinates are in the device coordinate context. Device
        ///       coordinates occur in screen coordinates just before they are drawn on the
        ///       screen.
        ///    </para>
        /// </devdoc>
        Device = 2
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\dashstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="DashStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DashStyle.cs
*
* Abstract:
*
*   Dash style constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Dash style constants (sdkinc\GDIplusEnums.h)
     */
    /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the style of dashed lines drawn with a <see cref='System.Drawing.Pen'/> .
    ///    </para>
    /// </devdoc>
    public enum DashStyle
    {
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.Solid"]/*' />
        /// <devdoc>
        ///    Specifies a solid line.
        /// </devdoc>
        Solid = 0,
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.Dash"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a line comprised of dashes.
        ///    </para>
        /// </devdoc>
        Dash = 1,
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.Dot"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a line comprised of dots.
        ///    </para>
        /// </devdoc>
        Dot = 2,
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.DashDot"]/*' />
        /// <devdoc>
        ///    Specifies a line comprised of an alternating
        ///    pattern of dash-dot-dash-dot.
        /// </devdoc>
        DashDot = 3,
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.DashDotDot"]/*' />
        /// <devdoc>
        ///    Specifies a line comprised of an alternating
        ///    pattern of dash-dot-dot-dash-dot-dot.
        /// </devdoc>
        DashDotDot = 4,
        /// <include file='doc\DashStyle.uex' path='docs/doc[@for="DashStyle.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a user-defined custom dash
        ///       style.
        ///    </para>
        /// </devdoc>
        Custom = 5
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\customlinecap.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomLineCap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CustomLineCap.cs
*
* Abstract:
*
*   Native GDI+ CustomLineCap structure.
*
* Revision History:
*
*   3/14/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;

    /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap"]/*' />
    /// <devdoc>
    ///    Encapsulates a custom user-defined line
    ///    cap.
    /// </devdoc>
    public class CustomLineCap : MarshalByRefObject, ICloneable, IDisposable {

#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif


        /*
         * Handle to native line cap object
         */

        internal IntPtr nativeCap;

        // For subclass creation
        internal CustomLineCap() {}
        
        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.CustomLineCap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.CustomLineCap'/> class with the specified outline
        ///       and fill.
        ///    </para>
        /// </devdoc>
        public CustomLineCap(GraphicsPath fillPath,
                             GraphicsPath strokePath) :
            this(fillPath, strokePath, LineCap.Flat) {}
            
        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.CustomLineCap1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.CustomLineCap'/> class from the
        ///       specified existing <see cref='System.Drawing.Drawing2D.LineCap'/> with the specified outline and
        ///       fill.
        ///    </para>
        /// </devdoc>
        public CustomLineCap(GraphicsPath fillPath,
                             GraphicsPath strokePath,
                             LineCap baseCap) :
            this(fillPath, strokePath, baseCap, 0) {}
            
        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.CustomLineCap2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.CustomLineCap'/> class from the
        ///       specified existing <see cref='System.Drawing.Drawing2D.LineCap'/> with the specified outline, fill, and
        ///       inset.
        ///    </para>
        /// </devdoc>
        public CustomLineCap(GraphicsPath fillPath,
                             GraphicsPath strokePath,
                             LineCap baseCap,
                             float baseInset)
        {
            IntPtr nativeCap = IntPtr.Zero;
            
            int status = SafeNativeMethods.GdipCreateCustomLineCap(
                                new HandleRef(fillPath, (fillPath == null) ? IntPtr.Zero : fillPath.nativePath),
                                new HandleRef(strokePath, (strokePath == null) ? IntPtr.Zero : strokePath.nativePath),
                                baseCap, baseInset, out nativeCap);    
                                
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            SetNativeLineCap(nativeCap);
        }

        internal CustomLineCap(IntPtr nativeLineCap)
        {
            SetNativeLineCap(nativeLineCap);
        }
        
        internal void SetNativeLineCap(IntPtr handle) {
            if (handle == IntPtr.Zero)
                throw new ArgumentNullException("handle");
        
            nativeCap = handle;
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Drawing2D.CustomLineCap'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeCap != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif

            if (nativeCap != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeleteCustomLineCap(new HandleRef(this, nativeCap));
                                
                nativeCap = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Drawing2D.CustomLineCap'/>.
        /// </devdoc>
        ~CustomLineCap() {
            Dispose(false);
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.CustomLineCap'/>.
        /// </devdoc>
        public object Clone()
        {
            IntPtr cloneCap = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneCustomLineCap(new HandleRef(this, nativeCap), out cloneCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
            
            return CustomLineCap.CreateCustomLineCapObject(cloneCap);
       }
       
       internal static CustomLineCap CreateCustomLineCapObject(IntPtr cap)
       {     
            CustomLineCapType capType = 0;
            
            int status = SafeNativeMethods.GdipGetCustomLineCapType(new HandleRef(null, cap), out capType);
            
            if (status != SafeNativeMethods.Ok)
            {
                SafeNativeMethods.GdipDeleteCustomLineCap(new HandleRef(null, cap));
                throw SafeNativeMethods.StatusException(status);
            }
            
            switch (capType)
            {
            case CustomLineCapType.Default:
                return new CustomLineCap(cap);
                
            case CustomLineCapType.AdjustableArrowCap:
                return new AdjustableArrowCap(cap);
            }
            
            SafeNativeMethods.GdipDeleteCustomLineCap(new HandleRef(null, cap));
            throw SafeNativeMethods.StatusException(SafeNativeMethods.NotImplemented);
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.SetStrokeCaps"]/*' />
        /// <devdoc>
        ///    Sets the caps used to start and end lines.
        /// </devdoc>
        public void SetStrokeCaps(LineCap startCap, LineCap endCap)
        {
            int status = SafeNativeMethods.GdipSetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), startCap, endCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.GetStrokeCaps"]/*' />
        /// <devdoc>
        ///    Gets the caps used to start and end lines.
        /// </devdoc>
        public void GetStrokeCaps(out LineCap startCap, out LineCap endCap) 
        {
            int status = SafeNativeMethods.GdipGetCustomLineCapStrokeCaps(new HandleRef(this, nativeCap), out startCap, out endCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private void _SetStrokeJoin(LineJoin lineJoin)
        {
            int status = SafeNativeMethods.GdipSetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), lineJoin);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
                                         
        private LineJoin _GetStrokeJoin()
        {
            LineJoin lineJoin;

            int status = SafeNativeMethods.GdipGetCustomLineCapStrokeJoin(new HandleRef(this, nativeCap), out lineJoin);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return lineJoin;
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.StrokeJoin"]/*' />
        /// <devdoc>
        ///    Gets or sets the <see cref='System.Drawing.Drawing2D.LineJoin'/> used by this custom cap.
        /// </devdoc>
        public LineJoin StrokeJoin
        {
            get { return _GetStrokeJoin(); }
            set { _SetStrokeJoin(value); }
        }
        
        private void _SetBaseCap(LineCap baseCap)
        {
            int status = SafeNativeMethods.GdipSetCustomLineCapBaseCap(new HandleRef(this, nativeCap), baseCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private LineCap _GetBaseCap()
        {
            LineCap baseCap;
            int status = SafeNativeMethods.GdipGetCustomLineCapBaseCap(new HandleRef(this, nativeCap), out baseCap);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return baseCap;
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.BaseCap"]/*' />
        /// <devdoc>
        ///    Gets or sets the <see cref='System.Drawing.Drawing2D.LineCap'/> on which this <see cref='System.Drawing.Drawing2D.CustomLineCap'/> is based.
        /// </devdoc>
        public LineCap BaseCap
        {
            get { return _GetBaseCap(); }
            set { _SetBaseCap(value); }
        }

        private void _SetBaseInset(float inset)
        {
            int status = SafeNativeMethods.GdipSetCustomLineCapBaseInset(new HandleRef(this, nativeCap), inset);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private float _GetBaseInset()
        {
            float inset;
            int status = SafeNativeMethods.GdipGetCustomLineCapBaseInset(new HandleRef(this, nativeCap), out inset);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return inset;
        }

        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.BaseInset"]/*' />
        /// <devdoc>
        ///    Gets or sets the distance between the cap
        ///    and the line.
        /// </devdoc>
        public float BaseInset
        {
            get { return _GetBaseInset(); }
            set { _SetBaseInset(value); }
        }
        
        private void _SetWidthScale(float widthScale)
        {
            int status = SafeNativeMethods.GdipSetCustomLineCapWidthScale(new HandleRef(this, nativeCap), widthScale);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private float _GetWidthScale()
        {
            float widthScale;
            int status = SafeNativeMethods.GdipGetCustomLineCapWidthScale(new HandleRef(this, nativeCap), out widthScale);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return widthScale;
        }
        
        /// <include file='doc\CustomLineCap.uex' path='docs/doc[@for="CustomLineCap.WidthScale"]/*' />
        /// <devdoc>
        ///    Gets or sets the amount by which to scale
        ///    the width of the cap.
        /// </devdoc>
        public float WidthScale
        {
            get { return _GetWidthScale(); }
            set { _SetWidthScale(value); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\decoderset.cs ===
//------------------------------------------------------------------------------
// <copyright file="DecoderSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// delete this
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\customlinecaptype.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomLineCapType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   CustomLineCapType.cs
*
* Abstract:
*
*   CustomLineCapType constant
*
* Revision History:
*
*   3/14/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Various custom line cap types
     */
    internal enum CustomLineCapType
    {
        Default = 0,
        AdjustableArrowCap = 1
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\emfplusflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="EmfPlusFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EmfPlusFlags.cs
*
* Abstract:
*
*   Native GDI+ Emf+ flags
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * EMF+ Flags
     */
    internal enum EmfPlusFlags
    {
        Display		    = 0x00000001, 
        NonDualGdi          = 0x00000002
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\emftype.cs ===
//------------------------------------------------------------------------------
// <copyright file="EmfType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EmfType.cs
*
* Abstract:
*
*   Native GDI+ Emf Type constants
*
* Revision History:
*
*   10/19/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * EmfType Type
     */
    /// <include file='doc\EmfType.uex' path='docs/doc[@for="EmfType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the metafile type.
    ///    </para>
    /// </devdoc>
    public enum EmfType
    {
        /// <include file='doc\EmfType.uex' path='docs/doc[@for="EmfType.EmfOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Windows enhanced metafile. Contains GDI commands. Metafiles of this type are
        ///       refered to as an EMF file.
        ///    </para>
        /// </devdoc>
        EmfOnly     = MetafileType.Emf,
        /// <include file='doc\EmfType.uex' path='docs/doc[@for="EmfType.EmfPlusOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Windows enhanced metafile plus. Contains GDI+ commands. Metafiles of this
        ///       type are refered to as an EMF+ file.
        ///    </para>
        /// </devdoc>
        EmfPlusOnly = MetafileType.EmfPlusOnly,
        /// <include file='doc\EmfType.uex' path='docs/doc[@for="EmfType.EmfPlusDual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Dual Windows enhanced metafile. Contains equivalent GDI and GDI+ commands.
        ///       Metafiles of this type are refered to as an EMF+ file.
        ///    </para>
        /// </devdoc>
        EmfPlusDual = MetafileType.EmfPlusDual
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encoder.cs ===
//------------------------------------------------------------------------------
// <copyright file="Encoder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Encoder.cs
*
* Abstract:
*
*   Encoder parameter types
*
* Revision History:
*
*   10/19/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Text;

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Encoder Parameter types
     */
    /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class Encoder
    {
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Compression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder Compression = new Encoder(new Guid(unchecked((int)0xe09d739d), unchecked((short)0xccd4), unchecked((short)0x44ee), new byte[] {0x8e, 0xba, 0x3f, 0xbf, 0x8b, 0xe4, 0xfc, 0x58}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.ColorDepth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder ColorDepth = new Encoder(new Guid(0x66087055, unchecked((short)0xad66), unchecked((short)0x4c7c), new byte[] {0x9a, 0x18, 0x38, 0xa2, 0x31, 0x0b, 0x83, 0x37}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.ScanMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder ScanMethod = new Encoder(new Guid(0x3a4e2661, (short)0x3109, (short)0x4e56, new byte[] {0x85, 0x36, 0x42, 0xc1, 0x56, 0xe7, 0xdc, 0xfa}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Version"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder Version = new Encoder(new Guid(0x24d18c76, unchecked((short)0x814a), unchecked((short)0x41a4), new byte[] {0xbf, 0x53, 0x1c, 0x21, 0x9c, 0xcc, 0xf7, 0x97}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.RenderMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder RenderMethod = new Encoder(new Guid(0x6d42c53a, (short)0x229a, (short)0x4825, new byte[] {0x8b, 0xb7, 0x5c, 0x99, 0xe2, 0xb9, 0xa8, 0xb8}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Quality"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder Quality = new Encoder(new Guid(0x1d5be4b5, unchecked((short)0xfa4a), unchecked((short)0x452d), new byte[] {0x9c, 0xdd, 0x5d, 0xb3, 0x51, 0x05, 0xe7, 0xeb}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Transformation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder Transformation = new Encoder(new Guid(unchecked((int)0x8d0eb2d1), unchecked((short)0xa58e), unchecked((short)0x4ea8), new byte[] {0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.LuminanceTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder LuminanceTable = new Encoder(new Guid(unchecked((int)0xedb33bce), unchecked((short)0x0266), unchecked((short)0x4a77), new byte[] {0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.ChrominanceTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder ChrominanceTable = new Encoder(new Guid(unchecked((int)0xf2e455dc), unchecked((short)0x09b3), unchecked((short)0x4316), new byte[] {0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c}));
        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.SaveFlag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Encoder SaveFlag = new Encoder(new Guid(unchecked((int)0x292266fc), unchecked((short)0xac40), unchecked((short)0x47bf), new byte[] {0x8c,0xfc,0xa8,0x5b,0x89,0xa6,0x55,0xde}));
                
        private Guid guid;

        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Encoder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Encoder(Guid guid) {
            this.guid = guid;
        }

        /// <include file='doc\Encoder.uex' path='docs/doc[@for="Encoder.Guid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Guid Guid {
            get { return guid;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\emfplusrecordtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="EmfPlusRecordType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EmfPlusRecordType.cs
*
* Abstract:
*
*   EmfPlusRecordType constants
*
* Revision History:
*
*   11/1/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.ComponentModel;

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /*
     * EmfPlusRecordType constants
     */

    /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the methods available in a metafile to read and write graphic
    ///       commands.
    ///    </para>
    /// </devdoc>
    public enum EmfPlusRecordType
    {
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfRecordBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfRecordBase              = 0x00010000,
        
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetBkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetBkColor              = WmfRecordBase | 0x201,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetBkMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetBkMode               = WmfRecordBase | 0x102,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetMapMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetMapMode              = WmfRecordBase | 0x103,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetROP2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetROP2                 = WmfRecordBase | 0x104,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetRelAbs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetRelAbs               = WmfRecordBase | 0x105,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetPolyFillMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetPolyFillMode         = WmfRecordBase | 0x106,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetStretchBltMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetStretchBltMode       = WmfRecordBase | 0x107,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetTextCharExtra"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetTextCharExtra        = WmfRecordBase | 0x108,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetTextColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetTextColor            = WmfRecordBase | 0x209,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetTextJustification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetTextJustification    = WmfRecordBase | 0x20A,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetWindowOrg"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetWindowOrg            = WmfRecordBase | 0x20B,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetWindowExt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetWindowExt            = WmfRecordBase | 0x20C,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetViewportOrg"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetViewportOrg          = WmfRecordBase | 0x20D,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetViewportExt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetViewportExt          = WmfRecordBase | 0x20E,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfOffsetWindowOrg"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfOffsetWindowOrg         = WmfRecordBase | 0x20F,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfScaleWindowExt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfScaleWindowExt          = WmfRecordBase | 0x410,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfOffsetViewportOrg"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfOffsetViewportOrg       = WmfRecordBase | 0x211,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfScaleViewportExt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfScaleViewportExt        = WmfRecordBase | 0x412,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfLineTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfLineTo                  = WmfRecordBase | 0x213,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfMoveTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfMoveTo                  = WmfRecordBase | 0x214,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfExcludeClipRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfExcludeClipRect         = WmfRecordBase | 0x415,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfIntersectClipRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfIntersectClipRect       = WmfRecordBase | 0x416,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfArc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfArc                     = WmfRecordBase | 0x817,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfEllipse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfEllipse                 = WmfRecordBase | 0x418,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfFloodFill"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfFloodFill               = WmfRecordBase | 0x419,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPie                     = WmfRecordBase | 0x81A,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfRectangle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfRectangle               = WmfRecordBase | 0x41B,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfRoundRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfRoundRect               = WmfRecordBase | 0x61C,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPatBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPatBlt                  = WmfRecordBase | 0x61D,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSaveDC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSaveDC                  = WmfRecordBase | 0x01E,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetPixel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetPixel                = WmfRecordBase | 0x41F,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfOffsetCilpRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfOffsetCilpRgn           = WmfRecordBase | 0x220,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfTextOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfTextOut                 = WmfRecordBase | 0x521,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfBitBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfBitBlt                  = WmfRecordBase | 0x922,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfStretchBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfStretchBlt              = WmfRecordBase | 0xB23,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPolygon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPolygon                 = WmfRecordBase | 0x324,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPolyline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPolyline                = WmfRecordBase | 0x325,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfEscape"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfEscape                  = WmfRecordBase | 0x626,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfRestoreDC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfRestoreDC               = WmfRecordBase | 0x127,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfFillRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfFillRegion              = WmfRecordBase | 0x228,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfFrameRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfFrameRegion             = WmfRecordBase | 0x429,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfInvertRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfInvertRegion            = WmfRecordBase | 0x12A,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPaintRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPaintRegion             = WmfRecordBase | 0x12B,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSelectClipRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSelectClipRegion        = WmfRecordBase | 0x12C,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSelectObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSelectObject            = WmfRecordBase | 0x12D,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetTextAlign"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetTextAlign            = WmfRecordBase | 0x12E,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfChord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfChord                   = WmfRecordBase | 0x830,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetMapperFlags"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetMapperFlags          = WmfRecordBase | 0x231,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfExtTextOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfExtTextOut              = WmfRecordBase | 0xA32,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetDibToDev"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetDibToDev             = WmfRecordBase | 0xD33,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSelectPalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSelectPalette           = WmfRecordBase | 0x234,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfRealizePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfRealizePalette          = WmfRecordBase | 0x035,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfAnimatePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfAnimatePalette          = WmfRecordBase | 0x436,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetPalEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetPalEntries           = WmfRecordBase | 0x037,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfPolyPolygon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfPolyPolygon             = WmfRecordBase | 0x538,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfResizePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfResizePalette           = WmfRecordBase | 0x139,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfDibBitBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfDibBitBlt               = WmfRecordBase | 0x940,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfDibStretchBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfDibStretchBlt           = WmfRecordBase | 0xb41,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfDibCreatePatternBrush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfDibCreatePatternBrush   = WmfRecordBase | 0x142,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfStretchDib"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfStretchDib              = WmfRecordBase | 0xf43,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfExtFloodFill"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfExtFloodFill            = WmfRecordBase | 0x548,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfSetLayout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfSetLayout               = WmfRecordBase | 0x149, // META_SETLAYOUT
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfDeleteObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfDeleteObject            = WmfRecordBase | 0x1f0,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreatePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreatePalette           = WmfRecordBase | 0x0f7,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreatePatternBrush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreatePatternBrush      = WmfRecordBase | 0x1f9,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreatePenIndirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreatePenIndirect       = WmfRecordBase | 0x2fa,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreateFontIndirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreateFontIndirect      = WmfRecordBase | 0x2fb,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreateBrushIndirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreateBrushIndirect     = WmfRecordBase | 0x2fc,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.WmfCreateRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WmfCreateRegion            = WmfRecordBase | 0x6ff,

        // Since we have to enumerate GDI records right along with GDI+ records,
        // we list all the GDI records here so that they can be part of the
        // same enumeration type which is used in the enumeration callback.

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfHeader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfHeader                  = 1,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyBezier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyBezier              = 2,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolygon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolygon                 = 3,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyline                = 4,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyBezierTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyBezierTo            = 5,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyLineTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyLineTo              = 6,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyPolyline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyPolyline            = 7,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyPolygon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyPolygon             = 8,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetWindowExtEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetWindowExtEx          = 9,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetWindowOrgEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetWindowOrgEx          = 10,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetViewportExtEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetViewportExtEx        = 11,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetViewportOrgEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetViewportOrgEx        = 12,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetBrushOrgEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetBrushOrgEx           = 13,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfEof"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfEof                     = 14,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetPixelV"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetPixelV               = 15,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetMapperFlags"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetMapperFlags          = 16,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetMapMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetMapMode              = 17,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetBkMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetBkMode               = 18,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetPolyFillMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetPolyFillMode         = 19,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetROP2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetROP2                 = 20,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetStretchBltMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetStretchBltMode       = 21,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetTextAlign"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetTextAlign            = 22,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetColorAdjustment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetColorAdjustment      = 23,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetTextColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetTextColor            = 24,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetBkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetBkColor              = 25,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfOffsetClipRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfOffsetClipRgn           = 26,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfMoveToEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfMoveToEx                = 27,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetMetaRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetMetaRgn              = 28,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExcludeClipRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExcludeClipRect         = 29,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfIntersectClipRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfIntersectClipRect       = 30,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfScaleViewportExtEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfScaleViewportExtEx      = 31,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfScaleWindowExtEx"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfScaleWindowExtEx        = 32,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSaveDC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSaveDC                  = 33,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfRestoreDC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfRestoreDC               = 34,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetWorldTransform       = 35,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfModifyWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfModifyWorldTransform    = 36,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSelectObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSelectObject            = 37,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreatePen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreatePen               = 38,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreateBrushIndirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreateBrushIndirect     = 39,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfDeleteObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfDeleteObject            = 40,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfAngleArc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfAngleArc                = 41,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfEllipse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfEllipse                 = 42,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfRectangle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfRectangle               = 43,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfRoundRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfRoundRect               = 44,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfRoundArc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfRoundArc                = 45,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfChord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfChord                   = 46,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPie                     = 47,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSelectPalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSelectPalette           = 48,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreatePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreatePalette           = 49,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetPaletteEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetPaletteEntries       = 50,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfResizePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfResizePalette           = 51,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfRealizePalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfRealizePalette          = 52,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtFloodFill"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtFloodFill            = 53,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfLineTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfLineTo                  = 54,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfArcTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfArcTo                   = 55,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyDraw"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyDraw                = 56,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetArcDirection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetArcDirection         = 57,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetMiterLimit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetMiterLimit           = 58,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfBeginPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfBeginPath               = 59,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfEndPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfEndPath                 = 60,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCloseFigure"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCloseFigure             = 61,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfFillPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfFillPath                = 62,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfStrokeAndFillPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfStrokeAndFillPath       = 63,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfStrokePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfStrokePath              = 64,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfFlattenPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfFlattenPath             = 65,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfWidenPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfWidenPath               = 66,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSelectClipPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSelectClipPath          = 67,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfAbortPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfAbortPath               = 68,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfReserved069"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfReserved069             = 69,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfGdiComment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfGdiComment              = 70,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfFillRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfFillRgn                 = 71,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfFrameRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfFrameRgn                = 72,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfInvertRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfInvertRgn               = 73,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPaintRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPaintRgn                = 74,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtSelectClipRgn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtSelectClipRgn        = 75,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfBitBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfBitBlt                  = 76,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfStretchBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfStretchBlt              = 77,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfMaskBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfMaskBlt                 = 78,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPlgBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPlgBlt                  = 79,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetDIBitsToDevice"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetDIBitsToDevice       = 80,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfStretchDIBits"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfStretchDIBits           = 81,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtCreateFontIndirect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtCreateFontIndirect   = 82,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtTextOutA"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtTextOutA             = 83,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtTextOutW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtTextOutW             = 84,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyBezier16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyBezier16            = 85,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolygon16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolygon16               = 86,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyline16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyline16              = 87,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyBezierTo16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyBezierTo16          = 88,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolylineTo16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolylineTo16            = 89,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyPolyline16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyPolyline16          = 90,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyPolygon16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyPolygon16           = 91,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyDraw16"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyDraw16              = 92,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreateMonoBrush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreateMonoBrush         = 93,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreateDibPatternBrushPt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreateDibPatternBrushPt = 94,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtCreatePen"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtCreatePen            = 95,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyTextOutA"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyTextOutA            = 96,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPolyTextOutW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPolyTextOutW            = 97,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetIcmMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetIcmMode              = 98,  // EMR_SETICMMODE,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreateColorSpace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetColorSpace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetColorSpace           = 100, // EMR_SETCOLORSPACE,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfDeleteColorSpace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfGlsRecord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfGlsRecord               = 102, // EMR_GLSRECORD,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfGlsBoundedRecord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfGlsBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPixelFormat"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPixelFormat             = 104, // EMR_PIXELFORMAT,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfDrawEscape"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfDrawEscape              = 105, // EMR_RESERVED_105,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfExtEscape"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfExtEscape               = 106, // EMR_RESERVED_106,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfStartDoc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfStartDoc                = 107, // EMR_RESERVED_107,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSmallTextOut"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSmallTextOut            = 108, // EMR_RESERVED_108,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfForceUfiMapping"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfForceUfiMapping         = 109, // EMR_RESERVED_109,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfNamedEscpae"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfNamedEscpae             = 110, // EMR_RESERVED_110,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfColorCorrectPalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetIcmProfileA"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetIcmProfileA          = 112, // EMR_SETICMPROFILEA,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetIcmProfileW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetIcmProfileW          = 113, // EMR_SETICMPROFILEW,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfAlphaBlend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfAlphaBlend              = 114, // EMR_ALPHABLEND,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetLayout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetLayout               = 115, // EMR_SETLAYOUT,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfTransparentBlt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfReserved117"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfReserved117             = 117, 
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfGradientFill"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfGradientFill            = 118, // EMR_GRADIENTFILL,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetLinkedUfis"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetLinkedUfis           = 119, // EMR_RESERVED_119,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfSetTextJustification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfSetTextJustification    = 120, // EMR_RESERVED_120,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfColorMatchToTargetW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfCreateColorSpaceW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfMax"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfMax                     = 122,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfMin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfMin                     = 1,
    
        // That is the END of the GDI EMF records.
    
        // Now we start the list of EMF+ records.  We leave quite
        // a bit of room here for the addition of any new GDI
        // records that may be added later.
                   
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EmfPlusRecordBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EmfPlusRecordBase          = 0x00004000,                   
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Invalid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Invalid                    = EmfPlusRecordBase,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Header"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Header,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EndOfFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EndOfFile,

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Comment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Comment,

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.GetDC"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GetDC,    // the application grabbed the metafile dc

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.MultiFormatStart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultiFormatStart,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.MultiFormatSection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultiFormatSection,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.MultiFormatEnd"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultiFormatEnd,
        
        // For all Persistent Objects
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Object"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Object,
        // Drawing Records
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Clear,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillRects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillRects,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawRects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawRects,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillPolygon"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillPolygon,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawLines"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawLines,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillEllipse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillEllipse,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawEllipse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawEllipse,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillPie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillPie,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawPie"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawPie,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawArc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawArc,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillRegion,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillPath,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawPath,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.FillClosedCurve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FillClosedCurve,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawClosedCurve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawClosedCurve,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawCurve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawCurve,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawBeziers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawBeziers,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawImage,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawImagePoints"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawImagePoints,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawString,
        
        // Graphics State Records
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetRenderingOrigin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetRenderingOrigin,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetAntiAliasMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetAntiAliasMode,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetTextRenderingHint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetTextRenderingHint,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetTextContrast"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetTextContrast,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetInterpolationMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetInterpolationMode,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetPixelOffsetMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetPixelOffsetMode,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetCompositingMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetCompositingMode,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetCompositingQuality"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetCompositingQuality,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Save"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Save,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Restore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Restore,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.BeginContainer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BeginContainer,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.BeginContainerNoParams"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BeginContainerNoParams,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.EndContainer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EndContainer,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.ResetWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResetWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.MultiplyWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultiplyWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.TranslateWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TranslateWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.ScaleWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ScaleWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.RotateWorldTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RotateWorldTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetPageTransform"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetPageTransform,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.ResetClip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResetClip,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetClipRect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetClipRect,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetClipPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetClipPath,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.SetClipRegion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SetClipRegion,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.OffsetClip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OffsetClip,

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.DrawDriverString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DrawDriverString,

        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Total"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Total,
        
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Max"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Max = Total-1,
        /// <include file='doc\EmfPlusRecordType.uex' path='docs/doc[@for="EmfPlusRecordType.Min"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Min = Header
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encoderset.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncoderSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// delete this
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encoderparametervaluetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncoderParameterValueType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EncoderParameterValueType.cs
*
* Abstract:
*
*   Native GDI+ value type constants
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
*   08/03/2000 minliu
*       Change ValueType to EncoderParameterValueType
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * EncoderParameter Value Type
     */
    /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType"]/*' />
    /// <devdoc>
    ///    Specifies a EncoderParameter data type.
    /// </devdoc>
    public enum EncoderParameterValueType
    {
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeByte"]/*' />
        /// <devdoc>
        ///    The data is an 8-bit unsigned value.
        /// </devdoc>
        ValueTypeByte           = 1,   // 8-bit unsigned int
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeAscii"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data is an 8-bit ASCII value.
        ///    </para>
        /// </devdoc>
        ValueTypeAscii          = 2,   // 8-bit byte containing one 7-bit ASCII
                                       // code. NULL terminated.
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeShort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data is a 16-bit unsigned value.
        ///    </para>
        /// </devdoc>
        ValueTypeShort          = 3,   // 16-bit unsigned int
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeLong"]/*' />
        /// <devdoc>
        ///    The data is a 32-bit unsigned value.
        /// </devdoc>
        ValueTypeLong           = 4,   // 32-bit unsigned int
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeRational"]/*' />
        /// <devdoc>
        ///    The data is two long integers, specifying
        ///    the numerator and the denominator of a rational number, respectively.
        /// </devdoc>
        ValueTypeRational       = 5,   // Two Longs. The first Long is the
                              // numerator, the second Long expresses the
                              // denomintor.
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeLongRange"]/*' />
        /// <devdoc>
        ///    Two values that specify a range of numbers.
        /// </devdoc>
        ValueTypeLongRange      = 6,   // Two longs which specify a range of
                              // integer values. The first Long specifies
                              // the lower end and the second one
                              // specifies the higher end. All values 
                              // are inclusive at both ends
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeUndefined"]/*' />
        /// <devdoc>
        ///    An 8-bit undefined value.
        /// </devdoc>
        ValueTypeUndefined      = 7,   // 8-bit byte that can take any value
                              // depending on field definition
        /// <include file='doc\EncoderParameterValueType.uex' path='docs/doc[@for="EncoderParameterValueType.ValueTypeRationalRange"]/*' />
        /// <devdoc>
        ///    A range of rational numbers.
        /// </devdoc>
        ValueTypeRationalRange  = 8    // Two Rationals. The first Rational
                              // specifies the lower end and the second
                              // specifies the higher end. All values 
                              // are inclusive at both ends
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encoderparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncoderParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EncoderParameter.cs
*
* Abstract:
*
*   Native GDI+ EncoderParam structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System;
    using System.Text;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Drawing.Internal;

    /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class EncoderParameter : IDisposable {
         
        [MarshalAs(UnmanagedType.Struct)]
        Guid parameterGuid;                    // GUID of the parameter
        int numberOfValues;                    // Number of the parameter values  
        int parameterValueType;                // Value type, like ValueTypeLONG  etc.
        IntPtr parameterValue;                    // A pointer to the parameter values
        
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.Finalize"]/*' />
         ~EncoderParameter() {
             Dispose(false);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.Encoder"]/*' />
         /// <devdoc>
         ///    Gets/Sets the Encoder for the EncoderPameter.
         /// </devdoc>
         public Encoder Encoder {
            get {
                return new Encoder(parameterGuid);
            }
            set {
                parameterGuid = Encoder.Guid;
            }
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.Type"]/*' />
         /// <devdoc>
         ///    Gets the EncoderParameterValueType object from the EncoderParameter.
         /// </devdoc>
         public EncoderParameterValueType Type {
            get { 
                return (EncoderParameterValueType)parameterValueType;
            }
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.ValueType"]/*' />
         /// <devdoc>
         ///    Gets the EncoderParameterValueType object from the EncoderParameter.
         /// </devdoc>
         public EncoderParameterValueType ValueType {
            get { 
                return (EncoderParameterValueType)parameterValueType;
            }
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.NumberOfValues"]/*' />
         /// <devdoc>
         ///    Gets the NumberOfValues from the EncoderParameter.
         /// </devdoc>
         public int NumberOfValues {
            get {
                return numberOfValues;
            }
         }
         
         IntPtr ValuePointer {
            get {
                return parameterValue;
            }
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.Dispose"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public void Dispose() {
             Dispose(true);
             GC.KeepAlive(this);
             GC.SuppressFinalize(this);
         }

         void Dispose(bool disposing) {
             if (parameterValue != IntPtr.Zero)
                 Marshal.FreeHGlobal(parameterValue);
             parameterValue = IntPtr.Zero;
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, byte value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeByte;
             numberOfValues = 1;
             parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Byte)));
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
                 
             Marshal.WriteByte(parameterValue, value);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter1"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, byte value, bool undefined)
         {
             parameterGuid = encoder.Guid;
             
             if (undefined == true)
                 parameterValueType = (int)EncoderParameterValueType.ValueTypeUndefined;
             else               
                 parameterValueType = (int)EncoderParameterValueType.ValueTypeByte;
             numberOfValues = 1;
             parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Byte)));
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
                 
             Marshal.WriteByte(parameterValue, value);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter2"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, short value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeShort;
             numberOfValues = 1;
             parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Int16)));
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             Marshal.WriteInt16(parameterValue, value);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter3"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, long value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeLong;
             numberOfValues = 1;
             parameterValue = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Int32)));
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             Marshal.WriteInt32(parameterValue, (int)value);
             GC.KeepAlive(this);
         }
                  
         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter4"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, int numerator, int demoninator)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeRational;
             numberOfValues = 1;
             int size = Marshal.SizeOf(typeof(Int32));
             parameterValue = Marshal.AllocHGlobal(2*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             Marshal.WriteInt32(parameterValue, numerator);
             Marshal.WriteInt32(Add(parameterValue, size), demoninator);
             GC.KeepAlive(this);
         }
         
         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter5"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, long rangebegin, long rangeend)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeLongRange;
             numberOfValues = 1;
             int size = Marshal.SizeOf(typeof(Int32));
             parameterValue = Marshal.AllocHGlobal(2*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

             Marshal.WriteInt32(parameterValue, (int)rangebegin);
             Marshal.WriteInt32(Add(parameterValue, size), (int)rangeend);
             GC.KeepAlive(this);
         }

         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter6"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, 
                                 int numerator1, int demoninator1,
                                 int numerator2, int demoninator2)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeRationalRange;
             numberOfValues = 1;
             int size = Marshal.SizeOf(typeof(Int32));
             parameterValue = Marshal.AllocHGlobal(4*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             Marshal.WriteInt32(parameterValue, numerator1);
             Marshal.WriteInt32(Add(parameterValue, size), demoninator1);
             Marshal.WriteInt32(Add(parameterValue, 2*size), numerator2);
             Marshal.WriteInt32(Add(parameterValue, 3*size), demoninator2);
             GC.KeepAlive(this);
         }
         
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter7"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, string value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeAscii;
             numberOfValues = value.Length;
             parameterValue = Marshal.StringToHGlobalAnsi(value);
             GC.KeepAlive(this);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter8"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, byte[] value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeByte;
             numberOfValues = value.Length;
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
                 
             Marshal.Copy(value, 0, parameterValue, numberOfValues);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter9"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, byte[] value, bool undefined)
         {
             parameterGuid = encoder.Guid;
             
             if (undefined == true)
                 parameterValueType = (int)EncoderParameterValueType.ValueTypeUndefined;
             else               
                 parameterValueType = (int)EncoderParameterValueType.ValueTypeByte;
                 
             numberOfValues = value.Length;
             parameterValue = Marshal.AllocHGlobal(numberOfValues);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
                 
             Marshal.Copy(value, 0, parameterValue, numberOfValues);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter10"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, short[] value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeShort;
             numberOfValues = value.Length;
             int size = Marshal.SizeOf(typeof(short));
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             Marshal.Copy(value, 0, parameterValue, numberOfValues);
             GC.KeepAlive(this);
         }

         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter11"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public unsafe EncoderParameter(Encoder encoder, long[] value)
         {
             parameterGuid = encoder.Guid;
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeLong;
             numberOfValues = value.Length;
             int size = Marshal.SizeOf(typeof(Int32));
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             int* dest = (int*)parameterValue;
             fixed (long* source = value) {
                 for (int i=0; i<value.Length; i++) {
                     dest[i] = (int)source[i];
                 }
             }
             GC.KeepAlive(this);
         }
                  
         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter12"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, int[] numerator, int[] denominator)
         {
             parameterGuid = encoder.Guid;
             
             if (numerator.Length != denominator.Length)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
                                                                
             parameterValueType = (int)EncoderParameterValueType.ValueTypeRational;
             numberOfValues = numerator.Length;
             int size = Marshal.SizeOf(typeof(Int32));
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues*2*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

             for (int i=0; i<numberOfValues; i++)
             {             
                 Marshal.WriteInt32(Add(i*2*size, parameterValue), (int)numerator[i]);
                 Marshal.WriteInt32(Add((i*2+1)*size, parameterValue), (int)denominator[i]);
             }
             GC.KeepAlive(this);
         }
         
         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter13"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, long[] rangebegin, long[] rangeend)
         {
             parameterGuid = encoder.Guid;
             
             if (rangebegin.Length != rangeend.Length)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeLongRange;
             numberOfValues = rangebegin.Length;
             int size = Marshal.SizeOf(typeof(Int32));
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues*2*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

             for (int i=0; i<numberOfValues; i++)
             {
                 Marshal.WriteInt32(Add(i*2*size, parameterValue), (int)rangebegin[i]);
                 Marshal.WriteInt32(Add((i*2+1)*size, parameterValue), (int)rangeend[i]);
             }
             GC.KeepAlive(this);
         }
      
         // Consider supporting a 'float' and converting to numerator/denominator                               
         /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter14"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public EncoderParameter(Encoder encoder, 
                                 int[] numerator1, int[] denominator1,
                                 int[] numerator2, int[] denominator2)
         {
             parameterGuid = encoder.Guid;
             
             if (numerator1.Length != denominator1.Length ||
                 numerator1.Length != denominator2.Length ||
                 denominator1.Length != denominator2.Length)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
             
             parameterValueType = (int)EncoderParameterValueType.ValueTypeRationalRange;
             numberOfValues = numerator1.Length;
             int size = Marshal.SizeOf(typeof(Int32));
             
             parameterValue = Marshal.AllocHGlobal(numberOfValues*4*size);
             
             if (parameterValue == IntPtr.Zero)
                 throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
             
             for (int i=0; i<numberOfValues; i++)
             {
                 Marshal.WriteInt32(Add(parameterValue, 4*i*size), numerator1[i]);
                 Marshal.WriteInt32(Add(parameterValue, (4*i+1)*size), denominator1[i]);
                 Marshal.WriteInt32(Add(parameterValue, (4*i+2)*size), numerator2[i]);
                 Marshal.WriteInt32(Add(parameterValue, (4*i+3)*size), denominator2[i]);
             }
             GC.KeepAlive(this);
        }
        
        // Consider supporting a 'float' and converting to numerator/denominator                               
        /// <include file='doc\EncoderParameter.uex' path='docs/doc[@for="EncoderParameter.EncoderParameter15"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value)
        {
            int size;
            
            switch((EncoderParameterValueType)Type)
            {
            case EncoderParameterValueType.ValueTypeByte:
            case EncoderParameterValueType.ValueTypeAscii: size = 1; break;
            case EncoderParameterValueType.ValueTypeShort: size = 2; break;
            case EncoderParameterValueType.ValueTypeLong: size = 4; break;
            case EncoderParameterValueType.ValueTypeRational: 
            case EncoderParameterValueType.ValueTypeLongRange: size = 2*4; break;
            case EncoderParameterValueType.ValueTypeUndefined: size = 1; break;
            case EncoderParameterValueType.ValueTypeRationalRange: size = 2*2*4; break;
            default:
                throw SafeNativeMethods.StatusException(SafeNativeMethods.WrongState);
            }

            int bytes = size*NumberOfValues;
            
            parameterValue = Marshal.AllocHGlobal(bytes);
                        
            if (parameterValue == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);

            for (int i=0; i<bytes; i++)
            {
                Marshal.WriteByte(Add(parameterValue, i), Marshal.ReadByte((IntPtr)(Value + i)));
            }
            
            parameterValueType = Type;
            numberOfValues = NumberOfValues;
            parameterGuid = encoder.Guid;              
            GC.KeepAlive(this);
        }

        private static IntPtr Add(IntPtr a, int b) {
            return (IntPtr) ((long)a + (long)b);
        }

        private static IntPtr Add(int a, IntPtr b) {
            return (IntPtr) ((long)a + (long)b);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encoderparameters.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncoderParameters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EncoderParameters.cs
*
* Abstract:
*
*   Native GDI+ EncoderParameters structure.
*
* Revision History:
*
*   9/22/1999 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Text;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Drawing.Internal;
    using Marshal = System.Runtime.InteropServices.Marshal;
    using System.Drawing;

    //[StructLayout(LayoutKind.Sequential)]
    /// <include file='doc\EncoderParameters.uex' path='docs/doc[@for="EncoderParameters"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class EncoderParameters : IDisposable {
        EncoderParameter[] param;

        /// <include file='doc\EncoderParameters.uex' path='docs/doc[@for="EncoderParameters.EncoderParameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EncoderParameters(int count) {
             param = new EncoderParameter[count];
        }

        /// <include file='doc\EncoderParameters.uex' path='docs/doc[@for="EncoderParameters.EncoderParameters1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EncoderParameters() {
             param = new EncoderParameter[1];
        }

        /// <include file='doc\EncoderParameters.uex' path='docs/doc[@for="EncoderParameters.Param"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EncoderParameter[] Param {
            // UNDONE : Consider better name? Params?
            //
            get {
                return param;
            }
            set {
                param = value;
            }
        }

        internal IntPtr ConvertToMemory() {
            int size = Marshal.SizeOf(typeof(EncoderParameter));
            Debug.Assert(size == (16 + 4 + 4 + 4), "wrong size! (" + size + ")");
            
            IntPtr memory = (IntPtr)((long)Marshal.AllocHGlobal(param.Length * size  + Marshal.SizeOf(typeof(Int32))));
            
            if (memory == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.OutOfMemory);
                
            Marshal.WriteInt32(memory, param.Length);
                
            for (int i=0; i<param.Length; i++) {                                          
                Marshal.StructureToPtr(param[i], (IntPtr)((long)memory+Marshal.SizeOf(typeof(Int32))+i*size), false);
            }

            return memory;
        }

        internal static EncoderParameters ConvertFromMemory(IntPtr memory) {
            if (memory == IntPtr.Zero)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

            int count;

            count = Marshal.ReadInt32(memory);

            EncoderParameters p;
             
            p = new EncoderParameters(count);
            int size = (int) Marshal.SizeOf(typeof(EncoderParameter));
                        
            for (int i=0; i<count; i++) {
                Guid guid;
                guid = (Guid)UnsafeNativeMethods.PtrToStructure((IntPtr)(i*size+(long)memory+4), typeof(Guid));
                
                int NumberOfValues;
                NumberOfValues = Marshal.ReadInt32((IntPtr)(i*size+(long)memory+4+size-12));

                int Type;
                Type = Marshal.ReadInt32((IntPtr)(i*size+(long)memory+4+size-8));

                int Value;
                Value = Marshal.ReadInt32((IntPtr)(i*size+(long)memory+4+size-4));

                p.param[i] = new EncoderParameter(new Encoder(guid), 
                                                       NumberOfValues, 
                                                       Type, 
                                                       Value);
            }
            
            return p;
        }

        /// <include file='doc\EncoderParameters.uex' path='docs/doc[@for="EncoderParameters.Dispose"]/*' />
        public void Dispose() {
            foreach (EncoderParameter p in param) {
                p.Dispose();
            }
            param = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\encodervalue.cs ===
//------------------------------------------------------------------------------
// <copyright file="EncoderValue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   EncoderValue.cs
*
* Abstract:
*
*   Native GDI+ data values
*
* Revision History:
*
*   10/17/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * EncoderParameter Value Type
     */
    /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The EncoderValue enum.
    ///    </para>
    /// </devdoc>
    public enum EncoderValue
    {
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.ColorTypeCMYK"]/*' />
        /// <devdoc>
        ///    Specifies the CMYK color space.
        /// </devdoc>
        ColorTypeCMYK,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.ColorTypeYCCK"]/*' />
        /// <devdoc>
        ///    Specifies the YCCK color space.
        /// </devdoc>
        ColorTypeYCCK,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.CompressionLZW"]/*' />
        /// <devdoc>
        ///    Specifies the LZW compression method.
        /// </devdoc>
        CompressionLZW,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.CompressionCCITT3"]/*' />
        /// <devdoc>
        ///    For a TIFF image, specifies the CCITT3 compression method.
        /// </devdoc>
        CompressionCCITT3,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.CompressionCCITT4"]/*' />
        /// <devdoc>
        ///    For a TIFF image, specifies the CCITT4 compression method.
        /// </devdoc>
        CompressionCCITT4,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.CompressionRle"]/*' />
        /// <devdoc>
        ///    For a TIFF image, specifies the RLE compression method.
        /// </devdoc>
        CompressionRle,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.CompressionNone"]/*' />
        /// <devdoc>
        ///    For a TIFF image, specifies no compression.
        /// </devdoc>
        CompressionNone,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.ScanMethodInterlaced"]/*' />
        /// <devdoc>
        ///    Specifies interlaced mode.
        /// </devdoc>
        ScanMethodInterlaced,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.ScanMethodNonInterlaced"]/*' />
        /// <devdoc>
        ///    Specifies non-interlaced mode.
        /// </devdoc>
        ScanMethodNonInterlaced,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.VersionGif87"]/*' />
        /// <devdoc>
        ///    For a GIF image, specifies version 87.
        /// </devdoc>
        VersionGif87,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.VersionGif89"]/*' />
        /// <devdoc>
        ///    For a GIF images, specifies version 89a.
        /// </devdoc>
        VersionGif89,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.RenderProgressive"]/*' />
        /// <devdoc>
        ///    Specifies progressive mode.
        /// </devdoc>
        RenderProgressive,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.RenderNonProgressive"]/*' />
        /// <devdoc>
        ///    Specifies non-progressive mode.
        /// </devdoc>
        RenderNonProgressive,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.TransformRotate90"]/*' />
        /// <devdoc>
        ///    For a JPEG image, specifies lossless 90-degree clockwise rotation.
        /// </devdoc>
        TransformRotate90,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.TransformRotate180"]/*' />
        /// <devdoc>
        ///    For a JPEG image, specifies lossless 180-degree rotation.
        /// </devdoc>
        TransformRotate180,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.TransformRotate270"]/*' />
        /// <devdoc>
        ///    For a JPEG image, specifies lossless 270-degree clockwise rotation.
        /// </devdoc>
        TransformRotate270,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.TransformFlipHorizontal"]/*' />
        /// <devdoc>
        ///    For a JPEG image, specifies a lossless horizontal flip.
        /// </devdoc>
        TransformFlipHorizontal,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.TransformFlipVertical"]/*' />
        /// <devdoc>
        ///    For a JPEG image, specifies a lossless vertical flip.
        /// </devdoc>
        TransformFlipVertical,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.MultiFrame"]/*' />
        /// <devdoc>
        ///    Specifies multiframe encoding.
        /// </devdoc>
        MultiFrame,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.LastFrame"]/*' />
        /// <devdoc>
        ///    Specifies the last frame of a multi-frame image.
        /// </devdoc>
        LastFrame,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.Flush"]/*' />
        /// <devdoc>
        ///    Specifies that the encoder object is to be closed. 
        /// </devdoc>
        Flush,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.FrameDimensionTime"]/*' />
        /// <devdoc>
        ///    For a GIF image, specifies the time frame dimension.
        /// </devdoc>
        FrameDimensionTime,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.FrameDimensionResolution"]/*' />
        /// <devdoc>
        ///    Specifies the resolution frame dimension.
        /// </devdoc>
        FrameDimensionResolution,
        /// <include file='doc\EncoderValue.uex' path='docs/doc[@for="EncoderValue.FrameDimensionPage"]/*' />
        /// <devdoc>
        ///    For a TIFF image, specifies the page frame dimension
        /// </devdoc>
        FrameDimensionPage
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\fillmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="FillMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   FillMode.cs
*
* Abstract:
*
*   Fill mode constants
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /*
     * Fill mode constants
     */

/// <include file='doc\FillMode.uex' path='docs/doc[@for="FillMode"]/*' />
/// <devdoc>
///    <para>
///       Specifies how the interior of a closed path
///       is filled.
///    </para>
/// </devdoc>
public enum FillMode {
        /**
         * Odd-even fill rule
         */
        /// <include file='doc\FillMode.uex' path='docs/doc[@for="FillMode.Alternate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the alternate fill mode.
        ///    </para>
        /// </devdoc>
        Alternate = 0,

        /**
         * Non-zero winding fill rule
         */
        /// <include file='doc\FillMode.uex' path='docs/doc[@for="FillMode.Winding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the winding fill mode.
        ///    </para>
        /// </devdoc>
        Winding = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\flushintention.cs ===
//------------------------------------------------------------------------------
// <copyright file="FlushIntention.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   FlushIntention.cs
*
* Abstract:
*
*   Flush intention enum
*
* Revision History:
*
*   2/2/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;

    // FlushIntentionFlush merely means that all the pending commands have been passed to
    // the hardware, and that the final results will be shown as soon as the hardware finishes
    // its rendering.  FlushIntentionSync means to wait for the hardware to actually finish its
    // rendering before returning - this is important for animation and timing loops.
    /// <include file='doc\FlushIntention.uex' path='docs/doc[@for="FlushIntention"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies whether commands in the graphics stack are terminated (flushed)
    ///       immediately or executed as soon as possible.
    ///    </para>
    /// </devdoc>
    public enum FlushIntention {

        // Flush all batched rendering operations
        /// <include file='doc\FlushIntention.uex' path='docs/doc[@for="FlushIntention.Flush"]/*' />
        /// <devdoc>
        ///    Specifies the stack of all graphics
        ///    operations is flushed immediately.
        /// </devdoc>
        Flush = 0,

        // Flush all batched rendering operations and wait for them to complete
        /// <include file='doc\FlushIntention.uex' path='docs/doc[@for="FlushIntention.Sync"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that all graphics operations on the stack are execyted as soon as
        ///       possible. This synchronizes the graphics state.
        ///    </para>
        /// </devdoc>
        Sync = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\fontfamily.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontFamily.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   fontfamily.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ FontFamily object
*
* Revision History:
*
*   10/04/1999 yungt [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/


/*
* font family object (sdkinc\GDIplusFontFamily.h)
*/

namespace System.Drawing {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;    
    using System.Globalization;
    using System.Drawing.Text;
    using System.Drawing;
    using System.Drawing.Internal;

    /**
     * Represent a FontFamily object
     */
    /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily"]/*' />
    /// <devdoc>
    ///    Abstracts a group of type faces having a
    ///    similar basic design but having certain variation in styles.
    /// </devdoc>
    public sealed class FontFamily : MarshalByRefObject, IDisposable {
        ///////////////////////////////////////
        //      Data members

        internal IntPtr nativeFamily;

        internal FontFamily() {
            nativeFamily = IntPtr.Zero; 
        }

        internal FontFamily(IntPtr family) {
            nativeFamily = family; 
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.FontFamily"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.FontFamily'/>
        ///       class with the specified name.
        ///    </para>
        /// </devdoc>
        public FontFamily(string name) : this(name, null) {
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.FontFamily1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.FontFamily'/>
        ///    class in the specified <see cref='System.Drawing.Text.FontCollection'/> and with the specified name.
        /// </devdoc>
        public FontFamily(string name, FontCollection fontCollection) {

            IntPtr fontfamily = IntPtr.Zero;

            IntPtr nativeFontCollection = (fontCollection == null) ? IntPtr.Zero : fontCollection.nativeFontCollection;
            int status = SafeNativeMethods.GdipCreateFontFamilyFromName(name, new HandleRef(fontCollection, nativeFontCollection), out fontfamily);

            // Special case this incredibly common error message to give more information
            if (status == SafeNativeMethods.FontFamilyNotFound)
                throw new ArgumentException(SR.GetString(SR.GdiplusFontFamilyNotFound, name));
            else if (status == SafeNativeMethods.NotTrueTypeFont)
                throw new ArgumentException(SR.GetString(SR.GdiplusNotTrueTypeFont, name));
            else if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            nativeFamily = fontfamily;
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.FontFamily2"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.FontFamily'/>
        ///    class from the specified generic font family.
        /// </devdoc>
        public FontFamily(GenericFontFamilies genericFamily) {
            IntPtr fontfamily = IntPtr.Zero;
            int status;

            switch (genericFamily) {
                case GenericFontFamilies.Serif:

                {
                    status = SafeNativeMethods.GdipGetGenericFontFamilySerif(out fontfamily);
                    break;
                }
                case GenericFontFamilies.SansSerif:
                {
                    status = SafeNativeMethods.GdipGetGenericFontFamilySansSerif(out fontfamily);
                    break;
                }
                case GenericFontFamilies.Monospace:
                default:
                {
                    status = SafeNativeMethods.GdipGetGenericFontFamilyMonospace(out fontfamily);
                    break;
                }
            }   

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            nativeFamily = fontfamily;
        }

        // The managed wrappers do not expose a Clone method, as it's really nothing more
        // than AddRef (it doesn't copy the underlying GpFont), and in a garbage collected
        // world, that's not very useful.

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object obj) {

            if (obj == this)
                return true;
            if (!(obj is FontFamily))
                return false;
            return(((FontFamily)obj).nativeFamily == nativeFamily);
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.ToString"]/*' />
        /// <devdoc>
        ///    Converts this <see cref='System.Drawing.FontFamily'/> to a
        ///    human-readable string.
        /// </devdoc>
        public override string ToString() {
            if (nativeFamily != IntPtr.Zero) {
                return string.Format("[{0}: Name={1}]", GetType().Name, Name);
            }
            else
                return string.Format("[{0}]", GetType().Name);
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetHashCode"]/*' />
        /// <devdoc>
        ///    Gets a hash code for this <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        public override int GetHashCode() {
            return (int) nativeFamily;
        }

        private static int CurrentLanguage {
            get {
                return System.Globalization.CultureInfo.CurrentUICulture.LCID;
            }
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.Dispose"]/*' />
        /// <devdoc>
        ///    Disposes of this <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            if (nativeFamily != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeleteFontFamily(new HandleRef(this, nativeFamily));
                nativeFamily = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.Name"]/*' />
        /// <devdoc>
        ///    Gets the name of this <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        public String Name {
            get { return GetName(CurrentLanguage);}
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retuns the name of this <see cref='System.Drawing.FontFamily'/> in
        ///       the specified language.
        ///    </para>
        /// </devdoc>
        public String GetName(int language) {

            // LF_FACESIZE is 32
            StringBuilder name = new StringBuilder(32);

            int status = SafeNativeMethods.GdipGetFamilyName(new HandleRef(this, nativeFamily), name, language);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return name.ToString();
        }

        internal void SetNative(IntPtr native) {
            nativeFamily = native; 
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.Families"]/*' />
        /// <devdoc>
        ///    Returns an array that contains all of the
        /// <see cref='System.Drawing.FontFamily'/> objects associated with the current graphics 
        ///    context.
        /// </devdoc>
        public static FontFamily[] Families {
            get {
                IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                Graphics graphics = Graphics.FromHdcInternal(screenDC);
                FontFamily[] result = GetFamilies(graphics);
                graphics.Dispose();
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
                return result;
            }
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GenericSansSerif"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a generic SansSerif <see cref='System.Drawing.FontFamily'/>.
        ///    </para>
        /// </devdoc>
        public static FontFamily GenericSansSerif {
            get {
                IntPtr fontfamily = IntPtr.Zero;

                int status = SafeNativeMethods.GdipGetGenericFontFamilySansSerif(out fontfamily);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);


                return new FontFamily(fontfamily);
            }
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GenericSerif"]/*' />
        /// <devdoc>
        ///    Gets a generic Serif <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        public static FontFamily GenericSerif {

            get {
                IntPtr fontfamily = IntPtr.Zero;

                int status = SafeNativeMethods.GdipGetGenericFontFamilySerif(out fontfamily);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return new FontFamily(fontfamily);
            }
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GenericMonospace"]/*' />
        /// <devdoc>
        ///    Gets a generic monospace <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        public static FontFamily GenericMonospace {

            get {
                IntPtr fontfamily = IntPtr.Zero;

                int status = SafeNativeMethods.GdipGetGenericFontFamilyMonospace(out fontfamily);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return new FontFamily(fontfamily);
            }
        }

        // No longer support in FontFamily
        // Obsolete API and need to be removed later
        //
        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetFamilies"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an array that contains all of the <see cref='System.Drawing.FontFamily'/> objects associated with
        ///       the specified graphics context.
        ///    </para>
        /// </devdoc>
        public static FontFamily[] GetFamilies(Graphics graphics) {
            if (graphics == null)
                throw new ArgumentNullException("graphics");

            return new InstalledFontCollection().Families;
            /*            if (graphics == null)
                            throw new ArgumentNullException("graphics");
                        
                        int count = SafeNativeMethods.GdipEnumerableFonts(new HandleRef(graphics, graphics.nativeGraphics));
            
                        int[] gpfamilies = new int[count];
                        int found = 0;
                        
                        int status = SafeNativeMethods.GdipEnumerateFonts(count, gpfamilies, ref found, new HandleRef(graphics, graphics.nativeGraphics));
            
                        if (status != SafeNativeMethods.Ok)
                            throw SafeNativeMethods.StatusException(status);
            
                        Debug.Assert(count == found, "GDI+ can't give a straight answer about how many fonts there are");
                        FontFamily[] families = new FontFamily[count];
                        for (int f = 0; f < count; f++) {
                            families[f] = new FontFamily(gpfamilies[f]);
                        }
            
                        return families;
              */
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.IsStyleAvailable"]/*' />
        /// <devdoc>
        ///    Indicates whether the specified <see cref='System.Drawing.FontStyle'/> is
        ///    available.
        /// </devdoc>
        public bool IsStyleAvailable(FontStyle style) {
            int bresult;

            int status = SafeNativeMethods.GdipIsStyleAvailable(new HandleRef(this, nativeFamily), style, out bresult);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return bresult != 0;
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetEmHeight"]/*' />
        /// <devdoc>
        ///    Gets the size of the Em square for the
        ///    specified style in font design units.
        /// </devdoc>
        public int GetEmHeight(FontStyle style) {
            int result = 0; 

            int status = SafeNativeMethods.GdipGetEmHeight(new HandleRef(this, nativeFamily), style, out result);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return result;
        }


        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetCellAscent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the ascender metric for Windows.
        ///    </para>
        /// </devdoc>
        public int GetCellAscent(FontStyle style) {
            int result = 0; 

            int status = SafeNativeMethods.GdipGetCellAscent(new HandleRef(this, nativeFamily), style, out result);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return result;
        }   

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetCellDescent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the descender metric for Windows.
        ///    </para>
        /// </devdoc>
        public int GetCellDescent(FontStyle style) {
            int result = 0; 

            int status = SafeNativeMethods.GdipGetCellDescent(new HandleRef(this, nativeFamily), style, out result);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return result;
        }

        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.GetLineSpacing"]/*' />
        /// <devdoc>
        ///    Returns the distance between two
        ///    consecutive lines of text for this <see cref='System.Drawing.FontFamily'/> with the specified <see cref='System.Drawing.FontStyle'/>.
        /// </devdoc>
        public int GetLineSpacing(FontStyle style) {
            int result = 0; 

            int status = SafeNativeMethods.GdipGetLineSpacing(new HandleRef(this, nativeFamily), style, out result);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return result;
        }

        /**
         * Object cleanup
         */
        /// <include file='doc\FontFamily.uex' path='docs/doc[@for="FontFamily.Finalize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows an object to free resources before the object is reclaimed by the
        ///       Garbage Collector (<see langword='GC'/>).
        ///    </para>
        /// </devdoc>
        ~FontFamily() {
            Dispose(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\font.cs ===
//------------------------------------------------------------------------------
// <copyright file="Font.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   font.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ font objects
*
* Revision History:
*
*   10/04/1999 yungt [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Diagnostics;
    using System;
    using System.Drawing.Design;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Globalization;

    //--------------------------------------------------------------------------
    // FontStyle: face types and common styles
    //--------------------------------------------------------------------------

    //  These should probably be flags


    /*
     * Represent a font object
     */

    /// <include file='doc\Font.uex' path='docs/doc[@for="Font"]/*' />
    /// <devdoc>
    ///    Defines a particular format for text,
    ///    including font face, size, and style attributes.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(FontConverter)),
    EditorAttribute("System.Drawing.Design.FontEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
    ]
    [Serializable]
    [ComVisible(true)]
    public sealed class Font : MarshalByRefObject, ICloneable, ISerializable, IDisposable {
        const int LogFontCharSetOffset = 23;
        const int LogFontNameOffset = 28;

        //internal const int  ANSI_CHARSET            = 0;
        internal const int  DEFAULT_CHARSET         = 1;
        //internal const int  SYMBOL_CHARSET          = 2;
        //internal const int  SHIFTJIS_CHARSET        = 128;
        //internal const int  HANGEUL_CHARSET         = 129;
        //internal const int  HANGUL_CHARSET          = 129;
        //internal const int  GB2312_CHARSET          = 134;
        //internal const int  CHINESEBIG5_CHARSET     = 136;
        //internal const int  OEM_CHARSET             = 255;
        //internal const int  JOHAB_CHARSET           = 130;
        //internal const int  HEBREW_CHARSET          = 177;
        //internal const int  ARABIC_CHARSET          = 178;
        //internal const int  GREEK_CHARSET           = 161;
        //internal const int  TURKISH_CHARSET         = 162;
        //internal const int  VIETNAMESE_CHARSET      = 163;
        //internal const int  THAI_CHARSET            = 222;
        //internal const int  EASTEUROPE_CHARSET      = 238;
        //internal const int  RUSSIAN_CHARSET         = 204;
        //internal const int  MAC_CHARSET             = 77;
        //internal const int  BALTIC_CHARSET          = 186;

        // Initialized by SetNativeFont
        IntPtr         nativeFont;
        float          fontSize;
        FontStyle      fontStyle;
        FontFamily     fontFamily;
        GraphicsUnit   fontUnit;
        byte           gdiCharSet = DEFAULT_CHARSET; 
        bool           gdiVerticalFont;        
        
#if DEBUG
        string stackOnDispose = null;
        string stackOnCreate = null;
#endif

        /**
         * Constructor used in deserialization
         */
        private Font(SerializationInfo info, StreamingContext context) {
            Debug.Assert(info != null, "Didn't expect a null parameter");

            string name = null;
            float size = -1f;
            FontStyle style = FontStyle.Regular;
            GraphicsUnit unit = GraphicsUnit.Point;

            SerializationInfoEnumerator sie = info.GetEnumerator();
            for (; sie.MoveNext();) {
                if (String.Compare(sie.Name, "Name", true, CultureInfo.InvariantCulture) == 0)
                    name = (string) sie.Value;
                else if (String.Compare(sie.Name, "Size", true, CultureInfo.InvariantCulture) == 0)
                    size = (float) sie.Value;
                else if (String.Compare(sie.Name, "Style", true, CultureInfo.InvariantCulture) == 0)
                    style = (FontStyle) sie.Value;
                else if (String.Compare(sie.Name, "Unit", true, CultureInfo.InvariantCulture) == 0)
                    unit = (GraphicsUnit) sie.Value;
                else {
                    Debug.Fail("Unknown serialization item for font: " + sie.Name);
                }
            }

            Initialize(name, size, style, unit);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        ///     ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            si.AddValue("Name", Name);
            si.AddValue("Size", Size);
            si.AddValue("Style", Style);
            si.AddValue("Unit", Unit);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Font'/> class from
        ///       the specified existing <see cref='System.Drawing.Font'/> and <see cref='System.Drawing.FontStyle'/>.
        ///    </para>
        /// </devdoc>
        public Font(Font prototype, FontStyle newStyle) 
        : this(prototype.FontFamily, prototype.Size, newStyle, prototype.Unit) {
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit) {
            Initialize(family, emSize, style, unit, DEFAULT_CHARSET, false);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font9"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet) {
            Initialize(family, emSize, style, unit, gdiCharSet, false);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font11"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont) {
            Initialize(family, emSize, style, unit, gdiCharSet, gdiVerticalFont);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font10"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet) {
            Initialize(CreateFontFamilyWithFallback(familyName), emSize, style, unit, gdiCharSet, IsVerticalName(familyName));
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font12"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont) {
            Initialize(CreateFontFamilyWithFallback(familyName), emSize, style, unit, gdiCharSet, gdiVerticalFont);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font2"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize, FontStyle style) {
            Initialize(family, emSize, style, GraphicsUnit.Point, DEFAULT_CHARSET, false);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font3"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize, GraphicsUnit unit) {
            Initialize(family, emSize, FontStyle.Regular, unit, DEFAULT_CHARSET, false);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font4"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(FontFamily family, float emSize) {
            Initialize(family, emSize, FontStyle.Regular, GraphicsUnit.Point, DEFAULT_CHARSET, false);
            SuppressFinalizeOnClonedFontFamily();
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font5"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit) {
            Initialize(familyName, emSize, style, unit);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///       the specified
        ///       attributes.
        ///    </para>
        /// </devdoc>
        public Font(string familyName, float emSize, FontStyle style) {
            Initialize(familyName, emSize, style, GraphicsUnit.Point);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font7"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(string familyName, float emSize, GraphicsUnit unit) {
            Initialize(familyName, emSize, FontStyle.Regular, unit);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Font8"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Font'/> class with
        ///    the specified attributes.
        /// </devdoc>
        public Font(string familyName, float emSize) {
            Initialize(familyName, emSize, FontStyle.Regular, GraphicsUnit.Point);
        }

        private Font(IntPtr nativeFont, byte gdiCharSet, bool gdiVerticalFont) {
#if DEBUG
            if (CompModSwitches.LifetimeTracing.Enabled) stackOnCreate = new System.Diagnostics.StackTrace().ToString();
#endif
            SetNativeFont(nativeFont);
            this.gdiCharSet = gdiCharSet;
            this.gdiVerticalFont = gdiVerticalFont;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Bold"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.Font'/> is bold.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool Bold {
            get {
                return(Style & FontStyle.Bold) != 0;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GdiCharSet"]/*' />
        /// <devdoc>
        ///     Returns the GDI char set for this instance of a font. This will only
        ///     be valid if this font was created from a classic GDI font definition,
        ///     like a LOGFONT or HFONT, or it was passed into the constructor.
        ///
        ///     This is here for compatability with native Win32 intrinsic controls
        ///     on non-Unicode platforms.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public byte GdiCharSet {
            get {
                return gdiCharSet;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GdiVerticalFont"]/*' />
        /// <devdoc>
        ///     Determines if this font was created to represt a GDI vertical font.
        ///     his will only be valid if this font was created from a classic GDI
        ///     font definition, like a LOGFONT or HFONT, or it was passed into the 
        ///     constructor.
        ///
        ///     This is here for compatability with native Win32 intrinsic controls
        ///     on non-Unicode platforms.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool GdiVerticalFont {
            get {
                return gdiVerticalFont;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Italic"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.Font'/> is Italic.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool Italic {
            get {
                return(Style & FontStyle.Italic) != 0;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the face name of this <see cref='System.Drawing.Font'/> .
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [Editor("System.Drawing.Design.FontNameEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor))]
        [TypeConverterAttribute(typeof(FontConverter.FontNameConverter))]
        public string Name {
            get { return FontFamily.Name;}
        }

        internal IntPtr NativeFont {
            get {
                Debug.Assert(nativeFont != IntPtr.Zero, "Native font is null!");
                return nativeFont;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Strikeout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.Font'/> is strikeout (has a line
        ///       through it).
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool Strikeout {
            get {
                return(Style & FontStyle.Strikeout) != 0;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Underline"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.Font'/> is underlined.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool Underline {
            get {
                return(Style & FontStyle.Underline) != 0;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public object Clone() {
            IntPtr cloneFont = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneFont(new HandleRef(this, nativeFont), out cloneFont);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            Font newCloneFont = new Font(cloneFont, gdiCharSet, gdiVerticalFont);

            return newCloneFont;
        }

        static FontFamily CreateFontFamilyWithFallback(string familyName) {
            FontFamily family = null;
            if (familyName != null && familyName.Length > 0) {
                try {
                    family = new FontFamily(StripVerticalName(familyName));
                }
                catch (Exception e) {
                    Debug.Fail("Failed to create family '" + familyName + "'", e.ToString());
                }
            }
            if (family == null) {
                family = FontFamily.GenericSansSerif;
            }
            return family;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Equals"]/*' />
        /// <devdoc>
        ///    Returns a value indicating whether the
        ///    specified object is a <see cref='System.Drawing.Font'/> equivalent to this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public override bool Equals(object obj) {

            if (obj == this)
                return true;
            if (!(obj is Font))
                return false;
            Font font = (Font) obj;
            return font.fontFamily.nativeFamily == fontFamily.nativeFamily &&
            font.gdiVerticalFont == gdiVerticalFont &&
            font.gdiCharSet == gdiCharSet &&
            font.fontStyle == fontStyle &&
            font.fontSize == fontSize &&
            font.fontUnit == fontUnit;
        }       

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.FromHfont"]/*' />
        /// <devdoc>
        ///    Creates a <see cref='System.Drawing.Font'/> from the specified Windows
        ///    handle.
        /// </devdoc>
        public static Font FromHfont(IntPtr hfont) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            SafeNativeMethods.LOGFONT lf = new SafeNativeMethods.LOGFONT();
            SafeNativeMethods.GetObject(new HandleRef(null, hfont), lf);
            Font result;
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            try {
                result = Font.FromLogFont(lf, screenDC);
            }
            finally {
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
            }

            return result;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.FromLogFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Font FromLogFont(object lf) {
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            Font result;
            try {
                result = Font.FromLogFont(lf, screenDC);
            }
            finally {
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
            }
            return result;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.FromLogFont1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Font FromLogFont(object lf, IntPtr hdc) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr font = IntPtr.Zero;
            int status;

            if (Marshal.SystemDefaultCharSize == 1)
                status = SafeNativeMethods.GdipCreateFontFromLogfontA(new HandleRef(null, hdc), lf, out font);
            else
                status = SafeNativeMethods.GdipCreateFontFromLogfontW(new HandleRef(null, hdc), lf, out font);

            // Special case this incredibly common error message to give more information
            if (status == SafeNativeMethods.NotTrueTypeFont)
                throw new ArgumentException(SR.GetString(SR.GdiplusNotTrueTypeFont_NoName));
            else if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // GDI+ returns font = 0 even though the status is Ok.
            if (font == IntPtr.Zero)
                throw new ArgumentException("GDI+ does not handle non True-type fonts: " + lf.ToString());

            bool gdiVerticalFont;
            if (Marshal.SystemDefaultCharSize == 1) {
                gdiVerticalFont = (Marshal.ReadByte(lf, LogFontNameOffset) == (byte)(short)'@');
            }
            else {
                gdiVerticalFont = (Marshal.ReadInt16(lf, LogFontNameOffset) == (short)'@');
            }

            return new Font(font, Marshal.ReadByte(lf, LogFontCharSetOffset), gdiVerticalFont);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.FromHdc"]/*' />
        /// <devdoc>
        ///    Creates a Font from the specified Windows
        ///    handle to a device context.
        /// </devdoc>
        public static Font FromHdc(IntPtr hdc) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr font = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateFontFromDC(new HandleRef(null, hdc), ref font);

            // Special case this incredibly common error message to give more information
            if (status == SafeNativeMethods.NotTrueTypeFont)
                throw new ArgumentException(SR.GetString(SR.GdiplusNotTrueTypeFont_NoName));
            else if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Font(font, 0, false);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GetHashCode"]/*' />
        /// <devdoc>
        ///    Gets the hash code for this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public override int GetHashCode() {
            return(int)((UInt32)fontFamily.nativeFamily ^
                        (((UInt32)fontStyle << 13) | ((UInt32)fontStyle >> 19)) ^
                        (((UInt32)fontUnit << 26) | ((UInt32)fontUnit >>  6)) ^
                        (((UInt32)fontSize <<  7) | ((UInt32)fontSize >> 25)));
        }

        private void Initialize(string familyName, float emSize, FontStyle style, GraphicsUnit unit) {
            if (familyName == null) {
                throw new ArgumentNullException("familyName");
            }
            Initialize(CreateFontFamilyWithFallback(familyName), emSize, style, unit, DEFAULT_CHARSET, IsVerticalName(familyName));
        }

        private void Initialize(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont) {
#if DEBUG
            if (CompModSwitches.LifetimeTracing.Enabled) stackOnCreate = new System.Diagnostics.StackTrace().ToString();
#endif

            if (family == null)
                throw new ArgumentNullException("family");
            if (emSize == float.NaN 
                || emSize == float.NegativeInfinity
                || emSize == float.PositiveInfinity
                || emSize <= 0
                || emSize > float.MaxValue) {
                throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "emSize", emSize, 0, "System.Single.MaxValue"), "emSize");
            }
            IntPtr font = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateFont(new HandleRef(family, family.nativeFamily),
                                                emSize,
                                                style,
                                                unit,
                                                out font);

            // Special case this common error message to give more information
            if (status == SafeNativeMethods.FontStyleNotFound)
                throw new ArgumentException(SR.GetString(SR.GdiplusFontStyleNotFound, family.Name, style.ToString()));
            else if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeFont(font);
            this.gdiCharSet = gdiCharSet;
            this.gdiVerticalFont = gdiVerticalFont;
        }

        private static bool IsVerticalName(string familyName) {
            return familyName != null && familyName.Length > 0 && familyName[0] == '@';
        }

        private static string StripVerticalName(string familyName) {
            if (familyName != null && familyName.Length > 1 && familyName[0] == '@') {
                return familyName.Substring(1);
            }
            return familyName;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.ToString"]/*' />
        /// <devdoc>
        ///    Returns a human-readable string
        ///    representation of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public override string ToString() {
            if (nativeFont != IntPtr.Zero) {
                return string.Format("[{0}: Name={1}, Size={2}, Units={3}, GdiCharSet={4}, GdiVerticalFont={5}]", GetType().Name, fontFamily.Name, fontSize, ((int)fontUnit).ToString(), gdiCharSet, gdiVerticalFont);
            }
            else
                return string.Format("[{0}]", GetType().Name);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
        }

        void Dispose(bool disposing) {
            if (nativeFont != IntPtr.Zero) {
                SafeNativeMethods.GdipDeleteFont(new HandleRef(this, nativeFont));
                nativeFont = IntPtr.Zero;

                if (disposing) {
#if DEBUG
                    if (CompModSwitches.LifetimeTracing.Enabled) stackOnDispose = new System.Diagnostics.StackTrace().ToString();
#endif
                    GC.SuppressFinalize(this);
                }
            }
        }

        // Operations

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.ToLogFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ToLogFont(object logFont) {
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            try {
                Graphics graphics = Graphics.FromHdcInternal(screenDC);

                try {
                    this.ToLogFont(logFont, graphics);
                }
                finally {
                    graphics.Dispose();
                }
            }
            finally {
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.ToLogFont1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public unsafe void ToLogFont(object logFont, Graphics graphics) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            if (graphics == null)
                throw new ArgumentNullException("graphics");

            Debug.Assert(nativeFont != IntPtr.Zero, "font is null");
            int status;

            // handle proper marshalling of LogFontName as Unicode or ANSI
            if (Marshal.SystemDefaultCharSize == 1)
                status = SafeNativeMethods.GdipGetLogFontA(new HandleRef(this, nativeFont), new HandleRef(graphics, graphics.nativeGraphics), logFont);
            else
                status = SafeNativeMethods.GdipGetLogFontW(new HandleRef(this, nativeFont), new HandleRef(graphics, graphics.nativeGraphics), logFont);

            // append "@" to the begining of the string if we are 
            // a gdiVerticalFont.
            //
            if (gdiVerticalFont) {
                if (Marshal.SystemDefaultCharSize == 1) {

                    // copy contents of name, over 1 byte
                    //
                    for (int i=30; i>=0; i--) {
                        Marshal.WriteByte(logFont, 
                                          LogFontNameOffset + i + 1, 
                                          Marshal.ReadByte(logFont, LogFontNameOffset + i));
                    }

                    // write ANSI '@' sign at begining of name
                    //
                    Marshal.WriteByte(logFont, LogFontNameOffset, (byte)(int)'@');
                }
                else {
                    // copy contents of name, over 2 bytes (UNICODE)
                    //
                    for (int i=60; i>=0; i-=2) {
                        Marshal.WriteInt16(logFont, 
                                           LogFontNameOffset + i + 2, 
                                           Marshal.ReadInt16(logFont, LogFontNameOffset + i));
                    }

                    // write UNICODE '@' sign at begining of name
                    //
                    Marshal.WriteInt16(logFont, LogFontNameOffset, (short)'@');
                }
            }

            if (Marshal.ReadByte(logFont, LogFontCharSetOffset) == 0) {
                Marshal.WriteByte(logFont, LogFontCharSetOffset, gdiCharSet);
            }
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.ToHfont"]/*' />
        /// <devdoc>
        ///    Returns a handle to this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public IntPtr ToHfont() {
            SafeNativeMethods.LOGFONT lf = new SafeNativeMethods.LOGFONT();
               
            IntSecurity.ObjectFromWin32Handle.Assert();
            try {
                this.ToLogFont(lf);
            }
            finally {
                System.Security.CodeAccessPermission.RevertAssert();
            }

            IntPtr handle = SafeNativeMethods.CreateFontIndirect(lf);
            if (handle == IntPtr.Zero)
                throw new Win32Exception();

            return handle;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GetHeight"]/*' />
        /// <devdoc>
        ///    Returns the height of this Font in the
        ///    specified graphics context.
        /// </devdoc>
        public float GetHeight(Graphics graphics) {
            if (graphics == null)
                throw new ArgumentNullException("graphics");

            float ht;

            int status = SafeNativeMethods.GdipGetFontHeight(new HandleRef(this, nativeFont), new HandleRef(graphics, graphics.nativeGraphics), out ht);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return ht;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GetHeight1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public float GetHeight() {
            
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            float height = 0.0f;
            try {
                using (Graphics graphics = Graphics.FromHdcInternal(screenDC)) {
                    height = GetHeight(graphics);
                }
            }
            finally {
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));                    
            }
                    
            return height;        
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.GetHeight2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public float GetHeight(float dpi) {

            float ht;

            int status = SafeNativeMethods.GdipGetFontHeightGivenDPI(new HandleRef(this, nativeFont), dpi, out ht);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return ht;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.SuppressFinalizeOnClonedFontFamily"]/*' />
        /// <devdoc>
        ///    If we're not creating our own FontFamily, then be sure to suppress finalization on it.
        /// </devdoc>
        void SuppressFinalizeOnClonedFontFamily() {
            new System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode).Assert();
            GC.SuppressFinalize(fontFamily);
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.FontFamily"]/*' />
        /// <devdoc>
        ///    Gets the <see cref='System.Drawing.FontFamily'/> of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        [
        Browsable(false)
        ]
        public FontFamily FontFamily {
            get {
                return fontFamily;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Style"]/*' />
        /// <devdoc>
        ///    Gets style information for this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        [
        Browsable(false)
        ]
        public FontStyle Style {
            get {
                return fontStyle;
            }
        }

        // Return value is in Unit (the unit the font was created in)
        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Size"]/*' />
        /// <devdoc>
        ///    Gets the size of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        public float Size {
            get {
                return fontSize;
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.SizeInPoints"]/*' />
        /// <devdoc>
        ///    Gets the size, in points, of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        [Browsable(false)]
        public float SizeInPoints {
            get {
                if (Unit == GraphicsUnit.Point)
                    return Size;
                else {
                    IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                    Graphics graphics = Graphics.FromHdcInternal(screenDC);
                    float pixelsPerPoint      = (float) (graphics.DpiY / 72.0);
                    float lineSpacingInPixels = this.GetHeight(graphics);
                    graphics.Dispose();
                    UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));

                    float emHeightInPixels    = lineSpacingInPixels * FontFamily.GetEmHeight(Style)
                                                / FontFamily.GetLineSpacing(Style);
                    float emHeightInPoints    = emHeightInPixels / pixelsPerPoint;
                    return emHeightInPoints;
                }
            }
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Unit"]/*' />
        /// <devdoc>
        ///    Gets the unit of measure for this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        [TypeConverterAttribute(typeof(FontConverter.FontUnitConverter))]
        public GraphicsUnit Unit {
            get {
                return fontUnit;
            }
        }

        private void SetNativeFont(IntPtr font) {
            Debug.Assert(font != IntPtr.Zero, "font is null");
            int status;

            nativeFont = font;

            IntPtr nativeFamily = IntPtr.Zero;

            status = SafeNativeMethods.GdipGetFamily(new HandleRef(this, nativeFont), out nativeFamily);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            fontFamily = new FontFamily(nativeFamily);

            GraphicsUnit unit = GraphicsUnit.Point;

            status = SafeNativeMethods.GdipGetFontUnit(new HandleRef(this, nativeFont), out unit);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            fontUnit = unit;

            float size = 0;

            status = SafeNativeMethods.GdipGetFontSize(new HandleRef(this, nativeFont), out size);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            fontSize = size;

            FontStyle style = FontStyle.Regular;

            status = SafeNativeMethods.GdipGetFontStyle(new HandleRef(this, nativeFont), out style);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            fontStyle = style;
        }

        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Height"]/*' />
        /// <devdoc>
        ///    Gets the height of this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        [
        Browsable(false)
        ]
        public int Height {
            get {
                return(int) Math.Ceiling(GetHeight());
            }
        }

        /**
         * Object cleanup
         */
        /// <include file='doc\Font.uex' path='docs/doc[@for="Font.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this <see cref='System.Drawing.Font'/>.
        /// </devdoc>
        ~Font() {
            Dispose(false);
        }
        
        /// <internalonly/>
        class CompModSwitches {
            private static BooleanSwitch lifetimeTracing;
            
            public static BooleanSwitch LifetimeTracing {
                get {
                    if (lifetimeTracing == null) {
                        lifetimeTracing = new BooleanSwitch("LifetimeTracing", "Track lifetime events. This will cause objects to track the stack at creation and dispose.");
                    }
                    return lifetimeTracing;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\fontcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   font.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ font objects
*
* Revision History:
*
*   3/16/2000 yungt [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\FontCollection.uex' path='docs/doc[@for="FontCollection"]/*' />
    /// <devdoc>
    ///    When inherited, enumerates the FontFamily
    ///    objects in a collection of fonts.
    /// </devdoc>
    public abstract class FontCollection : IDisposable {

        internal IntPtr nativeFontCollection;

        
        internal FontCollection() {
            nativeFontCollection = IntPtr.Zero;
        }

        /// <include file='doc\FontCollection.uex' path='docs/doc[@for="FontCollection.Dispose"]/*' />
        /// <devdoc>
        ///    Disposes of this <see cref='System.Drawing.Text.FontCollection'/>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\FontCollection.uex' path='docs/doc[@for="FontCollection.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
            // nothing...
        }

        /// <include file='doc\FontCollection.uex' path='docs/doc[@for="FontCollection.Families"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the array of <see cref='System.Drawing.FontFamily'/>
        ///       objects associated with this <see cref='System.Drawing.Text.FontCollection'/>.
        ///    </para>
        /// </devdoc>
        public FontFamily[] Families {
            get {
                int numSought = 0;
    
                int status = SafeNativeMethods.GdipGetFontCollectionFamilyCount(new HandleRef(this, nativeFontCollection), out numSought);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                IntPtr[] gpfamilies = new IntPtr[numSought];
    
                int numFound = 0;
    
                status = SafeNativeMethods.GdipGetFontCollectionFamilyList(new HandleRef(this, nativeFontCollection), numSought, gpfamilies, 
                                                             out numFound);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);


                Debug.Assert(numSought == numFound, "GDI+ can't give a straight answer about how many fonts there are");
                FontFamily[] families = new FontFamily[numFound];
                for (int f = 0; f < numFound; f++) {
                    IntPtr native;
                    SafeNativeMethods.GdipCloneFontFamily(new HandleRef(null, (IntPtr)gpfamilies[f]), out native);
                    families[f] = new FontFamily(native);
                }

                return families;
            }
        }

        /**
         * Object cleanup
         */
        /// <include file='doc\FontCollection.uex' path='docs/doc[@for="FontCollection.Finalize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows an object to free resources before the object is
        ///       reclaimed by the Garbage Collector (<see langword='GC'/>).
        ///    </para>
        /// </devdoc>
        ~FontCollection() {
            Dispose(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\fontstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* font style constants (sdkinc\GDIplusEnums.h)
*/

namespace System.Drawing {

    using System;
    using System.Diagnostics;
    
    /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies style information applied to
    ///       text.
    ///    </para>
    /// </devdoc>
    [
    Flags
    ]
    public enum FontStyle { 
        /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle.Regular"]/*' />
        /// <devdoc>
        ///    Normal text.
        /// </devdoc>
        Regular    = 0,
        /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle.Bold"]/*' />
        /// <devdoc>
        ///    Bold text.
        /// </devdoc>
        Bold       = 1,
        /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle.Italic"]/*' />
        /// <devdoc>
        ///    Italic text.
        /// </devdoc>
        Italic     = 2,
        /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle.Underline"]/*' />
        /// <devdoc>
        ///    Underlined text.
        /// </devdoc>
        Underline  = 4,
        /// <include file='doc\FontStyle.uex' path='docs/doc[@for="FontStyle.Strikeout"]/*' />
        /// <devdoc>
        ///    Text with a line through the middle.
        /// </devdoc>
        Strikeout  = 8,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\framedimension.cs ===
//------------------------------------------------------------------------------
// <copyright file="FrameDimension.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   FrameDimension.cs
*
* Abstract:
*
*   Image format constant types
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.ComponentModel;

    /**
     * frame dimension constants (used with Bitmap.FrameDimensionsList)
     */
    /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension"]/*' />
    /// <devdoc>
    ///    
    /// </devdoc>
    // [TypeConverterAttribute(typeof(FrameDimensionConverter))]
    public sealed class FrameDimension {
        // Frame dimension GUIDs, from sdkinc\imgguids.h
        private static FrameDimension time = new FrameDimension(new Guid("{6aedbd6d-3fb5-418a-83a6-7f45229dc872}"));
        private static FrameDimension resolution = new FrameDimension(new Guid("{84236f7b-3bd3-428f-8dab-4ea1439ca315}"));
        private static FrameDimension page = new FrameDimension(new Guid("{7462dc86-6180-4c7e-8e3f-ee7333a7a483}"));

        private Guid guid;

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.FrameDimension"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.FrameDimension'/> class with the specified GUID.
        /// </devdoc>
        public FrameDimension(Guid guid) {
            this.guid = guid;
        }

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.Guid"]/*' />
        /// <devdoc>
        ///    Specifies a global unique identifier (GUID)
        ///    that represents this <see cref='System.Drawing.Imaging.FrameDimension'/>.
        /// </devdoc>
        public Guid Guid {
            get { return guid;}
        }

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.Time"]/*' />
        /// <devdoc>
        ///    The time dimension.
        /// </devdoc>
        public static FrameDimension Time {
            get { return time;}
        }

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.Resolution"]/*' />
        /// <devdoc>
        ///    The resolution dimension.
        /// </devdoc>
        public static FrameDimension Resolution {
            get { return resolution;}
        }

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.Page"]/*' />
        /// <devdoc>
        ///    The page dimension.
        /// </devdoc>
        public static FrameDimension Page {
            get { return page;}
        }
        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.Equals"]/*' />
        /// <devdoc>
        ///    Returns a value indicating whether the
        ///    specified object is an <see cref='System.Drawing.Imaging.FrameDimension'/> equivalent to this <see cref='System.Drawing.Imaging.FrameDimension'/>.
        /// </devdoc>
        public override bool Equals(object o) {
            FrameDimension format = o as FrameDimension;
            if (format == null)
                return false;
            return this.guid == format.guid;
        }

        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return guid.GetHashCode();
        }
        
        /// <include file='doc\FrameDimension.uex' path='docs/doc[@for="FrameDimension.ToString"]/*' />
        /// <devdoc>
        ///    Converts this <see cref='System.Drawing.Imaging.FrameDimension'/> to a human-readable string.
        /// </devdoc>
        public override string ToString() {
            if (this == time) return "Time";
            if (this == resolution) return "Resolution";
            if (this == page) return "Page";
            return "[FrameDimension: " + guid + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gppoint.cs ===
//------------------------------------------------------------------------------
// <copyright file="GPPOINT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GPPOINT.cs
*
* Abstract:
*
*   Native GDI+ integer coordinate point structure.
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Internal {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal class GPPOINT
    {
        internal int X;
        internal int Y;

    	 internal GPPOINT()
    	 {
    	 }

    	 internal GPPOINT(PointF pt)
    	 {
    		 X = (int) pt.X;
    		 Y = (int) pt.Y;
    	 }

    	 internal GPPOINT(Point pt)
    	 {
    		 X = pt.X;
    		 Y = pt.Y;
    	 }

    	 internal PointF ToPoint()
    	 {
    		 return new PointF(X, Y);
    	 }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\genericfontfamilies.cs ===
//------------------------------------------------------------------------------
// <copyright file="GenericFontFamilies.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GenericFontFamilies.cs
*
* Abstract:
*
*   Native GDI+ GenericFontFamilies flags
*
* Revision History:
*
*   3/1/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Drawing;
    using System;

    /**
     * GenericFontFamilies
     */
    /// <include file='doc\GenericFontFamilies.uex' path='docs/doc[@for="GenericFontFamilies"]/*' />
    /// <devdoc>
    ///    Specifies a generic <see cref='System.Drawing.FontFamily'/>.
    /// </devdoc>
    public enum GenericFontFamilies
    {
        /// <include file='doc\GenericFontFamilies.uex' path='docs/doc[@for="GenericFontFamilies.Serif"]/*' />
        /// <devdoc>
        ///    A generic Serif <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        Serif,
        /// <include file='doc\GenericFontFamilies.uex' path='docs/doc[@for="GenericFontFamilies.SansSerif"]/*' />
        /// <devdoc>
        ///    A generic SansSerif <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        SansSerif,
        /// <include file='doc\GenericFontFamilies.uex' path='docs/doc[@for="GenericFontFamilies.Monospace"]/*' />
        /// <devdoc>
        ///    A generic Monospace <see cref='System.Drawing.FontFamily'/>.
        /// </devdoc>
        Monospace
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gppointf.cs ===
//------------------------------------------------------------------------------
// <copyright file="GPPOINTF.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GPPOINTF.cpp
*
* Abstract:
*
*   Native GDI+ floating-point coordinate point structure.
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Internal {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal class GPPOINTF {
        internal float X;
        internal float Y;

        internal GPPOINTF() {
        }

        internal GPPOINTF(PointF pt) {
            X = pt.X;
            Y = pt.Y;
        }

        internal GPPOINTF(Point pt) {
            X = (float) pt.X;
            Y = (float) pt.Y;
        }

        internal PointF ToPoint() {
            return new PointF(X, Y);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gprect.cs ===
//------------------------------------------------------------------------------
// <copyright file="GPRECT.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GPRECT.cpp
*
* Abstract:
*
*   Native GDI+ integer coordinate rectangle structure.
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Internal {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal struct GPRECT {
        internal int X;
        internal int Y;
        internal int Width;
        internal int Height;

        internal GPRECT(int x, int y, int width, int height) {
            X = x;
            Y = y;
            Width = width;
            Height = height;
        }

        internal GPRECT(Rectangle rect) {
            X = rect.X;
            Y = rect.Y;
            Width = rect.Width;
            Height = rect.Height;
        }

        internal Rectangle ToRectangle() {
            return new Rectangle(X, Y, Width, Height);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\graphicspathiterator.cs ===
//------------------------------------------------------------------------------
// <copyright file="GraphicsPathIterator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GraphicsPathIterator.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ path iterator objects
*
* Revision History:
*
*    3/15/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Drawing;
    using System.ComponentModel;
    using System.Drawing.Internal;
    
    /**
     * Represent a Path Iterator object
     */
    /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides helper functions for the <see cref='System.Drawing.Drawing2D.GraphicsPath'/> class.
    ///    </para>
    /// </devdoc>
    public sealed class GraphicsPathIterator : MarshalByRefObject, IDisposable {
        /**
         * Create a new path iterator object
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.GraphicsPathIterator"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.GraphicsPathIterator'/> class with the specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public GraphicsPathIterator(GraphicsPath path)
        {
            IntPtr nativeIter = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreatePathIter(out nativeIter, new HandleRef(path, (path == null) ? IntPtr.Zero : path.nativePath));
                                        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativeIter = nativeIter;
        }

        /**
         * Dispose of resources associated with the
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Drawing2D.GraphicsPathIterator'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            if (nativeIter != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeletePathIter(new HandleRef(this, nativeIter));

                nativeIter = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

            }
        }

        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Drawing2D.GraphicsPathIterator'/>.
        /// </devdoc>
        ~GraphicsPathIterator() {
            Dispose(false);
        }

        /**
         * Next subpath in path
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.NextSubpath"]/*' />
        /// <devdoc>
        ///    Returns the number of subpaths in the
        /// <see cref='System.Drawing.Drawing2D.GraphicsPath'/>. The start index and end index of the 
        ///    next subpath are contained in out parameters.
        /// </devdoc>
        public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed) {
            int resultCount = 0;
            int status = SafeNativeMethods.GdipPathIterNextSubpath(new HandleRef(this, nativeIter), out resultCount,
                                    out startIndex, out endIndex, out isClosed);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return resultCount;
        }

        /**
         * Next subpath in path
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.NextSubpath1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NextSubpath(GraphicsPath path, out bool isClosed) {
            int resultCount = 0;
            int status = SafeNativeMethods.GdipPathIterNextSubpathPath(new HandleRef(this, nativeIter), out resultCount,
                                    new HandleRef(path, (path == null) ? IntPtr.Zero : path.nativePath), out isClosed);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return resultCount;
        }
        
        /**
         * Next type in subpath
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.NextPathType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NextPathType(out byte pathType, out int startIndex, out int endIndex)
        {
            int resultCount = 0;
            int status = SafeNativeMethods.GdipPathIterNextPathType(new HandleRef(this, nativeIter), out resultCount,
                                    out pathType, out startIndex, out endIndex);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return resultCount;
        }

        /**
         * Next marker in subpath
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.NextMarker"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NextMarker(out int startIndex, out int endIndex)
        {
            int resultCount = 0;
            int status = SafeNativeMethods.GdipPathIterNextMarker(new HandleRef(this, nativeIter), out resultCount,
                                    out startIndex, out endIndex);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return resultCount;
        }
        
        /**
         * Next marker in subpath
         */
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.NextMarker1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NextMarker(GraphicsPath path)
        {
            int resultCount = 0;
            int status = SafeNativeMethods.GdipPathIterNextMarkerPath(new HandleRef(this, nativeIter), out resultCount,
                                    new HandleRef(path, (path == null) ? IntPtr.Zero : path.nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return resultCount;
        }

        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count
        {
            get {
                int resultCount = 0;
                int status = SafeNativeMethods.GdipPathIterGetCount(new HandleRef(this, nativeIter), out resultCount);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
                
                return resultCount;
            }
        }

        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.SubpathCount"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int SubpathCount
        {
            get {
                int resultCount = 0;
                int status = SafeNativeMethods.GdipPathIterGetSubpathCount(new HandleRef(this, nativeIter), out resultCount);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
                
                return resultCount;
            }
        }
        
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.HasCurve"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool HasCurve()
        {
            bool hasCurve = false;
                
            int status = SafeNativeMethods.GdipPathIterHasCurve(new HandleRef(this, nativeIter), out hasCurve);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return hasCurve;
        }
          
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.Rewind"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Rewind()
        {
            int status = SafeNativeMethods.GdipPathIterRewind(new HandleRef(this, nativeIter));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.Enumerate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Enumerate(ref PointF[] points, ref byte[] types)
        {
            if (points.Length != types.Length)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
                
            int resultCount = 0;
            GPPOINTF pt = new GPPOINTF();

            int size =  (int) Marshal.SizeOf(pt.GetType());
            int count = points.Length;

            IntPtr memoryPts =  Marshal.AllocHGlobal(count*size);
            
            int status = SafeNativeMethods.GdipPathIterEnumerate(new HandleRef(this, nativeIter), out resultCount,
                                memoryPts, types, points.Length);

            if (status != SafeNativeMethods.Ok)
            {
                Marshal.FreeHGlobal(memoryPts);
                throw SafeNativeMethods.StatusException(status);
            }
            
            points = SafeNativeMethods.ConvertGPPOINTFArrayF(memoryPts, points.Length);
            Marshal.FreeHGlobal(memoryPts);
            
            return resultCount;
        }
                   
        /// <include file='doc\GraphicsPathIterator.uex' path='docs/doc[@for="GraphicsPathIterator.CopyData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int CopyData(ref PointF[] points, ref byte[] types, int startIndex, int endIndex)
        {
            if (points.Length != types.Length)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
                
            int resultCount = 0;
            GPPOINTF pt = new GPPOINTF();

            int size =  (int)Marshal.SizeOf(pt.GetType());
            int count = points.Length;

            IntPtr memoryPts =  Marshal.AllocHGlobal(count*size);
            
            int status = SafeNativeMethods.GdipPathIterCopyData(new HandleRef(this, nativeIter), out resultCount,
                                memoryPts, types, startIndex, endIndex);

            if (status != SafeNativeMethods.Ok)
            {
                Marshal.FreeHGlobal(memoryPts);
                throw SafeNativeMethods.StatusException(status);
            }
            
            points = SafeNativeMethods.ConvertGPPOINTFArrayF(memoryPts, points.Length);
            Marshal.FreeHGlobal(memoryPts);
            
            return resultCount;
        }
        
        /*
         * handle to native path iterator object
         */
        internal IntPtr nativeIter;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gpstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="GPStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Internal {

    using System;
    using System.IO;
    using System.Drawing;
    using System.Runtime.InteropServices;

    internal class GPStream : UnsafeNativeMethods.IStream {
        protected Stream dataStream;

        // to support seeking ahead of the stream length...
        long virtualPosition = -1;

        internal GPStream(Stream stream) {
            if (!stream.CanSeek) {
                const int ReadBlock = 256;
                byte[] bytes = new byte[ReadBlock];
                int readLen;
                int current = 0;
                do {
                    if (bytes.Length < current + ReadBlock) {
                        byte[] newData = new byte[bytes.Length * 2];
                        Array.Copy(bytes, newData, bytes.Length);
                        bytes = newData;
                    }
                    readLen = stream.Read(bytes, current, ReadBlock);
                    current += readLen;
                } while (readLen != 0);

                dataStream = new MemoryStream(bytes);
            }
            else {
                dataStream = stream;
            }
        }

        private void ActualizeVirtualPosition() {
            if (virtualPosition == -1) return;

            if (virtualPosition > dataStream.Length)
                dataStream.SetLength(virtualPosition);

            dataStream.Position = virtualPosition;

            virtualPosition = -1;
        }

        public virtual UnsafeNativeMethods.IStream Clone() {
            NotImplemented();
            return null;
        }

        public virtual void Commit(int grfCommitFlags) {
            dataStream.Flush();
            // Extend the length of the file if needed.
            ActualizeVirtualPosition();
        }

        public virtual long CopyTo(UnsafeNativeMethods.IStream pstm, long cb, long[] pcbRead) {
            int bufsize = 4096; // one page
            IntPtr buffer = Marshal.AllocHGlobal(bufsize);
            if (buffer == IntPtr.Zero) throw new OutOfMemoryException();
            long written = 0;
            try {
                while (written < cb) {
                    int toRead = bufsize;
                    if (written + toRead > cb) toRead  = (int) (cb - written);
                    int read = Read(buffer, toRead);
                    if (read == 0) break;
                    if (pstm.Write(buffer, read) != read) {
                        throw EFail("Wrote an incorrect number of bytes");
                    }
                    written += read;
                }
            }
            finally {
                Marshal.FreeHGlobal(buffer);
            }
            if (pcbRead != null && pcbRead.Length > 0) {
                pcbRead[0] = written;
            }

            return written;
        }

        public virtual Stream GetDataStream() {
            return dataStream;
        }

        public virtual void LockRegion(long libOffset, long cb, int dwLockType) {
        }

        protected static ExternalException EFail(string msg) {
            ExternalException e = new ExternalException(msg, SafeNativeMethods.E_FAIL);
            throw e;
        }

        protected static void NotImplemented() {
            ExternalException e = new ExternalException("Not implemented.", SafeNativeMethods.E_NOTIMPL);
            throw e;
        }

        public virtual int Read(IntPtr buf, /* cpr: int offset,*/  int length) {
            //        System.Text.Out.WriteLine("IStream::Read(" + length + ")");
            byte[] buffer = new byte[length];
            int count = Read(buffer, length);
            Marshal.Copy(buffer, 0, buf, length);
            return count;
        }

        public virtual int Read(byte[] buffer, /* cpr: int offset,*/  int length) {
            ActualizeVirtualPosition();
            return dataStream.Read(buffer, 0, length);
        }

        public virtual void Revert() {
            NotImplemented();
        }

        public virtual long Seek(long offset, int origin) {
            // Console.WriteLine("IStream::Seek("+ offset + ", " + origin + ")");
            long pos = virtualPosition;
            if (virtualPosition == -1) {
                pos = dataStream.Position;
            }
            long len = dataStream.Length;
            switch (origin) {
                case SafeNativeMethods.StreamConsts.STREAM_SEEK_SET:
                    if (offset <= len) {
                        dataStream.Position = offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = offset;
                    }
                    break;
                case SafeNativeMethods.StreamConsts.STREAM_SEEK_END:
                    if (offset <= 0) {
                        dataStream.Position = len + offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = len + offset;
                    }
                    break;
                case SafeNativeMethods.StreamConsts.STREAM_SEEK_CUR:
                    if (offset+pos <= len) {
                        dataStream.Position = pos + offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = offset + pos;
                    }
                    break;
            }
            if (virtualPosition != -1) {
                return virtualPosition;
            }
            else {
                return dataStream.Position;
            }
        }

        public virtual void SetSize(long value) {
            dataStream.SetLength(value);
        }

        public void Stat(IntPtr pstatstg, int grfStatFlag) {
            STATSTG stats = new STATSTG();
            stats.cbSize = dataStream.Length;
            Marshal.StructureToPtr(stats, pstatstg, true);
        }

        public virtual void UnlockRegion(long libOffset, long cb, int dwLockType) {
        }

        public virtual int Write(IntPtr buf, /* cpr: int offset,*/ int length) {
            byte[] buffer = new byte[length];
            Marshal.Copy(buf, buffer, 0, length);
            return Write(buffer, length);
        }

        public virtual int Write(byte[] buffer, /* cpr: int offset,*/ int length) {
            ActualizeVirtualPosition();
            dataStream.Write(buffer, 0, length);
            return length;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        public class STATSTG {
            public   IntPtr pwcsName;
            public   int type = 0;
            [MarshalAs(UnmanagedType.I8)]
            public   long cbSize;
            [MarshalAs(UnmanagedType.I8)]
            public   long mtime;
            [MarshalAs(UnmanagedType.I8)]
            public   long ctime;
            [MarshalAs(UnmanagedType.I8)]
            public   long atime;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfMode;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfLocksSupported;
            
            public   int clsid_data1;
            [MarshalAs(UnmanagedType.I2)]
            public   short clsid_data2;
            [MarshalAs(UnmanagedType.I2)]
            public   short clsid_data3;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b0;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b1;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b2;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b3;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b4;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b5;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b6;
            [MarshalAs(UnmanagedType.U1)]
            public   byte clsid_b7;
            [MarshalAs(UnmanagedType.I4)]
            public   int grfStateBits;
            [MarshalAs(UnmanagedType.I4)]
            public   int reserved;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\graphicsstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="GraphicsState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GraphicsState.cs
*
* Abstract:
*
*   What Graphics.Save saves and Graphics.Restore restores
*
* Revision History:
*
*   11/10/99 nkramer
*       Created it.
*
\**************************************************************************/


namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;

    /// <include file='doc\GraphicsState.uex' path='docs/doc[@for="GraphicsState"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class GraphicsState : MarshalByRefObject {
        internal int nativeState;

        internal GraphicsState(int nativeState) {
            this.nativeState = nativeState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\graphicspath.cs ===
//------------------------------------------------------------------------------
// <copyright file="GraphicsPath.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GraphicsPath.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ path objects
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using Microsoft.Win32;
    using System.Drawing;
    using System.ComponentModel;
    using System.Drawing.Internal;
    
    /**
     * Represent a Path object
     */
    /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath"]/*' />
    /// <devdoc>
    ///    Represents a series of connected lines and
    ///    curves.
    /// </devdoc>
    public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable {

        /*
         * handle to native path object
         */
        internal IntPtr nativePath;

        /**
         * Create a new path object with the default fill mode
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.GraphicsPath'/> class with a <see cref='System.Drawing.Drawing2D.FillMode'/> of <see cref='System.Drawing.Drawing2D.FillMode.Alternate'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public GraphicsPath() : this(System.Drawing.Drawing2D.FillMode.Alternate) { }

        /**
         * Create a new path object with the specified fill mode
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.GraphicsPath'/> class with the specified <see cref='System.Drawing.Drawing2D.FillMode'/>.
        /// </devdoc>
        public GraphicsPath(FillMode fillMode) {
            IntPtr nativePath = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreatePath((int)fillMode, out nativePath);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativePath = nativePath;
        }

        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath2"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Initializes a new instance of the
        ///    <see cref='System.Drawing.Drawing2D.GraphicsPath'/> array with the
        ///    specified <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/>
        ///    and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> arrays.
        ///    </para>
        /// </devdoc>
        public GraphicsPath(PointF[] pts, byte[] types) :
          this(pts, types, System.Drawing.Drawing2D.FillMode.Alternate) {}
                  
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.GraphicsPath'/> array with the
        ///       specified <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/> and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> arrays and with the
        ///       specified <see cref='System.Drawing.Drawing2D.FillMode'/>.
        ///    </para>
        /// </devdoc>
        public GraphicsPath(PointF[] pts, byte[] types, FillMode fillMode) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr nativePath = IntPtr.Zero;
                  
            if (pts == null)
                throw new ArgumentNullException("points");
            if (pts.Length != types.Length)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

            int count = types.Length;
            IntPtr ptbuf = SafeNativeMethods.ConvertPointToMemory(pts);
            IntPtr typebuf = Marshal.AllocHGlobal(count);

            Marshal.Copy(types, 0, typebuf, count);

            int status = SafeNativeMethods.GdipCreatePath2(new HandleRef(null, ptbuf), new HandleRef(null, typebuf), count,
                                                 (int)fillMode, out nativePath);

            Marshal.FreeHGlobal(ptbuf);
            Marshal.FreeHGlobal(typebuf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativePath = nativePath;
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath4"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Initializes a new instance of the
        ///    <see cref='System.Drawing.Drawing2D.GraphicsPath'/> array with the
        ///    specified <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/>
        ///    and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> arrays.
        ///    </para>
        /// </devdoc>
        public GraphicsPath(Point[] pts, byte[] types) :
          this(pts, types, System.Drawing.Drawing2D.FillMode.Alternate) {}
          
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GraphicsPath5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.GraphicsPath'/> array with the
        ///       specified <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/> and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> arrays and with the
        ///       specified <see cref='System.Drawing.Drawing2D.FillMode'/>.
        ///    </para>
        /// </devdoc>
        public GraphicsPath(Point[] pts, byte[] types, FillMode fillMode) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr nativePath = IntPtr.Zero;

            if (pts.Length != types.Length)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

            int count = types.Length;
            IntPtr ptbuf = SafeNativeMethods.ConvertPointToMemory(pts);
            IntPtr typebuf = Marshal.AllocHGlobal(count);

            Marshal.Copy(types, 0, typebuf, count);

            int status = SafeNativeMethods.GdipCreatePath2I(new HandleRef(null, ptbuf), new HandleRef(null, typebuf), count,
                                                  (int)fillMode, out nativePath);

            Marshal.FreeHGlobal(ptbuf);
            Marshal.FreeHGlobal(typebuf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativePath = nativePath;
        }

        /**
         * Make a copy of the current path object
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public object Clone() {
            IntPtr clonePath = IntPtr.Zero;

            int status = SafeNativeMethods.GdipClonePath(new HandleRef(this, nativePath), out clonePath);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new GraphicsPath(clonePath, 0);

        }

        /**
         * 'extra' parameter is necessary to avoid conflict with
         * other constructor GraphicsPath(int fillmode)
         */

        private GraphicsPath(IntPtr nativePath, int extra) {
            if (nativePath == IntPtr.Zero)
                throw new ArgumentNullException("nativePath");

            this.nativePath = nativePath;
        }

        /**
         * Dispose of resources associated with the
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Dispose"]/*' />
        /// <devdoc>
        ///    Eliminates resources for this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        void Dispose(bool disposing) {
            if (nativePath != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeletePath(new HandleRef(this, nativePath));

                nativePath = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Finalize"]/*' />
        /// <devdoc>
        ///    Eliminates resources for this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        ~GraphicsPath() {
            Dispose(false);
        }

        /**
         * Reset the path object to empty
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Reset"]/*' />
        /// <devdoc>
        ///    Empties the <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/>
        ///    and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/> arrays
        ///    and sets the <see cref='System.Drawing.Drawing2D.GraphicsPath.FillMode'/> to
        ///    <see cref='System.Drawing.Drawing2D.FillMode.Alternate'/>.
        /// </devdoc>
        public void Reset() {
            int status = SafeNativeMethods.GdipResetPath(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /**
         * Get path fill mode information
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.FillMode"]/*' />
        /// <devdoc>
        ///    Gets or sets a <see cref='System.Drawing.Drawing2D.FillMode'/> that determines how the interiors of
        ///    shapes in this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> are filled.
        /// </devdoc>
        public FillMode FillMode {
            get {
                int fillmode = 0;

                int status = SafeNativeMethods.GdipGetPathFillMode(new HandleRef(this, nativePath), out fillmode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return(FillMode) fillmode;
            }
            set {
                //validate the FillMode enum
                if (!Enum.IsDefined(typeof(FillMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(FillMode));
                }

                int status = SafeNativeMethods.GdipSetPathFillMode(new HandleRef(this, nativePath), (int) value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        private PathData _GetPathData() {
            int temp = 0;
            int intSize = (int) Marshal.SizeOf(temp);
            
            GPPOINTF pt = new GPPOINTF();
            int ptSize = (int) Marshal.SizeOf(pt);

            int numPts = PointCount;
            
            PathData pathData = new PathData();
            pathData.Types = new byte[numPts];

            IntPtr memoryPathData = Marshal.AllocHGlobal(intSize*3);
            IntPtr memoryPoints = Marshal.AllocHGlobal(ptSize*numPts);
            GCHandle typesHandle = GCHandle.Alloc(pathData.Types, GCHandleType.Pinned);
            IntPtr typesPtr = typesHandle.AddrOfPinnedObject();
            //IntPtr typesPtr = Marshal.AddrOfArrayElement(pathData.Types, IntPtr.Zero);
            
            Marshal.StructureToPtr(numPts, memoryPathData, false);
            Marshal.StructureToPtr(memoryPoints, (IntPtr)((long)memoryPathData+intSize), false);
            Marshal.StructureToPtr(typesPtr, (IntPtr)((long)memoryPathData+intSize*2), false);

            int status = SafeNativeMethods.GdipGetPathData(new HandleRef(this, nativePath), memoryPathData);

            if (status != SafeNativeMethods.Ok)
            {
                Marshal.FreeHGlobal(memoryPathData);
                Marshal.FreeHGlobal(memoryPoints);
                throw SafeNativeMethods.StatusException(status);
            }

            pathData.Points = SafeNativeMethods.ConvertGPPOINTFArrayF(memoryPoints, numPts);

            typesHandle.Free();
            Marshal.FreeHGlobal(memoryPathData);
            Marshal.FreeHGlobal(memoryPoints);
    
            return pathData;
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.PathData"]/*' />
        /// <devdoc>
        ///    Gets a <see cref='System.Drawing.Drawing2D.PathData'/> object that
        ///    encapsulates both the <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> and <see cref='System.Drawing.Drawing2D.GraphicsPath.PathTypes'/> arrays of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public PathData PathData {
            get {
                return _GetPathData();
            }
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.StartFigure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts a new figure without closing the
        ///       current figure. All subsequent points added to the path are added to this new
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void StartFigure() {
            int status = SafeNativeMethods.GdipStartPathFigure(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.CloseFigure"]/*' />
        /// <devdoc>
        ///    Closes the current figure and starts a new
        ///    figure. If the current figure contains a sequence of connected lines and curves,
        ///    it closes the loop by connecting a line from the ending point to the starting
        ///    point.
        /// </devdoc>
        public void CloseFigure() {
            int status = SafeNativeMethods.GdipClosePathFigure(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.CloseAllFigures"]/*' />
        /// <devdoc>
        ///    Closes all open figures in a path and
        ///    starts a new figure. It closes each open figure by connecting a line from it's
        ///    ending point to it's starting point.
        /// </devdoc>
        public void CloseAllFigures() {
            int status = SafeNativeMethods.GdipClosePathFigures(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.SetMarkers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets a marker on this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> .
        ///    </para>
        /// </devdoc>
        public void SetMarkers() {
            int status = SafeNativeMethods.GdipSetPathMarker(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.ClearMarkers"]/*' />
        /// <devdoc>
        ///    Clears all markers from this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void ClearMarkers() {
            int status = SafeNativeMethods.GdipClearPathMarkers(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Reverse"]/*' />
        /// <devdoc>
        ///    Reverses the order of points in the <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> array of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Reverse() {
            int status = SafeNativeMethods.GdipReversePath(new HandleRef(this, nativePath));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GetLastPoint"]/*' />
        /// <devdoc>
        ///    Gets the last point in the <see cref='System.Drawing.Drawing2D.GraphicsPath.PathPoints'/> array of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public PointF GetLastPoint() {
            GPPOINTF gppt = new GPPOINTF();
            
            int status = SafeNativeMethods.GdipGetPathLastPoint(new HandleRef(this, nativePath), gppt);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return gppt.ToPoint();
        }
        
        /*
         * Hit testing
         */
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained
        ///       within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y) {
            return IsVisible(new PointF(x,y), (Graphics)null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained
        ///       within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(PointF point) {
            return IsVisible(point, (Graphics)null);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> in the visible clip region of the
        ///       specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(float x, float y, Graphics graphics) {
            return IsVisible(new PointF(x,y), graphics);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(PointF pt, Graphics graphics) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisiblePathPoint(new HandleRef(this, nativePath),
                                                        pt.X,
                                                        pt.Y,
                                                        new HandleRef(graphics, (graphics != null) ? 
                                                            graphics.nativeGraphics : IntPtr.Zero),
                                                        out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        } 
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> .
        ///    </para>
        /// </devdoc>
        public bool IsVisible(int x, int y) {
            return IsVisible(new Point(x,y), (Graphics)null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(Point point) {
            return IsVisible(point, (Graphics)null);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> in the visible clip region of the
        ///       specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(int x, int y, Graphics graphics) {
            return IsVisible(new Point(x,y), graphics);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsVisible7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the specified point is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsVisible(Point pt, Graphics graphics) {
            int isVisible;

            int status = SafeNativeMethods.GdipIsVisiblePathPointI(new HandleRef(this, nativePath),
                                                         pt.X,
                                                         pt.Y,
                                                         new HandleRef(graphics, (graphics != null) ? 
                                                             graphics.nativeGraphics : IntPtr.Zero),
                                                         out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible"]/*' />
        /// <devdoc>
        ///    Indicates whether an outline drawn by the
        ///    specified <see cref='System.Drawing.Pen'/> at the specified location is contained
        ///    within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public bool IsOutlineVisible(float x, float y, Pen pen) {
            return IsOutlineVisible(new PointF(x,y), pen, (Graphics)null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified <see cref='System.Drawing.Pen'/> at the
        ///       specified location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(PointF point, Pen pen) {
            return IsOutlineVisible(point, pen, (Graphics)null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified <see cref='System.Drawing.Pen'/> at the
        ///       specified location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> and within the visible clip region of
        ///       the specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics) {
            return IsOutlineVisible(new PointF(x,y), pen, graphics);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified
        ///    <see cref='System.Drawing.Pen'/> at the specified 
        ///       location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> and within the visible clip region of
        ///       the specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics) {
            int isVisible;

            if (pen == null)
                throw new ArgumentNullException("pen");
                                                                                       
            int status = SafeNativeMethods.GdipIsOutlineVisiblePathPoint(new HandleRef(this, nativePath),
                                                               pt.X,
                                                               pt.Y,
                                                               new HandleRef(pen, pen.nativePen),
                                                               new HandleRef(graphics, (graphics != null) ? 
                                                                   graphics.nativeGraphics : IntPtr.Zero),
                                                               out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified <see cref='System.Drawing.Pen'/> at the
        ///       specified location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(int x, int y, Pen pen) {
            return IsOutlineVisible(new Point(x,y), pen, (Graphics)null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified <see cref='System.Drawing.Pen'/> at the
        ///       specified location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(Point point, Pen pen) {
            return IsOutlineVisible(point, pen, (Graphics)null);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified <see cref='System.Drawing.Pen'/> at the
        ///       specified location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> and within the visible clip region of
        ///       the specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics) {
            return IsOutlineVisible(new Point(x,y), pen, graphics);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.IsOutlineVisible7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether an outline drawn by the specified
        ///    <see cref='System.Drawing.Pen'/> at the specified 
        ///       location is contained within this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> and within the visible clip region of
        ///       the specified <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics) {
            int isVisible;
            
            if (pen == null)
                throw new ArgumentNullException("pen");
                                                                                      
            int status = SafeNativeMethods.GdipIsOutlineVisiblePathPointI(new HandleRef(this, nativePath),
                                                                pt.X,
                                                                pt.Y,
                                                                new HandleRef(pen, pen.nativePen),
                                                                new HandleRef(graphics, (graphics != null) ?
                                                                    graphics.nativeGraphics : IntPtr.Zero),
                                                                out isVisible);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isVisible != 0;
        }

        /*
         * Add lines to the path object
         */
        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLine"]/*' />
        /// <devdoc>
        ///    Appends a line segment to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void AddLine(PointF pt1, PointF pt2) {
            AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLine1"]/*' />
        /// <devdoc>
        ///    Appends a line segment to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void AddLine(float x1, float y1, float x2, float y2) {
            int status = SafeNativeMethods.GdipAddPathLine(new HandleRef(this, nativePath), x1, y1, x2, y2);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLines"]/*' />
        /// <devdoc>
        ///    Appends a series of connected line
        ///    segments to the end of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void AddLines(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathLine2(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLine2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends a line segment to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public void AddLine(Point pt1, Point pt2) {
            AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLine3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends a line segment to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public void AddLine(int x1, int y1, int x2, int y2) {
            int status = SafeNativeMethods.GdipAddPathLineI(new HandleRef(this, nativePath), x1, y1, x2, y2);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddLines1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends a series of connected line segments to the end of this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public void AddLines(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathLine2I(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Add an arc to the path object
         */
        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddArc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends an elliptical arc to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddArc(RectangleF rect, float startAngle, float sweepAngle) {
            AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddArc1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends an elliptical arc to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddArc(float x, float y, float width, float height,
                           float startAngle, float sweepAngle) {
            int status = SafeNativeMethods.GdipAddPathArc(new HandleRef(this, nativePath), x, y, width, height,
                                                startAngle, sweepAngle);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddArc2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends an elliptical arc to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddArc(Rectangle rect, float startAngle, float sweepAngle) {
            AddArc(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddArc3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Appends an elliptical arc to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddArc(int x, int y, int width, int height,
                           float startAngle, float sweepAngle) {
            int status = SafeNativeMethods.GdipAddPathArcI(new HandleRef(this, nativePath), x, y, width, height,
                                                 startAngle, sweepAngle);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
        * Add Bezier curves to the path object
        */
        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBezier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a cubic Bzier curve to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4) {
            AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBezier1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a cubic Bzier curve to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddBezier(float x1, float y1, float x2, float y2,
                              float x3, float y3, float x4, float y4) {
            int status = SafeNativeMethods.GdipAddPathBezier(new HandleRef(this, nativePath), x1, y1, x2, y2,
                                                   x3, y3, x4, y4);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBeziers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a sequence of connected cubic Bzier
        ///       curves to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddBeziers(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathBeziers(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBezier2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a cubic Bzier curve to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4) {
            AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBezier3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a cubic Bzier curve to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddBezier(int x1, int y1, int x2, int y2,
                              int x3, int y3, int x4, int y4) {
            int status = SafeNativeMethods.GdipAddPathBezierI(new HandleRef(this, nativePath), x1, y1, x2, y2,
                                                    x3, y3, x4, y4);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddBeziers1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a sequence of connected cubic Bzier curves to the
        ///       current figure.
        ///    </para>
        /// </devdoc>
        public void AddBeziers(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathBeziersI(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Add cardinal splines to the path object
         */
        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a spline curve to the current figure.
        ///       A Cardinal spline curve is used because the curve travels through each of the
        ///       points in the array.
        ///    </para>
        /// </devdoc>
        public void AddCurve(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurve(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve1"]/*' />
        /// <devdoc>
        ///    Adds a spline curve to the current figure.
        /// </devdoc>
        public void AddCurve(PointF[] points, float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurve2(new HandleRef(this, nativePath), new HandleRef(null, buf),
                                                   points.Length, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a spline curve to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddCurve(PointF[] points, int offset, int numberOfSegments,
                             float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurve3(new HandleRef(this, nativePath), new HandleRef(null, buf),
                                                   points.Length, offset,
                                                   numberOfSegments, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a spline curve to the current figure. A Cardinal spline curve is used
        ///       because the curve travels through each of the points in the array.
        ///    </para>
        /// </devdoc>
        public void AddCurve(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurveI(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a spline curve to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddCurve(Point[] points, float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurve2I(new HandleRef(this, nativePath), new HandleRef(null, buf),
                                                    points.Length, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddCurve5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a spline curve to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddCurve(Point[] points, int offset, int numberOfSegments,
                             float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathCurve3I(new HandleRef(this, nativePath), new HandleRef(null, buf),
                                                    points.Length, offset,
                                                    numberOfSegments, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddClosedCurve"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a closed curve to the current figure. A Cardinal spline curve is
        ///       used because the curve travels through each of the points in the array.
        ///    </para>
        /// </devdoc>
        public void AddClosedCurve(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathClosedCurve(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddClosedCurve1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a closed curve to the current figure. A Cardinal spline curve is
        ///       used because the curve travels through each of the points in the array.
        ///    </para>
        /// </devdoc>
        public void AddClosedCurve(PointF[] points, float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathClosedCurve2(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddClosedCurve2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a closed curve to the current figure. A Cardinal spline curve is used
        ///       because the curve travels through each of the points in the array.
        ///    </para>
        /// </devdoc>
        public void AddClosedCurve(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathClosedCurveI(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddClosedCurve3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a closed curve to the current figure. A Cardinal spline curve is used
        ///       because the curve travels through each of the points in the array.
        ///    </para>
        /// </devdoc>
        public void AddClosedCurve(Point[] points, float tension) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathClosedCurve2I(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length, tension);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddRectangle"]/*' />
        /// <devdoc>
        ///    Adds a rectangle to the current figure.
        /// </devdoc>
        public void AddRectangle(RectangleF rect) {
            int status = SafeNativeMethods.GdipAddPathRectangle(new HandleRef(this, nativePath), rect.X, rect.Y,
                                                      rect.Width, rect.Height);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddRectangles"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a series of rectangles to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddRectangles(RectangleF[] rects) {
            if (rects == null)
                throw new ArgumentNullException("rectangles");
            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipAddPathRectangles(new HandleRef(this, nativePath), new HandleRef(null, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddRectangle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a rectangle to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddRectangle(Rectangle rect) {
            int status = SafeNativeMethods.GdipAddPathRectangleI(new HandleRef(this, nativePath), rect.X, rect.Y,
                                                       rect.Width, rect.Height);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddRectangles1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a series of rectangles to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddRectangles(Rectangle[] rects) {
            if (rects == null)
                throw new ArgumentNullException("rectangles");
            IntPtr buf = SafeNativeMethods.ConvertRectangleToMemory(rects);
            int status = SafeNativeMethods.GdipAddPathRectanglesI(new HandleRef(this, nativePath), new HandleRef(null, buf), rects.Length);

            Marshal.FreeHGlobal(buf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddEllipse"]/*' />
        /// <devdoc>
        ///    Adds an ellipse to the current figure.
        /// </devdoc>
        public void AddEllipse(RectangleF rect) {
            AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
        }

        /**
         * Add an ellipse to the current path
         *
         * !!! Need to handle the status code returned
         *  by the native GDI+ APIs.
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddEllipse1"]/*' />
        /// <devdoc>
        ///    Adds an ellipse to the current figure.
        /// </devdoc>
        public void AddEllipse(float x, float y, float width, float height) {
            int status = SafeNativeMethods.GdipAddPathEllipse(new HandleRef(this, nativePath), x, y, width, height);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddEllipse2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an ellipse to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddEllipse(Rectangle rect) {
            AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
        }

        /**
         * Add an ellipse to the current path
         *
         * !!! Need to handle the status code returned
         *  by the native GDI+ APIs.
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddEllipse3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an ellipse to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddEllipse(int x, int y, int width, int height) {
            int status = SafeNativeMethods.GdipAddPathEllipseI(new HandleRef(this, nativePath), x, y, width, height);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPie"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the outline of a pie shape to the
        ///       current figure.
        ///    </para>
        /// </devdoc>
        public void AddPie(Rectangle rect, float startAngle, float sweepAngle) {
            AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle, sweepAngle);
        }

        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPie1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the outline of a pie shape to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddPie(float x, float y, float width, float height,
                           float startAngle, float sweepAngle) {
            int status = SafeNativeMethods.GdipAddPathPie(new HandleRef(this, nativePath), x, y, width, height,
                                                startAngle, sweepAngle);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPie2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the outline of a pie shape to the current
        ///       figure.
        ///    </para>
        /// </devdoc>
        public void AddPie(int x, int y, int width, int height,
                           float startAngle, float sweepAngle) {
            int status = SafeNativeMethods.GdipAddPathPieI(new HandleRef(this, nativePath), x, y, width, height,
                                                 startAngle, sweepAngle);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPolygon"]/*' />
        /// <devdoc>
        ///    Adds a polygon to the current figure.
        /// </devdoc>
        public void AddPolygon(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathPolygon(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length); 
            Marshal.FreeHGlobal(buf);
                                       
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // int version
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPolygon1"]/*' />
        /// <devdoc>
        ///    Adds a polygon to the current figure.
        /// </devdoc>
        public void AddPolygon(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(points);

            int status = SafeNativeMethods.GdipAddPathPolygonI(new HandleRef(this, nativePath), new HandleRef(null, buf), points.Length); 

            Marshal.FreeHGlobal(buf);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddPath"]/*' />
        /// <devdoc>
        ///    Appends the specified <see cref='System.Drawing.Drawing2D.GraphicsPath'/> to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void AddPath(GraphicsPath addingPath,
                            bool connect) 
        {
            if (addingPath == null)
                throw new ArgumentNullException("adding path");
                            
            int status = SafeNativeMethods.GdipAddPathPath(new HandleRef(this, nativePath), new HandleRef(addingPath, addingPath.nativePath), connect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Add text string to the path object
         *
         * @notes The final form of this API is yet to be defined.
         * @notes What are the choices for the format parameter?
         */

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a text string to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddString(String s, FontFamily family, int style, float emSize,
                              PointF origin, StringFormat format) {
            GPRECTF rectf = new GPRECTF(origin.X, origin.Y, 0, 0);

            int status = SafeNativeMethods.GdipAddPathString(new HandleRef(this, nativePath),
                                                   s,
                                                   s.Length,
                                                   new HandleRef(family, (family != null) ? family.nativeFamily : IntPtr.Zero),
                                                   style,
                                                   emSize,
                                                   ref rectf,
                                                   new HandleRef(format, (format != null) ? format.nativeFormat : IntPtr.Zero));
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddString1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a text string to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddString(String s, FontFamily family, int style, float emSize,
                              Point origin, StringFormat format) {
            GPRECT rect = new GPRECT(origin.X, origin.Y, 0, 0);

            int status = SafeNativeMethods.GdipAddPathStringI(new HandleRef(this, nativePath),
                                                    s,
                                                    s.Length,
                                                    new HandleRef(family, (family != null) ? family.nativeFamily : IntPtr.Zero),
                                                    style,
                                                    emSize,
                                                    ref rect,
                                                    new HandleRef(format, (format != null) ? format.nativeFormat : IntPtr.Zero));
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddString2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a text string to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddString(String s, FontFamily family, int style, float emSize,
                              RectangleF layoutRect, StringFormat format) {
            GPRECTF rectf = new GPRECTF(layoutRect);
            int status = SafeNativeMethods.GdipAddPathString(new HandleRef(this, nativePath),
                                                   s,
                                                   s.Length,
                                                   new HandleRef(family, (family != null) ? family.nativeFamily : IntPtr.Zero),
                                                   style,
                                                   emSize,
                                                   ref rectf,
                                                   new HandleRef(format, (format != null) ? format.nativeFormat : IntPtr.Zero));
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.AddString3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a text string to the current figure.
        ///    </para>
        /// </devdoc>
        public void AddString(String s, FontFamily family, int style, float emSize,
                              Rectangle layoutRect, StringFormat format) {
            GPRECT rect = new GPRECT(layoutRect);
            int status = SafeNativeMethods.GdipAddPathStringI(new HandleRef(this, nativePath),
                                                   s,
                                                   s.Length,
                                                   new HandleRef(family, (family != null) ? family.nativeFamily : IntPtr.Zero),
                                                   style,
                                                   emSize,
                                                   ref rect,
                                                   new HandleRef(format, (format != null) ? format.nativeFormat : IntPtr.Zero));
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Transform"]/*' />
        /// <devdoc>
        ///    Applies a transform matrix to this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        public void Transform(Matrix matrix) {
            if (matrix == null)
                throw new ArgumentNullException("matrix");

            // !! NKramer: Is this an optimization?  We should catch this in GdipTransformPath                                                                                       
            if (matrix.nativeMatrix == IntPtr.Zero)
                return;
                 
            int status = SafeNativeMethods.GdipTransformPath(new HandleRef(this, nativePath),
                                                   new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GetBounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a rectangle that bounds this <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        ///    </para>
        /// </devdoc>
        public RectangleF GetBounds() {
            return GetBounds(null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GetBounds1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a rectangle that bounds this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> when it
        ///       is transformed by the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public RectangleF GetBounds(Matrix matrix) {
            return GetBounds(matrix, null);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.GetBounds2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a rectangle that bounds this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> when it is
        ///       transformed by the specified <see cref='System.Drawing.Drawing2D.Matrix'/>. and drawn with the specified <see cref='System.Drawing.Pen'/>.
        ///    </para>
        /// </devdoc>
        public RectangleF GetBounds(Matrix matrix, Pen pen) {
            GPRECTF gprectf = new GPRECTF();

            IntPtr nativeMatrix = IntPtr.Zero, nativePen = IntPtr.Zero;

            if (matrix != null)
                nativeMatrix = matrix.nativeMatrix;

            if (pen != null)
                nativePen = pen.nativePen;
            
            int status = SafeNativeMethods.GdipGetPathWorldBounds(new HandleRef(this, nativePath), 
                                                        ref gprectf, 
                                                        new HandleRef(matrix, nativeMatrix),
                                                        new HandleRef(pen, nativePen));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return gprectf.ToRectangleF();
        }

        /*
         * Flatten the path object
         */

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Flatten"]/*' />
        /// <devdoc>
        ///    Converts each curve in this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> into a sequence of connected line
        ///    segments.
        /// </devdoc>
        public void Flatten() {
            Flatten(null);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Flatten1"]/*' />
        /// <devdoc>
        ///    Converts each curve in this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> into a sequence of connected line
        ///    segments.
        /// </devdoc>
        public void Flatten(Matrix matrix) {
            Flatten(matrix, 0.25f);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Flatten2"]/*' />
        /// <devdoc>
        ///    Converts each curve in this <see cref='System.Drawing.Drawing2D.GraphicsPath'/> into a sequence of connected line
        ///    segments.
        /// </devdoc>
        public void Flatten(Matrix matrix, float flatness) {
            
            int status = SafeNativeMethods.GdipFlattenPath(new HandleRef(this, nativePath),
                                                           new HandleRef(matrix, (matrix == null) ? IntPtr.Zero : matrix.nativeMatrix),
                                                           flatness);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }


        /**
         * Widen the path object
         *
         * @notes We don't have an API yet.
         *  Should we just take in a GeometricPen as parameter?
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Widen"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Widen(Pen pen) {
            float flatness = (float) 2.0 / (float) 3.0;
            Widen(pen, (Matrix)null, flatness);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Widen1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Widen(Pen pen, Matrix matrix) {
            float flatness = (float) 2.0 / (float) 3.0;
            Widen(pen, matrix, flatness);
        }

        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Widen2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Widen(Pen pen, 
                          Matrix matrix, 
                          float flatness) 
        {
            IntPtr nativeMatrix;

            if (matrix == null)
                nativeMatrix = IntPtr.Zero;
            else
                nativeMatrix = matrix.nativeMatrix;

            if (pen == null)
                throw new ArgumentNullException("pen");
                                                                                       
            int status = SafeNativeMethods.GdipWidenPath(new HandleRef(this, nativePath), 
                                new HandleRef(pen, pen.nativePen), 
                                new HandleRef(matrix, nativeMatrix), 
                                flatness);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Warp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Warp(PointF[] destPoints, RectangleF srcRect)
        { Warp(destPoints, srcRect, null); }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Warp1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix)
        { Warp(destPoints, srcRect, matrix, WarpMode.Perspective); }
        
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Warp2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix,
                         WarpMode warpMode)
        { Warp(destPoints, srcRect, matrix, warpMode, 0.25f); }
         
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.Warp3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix,
                         WarpMode warpMode, float flatness)
        {
            if (destPoints == null)
                throw new ArgumentNullException("destPoints");
            
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(destPoints);
            
            int status = SafeNativeMethods.GdipWarpPath(new HandleRef(this, nativePath),
                                              new HandleRef(matrix, (matrix == null) ? IntPtr.Zero : matrix.nativeMatrix),
                                              new HandleRef(null, buf),
                                              destPoints.Length,
                                              srcRect.X,
                                              srcRect.Y,
                                              srcRect.Width,
                                              srcRect.Height,
                                              warpMode,
                                              flatness);

            Marshal.FreeHGlobal(buf);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
                
        /**
         * Return the number of points in the current path
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.PointCount"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int PointCount {
            get {
                int count = 0;

                int status = SafeNativeMethods.GdipGetPointCount(new HandleRef(this, nativePath), out count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return count;
            }
        }

        /**
         * Return the path point type information
         */
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.PathTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public byte[] PathTypes {
            get {
                int count = PointCount;

                byte[] types = new byte[count];

                int status = SafeNativeMethods.GdipGetPathTypes(new HandleRef(this, nativePath), types, count);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return types;
            }
        }

        /*
         * Return the path point coordinate information
         * @notes Should there be PathData that contains types[] and points[]
         *        for get & set purposes.
         */
        // float points
        /// <include file='doc\GraphicsPath.uex' path='docs/doc[@for="GraphicsPath.PathPoints"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PointF[] PathPoints {
            get {
                int count = PointCount;
                int size = (int) Marshal.SizeOf(typeof(GPPOINTF));
                IntPtr buf = Marshal.AllocHGlobal(count * size);
                int status = SafeNativeMethods.GdipGetPathPoints(new HandleRef(this, nativePath), new HandleRef(null, buf), count);

                if (status != SafeNativeMethods.Ok) {
                    Marshal.FreeHGlobal(buf);
                    throw SafeNativeMethods.StatusException(status);
                }

                PointF[] points = SafeNativeMethods.ConvertGPPOINTFArrayF(buf, count);

                Marshal.FreeHGlobal(buf);

                return points;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\graphicscontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="GraphicsContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GraphicsContainer.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ GraphicsContainer objects
*
* Revision History:
*
*   12/18/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Represent the internal data of a Graphics Container object
     */
    /// <include file='doc\GraphicsContainer.uex' path='docs/doc[@for="GraphicsContainer"]/*' />
    /// <devdoc>
    ///    Represents the internal data of a graphics
    ///    container.
    /// </devdoc>
    public sealed class GraphicsContainer : MarshalByRefObject {
        /**
         * @notes How do we want to expose region data?
         *
         * @notes Need serialization methods too.  Needs to be defined.
         */

        internal GraphicsContainer(int graphicsContainer)
        {
             nativeGraphicsContainer = graphicsContainer;
        }

        internal int nativeGraphicsContainer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gprectf.cs ===
//------------------------------------------------------------------------------
// <copyright file="GPRECTF.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GPRECTF.cpp
*
* Abstract:
*
*   Native GDI+ floating-point coordinate rectangle structure.
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Internal {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal struct GPRECTF {
        internal float X;
        internal float Y;
        internal float Width;
        internal float Height;
        
        internal GPRECTF(float x, float y, float width, float height) {
            X = x;
            Y = y;
            Width = width;
            Height = height;
        }

        internal GPRECTF(RectangleF rect) {
            X = rect.X;
            Y = rect.Y;
            Width = rect.Width;
            Height = rect.Height;
        }

        internal SizeF SizeF {
            get {
                return new SizeF(Width, Height);
            }
        }

        internal RectangleF ToRectangleF() {
            return new RectangleF(X, Y, Width, Height);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\hatchbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="HatchBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   HatchBrush.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ HatchBrush objects
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;    
    using System.Drawing.Internal;

    /**
     * Represent a HatchBrush brush object
     */
    /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush"]/*' />
    /// <devdoc>
    ///    Defines a rectangular brush with a hatch
    ///    style, a foreground color, and a background color.
    /// </devdoc>
    public sealed class HatchBrush : Brush {
        
        internal HatchBrush() { nativeBrush = IntPtr.Zero; }

        /**
         * Create a new hatch brush object
         */
        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.HatchBrush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.HatchBrush'/> class with the specified <see cref='System.Drawing.Drawing2D.HatchStyle'/> and foreground color.
        ///    </para>
        /// </devdoc>
        public HatchBrush(HatchStyle hatchstyle, Color foreColor) {
            IntPtr nativeBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateHatchBrush((int) hatchstyle, 
                                                      foreColor.ToArgb(),
                                                      (int)unchecked((int)0xff000000), 
                                                      out nativeBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(nativeBrush);
        }

        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.HatchBrush1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.HatchBrush'/> class with the specified <see cref='System.Drawing.Drawing2D.HatchStyle'/>,
        ///       foreground color, and background color.
        ///    </para>
        /// </devdoc>
        public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor) {
            IntPtr nativeBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateHatchBrush((int) hatchstyle, 
                                                      foreColor.ToArgb(),
                                                      backColor.ToArgb(), 
                                                      out nativeBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(nativeBrush);
        }

        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.HatchBrush'/>.
        /// </devdoc>
        public override object Clone() {
            IntPtr cloneBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBrush(new HandleRef(this, nativeBrush), out cloneBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new HatchBrush(cloneBrush);
        }

        private HatchBrush(IntPtr nativeBrush) {
            SetNativeBrush(nativeBrush);
        }

        /**
         * Get hatch brush object attributes
         */
        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.HatchStyle"]/*' />
        /// <devdoc>
        ///    Gets the hatch style of this <see cref='System.Drawing.Drawing2D.HatchBrush'/>.
        /// </devdoc>
        public HatchStyle HatchStyle
        {
            get {
                int hatchStyle = 0;

                int status = SafeNativeMethods.GdipGetHatchStyle(new HandleRef(this, nativeBrush), out hatchStyle);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return (HatchStyle) hatchStyle;
            }
        }

        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.ForegroundColor"]/*' />
        /// <devdoc>
        ///    Gets the color of hatch lines drawn by this
        /// <see cref='System.Drawing.Drawing2D.HatchBrush'/>.
        /// </devdoc>
        public Color ForegroundColor
        {
            get {
                int forecol;

                int status = SafeNativeMethods.GdipGetHatchForegroundColor(new HandleRef(this, nativeBrush), out forecol);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return Color.FromArgb(forecol);
            }
        }

        /// <include file='doc\HatchBrush.uex' path='docs/doc[@for="HatchBrush.BackgroundColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the color of spaces between the hatch
        ///       lines drawn by this <see cref='System.Drawing.Drawing2D.HatchBrush'/>.
        ///    </para>
        /// </devdoc>
        public Color BackgroundColor
        {
            get {
                int backcol;

                int status = SafeNativeMethods.GdipGetHatchBackgroundColor(new HandleRef(this, nativeBrush), out backcol);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return Color.FromArgb(backcol);
            }           
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imageattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageAttributes.cs
*
* Abstract:
*
*   Native GDI+ ImageAttributes structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;    
    using System.Drawing.Drawing2D;
    using System.Drawing.Internal;

    // sdkinc\GDIplusImageAttributes.h

    // There are 5 possible sets of color adjustments:
    //          ColorAdjustDefault,
    //          ColorAdjustBitmap,
    //          ColorAdjustBrush,
    //          ColorAdjustPen,
    //          ColorAdjustText,

    // Bitmaps, Brushes, Pens, and Text will all use any color adjustments
    // that have been set into the default ImageAttributes until their own
    // color adjustments have been set.  So as soon as any "Set" method is
    // called for Bitmaps, Brushes, Pens, or Text, then they start from
    // scratch with only the color adjustments that have been set for them.
    // Calling Reset removes any individual color adjustments for a type
    // and makes it revert back to using all the default color adjustments
    // (if any).  The SetToIdentity method is a way to force a type to
    // have no color adjustments at all, regardless of what previous adjustments
    // have been set for the defaults or for that type.

    /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes"]/*' />
    /// <devdoc>
    ///    Contains information about how image colors
    ///    are manipulated during rendering.
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class ImageAttributes : ICloneable, IDisposable {
#if FINALIZATION_WATCH
        private string allocationSite = Graphics.GetAllocationStack();
#endif                                                         


        /*
         * Handle to native image attributes object
         */

        internal IntPtr nativeImageAttributes;

        internal void SetNativeImageAttributes(IntPtr handle) {
            if (handle == IntPtr.Zero)
                    throw new ArgumentNullException("handle");
    
            nativeImageAttributes = handle;
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ImageAttributes"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.ImageAttributes'/> class.
        /// </devdoc>
        public ImageAttributes()
            {
                IntPtr newImageAttributes = IntPtr.Zero;

                int status = SafeNativeMethods.GdipCreateImageAttributes(out newImageAttributes);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);

                SetNativeImageAttributes(newImageAttributes);
            }

        internal ImageAttributes(IntPtr newNativeImageAttributes)
            {
                SetNativeImageAttributes(newNativeImageAttributes);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Imaging.ImageAttributes'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
#if FINALIZATION_WATCH
            if (!disposing && nativeImageAttributes != IntPtr.Zero)
                Debug.WriteLine("**********************\nDisposed through finalization:\n" + allocationSite);
#endif
            if (nativeImageAttributes != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDisposeImageAttributes(new HandleRef(this, nativeImageAttributes));
                nativeImageAttributes = IntPtr.Zero;
                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
       }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.Imaging.ImageAttributes'/>.
        /// </devdoc>
        ~ImageAttributes() {
            Dispose(false);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.Clone"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an exact copy of this <see cref='System.Drawing.Imaging.ImageAttributes'/>.
        ///    </para>
        /// </devdoc>
        public object Clone() {
            IntPtr clone = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneImageAttributes(
                                    new HandleRef(this, nativeImageAttributes),
                                    out clone);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

            return new ImageAttributes(clone);
        }

        void SetToIdentity()
        {
            SetToIdentity(ColorAdjustType.Default);
        }

        void SetToIdentity(ColorAdjustType type) 
        {
            int status = SafeNativeMethods.GdipSetImageAttributesToIdentity(new HandleRef(this, nativeImageAttributes), type);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
        }

        void Reset()
        {
            Reset(ColorAdjustType.Default);
        }

        void Reset(ColorAdjustType type)
        {
            int status = SafeNativeMethods.GdipResetImageAttributes(new HandleRef(this, nativeImageAttributes), type);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the 5 X 5 color adjust matrix to the
        ///       specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void SetColorMatrix(ColorMatrix newColorMatrix)
        {
            SetColorMatrix(newColorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrix1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the 5 X 5 color adjust matrix to the specified 'Matrix' with the specified 'ColorMatrixFlags'.
        ///    </para>
        /// </devdoc>
        public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags)
        {
            SetColorMatrix(newColorMatrix, flags, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrix2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the 5 X 5 color adjust matrix to the specified 'Matrix' with the 
        ///       specified 'ColorMatrixFlags'.
        ///    </para>
        /// </devdoc>
        public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type)
        {
            int status = SafeNativeMethods.GdipSetImageAttributesColorMatrix(
                        new HandleRef(this, nativeImageAttributes),
                        type,
                        true,
                        newColorMatrix,
                        null,
                        mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }   

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearColorMatrix"]/*' />
        /// <devdoc>
        ///    Clears the color adjust matrix to all
        ///    zeroes.
        /// </devdoc>
        public void ClearColorMatrix()
        {
            ClearColorMatrix(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearColorMatrix1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears the color adjust matrix.
        ///    </para>
        /// </devdoc>
        public void ClearColorMatrix(ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesColorMatrix(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false,
                    null,
                    null,
                    ColorMatrixFlag.Default);
        
                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrices"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets a color adjust matrix for image colors
        ///       and a separate gray scale adjust matrix for gray scale values.
        ///    </para>
        /// </devdoc>
        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix)
        {
            SetColorMatrices(newColorMatrix, grayMatrix, ColorMatrixFlag.Default, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrices1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags)
        {
            SetColorMatrices(newColorMatrix, grayMatrix, flags, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorMatrices2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, 
                                     ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesColorMatrix(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    true,
                    newColorMatrix,
                    grayMatrix,
                    mode);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }   

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetThreshold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetThreshold(float threshold)
            {
            SetThreshold(threshold, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetThreshold1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetThreshold(float threshold, ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesThreshold(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    true,
                    threshold);
        
                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearThreshold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearThreshold()
            {
            ClearThreshold(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearThreshold1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearThreshold(ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesThreshold(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false,
                    0.0f);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetGamma"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetGamma(float gamma)
            {
            SetGamma(gamma, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetGamma1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetGamma(float gamma, ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesGamma(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    true,
                    gamma);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearGamma"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearGamma()
            {
            ClearGamma(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearGamma1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearGamma(ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesGamma(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false,
                    0.0f);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetNoOp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetNoOp()
        {
            SetNoOp(ColorAdjustType.Default);   
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetNoOp1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetNoOp(ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesNoOp(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    true);

                if (status != SafeNativeMethods.Ok)
                        throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearNoOp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearNoOp()
            {
            ClearNoOp(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearNoOp1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearNoOp(ColorAdjustType type)
            {
                int status = SafeNativeMethods.GdipSetImageAttributesNoOp(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetColorKey(Color colorLow, Color colorHigh)
        {
            SetColorKey(colorLow, colorHigh, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetColorKey1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type)
        {
            int lowInt = colorLow.ToArgb();
            int highInt = colorHigh.ToArgb();

            int status = SafeNativeMethods.GdipSetImageAttributesColorKeys(
                                        new HandleRef(this, nativeImageAttributes),
                                        type,
                                        true,
                                        lowInt,
                                        highInt);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearColorKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearColorKey()
            {
            ClearColorKey(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearColorKey1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearColorKey(ColorAdjustType type)
            {
            int zero = 0;
            int status = SafeNativeMethods.GdipSetImageAttributesColorKeys(
                                        new HandleRef(this, nativeImageAttributes),
                                        type,
                                        false,
                                        zero,
                                        zero);

           if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetOutputChannel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetOutputChannel(ColorChannelFlag flags)
        {
            SetOutputChannel(flags, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetOutputChannel1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type)
        {
                int status = SafeNativeMethods.GdipSetImageAttributesOutputChannel(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    true,
                    flags);
                            
            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearOutputChannel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearOutputChannel()
        {
            ClearOutputChannel(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearOutputChannel1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearOutputChannel(ColorAdjustType type)
        {
                int status = SafeNativeMethods.GdipSetImageAttributesOutputChannel(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false,
                    ColorChannelFlag.ColorChannelLast);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetOutputChannelColorProfile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetOutputChannelColorProfile(String colorProfileFilename)
        {
            SetOutputChannelColorProfile(colorProfileFilename, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetOutputChannelColorProfile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetOutputChannelColorProfile(String colorProfileFilename,
                                                 ColorAdjustType type)
        {
            IntSecurity.DemandReadFileIO(colorProfileFilename);

            int status = SafeNativeMethods.GdipSetImageAttributesOutputChannelColorProfile(
                                        new HandleRef(this, nativeImageAttributes),
                                        type,
                                        true,
                                        colorProfileFilename);
                            
            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearOutputChannelColorProfile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearOutputChannelColorProfile()
        {
            ClearOutputChannel(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearOutputChannelColorProfile1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearOutputChannelColorProfile(ColorAdjustType type)
        {
                int status = SafeNativeMethods.GdipSetImageAttributesOutputChannel(
                    new HandleRef(this, nativeImageAttributes),
                    type,
                    false,
                    ColorChannelFlag.ColorChannelLast);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetRemapTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetRemapTable(ColorMap[] map)
        {
            SetRemapTable(map, ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetRemapTable1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetRemapTable(ColorMap[] map, ColorAdjustType type)
        {
            int index = 0;
            int mapSize = map.Length;
            int size = 4; // Marshal.SizeOf(index.GetType());
            IntPtr memory = Marshal.AllocHGlobal(mapSize*size*2);

            for (index=0; index<mapSize; index++) {
                Marshal.StructureToPtr(map[index].OldColor.ToArgb(), (IntPtr)((long)memory+index*size*2), false);
                Marshal.StructureToPtr(map[index].NewColor.ToArgb(), (IntPtr)((long)memory+index*size*2+size), false);
            }

            int status = SafeNativeMethods.GdipSetImageAttributesRemapTable(
                new HandleRef(this, nativeImageAttributes),
                type,
                true,
                mapSize,
                new HandleRef(null, memory));

            Marshal.FreeHGlobal(memory);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearRemapTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearRemapTable()
        {
            ClearRemapTable(ColorAdjustType.Default);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearRemapTable1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearRemapTable(ColorAdjustType type)
        {
                int status = SafeNativeMethods.GdipSetImageAttributesRemapTable(
                                new HandleRef(this, nativeImageAttributes),
                                type,
                                false,
                                0,
                                NativeMethods.NullHandleRef);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetBrushRemapTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetBrushRemapTable(ColorMap[] map)
        {
            SetRemapTable(map, ColorAdjustType.Brush);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.ClearBrushRemapTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ClearBrushRemapTable()
        {
            ClearRemapTable(ColorAdjustType.Brush);
        }

        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetWrapMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetWrapMode(WrapMode mode)
        {
            SetWrapMode(mode, new Color(), false);
        }
        
        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetWrapMode1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetWrapMode(WrapMode mode, Color color)
        {
            SetWrapMode(mode, color, false);
        }
        
        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.SetWrapMode2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetWrapMode(WrapMode mode, Color color, bool clamp)
        {
            int status = SafeNativeMethods.GdipSetImageAttributesWrapMode(
                            new HandleRef(this, nativeImageAttributes),
                            (int)mode,
                            color.ToArgb(),
                            clamp);

            if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\ImageAttributes.uex' path='docs/doc[@for="ImageAttributes.GetAdjustedPalette"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type)
        {
            // does inplace adjustment
            IntPtr memory = palette.ConvertToMemory();
            
            int status = SafeNativeMethods.GdipGetImageAttributesAdjustedPalette(
                                new HandleRef(this, nativeImageAttributes), new HandleRef(null, memory), type);
                                            
            if (status != SafeNativeMethods.Ok)
            {
                Marshal.FreeHGlobal(memory);
                throw SafeNativeMethods.StatusException(status);
            }
            
            palette.ConvertFromMemory(memory);
            Marshal.FreeHGlobal(memory);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\hotkeyprefix.cs ===
//------------------------------------------------------------------------------
// <copyright file="HotkeyPrefix.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   HotkeyPrefix.cs
*
* Abstract:
*
*   text-related constants
*
* Revision History:
*
*   3/13/2000 nkramer
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Drawing;
    using System;

    /// <include file='doc\HotkeyPrefix.uex' path='docs/doc[@for="HotkeyPrefix"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of display for hotkey prefixes for text.
    ///    </para>
    /// </devdoc>
    public enum HotkeyPrefix
    {
        /// <include file='doc\HotkeyPrefix.uex' path='docs/doc[@for="HotkeyPrefix.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No hotkey prefix.
        ///    </para>
        /// </devdoc>
        None        = 0,
        /// <include file='doc\HotkeyPrefix.uex' path='docs/doc[@for="HotkeyPrefix.Show"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Display the hotkey prefix.
        ///    </para>
        /// </devdoc>
        Show        = 1,
        /// <include file='doc\HotkeyPrefix.uex' path='docs/doc[@for="HotkeyPrefix.Hide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Do not display the hotkey prefix.
        ///    </para>
        /// </devdoc>
        Hide        = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imagecodecinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageCodecInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageCodecInfo.cs
*
* Abstract:
*
*   Native GDI+ ImageCodecInfo structure.
*
* Revision History:
*
*   9/22/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.Drawing.Internal;

    // sdkinc\imaging.h
    /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    System.Runtime.InteropServices.ComVisible(false)
    ]
    public sealed class ImageCodecInfo {
         Guid clsid;
         Guid formatID;
         string codecName;
         string dllName;
         string formatDescription;
         string filenameExtension;
         string mimeType;
         ImageCodecFlags flags;
         int version;
         byte[][] signaturePatterns;
         byte[][] signatureMasks;

         internal ImageCodecInfo() {
         }
         
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.Clsid"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public Guid Clsid {
             get { return clsid; }
             set { clsid = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.FormatID"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public Guid FormatID {
             get { return formatID; }
             set { formatID = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.CodecName"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public string CodecName {
             get { return codecName; }
             set { codecName = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.DllName"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public string DllName {
             get { return dllName; }
             set { dllName = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.FormatDescription"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public string FormatDescription {
             get { return formatDescription; }
             set { formatDescription = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.FilenameExtension"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public string FilenameExtension {
             get { return filenameExtension; }
             set { filenameExtension = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.MimeType"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public string MimeType {
             get { return mimeType; }
             set { mimeType = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.Flags"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public ImageCodecFlags Flags {
             get { return flags; }
             set { flags = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.Version"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public int Version {
             get { return version; }
             set { version = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.SignaturePatterns"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         [CLSCompliant(false)]
         public byte[][] SignaturePatterns {
             get { return signaturePatterns; }
             set { signaturePatterns = value; }
         }
         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.SignatureMasks"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         [CLSCompliant(false)]
         public byte[][] SignatureMasks {
             get { return signatureMasks; }
             set { signatureMasks = value; }
         }
         
         // Encoder/Decoder selection APIs

         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.GetImageDecoders"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public static ImageCodecInfo[] GetImageDecoders() {
             int numDecoders;
             int size;

             int status = SafeNativeMethods.GdipGetImageDecodersSize(out numDecoders, out size);

             if (status != SafeNativeMethods.Ok)
                 throw SafeNativeMethods.StatusException(status);

             IntPtr memory = Marshal.AllocHGlobal(size);

             status = SafeNativeMethods.GdipGetImageDecoders(numDecoders, size, memory);

             if (status != SafeNativeMethods.Ok) {
                 Marshal.FreeHGlobal(memory);
                 throw SafeNativeMethods.StatusException(status);
             }

             ImageCodecInfo[] imageCodecs = ImageCodecInfo.ConvertFromMemory(memory, numDecoders);

             Marshal.FreeHGlobal(memory);
                          
             return imageCodecs;
         }

         /// <include file='doc\ImageCodecInfo.uex' path='docs/doc[@for="ImageCodecInfo.GetImageEncoders"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public static ImageCodecInfo[] GetImageEncoders() {
             int numEncoders;
             int size;

             int status = SafeNativeMethods.GdipGetImageEncodersSize(out numEncoders, out size);

             if (status != SafeNativeMethods.Ok)
                 throw SafeNativeMethods.StatusException(status);

             IntPtr memory = Marshal.AllocHGlobal(size);

             status = SafeNativeMethods.GdipGetImageEncoders(numEncoders, size, memory);

             if (status != SafeNativeMethods.Ok) {
                 Marshal.FreeHGlobal(memory);
                 throw SafeNativeMethods.StatusException(status);
             }

             ImageCodecInfo[] imageCodecs = ImageCodecInfo.ConvertFromMemory(memory, numEncoders);

             Marshal.FreeHGlobal(memory);

             return imageCodecs;
         }
         
         internal static ImageCodecInfoPrivate ConvertToMemory(ImageCodecInfo imagecs)
         {
             ImageCodecInfoPrivate imagecsp = new ImageCodecInfoPrivate();
             
             imagecsp.Clsid = imagecs.Clsid;
             imagecsp.FormatID = imagecs.FormatID;
             
             imagecsp.CodecName = Marshal.StringToHGlobalUni(imagecs.CodecName);
             imagecsp.DllName = Marshal.StringToHGlobalUni(imagecs.DllName);
             imagecsp.FormatDescription = Marshal.StringToHGlobalUni(imagecs.FormatDescription);
             imagecsp.FilenameExtension = Marshal.StringToHGlobalUni(imagecs.FilenameExtension);
             imagecsp.MimeType = Marshal.StringToHGlobalUni(imagecs.MimeType);
             
             imagecsp.Flags = (int)imagecs.Flags;
             imagecsp.Version = (int)imagecs.Version;
             imagecsp.SigCount = imagecs.SignaturePatterns.Length;
             imagecsp.SigSize = imagecs.SignaturePatterns[0].Length;
             
             imagecsp.SigPattern = Marshal.AllocHGlobal(imagecsp.SigCount*imagecsp.SigSize);
             imagecsp.SigMask = Marshal.AllocHGlobal(imagecsp.SigCount*imagecsp.SigSize);
             
             for (int i=0; i<imagecsp.SigCount; i++)
             {
                 Marshal.Copy(imagecs.SignaturePatterns[i], 
                              0, 
                              (IntPtr)((long)imagecsp.SigPattern + i*imagecsp.SigSize), 
                              imagecsp.SigSize);
                                  
                 Marshal.Copy(imagecs.SignatureMasks[i], 
                              0, 
                              (IntPtr)((long)imagecsp.SigMask + i*imagecsp.SigSize), 
                              imagecsp.SigSize);
             }
                          
             return imagecsp;
         }

         internal static void FreeMemory(ImageCodecInfoPrivate imagecodecp)
         {
             Marshal.FreeHGlobal(imagecodecp.CodecName);
             Marshal.FreeHGlobal(imagecodecp.FormatDescription);
             Marshal.FreeHGlobal(imagecodecp.FilenameExtension);
             Marshal.FreeHGlobal(imagecodecp.MimeType);
             Marshal.FreeHGlobal(imagecodecp.SigPattern);
             Marshal.FreeHGlobal(imagecodecp.SigMask);
         }
                          
         internal static ImageCodecInfo[] ConvertFromMemory(IntPtr memoryStart, int numCodecs)
         {
             ImageCodecInfo[] codecs = new ImageCodecInfo[numCodecs];

             int index;

             for (index=0; index<numCodecs; index++)
             {
                 IntPtr curcodec = (IntPtr)((long)memoryStart + (int)Marshal.SizeOf(typeof(ImageCodecInfoPrivate))*index);
                 ImageCodecInfoPrivate codecp = new ImageCodecInfoPrivate();
                 UnsafeNativeMethods.PtrToStructure(curcodec, codecp);
                 
                 codecs[index] = new ImageCodecInfo();
                 codecs[index].Clsid = codecp.Clsid;
                 codecs[index].FormatID = codecp.FormatID;
                 codecs[index].CodecName = Marshal.PtrToStringUni(codecp.CodecName);
                 codecs[index].DllName = Marshal.PtrToStringUni(codecp.DllName);
                 codecs[index].FormatDescription = Marshal.PtrToStringUni(codecp.FormatDescription);
                 codecs[index].FilenameExtension = Marshal.PtrToStringUni(codecp.FilenameExtension);
                 codecs[index].MimeType = Marshal.PtrToStringUni(codecp.MimeType);
                 
                 codecs[index].Flags = (ImageCodecFlags)codecp.Flags;
                 codecs[index].Version = (int)codecp.Version;
                                  
                 codecs[index].SignaturePatterns = new byte[codecp.SigCount][];
                 codecs[index].SignatureMasks = new byte[codecp.SigCount][];
                 
                 for (int j=0; j<codecp.SigCount; j++)
                 {
                     codecs[index].SignaturePatterns[j] = new byte[codecp.SigSize];
                     codecs[index].SignatureMasks[j] = new byte[codecp.SigSize];

                     Marshal.Copy((IntPtr)((long)codecp.SigMask + j*codecp.SigSize), codecs[index].SignatureMasks[j], 0, codecp.SigSize);
                     Marshal.Copy((IntPtr)((long)codecp.SigPattern + j*codecp.SigSize), codecs[index].SignaturePatterns[j], 0, codecp.SigSize);
                 }
             }

             return codecs;
         }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\hatchstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="HatchStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   HatchStyle.cs
*
* Abstract:
*
*   Hatch styles for Hatch brushes
*
* Revision History:
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle"]/*' />
    /// <devdoc>
    ///    Specifies the different patterns available
    ///    for <see cref='System.Drawing.Drawing2D.HatchBrush'/> objects.
    /// </devdoc>
    public enum HatchStyle
    {
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pattern of horizontal lines.
        ///    </para>
        /// </devdoc>
        Horizontal = 0,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pattern of vertical lines.
        ///    </para>
        /// </devdoc>
        Vertical = 1,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.ForwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pattern of lines on a diagonal from top-left to bottom-right.
        ///    </para>
        /// </devdoc>
        ForwardDiagonal = 2,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.BackwardDiagonal"]/*' />
        /// <devdoc>
        ///    A pattern of lines on a diagonal from
        ///    top-right to bottom-left.
        /// </devdoc>
        BackwardDiagonal = 3,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Cross"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pattern of criss-cross horizontal and vertical lines.
        ///    </para>
        /// </devdoc>
        Cross = 4,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DiagonalCross"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A pattern of criss-cross diagonal lines.
        ///    </para>
        /// </devdoc>
        DiagonalCross = 5,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent05"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent05 = 6,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent10"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent10 = 7,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent20"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent20 = 8,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent25"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent25 = 9,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent30"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent30 = 10,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent40"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent40 = 11,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent50"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent50 = 12,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent60"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent60 = 13,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent70"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent70 = 14,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent75"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent75 = 15,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent80"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent80 = 16,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Percent90"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Percent90 = 17,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LightDownwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LightDownwardDiagonal = 18,        
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LightUpwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LightUpwardDiagonal = 19,          
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DarkDownwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DarkDownwardDiagonal = 20,         
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DarkUpwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DarkUpwardDiagonal = 21,           
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.WideDownwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        WideDownwardDiagonal = 22,         
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.WideUpwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        WideUpwardDiagonal = 23,           
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LightVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LightVertical = 24,                
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LightHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LightHorizontal =25,              
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.NarrowVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        NarrowVertical = 26,               
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.NarrowHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        NarrowHorizontal = 27,             
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DarkVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DarkVertical = 28,                 
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DarkHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DarkHorizontal = 29,               
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DashedDownwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DashedDownwardDiagonal = 30,       
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DashedUpwardDiagonal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DashedUpwardDiagonal = 31,         
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DashedHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DashedHorizontal = 32,             
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DashedVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DashedVertical = 33,               
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.SmallConfetti"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        SmallConfetti = 34,                
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LargeConfetti"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LargeConfetti = 35,                
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.ZigZag"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        ZigZag = 36,                       
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Wave"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Wave = 37,                         
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DiagonalBrick"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DiagonalBrick = 38,                
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.HorizontalBrick"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        HorizontalBrick = 39,              
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Weave"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Weave = 40,                        
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Plaid"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Plaid = 41,                        
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Divot"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Divot = 42,                        
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DottedGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DottedGrid = 43,                   
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.DottedDiamond"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        DottedDiamond = 44,                
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Shingle"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Shingle = 45,                      
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Trellis"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Trellis = 46,                      
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Sphere"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Sphere = 47,                       
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.SmallGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        SmallGrid = 48,                    
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.SmallCheckerBoard"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        SmallCheckerBoard = 49,            
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LargeCheckerBoard"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LargeCheckerBoard = 50,            
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.OutlinedDiamond"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        OutlinedDiamond = 51,              
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.SolidDiamond"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        SolidDiamond = 52,                 

        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.LargeGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        LargeGrid = Cross,  

        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Min"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Min       = Horizontal,
        /// <include file='doc\HatchStyle.uex' path='docs/doc[@for="HatchStyle.Max"]/*' />
        /// <devdoc>
        ///    <para>
        ///    </para>
        /// </devdoc>
        Max       = LargeGrid

    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imageflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageFlags.cs
*
* Abstract:
*
*   ImageFlags constants
*
* Revision History:
*
*   3/15/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color channel flag constants
     */
    /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags"]/*' />
    /// <devdoc>
    ///    Specifies the attributes of the pixel data
    ///    contained in an <see langword='Image'/> object.
    /// </devdoc>
    [Flags()]
    public enum ImageFlags {
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.None"]/*' />
        /// <devdoc>
        ///    There is no format information.
        /// </devdoc>
        None                = 0,

    // Low-word: shared with SINKFLAG_x

        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.Scalable"]/*' />
        /// <devdoc>
        ///    Pixel data is scalable.
        /// </devdoc>
        Scalable            = 0x0001,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.HasAlpha"]/*' />
        /// <devdoc>
        ///    Pixel data contains alpha information.
        /// </devdoc>
        HasAlpha            = 0x0002,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.HasTranslucent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HasTranslucent      = 0x0004,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.PartiallyScalable"]/*' />
        /// <devdoc>
        ///    Pixel data is partially scalable, but there
        ///    are some limitations.
        /// </devdoc>
        PartiallyScalable   = 0x0008,

    // Low-word: color space definition

        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ColorSpaceRgb"]/*' />
        /// <devdoc>
        ///    Pixel data uses an RGB color space.
        /// </devdoc>
        ColorSpaceRgb       = 0x0010,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ColorSpaceCmyk"]/*' />
        /// <devdoc>
        ///    Pixel data uses a CMYK color space.
        /// </devdoc>
        ColorSpaceCmyk      = 0x0020,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ColorSpaceGray"]/*' />
        /// <devdoc>
        ///    Pixel data is grayscale.
        /// </devdoc>
        ColorSpaceGray      = 0x0040,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ColorSpaceYcbcr"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ColorSpaceYcbcr     = 0x0080,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ColorSpaceYcck"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ColorSpaceYcck      = 0x0100,
 
    // Low-word: image size info

        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.HasRealDpi"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HasRealDpi          = 0x1000,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.HasRealPixelSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        HasRealPixelSize    = 0x2000,

    // High-word

        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.ReadOnly"]/*' />
        /// <devdoc>
        ///    Pixel data is read-only.
        /// </devdoc>
        ReadOnly            = 0x00010000,
        /// <include file='doc\ImageFlags.uex' path='docs/doc[@for="ImageFlags.Caching"]/*' />
        /// <devdoc>
        ///    Pixel data can be cached for faster access.
        /// </devdoc>
        Caching             = 0x00020000
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imagecodecflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageCodecFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageCodecFlags.cs
*
* Abstract:
*
*   ImageCodecInfo flag constants
*
* Revision History:
*
*   1/25/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Text;

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Color channel flag constants
     */
    /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags()]
    public enum ImageCodecFlags {
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.Encoder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Encoder         = 0x00000001,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.Decoder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Decoder         = 0x00000002,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.SupportBitmap"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SupportBitmap   = 0x00000004,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.SupportVector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SupportVector   = 0x00000008,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.SeekableEncode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SeekableEncode  = 0x00000010,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.BlockingDecode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BlockingDecode  = 0x00000020,
        
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.Builtin"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Builtin         = 0x00010000,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.System"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        System          = 0x00020000,
        /// <include file='doc\ImageCodecFlags.uex' path='docs/doc[@for="ImageCodecFlags.User"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        User            = 0x00040000
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imagecodecinfoprivate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageCodecInfoPrivate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageCodecInfo.cs
*
* Abstract:
*
*   Native GDI+ ImageCodecInfo structure.
*
* Revision History:
*
*   1/26/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;

    // sdkinc\imaging.h
    [StructLayout(LayoutKind.Sequential, Pack=8)]
    internal class ImageCodecInfoPrivate {
        [MarshalAs(UnmanagedType.Struct)]
        public Guid Clsid;
        [MarshalAs(UnmanagedType.Struct)]
        public Guid FormatID;

        public IntPtr CodecName;
        public IntPtr DllName;
        public IntPtr FormatDescription;
        public IntPtr FilenameExtension;
        public IntPtr MimeType;

        public int Flags;
        public int Version;
        public int SigCount;
        public int SigSize;

        public IntPtr SigPattern;
        public IntPtr SigMask;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imagelockmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageLockMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    //
    // Access modes used when calling IImage::LockBits
    //
    /// <include file='doc\ImageLockMode.uex' path='docs/doc[@for="ImageLockMode"]/*' />
    /// <devdoc>
    ///    Indicates the access mode for an <see cref='System.Drawing.Image'/>.
    /// </devdoc>
    public enum ImageLockMode {
        /// <include file='doc\ImageLockMode.uex' path='docs/doc[@for="ImageLockMode.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the image is read-only.
        ///    </para>
        /// </devdoc>
        ReadOnly        = 0x0001,
        /// <include file='doc\ImageLockMode.uex' path='docs/doc[@for="ImageLockMode.WriteOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the image is
        ///       write-only.
        ///    </para>
        /// </devdoc>
        WriteOnly       = 0x0002,
        /// <include file='doc\ImageLockMode.uex' path='docs/doc[@for="ImageLockMode.ReadWrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the image is
        ///       read-write.
        ///    </para>
        /// </devdoc>
        ReadWrite = ReadOnly | WriteOnly,
        /// <include file='doc\ImageLockMode.uex' path='docs/doc[@for="ImageLockMode.UserInputBuffer"]/*' />
        /// <devdoc>
        ///    Indicates the image resides in a user input
        ///    buffer, to which the user controls access.
        /// </devdoc>
        UserInputBuffer = 0x0004,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\gdiplus.cs ===
//------------------------------------------------------------------------------
// <copyright file="Gdiplus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   gdiplus.cs
*
* Abstract:
*
*   Wrapper for flat GDI+ APIs exported by gdiplus.dll
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Text;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.IO;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Drawing.Imaging;
    using System.Drawing.Text;
    using System.Drawing.Drawing2D;
    using System.Threading;
    using System.Security.Permissions;
    using System.Security;

    [System.Runtime.InteropServices.ComVisible(false)]
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class SafeNativeMethods {
        private static readonly TraceSwitch GdiPlusInitialization = new TraceSwitch("GdiPlusInitialization", "Tracks GDI+ initialization and teardown");
        private static readonly BooleanSwitch GdiPlusIgnoreAtom = new BooleanSwitch("GdiPlusIgnoreAtom", "Ignores the use of global atoms for startup/shutdown");

        private static bool isShutdown = true; //true if GDI+ isn't initialized or has been shutdown
        private static IntPtr initToken;
        private static IntPtr hookToken;
        private const string ThreadDataSlotName = "system.drawing.threaddata";
        private static string atomName = null;
        private static IntPtr hAtom = IntPtr.Zero;

        static SafeNativeMethods() {
            Initialize();
        }

        /// <devdoc>
        ///      Determines if GDI+ is already initialized, we do this by checking
        ///      a global atom that we create - once per process.
        /// </devdoc>
        static bool AlreadyInitialized {
            get {
                if (atomName == null) {
                    atomName = "GDI+Atom" + GetCurrentProcessId().ToString();
                }
                if (FindAtom(atomName) != IntPtr.Zero) {
                    return true;
                }
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Creating our global atom: " + atomName);
                hAtom = AddAtom(atomName);
                return false;  
            }
        }
        
        /// <devdoc>
        ///      Returns true if we've shutdown GDI+
        /// </devdoc>
        private static bool IsShutdown {
            get {
                return isShutdown;
            }
            set {
                isShutdown = value;
            }
        }

        /// <devdoc>
        ///      This property will give us back a hashtable we can use to store
        ///      all of our static brushes and pens on a per-thread basis.  This way   
        ///      we can avoid 'object in use' crashes when differnt threads are
        ///      referencing the same drawing object.
        /// </devdoc>
        internal static IDictionary ThreadData {
            get {
                LocalDataStoreSlot slot = Thread.GetNamedDataSlot(ThreadDataSlotName);
                IDictionary threadData = (IDictionary)Thread.GetData(slot);
                if (threadData == null) {
                    threadData = new Hashtable();
                    Thread.SetData(slot, threadData);
                }
                return threadData;
            }
        }
        
        /// <devdoc>
        ///      If we've created a valid atom when we started gdi+
        ///      we'll tear it down here.
        /// </devdoc>
        static void DestroyAtom() {
            if (hAtom != IntPtr.Zero) {
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Deleting our global atom");
                DeleteAtom(new HandleRef(null, hAtom));
            }
        }

        /// <devdoc>
        ///      Initializes GDI+
        /// </devdoc>
        static void Initialize() {
            bool isUserInteractive = Environment.UserInteractive;
            bool alreadyInitialized;

            // We only want to initialize GDI+ once per process
            // so we'll bail out if we can find our atom.
            // 
#if DEBUG 
            alreadyInitialized = (!GdiPlusIgnoreAtom.Enabled && AlreadyInitialized);
#else
            alreadyInitialized = AlreadyInitialized;
#endif

            if (!alreadyInitialized) {
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Initialize GDI+ [" + AppDomain.CurrentDomain.FriendlyName + "]");
                Debug.Indent();

                // We'll try to load the gdiplus.dll from the framework's install directory.
                // Since we weak bind - on a down level system (something < WindowsXP) 
                // the dll will get loaded here.  On a WindowsXP OS, this will fail and fusion
                // will load the gdiplus.dll from the System32 directory.
                //
                IntPtr dllModule;
                string version = null;
                int result = LoadLibraryShim("Gdiplus.dll", version, (IntPtr)0, out dllModule);

                StartupInput input = StartupInput.GetDefault();
                StartupOutput output;

                if (isUserInteractive) {
                    input.SuppressBackgroundThread = true;
                    Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Process is user interactive, suppress GDI+ background thread...");
                }

                int status = GdiplusStartup(out initToken, ref input, out output);

                if (status != SafeNativeMethods.Ok) {
                    throw SafeNativeMethods.StatusException(status);
                }

                // NOTE:  The secondary check here is to prevent system events thread from starting up 
                // under asp.net.  If this thread starts up, it kills their performance because
                // there is one of these threads per app-domain.
                if (isUserInteractive &&  Thread.GetDomain().GetData(".appDomain") == null) {
                    Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Process is user interactive, and not running inside ASP.NET...");
                    SystemEvents.InvokeOnEventsThread(new EventHandler(SystemEventThreadCallback));
                }
                
                Debug.Unindent();
            }
            else {
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "GDI+ was already initialized, so we won't attempt to do it again.");
            }

            IsShutdown = false;
            AppDomain.CurrentDomain.ProcessExit += new EventHandler(SafeNativeMethods.OnProcessExit);
            
            // NOTE:  The secondary check here is to prevent system events thread from starting up 
            // under asp.net.  If this thread starts up, it kills their performance because
            // there is one of these threads per app-domain.
            if (isUserInteractive &&  Thread.GetDomain().GetData(".appDomain") == null) {
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Process is user interactive, and not running inside ASP.NET...");
                SystemEvents.EventsThreadShutdown += new EventHandler(OnSystemEventThreadShutdown);
            }
        }

        /// <devdoc>
        ///      Shutsdown GDI+
        /// </devdoc>
        private static void Shutdown() {
            Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Shutdown GDI+ [" + AppDomain.CurrentDomain.FriendlyName + "]");
            Debug.Indent();

#if DEBUG
            if (!GdiPlusIgnoreAtom.Enabled) {
                DestroyAtom();
            }
#else
            DestroyAtom();
#endif
            
            if (!IsShutdown) {
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Not already shutdown");

                // Nuke thread data
                //
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Releasing TLS data");
                LocalDataStoreSlot slot = Thread.GetNamedDataSlot(ThreadDataSlotName);
                Thread.SetData(slot, null);

                // Let any thread data collect and finalize before
                // we tear down GDI+
                //
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Running garbage collector");
                GC.Collect();
                GC.WaitForPendingFinalizers();

                // Shutdown GDI+
                //
                Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Instruct GDI+ to shutdown");

                if (initToken != IntPtr.Zero) {
                    GdiplusShutdown(new HandleRef(null, initToken));
                }

                // Mark the AppDomain as having GDI+ unloaded
                //
                IsShutdown = true;
            }
            Debug.Unindent();
        }

        // Called on the SystemEventThread so that GDI+ will use this
        // thread to listen to system events.
        //
        private static void SystemEventThreadCallback(object sender, EventArgs e) {
            int status = GdiplusNotificationHook(out hookToken);
        }

        // Called on the SystemEventThread so that GDI+ will stop
        // listening to system events on this thread.
        //
        private static void OnSystemEventThreadShutdown(object sender, EventArgs e) {
            if (hookToken != IntPtr.Zero) {
                GdiplusNotificationUnhook(new HandleRef(null, hookToken));
            }
        }

        // When we get notification that the process is terminating, we will
        // try to shutdown GDI+ if we haven't already.
        //
        private static void OnProcessExit(object sender, EventArgs e) {
            Debug.WriteLineIf(GdiPlusInitialization.TraceVerbose, "Process exited");
            Shutdown();
        }


        //-------------------------------------------------------------------------------------------
        // Global atom APIs - used to determine when to startup/shutdown GDI+ on a per-process basis
        //-------------------------------------------------------------------------------------------

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int GetCurrentProcessId();

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr AddAtom(string lpString);

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr DeleteAtom(HandleRef hAtom);

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr FindAtom(string lpString);


        //----------------------------------------------------------------------------------------                                                           
        // LoadLibrary method - used for weak binding to the gdiplus.dll on a down-level system
        //----------------------------------------------------------------------------------------
        
        [DllImport(ExternDll.Mscoree, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int LoadLibraryShim(string dllName, string version, IntPtr reserved, out IntPtr dllModule);


        //----------------------------------------------------------------------------------------                                                           
        // Initialization methods (GdiplusInit.h)
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int GdiplusNotificationHook(out IntPtr token);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern void GdiplusNotificationUnhook(HandleRef token);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int GdiplusStartup(out IntPtr token, ref StartupInput input, out StartupOutput output);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern void GdiplusShutdown(HandleRef token);

        [StructLayout(LayoutKind.Sequential)]
        private struct StartupInput {
            public int GdiplusVersion;             // Must be 1

            // public DebugEventProc DebugEventCallback; // Ignored on free builds
            public IntPtr DebugEventCallback;

            public bool SuppressBackgroundThread;     // FALSE unless you're prepared to call 
            // the hook/unhook functions properly

            public bool SuppressExternalCodecs;       // FALSE unless you want GDI+ only to use
            // its internal image codecs.

            public static StartupInput GetDefault() {
                StartupInput result = new StartupInput();
                result.GdiplusVersion = 1;
                // result.DebugEventCallback = null;
                result.SuppressBackgroundThread = false;
                result.SuppressExternalCodecs  = false;
                return result;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct StartupOutput
        {
            // The following 2 fields won't be used.  They were originally intended 
            // for getting GDI+ to run on our thread - however there are marshalling
            // dealing with function *'s and what not - so we make explicit calls
            // to gdi+ after the fact, via the GdiplusNotificationHook and 
            // GdiplusNotificationUnhook methods.
            public IntPtr hook;//not used
            public IntPtr unhook;//not used.
        }

        private enum DebugEventLevel {
            Fatal,
            Warning,
        }


        // private delegate void DebugEventProc(DebugEventLevel level, /* char* */ string message);

        // returns GdiplusStatus
        private delegate int NotificationHookProc(out IntPtr token);
        private delegate void NotificationUnhookProc(IntPtr token);

        //----------------------------------------------------------------------------------------                                                           
        // Path methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePath(int brushMode, out IntPtr path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePath2(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePath2I(HandleRef points, HandleRef types, int count, int brushMode, out IntPtr path);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipClonePath(HandleRef path, out IntPtr clonepath);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeletePath", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeletePath(HandleRef path);
        internal static int GdipDeletePath(HandleRef path) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeletePath(path);
            return result;
        }


        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetPath(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPointCount(HandleRef path, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathTypes(HandleRef path, byte[] types, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathPoints(HandleRef path, HandleRef points, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathFillMode(HandleRef path, out int fillmode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathFillMode(HandleRef path, int fillmode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathData(HandleRef path, IntPtr pathData);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipStartPathFigure(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipClosePathFigure(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipClosePathFigures(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathMarker(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipClearPathMarkers(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipReversePath(HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathLastPoint(HandleRef path, GPPOINTF lastPoint);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathLine(HandleRef path, float x1, float y1, float x2,
                                                   float y2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathLine2(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathArc(HandleRef path, float x, float y, float width,
                                                  float height, float startAngle,
                                                  float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathBezier(HandleRef path, float x1, float y1, float x2,
                                                     float y2, float x3, float y3, float x4,
                                                     float y4);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathBeziers(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurve(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurve2(HandleRef path, HandleRef memorypts, int count,
                                                     float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurve3(HandleRef path, HandleRef memorypts, int count,
                                                     int offset, int numberOfSegments,
                                                     float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathClosedCurve(HandleRef path, HandleRef memorypts,
                                                          int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathClosedCurve2(HandleRef path, HandleRef memorypts,
                                                           int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathRectangle(HandleRef path, float x, float y, float width,
                                                        float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathRectangles(HandleRef path, HandleRef rects, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathEllipse(HandleRef path, float x, float y,
                                                      float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathPie(HandleRef path, float x, float y, float width,
                                                  float height, float startAngle,
                                                  float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathPolygon(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathPath(HandleRef path, HandleRef addingPath, bool connect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathString(HandleRef path, string s, int length,
                                                     HandleRef fontFamily, int style, float emSize,
                                                     ref GPRECTF layoutRect, HandleRef format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathStringI(HandleRef path, string s, int length,
                                                      HandleRef fontFamily, int style, float emSize,
                                                      ref GPRECT layoutRect, HandleRef format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathLineI(HandleRef path, int x1, int y1, int x2,
                                                    int y2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathLine2I(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathArcI(HandleRef path, int x, int y, int width,
                                                   int height, float startAngle,
                                                   float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathBezierI(HandleRef path, int x1, int y1, int x2,
                                                      int y2, int x3, int y3, int x4,
                                                      int y4);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathBeziersI(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurveI(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurve2I(HandleRef path, HandleRef memorypts, int count,
                                                      float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathCurve3I(HandleRef path, HandleRef memorypts, int count,
                                                      int offset, int numberOfSegments,
                                                      float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathClosedCurveI(HandleRef path, HandleRef memorypts,
                                                           int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathClosedCurve2I(HandleRef path, HandleRef memorypts,
                                                            int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathRectangleI(HandleRef path, int x, int y, int width,
                                                         int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathRectanglesI(HandleRef path, HandleRef rects, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathEllipseI(HandleRef path, int x, int y,
                                                       int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathPieI(HandleRef path, int x, int y, int width,
                                                   int height, float startAngle,
                                                   float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipAddPathPolygonI(HandleRef path, HandleRef memorypts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFlattenPath(HandleRef path, HandleRef matrixfloat, float flatness);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipWidenPath(HandleRef path, HandleRef pen, HandleRef matrix, float flatness);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipWindingModeOutline(HandleRef path, HandleRef matrix, float flatness);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipWarpPath(HandleRef path, HandleRef matrix, HandleRef points, int count,
                                                float srcX, float srcY, float srcWidth, float srcHeight,
                                                WarpMode warpMode, float flatness);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformPath(HandleRef path, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathWorldBounds(HandleRef path, ref GPRECTF gprectf, HandleRef matrix, HandleRef pen);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathWorldBoundsI(HandleRef path, ref GPRECT gprect, HandleRef matrix, HandleRef pen);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisiblePathPoint(HandleRef path, float x, float y,
                                                          HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisiblePathPointI(HandleRef path, int x, int y,
                                                           HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsOutlineVisiblePathPoint(HandleRef path, float x, float y, HandleRef pen,
                                                                 HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsOutlineVisiblePathPointI(HandleRef path, int x, int y, HandleRef pen,
                                                                  HandleRef graphics, out int boolean);

        //----------------------------------------------------------------------------------------                                                           
        // GraphicsPath Enumeration methods
        //----------------------------------------------------------------------------------------
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePathIter(out IntPtr pathIter, HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeletePathIter", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeletePathIter(HandleRef pathIter);
        internal static int GdipDeletePathIter(HandleRef pathIter) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeletePathIter(pathIter);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterNextSubpath(HandleRef pathIter, out int resultCount,
                                                           out int startIndex, out int endIndex, out bool isClosed);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterNextSubpathPath(HandleRef pathIter, out int resultCount,
                                                               HandleRef path, out bool isClosed);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterNextPathType(HandleRef pathIter, out int resultCount,
                                                            out byte pathType, out int startIndex, 
                                                            out int endIndex);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterNextMarker(HandleRef pathIter, out int resultCount,
                                                          out int startIndex, out int endIndex);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterNextMarkerPath(HandleRef pathIter, out int resultCount,
                                                              HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterGetCount(HandleRef pathIter, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterGetSubpathCount(HandleRef pathIter, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterIsValid(HandleRef pathIter, out bool valid);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterHasCurve(HandleRef pathIter, out bool hasCurve);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterRewind(HandleRef pathIter);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterEnumerate(HandleRef pathIter, out int resultCount,
                                                         IntPtr memoryPts, [In, Out] byte[] types, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPathIterCopyData(HandleRef pathIter, out int resultCount,
                                                        IntPtr memoryPts, [In, Out] byte[] types, int startIndex,
                                                        int endIndex);

        //----------------------------------------------------------------------------------------                                                           
        // Matrix methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMatrix(out IntPtr matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMatrix2(float m11, float m12,
                                                     float m21, float m22, float dx,
                                                     float dy, out IntPtr matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMatrix3(ref GPRECTF rect, HandleRef dstplg, out IntPtr matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMatrix3I(ref GPRECT rect, HandleRef dstplg, out IntPtr matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneMatrix(HandleRef matrix, out IntPtr cloneMatrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteMatrix",  CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteMatrix(HandleRef matrix);
        internal static int GdipDeleteMatrix(HandleRef matrix) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteMatrix(matrix);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetMatrixElements(HandleRef matrix, float m11,
                                                         float m12, float m21,
                                                         float m22, float dx, float dy);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyMatrix(HandleRef matrix, HandleRef matrix2, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateMatrix(HandleRef matrix, float offsetX,
                                                       float offsetY, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScaleMatrix(HandleRef matrix, float scaleX, float scaleY, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotateMatrix(HandleRef matrix, float angle, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipShearMatrix(HandleRef matrix, float shearX, float shearY, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipInvertMatrix(HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformMatrixPoints(HandleRef matrix, HandleRef pts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformMatrixPointsI(HandleRef matrix, HandleRef pts, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipVectorTransformMatrixPoints(HandleRef matrix, HandleRef pts,
                                                                   int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipVectorTransformMatrixPointsI(HandleRef matrix, HandleRef pts,
                                                                    int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMatrixElements(HandleRef matrix, IntPtr m);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsMatrixInvertible(HandleRef matrix, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsMatrixIdentity(HandleRef matrix, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsMatrixEqual(HandleRef matrix, HandleRef matrix2,
                                                     out int boolean);

        //----------------------------------------------------------------------------------------                                                           
        // Region methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegion(out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegionRect(ref GPRECTF gprectf, out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegionRectI(ref GPRECT gprect, out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegionPath(HandleRef path, out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegionRgnData(byte[] rgndata, int size, out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateRegionHrgn(HandleRef hRgn, out IntPtr region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneRegion(HandleRef region, out IntPtr cloneregion);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteRegion", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteRegion(HandleRef region);
        internal static int GdipDeleteRegion(HandleRef region) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteRegion(region);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetInfinite(HandleRef region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetEmpty(HandleRef region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCombineRegionRect(HandleRef region, ref GPRECTF gprectf, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCombineRegionRectI(HandleRef region, ref GPRECT gprect, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCombineRegionPath(HandleRef region, HandleRef path, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCombineRegionRegion(HandleRef region, HandleRef region2, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateRegion(HandleRef region, float dx, float dy);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateRegionI(HandleRef region, int dx, int dy);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformRegion(HandleRef region, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionBounds(HandleRef region, HandleRef graphics, ref GPRECTF gprectf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionBoundsI(HandleRef region, HandleRef graphics, ref GPRECT gprect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionHRgn(HandleRef region, HandleRef graphics, out IntPtr hrgn);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsEmptyRegion(HandleRef region, HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsInfiniteRegion(HandleRef region, HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsEqualRegion(HandleRef region, HandleRef region2, HandleRef graphics,
                                                     out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionDataSize(HandleRef region, out int bufferSize);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionData(HandleRef region, 
                                                     byte[] regionData,
                                                     int bufferSize,
                                                     out int sizeFilled);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRegionPoint(HandleRef region, float X, float Y,
                                                            HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRegionPointI(HandleRef region, int X, int Y,
                                                             HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRegionRect(HandleRef region, float X, float Y,
                                                           float width, float height,
                                                           HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRegionRectI(HandleRef region, int X, int Y,
                                                            int width, int height,
                                                            HandleRef graphics, out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionScansCount(HandleRef region, out int count, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionScans(HandleRef region, IntPtr rects, out int count, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRegionScansI(HandleRef region, IntPtr rects, out int count, HandleRef matrix);

        //----------------------------------------------------------------------------------------                                                           
        // Brush methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneBrush(HandleRef brush, out IntPtr clonebrush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteBrush", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteBrush(HandleRef brush);
        internal static int GdipDeleteBrush(HandleRef brush) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteBrush(brush);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetBrushType(HandleRef brush, out int type);

        //----------------------------------------------------------------------------------------                                                           
        // Hatch Brush
        //----------------------------------------------------------------------------------------
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateHatchBrush(int hatchstyle, int forecol, int backcol, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetHatchStyle(HandleRef brush, out int hatchstyle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetHatchForegroundColor(HandleRef brush, out int forecol);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetHatchBackgroundColor(HandleRef brush, out int backcol);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateTexture(HandleRef bitmap, int wrapmode, out IntPtr texture);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateTexture2(HandleRef bitmap, int wrapmode, float x,
                                                      float y, float width, float height,
                                                      out IntPtr texture);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateTextureIA(HandleRef bitmap, HandleRef imageAttrib,
                                                       float x, float y, float width, float height,
                                                       out IntPtr texture);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateTexture2I(HandleRef bitmap, int wrapmode, int x,
                                                       int y, int width, int height,
                                                       out IntPtr texture);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateTextureIAI(HandleRef bitmap, HandleRef imageAttrib,
                                                        int x, int y, int width, int height,
                                                        out IntPtr texture);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetTextureTransform(HandleRef brush, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetTextureTransform(HandleRef brush, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetTextureTransform(HandleRef brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyTextureTransform(HandleRef brush, 
                                                                HandleRef matrix, 
                                                                MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateTextureTransform(HandleRef brush, 
                                                                 float dx,
                                                                 float dy,
                                                                 MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScaleTextureTransform(HandleRef brush, 
                                                             float sx, 
                                                             float sy,
                                                             MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotateTextureTransform(HandleRef brush, 
                                                              float angle,
                                                              MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetTextureWrapMode(HandleRef brush, int wrapMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetTextureWrapMode(HandleRef brush, out int wrapMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetTextureImage(HandleRef brush, out IntPtr image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateSolidFill(int color, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetSolidFillColor(HandleRef brush, int color);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetSolidFillColor(HandleRef brush, out int color);

        //----------------------------------------------------------------------------------------                                                           
        // Linear Gradient Brush
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrush(GPPOINTF point1, GPPOINTF point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrushI(GPPOINT point1, GPPOINT point2, int color1, int color2, int wrapMode, out IntPtr lineGradient);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrushFromRect(ref GPRECTF rect, int color1, int color2, int lineGradientMode, int wrapMode,
                                                                 out IntPtr lineGradient);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrushFromRectI(ref GPRECT rect, int color1, int color2, int lineGradientMode, int wrapMode,
                                                                  out IntPtr lineGradient);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrushFromRectWithAngle(ref GPRECTF rect, int color1, int color2, float angle, bool isAngleScaleable,
                                                                          int wrapMode, out IntPtr lineGradient);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateLineBrushFromRectWithAngleI(ref GPRECT rect, int color1, int color2, float angle, bool isAngleScaleable,
                                                                           int wrapMode, out IntPtr lineGradient);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLinePoints(HandleRef brush, GPPOINTF point1, GPPOINTF point2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLinePointsI(HandleRef brush, GPPOINT point1, GPPOINT point2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLinePoints(HandleRef brush, HandleRef points);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLinePointsI(HandleRef brush, HandleRef points);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineColors(HandleRef brush, int color1, int color2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineColors(HandleRef brush, int[] colors);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineRect(HandleRef brush, ref GPRECTF gprectf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineRectI(HandleRef brush, ref GPRECT gprect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineGammaCorrection(HandleRef brush, out bool useGammaCorrection);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineGammaCorrection(HandleRef brush, bool useGammaCorrection);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineSigmaBlend(HandleRef brush, float focus, float scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineLinearBlend(HandleRef brush, float focus, float scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineBlendCount(HandleRef brush, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLinePresetBlendCount(HandleRef brush, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLinePresetBlend(HandleRef brush, IntPtr blend, IntPtr positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLinePresetBlend(HandleRef brush, HandleRef blend, HandleRef positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineWrapMode(HandleRef brush, int wrapMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineWrapMode(HandleRef brush, out int wrapMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetLineTransform(HandleRef brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyLineTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineTransform(HandleRef brush, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetLineTransform(HandleRef brush, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateLineTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScaleLineTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotateLineTransform(HandleRef brush, float angle, MatrixOrder order);

        //----------------------------------------------------------------------------------------                                                           
        // Path Gradient Brush
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePathGradient(HandleRef points, int count, int wrapMode, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePathGradientI(HandleRef points, int count, int wrapMode, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePathGradientFromPath(HandleRef path, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientCenterColor(HandleRef brush,
                                                                  out int color);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientCenterColor(HandleRef brush,
                                                                  int color);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientSurroundColorsWithCount(HandleRef brush,
                                                                              int[] color,
                                                                              ref int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientSurroundColorsWithCount(HandleRef brush,
                                                                              int[] argb,
                                                                              ref int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientCenterPoint(HandleRef brush,
                                                                  GPPOINTF point);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientCenterPointI(HandleRef brush,
                                                                   GPPOINT point);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientCenterPoint(HandleRef brush,
                                                                  GPPOINTF point);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientCenterPointI(HandleRef brush,
                                                                   GPPOINT point);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientRect(HandleRef brush,
                                                           ref GPRECTF gprectf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientRectI(HandleRef brush,
                                                            ref GPRECT gprect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientPointCount(HandleRef brush, 
                                                                 out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientSurroundColorCount(HandleRef brush, 
                                                                         out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientBlendCount(HandleRef brush,
                                                                 out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientBlend(HandleRef brush,
                                                            IntPtr blend,
                                                            IntPtr positions,
                                                            int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientBlend(HandleRef brush,
                                                            HandleRef blend,
                                                            HandleRef positions,
                                                            int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientPresetBlendCount(HandleRef brush, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientPresetBlend(HandleRef brush, IntPtr blend,
                                                                  IntPtr positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientPresetBlend(HandleRef brush, HandleRef blend,
                                                                  HandleRef positions, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientSigmaBlend(HandleRef brush,
                                                                 float focus,
                                                                 float scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientLinearBlend(HandleRef brush,
                                                                  float focus,
                                                                  float scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientWrapMode(HandleRef brush,
                                                               int wrapmode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientWrapMode(HandleRef brush,
                                                               out int wrapmode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientTransform(HandleRef brush,
                                                                HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientTransform(HandleRef brush,
                                                                HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetPathGradientTransform(HandleRef brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyPathGradientTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslatePathGradientTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScalePathGradientTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotatePathGradientTransform(HandleRef brush, float angle, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPathGradientFocusScales(HandleRef brush,
                                                                  float[] xScale,
                                                                  float[] yScale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPathGradientFocusScales(HandleRef brush,
                                                                  float xScale,
                                                                  float yScale);

        //----------------------------------------------------------------------------------------                                                           
        // Pen methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePen1(int argb, float width, int unit,
                                                  out IntPtr pen);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreatePen2(HandleRef brush, float width, int unit,
                                                  out IntPtr pen);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipClonePen(HandleRef pen, out IntPtr clonepen);
  
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeletePen", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeletePen(HandleRef Pen);
        internal static int GdipDeletePen(HandleRef pen) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeletePen(pen);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenMode(HandleRef pen, PenAlignment penAlign);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenMode(HandleRef pen, out PenAlignment penAlign);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenWidth(HandleRef pen, float width);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenWidth(HandleRef pen, float[] width);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenUnit(HandleRef pen, int unit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenUnit(HandleRef pen, out int unit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenLineCap197819(HandleRef pen, int startCap, int endCap, int dashCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenStartCap(HandleRef pen, int startCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenEndCap(HandleRef pen, int endCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenStartCap(HandleRef pen, out int startCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenEndCap(HandleRef pen, out int endCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashCap197819(HandleRef pen, out int dashCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashCap(HandleRef pen, out int dashCap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenDashCap197819(HandleRef pen, int dashCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenLineJoin(HandleRef pen, int lineJoin);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenLineJoin(HandleRef pen, out int lineJoin);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenCustomStartCap(HandleRef pen, HandleRef customCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenCustomStartCap(HandleRef pen, out IntPtr customCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenCustomEndCap(HandleRef pen, HandleRef customCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenCustomEndCap(HandleRef pen, out IntPtr customCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenMiterLimit(HandleRef pen, float miterLimit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenMiterLimit(HandleRef pen, float[] miterLimit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenTransform(HandleRef pen, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenTransform(HandleRef pen, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetPenTransform(HandleRef brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyPenTransform(HandleRef brush, HandleRef matrix, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslatePenTransform(HandleRef brush, float dx, float dy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScalePenTransform(HandleRef brush, float sx, float sy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotatePenTransform(HandleRef brush, float angle, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenColor(HandleRef pen, int argb);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenColor(HandleRef pen, out int argb);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenBrushFill(HandleRef pen, HandleRef brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenBrushFill(HandleRef pen, out IntPtr brush);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenFillType(HandleRef pen, out int pentype);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashStyle(HandleRef pen, out int dashstyle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenDashStyle(HandleRef pen, int dashstyle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenDashArray(HandleRef pen, HandleRef memorydash, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashOffset(HandleRef pen, float[] dashoffset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenDashOffset(HandleRef pen, float dashoffset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashCount(HandleRef pen, out int dashcount);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenDashArray(HandleRef pen, IntPtr memorydash, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenCompoundCount(HandleRef pen, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPenCompoundArray(HandleRef pen, float[] array, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPenCompoundArray(HandleRef pen, float[] array, int count);

        //----------------------------------------------------------------------------------------                                                           
        // CustomLineCap methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateCustomLineCap(HandleRef fillpath, HandleRef strokepath, LineCap baseCap, float baseInset, out IntPtr customCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteCustomLineCap", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteCustomLineCap(HandleRef customCap);
        internal static int GdipDeleteCustomLineCap(HandleRef customCap) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteCustomLineCap(customCap);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneCustomLineCap(HandleRef customCap, out IntPtr clonedCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapType(HandleRef customCap, 
                                                            out CustomLineCapType capType);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCustomLineCapStrokeCaps(HandleRef customCap,
                                                                  LineCap startCap,
                                                                  LineCap endCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapStrokeCaps(HandleRef customCap,
                                                                  out LineCap startCap,
                                                                  out LineCap endCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCustomLineCapStrokeJoin(HandleRef customCap,
                                                                  LineJoin lineJoin);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapStrokeJoin(HandleRef customCap,
                                                                  out LineJoin lineJoin);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCustomLineCapBaseCap(HandleRef customCap,
                                                               LineCap baseCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapBaseCap(HandleRef customCap,
                                                               out LineCap baseCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCustomLineCapBaseInset(HandleRef customCap,
                                                                 float inset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapBaseInset(HandleRef customCap,
                                                                 out float inset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCustomLineCapWidthScale(HandleRef customCap,
                                                                  float widthScale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCustomLineCapWidthScale(HandleRef customCap,
                                                                  out float widthScale);

        //----------------------------------------------------------------------------------------                                                           
        // AdjustableArrowCap methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateAdjustableArrowCap(float height, float width, bool isFilled, out IntPtr adjustableArrowCap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetAdjustableArrowCapHeight(HandleRef adjustableArrowCap,
                                                                   float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetAdjustableArrowCapHeight(HandleRef adjustableArrowCap,
                                                                   out float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetAdjustableArrowCapWidth(HandleRef adjustableArrowCap,
                                                                  float width);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetAdjustableArrowCapWidth(HandleRef adjustableArrowCap,
                                                                  out float width);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap,
                                                                        float middleInset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetAdjustableArrowCapMiddleInset(HandleRef adjustableArrowCap,
                                                                        out float middleInset);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetAdjustableArrowCapFillState(HandleRef adjustableArrowCap,
                                                                      bool fillState);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetAdjustableArrowCapFillState(HandleRef adjustableArrowCap,
                                                                      out bool fillState);

        //----------------------------------------------------------------------------------------                                                           
        // Image methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipLoadImageFromStream(UnsafeNativeMethods.IStream stream, out IntPtr image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipLoadImageFromFile(string filename, out IntPtr image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipLoadImageFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipLoadImageFromFileICM(string filename, out IntPtr image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneImage(HandleRef image, out IntPtr cloneimage);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDisposeImage", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDisposeImage(HandleRef image);
        internal static int GdipDisposeImage(HandleRef image) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result =  IntGdipDisposeImage(image);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSaveImageToFile(HandleRef image, string filename,
                                                       ref Guid classId, HandleRef encoderParams);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSaveImageToStream(HandleRef image, UnsafeNativeMethods.IStream stream,
                                                         ref Guid classId, HandleRef encoderParams);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSaveAdd(HandleRef image, HandleRef encoderParams);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSaveAddImage(HandleRef image, HandleRef newImage, HandleRef encoderParams);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageGraphicsContext(HandleRef image, out IntPtr graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageBounds(HandleRef image, ref GPRECTF gprectf, out GraphicsUnit unit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageDimension(HandleRef image, out float width, out float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageType(HandleRef image, out int type);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageWidth(HandleRef image, out int width);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageHeight(HandleRef image, out int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageHorizontalResolution(HandleRef image, out float horzRes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageVerticalResolution(HandleRef image, out float vertRes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageFlags(HandleRef image, out int flags);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageRawFormat(HandleRef image, ref Guid format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImagePixelFormat(HandleRef image, out int format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageThumbnail(HandleRef image, int thumbWidth, int thumbHeight, 
                                                         out IntPtr thumbImage, 
                                                         Image.GetThumbnailImageAbort callback, 
                                                         IntPtr callbackdata);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetEncoderParameterListSize(HandleRef image, ref Guid clsid,
                                                                   out int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetEncoderParameterList(HandleRef image, ref Guid clsid, int size,
                                                               IntPtr buffer);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageGetFrameDimensionsCount(HandleRef image, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageGetFrameDimensionsList(HandleRef image, 
                                                                   IntPtr buffer,
                                                                   int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageGetFrameCount(HandleRef image, ref Guid dimensionID, int[] count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageSelectActiveFrame(HandleRef image, ref Guid dimensionID, int frameIndex);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageRotateFlip(HandleRef image, int rotateFlipType);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImagePalette(HandleRef image, IntPtr palette, int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImagePalette(HandleRef image, IntPtr palette);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImagePaletteSize(HandleRef image, out int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPropertyCount(HandleRef image, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPropertyIdList(HandleRef image, int count, int[] list);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPropertyItemSize(HandleRef image, int propid, out int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPropertyItem(HandleRef image, int propid, int size, IntPtr buffer);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPropertySize(HandleRef image, out int totalSize, ref int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetAllPropertyItems(HandleRef image, int totalSize, int count, IntPtr buffer);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRemovePropertyItem(HandleRef image, int propid);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPropertyItem(HandleRef image, PropertyItemInternal propitem);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipImageForceValidation(HandleRef image);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageDecodersSize(out int numDecoders, out int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageDecoders(int numDecoders, int size, IntPtr decoders);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageEncodersSize(out int numEncoders, out int size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageEncoders(int numEncoders, int size, IntPtr encoders);

        //----------------------------------------------------------------------------------------                                                           
        // Bitmap methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromStream(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromFile(string filename, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromStreamICM(UnsafeNativeMethods.IStream stream, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromFileICM(string filename, out IntPtr bitmap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromScan0(int width, int height, int stride, int format, HandleRef scan0, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromGraphics(int width, int height, HandleRef graphics, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromHBITMAP(HandleRef hbitmap, HandleRef hpalette, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromHICON(HandleRef hicon, out IntPtr bitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateBitmapFromResource(HandleRef hresource, HandleRef name, out IntPtr bitmap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateHBITMAPFromBitmap(HandleRef nativeBitmap, out IntPtr hbitmap, int argbBackground);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateHICONFromBitmap(HandleRef nativeBitmap, out IntPtr hicon);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneBitmapArea(float x, float y, float width, float height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneBitmapAreaI(int x, int y, int width, int height, int format, HandleRef srcbitmap, out IntPtr dstbitmap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBitmapLockBits(HandleRef bitmap, 
                                                      ref GPRECT rect,
                                                      ImageLockMode flags, // ImageLockMode
                                                      PixelFormat format, // PixelFormat
                                                      [In, Out] BitmapData lockedBitmapData);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBitmapUnlockBits(HandleRef bitmap,
                                                        BitmapData lockedBitmapData);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBitmapGetPixel(HandleRef bitmap, int x, int y, out int argb);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBitmapSetPixel(HandleRef bitmap, int x, int y, int argb);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBitmapSetResolution(HandleRef bitmap, float dpix, float dpiy);

        //----------------------------------------------------------------------------------------                                                           
        // ImageAttributes methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateImageAttributes(out IntPtr imageattr);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneImageAttributes(HandleRef imageattr, out IntPtr cloneImageattr);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDisposeImageAttributes", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDisposeImageAttributes(HandleRef imageattr);
        internal static int GdipDisposeImageAttributes(HandleRef imageattr) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDisposeImageAttributes(imageattr);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesToIdentity(HandleRef imageattr,
                                                                    ColorAdjustType type);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetImageAttributes(HandleRef imageattr,
                                                            ColorAdjustType type);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesColorMatrix(HandleRef imageattr,
                                                                     ColorAdjustType type,
                                                                     bool enableFlag,
                                                                     ColorMatrix colorMatrix,
                                                                     ColorMatrix grayMatrix,
                                                                     ColorMatrixFlag flags);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesThreshold(HandleRef imageattr,
                                                                   ColorAdjustType type,
                                                                   bool enableFlag,
                                                                   float threshold);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesGamma(HandleRef imageattr,
                                                               ColorAdjustType type,
                                                               bool enableFlag,
                                                               float gamma);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesNoOp(HandleRef imageattr,
                                                              ColorAdjustType type,
                                                              bool enableFlag);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesColorKeys(HandleRef imageattr,
                                                                   ColorAdjustType type,
                                                                   bool enableFlag,
                                                                   int colorLow, // yes, ref, not out
                                                                   int colorHigh);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesOutputChannel(HandleRef imageattr,
                                                                       ColorAdjustType type,
                                                                       bool enableFlag,
                                                                       ColorChannelFlag flags);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesOutputChannelColorProfile(
                                                                                  HandleRef imageattr,
                                                                                  ColorAdjustType type,
                                                                                  bool enableFlag,
                                                                                  string colorProfileFilename);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesRemapTable(HandleRef imageattr,
                                                                    ColorAdjustType type,
                                                                    bool enableFlag,
                                                                    int mapSize,
                                                                    HandleRef map);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetImageAttributesWrapMode(HandleRef imageattr,
                                                                  int wrapmode,
                                                                  int argb,
                                                                  bool clamp);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetImageAttributesAdjustedPalette(HandleRef imageattr,
                                                                         HandleRef palette,
                                                                         ColorAdjustType type);

        //----------------------------------------------------------------------------------------                                                           
        // Graphics methods
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFlush(HandleRef graphics, FlushIntention intention);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFromHDC(HandleRef hdc, out IntPtr graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFromHDC2(HandleRef hdc, HandleRef hdevice, out IntPtr graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFromHWND(HandleRef hwnd, out IntPtr graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFromHWNDICM(HandleRef hwnd, out IntPtr graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteGraphics", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteGraphics(HandleRef graphics);
        internal static int GdipDeleteGraphics(HandleRef graphics) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteGraphics(graphics);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetDC(HandleRef graphics, out IntPtr hdc);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipReleaseDC", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipReleaseDC(HandleRef graphics, HandleRef hdc);
        internal static int GdipReleaseDC(HandleRef graphics, HandleRef hdc) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipReleaseDC(graphics, hdc);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCompositingMode(HandleRef graphics, int compositeMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetTextRenderingHint(HandleRef graphics, TextRenderingHint textRenderingHint);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetTextContrast(HandleRef graphics, int textContrast);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetInterpolationMode(HandleRef graphics, int mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCompositingMode(HandleRef graphics, out int compositeMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetRenderingOrigin(HandleRef graphics, int x, int y);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetRenderingOrigin(HandleRef graphics, out int x, out int y);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetCompositingQuality(HandleRef graphics, CompositingQuality quality);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCompositingQuality(HandleRef graphics, out CompositingQuality quality);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetSmoothingMode(HandleRef graphics, SmoothingMode smoothingMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetSmoothingMode(HandleRef graphics, out SmoothingMode smoothingMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPixelOffsetMode(HandleRef graphics, PixelOffsetMode pixelOffsetMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPixelOffsetMode(HandleRef graphics, out PixelOffsetMode pixelOffsetMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetTextRenderingHint(HandleRef graphics, out TextRenderingHint textRenderingHint);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetTextContrast(HandleRef graphics, out int textContrast);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetInterpolationMode(HandleRef graphics, out int mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetWorldTransform(HandleRef graphics, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetWorldTransform(HandleRef graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMultiplyWorldTransform(HandleRef graphics, HandleRef matrix, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateWorldTransform(HandleRef graphics, float dx, float dy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipScaleWorldTransform(HandleRef graphics, float sx, float sy, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRotateWorldTransform(HandleRef graphics, float angle, MatrixOrder order);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetWorldTransform(HandleRef graphics, HandleRef matrix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetPageTransform(HandleRef graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPageUnit(HandleRef graphics, out int unit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetPageScale(HandleRef graphics, float[] scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPageUnit(HandleRef graphics, int unit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetPageScale(HandleRef graphics, float scale);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetDpiX(HandleRef graphics, float[] dpi);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetDpiY(HandleRef graphics, float[] dpi);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformPoints(HandleRef graphics, int destSpace,
                                                       int srcSpace, IntPtr points, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTransformPointsI(HandleRef graphics, int destSpace,
                                                        int srcSpace, IntPtr points, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetNearestColor(HandleRef graphics, ref int color);

        // Create the Win9x Halftone Palette (even on NT) with correct Desktop colors
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern IntPtr GdipCreateHalftonePalette();

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawLine(HandleRef graphics, HandleRef pen, float x1, float y1,
                                                float x2, float y2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawLineI(HandleRef graphics, HandleRef pen, int x1, int y1,
                                                 int x2, int y2);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawLines(HandleRef graphics, HandleRef pen, HandleRef points,
                                                 int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawLinesI(HandleRef graphics, HandleRef pen, HandleRef points,
                                                  int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawArc(HandleRef graphics, HandleRef pen, float x, float y,
                                               float width, float height, float startAngle,
                                               float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawArcI(HandleRef graphics, HandleRef pen, int x, int y,
                                                int width, int height, float startAngle,
                                                float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawBezier(HandleRef graphics, HandleRef pen, float x1, float y1,
                                                  float x2, float y2, float x3, float y3,
                                                  float x4, float y4);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawBezierI(HandleRef graphics, HandleRef pen, int x1, int y1,
                                                   int x2, int y2, int x3, int y3,
                                                   int x4, int y4);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawBeziers(HandleRef graphics, HandleRef pen, HandleRef points,
                                                   int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawBeziersI(HandleRef graphics, HandleRef pen, HandleRef points,
                                                    int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawRectangle(HandleRef graphics, HandleRef pen, float x, float y,
                                                     float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawRectangleI(HandleRef graphics, HandleRef pen, int x, int y,
                                                      int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawRectangles(HandleRef graphics, HandleRef pen, HandleRef rects,
                                                      int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawRectanglesI(HandleRef graphics, HandleRef pen, HandleRef rects,
                                                       int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawEllipse(HandleRef graphics, HandleRef pen, float x, float y,
                                                   float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawEllipseI(HandleRef graphics, HandleRef pen, int x, int y,
                                                    int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawPie(HandleRef graphics, HandleRef pen, float x, float y,
                                               float width, float height, float startAngle,
                                               float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawPieI(HandleRef graphics, HandleRef pen, int x, int y,
                                                int width, int height, float startAngle,
                                                float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawPolygon(HandleRef graphics, HandleRef pen, HandleRef points,
                                                   int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawPolygonI(HandleRef graphics, HandleRef pen, HandleRef points,
                                                    int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawPath(HandleRef graphics, HandleRef pen, HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurve(HandleRef graphics, HandleRef pen, HandleRef points,
                                                 int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurveI(HandleRef graphics, HandleRef pen, HandleRef points,
                                                  int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurve2(HandleRef graphics, HandleRef pen, HandleRef points,
                                                  int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurve2I(HandleRef graphics, HandleRef pen, HandleRef points,
                                                   int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurve3(HandleRef graphics, HandleRef pen, HandleRef points,
                                                  int count, int offset,
                                                  int numberOfSegments, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCurve3I(HandleRef graphics, HandleRef pen, HandleRef points,
                                                   int count, int offset,
                                                   int numberOfSegments, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawClosedCurve(HandleRef graphics, HandleRef pen, HandleRef points,
                                                       int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawClosedCurveI(HandleRef graphics, HandleRef pen, HandleRef points,
                                                        int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawClosedCurve2(HandleRef graphics, HandleRef pen, HandleRef points,
                                                        int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawClosedCurve2I(HandleRef graphics, HandleRef pen, HandleRef points,
                                                         int count, float tension);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGraphicsClear(HandleRef graphics, int argb);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillRectangle(HandleRef graphics, HandleRef brush, float x, float y,
                                                     float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillRectangleI(HandleRef graphics, HandleRef brush, int x, int y,
                                                      int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillRectangles(HandleRef graphics, HandleRef brush, HandleRef rects,
                                                      int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillRectanglesI(HandleRef graphics, HandleRef brush, HandleRef rects,
                                                       int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPolygon(HandleRef graphics, HandleRef brush, HandleRef points,
                                                   int count, int brushMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPolygonI(HandleRef graphics, HandleRef brush, HandleRef points,
                                                    int count, int brushMode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPolygon2(HandleRef graphics, HandleRef brush, HandleRef points,
                                                    int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPolygon2I(HandleRef graphics, HandleRef brush, HandleRef points,
                                                     int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillEllipse(HandleRef graphics, HandleRef brush, float x, float y,
                                                   float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillEllipseI(HandleRef graphics, HandleRef brush, int x, int y,
                                                    int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPie(HandleRef graphics, HandleRef brush, float x, float y,
                                               float width, float height, float startAngle,
                                               float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPieI(HandleRef graphics, HandleRef brush, int x, int y,
                                                int width, int height, float startAngle,
                                                float sweepAngle);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillPath(HandleRef graphics, HandleRef brush, HandleRef path);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillClosedCurve(HandleRef graphics, HandleRef brush, HandleRef points,
                                                       int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillClosedCurveI(HandleRef graphics, HandleRef brush, HandleRef points,
                                                        int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillClosedCurve2(HandleRef graphics, HandleRef brush, HandleRef points,
                                                        int count, float tension,
                                                        int mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillClosedCurve2I(HandleRef graphics, HandleRef brush, HandleRef points,
                                                         int count, float tension,
                                                         int mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipFillRegion(HandleRef graphics, HandleRef brush, HandleRef region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImage(HandleRef graphics, HandleRef image, float x, float y);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImageI(HandleRef graphics, HandleRef image, int x, int y);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImageRect(HandleRef graphics, HandleRef image, float x,
                                                     float y, float width, float height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImageRectI(HandleRef graphics, HandleRef image, int x,
                                                      int y, int width, int height);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePoints(HandleRef graphics, HandleRef image,
                                                       HandleRef points, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePointsI(HandleRef graphics, HandleRef image,
                                                        HandleRef points, int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePointRect(HandleRef graphics, HandleRef image, float x,
                                                          float y, float srcx, float srcy,
                                                          float srcwidth, float srcheight,
                                                          int srcunit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePointRectI(HandleRef graphics, HandleRef image, int x,
                                                           int y, int srcx, int srcy,
                                                           int srcwidth, int srcheight,
                                                           int srcunit);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImageRectRect(HandleRef graphics, HandleRef image,
                                                         float dstx, float dsty,
                                                         float dstwidth, float dstheight,
                                                         float srcx, float srcy,
                                                         float srcwidth, float srcheight,
                                                         int srcunit, HandleRef imageAttributes,
                                                         Graphics.DrawImageAbort callback, HandleRef callbackdata);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImageRectRectI(HandleRef graphics, HandleRef image,
                                                          int dstx, int dsty,
                                                          int dstwidth, int dstheight,
                                                          int srcx, int srcy,
                                                          int srcwidth, int srcheight,
                                                          int srcunit, HandleRef imageAttributes,
                                                          Graphics.DrawImageAbort callback, HandleRef callbackdata);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePointsRect(HandleRef graphics, HandleRef image,
                                                           HandleRef points, int count, float srcx,
                                                           float srcy, float srcwidth,
                                                           float srcheight, int srcunit,
                                                           HandleRef imageAttributes,
                                                           Graphics.DrawImageAbort callback, HandleRef callbackdata);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawImagePointsRectI(HandleRef graphics, HandleRef image,
                                                            HandleRef points, int count, int srcx,
                                                            int srcy, int srcwidth,
                                                            int srcheight, int srcunit,
                                                            HandleRef imageAttributes,
                                                            Graphics.DrawImageAbort callback, HandleRef callbackdata);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestPoint(HandleRef graphics,
                                                                  HandleRef metafile,
                                                                  GPPOINTF destPoint,
                                                                  Graphics.EnumerateMetafileProc callback,
                                                                  HandleRef callbackdata,
                                                                  HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestPointI(HandleRef graphics,
                                                                   HandleRef metafile,
                                                                   GPPOINT destPoint,
                                                                   Graphics.EnumerateMetafileProc callback,
                                                                   HandleRef callbackdata,
                                                                   HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestRect(HandleRef graphics,
                                                                 HandleRef metafile,
                                                                 ref GPRECTF destRect,
                                                                 Graphics.EnumerateMetafileProc callback,
                                                                 HandleRef callbackdata,
                                                                 HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestRectI(HandleRef graphics,
                                                                  HandleRef metafile,
                                                                  ref GPRECT destRect,
                                                                  Graphics.EnumerateMetafileProc callback,
                                                                  HandleRef callbackdata,
                                                                  HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestPoints(HandleRef graphics,
                                                                   HandleRef metafile,
                                                                   IntPtr destPoints,
                                                                   int count,
                                                                   Graphics.EnumerateMetafileProc callback,
                                                                   HandleRef callbackdata,
                                                                   HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileDestPointsI(HandleRef graphics,
                                                                    HandleRef metafile,
                                                                    IntPtr destPoints,
                                                                    int count,
                                                                    Graphics.EnumerateMetafileProc callback,
                                                                    HandleRef callbackdata,
                                                                    HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestPoint(HandleRef graphics,
                                                                         HandleRef metafile,
                                                                         GPPOINTF destPoint,
                                                                         ref GPRECTF srcRect,
                                                                         int pageUnit,
                                                                         Graphics.EnumerateMetafileProc callback,
                                                                         HandleRef callbackdata,
                                                                         HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestPointI(HandleRef graphics,
                                                                          HandleRef metafile,
                                                                          GPPOINT destPoint,
                                                                          ref GPRECT srcRect,
                                                                          int pageUnit,
                                                                          Graphics.EnumerateMetafileProc callback,
                                                                          HandleRef callbackdata,
                                                                          HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestRect(HandleRef graphics,
                                                                        HandleRef metafile,
                                                                        ref GPRECTF destRect,
                                                                        ref GPRECTF srcRect,
                                                                        int pageUnit,
                                                                        Graphics.EnumerateMetafileProc callback,
                                                                        HandleRef callbackdata,
                                                                        HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestRectI(HandleRef graphics,
                                                                         HandleRef metafile,
                                                                         ref GPRECT destRect,
                                                                         ref GPRECT srcRect,
                                                                         int pageUnit,
                                                                         Graphics.EnumerateMetafileProc callback,
                                                                         HandleRef callbackdata,
                                                                         HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestPoints(HandleRef graphics,
                                                                          HandleRef metafile,
                                                                          IntPtr destPoints,
                                                                          int count,
                                                                          ref GPRECTF srcRect,
                                                                          int pageUnit,
                                                                          Graphics.EnumerateMetafileProc callback,
                                                                          HandleRef callbackdata,
                                                                          HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEnumerateMetafileSrcRectDestPointsI(HandleRef graphics,
                                                                           HandleRef metafile,
                                                                           IntPtr destPoints,
                                                                           int count,
                                                                           ref GPRECT srcRect,
                                                                           int pageUnit,
                                                                           Graphics.EnumerateMetafileProc callback,
                                                                           HandleRef callbackdata,
                                                                           HandleRef imageattributes);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPlayMetafileRecord(HandleRef graphics, 
                                                          EmfPlusRecordType recordType, 
                                                          int flags, 
                                                          int dataSize, 
                                                          byte[] data);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipGraphics(HandleRef graphics, HandleRef srcgraphics, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipRect(HandleRef graphics, float x, float y,
                                                   float width, float height, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipRectI(HandleRef graphics, int x, int y,
                                                    int width, int height, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipPath(HandleRef graphics, HandleRef path, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipRegion(HandleRef graphics, HandleRef region, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetClipHrgn(HandleRef graphics, HandleRef hRgn, CombineMode mode);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipResetClip(HandleRef graphics);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateClip(HandleRef graphics, float dx, float dy);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipTranslateClipI(HandleRef graphics, int dx, int dy);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetClip(HandleRef graphics, HandleRef region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetClipBounds(HandleRef graphics, ref GPRECTF rect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetClipBoundsI(HandleRef graphics, ref GPRECT rect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsClipEmpty(HandleRef graphics,
                                                   out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetVisibleClipBounds(HandleRef graphics, ref GPRECTF rect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetVisibleClipBoundsI(HandleRef graphics, ref GPRECT rect);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleClipEmpty(HandleRef graphics,
                                                          out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisiblePoint(HandleRef graphics, float x, float y,
                                                      out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisiblePointI(HandleRef graphics, int x, int y,
                                                       out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRect(HandleRef graphics, float x, float y,
                                                     float width, float height,
                                                     out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsVisibleRectI(HandleRef graphics, int x, int y,
                                                      int width, int height,
                                                      out int boolean);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSaveGraphics(HandleRef graphics, out int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRestoreGraphics(HandleRef graphics, int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBeginContainer(HandleRef graphics, ref GPRECTF dstRect,
                                                      ref GPRECTF srcRect, int unit,
                                                      out int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBeginContainer2(HandleRef graphics, out int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipBeginContainerI(HandleRef graphics, ref GPRECT dstRect,
                                                       ref GPRECT srcRect, int unit,
                                                       out int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEndContainer(HandleRef graphics, int state);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileHeaderFromWmf(HandleRef hMetafile,      // WMF
                                                                WmfPlaceableFileHeader wmfplaceable,
                                                                [In, Out] MetafileHeaderWmf metafileHeaderWmf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileHeaderFromEmf(HandleRef hEnhMetafile,   // EMF
                                                                [In, Out] MetafileHeaderEmf metafileHeaderEmf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileHeaderFromFile(string filename,
                                                                 IntPtr header);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileHeaderFromStream(UnsafeNativeMethods.IStream stream,
                                                                   IntPtr header);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileHeaderFromMetafile(HandleRef metafile,
                                                                     IntPtr header);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetHemfFromMetafile(HandleRef metafile,
                                                           out IntPtr hEnhMetafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateStreamOnFile(string file, int access, UnsafeNativeMethods.IStream[] stream);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMetafileFromWmf(HandleRef hMetafile, WmfPlaceableFileHeader wmfplacealbeHeader,bool deleteWmf, out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMetafileFromEmf(HandleRef hEnhMetafile, bool deleteEmf, out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMetafileFromFile(string file, out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateMetafileFromWmfFile(string file, WmfPlaceableFileHeader wmfplaceableFileHeader, 
                                                                 out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode        
        internal static extern int GdipCreateMetafileFromStream(UnsafeNativeMethods.IStream stream, out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafile(HandleRef referenceHdc,
                                                      int emfType,
                                                      ref GPRECTF frameRect,
                                                      int frameUnit,
                                                      string description,
                                                      out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafile(HandleRef referenceHdc,
                                                      int emfType,
                                                      HandleRef pframeRect,
                                                      int frameUnit,
                                                      string description,
                                                      out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileI(HandleRef referenceHdc,
                                                       int emfType,
                                                       ref GPRECT frameRect,
                                                       int frameUnit,
                                                       string description,
                                                       out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileFileName(string fileName,
                                                              HandleRef referenceHdc,
                                                              int emfType,
                                                              ref GPRECTF frameRect,
                                                              int frameUnit,
                                                              string description,
                                                              out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileFileName(string fileName,
                                                              HandleRef referenceHdc,
                                                              int emfType,
                                                              HandleRef pframeRect,
                                                              int frameUnit,
                                                              string description,
                                                              out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileFileNameI(string fileName,
                                                               HandleRef referenceHdc,
                                                               int emfType,
                                                               ref GPRECT frameRect,
                                                               int frameUnit,
                                                               string description,
                                                               out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream,
                                                            HandleRef referenceHdc,
                                                            int emfType,
                                                            ref GPRECTF frameRect,
                                                            int frameUnit,
                                                            string description,
                                                            out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileStream(UnsafeNativeMethods.IStream stream,
                                                            HandleRef referenceHdc,
                                                            int emfType,
                                                            HandleRef pframeRect,
                                                            int frameUnit,
                                                            string description,
                                                            out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipRecordMetafileStreamI(UnsafeNativeMethods.IStream stream,
                                                             HandleRef referenceHdc,
                                                             int emfType,
                                                             ref GPRECT frameRect,
                                                             int frameUnit,
                                                             string description,
                                                             out IntPtr metafile);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetMetafileDownLevelRasterizationLimit(
                                                             HandleRef metafile,
                                                             int rasterizationLimit);
                                                                     
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetMetafileDownLevelRasterizationLimit(
                                                             HandleRef metafile,
                                                             out int rasterizationLimit);
                                                                     
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipEmfToWmfBits(int hEnhMetafile,
                                                    int cbData16,
                                                    byte[] pData16,
                                                    int mapMode,
                                                    int eFlags);
        
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipComment(HandleRef graphics, int sizeData, byte[] data);

        //----------------------------------------------------------------------------------------
        // Font Collection
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipNewInstalledFontCollection(out IntPtr fontCollection);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipNewPrivateFontCollection(out IntPtr fontCollection);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeletePrivateFontCollection", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeletePrivateFontCollection(out IntPtr fontCollection);
        internal static int GdipDeletePrivateFontCollection(out IntPtr fontCollection) {
            if (IsShutdown) {
                fontCollection = IntPtr.Zero;
                return SafeNativeMethods.Ok;
            }
            int result = IntGdipDeletePrivateFontCollection(out fontCollection);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontCollectionFamilyCount(HandleRef fontCollection, out int numFound);

        // should be IntPtr
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontCollectionFamilyList(HandleRef fontCollection, int numSought, IntPtr[] gpfamilies,
                                                                   out int numFound);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPrivateAddFontFile(HandleRef fontCollection, string filename);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipPrivateAddMemoryFont(HandleRef fontCollection, HandleRef memory, int length);

        //----------------------------------------------------------------------------------------                                                           
        // FontFamily
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFontFamilyFromName(string name, HandleRef fontCollection, out IntPtr FontFamily);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetGenericFontFamilySansSerif(out IntPtr fontfamily);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetGenericFontFamilySerif(out IntPtr fontfamily);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetGenericFontFamilyMonospace(out IntPtr fontfamily);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteFontFamily", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteFontFamily(HandleRef fontFamily);
        internal static int GdipDeleteFontFamily(HandleRef fontFamily) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteFontFamily(fontFamily);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneFontFamily(HandleRef fontfamily, out IntPtr clonefontfamily);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFamilyName(HandleRef family, StringBuilder name, int language);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipIsStyleAvailable(HandleRef family, FontStyle style, out int isStyleAvailable);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetEmHeight(HandleRef family, FontStyle style, out int EmHeight);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCellAscent(HandleRef family, FontStyle style, out int CellAscent);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetCellDescent(HandleRef family, FontStyle style, out int CellDescent);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLineSpacing(HandleRef family, FontStyle style, out int LineSpaceing);
        //----------------------------------------------------------------------------------------                                                           
        // Font      
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFontFromDC(HandleRef hdc, ref IntPtr font);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)] // DIFFERENT: ANSI, not Unicode
        internal static extern int GdipCreateFontFromLogfontA(HandleRef hdc, [In, Out, MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFontFromLogfontW(HandleRef hdc, [In, Out, MarshalAs(UnmanagedType.AsAny)] object lf, out IntPtr font);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateFont(HandleRef fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetLogFontW(HandleRef font, HandleRef graphics, [In, Out, MarshalAs(UnmanagedType.AsAny)] object lf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)] // 3 = Unicode
        internal static extern int GdipGetLogFontA(HandleRef font, HandleRef graphics, [In, Out, MarshalAs(UnmanagedType.AsAny)] object lf);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneFont(HandleRef font, out IntPtr cloneFont);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteFont", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteFont(HandleRef font);
        internal static int GdipDeleteFont(HandleRef font) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteFont(font);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFamily(HandleRef font, out IntPtr family);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontStyle(HandleRef font, out FontStyle style);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontSize(HandleRef font, out float size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontHeight(HandleRef font, HandleRef graphics, out float size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontHeightGivenDPI(HandleRef font, float dpi, out float size);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetFontUnit(HandleRef font, out GraphicsUnit unit);

        // Text

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect,
                                                  HandleRef stringFormat, HandleRef brush);
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMeasureString(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect,
                                                     HandleRef stringFormat, [In, Out] ref GPRECTF boundingBox, out int codepointsFitted, out int linesFilled);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipMeasureCharacterRanges(HandleRef graphics, string textString, int length, HandleRef font, ref GPRECTF layoutRect, HandleRef stringFormat, 
                                                           int characterCount, [In, Out] int[] region);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatMeasurableCharacterRanges(HandleRef format, int rangeCount, [In, Out] CharacterRange[] range);
                                                                      
        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateStringFormat(StringFormatFlags options, int language, out IntPtr format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipStringFormatGetGenericDefault(out IntPtr format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipStringFormatGetGenericTypographic(out IntPtr format);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteStringFormat", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteStringFormat(HandleRef format);
        internal static int GdipDeleteStringFormat(HandleRef format) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteStringFormat(format);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCloneStringFormat(HandleRef format, out IntPtr newFormat);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatFlags(HandleRef format, StringFormatFlags options);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatFlags(HandleRef format, out StringFormatFlags result);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatLineSpacingAmount(HandleRef format, out float amount);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatAlign(HandleRef format, StringAlignment align);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatAlign(HandleRef format, out StringAlignment align);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatLineAlign(HandleRef format, StringAlignment align);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatLineAlign(HandleRef format, out StringAlignment align);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatHotkeyPrefix(HandleRef format, HotkeyPrefix hotkeyPrefix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatHotkeyPrefix(HandleRef format, out HotkeyPrefix hotkeyPrefix);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatTabStops(HandleRef format, float firstTabOffset, int count, float[] tabStops);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatTabStops(HandleRef format, int count, out float firstTabOffset, [In, Out]float[] tabStops);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatTabStopCount(HandleRef format, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatMeasurableCharacterRangeCount(HandleRef format, out int count);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatTrimming(HandleRef format, StringTrimming  trimming);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatTrimming(HandleRef format, out StringTrimming trimming);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipSetStringFormatDigitSubstitution(HandleRef format, int langID, StringDigitSubstitute sds);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipGetStringFormatDigitSubstitution(HandleRef format, out int langID, out StringDigitSubstitute sds);

        //----------------------------------------------------------------------------------------                                                           
        // Cached Bitmap APIs
        //----------------------------------------------------------------------------------------

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipCreateCachedBitmap(HandleRef bitmap, HandleRef graphics, out IntPtr cachedBitmap);

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, EntryPoint="GdipDeleteCachedBitmap", CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        private static extern int IntGdipDeleteCachedBitmap(HandleRef cachedBitmap);
        internal static int GdipDeleteCachedBitmap(HandleRef cachedBitmap) {
            if (IsShutdown) return SafeNativeMethods.Ok;
            int result = IntGdipDeleteCachedBitmap(cachedBitmap);
            return result;
        }

        [DllImport(ExternDll.Gdiplus, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)] // 3 = Unicode
        internal static extern int GdipDrawCachedBitmap(HandleRef graphics, HandleRef cachedbitmap, int x, int y);

        //----------------------------------------------------------------------------------------                                                           
        // Status codes
        //----------------------------------------------------------------------------------------
        internal const int Ok = 0;
        internal const int GenericError = 1;
        internal const int InvalidParameter = 2;
        internal const int OutOfMemory = 3;
        internal const int ObjectBusy = 4;
        internal const int InsufficientBuffer = 5;
        internal const int NotImplemented = 6;
        internal const int Win32Error = 7;
        internal const int WrongState = 8;
        internal const int Aborted = 9;
        internal const int FileNotFound = 10; 
        internal const int ValueOverflow = 11;
        internal const int AccessDenied = 12;
        internal const int UnknownImageFormat = 13;
        internal const int FontFamilyNotFound = 14;
        internal const int FontStyleNotFound = 15;
        internal const int NotTrueTypeFont = 16;
        internal const int UnsupportedGdiplusVersion = 17;
        internal const int GdiplusNotInitialized = 18;
        internal const int PropertyNotFound = 19;
        internal const int PropertyNotSupported = 20;

        internal static Exception StatusException(int status) {

            Debug.Assert(status != Ok, "Throwing an exception for an 'Ok' return code");

            switch (status) {
                case GenericError:       return new ExternalException(SR.GetString(SR.GdiplusGenericError), E_FAIL);
                case InvalidParameter:   return new ArgumentException(SR.GetString(SR.GdiplusInvalidParameter));
                case OutOfMemory:        return new OutOfMemoryException(SR.GetString(SR.GdiplusOutOfMemory));
                case ObjectBusy:         return new InvalidOperationException(SR.GetString(SR.GdiplusObjectBusy));
                case InsufficientBuffer: return new OutOfMemoryException(SR.GetString(SR.GdiplusInsufficientBuffer));
                case NotImplemented:     return new NotImplementedException(SR.GetString(SR.GdiplusNotImplemented));
                case Win32Error:         return new ExternalException(SR.GetString(SR.GdiplusGenericError), E_FAIL);
                case WrongState:         return new InvalidOperationException(SR.GetString(SR.GdiplusWrongState));
                case Aborted:            return new ExternalException(SR.GetString(SR.GdiplusAborted), E_ABORT);
                case FileNotFound:       return new FileNotFoundException(SR.GetString(SR.GdiplusFileNotFound));
                case ValueOverflow:      return new OverflowException(SR.GetString(SR.GdiplusOverflow));
                case AccessDenied:       return new ExternalException(SR.GetString(SR.GdiplusAccessDenied), E_ACCESSDENIED);
                case UnknownImageFormat: return new ArgumentException(SR.GetString(SR.GdiplusUnknownImageFormat));
                case PropertyNotFound:   return new ArgumentException(SR.GetString(SR.GdiplusPropertyNotFoundError));
                case PropertyNotSupported:return new ArgumentException(SR.GetString(SR.GdiplusPropertyNotSupportedError));


                case FontFamilyNotFound:
                    Debug.Fail("We should be special casing FontFamilyNotFound so we can provide the font name");
                    return new ArgumentException(SR.GetString(SR.GdiplusFontFamilyNotFound, "?"));

                case FontStyleNotFound:
                    Debug.Fail("We should be special casing FontStyleNotFound so we can provide the font name");
                    return new ArgumentException(SR.GetString(SR.GdiplusFontStyleNotFound, "?", "?"));

                case NotTrueTypeFont:
                    Debug.Fail("We should be special casing NotTrueTypeFont so we can provide the font name");
                    return new ArgumentException(SR.GetString(SR.GdiplusNotTrueTypeFont_NoName));

                case UnsupportedGdiplusVersion:
                    return new ExternalException(SR.GetString(SR.GdiplusUnsupportedGdiplusVersion), E_FAIL);

                case GdiplusNotInitialized:
                    return new ExternalException(SR.GetString(SR.GdiplusNotInitialized), E_FAIL);
            }

            return new ExternalException(SR.GetString(SR.GdiplusUnknown), E_UNEXPECTED);
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert GpPointF* memory block to PointF[]
        //----------------------------------------------------------------------------------------
        internal static PointF[] ConvertGPPOINTFArrayF(IntPtr memory, int count) {
            if (memory == IntPtr.Zero)
                throw new ArgumentNullException("temporary memory allocation");

            PointF[] points = new PointF[count];

            int index;
            GPPOINTF pt = new GPPOINTF();

            int size = (int)Marshal.SizeOf(pt.GetType());

            for (index=0; index < count; index++) {
                pt = (GPPOINTF)  UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory+index*size), pt.GetType());
                points[index] = new PointF(pt.X, pt.Y);
            }

            return points;
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert GpPoint* memory block to Point[]
        //----------------------------------------------------------------------------------------
        internal static Point[] ConvertGPPOINTArray(IntPtr memory, int count) {
            if (memory == IntPtr.Zero)
                throw new ArgumentNullException("temporary memory allocation");

            Point[] points = new Point[count];

            int index;
            GPPOINT pt = new GPPOINT();

            int size = (int)Marshal.SizeOf(pt.GetType());

            for (index=0; index < count; index++) {
                pt = (GPPOINT)  UnsafeNativeMethods.PtrToStructure((IntPtr)((long)memory+index*size), pt.GetType());
                points[index] = new Point( (int)pt.X, (int) pt.Y);
            }

            return points;
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert PointF[] to native memory block GpPointF*
        //----------------------------------------------------------------------------------------
        internal static IntPtr ConvertPointToMemory(PointF[] points) {
            if (points == null)
                throw new ArgumentNullException("points");

            int index;

            GPPOINTF pt = new GPPOINTF();

            int size =  (int)Marshal.SizeOf(pt.GetType());
            int count = points.Length;

            IntPtr memory =  Marshal.AllocHGlobal(count*size);

            for (index=0; index<count; index++) {
                Marshal.StructureToPtr(new GPPOINTF(points[index]), (IntPtr)((long)memory+index*size), false);
            }

            return memory;
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert Point[] to native memory block GpPoint*
        //----------------------------------------------------------------------------------------
        internal static IntPtr ConvertPointToMemory(Point[] points) {
            if (points == null)
                throw new ArgumentNullException("points");

            int index;

            GPPOINT pt = new GPPOINT();

            int size =  (int)Marshal.SizeOf(pt.GetType());
            int count = points.Length;

            IntPtr memory =  Marshal.AllocHGlobal(count*size);

            for (index=0; index<count; index++) {
                Marshal.StructureToPtr(new GPPOINT(points[index]), (IntPtr)((long)memory+index*size), false);
            }

            return memory;
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert RectangleF[] to native memory block GpRectF*
        //----------------------------------------------------------------------------------------
        internal static IntPtr ConvertRectangleToMemory(RectangleF[] rect) {
            if (rect == null)
                throw new ArgumentNullException("rectangle");

            int index;

            GPRECTF rt = new GPRECTF();

            int size =  (int)Marshal.SizeOf(rt.GetType());
            int count = rect.Length;

            IntPtr memory =  Marshal.AllocHGlobal(count*size);

            for (index=0; index<count; index++) {
                Marshal.StructureToPtr(new GPRECTF(rect[index]), (IntPtr)((long)memory+index*size), false);
            }

            return memory;
        }

        //----------------------------------------------------------------------------------------                                                           
        // Helper function:  Convert Rectangle[] to native memory block GpRect*
        //----------------------------------------------------------------------------------------
        internal static IntPtr ConvertRectangleToMemory(Rectangle[] rect) {
            if (rect == null)
                throw new ArgumentNullException("rectangle");

            int index;

            GPRECT rt = new GPRECT();

            int size =  (int)Marshal.SizeOf(rt.GetType());
            int count = rect.Length;

            IntPtr memory =  Marshal.AllocHGlobal(count*size);

            for (index=0; index<count; index++) {
                Marshal.StructureToPtr(new GPRECT(rect[index]), (IntPtr)((long)memory+index*size), false);
            }

            return memory;
        }
        
        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));
        
        [StructLayout(LayoutKind.Sequential)]
        public class USEROBJECTFLAGS {
            public int fInherit = 0;
            public int fReserved = 0;
            public int dwFlags = 0;
        }

        public const int 
        UOI_FLAGS = 1,
        WSF_VISIBLE = 0x0001,
        E_UNEXPECTED = unchecked((int)0x8000FFFF),
        E_NOTIMPL = unchecked((int)0x80004001),
        E_OUTOFMEMORY = unchecked((int)0x8007000E),
        E_INVALIDARG = unchecked((int)0x80070057),
        E_NOINTERFACE = unchecked((int)0x80004002),
        E_POINTER = unchecked((int)0x80004003),
        E_HANDLE = unchecked((int)0x80070006),
        E_ABORT = unchecked((int)0x80004004),
        E_FAIL = unchecked((int)0x80004005),
        E_ACCESSDENIED = unchecked((int)0x80070005),
        PM_NOREMOVE = 0x0000,
        PM_REMOVE = 0x0001,
        PM_NOYIELD = 0x0002,
        GMEM_FIXED = 0x0000,
        GMEM_MOVEABLE = 0x0002,
        GMEM_NOCOMPACT = 0x0010,
        GMEM_NODISCARD = 0x0020,
        GMEM_ZEROINIT = 0x0040,
        GMEM_MODIFY = 0x0080,
        GMEM_DISCARDABLE = 0x0100,
        GMEM_NOT_BANKED = 0x1000,
        GMEM_SHARE = 0x2000,
        GMEM_DDESHARE = 0x2000,
        GMEM_NOTIFY = 0x4000,
        GMEM_LOWER = 0x1000,
        GMEM_VALID_FLAGS = 0x7F72,
        GMEM_INVALID_HANDLE = unchecked((int)0x8000),
        DM_UPDATE = 1,
        DM_COPY = 2,
        DM_PROMPT = 4,
        DM_MODIFY = 8,
        DM_IN_BUFFER = 8,
        DM_IN_PROMPT = 4,
        DM_OUT_BUFFER = 2,
        DM_OUT_DEFAULT = 1,
        DT_PLOTTER = 0,
        DT_RASDISPLAY = 1,
        DT_RASPRINTER = 2,
        DT_RASCAMERA = 3,
        DT_CHARSTREAM = 4,
        DT_METAFILE = 5,
        DT_DISPFILE = 6,
        TECHNOLOGY = 2,
        DC_FIELDS = 1,
        DC_PAPERS = 2,
        DC_PAPERSIZE = 3,
        DC_MINEXTENT = 4,
        DC_MAXEXTENT = 5,
        DC_BINS = 6,
        DC_DUPLEX = 7,
        DC_SIZE = 8,
        DC_EXTRA = 9,
        DC_VERSION = 10,
        DC_DRIVER = 11,
        DC_BINNAMES = 12,
        DC_ENUMRESOLUTIONS = 13,
        DC_FILEDEPENDENCIES = 14,
        DC_TRUETYPE = 15,
        DC_PAPERNAMES = 16,
        DC_ORIENTATION = 17,
        DC_COPIES = 18,
        PD_ALLPAGES = 0x00000000,
        PD_SELECTION = 0x00000001,
        PD_PAGENUMS = 0x00000002,
        PD_CURRENTPAGE = 0x00400000,
        PD_NOSELECTION = 0x00000004,
        PD_NOPAGENUMS = 0x00000008,
        PD_NOCURRENTPAGE = 0x00800000,
        PD_COLLATE = 0x00000010,
        PD_PRINTTOFILE = 0x00000020,
        PD_PRINTSETUP = 0x00000040,
        PD_NOWARNING = 0x00000080,
        PD_RETURNDC = 0x00000100,
        PD_RETURNIC = 0x00000200,
        PD_RETURNDEFAULT = 0x00000400,
        PD_SHOWHELP = 0x00000800,
        PD_ENABLEPRINTHOOK = 0x00001000,
        PD_ENABLESETUPHOOK = 0x00002000,
        PD_ENABLEPRINTTEMPLATE = 0x00004000,
        PD_ENABLESETUPTEMPLATE = 0x00008000,
        PD_ENABLEPRINTTEMPLATEHANDLE = 0x00010000,
        PD_ENABLESETUPTEMPLATEHANDLE = 0x00020000,
        PD_USEDEVMODECOPIES = 0x00040000,
        PD_USEDEVMODECOPIESANDCOLLATE = 0x00040000,
        PD_DISABLEPRINTTOFILE = 0x00080000,
        PD_HIDEPRINTTOFILE = 0x00100000,
        PD_NONETWORKBUTTON = 0x00200000,
        DI_MASK = 0x0001,
        DI_IMAGE = 0x0002,
        DI_NORMAL = 0x0003,
        DI_COMPAT = 0x0004,
        DI_DEFAULTSIZE = 0x0008,
        IDC_ARROW = 32512,
        IDC_IBEAM = 32513,
        IDC_WAIT = 32514,
        IDC_CROSS = 32515,
        IDC_UPARROW = 32516,
        IDC_SIZE = 32640,
        IDC_ICON = 32641,
        IDC_SIZENWSE = 32642,
        IDC_SIZENESW = 32643,
        IDC_SIZEWE = 32644,
        IDC_SIZENS = 32645,
        IDC_SIZEALL = 32646,
        IDC_NO = 32648,
        IDC_APPSTARTING = 32650,
        IDC_HELP = 32651,
        IMAGE_BITMAP = 0,
        IMAGE_ICON = 1,
        IMAGE_CURSOR = 2,
        IMAGE_ENHMETAFILE = 3,
        IDI_APPLICATION = 32512,
        IDI_HAND = 32513,
        IDI_QUESTION = 32514,
        IDI_EXCLAMATION = 32515,
        IDI_ASTERISK = 32516,
        IDI_WINLOGO = 32517,
        IDI_WARNING = 32515,
        IDI_ERROR = 32513,
        IDI_INFORMATION = 32516,
        SRCCOPY = 0x00CC0020,
        PLANES = 14,
        PS_SOLID = 0,
        PS_DASH = 1,
        PS_DOT = 2,
        PS_DASHDOT = 3,
        PS_DASHDOTDOT = 4,
        PS_NULL = 5,
        PS_INSIDEFRAME = 6,
        PS_USERSTYLE = 7,
        PS_ALTERNATE = 8,
        PS_STYLE_MASK = 0x0000000F,
        PS_ENDCAP_ROUND = 0x00000000,
        PS_ENDCAP_SQUARE = 0x00000100,
        PS_ENDCAP_FLAT = 0x00000200,
        PS_ENDCAP_MASK = 0x00000F00,
        PS_JOIN_ROUND = 0x00000000,
        PS_JOIN_BEVEL = 0x00001000,
        PS_JOIN_MITER = 0x00002000,
        PS_JOIN_MASK = 0x0000F000,
        PS_COSMETIC = 0x00000000,
        PS_GEOMETRIC = 0x00010000,
        PS_TYPE_MASK = 0x000F0000,
        BITSPIXEL = 12,
        ALTERNATE = 1,
        LOGPIXELSX = 88,
        LOGPIXELSY = 90,
        PHYSICALWIDTH = 110,
        PHYSICALHEIGHT = 111,
        PHYSICALOFFSETX = 112,
        PHYSICALOFFSETY = 113,
        WINDING = 2,
        VERTRES = 10,
        HORZRES = 8,
        DM_SPECVERSION = 0x0401,
        DM_ORIENTATION = 0x00000001,
        DM_PAPERSIZE = 0x00000002,
        DM_PAPERLENGTH = 0x00000004,
        DM_PAPERWIDTH = 0x00000008,
        DM_SCALE = 0x00000010,
        DM_COPIES = 0x00000100,
        DM_DEFAULTSOURCE = 0x00000200,
        DM_PRINTQUALITY = 0x00000400,
        DM_COLOR = 0x00000800,
        DM_DUPLEX = 0x00001000,
        DM_YRESOLUTION = 0x00002000,
        DM_TTOPTION = 0x00004000,
        DM_COLLATE = 0x00008000,
        DM_FORMNAME = 0x00010000,
        DM_LOGPIXELS = 0x00020000,
        DM_BITSPERPEL = 0x00040000,
        DM_PELSWIDTH = 0x00080000,
        DM_PELSHEIGHT = 0x00100000,
        DM_DISPLAYFLAGS = 0x00200000,
        DM_DISPLAYFREQUENCY = 0x00400000,
        DM_PANNINGWIDTH = 0x00800000,
        DM_PANNINGHEIGHT = 0x01000000,
        DM_ICMMETHOD = 0x02000000,
        DM_ICMINTENT = 0x04000000,
        DM_MEDIATYPE = 0x08000000,
        DM_DITHERTYPE = 0x10000000,
        DM_ICCMANUFACTURER = 0x20000000,
        DM_ICCMODEL = 0x40000000,
        DMORIENT_PORTRAIT = 1,
        DMORIENT_LANDSCAPE = 2,
        DMPAPER_LETTER = 1,
        DMPAPER_LETTERSMALL = 2,
        DMPAPER_TABLOID = 3,
        DMPAPER_LEDGER = 4,
        DMPAPER_LEGAL = 5,
        DMPAPER_STATEMENT = 6,
        DMPAPER_EXECUTIVE = 7,
        DMPAPER_A3 = 8,
        DMPAPER_A4 = 9,
        DMPAPER_A4SMALL = 10,
        DMPAPER_A5 = 11,
        DMPAPER_B4 = 12,
        DMPAPER_B5 = 13,
        DMPAPER_FOLIO = 14,
        DMPAPER_QUARTO = 15,
        DMPAPER_10X14 = 16,
        DMPAPER_11X17 = 17,
        DMPAPER_NOTE = 18,
        DMPAPER_ENV_9 = 19,
        DMPAPER_ENV_10 = 20,
        DMPAPER_ENV_11 = 21,
        DMPAPER_ENV_12 = 22,
        DMPAPER_ENV_14 = 23,
        DMPAPER_CSHEET = 24,
        DMPAPER_DSHEET = 25,
        DMPAPER_ESHEET = 26,
        DMPAPER_ENV_DL = 27,
        DMPAPER_ENV_C5 = 28,
        DMPAPER_ENV_C3 = 29,
        DMPAPER_ENV_C4 = 30,
        DMPAPER_ENV_C6 = 31,
        DMPAPER_ENV_C65 = 32,
        DMPAPER_ENV_B4 = 33,
        DMPAPER_ENV_B5 = 34,
        DMPAPER_ENV_B6 = 35,
        DMPAPER_ENV_ITALY = 36,
        DMPAPER_ENV_MONARCH = 37,
        DMPAPER_ENV_PERSONAL = 38,
        DMPAPER_FANFOLD_US = 39,
        DMPAPER_FANFOLD_STD_GERMAN = 40,
        DMPAPER_FANFOLD_LGL_GERMAN = 41,
        DMPAPER_ISO_B4 = 42,
        DMPAPER_JAPANESE_POSTCARD = 43,
        DMPAPER_9X11 = 44,
        DMPAPER_10X11 = 45,
        DMPAPER_15X11 = 46,
        DMPAPER_ENV_INVITE = 47,
        DMPAPER_RESERVED_48 = 48,
        DMPAPER_RESERVED_49 = 49,
        DMPAPER_LETTER_EXTRA = 50,
        DMPAPER_LEGAL_EXTRA = 51,
        DMPAPER_TABLOID_EXTRA = 52,
        DMPAPER_A4_EXTRA = 53,
        DMPAPER_LETTER_TRANSVERSE = 54,
        DMPAPER_A4_TRANSVERSE = 55,
        DMPAPER_LETTER_EXTRA_TRANSVERSE = 56,
        DMPAPER_A_PLUS = 57,
        DMPAPER_B_PLUS = 58,
        DMPAPER_LETTER_PLUS = 59,
        DMPAPER_A4_PLUS = 60,
        DMPAPER_A5_TRANSVERSE = 61,
        DMPAPER_B5_TRANSVERSE = 62,
        DMPAPER_A3_EXTRA = 63,
        DMPAPER_A5_EXTRA = 64,
        DMPAPER_B5_EXTRA = 65,
        DMPAPER_A2 = 66,
        DMPAPER_A3_TRANSVERSE = 67,
        DMPAPER_A3_EXTRA_TRANSVERSE = 68,

        // WINVER >= 0x0500
        DMPAPER_DBL_JAPANESE_POSTCARD = 69, /* Japanese Double Postcard 200 x 148 mm */
        DMPAPER_A6 =                  70,  /* A6 105 x 148 mm                 */
        DMPAPER_JENV_KAKU2 =          71,  /* Japanese Envelope Kaku #2       */
        DMPAPER_JENV_KAKU3 =          72,  /* Japanese Envelope Kaku #3       */
        DMPAPER_JENV_CHOU3 =          73,  /* Japanese Envelope Chou #3       */
        DMPAPER_JENV_CHOU4 =          74,  /* Japanese Envelope Chou #4       */
        DMPAPER_LETTER_ROTATED =      75,  /* Letter Rotated 11 x 8 1/2 11 in */
        DMPAPER_A3_ROTATED =          76,  /* A3 Rotated 420 x 297 mm         */
        DMPAPER_A4_ROTATED =          77,  /* A4 Rotated 297 x 210 mm         */
        DMPAPER_A5_ROTATED =          78,  /* A5 Rotated 210 x 148 mm         */
        DMPAPER_B4_JIS_ROTATED =      79,  /* B4 (JIS) Rotated 364 x 257 mm   */
        DMPAPER_B5_JIS_ROTATED =      80,  /* B5 (JIS) Rotated 257 x 182 mm   */
        DMPAPER_JAPANESE_POSTCARD_ROTATED = 81, /* Japanese Postcard Rotated 148 x 100 mm */
        DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82, /* Double Japanese Postcard Rotated 148 x 200 mm */
        DMPAPER_A6_ROTATED =          83,  /* A6 Rotated 148 x 105 mm         */
        DMPAPER_JENV_KAKU2_ROTATED =  84,  /* Japanese Envelope Kaku #2 Rotated */
        DMPAPER_JENV_KAKU3_ROTATED =  85,  /* Japanese Envelope Kaku #3 Rotated */
        DMPAPER_JENV_CHOU3_ROTATED =  86,  /* Japanese Envelope Chou #3 Rotated */
        DMPAPER_JENV_CHOU4_ROTATED =  87,  /* Japanese Envelope Chou #4 Rotated */
        DMPAPER_B6_JIS =              88,  /* B6 (JIS) 128 x 182 mm           */
        DMPAPER_B6_JIS_ROTATED =      89,  /* B6 (JIS) Rotated 182 x 128 mm   */
        DMPAPER_12X11 =               90,  /* 12 x 11 in                      */
        DMPAPER_JENV_YOU4 =           91,  /* Japanese Envelope You #4        */
        DMPAPER_JENV_YOU4_ROTATED =   92,  /* Japanese Envelope You #4 Rotated*/
        DMPAPER_P16K =                93,  /* PRC 16K 146 x 215 mm            */
        DMPAPER_P32K =                94,  /* PRC 32K 97 x 151 mm             */
        DMPAPER_P32KBIG =             95,  /* PRC 32K(Big) 97 x 151 mm        */
        DMPAPER_PENV_1 =              96,  /* PRC Envelope #1 102 x 165 mm    */
        DMPAPER_PENV_2 =              97,  /* PRC Envelope #2 102 x 176 mm    */
        DMPAPER_PENV_3 =              98,  /* PRC Envelope #3 125 x 176 mm    */
        DMPAPER_PENV_4 =              99,  /* PRC Envelope #4 110 x 208 mm    */
        DMPAPER_PENV_5 =              100, /* PRC Envelope #5 110 x 220 mm    */
        DMPAPER_PENV_6 =              101, /* PRC Envelope #6 120 x 230 mm    */
        DMPAPER_PENV_7 =              102, /* PRC Envelope #7 160 x 230 mm    */
        DMPAPER_PENV_8 =              103, /* PRC Envelope #8 120 x 309 mm    */
        DMPAPER_PENV_9 =              104, /* PRC Envelope #9 229 x 324 mm    */
        DMPAPER_PENV_10 =             105, /* PRC Envelope #10 324 x 458 mm   */
        DMPAPER_P16K_ROTATED =        106, /* PRC 16K Rotated                 */
        DMPAPER_P32K_ROTATED =        107, /* PRC 32K Rotated                 */
        DMPAPER_P32KBIG_ROTATED =     108, /* PRC 32K(Big) Rotated            */
        DMPAPER_PENV_1_ROTATED =      109, /* PRC Envelope #1 Rotated 165 x 102 mm */
        DMPAPER_PENV_2_ROTATED =      110, /* PRC Envelope #2 Rotated 176 x 102 mm */
        DMPAPER_PENV_3_ROTATED =      111, /* PRC Envelope #3 Rotated 176 x 125 mm */
        DMPAPER_PENV_4_ROTATED =      112, /* PRC Envelope #4 Rotated 208 x 110 mm */
        DMPAPER_PENV_5_ROTATED =      113, /* PRC Envelope #5 Rotated 220 x 110 mm */
        DMPAPER_PENV_6_ROTATED =      114, /* PRC Envelope #6 Rotated 230 x 120 mm */
        DMPAPER_PENV_7_ROTATED =      115, /* PRC Envelope #7 Rotated 230 x 160 mm */
        DMPAPER_PENV_8_ROTATED =      116, /* PRC Envelope #8 Rotated 309 x 120 mm */
        DMPAPER_PENV_9_ROTATED =      117, /* PRC Envelope #9 Rotated 324 x 229 mm */
        DMPAPER_PENV_10_ROTATED =     118, /* PRC Envelope #10 Rotated 458 x 324 mm */

        DMPAPER_LAST = DMPAPER_PENV_10_ROTATED,
        DMPAPER_USER = 256,

        DMBIN_UPPER = 1,
        DMBIN_ONLYONE = 1,
        DMBIN_LOWER = 2,
        DMBIN_MIDDLE = 3,
        DMBIN_MANUAL = 4,
        DMBIN_ENVELOPE = 5,
        DMBIN_ENVMANUAL = 6,
        DMBIN_AUTO = 7,
        DMBIN_TRACTOR = 8,
        DMBIN_SMALLFMT = 9,
        DMBIN_LARGEFMT = 10,
        DMBIN_LARGECAPACITY = 11,
        DMBIN_CASSETTE = 14,
        DMBIN_FORMSOURCE = 15,
        DMBIN_LAST = 15,
        DMBIN_USER = 256,
        DMRES_DRAFT = -1,
        DMRES_LOW = -2,
        DMRES_MEDIUM = -3,
        DMRES_HIGH = -4,
        DMCOLOR_MONOCHROME = 1,
        DMCOLOR_COLOR = 2,
        DMDUP_SIMPLEX = 1,
        DMDUP_VERTICAL = 2,
        DMDUP_HORIZONTAL = 3,
        DMTT_BITMAP = 1,
        DMTT_DOWNLOAD = 2,
        DMTT_SUBDEV = 3,
        DMTT_DOWNLOAD_OUTLINE = 4,
        DMCOLLATE_FALSE = 0,
        DMCOLLATE_TRUE = 1,
        DMDISPLAYFLAGS_TEXTMODE = 0x00000004,
        DMICMMETHOD_NONE = 1,
        DMICMMETHOD_SYSTEM = 2,
        DMICMMETHOD_DRIVER = 3,
        DMICMMETHOD_DEVICE = 4,
        DMICMMETHOD_USER = 256,
        DMICM_SATURATE = 1,
        DMICM_CONTRAST = 2,
        DMICM_COLORMETRIC = 3,
        DMICM_USER = 256,
        DMMEDIA_STANDARD = 1,
        DMMEDIA_TRANSPARENCY = 2,
        DMMEDIA_GLOSSY = 3,
        DMMEDIA_USER = 256,
        DMDITHER_NONE = 1,
        DMDITHER_COARSE = 2,
        DMDITHER_FINE = 3,
        DMDITHER_LINEART = 4,
        DMDITHER_GRAYSCALE = 5,
        DMDITHER_USER = 256,
        PRINTER_ENUM_DEFAULT = 0x00000001,
        PRINTER_ENUM_LOCAL = 0x00000002,
        PRINTER_ENUM_CONNECTIONS = 0x00000004,
        PRINTER_ENUM_FAVORITE = 0x00000004,
        PRINTER_ENUM_NAME = 0x00000008,
        PRINTER_ENUM_REMOTE = 0x00000010,
        PRINTER_ENUM_SHARED = 0x00000020,
        PRINTER_ENUM_NETWORK = 0x00000040,
        PRINTER_ENUM_EXPAND = 0x00004000,
        PRINTER_ENUM_CONTAINER = 0x00008000,
        PRINTER_ENUM_ICONMASK = 0x00ff0000,
        PRINTER_ENUM_ICON1 = 0x00010000,
        PRINTER_ENUM_ICON2 = 0x00020000,
        PRINTER_ENUM_ICON3 = 0x00040000,
        PRINTER_ENUM_ICON4 = 0x00080000,
        PRINTER_ENUM_ICON5 = 0x00100000,
        PRINTER_ENUM_ICON6 = 0x00200000,
        PRINTER_ENUM_ICON7 = 0x00400000,
        PRINTER_ENUM_ICON8 = 0x00800000,
        DC_BINADJUST = 19,
        DC_EMF_COMPLIANT = 20,
        DC_DATATYPE_PRODUCED = 21,
        DC_COLLATE = 22,
        DCTT_BITMAP = 0x0000001,
        DCTT_DOWNLOAD = 0x0000002,
        DCTT_SUBDEV = 0x0000004,
        DCTT_DOWNLOAD_OUTLINE = 0x0000008,
        DCBA_FACEUPNONE = 0x0000,
        DCBA_FACEUPCENTER = 0x0001,
        DCBA_FACEUPLEFT = 0x0002,
        DCBA_FACEUPRIGHT = 0x0003,
        DCBA_FACEDOWNNONE = 0x0100,
        DCBA_FACEDOWNCENTER = 0x0101,
        DCBA_FACEDOWNLEFT = 0x0102,
        DCBA_FACEDOWNRIGHT = 0x0103,
        SM_CXSCREEN = 0,
        SM_CYSCREEN = 1,
        SM_CXVSCROLL = 2,
        SM_CYHSCROLL = 3,
        SM_CYCAPTION = 4,
        SM_CXBORDER = 5,
        SM_CYBORDER = 6,
        SM_CXDLGFRAME = 7,
        SM_CYDLGFRAME = 8,
        SM_CYVTHUMB = 9,
        SM_CXHTHUMB = 10,
        SM_CXICON = 11,
        SM_CYICON = 12,
        SM_CXCURSOR = 13,
        SM_CYCURSOR = 14,
        SM_CYMENU = 15,
        SM_CXFULLSCREEN = 16,
        SM_CYFULLSCREEN = 17,
        SM_CYKANJIWINDOW = 18,
        SM_MOUSEPRESENT = 19,
        SM_CYVSCROLL = 20,
        SM_CXHSCROLL = 21,
        SM_DEBUG = 22,
        SM_SWAPBUTTON = 23,
        SM_RESERVED1 = 24,
        SM_RESERVED2 = 25,
        SM_RESERVED3 = 26,
        SM_RESERVED4 = 27,
        SM_CXMIN = 28,
        SM_CYMIN = 29,
        SM_CXSIZE = 30,
        SM_CYSIZE = 31,
        SM_CXFRAME = 32,
        SM_CYFRAME = 33,
        SM_CXMINTRACK = 34,
        SM_CYMINTRACK = 35,
        SM_CXDOUBLECLK = 36,
        SM_CYDOUBLECLK = 37,
        SM_CXICONSPACING = 38,
        SM_CYICONSPACING = 39,
        SM_MENUDROPALIGNMENT = 40,
        SM_PENWINDOWS = 41,
        SM_DBCSENABLED = 42,
        SM_CMOUSEBUTTONS = 43,
        SM_CXFIXEDFRAME = 7,
        SM_CYFIXEDFRAME = 8,
        SM_CXSIZEFRAME = 32,
        SM_CYSIZEFRAME = 33,
        SM_SECURE = 44,
        SM_CXEDGE = 45,
        SM_CYEDGE = 46,
        SM_CXMINSPACING = 47,
        SM_CYMINSPACING = 48,
        SM_CXSMICON = 49,
        SM_CYSMICON = 50,
        SM_CYSMCAPTION = 51,
        SM_CXSMSIZE = 52,
        SM_CYSMSIZE = 53,
        SM_CXMENUSIZE = 54,
        SM_CYMENUSIZE = 55,
        SM_ARRANGE = 56,
        SM_CXMINIMIZED = 57,
        SM_CYMINIMIZED = 58,
        SM_CXMAXTRACK = 59,
        SM_CYMAXTRACK = 60,
        SM_CXMAXIMIZED = 61,
        SM_CYMAXIMIZED = 62,
        SM_NETWORK = 63,
        SM_CLEANBOOT = 67,
        SM_CXDRAG = 68,
        SM_CYDRAG = 69,
        SM_SHOWSOUNDS = 70,
        SM_CXMENUCHECK = 71,
        SM_CYMENUCHECK = 72,
        SM_SLOWMACHINE = 73,
        SM_MIDEASTENABLED = 74,
        SM_MOUSEWHEELPRESENT = 75,
        SM_XVIRTUALSCREEN = 76,
        SM_YVIRTUALSCREEN = 77,
        SM_CXVIRTUALSCREEN = 78,
        SM_CYVIRTUALSCREEN = 79,
        SM_CMONITORS = 80,
        SM_SAMEDISPLAYFORMAT = 81,
        SM_CMETRICS = 83;

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalFree(HandleRef handle);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int StartDoc(HandleRef hDC, DOCINFO lpDocInfo);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int StartPage(HandleRef hDC);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int EndPage(HandleRef hDC);
        //      public static extern int SetAbortProc(m_hDC, (ABORTPROC)lpfn);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int AbortDoc(HandleRef hDC);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int EndDoc(HandleRef hDC);

        [DllImport(ExternDll.Comdlg32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool PrintDlg([In, Out] PRINTDLG lppd);
        
        [DllImport(ExternDll.Comdlg32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int PageSetupDlg([In, Out] PAGESETUPDLG lppsd);

        [DllImport(ExternDll.Winspool, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr /*DEVMODE*/ pDevMode);

        [DllImport(ExternDll.Winspool, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr /*DEVMODE*/ pDevModeOutput, HandleRef /*DEVMODE*/ pDevModeInput, int fMode);

        [DllImport(ExternDll.Winspool, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetPrinter(HandleRef hPrinter, int level, HandleRef pPrinter, int cbBuf, int[] pcbNeeded);

        [DllImport(ExternDll.Winspool, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool OpenPrinter(string pPrinterName, HandleRef [] phPrinter, HandleRef pDefault);
        [DllImport(ExternDll.Winspool, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int ClosePrinter(HandleRef hPrinter);

        [DllImport(ExternDll.Winspool, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int EnumPrinters(int flags, string name, int level, IntPtr pPrinterEnum/*buffer*/,
                                              int cbBuf, out int pcbNeeded, out int pcReturned);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalLock(HandleRef handle);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr /*HDC*/ ResetDC(HandleRef hDC, HandleRef /*DEVMODE*/ lpDevMode);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GlobalUnlock(HandleRef handle);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteDC", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern bool IntDeleteDC(HandleRef hDC);
        public static bool DeleteDC(HandleRef hDC) {
            // GDI or HDC handle?  If from bitmap, GDI, but if printer, HDC?
            HandleCollector.Remove((IntPtr)hDC, CommonHandles.GDI);
            return IntDeleteDC(hDC);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalAlloc(int uFlags, int dwBytes);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static int GetLastError();
        
        public const int ERROR_ACCESS_DENIED = 5;
        public const int ERROR_PROC_NOT_FOUND = 127;


        [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
        public class ENHMETAHEADER {
            public int  iType;
            public int  nSize = 40; // ndirect.DllLib.sizeOf( this )
            // rclBounds was a by-value RECTL structure
            public int  rclBounds_left;
            public int  rclBounds_top;
            public int  rclBounds_right;
            public int  rclBounds_bottom;
            // rclFrame was a by-value RECTL structure
            public int  rclFrame_left;
            public int  rclFrame_top;
            public int  rclFrame_right;
            public int  rclFrame_bottom;
            public int  dSignature;
            public int  nVersion;
            public int  nBytes;
            public int  nRecords;
            public short nHandles;
            public short sReserved;
            public int  nDescription;
            public int  offDescription;
            public int  nPalEntries;
            // szlDevice was a by-value SIZE structure
            public int  szlDevice_cx;
            public int  szlDevice_cy;
            // szlMillimeters was a by-value SIZE structure
            public int  szlMillimeters_cx;
            public int  szlMillimeters_cy;
            public int  cbPixelFormat;
            public int  offPixelFormat;
            public int  bOpenGL;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class DOCINFO {
                public int cbSize = 20; //ndirect.DllLib.sizeOf(this);
                public String lpszDocName;
                public String lpszOutput;
                public String lpszDatatype;
                public int fwType;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto, Pack=1)]
        public class PRINTDLG {
            public   int lStructSize;
            public   IntPtr hwndOwner;
            public   IntPtr hDevMode;
            public   IntPtr hDevNames;
            public   IntPtr hDC;
            public   int Flags;
            public   short nFromPage;
            public   short nToPage;
            public   short nMinPage;
            public   short nMaxPage;
            public   short nCopies;
            public   IntPtr hInstance;
            public   IntPtr lCustData;
            public   WndProc lpfnPrintHook;
            public   WndProc lpfnSetupHook;
            public   string lpPrintTemplateName;
            public   string lpSetupTemplateName;
            public   IntPtr hPrintTemplate;
            public   IntPtr hSetupTemplate;
        }

        public delegate int WndProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        
        [System.Runtime.InteropServices.ComVisible(false)]
        public enum StructFormat {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class PAGESETUPDLG {
            public int      lStructSize; 
            public IntPtr   hwndOwner; 
            public IntPtr   hDevMode; 
            public IntPtr   hDevNames; 
            public int      Flags; 

            //POINT           ptPaperSize; 
            public int      paperSizeX;
            public int      paperSizeY;

            // RECT            rtMinMargin; 
            public int minMarginLeft;
            public int minMarginTop;
            public int minMarginRight;
            public int minMarginBottom;

            // RECT            rtMargin; 
            public int marginLeft;
            public int marginTop;
            public int marginRight;
            public int marginBottom;

            public IntPtr   hInstance; 
            public IntPtr   lCustData; 
            public WndProc  lpfnPageSetupHook; 
            public WndProc  lpfnPagePaintHook; 
            public string   lpPageSetupTemplateName; 
            public IntPtr   hPageSetupTemplate; 
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public RECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static RECT FromXYWH(int x, int y, int width, int height) {
                return new RECT(x,
                                y,
                                x + width,
                                y + height);
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public class COMRECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public COMRECT() {
            }

            public COMRECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static COMRECT FromXYWH(int x, int y, int width, int height) {
                return new COMRECT(x,
                                y,
                                x + width,
                                y + height);
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }

            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr   hwnd;
            public int      message;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public int      time;
            // pt was a by-value POINT structure
            public int      pt_x;
            public int      pt_y;
        }
        [StructLayout(LayoutKind.Sequential)]
        public class ICONINFO {
                public int fIcon;
                public int xHotspot;
                public int yHotspot;
                public IntPtr hbmMask;
                public IntPtr hbmColor;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class BITMAP {
                public int bmType;
                public int bmWidth;
                public int bmHeight;
                public int bmWidthBytes;
                public short bmPlanes;
                public short bmBitsPixel;
                public IntPtr bmBits;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class DIBSECTION {
            public BITMAP dsBm;
            public BITMAPINFOHEADER dsBmih;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst=3)]
            public int[] dsBitfields;
            public IntPtr dshSection;
            public int dsOffset;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class BITMAPINFOHEADER {
                public int      biSize = 40;    // ndirect.DllLib.sizeOf( this );
                public int      biWidth;
                public int      biHeight;
                public short    biPlanes;
                public short    biBitCount;
                public int      biCompression;
                public int      biSizeImage;
                public int      biXPelsPerMeter;
                public int      biYPelsPerMeter;
                public int      biClrUsed;
                public int      biClrImportant;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class LOGPEN {
            public int  lopnStyle;
            // lopnWidth was a by-value POINT structure
            public int  lopnWidth_x;
            public int  lopnWidth_y;
            public int  lopnColor;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class LOGBRUSH {
                public int lbStyle;
                public int lbColor;
                public int lbHatch;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class LOGFONT {
                public int lfHeight;
                public int lfWidth;
                public int lfEscapement;
                public int lfOrientation;
                public int lfWeight;
                public byte lfItalic;
                public byte lfUnderline;
                public byte lfStrikeOut;
                public byte lfCharSet;
                public byte lfOutPrecision;
                public byte lfClipPrecision;
                public byte lfQuality;
                public byte lfPitchAndFamily;
                [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValTStr, SizeConst=32)]
                public string   lfFaceName;

                public override string ToString() {
                    return 
                        "lfHeight=" + lfHeight + ", " +
                        "lfWidth=" + lfWidth + ", " +
                        "lfEscapement=" + lfEscapement + ", " +
                        "lfOrientation=" + lfOrientation + ", " +
                        "lfWeight=" + lfWeight + ", " +
                        "lfItalic=" + lfItalic + ", " +
                        "lfUnderline=" + lfUnderline + ", " +
                        "lfStrikeOut=" + lfStrikeOut + ", " +
                        "lfCharSet=" + lfCharSet + ", " +
                        "lfOutPrecision=" + lfOutPrecision + ", " +
                        "lfClipPrecision=" + lfClipPrecision + ", " +
                        "lfQuality=" + lfQuality + ", " +
                        "lfPitchAndFamily=" + lfPitchAndFamily + ", " +
                          "lfFaceName=" +   lfFaceName;
                }
        }
        
        [StructLayout(LayoutKind.Sequential, Pack=2)]
        public struct ICONDIR {
            public short idReserved;
            public short idType;
            public short idCount;
            public ICONDIRENTRY idEntries;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct ICONDIRENTRY {
            public byte bWidth;
            public byte bHeight;
            public byte bColorCount;
            public byte bReserved;
            public short wPlanes;
            public short wBitCount;
            public int dwBytesInRes;
            public int dwImageOffset;
        }
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class PICTDESC
        {
            internal int cbSizeOfStruct;
            public int picType;
            internal IntPtr union1;
            internal int union2;
            internal int union3;

            public static PICTDESC CreateBitmapPICTDESC(IntPtr hbitmap, IntPtr hpal) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 16;
                pictdesc.picType = Ole.PICTYPE_BITMAP;
                pictdesc.union1 = hbitmap;
                pictdesc.union2 = (int)(((long)hpal) & 0xffffffff);
                pictdesc.union3 = (int)(((long)hpal) >> 32);
                return pictdesc;
            }

            public static PICTDESC CreateIconPICTDESC(IntPtr hicon) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 12;
                pictdesc.picType = Ole.PICTYPE_ICON;
                pictdesc.union1 = hicon;
                return pictdesc;
            }

            public static PICTDESC CreateEnhMetafilePICTDESC(IntPtr hEMF) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 12;
                pictdesc.picType = Ole.PICTYPE_ENHMETAFILE;
                pictdesc.union1 = hEMF;
                return pictdesc;
            }

            public static PICTDESC CreateWinMetafilePICTDESC(IntPtr hmetafile, int x, int y) {
                PICTDESC pictdesc = new PICTDESC();
                pictdesc.cbSizeOfStruct = 20;
                pictdesc.picType = Ole.PICTYPE_METAFILE;
                pictdesc.union1 = hmetafile;
                pictdesc.union2 = x;
                pictdesc.union3 = y;
                return pictdesc;
            }

            public virtual IntPtr GetHandle() {
                return union1;
            }

            public virtual IntPtr GetHPal() {
                Debug.Assert((union2 >= 0) && (union3 >= 0));

                long u2 = union2;
                long u3 = union3;
                if (picType == Ole.PICTYPE_BITMAP)
                    return (IntPtr)(u2 | (u3 << 32));
                    // REVIEW: This is what it used to be. Had to change it since the compiler did not like
                    //         the casts and the bitwise OR.
                    // return (IntPtr)(union2 | (((long)union3) << 32));
                else
                    return IntPtr.Zero;
            }
        }
        [System.Runtime.InteropServices.ComVisible(false)]
        public class Ole {
            /*
             * Pictypes
             */
            public const int PICTYPE_UNINITIALIZED = -1;
            public const int PICTYPE_NONE          =  0;
            public const int PICTYPE_BITMAP        =  1;
            public const int PICTYPE_METAFILE      =  2;
            public const int PICTYPE_ICON          =  3;
            public const int PICTYPE_ENHMETAFILE   =  4;

            public const int STATFLAG_DEFAULT = 0;
            public const int STATFLAG_NONAME = 1;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class DEVMODE {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValTStr, SizeConst=32)]
            public string dmDeviceName;
            public short dmSpecVersion;
            public short dmDriverVersion;
            public short dmSize;
            public short dmDriverExtra;
            public int dmFields;
            public short dmOrientation;
            public short dmPaperSize;
            public short dmPaperLength;
            public short dmPaperWidth;
            public short dmScale;
            public short dmCopies;
            public short dmDefaultSource;
            public short dmPrintQuality;
            public short dmColor;
            public short dmDuplex;
            public short dmYResolution;
            public short dmTTOption;
            public short dmCollate;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValTStr, SizeConst=32)]
            public string dmFormName;
            public short dmLogPixels;
            public int dmBitsPerPel;
            public int dmPelsWidth;
            public int dmPelsHeight;
            public int dmDisplayFlags;
            public int dmDisplayFrequency;
            public int dmICMMethod;
            public int dmICMIntent;
            public int dmMediaType;
            public int dmDitherType;
            public int dmICCManufacturer;
            public int dmICCModel;
            public int dmPanningWidth;
            public int dmPanningHeight;


            public override string ToString() {
                return "[DEVMODE: "
                + "dmDeviceName=" + dmDeviceName
                + ", dmSpecVersion=" + dmSpecVersion
                + ", dmDriverVersion=" + dmDriverVersion
                + ", dmSize=" + dmSize
                + ", dmDriverExtra=" + dmDriverExtra
                + ", dmFields=" + dmFields
                + ", dmOrientation=" + dmOrientation
                + ", dmPaperSize=" + dmPaperSize
                + ", dmPaperLength=" + dmPaperLength
                + ", dmPaperWidth=" + dmPaperWidth
                + ", dmScale=" + dmScale
                + ", dmCopies=" + dmCopies
                + ", dmDefaultSource=" + dmDefaultSource
                + ", dmPrintQuality=" + dmPrintQuality
                + ", dmColor=" + dmColor
                + ", dmDuplex=" + dmDuplex
                + ", dmYResolution=" + dmYResolution
                + ", dmTTOption=" + dmTTOption
                + ", dmCollate=" + dmCollate
                + ", dmFormName=" + dmFormName
                + ", dmLogPixels=" + dmLogPixels
                + ", dmBitsPerPel=" + dmBitsPerPel
                + ", dmPelsWidth=" + dmPelsWidth
                + ", dmPelsHeight=" + dmPelsHeight
                + ", dmDisplayFlags=" + dmDisplayFlags
                + ", dmDisplayFrequency=" + dmDisplayFrequency
                + ", dmICMMethod=" + dmICMMethod
                + ", dmICMIntent=" + dmICMIntent
                + ", dmMediaType=" + dmMediaType
                + ", dmDitherType=" + dmDitherType
                + ", dmICCManufacturer=" + dmICCManufacturer
                + ", dmICCModel=" + dmICCModel
                + ", dmPanningWidth=" + dmPanningWidth
                + ", dmPanningHeight=" + dmPanningHeight
                + "]";
            }
        }

        public sealed class CommonHandles {
            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Accelerator"]/*' />
            /// <devdoc>
            ///     Handle type for accelerator tables.
            /// </devdoc>
            public static readonly int Accelerator  = HandleCollector.RegisterType("Accelerator", 80, 50);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Cursor"]/*' />
            /// <devdoc>
            ///     handle type for cursors.
            /// </devdoc>
            public static readonly int Cursor       = HandleCollector.RegisterType("Cursor", 20, 500);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.EMF"]/*' />
            /// <devdoc>
            ///     Handle type for enhanced metafiles.
            /// </devdoc>
            public static readonly int EMF          = HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Find"]/*' />
            /// <devdoc>
            ///     Handle type for file find handles.
            /// </devdoc>
            public static readonly int Find         = HandleCollector.RegisterType("Find", 0, 1000);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.GDI"]/*' />
            /// <devdoc>
            ///     Handle type for GDI objects.
            /// </devdoc>
            public static readonly int GDI          = HandleCollector.RegisterType("GDI", 90, 50);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.HDC"]/*' />
            /// <devdoc>
            ///     Handle type for HDC's that count against the Win98 limit of five DC's.  HDC's
            ///     which are not scarce, such as HDC's for bitmaps, are counted as GDIHANDLE's.
            /// </devdoc>
            public static readonly int HDC          = HandleCollector.RegisterType("HDC", 100, 2); // wait for 2 dc's before collecting

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Icon"]/*' />
            /// <devdoc>
            ///     Handle type for icons.
            /// </devdoc>
            public static readonly int Icon         = HandleCollector.RegisterType("Icon", 20, 500);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Kernel"]/*' />
            /// <devdoc>
            ///     Handle type for kernel objects.
            /// </devdoc>
            public static readonly int Kernel       = HandleCollector.RegisterType("Kernel", 0, 1000);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Menu"]/*' />
            /// <devdoc>
            ///     Handle type for files.
            /// </devdoc>
            public static readonly int Menu         = HandleCollector.RegisterType("Menu", 30, 1000);

            /// <include file='doc\SafeNativeMethods.uex' path='docs/doc[@for="SafeNativeMethods.CommonHandles.Window"]/*' />
            /// <devdoc>
            ///     Handle type for windows.
            /// </devdoc>
            public static readonly int Window       = HandleCollector.RegisterType("Window", 5, 1000);
        }
        
        [System.Runtime.InteropServices.ComVisible(false)]
        public class StreamConsts {
            public const   int LOCK_WRITE = 0x1;
            public const   int LOCK_EXCLUSIVE = 0x2;
            public const   int LOCK_ONLYONCE = 0x4;
            public const   int STATFLAG_DEFAULT = 0x0;
            public const   int STATFLAG_NONAME = 0x1;
            public const   int STATFLAG_NOOPEN = 0x2;
            public const   int STGC_DEFAULT = 0x0;
            public const   int STGC_OVERWRITE = 0x1;
            public const   int STGC_ONLYIFCURRENT = 0x2;
            public const   int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 0x4;
            public const   int STREAM_SEEK_SET = 0x0;
            public const   int STREAM_SEEK_CUR = 0x1;
            public const   int STREAM_SEEK_END = 0x2;
        }
        [DllImport(ExternDll.Gdi32)]
        public static extern int DeleteObject(HandleRef hObject);

        [DllImport(ExternDll.User32, EntryPoint="CreateIconIndirect")]
        private static extern IntPtr IntCreateIconIndirect(SafeNativeMethods.ICONINFO piconinfo);
        public static IntPtr CreateIconIndirect(SafeNativeMethods.ICONINFO piconinfo) {
            return HandleCollector.Add(IntCreateIconIndirect(piconinfo), SafeNativeMethods.CommonHandles.Icon);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public unsafe static extern IntPtr CreateIconFromResourceEx(byte * pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);
        
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr LoadIcon(HandleRef hInst, int iconId);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="DestroyIcon", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern bool IntDestroyIcon(HandleRef hIcon);
        public static bool DestroyIcon(HandleRef hIcon) {
            HandleCollector.Remove((IntPtr)hIcon, SafeNativeMethods.CommonHandles.Icon);
            return IntDestroyIcon(hIcon);
        }
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr CreateFontIndirect(SafeNativeMethods.LOGFONT lf);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="CopyImage", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);
        public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags) {
            return HandleCollector.Add(IntCopyImage(hImage, uType, cxDesired, cyDesired, fuFlags), SafeNativeMethods.CommonHandles.GDI);
        }
        
        // GetObject stuff
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] SafeNativeMethods.BITMAP bm);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] SafeNativeMethods.DIBSECTION ds);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] SafeNativeMethods.LOGPEN lp);
        public static int GetObject(HandleRef hObject, SafeNativeMethods.LOGPEN lp) {
            return GetObject(hObject, System.Runtime.InteropServices.Marshal.SizeOf(typeof(SafeNativeMethods.LOGPEN)), lp);
        }
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] SafeNativeMethods.LOGBRUSH lb);
        public static int GetObject(HandleRef hObject, SafeNativeMethods.LOGBRUSH lb) {
            return GetObject(hObject, System.Runtime.InteropServices.Marshal.SizeOf(typeof(SafeNativeMethods.LOGBRUSH)), lb);
        }
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] SafeNativeMethods.LOGFONT lf);
        public static int GetObject(HandleRef hObject, SafeNativeMethods.LOGFONT lp) {
            return GetObject(hObject, System.Runtime.InteropServices.Marshal.SizeOf(typeof(SafeNativeMethods.LOGFONT)), lp);
        }
        //HPALETTE
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, ref int nEntries);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, int[] nEntries);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetIconInfo(HandleRef hIcon, [In, Out] SafeNativeMethods.ICONINFO info);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetSysColor(int nIndex);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawIcon(HandleRef hDC, int x, int y, HandleRef hIcon);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SafeIntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern IPicture OleLoadPicture(UnsafeNativeMethods.IStream pStream, int lSize, bool fRunmode, ref Guid refiid);
        
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern IPicture OleLoadPictureEx(UnsafeNativeMethods.IStream pStream, int lSize, bool fRunmode, ref Guid refiid, int width, int height, int dwFlags);
        
        
        #if CUSTOM_MARSHALING_ISTREAM
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern IPicture OleLoadPictureEx(
                                                        [return: MarshalAs(UnmanagedType.CustomMarshaler,MarshalType="StreamToIStreamMarshaler")] Stream pStream, 
                                                        int lSize, bool fRunmode, ref Guid refiid, int width, int height, int dwFlags);
                                                        
                                                        
        #endif
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern IPicture OleCreatePictureIndirect(SafeNativeMethods.PICTDESC pictdesc, [In]ref Guid refiid, bool fOwn);
    
        [
            ComImport(), 
            Guid("7BF80980-BF32-101A-8BBB-00AA00300CAB"), 
            InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
            
        ]
        public interface IPicture {

            [SuppressUnmanagedCodeSecurity()]
             IntPtr GetHandle();

            [SuppressUnmanagedCodeSecurity()]
             IntPtr GetHPal();

            [return: MarshalAs(UnmanagedType.I2)]
            [SuppressUnmanagedCodeSecurity()]
             short GetPictureType();

            [SuppressUnmanagedCodeSecurity()]
             int GetWidth();

            [SuppressUnmanagedCodeSecurity()]
             int GetHeight();

            [SuppressUnmanagedCodeSecurity()]
             void Render();

            [SuppressUnmanagedCodeSecurity()]
             void SetHPal(
                    [In] 
                     IntPtr phpal);

            [SuppressUnmanagedCodeSecurity()]
             IntPtr GetCurDC();

            [SuppressUnmanagedCodeSecurity()]
             void SelectPicture(
                    [In] 
                     IntPtr hdcIn,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     int[] phdcOut,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     int[] phbmpOut);

            [return: MarshalAs(UnmanagedType.Bool)]
            [SuppressUnmanagedCodeSecurity()]
             bool GetKeepOriginalFormat();

            [SuppressUnmanagedCodeSecurity()]
             void SetKeepOriginalFormat(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool pfkeep);

            [SuppressUnmanagedCodeSecurity()]
             void PictureChanged();

            [SuppressUnmanagedCodeSecurity()]
             [System.Runtime.InteropServices.PreserveSig]
             int SaveAsFile(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                     UnsafeNativeMethods.IStream pstm,
                    [In] 
                     int fSaveMemCopy,
                    [Out]
                     out int pcbSize);

            [SuppressUnmanagedCodeSecurity()]
             int GetAttributes();

            [SuppressUnmanagedCodeSecurity()]
             void SetHdc(
                    [In] 
                     IntPtr hdc);


        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imageformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImageFormat.cs
*
* Abstract:
*
*   Image format constant types
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.ComponentModel;

    /**
     * Image format constants
     */
    /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat"]/*' />
    /// <devdoc>
    ///    Specifies the format of the image.
    /// </devdoc>
    [TypeConverterAttribute(typeof(ImageFormatConverter))]
    public sealed class ImageFormat {
        // Format IDs
        // private static ImageFormat undefined = new ImageFormat(new Guid("{b96b3ca9-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat memoryBMP = new ImageFormat(new Guid("{b96b3caa-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat bmp       = new ImageFormat(new Guid("{b96b3cab-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat emf       = new ImageFormat(new Guid("{b96b3cac-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat wmf       = new ImageFormat(new Guid("{b96b3cad-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat jpeg      = new ImageFormat(new Guid("{b96b3cae-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat png       = new ImageFormat(new Guid("{b96b3caf-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat gif       = new ImageFormat(new Guid("{b96b3cb0-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat tiff      = new ImageFormat(new Guid("{b96b3cb1-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat exif      = new ImageFormat(new Guid("{b96b3cb2-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat photoCD   = new ImageFormat(new Guid("{b96b3cb3-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat flashPIX  = new ImageFormat(new Guid("{b96b3cb4-0728-11d3-9d7b-0000f81ef32e}"));
        private static ImageFormat icon      = new ImageFormat(new Guid("{b96b3cb5-0728-11d3-9d7b-0000f81ef32e}"));


        private Guid guid;

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.ImageFormat"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.ImageFormat'/> class with the specified GUID.
        /// </devdoc>
        public ImageFormat(Guid guid) {
            this.guid = guid;
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Guid"]/*' />
        /// <devdoc>
        ///    Specifies a global unique identifier (GUID)
        ///    that represents this <see cref='System.Drawing.Imaging.ImageFormat'/>.
        /// </devdoc>
        public Guid Guid {
            get { return guid;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.MemoryBmp"]/*' />
        /// <devdoc>
        ///    Specifies a memory bitmap image format.
        /// </devdoc>
        public static ImageFormat MemoryBmp {
            get { return memoryBMP;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Bmp"]/*' />
        /// <devdoc>
        ///    Specifies the bitmap image format.
        /// </devdoc>
        public static ImageFormat Bmp {
            get { return bmp;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Emf"]/*' />
        /// <devdoc>
        ///    Specifies the enhanced Windows metafile
        ///    image format.
        /// </devdoc>
        public static ImageFormat Emf {
            get { return emf;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Wmf"]/*' />
        /// <devdoc>
        ///    Specifies the Windows metafile image
        ///    format.
        /// </devdoc>
        public static ImageFormat Wmf {
            get { return wmf;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Gif"]/*' />
        /// <devdoc>
        ///    Specifies the GIF image format.
        /// </devdoc>
        public static ImageFormat Gif {
            get { return gif;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Jpeg"]/*' />
        /// <devdoc>
        ///    Specifies the JPEG image format.
        /// </devdoc>
        public static ImageFormat Jpeg {
            get { return jpeg;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Png"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the W3C PNG image format.
        ///    </para>
        /// </devdoc>
        public static ImageFormat Png {
            get { return png;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Tiff"]/*' />
        /// <devdoc>
        ///    Specifies the Tag Image File
        ///    Format (TIFF) image format.
        /// </devdoc>
        public static ImageFormat Tiff {
            get { return tiff;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Exif"]/*' />
        /// <devdoc>
        ///    Specifies the Exchangable Image Format
        ///    (EXIF).
        /// </devdoc>
        public static ImageFormat Exif {
            get { return exif;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the Windows icon image format.
        ///    </para>
        /// </devdoc>
        public static ImageFormat Icon {
            get { return icon;}
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.Equals"]/*' />
        /// <devdoc>
        ///    Returns a value indicating whether the
        ///    specified object is an <see cref='System.Drawing.Imaging.ImageFormat'/> equivalent to this <see cref='System.Drawing.Imaging.ImageFormat'/>.
        /// </devdoc>
        public override bool Equals(object o) {
            ImageFormat format = o as ImageFormat;
            if (format == null)
                return false;
            return this.guid == format.guid;
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a hash code.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return this.guid.GetHashCode();
        }
        
        // Find any random encoder which supports this format
        internal ImageCodecInfo FindEncoder() {
            ImageCodecInfo[] codecs = ImageCodecInfo.GetImageEncoders();
            foreach (ImageCodecInfo codec in codecs) {
                if (codec.FormatID.Equals(this.guid))
                    return codec;
            }
            return null;
        }

        /// <include file='doc\ImageFormat.uex' path='docs/doc[@for="ImageFormat.ToString"]/*' />
        /// <devdoc>
        ///    Converts this <see cref='System.Drawing.Imaging.ImageFormat'/> to a human-readable string.
        /// </devdoc>
        public override string ToString() {
            if (this == memoryBMP) return "MemoryBMP";
            if (this == bmp) return "Bmp";
            if (this == emf) return "Emf";
            if (this == wmf) return "Wmf";
            if (this == gif) return "Gif";
            if (this == jpeg) return "Jpeg";
            if (this == png) return "Png";
            if (this == tiff) return "Tiff";
            if (this == exif) return "Exif";
            if (this == icon) return "Icon";
            return "[ImageFormat: " + guid + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\isystemeventtracker.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISystemEventTracker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Internal {

    using System.Diagnostics;

    using System;

    // See SystemColorTracker
    internal interface ISystemColorTracker {
        void OnSystemColorChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\imageformatconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageFormatConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing {

    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;
    using System.Drawing.Imaging;

    /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter"]/*' />
    /// <devdoc>
    ///      ImageFormatConverter is a class that can be used to convert
    ///      colors from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class ImageFormatConverter : TypeConverter {
        private StandardValuesCollection values;
        
        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.ImageFormatConverter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ImageFormatConverter() {
        }
        
        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {
                string text = ((string)value).Trim();

                PropertyInfo[] props = GetProperties();
                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    if (string.Compare(prop.Name, text, true, CultureInfo.InvariantCulture) == 0) {
                        object[] tempIndex = null;
                        return prop.GetValue(null, tempIndex);
                    }
                }
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (value is ImageFormat) {
                PropertyInfo targetProp = null;
                
                PropertyInfo[] props = GetProperties();
                foreach(PropertyInfo p in props) {
                    if (p.GetValue(null, null).Equals(value)) {
                        targetProp = p;
                        break;
                    }
                }
                
                if (targetProp != null) {
                    if (destinationType == typeof(string)) {
                        return targetProp.Name;
                    }
                    else if (destinationType == typeof(InstanceDescriptor)) {
                        return new InstanceDescriptor(targetProp, null);
                    }
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the properties for the available image formats.
        /// </devdoc>
        private PropertyInfo[] GetProperties() {
            return typeof(ImageFormat).GetProperties(BindingFlags.Static | BindingFlags.Public);
        }

        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                ArrayList list = new ArrayList();
                PropertyInfo[] props = GetProperties();
                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    object[] tempIndex = null;
                    Debug.Assert(prop.GetValue(null, tempIndex) != null, "Property " + prop.Name + " returned NULL");
                    list.Add(prop.GetValue(null, tempIndex));
                }

                values = new StandardValuesCollection(list.ToArray());
            }

            return values;
        }

        /// <include file='doc\ImageFormatConverter.uex' path='docs/doc[@for="ImageFormatConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\installedfontcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstalledFontCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   font.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ font objects
*
* Revision History:
*
*   3/16/2000 yungt [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\InstalledFontCollection.uex' path='docs/doc[@for="InstalledFontCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the fonts installed on the
    ///       system.
    ///    </para>
    /// </devdoc>
    public sealed class InstalledFontCollection : FontCollection {

        /// <include file='doc\InstalledFontCollection.uex' path='docs/doc[@for="InstalledFontCollection.InstalledFontCollection"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Text.InstalledFontCollection'/> class.
        /// </devdoc>
        public InstalledFontCollection() {

            nativeFontCollection = IntPtr.Zero;

            int status = SafeNativeMethods.GdipNewInstalledFontCollection(out nativeFontCollection);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\lineargradientbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinearGradientBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   LinearGradientBrush.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ LinearGradient objects
*
* Revision History:
*
*   01/11/1999 davidx
*       Code review.
*
*   12/15/1998 ericvan
*       Created it.
*
*   3/14/2000 ericvan
*       Renamed LineGradientBrush to LinearGradientBrush
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.Drawing.Internal;

    /**
     * Represent a LinearGradient brush object
     */
    /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Encapsulates a <see cref='System.Drawing.Brush'/> with a linear gradient.
    ///    </para>
    /// </devdoc>
    public sealed class LinearGradientBrush : Brush {
    
        internal LinearGradientBrush() { nativeBrush = IntPtr.Zero; }
        private bool interpolationColorsWasSet = false;

        /**
         * Create a new rectangle gradient brush object
         */
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the specified points and
        ///    colors.
        /// </devdoc>
        public LinearGradientBrush(PointF point1, PointF point2,
                                   Color color1, Color color2)
        {
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateLineBrush(new GPPOINTF(point1),
                                                     new GPPOINTF(point2),
                                                     color1.ToArgb(),
                                                     color2.ToArgb(),
                                                     (int)WrapMode.Tile,
                                                     out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points and colors.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(Point point1, Point point2,
                                   Color color1, Color color2)
        {
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateLineBrushI(new GPPOINT(point1),
                                                      new GPPOINT(point2),
                                                      color1.ToArgb(),
                                                      color2.ToArgb(),
                                                      (int)WrapMode.Tile,
                                                      out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with
        ///       the specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(RectangleF rect, Color color1, Color color2,
                                   LinearGradientMode linearGradientMode)
        {   
            //validate the LinearGradientMode enum
            if (!Enum.IsDefined(typeof(LinearGradientMode), linearGradientMode)) {
                throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
            }

            //validate the rect
            if (rect.Width == 0.0 || rect.Height == 0.0) {
                throw new ArgumentException(SR.GetString(SR.GdiplusInvalidRectangle, rect.ToString()));
            }

            IntPtr brush = IntPtr.Zero;

            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCreateLineBrushFromRect(ref gprectf,
                                                             color1.ToArgb(),
                                                             color2.ToArgb(),
                                                             (int) linearGradientMode,
                                                             (int)WrapMode.Tile,
                                                             out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(Rectangle rect, Color color1, Color color2,
                                   LinearGradientMode linearGradientMode)
        {
            //validate the LinearGradientMode enum
            if (!Enum.IsDefined(typeof(LinearGradientMode), linearGradientMode)) {
                throw new InvalidEnumArgumentException("linearGradientMode", (int)linearGradientMode, typeof(LinearGradientMode));
            }

            //validate the rect
            if (rect.Width == 0 || rect.Height == 0) {
                throw new ArgumentException(SR.GetString(SR.GdiplusInvalidRectangle, rect.ToString()));
            }

            IntPtr brush = IntPtr.Zero;

            GPRECT gpRect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCreateLineBrushFromRectI(ref gpRect,
                                                              color1.ToArgb(),
                                                              color2.ToArgb(),
                                                              (int) linearGradientMode,
                                                              (int)WrapMode.Tile,
                                                              out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(RectangleF rect, Color color1, Color color2,
                                 float angle)
            : this(rect, color1, color2, angle, false) {}

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(RectangleF rect, Color color1, Color color2,
                                 float angle, bool isAngleScaleable)
        {
            IntPtr brush = IntPtr.Zero;

            //validate the rect
            if (rect.Width == 0.0 || rect.Height == 0.0) {
                throw new ArgumentException(SR.GetString(SR.GdiplusInvalidRectangle, rect.ToString()));
            }

            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCreateLineBrushFromRectWithAngle(ref gprectf,
                                                                      color1.ToArgb(),
                                                                      color2.ToArgb(),
                                                                      angle,
                                                                      isAngleScaleable,
                                                                      (int)WrapMode.Tile,
                                                                      out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(Rectangle rect, Color color1, Color color2,
                                   float angle)
            : this(rect, color1, color2, angle, false) {
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearGradientBrush7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Encapsulates a new instance of the <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> class with the
        ///       specified points, colors, and orientation.
        ///    </para>
        /// </devdoc>
        public LinearGradientBrush(Rectangle rect, Color color1, Color color2,
                                 float angle, bool isAngleScaleable)
        {
            IntPtr brush = IntPtr.Zero;

            //validate the rect
            if (rect.Width == 0 || rect.Height == 0) {
                throw new ArgumentException(SR.GetString(SR.GdiplusInvalidRectangle, rect.ToString()));
            }

            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCreateLineBrushFromRectWithAngleI(ref gprect,
                                                                       color1.ToArgb(),
                                                                       color2.ToArgb(),
                                                                       angle,
                                                                       isAngleScaleable,
                                                                       (int)WrapMode.Tile,
                                                                       out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/>.
        /// </devdoc>
        public override object Clone() {
            IntPtr cloneBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBrush(new HandleRef(this, nativeBrush), out cloneBrush);
     
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new LinearGradientBrush(cloneBrush);
        }
        
        /**
         * Get/set colors
         */

        private void _SetLinearColors(Color color1, Color color2)
        {
            int status = SafeNativeMethods.GdipSetLineColors(new HandleRef(this, nativeBrush), 
                                                   color1.ToArgb(), 
                                                   color2.ToArgb());

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private Color[] _GetLinearColors()
        {
            int[] colors =
            new int[]
            {
                0,
                0
            };

            int status = SafeNativeMethods.GdipGetLineColors(new HandleRef(this, nativeBrush), colors);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            Color[] lineColor = new Color[2];

            lineColor[0] = Color.FromArgb(colors[0]);
            lineColor[1] = Color.FromArgb(colors[1]);

            return lineColor;
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.LinearColors"]/*' />
        /// <devdoc>
        ///    Gets or sets the starting and ending colors of the
        ///    gradient.
        /// </devdoc>
        public Color[] LinearColors
        {
            get { return _GetLinearColors();}
            set { _SetLinearColors(value[0], value[1]);}
        }

        /**
         * Get source rectangle
         */
        private RectangleF _GetRectangle() {
            GPRECTF rect = new GPRECTF();

            int status = SafeNativeMethods.GdipGetLineRect(new HandleRef(this, nativeBrush), ref rect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
     
            return rect.ToRectangleF();
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.Rectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a rectangular region that defines the
        ///       starting and ending points of the gradient.
        ///    </para>
        /// </devdoc>
        public RectangleF Rectangle
        {
            get { return _GetRectangle(); }
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.GammaCorrection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether
        ///       gamma correction is enabled for this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/>.
        ///    </para>
        /// </devdoc>
        public bool GammaCorrection
        {
            get {
                bool useGammaCorrection;
                
                int status = SafeNativeMethods.GdipGetLineGammaCorrection(new HandleRef(this, nativeBrush), 
                                                       out useGammaCorrection); 
                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
                    
                return useGammaCorrection; 
            }
            set {
                int status = SafeNativeMethods.GdipSetLineGammaCorrection(new HandleRef(this, nativeBrush),
                                                        value);
                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }
         
        /**
         * Get/set blend factors
         *
         * @notes If the blendFactors.Length = 1, then it's treated
         *  as the falloff parameter. Otherwise, it's the array
         *  of blend factors.
         */

        private Blend _GetBlend() {
            // Figure out the size of blend factor array
            int retval = 0;
            int status = SafeNativeMethods.GdipGetLineBlendCount(new HandleRef(this, nativeBrush), out retval);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            if (retval <= 0)
                return null;
                
            // Allocate temporary native memory buffer
            int count = retval;
            IntPtr factors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            // Retrieve horizontal blend factors
            status = SafeNativeMethods.GdipGetLineBlend(new HandleRef(this, nativeBrush), factors, positions, count);
            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(factors);
                Marshal.FreeHGlobal(positions);
                throw SafeNativeMethods.StatusException(status);
            }

            // Return the result in a managed array
            Blend blend = new Blend(count);

            Marshal.Copy(factors, blend.Factors, 0, count);
            Marshal.Copy(positions, blend.Positions, 0, count);

            Marshal.FreeHGlobal(factors);
            Marshal.FreeHGlobal(positions);
        
            return blend;
        }

        private void _SetBlend(Blend blend) {
            // Allocate temporary native memory buffer
            // and copy input blend factors into it.

            int count = blend.Factors.Length;
            IntPtr factors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            Marshal.Copy(blend.Factors, 0, factors, count);
            Marshal.Copy(blend.Positions, 0, positions, count);

            // Set blend factors

            int status = SafeNativeMethods.GdipSetLineBlend(new HandleRef(this, nativeBrush), new HandleRef(null, factors), new HandleRef(null, positions), count);

            Marshal.FreeHGlobal(factors);
            Marshal.FreeHGlobal(positions);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.Blend"]/*' />
        /// <devdoc>
        ///    Gets or sets a <see cref='System.Drawing.Drawing2D.Blend'/> that specifies
        ///    positions and factors that define a custom falloff for the gradient.
        /// </devdoc>
        public Blend Blend
        {
            get { return _GetBlend();}
            set { _SetBlend(value);}
        }

        /*
         * SigmaBlend & LinearBlend not yet implemented
         */

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.SetSigmaBellShape"]/*' />
        /// <devdoc>
        ///    Creates a gradient falloff based on a
        ///    bell-shaped curve.
        /// </devdoc>
        public void SetSigmaBellShape(float focus)
        {
            SetSigmaBellShape(focus, (float)1.0);
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.SetSigmaBellShape1"]/*' />
        /// <devdoc>
        ///    Creates a gradient falloff based on a
        ///    bell-shaped curve.
        /// </devdoc>
        public void SetSigmaBellShape(float focus, float scale)
        {
            int status = SafeNativeMethods.GdipSetLineSigmaBlend(new HandleRef(this, nativeBrush), focus, scale);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.SetBlendTriangularShape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a triangular gradient.
        ///    </para>
        /// </devdoc>
        public void SetBlendTriangularShape(float focus)
        {
            SetBlendTriangularShape(focus, (float)1.0);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.SetBlendTriangularShape1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a triangular gradient.
        ///    </para>
        /// </devdoc>
        public void SetBlendTriangularShape(float focus, float scale)
        {
            int status = SafeNativeMethods.GdipSetLineLinearBlend(new HandleRef(this, nativeBrush), focus, scale);
            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /*
         * Preset Color Blend
         */

        private ColorBlend _GetInterpolationColors() {
            if (!interpolationColorsWasSet) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsColorBlendNotSet),""));
            }
            // Figure out the size of blend factor array

            int retval = 0;
            int status = SafeNativeMethods.GdipGetLinePresetBlendCount(new HandleRef(this, nativeBrush), out retval);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // Allocate temporary native memory buffer

            int count = retval;
            IntPtr colors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            // Retrieve horizontal blend factors

            status = SafeNativeMethods.GdipGetLinePresetBlend(new HandleRef(this, nativeBrush), colors, positions, count);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(colors);
                Marshal.FreeHGlobal(positions);
                throw SafeNativeMethods.StatusException(status);
            }

            // Return the result in a managed array

            ColorBlend blend = new ColorBlend(count);

            int[] argb = new int[count];
            Marshal.Copy(colors, argb, 0, count);
            Marshal.Copy(positions, blend.Positions, 0, count);

            // copy ARGB values into Color array of ColorBlend
            blend.Colors = new Color[argb.Length];

            for (int i=0; i<argb.Length; i++)
                blend.Colors[i] = Color.FromArgb(argb[i]);

            Marshal.FreeHGlobal(colors);
            Marshal.FreeHGlobal(positions);
     
            return blend;
        }

        private void _SetInterpolationColors(ColorBlend blend) {
            interpolationColorsWasSet = true;
            
            // Validate the ColorBlend object.
            if (blend == null) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsInvalidColorBlendObject), ""));
            }
            else if (blend.Colors.Length < 2) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsInvalidColorBlendObject), 
                                            SR.GetString(SR.InterpolationColorsLength)));
            }
            else if (blend.Colors.Length != blend.Positions.Length) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsInvalidColorBlendObject), 
                                            SR.GetString(SR.InterpolationColorsLengthsDiffer)));
            }
            else if (blend.Positions[0] != 0.0f) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsInvalidColorBlendObject),
                                            SR.GetString(SR.InterpolationColorsInvalidStartPosition)));
            }
            else if (blend.Positions[blend.Positions.Length - 1] != 1.0f) {
                throw new ArgumentException(SR.GetString(SR.InterpolationColorsCommon,
                                            SR.GetString(SR.InterpolationColorsInvalidColorBlendObject),
                                            SR.GetString(SR.InterpolationColorsInvalidEndPosition)));
            }


            // Allocate temporary native memory buffer
            // and copy input blend factors into it.

            int count = blend.Colors.Length;
            IntPtr colors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            int[] argbs = new int[count];
            for (int i=0; i<count; i++)
                argbs[i] = blend.Colors[i].ToArgb();

            Marshal.Copy(argbs, 0, colors, count);
            Marshal.Copy(blend.Positions, 0, positions, count);

            // Set blend factors

            int status = SafeNativeMethods.GdipSetLinePresetBlend(new HandleRef(this, nativeBrush), new HandleRef(null, colors), new HandleRef(null, positions), count);

            Marshal.FreeHGlobal(colors);
            Marshal.FreeHGlobal(positions);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.InterpolationColors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.ColorBlend'/> that defines a multi-color linear
        ///       gradient.
        ///    </para>
        /// </devdoc>
        public ColorBlend InterpolationColors
        {
            get { return _GetInterpolationColors();}
            set { _SetInterpolationColors(value);}
        }

        /**
         * Set/get brush wrapping mode
         */
        private void _SetWrapMode(WrapMode wrapMode) {
            int status = SafeNativeMethods.GdipSetLineWrapMode(new HandleRef(this, nativeBrush), (int) wrapMode);
     
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private WrapMode _GetWrapMode() {
            int mode = 0;

            int status = SafeNativeMethods.GdipGetLineWrapMode(new HandleRef(this, nativeBrush), out mode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return (WrapMode) mode;
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.WrapMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.WrapMode'/> that indicates the wrap mode for this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/>.
        ///    </para>
        /// </devdoc>
        public WrapMode WrapMode
        {
            get {
                return _GetWrapMode();
            }
            set {
                //validate the WrapMode enum
                if (!Enum.IsDefined(typeof(WrapMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
                }

                _SetWrapMode(value);
            }
        }

        /**
         * Set/get brush transform
         */
        private void _SetTransform(Matrix matrix) {
            if (matrix == null)
                throw new ArgumentNullException("matrix");
            
            int status = SafeNativeMethods.GdipSetLineTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private Matrix _GetTransform() {
            Matrix matrix = new Matrix();
            
            // NOTE: new Matrix() will throw an exception if matrix == null.
            
            int status = SafeNativeMethods.GdipGetLineTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        
            return matrix;
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.Transform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.Matrix'/> that defines a local geometrical transform for
        ///       this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/>.
        ///    </para>
        /// </devdoc>
        public Matrix Transform
        {
            get { return _GetTransform();}
            set { _SetTransform(value);}
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.ResetTransform"]/*' />
        /// <devdoc>
        ///    Resets the <see cref='System.Drawing.Drawing2D.LinearGradientBrush.Transform'/> property to identity.
        /// </devdoc>
        public void ResetTransform() {
            int status = SafeNativeMethods.GdipResetLineTransform(new HandleRef(this, nativeBrush));
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.MultiplyTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix) 
        {
            MultiplyTransform(matrix, MatrixOrder.Prepend);
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.MultiplyTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix, MatrixOrder order) 
        {
            if (matrix == null) {
                throw new ArgumentNullException("matrix");
            }

            int status = SafeNativeMethods.GdipMultiplyLineTransform(new HandleRef(this, nativeBrush),
                                                new HandleRef(matrix, matrix.nativeMatrix),
                                                order);
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }


        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.TranslateTransform"]/*' />
        /// <devdoc>
        ///    Translates the local geometrical transform
        ///    by the specified dimmensions. This method prepends the translation to the
        ///    transform.
        /// </devdoc>
        public void TranslateTransform(float dx, float dy)
        { TranslateTransform(dx, dy, MatrixOrder.Prepend); }
                
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.TranslateTransform1"]/*' />
        /// <devdoc>
        ///    Translates the local geometrical transform
        ///    by the specified dimmensions in the specified order.
        /// </devdoc>
        public void TranslateTransform(float dx, float dy, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipTranslateLineTransform(new HandleRef(this, nativeBrush),
                                                            dx, 
                                                            dy,
                                                            order);
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.ScaleTransform"]/*' />
        /// <devdoc>
        ///    Scales the local geometric transform by the
        ///    specified amounts. This method prepends the scaling matrix to the transform.
        /// </devdoc>
        public void ScaleTransform(float sx, float sy)
        { ScaleTransform(sx, sy, MatrixOrder.Prepend); }
                
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.ScaleTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the
        ///       specified amounts in the specified order.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipScaleLineTransform(new HandleRef(this, nativeBrush),
                                                        sx, 
                                                        sy,
                                                        order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.RotateTransform"]/*' />
        /// <devdoc>
        ///    Rotates the local geometric transform by the
        ///    specified amount. This method prepends the rotation to the transform.
        /// </devdoc>
        public void RotateTransform(float angle)
        { RotateTransform(angle, MatrixOrder.Prepend); }
                
        /// <include file='doc\LinearGradientBrush.uex' path='docs/doc[@for="LinearGradientBrush.RotateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified
        ///       amount in the specified order.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipRotateLineTransform(new HandleRef(this, nativeBrush),
                                                         angle,
                                                         order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        private LinearGradientBrush(IntPtr nativeBrush) {
            SetNativeBrush(nativeBrush);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\interpolationmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="InterpolationMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   InterpolationMode.cs
*
* Abstract:
*
*   Inteprolation modes for filtering
*
* Revision History:
*
*   2/2/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Various wrap modes for brushes
     */
    /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode"]/*' />
    /// <devdoc>
    ///    Specifies how data is interpolated between
    ///    endpoints.
    /// </devdoc>
    public enum InterpolationMode
    {
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.Invalid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Equivalent to <see cref='System.Drawing.Drawing2D.QualityMode.Invalid'/>
        ///    </para>
        /// </devdoc>
        Invalid = QualityMode.Invalid,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.Default"]/*' />
        /// <devdoc>
        ///    Specifies default mode.
        /// </devdoc>
        Default = QualityMode.Default,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.Low"]/*' />
        /// <devdoc>
        ///    Specifies low quality.
        /// </devdoc>
        Low = QualityMode.Low,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.High"]/*' />
        /// <devdoc>
        ///    Specifies high quality.
        /// </devdoc>
        High = QualityMode.High,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.Bilinear"]/*' />
        /// <devdoc>
        ///    Specifies bilinear interpolation.
        /// </devdoc>
        Bilinear,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.Bicubic"]/*' />
        /// <devdoc>
        ///    Specifies bicubic interpolation.
        /// </devdoc>
        Bicubic,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.NearestNeighbor"]/*' />
        /// <devdoc>
        ///    Specifies nearest neighbor interpolation.
        /// </devdoc>
        NearestNeighbor,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.HighQualityBilinear"]/*' />
        /// <devdoc>
        ///    Specifies high qulaity bilenear
        ///    interpolation.
        /// </devdoc>
        HighQualityBilinear,
        /// <include file='doc\InterpolationMode.uex' path='docs/doc[@for="InterpolationMode.HighQualityBicubic"]/*' />
        /// <devdoc>
        ///    Specifies high quality bicubic
        ///    interpolation.
        /// </devdoc>
        HighQualityBicubic
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\linecap.cs ===
//------------------------------------------------------------------------------
// <copyright file="LineCap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   LineCap.cs
*
* Abstract:
*
*   Line cap constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Line cap constants
     */
    /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap"]/*' />
    /// <devdoc>
    ///    Specifies the available cap
    ///    styles with which a <see cref='System.Drawing.Pen'/> can end a line.
    /// </devdoc>
    public enum LineCap
    {
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.Flat"]/*' />
        /// <devdoc>
        ///    Specifies a flat line cap.
        /// </devdoc>
        Flat             = 0,
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.Square"]/*' />
        /// <devdoc>
        ///    Specifies a square line cap.
        /// </devdoc>
        Square           = 1,
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.Round"]/*' />
        /// <devdoc>
        ///    Specifies a round line cap.
        /// </devdoc>
        Round            = 2,
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.Triangle"]/*' />
        /// <devdoc>
        ///    Specifies a triangular line cap.
        /// </devdoc>
        Triangle         = 3,

        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.NoAnchor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoAnchor         = 0x10, // corresponds to flat cap
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.SquareAnchor"]/*' />
        /// <devdoc>
        ///    Specifies no line cap.
        /// </devdoc>
        SquareAnchor     = 0x11, // corresponds to square cap
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.RoundAnchor"]/*' />
        /// <devdoc>
        ///    Specifies a round anchor cap.
        /// </devdoc>
        RoundAnchor      = 0x12, // corresponds to round cap
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.DiamondAnchor"]/*' />
        /// <devdoc>
        ///    Specifies a diamond anchor cap.
        /// </devdoc>
        DiamondAnchor    = 0x13, // corresponds to triangle cap
        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.ArrowAnchor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies an arrow-shaped anchor cap.
        ///    </para>
        /// </devdoc>
        ArrowAnchor      = 0x14, // no correspondence

        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a custom line cap.
        ///    </para>
        /// </devdoc>
        Custom           = 0xff, // custom cap

        /// <include file='doc\LineCap.uex' path='docs/doc[@for="LineCap.AnchorMask"]/*' />
        /// <devdoc>
        ///    Specifies a mask used to check whether a
        ///    line cap is an anchor cap.
        /// </devdoc>
        AnchorMask       = 0xf0  // mask to check for anchor or not.
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\lineargradientmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="LinearGradientMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   LinearGradientMode.cs
*
* Abstract:
*
*   Linear gradient constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Linear Gradient mode constants
     */
    /// <include file='doc\LinearGradientMode.uex' path='docs/doc[@for="LinearGradientMode"]/*' />
    /// <devdoc>
    ///    Specifies the direction of a linear
    ///    gradient.
    /// </devdoc>
    public enum LinearGradientMode
    {
        /// <include file='doc\LinearGradientMode.uex' path='docs/doc[@for="LinearGradientMode.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a gradient from left to right.
        ///    </para>
        /// </devdoc>
        Horizontal = 0,
        /// <include file='doc\LinearGradientMode.uex' path='docs/doc[@for="LinearGradientMode.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a gradient from top to bottom.
        ///    </para>
        /// </devdoc>
        Vertical = 1,
        /// <include file='doc\LinearGradientMode.uex' path='docs/doc[@for="LinearGradientMode.ForwardDiagonal"]/*' />
        /// <devdoc>
        ///    Specifies a gradient from upper-left to
        ///    lower-right.
        /// </devdoc>
        ForwardDiagonal = 2,
        /// <include file='doc\LinearGradientMode.uex' path='docs/doc[@for="LinearGradientMode.BackwardDiagonal"]/*' />
        /// <devdoc>
        ///    Specifies a gradient from upper-right to
        ///    lower-left.
        /// </devdoc>
        BackwardDiagonal = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\matrix.cs ===
//------------------------------------------------------------------------------
// <copyright file="Matrix.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Matrix.cs
*
* Abstract:
*
*   GDI+ affine transformation matrix
*
* Revision History:
*
*   01/11/1999 ericvan
*       Code review changes.
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Drawing;    
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Internal;

    /**
     * Represent a Matrix object
     */
    /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix"]/*' />
    /// <devdoc>
    ///    Encapsulates a 3 X 3 affine matrix that
    ///    represents a geometric transform.
    /// </devdoc>
    public sealed class Matrix : MarshalByRefObject, IDisposable {
        internal IntPtr nativeMatrix;

        /*
         * Create a new identity matrix
         */

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Matrix"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.Matrix'/> class.
        /// </devdoc>
        public Matrix() {
            IntPtr matrix = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMatrix(out matrix);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativeMatrix = matrix;
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Matrix1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initialized a new instance of the <see cref='System.Drawing.Drawing2D.Matrix'/> class with the specified
        ///       elements.
        ///    </para>
        /// </devdoc>
        public Matrix(float m11,
                      float m12,
                      float m21,
                      float m22,
                      float dx,
                      float dy) {
            IntPtr matrix = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMatrix2(m11, m12, m21, m22, dx, dy,
                                                   out matrix);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativeMatrix = matrix;
        }

        // float version
        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Matrix2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.Matrix'/> class to the geometrical transform
        ///       defined by the specified rectangle and array of points.
        ///    </para>
        /// </devdoc>
        public Matrix(RectangleF rect, PointF[] plgpts) {
            if (plgpts == null)
                throw new ArgumentNullException("plgpts");
            if (plgpts.Length != 3)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(plgpts);

            IntPtr matrix = IntPtr.Zero;

            GPRECTF gprectf = new GPRECTF(rect);
            int status = SafeNativeMethods.GdipCreateMatrix3(ref gprectf, new HandleRef(null, buf), out matrix);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativeMatrix = matrix;

            Marshal.FreeHGlobal(buf);
        }

        // int version
        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Matrix3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.Matrix'/> class to the geometrical transform
        ///       defined by the specified rectangle and array of points.
        ///    </para>
        /// </devdoc>
        public Matrix(Rectangle rect, Point[] plgpts) {
            if (plgpts == null)
                throw new ArgumentNullException("plgpts");
            if (plgpts.Length != 3)
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(plgpts);

            IntPtr matrix = IntPtr.Zero;

            GPRECT gprect = new GPRECT(rect);
            int status = SafeNativeMethods.GdipCreateMatrix3I(ref gprect, new HandleRef(null, buf), out matrix);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            this.nativeMatrix = matrix;

            Marshal.FreeHGlobal(buf);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up resources allocated for this
        /// <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            if (nativeMatrix != IntPtr.Zero) {
                SafeNativeMethods.GdipDeleteMatrix(new HandleRef(this, nativeMatrix));
                nativeMatrix = IntPtr.Zero;
            }
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up resources allocated for this
        /// <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        ~Matrix() {
            Dispose(false);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public Matrix Clone() {
            IntPtr cloneMatrix = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneMatrix(new HandleRef(this, nativeMatrix), out cloneMatrix);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new Matrix(cloneMatrix);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Elements"]/*' />
        /// <devdoc>
        ///    Gets an array of floating-point values that
        ///    represent the elements of this <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public float[] Elements
        {
            get {
                float[] m;

                IntPtr buf = Marshal.AllocHGlobal(6 * 8); // 6 elements x 8 bytes (float)

                int status = SafeNativeMethods.GdipGetMatrixElements(new HandleRef(this, nativeMatrix), buf);

                if (status != SafeNativeMethods.Ok) {
                    Marshal.FreeHGlobal(buf);
                    throw SafeNativeMethods.StatusException(status);
                }

                m = new float[6];

                Marshal.Copy(buf, m, 0, 6);

                Marshal.FreeHGlobal(buf);

                return m;
            }
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.OffsetX"]/*' />
        /// <devdoc>
        ///    Gets the x translation value (the dx value,
        ///    or the element in the third row and first column) of this <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public float OffsetX  {
            get { return Elements[4];}
        } 

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.OffsetY"]/*' />
        /// <devdoc>
        ///    Gets the y translation value (the dy
        ///    value, or the element in the third row and second column) of this <see cref='System.Drawing.Drawing2D.Matrix'/>.
        /// </devdoc>
        public float OffsetY  {
            get { return Elements[5];}
        } 

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Reset"]/*' />
        /// <devdoc>
        ///    Resets this <see cref='System.Drawing.Drawing2D.Matrix'/> to identity.
        /// </devdoc>
        public void Reset() {
            int status = SafeNativeMethods.GdipSetMatrixElements(new HandleRef(this, nativeMatrix),
                                                       1.0f, 0.0f, 0.0f,
                                                       1.0f, 0.0f, 0.0f);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Multiply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies this <see cref='System.Drawing.Drawing2D.Matrix'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void Multiply(Matrix matrix) {
            Multiply(matrix, MatrixOrder.Prepend);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Multiply1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies this <see cref='System.Drawing.Drawing2D.Matrix'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void Multiply(Matrix matrix, MatrixOrder order) {
            
            if (matrix == null) {
                throw new ArgumentNullException("matrix");
            }

            int status = SafeNativeMethods.GdipMultiplyMatrix(new HandleRef(this, nativeMatrix), new HandleRef(matrix, matrix.nativeMatrix), 
                                                    order); 

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Translate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the specified translation vector to
        ///       the this <see cref='System.Drawing.Drawing2D.Matrix'/> by
        ///       prepending the translation vector.
        ///    </para>
        /// </devdoc>
        public void Translate(float offsetX, float offsetY) {
            Translate(offsetX, offsetY, MatrixOrder.Prepend);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Translate1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the specified translation vector to
        ///       the this <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void Translate(float offsetX, float offsetY, MatrixOrder order) {
            int status = SafeNativeMethods.GdipTranslateMatrix(new HandleRef(this, nativeMatrix),
                                                     offsetX, offsetY, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Scale"]/*' />
        /// <devdoc>
        ///    Applies the specified scale vector to this
        /// <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the scale vector.
        /// </devdoc>
        public void Scale(float scaleX, float scaleY) {
            Scale(scaleX, scaleY, MatrixOrder.Prepend);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Scale1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the specified scale vector to this
        ///    <see cref='System.Drawing.Drawing2D.Matrix'/> using the specified order.
        ///    </para>
        /// </devdoc>
        public void Scale(float scaleX, float scaleY, MatrixOrder order) {
            int status = SafeNativeMethods.GdipScaleMatrix(new HandleRef(this, nativeMatrix), scaleX, scaleY, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Rotate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates this <see cref='System.Drawing.Drawing2D.Matrix'/> clockwise about the
        ///       origin by the specified angle.
        ///    </para>
        /// </devdoc>
        public void Rotate(float angle) {
            Rotate(angle, MatrixOrder.Prepend);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Rotate1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates this <see cref='System.Drawing.Drawing2D.Matrix'/> clockwise about the
        ///       origin by the specified
        ///       angle in the specified order.
        ///    </para>
        /// </devdoc>
        public void Rotate(float angle, MatrixOrder order) {
            int status = SafeNativeMethods.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.RotateAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies a clockwise rotation about the
        ///       specified point to this <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the rotation.
        ///    </para>
        /// </devdoc>
        public void RotateAt(float angle, PointF point) {
            RotateAt(angle, point, MatrixOrder.Prepend);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.RotateAt1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies a clockwise rotation about the specified point
        ///       to this <see cref='System.Drawing.Drawing2D.Matrix'/> in the
        ///       specified order.
        ///    </para>
        /// </devdoc>
        public void RotateAt(float angle, PointF point, MatrixOrder order) {
            int status;
            
            // !! TO DO: We cheat with error codes here...
            if (order == MatrixOrder.Prepend) {
                status = SafeNativeMethods.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
                status |= SafeNativeMethods.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
                status |= SafeNativeMethods.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), -point.X, -point.Y, order);
            } 
            else {
                status = SafeNativeMethods.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), -point.X, -point.Y, order);
                status |= SafeNativeMethods.GdipRotateMatrix(new HandleRef(this, nativeMatrix), angle, order);
                status |= SafeNativeMethods.GdipTranslateMatrix(new HandleRef(this, nativeMatrix), point.X, point.Y, order);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Shear"]/*' />
        /// <devdoc>
        ///    Applies the specified shear
        ///    vector to this <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the shear vector.
        /// </devdoc>
        public void Shear(float shearX, float shearY) {
            int status = SafeNativeMethods.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, MatrixOrder.Prepend);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Shear1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the specified shear
        ///       vector to this <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void Shear(float shearX, float shearY, MatrixOrder order) {
            int status = SafeNativeMethods.GdipShearMatrix(new HandleRef(this, nativeMatrix), shearX, shearY, order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Invert"]/*' />
        /// <devdoc>
        ///    Inverts this <see cref='System.Drawing.Drawing2D.Matrix'/>, if it is
        ///    invertible.
        /// </devdoc>
        public void Invert() {
            int status = SafeNativeMethods.GdipInvertMatrix(new HandleRef(this, nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // float version
        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.TransformPoints"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the geometrical transform this <see cref='System.Drawing.Drawing2D.Matrix'/>represents to an
        ///       array of points.
        ///    </para>
        /// </devdoc>
        public void TransformPoints(PointF[] pts) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipTransformMatrixPoints(new HandleRef(this, nativeMatrix),
                                                           new HandleRef(null, buf),
                                                           pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            PointF[] newPts = SafeNativeMethods.ConvertGPPOINTFArrayF(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        // int version
        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.TransformPoints1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Applies the geometrical transform this <see cref='System.Drawing.Drawing2D.Matrix'/> represents to an array of points.
        ///    </para>
        /// </devdoc>
        public void TransformPoints(Point[] pts) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipTransformMatrixPointsI(new HandleRef(this, nativeMatrix),
                                                            new HandleRef(null, buf),
                                                            pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            // must do an in-place copy because we only have a reference
            Point[] newPts = SafeNativeMethods.ConvertGPPOINTArray(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.TransformVectors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void TransformVectors(PointF[] pts) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipVectorTransformMatrixPoints(new HandleRef(this, nativeMatrix),
                                                                 new HandleRef(null, buf),
                                                                 pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            // must do an in-place copy because we only have a reference
            PointF[] newPts = SafeNativeMethods.ConvertGPPOINTFArrayF(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        // int version
        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.VectorTransformPoints"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void VectorTransformPoints(Point[] pts) {
            TransformVectors(pts);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.TransformVectors1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void TransformVectors(Point[] pts) {
            if (pts == null)
                throw new ArgumentNullException("points");
            IntPtr buf = SafeNativeMethods.ConvertPointToMemory(pts);

            int status = SafeNativeMethods.GdipVectorTransformMatrixPointsI(new HandleRef(this, nativeMatrix),
                                                                  new HandleRef(null, buf),
                                                                  pts.Length);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(buf);
                throw SafeNativeMethods.StatusException(status);
            }

            // must do an in-place copy because we only have a reference
            Point[] newPts = SafeNativeMethods.ConvertGPPOINTArray(buf, pts.Length);

            for (int i=0; i<pts.Length; i++)
                pts[i] = newPts[i];

            Marshal.FreeHGlobal(buf);
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.IsInvertible"]/*' />
        /// <devdoc>
        ///    Gets a value indicating whether this
        /// <see cref='System.Drawing.Drawing2D.Matrix'/> is invertible.
        /// </devdoc>
        public bool IsInvertible {
            get {
                int isInvertible;

                int status = SafeNativeMethods.GdipIsMatrixInvertible(new HandleRef(this, nativeMatrix), out isInvertible);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return isInvertible != 0;
            }
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.IsIdentity"]/*' />
        /// <devdoc>
        ///    Gets a value indicating whether this <see cref='System.Drawing.Drawing2D.Matrix'/> is the identity matrix.
        /// </devdoc>
        public bool IsIdentity {
            get {
                int isIdentity;

                int status = SafeNativeMethods.GdipIsMatrixIdentity(new HandleRef(this, nativeMatrix), out isIdentity);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return isIdentity != 0;
            }
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified object is a
        ///    <see cref='System.Drawing.Drawing2D.Matrix'/> and is identical to this <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is Matrix)) return false;
            Matrix matrix2 = (Matrix) obj;
            int isEqual;

            int status = SafeNativeMethods.GdipIsMatrixEqual(new HandleRef(this, nativeMatrix),
                                                   new HandleRef(matrix2, matrix2.nativeMatrix),
                                                   out isEqual);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return isEqual != 0;
        }

        /// <include file='doc\Matrix.uex' path='docs/doc[@for="Matrix.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a hash code.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        internal Matrix(IntPtr nativeMatrix) {
            SetNativeMatrix(nativeMatrix);
        }

        internal void SetNativeMatrix(IntPtr nativeMatrix) {
            this.nativeMatrix = nativeMatrix;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\linegradientbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="LineGradientBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/* Delete this file!! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\linetexture.cs ===
//------------------------------------------------------------------------------
// <copyright file="LineTexture.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// !! Delete this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\matrixorder.cs ===
//------------------------------------------------------------------------------
// <copyright file="MatrixOrder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MatrixOrder.cs
*
* Abstract:
*
*   Matrix ordering constants
*
* Revision History:
*
*   2/2/2K ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Various wrap modes for brushes
     */
    /// <include file='doc\MatrixOrder.uex' path='docs/doc[@for="MatrixOrder"]/*' />
    /// <devdoc>
    ///    Specifies the order for matrix transform
    ///    operations.
    /// </devdoc>
    public enum MatrixOrder
    {
        /// <include file='doc\MatrixOrder.uex' path='docs/doc[@for="MatrixOrder.Prepend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The new operation is applied before the old
        ///       operation.
        ///    </para>
        /// </devdoc>
        Prepend = 0,
        /// <include file='doc\MatrixOrder.uex' path='docs/doc[@for="MatrixOrder.Append"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The new operation is applied after the old operation.
        ///    </para>
        /// </devdoc>
        Append = 1
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\linejoin.cs ===
//------------------------------------------------------------------------------
// <copyright file="LineJoin.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   LineJoin.cs
*
* Abstract:
*
*   Line join constants
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Line join constants
     */
    /// <include file='doc\LineJoin.uex' path='docs/doc[@for="LineJoin"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how to join two intersecting lines in a
    ///    <see cref='System.Drawing.Drawing2D.GraphicsPath'/> at their intersection.
    ///    </para>
    /// </devdoc>
    public enum LineJoin
    {
        /// <include file='doc\LineJoin.uex' path='docs/doc[@for="LineJoin.Miter"]/*' />
        /// <devdoc>
        ///    Specifies an angled miter join.
        /// </devdoc>
        Miter = 0,
        /// <include file='doc\LineJoin.uex' path='docs/doc[@for="LineJoin.Bevel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a beveled join.
        ///    </para>
        /// </devdoc>
        Bevel = 1,
        /// <include file='doc\LineJoin.uex' path='docs/doc[@for="LineJoin.Round"]/*' />
        /// <devdoc>
        ///    Specifies a smooth, rounded join.
        /// </devdoc>
        Round = 2,
        /// <include file='doc\LineJoin.uex' path='docs/doc[@for="LineJoin.MiterClipped"]/*' />
        /// <devdoc>
        ///    Specifies a mitered clipped join
        /// </devdoc>
        MiterClipped = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafileframeunit.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileFrameUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MetafileFrameUnit.cs
*
* Abstract:
*
*   Page unit constant types
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/                   

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Page unit constants
     */
    /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the unit of measurement for the
    ///       rectangle used to size and position a metafile. This is specified during the
    ///       creation of the <see cref='System.Drawing.Imaging.Metafile'/>.
    ///    </para>
    /// </devdoc>
    public enum MetafileFrameUnit
    {
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.Pixel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a pixel as the unit of measure.
        ///    </para>
        /// </devdoc>
        Pixel = GraphicsUnit.Pixel,
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.Point"]/*' />
        /// <devdoc>
        ///    Specifies a printer's point as
        ///    the unit of measure.
        /// </devdoc>
        Point = GraphicsUnit.Point,
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.Inch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies an inch as the unit of measure.
        ///    </para>
        /// </devdoc>
        Inch = GraphicsUnit.Inch,
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.Document"]/*' />
        /// <devdoc>
        ///    Specifies 1/300 of an inch as the unit of
        ///    measure.
        /// </devdoc>
        Document = GraphicsUnit.Document,
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.Millimeter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a millimeter as the unit of
        ///       measure.
        ///    </para>
        /// </devdoc>
        Millimeter = GraphicsUnit.Millimeter,
        /// <include file='doc\MetafileFrameUnit.uex' path='docs/doc[@for="MetafileFrameUnit.GdiCompatible"]/*' />
        /// <devdoc>
        ///    Specifies .01 millimeter as the unit of
        ///    measure. Provided for compatibility with GDI.
        /// </devdoc>
        GdiCompatible
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafile.cs ===
//------------------------------------------------------------------------------
// <copyright file="Metafile.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile.cs
* Abstract:
*
*   COM+ wrapper for GDI+ Metafile objects
*
* Revision History:
*
*   9/27/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Internal;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;

    /**
     * Represent a metafile image
     */
    /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile"]/*' />
    /// <devdoc>
    ///    Defines a graphic metafile. A metafile
    ///    contains records that describe a sequence of graphics operations that can be
    ///    recorded and played back.
    /// </devdoc>
    [
    Editor("System.Drawing.Design.MetafileEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor)),
    ]
    [Serializable]
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public sealed class Metafile : Image {

        /*
         * Create a new metafile object from a metafile handle (WMF)
         */

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified handle and
        ///    <see cref='System.Drawing.Imaging.WmfPlaceableFileHeader'/>.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader) :
        this(hmetafile, wmfHeader, false) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified handle and
        ///    <see cref='System.Drawing.Imaging.WmfPlaceableFileHeader'/>.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMetafileFromWmf(new HandleRef(null, hmetafile), wmfHeader, deleteWmf, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /*
         * Create a new metafile object from an enhanced metafile handle
         */

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified handle and <see cref='System.Drawing.Imaging.WmfPlaceableFileHeader'/>.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr henhmetafile, bool deleteEmf) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMetafileFromEmf(new HandleRef(null, henhmetafile), deleteEmf, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /**
         * Create a new metafile object from a file
         */
        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile3"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified filename.
        /// </devdoc>
        public Metafile(string filename) {
            IntSecurity.DemandReadFileIO(filename);

            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMetafileFromFile(filename, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /**
         * Create a new metafile object from a stream
         */
        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile4"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified stream.
        /// </devdoc>
        public Metafile(Stream stream) {

            if (stream == null)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));
            
            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateMetafileFromStream(new GPStream(stream), out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile5"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified handle to a
        ///    device context.
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, EmfType emfType) :
        this(referenceHdc, emfType, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified handle to a device context.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, EmfType emfType, String description) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)emfType, NativeMethods.NullHandleRef, (int) MetafileFrameUnit.GdiCompatible,
                                                    description,
                                                    out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified device context,
        ///       bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, RectangleF frameRect) :
        this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified device context,
        ///       bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit) :
        this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified device context, bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type) :
        this(referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified device context,
        ///       bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, String description)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            GPRECTF rectf = new GPRECTF(frameRect);
            int status = SafeNativeMethods.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, ref rectf, (int)frameUnit,
                                                    description, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified device context, bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, Rectangle frameRect) :
        this(referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified device context, bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit) :
        this(referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile13"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified device context, bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type) :
        this(referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile14"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified device context, bounded by the specified rectangle.
        ///    </para>
        /// </devdoc>
        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status;

            if (frameRect.IsEmpty) {
                status = SafeNativeMethods.GdipRecordMetafile(new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)MetafileFrameUnit.GdiCompatible,
                                                    desc, out metafile);
            }
            else {
                GPRECT gprect = new GPRECT(frameRect);
                status = SafeNativeMethods.GdipRecordMetafileI(new HandleRef(null, referenceHdc), (int)type, ref gprect, (int)frameUnit,
                                                     desc, out metafile);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile15"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified
        ///    filename.
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc) :
        this(fileName, referenceHdc, EmfType.EmfPlusDual, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile16"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified
        ///       filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, EmfType type) :
        this(fileName, referenceHdc, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile17"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, EmfType type, String description)
        {
            IntSecurity.DemandReadFileIO(fileName);
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type,  NativeMethods.NullHandleRef,
                                                            (int) MetafileFrameUnit.GdiCompatible, description,
                                                            out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }        

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile18"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect) :
        this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile19"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit) :
        this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile20"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit, EmfType type) :
        this(fileName, referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile21"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc) :
        this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, desc) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile22"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit, EmfType type, String description)
        {
            IntSecurity.DemandReadFileIO(fileName);
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            GPRECTF rectf = new GPRECTF(frameRect);
            int status = SafeNativeMethods.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, ref rectf,
                                                            (int)frameUnit, description, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile23"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect) :
        this(fileName, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile24"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect,
                        MetafileFrameUnit frameUnit) :
        this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile25"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect,
                        MetafileFrameUnit frameUnit, EmfType type) :
        this(fileName, referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile26"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description) :
        this(fileName, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual, description) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile27"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description)
        {
            IntSecurity.DemandReadFileIO(fileName);
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status;

            if (frameRect.IsEmpty) {
                status = SafeNativeMethods.GdipRecordMetafileFileName(fileName, new HandleRef(null, referenceHdc), (int)type, NativeMethods.NullHandleRef, (int)frameUnit,
                                                            description, out metafile);
            }
            else {
                GPRECT gprect = new GPRECT(frameRect);
                status = SafeNativeMethods.GdipRecordMetafileFileNameI(fileName, new HandleRef(null, referenceHdc), (int)type,
                                                             ref gprect, (int)frameUnit,
                                                             description, out metafile);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }    

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile28"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified data
        ///       stream.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc) :
        this(stream, referenceHdc, EmfType.EmfPlusDual, null) {}
        
        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile29"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified data
        ///       stream.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, EmfType type) :
        this(stream, referenceHdc, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile30"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified data stream.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();
            IntPtr metafile = IntPtr.Zero;

            int status = SafeNativeMethods.GdipRecordMetafileStream(new GPStream(stream), 
                                                          new HandleRef(null, referenceHdc), (int)type,  NativeMethods.NullHandleRef,
                                                          (int)MetafileFrameUnit.GdiCompatible, description,
                                                          out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }        

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile31"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the specified data stream.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect) :
        this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile32"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit) :
        this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile33"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit, EmfType type) :
        this(stream, referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile34"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect,
                        MetafileFrameUnit frameUnit, EmfType type, string description)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();
            IntPtr metafile = IntPtr.Zero;
            
            GPRECTF rectf = new GPRECTF(frameRect);
            int status = SafeNativeMethods.GdipRecordMetafileStream(new GPStream(stream),
                                                          new HandleRef(null, referenceHdc), (int)type, ref rectf,
                                                          (int)frameUnit, description, out metafile);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile35"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class from the
        ///       specified data stream.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect) :
        this(stream, referenceHdc, frameRect, MetafileFrameUnit.GdiCompatible) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile36"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect,
                        MetafileFrameUnit frameUnit) :
        this(stream, referenceHdc, frameRect, frameUnit, EmfType.EmfPlusDual) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile37"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect,
                        MetafileFrameUnit frameUnit, EmfType type) :
        this(stream, referenceHdc, frameRect, frameUnit, type, null) {}

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.Metafile38"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Imaging.Metafile'/> class with the
        ///       specified filename.
        ///    </para>
        /// </devdoc>
        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit,
                        EmfType type, string description)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            IntPtr metafile = IntPtr.Zero;

            int status;

            if (frameRect.IsEmpty) {
                status = SafeNativeMethods.GdipRecordMetafileStream(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type,
                                                          NativeMethods.NullHandleRef, (int)frameUnit, description, out metafile);
            }
            else {
                GPRECT gprect = new GPRECT(frameRect);
                status = SafeNativeMethods.GdipRecordMetafileStreamI(new GPStream(stream), new HandleRef(null, referenceHdc), (int)type,
                                                           ref gprect, (int)frameUnit, description, out metafile);
            }

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeImage(metafile);
        }

        /**
         * Constructor used in deserialization
         */
        private Metafile(SerializationInfo info, StreamingContext context) : base(info, context) {            
        }
        
        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetMetafileHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.Imaging.MetafileHeader'/> associated with the specified <see cref='System.Drawing.Imaging.Metafile'/>.
        ///    </para>
        /// </devdoc>
        public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            MetafileHeader header = new MetafileHeader();
            
            header.wmf = new MetafileHeaderWmf();

            int status = SafeNativeMethods.GdipGetMetafileHeaderFromWmf(new HandleRef(null, hmetafile), wmfHeader, header.wmf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return header;
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetMetafileHeader1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.Imaging.MetafileHeader'/> associated with the specified <see cref='System.Drawing.Imaging.Metafile'/>.
        ///    </para>
        /// </devdoc>
        public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile)
        {
            IntSecurity.ObjectFromWin32Handle.Demand();

            MetafileHeader header = new MetafileHeader();
            header.emf = new MetafileHeaderEmf();

            int status = SafeNativeMethods.GdipGetMetafileHeaderFromEmf(new HandleRef(null, henhmetafile), header.emf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                
            return header;
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetMetafileHeader2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.Imaging.MetafileHeader'/> associated with the specified <see cref='System.Drawing.Imaging.Metafile'/>.
        ///    </para>
        /// </devdoc>
        public static MetafileHeader GetMetafileHeader(string fileName)
        {
            IntSecurity.DemandReadFileIO(fileName);

            MetafileHeader header = new MetafileHeader();
            
            IntPtr memory = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));

            int status = SafeNativeMethods.GdipGetMetafileHeaderFromFile(fileName, memory);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(memory);
                throw SafeNativeMethods.StatusException(status);
            }

            int[] type = new int[] { 0};

            Marshal.Copy(memory, type, 0, 1);

            MetafileType metafileType = (MetafileType) type[0];

            if (metafileType == MetafileType.Wmf ||
                metafileType == MetafileType.WmfPlaceable) {
                // WMF header
                header.wmf = (MetafileHeaderWmf) UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderWmf));
                header.emf = null;
            } else {
                // EMF header
                header.wmf = null;
                header.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderEmf));
            }

            Marshal.FreeHGlobal(memory);
            
            return header;
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetMetafileHeader3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.Imaging.MetafileHeader'/> associated with the specified <see cref='System.Drawing.Imaging.Metafile'/>.
        ///    </para>
        /// </devdoc>
        public static MetafileHeader GetMetafileHeader(Stream stream)
        {

            MetafileHeader header = new MetafileHeader();
            
            IntPtr memory = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));

            int status = SafeNativeMethods.GdipGetMetafileHeaderFromStream(new GPStream(stream), memory);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(memory);
                throw SafeNativeMethods.StatusException(status);
            }

            int[] type = new int[] { 0};

            Marshal.Copy(memory, type, 0, 1);

            MetafileType metafileType = (MetafileType) type[0];

            if (metafileType == MetafileType.Wmf ||
                metafileType == MetafileType.WmfPlaceable) {
                // WMF header
                header.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderWmf));
                header.emf = null;
            } else {
                // EMF header
                header.wmf = null;
                header.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderEmf));
            }

            Marshal.FreeHGlobal(memory);
            
            return header;
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetMetafileHeader4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Drawing.Imaging.MetafileHeader'/> associated with this <see cref='System.Drawing.Imaging.Metafile'/>.
        ///    </para>
        /// </devdoc>
        public MetafileHeader GetMetafileHeader()
        {
            IntPtr memory = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(MetafileHeaderEmf)));

            int status = SafeNativeMethods.GdipGetMetafileHeaderFromMetafile(new HandleRef(this, nativeImage), memory);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(memory);
                throw SafeNativeMethods.StatusException(status);
            }

            int[] type = new int[] { 0};

            Marshal.Copy(memory, type, 0, 1);

            MetafileType metafileType = (MetafileType) type[0];

            MetafileHeader header = new MetafileHeader();

            if (metafileType == MetafileType.Wmf ||
                metafileType == MetafileType.WmfPlaceable) {
                // WMF header
                header.wmf = (MetafileHeaderWmf)UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderWmf));
                header.emf = null;
            } else {
                // EMF header
                header.wmf = null;
                header.emf = (MetafileHeaderEmf)UnsafeNativeMethods.PtrToStructure(memory, typeof(MetafileHeaderEmf));
            }

            Marshal.FreeHGlobal(memory);

            return header;
        }

        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.GetHenhmetafile"]/*' />
        /// <devdoc>
        ///    Returns a Windows handle to an enhanced
        /// <see cref='System.Drawing.Imaging.Metafile'/>.
        /// </devdoc>
        public IntPtr GetHenhmetafile()
        {
            IntPtr hEmf = IntPtr.Zero;

            int status = SafeNativeMethods.GdipGetHemfFromMetafile(new HandleRef(this, nativeImage), out hEmf);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return hEmf;
        }
        
        /// <include file='doc\Metafile.uex' path='docs/doc[@for="Metafile.PlayRecord"]/*' />
        /// <devdoc>
        ///    Plays an EMF+ file.
        /// </devdoc>
        public void PlayRecord(EmfPlusRecordType recordType,
                               int flags,
                               int dataSize,
                               byte[] data)
        {
            // Used in conjunction with Graphics.EnumerateMetafile to play an EMF+
            // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
            // WORD aligned if it's a WMF.
            
            int status = SafeNativeMethods.GdipPlayMetafileRecord(new HandleRef(this, nativeImage),
                                                        recordType,
                                                        flags,
                                                        dataSize,
                                                        data);
                                                        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /*
         * Create a new metafile object from a native metafile handle.
         * This is only for internal purpose.
         */
        internal static Metafile FromGDIplus(IntPtr nativeImage) {
            Metafile metafile = new Metafile();
            metafile.SetNativeImage(nativeImage);
            return metafile;
        }

        private Metafile() {
        }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafileheaderemf.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileHeaderEmf.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MetafileHeaderEmf.cs
*
* Abstract:
*
*   Native GDI+ MetafileHeaderEmf structure.
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal class MetafileHeaderEmf
    {
         public MetafileType type = (MetafileType)0;
         public int size = 0;
         public int version = 0;
         public EmfPlusFlags emfPlusFlags = (EmfPlusFlags)0;
         public float dpiX = 0;
         public float dpiY = 0;
         public int X = 0;
         public int Y = 0;
         public int Width = 0;
         public int Height = 0;
         public SafeNativeMethods.ENHMETAHEADER EmfHeader = null;
         public int EmfPlusHeaderSize = 0;
         public int LogicalDpiX = 0;
         public int LogicalDpiY = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metaheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="METAHEADER.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   METAHEADER.cs
*
* Abstract:
*
*   Native GDI+ MetaHeader WMF structure.
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;
    using System.Runtime.InteropServices;

    /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential, Pack=2)]
    public sealed class MetaHeader {
        short type;
        short headerSize;
        short version;
        int size;
        short noObjects;
        int maxRecord;
        short noParameters;

        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.Type"]/*' />
        /// <devdoc>
        ///    Represents the type of the associated
        /// <see cref='System.Drawing.Imaging.Metafile'/>.
        /// </devdoc>
        public short Type {
            get { return type; }
            set { type = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.HeaderSize"]/*' />
        /// <devdoc>
        ///    Represents the sizi, in bytes, of the
        ///    header file.
        /// </devdoc>
        public short HeaderSize {
            get { return headerSize; }
            set { headerSize = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.Version"]/*' />
        /// <devdoc>
        ///    Represents the version number of the header
        ///    format.
        /// </devdoc>
        public short Version {
            get { return version; }
            set { version = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.Size"]/*' />
        /// <devdoc>
        ///    Represents the sizi, in bytes, of the
        ///    associated <see cref='System.Drawing.Imaging.Metafile'/>.
        /// </devdoc>
        public int Size {
            get { return size; }
            set { size = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.NoObjects"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public short NoObjects {
            get { return noObjects; }
            set { noObjects = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.MaxRecord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int MaxRecord {
            get { return maxRecord; }
            set { maxRecord = value; }
        }
        /// <include file='doc\METAHEADER.uex' path='docs/doc[@for="MetaHeader.NoParameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public short NoParameters {
            get { return noParameters; }
            set { noParameters = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafileheaderwmf.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileHeaderWmf.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MetafileHeaderWmf.cs
*
* Abstract:
*
*   Native GDI+ MetafileHeaderWmf structure.
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;
    using System.Runtime.InteropServices;
     
    [StructLayout(LayoutKind.Sequential, Pack=8)]
    internal class MetafileHeaderWmf
    {
        public MetafileType type = (MetafileType)0;
        public int size = Marshal.SizeOf(typeof(MetafileHeaderWmf));
        public int version = 0;
        public EmfPlusFlags emfPlusFlags = (EmfPlusFlags)0;
        public float dpiX = 0;
        public float dpiY = 0;
        public int X = 0;
        public int Y = 0;
        public int Width = 0;
        public int Height = 0;
        
        //The below datatype, WmfHeader, file is defined natively
        //as a union with EmfHeader.  Since EmfHeader is a larger
        //structure, we need to pad the struct below so that this
        //will marshal correctly.
        [MarshalAs(UnmanagedType.Struct)]
        public MetaHeader WmfHeader = new MetaHeader();
        public int dummy1 = 0;
        public int dummy2 = 0;
        public int dummy3 = 0;
        public int dummy4 = 0;

        public int EmfPlusHeaderSize = 0;
        public int LogicalDpiX = 0;
        public int LogicalDpiY = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafiletype.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MetafileType.cs
*
* Abstract:
*
*   Native GDI+ Metafile Type constants
*
* Revision History:
*
*   10/19/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * MetafileType Type
     */
    /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the format of a <see cref='System.Drawing.Imaging.Metafile'/>.
    ///    </para>
    /// </devdoc>
    public enum MetafileType
    {
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.Invalid"]/*' />
         /// <devdoc>
         ///    Specifies an invalid type.
         /// </devdoc>
         Invalid,            // Invalid metafile
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.Wmf"]/*' />
         /// <devdoc>
         ///    Specifies a standard Windows metafile.
         /// </devdoc>
         Wmf,                // Standard WMF
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.WmfPlaceable"]/*' />
         /// <devdoc>
         ///    Specifies a Windows Placeable metafile.
         /// </devdoc>
         WmfPlaceable,           // Placeable Metafile format
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.Emf"]/*' />
         /// <devdoc>
         ///    Specifies a Windows enhanced metafile.
         /// </devdoc>
         Emf,                // EMF (not EMF+)
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.EmfPlusOnly"]/*' />
         /// <devdoc>
         ///    Specifies a Windows enhanced metafile plus.
         /// </devdoc>
         EmfPlusOnly,        // EMF+ without dual, down-level records
         /// <include file='doc\MetafileType.uex' path='docs/doc[@for="MetafileType.EmfPlusDual"]/*' />
         /// <devdoc>
         ///    Specifies both enhanced and enhanced plus
         ///    commands in the same file.
         /// </devdoc>
         EmfPlusDual,        // EMF+ with dual, down-level records
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\paletteflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaletteFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PaletteFlags.cs
*
* Abstract:
*
*   Palette Flags const types
*
* Revision History:
*
*   3/14/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Drawing;
    using System;

    /// <include file='doc\PaletteFlags.uex' path='docs/doc[@for="PaletteFlags"]/*' />
    /// <devdoc>
    ///    Specifies the type of color data in the
    ///    system palette. The data can be color data with alpha, grayscale only, or
    ///    halftone data.
    /// </devdoc>
    public enum PaletteFlags
    {
    
        /// <include file='doc\PaletteFlags.uex' path='docs/doc[@for="PaletteFlags.HasAlpha"]/*' />
        /// <devdoc>
        ///    Specifies alpha data.
        /// </devdoc>
        HasAlpha    = 0x0001,
        /// <include file='doc\PaletteFlags.uex' path='docs/doc[@for="PaletteFlags.GrayScale"]/*' />
        /// <devdoc>
        ///    Specifies grayscale data.
        /// </devdoc>
        GrayScale   = 0x0002,
        /// <include file='doc\PaletteFlags.uex' path='docs/doc[@for="PaletteFlags.Halftone"]/*' />
        /// <devdoc>
        ///    Specifies halftone data.
        /// </devdoc>
        Halftone    = 0x0004
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\metafileheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MetafileHeader.cs
*
* Abstract:
*
*   Native GDI+ MetafileHeader structure.
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Configuration.Assemblies;

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Drawing.Internal;

    /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader"]/*' />
    /// <devdoc>
    ///    Contains attributes of an
    ///    associated <see cref='System.Drawing.Imaging.Metafile'/>.
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class MetafileHeader
    {
         // determine which to use by nullity
         internal MetafileHeaderWmf wmf;
         internal MetafileHeaderEmf emf;

         internal MetafileHeader()
         {
             wmf = null;
             emf = null;
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.Type"]/*' />
         /// <devdoc>
         ///    Gets the type of the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public MetafileType Type
         {
             get
             {
                 return IsWmf() ? wmf.type : emf.type;
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.MetafileSize"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets the size, in bytes, of the associated
         ///    <see cref='System.Drawing.Imaging.Metafile'/>.
         ///    </para>
         /// </devdoc>
         public int MetafileSize
         {
             get
             {
                 return IsWmf() ? wmf.size : emf.size;
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.Version"]/*' />
         /// <devdoc>
         ///    Gets the version number of the associated
         /// <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public int Version
         {
             get
             {
                 return IsWmf() ? wmf.version : emf.version;
             }
         }

         private EmfPlusFlags EmfPlusFlags
         {
             get
             {
                 return IsWmf() ? wmf.emfPlusFlags : emf.emfPlusFlags;
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.DpiX"]/*' />
         /// <devdoc>
         ///    Gets the horizontal resolution, in
         ///    dots-per-inch, of the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public float DpiX
         {
             get
             {
                 return IsWmf() ? wmf.dpiX : emf.dpiX;
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.DpiY"]/*' />
         /// <devdoc>
         ///    Gets the vertical resolution, in
         ///    dots-per-inch, of the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public float DpiY
         {
             get
             {
                 return IsWmf() ? wmf.dpiY : emf.dpiY;
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.Bounds"]/*' />
         /// <devdoc>
         ///    Gets a <see cref='System.Drawing.Rectangle'/> that bounds the associated
         /// <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public Rectangle Bounds
         {
             get
             {
                 return IsWmf() ?
                     new Rectangle(wmf.X, wmf.Y, wmf.Width, wmf.Height) :
                     new Rectangle(emf.X, emf.Y, emf.Width, emf.Height);
             }
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsWmf"]/*' />
         /// <devdoc>
         ///    Returns a value indicating whether the
         ///    associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Windows metafile
         ///    format.
         /// </devdoc>
         public bool IsWmf()
         {
              if ((wmf == null) && (emf == null))
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              if ((wmf != null) &&
                  ((wmf.type == MetafileType.Wmf) ||
                   (wmf.type == MetafileType.WmfPlaceable)))
                   return true;
              else
                   return false;
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsWmfPlaceable"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Returns a value indicating whether the
         ///       associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Windows Placeable metafile
         ///       format.
         ///    </para>
         /// </devdoc>
         public bool IsWmfPlaceable()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((wmf != null) && (wmf.type == MetafileType.WmfPlaceable));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsEmf"]/*' />
         /// <devdoc>
         ///    Returns a value indicating whether the
         ///    associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Windows enhanced metafile
         ///    format.
         /// </devdoc>
         public bool IsEmf()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((emf != null) && (emf.type == MetafileType.Emf));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsEmfOrEmfPlus"]/*' />
         /// <devdoc>
         ///    Returns a value indicating whether the
         ///    associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Windows enhanced metafile
         ///    format or the Windows enhanced metafile plus.
         /// </devdoc>
         public bool IsEmfOrEmfPlus()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((emf != null) && (emf.type >= MetafileType.Emf));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsEmfPlus"]/*' />
         /// <devdoc>
         ///    Returns a value indicating whether the
         ///    associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Windows enhanced metafile
         ///    plus format.
         /// </devdoc>
         public bool IsEmfPlus()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((emf != null) && (emf.type >= MetafileType.EmfPlusOnly));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsEmfPlusDual"]/*' />
         /// <devdoc>
         ///    Returns a value indicating whether the
         ///    associated <see cref='System.Drawing.Imaging.Metafile'/> is in the Dual enhanced
         ///    metafile format. This format supports both the enhanced and the enhanced
         ///    plus format.
         /// </devdoc>
         public bool IsEmfPlusDual()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((emf != null) && (emf.type == MetafileType.EmfPlusDual));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsEmfPlusOnly"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Returns a value indicating whether the associated <see cref='System.Drawing.Imaging.Metafile'/> supports only the Windows
         ///       enhanced metafile plus format.
         ///    </para>
         /// </devdoc>
         public bool IsEmfPlusOnly()
         {
              if (wmf == null && emf == null)
                  throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

              return ((emf != null) && (emf.type == MetafileType.EmfPlusOnly));
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.IsDisplay"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Returns a value indicating whether the associated <see cref='System.Drawing.Imaging.Metafile'/> is device-dependent.
         ///    </para>
         /// </devdoc>
         public bool IsDisplay()
         {
	      return IsEmfPlus() &&
		     ((((int)emf.emfPlusFlags) & ((int)EmfPlusFlags.Display)) != 0);
         }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.WmfHeader"]/*' />
         /// <devdoc>
         ///    Gets the WMF header file for the associated
         /// <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public MetaHeader WmfHeader
         {
             get
             {
                 if (wmf == null)
                     throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

                 return wmf.WmfHeader;
              }
          }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.EmfHeader"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets the WMF header file for the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         ///    </para>
         /// </devdoc>
         internal SafeNativeMethods.ENHMETAHEADER EmfHeader
         {
             get
             {
                 if (emf == null)
                     throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

                 return emf.EmfHeader;
              }
          }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.EmfPlusHeaderSize"]/*' />
         /// <devdoc>
         ///    Gets the size, in bytes, of the
         ///    enhanced metafile plus header file.
         /// </devdoc>
         public int EmfPlusHeaderSize
	 {
	     get { 	
		 if (wmf == null && emf == null)
	  	     throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

	         return IsWmf() ? wmf.EmfPlusHeaderSize : emf.EmfPlusHeaderSize;
	     }
	 }

         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.LogicalDpiX"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets the logical horizontal resolution, in
         ///       dots-per-inch, of the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         ///    </para>
         /// </devdoc>
         public int LogicalDpiX
	 {
	     get { 	
		 if (wmf == null && emf == null)
	  	     throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

	         return IsWmf() ? wmf.LogicalDpiX : emf.LogicalDpiX;
	     }
	 }
         
         /// <include file='doc\MetafileHeader.uex' path='docs/doc[@for="MetafileHeader.LogicalDpiY"]/*' />
         /// <devdoc>
         ///    Gets the logical vertical resolution, in
         ///    dots-per-inch, of the associated <see cref='System.Drawing.Imaging.Metafile'/>.
         /// </devdoc>
         public int LogicalDpiY
	 {
	     get { 	
		 if (wmf == null && emf == null)
	  	     throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);

	         return IsWmf() ? wmf.LogicalDpiY : emf.LogicalDpiX;
	     }
	 }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pathgradientbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="PathGradientBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PathGradient.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ PathGradient objects
*
* Revision History:
*
*   01/11/1999 davidx
*       Code review.
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;    
    using System.Drawing.Internal;
    using System;

    /**
     * Represent a PathGradient brush object
     */
    /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush"]/*' />
    /// <devdoc>
    ///    Encapsulates a <see cref='System.Drawing.Brush'/> that fills the interior of a
    /// <see cref='System.Drawing.Drawing2D.GraphicsPath'/> with a gradient.
    /// </devdoc>
    public sealed class PathGradientBrush : Brush {
        
        internal PathGradientBrush() { nativeBrush = IntPtr.Zero; }

        /**
         * Create a new rectangle gradient brush object
         */
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.PathGradientBrush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> class with the specified points.
        ///    </para>
        /// </devdoc>
        public PathGradientBrush(PointF[] points)
            : this(points, System.Drawing.Drawing2D.WrapMode.Clamp) {
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.PathGradientBrush1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> class with the specified points and
        ///    wrap mode.
        /// </devdoc>
        public PathGradientBrush(PointF[] points, WrapMode wrapMode)
        {
            if (points == null)
                throw new ArgumentNullException("points");
            
            //validate the WrapMode enum
            if (!Enum.IsDefined(typeof(WrapMode), wrapMode)) {
                throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
            }

            IntPtr brush = IntPtr.Zero;
            IntPtr pointsBuf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipCreatePathGradient(new HandleRef(null, pointsBuf),
                                                        points.Length,
                                                        (int) wrapMode,
                                                        out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.PathGradientBrush2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> class with the
        ///       specified points.
        ///    </para>
        /// </devdoc>
        public PathGradientBrush(Point[] points)
            : this(points, System.Drawing.Drawing2D.WrapMode.Clamp) {
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.PathGradientBrush3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> class with the
        ///       specified points and wrap mode.
        ///    </para>
        /// </devdoc>
        public PathGradientBrush(Point[] points, WrapMode wrapMode)
        {
            if (points == null)
                throw new ArgumentNullException("points");
            
            //validate the WrapMode enum
            if (!Enum.IsDefined(typeof(WrapMode), wrapMode)) {
                throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
            }

            IntPtr brush = IntPtr.Zero;
            IntPtr pointsBuf = SafeNativeMethods.ConvertPointToMemory(points);
            int status = SafeNativeMethods.GdipCreatePathGradientI(new HandleRef(null, pointsBuf),
                                                         points.Length,
                                                         (int) wrapMode,
                                                         out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.PathGradientBrush4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathGradientBrush'/>
        ///       class with the specified path.
        ///    </para>
        /// </devdoc>
        public PathGradientBrush(GraphicsPath path)
        {
            if (path == null)
                throw new ArgumentNullException("path");
            
            IntPtr brush = IntPtr.Zero;
            int status = SafeNativeMethods.GdipCreatePathGradientFromPath(new HandleRef(path, path.nativePath),
                                                                out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.Drawing2D.PathGradientBrush'/>.
        /// </devdoc>
        public override object Clone() {
            IntPtr cloneBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBrush(new HandleRef(this, nativeBrush), out cloneBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new PathGradientBrush(cloneBrush );
        }

        /**
         * Set/get center color attributes
         */
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.CenterColor"]/*' />
        /// <devdoc>
        ///    Gets or sets the color at the center of the
        ///    path gradient.
        /// </devdoc>
        public Color CenterColor
        {
            get {
                int argb;
                
                int status = SafeNativeMethods.GdipGetPathGradientCenterColor(new HandleRef(this, nativeBrush), out argb);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return Color.FromArgb(argb);
            }

            set {
                int status = SafeNativeMethods.GdipSetPathGradientCenterColor(new HandleRef(this, nativeBrush), value.ToArgb());

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Get/set colors
         * !! NOTE: We do not have methods for GetSurroundColor or SetSurroundColor,
         *    May need to add usage of Collection class
         */

        private void _SetSurroundColors(Color[] colors)
        {
            int count;
            
            int status = SafeNativeMethods.GdipGetPathGradientSurroundColorCount(new HandleRef(this, nativeBrush),
                                                                       out count);
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
                      
            if ((colors.Length > count) || (count <= 0))  
                throw SafeNativeMethods.StatusException(SafeNativeMethods.InvalidParameter);
                
            count = colors.Length;
            int[] argbs = new int[count];
            for (int i=0; i<colors.Length; i++)
                argbs[i] = colors[i].ToArgb();

            status = SafeNativeMethods.GdipSetPathGradientSurroundColorsWithCount(new HandleRef(this, nativeBrush), 
                                                                        argbs,
                                                                        ref count);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private Color[] _GetSurroundColors()
        {
            int count;
            
            int status = SafeNativeMethods.GdipGetPathGradientSurroundColorCount(new HandleRef(this, nativeBrush),
                                                                       out count);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
            
            int[] argbs = new int[count];

            status = SafeNativeMethods.GdipGetPathGradientSurroundColorsWithCount(new HandleRef(this, nativeBrush),
                                                                        argbs,
                                                                        ref count);

            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            Color[] colors = new Color[count];
            for (int i=0; i<count; i++)
                colors[i] = Color.FromArgb(argbs[i]);

            return colors;
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.SurroundColors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets an array of colors that
        ///       correspond to the points in the path this <see cref='System.Drawing.Drawing2D.LinearGradientBrush'/> fills.
        ///    </para>
        /// </devdoc>
        public Color[] SurroundColors
        {
            get { return _GetSurroundColors();}
            set { _SetSurroundColors(value);}
        }

        /**
         * Set/gfet points
         */

        private void _SetPolygon(PointF[] points)
        {
            if (points == null)
                throw new ArgumentNullException("points");
            throw SafeNativeMethods.StatusException(SafeNativeMethods.NotImplemented);
        }

        private PointF[] _GetPolygon()
        {
            throw SafeNativeMethods.StatusException(SafeNativeMethods.NotImplemented);
        }

       /**
         * Set/get center point
         */
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.CenterPoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the center point of the path
        ///       gradient.
        ///    </para>
        /// </devdoc>
        public PointF CenterPoint
        {
            get {
                GPPOINTF point = new GPPOINTF();

                int status = SafeNativeMethods.GdipGetPathGradientCenterPoint(new HandleRef(this, nativeBrush), point);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return point.ToPoint();
            }

            set {
                int status = SafeNativeMethods.GdipSetPathGradientCenterPoint(new HandleRef(this, nativeBrush), new GPPOINTF(value));

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Get source rectangle
         */
        private RectangleF _GetRectangle() {
            GPRECTF rect = new GPRECTF();

            int status = SafeNativeMethods.GdipGetPathGradientRect(new HandleRef(this, nativeBrush), ref rect);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return rect.ToRectangleF();
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.Rectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a bounding rectangle for this <see cref='System.Drawing.Drawing2D.PathGradientBrush'/>.
        ///    </para>
        /// </devdoc>
        public RectangleF Rectangle
        {
            get { return _GetRectangle();}          
        }

        /**
         * Set/get blend factors
         */
        private Blend _GetBlend() {
            // Figure out the size of blend factor array

            int retval = 0;
            int status = SafeNativeMethods.GdipGetPathGradientBlendCount(new HandleRef(this, nativeBrush), out retval);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // Allocate temporary native memory buffer

            int count = retval;
            IntPtr factors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            // Retrieve horizontal blend factors

            status = SafeNativeMethods.GdipGetPathGradientBlend(new HandleRef(this, nativeBrush), factors, positions, count);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(factors);
                Marshal.FreeHGlobal(positions);
                throw SafeNativeMethods.StatusException(status);
            }

            // Return the result in a managed array

            Blend blend = new Blend(count);

            Marshal.Copy(factors, blend.Factors, 0, count);
            Marshal.Copy(positions, blend.Positions, 0, count);

            Marshal.FreeHGlobal(factors);
            Marshal.FreeHGlobal(positions);

            return blend;
        }

        private void _SetBlend(Blend blend) {
            // Allocate temporary native memory buffer
            // and copy input blend factors into it.

            int count = blend.Factors.Length;
            IntPtr factors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            Marshal.Copy(blend.Factors, 0, factors, count);
            Marshal.Copy(blend.Positions, 0, positions, count);

            // Set blend factors

            int status = SafeNativeMethods.GdipSetPathGradientBlend(new HandleRef(this, nativeBrush), new HandleRef(null, factors), new HandleRef(null, positions), count);

            Marshal.FreeHGlobal(factors);
            Marshal.FreeHGlobal(positions);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.Blend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.Blend'/> that specifies positions and factors
        ///       that define a custom falloff for the gradient.
        ///    </para>
        /// </devdoc>
        public Blend Blend
        {
            get { return _GetBlend();}
            set { _SetBlend(value);}
        }

        /*
         * SigmaBlend & LinearBlend
         */

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.SetSigmaBellShape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a gradient falloff based on a bell-shaped curve.
        ///    </para>
        /// </devdoc>
        public void SetSigmaBellShape(float focus)
        {
            SetSigmaBellShape(focus, (float)1.0);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.SetSigmaBellShape1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a gradient falloff based on a bell-shaped curve.
        ///    </para>
        /// </devdoc>
        public void SetSigmaBellShape(float focus, float scale)
        {
            int status = SafeNativeMethods.GdipSetPathGradientSigmaBlend(new HandleRef(this, nativeBrush), focus, scale);

            if (status != SafeNativeMethods.Ok)
                 throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.SetBlendTriangularShape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a triangular gradient.
        ///    </para>
        /// </devdoc>
        public void SetBlendTriangularShape(float focus)
        {
            SetBlendTriangularShape(focus, (float)1.0);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.SetBlendTriangularShape1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a triangular gradient.
        ///    </para>
        /// </devdoc>
        public void SetBlendTriangularShape(float focus, float scale)
        {
            int status = SafeNativeMethods.GdipSetPathGradientLinearBlend(new HandleRef(this, nativeBrush), focus, scale);

            if (status != SafeNativeMethods.Ok)
                 throw SafeNativeMethods.StatusException(status);
        }

        /*
         * Preset Color Blend
         */

        private ColorBlend _GetInterpolationColors() {
            // Figure out the size of blend factor array

            int retval = 0;
            int status = SafeNativeMethods.GdipGetPathGradientPresetBlendCount(new HandleRef(this, nativeBrush), out retval);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            // If retVal is 0, then there is nothing to marshal.
            // In this case, we'll return an empty ColorBlend...
            //
            if (retval == 0) {
                return new ColorBlend();
            }

            // Allocate temporary native memory buffer

            int count = retval;
            IntPtr colors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            // Retrieve horizontal blend factors

            status = SafeNativeMethods.GdipGetPathGradientPresetBlend(new HandleRef(this, nativeBrush), colors, positions, count);

            if (status != SafeNativeMethods.Ok) {
                Marshal.FreeHGlobal(colors);
                Marshal.FreeHGlobal(positions);
                throw SafeNativeMethods.StatusException(status);
            }

            // Return the result in a managed array

            ColorBlend blend = new ColorBlend(count);

            int[] argb = new int[count];
            Marshal.Copy(colors, argb, 0, count);
            Marshal.Copy(positions, blend.Positions, 0, count);

            // copy ARGB values into Color array of ColorBlend
            blend.Colors = new Color[argb.Length];

            for (int i=0; i<argb.Length; i++)
                blend.Colors[i] = Color.FromArgb(argb[i]);

            Marshal.FreeHGlobal(colors);
            Marshal.FreeHGlobal(positions);

            return blend;
        }

        private void _SetInterpolationColors(ColorBlend blend) {
            // Allocate temporary native memory buffer
            // and copy input blend factors into it.

            int count = blend.Colors.Length;
            IntPtr colors = Marshal.AllocHGlobal(4*count);
            IntPtr positions = Marshal.AllocHGlobal(4*count);

            int[] argbs = new int[count];
            for (int i=0; i<count; i++)
                argbs[i] = blend.Colors[i].ToArgb();

            Marshal.Copy(argbs, 0, colors, count);
            Marshal.Copy(blend.Positions, 0, positions, count);

            // Set blend factors

            int status = SafeNativeMethods.GdipSetPathGradientPresetBlend(new HandleRef(this, nativeBrush), new HandleRef(null, colors), new HandleRef(null, positions), count);

            Marshal.FreeHGlobal(colors);
            Marshal.FreeHGlobal(positions);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.InterpolationColors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.ColorBlend'/> that defines a multi-color linear
        ///       gradient.
        ///    </para>
        /// </devdoc>
        public ColorBlend InterpolationColors
        {
            get { return _GetInterpolationColors(); }
            set { _SetInterpolationColors(value); }
        }
        
        /**
         * Set/get brush transform
         */
        private void _SetTransform(Matrix matrix) {
            if (matrix == null)
                throw new ArgumentNullException("matrix");
            
            int status = SafeNativeMethods.GdipSetPathGradientTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private Matrix _GetTransform() {
            Matrix matrix = new Matrix();
                        
            int status = SafeNativeMethods.GdipGetPathGradientTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return matrix;
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.Transform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.Matrix'/> that defines a local geometrical
        ///       transform for this <see cref='System.Drawing.Drawing2D.PathGradientBrush'/>.
        ///    </para>
        /// </devdoc>
        public Matrix Transform
        {
            get { return _GetTransform();}
            set { _SetTransform(value);}
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.ResetTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Drawing.Drawing2D.PathGradientBrush.Transform'/> property to
        ///       identity.
        ///    </para>
        /// </devdoc>
        public void ResetTransform() {
            int status = SafeNativeMethods.GdipResetPathGradientTransform(new HandleRef(this, nativeBrush));
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.MultiplyTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix) 
        {
            MultiplyTransform(matrix, MatrixOrder.Prepend);
        }
        
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.MultiplyTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.Drawing2D.PathGradientBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix, MatrixOrder order) 
        {
            if (matrix == null)
                throw new ArgumentNullException("matrix");
            
            int status = SafeNativeMethods.GdipMultiplyPathGradientTransform(new HandleRef(this, nativeBrush),
                                                new HandleRef(matrix, matrix.nativeMatrix),
                                                order);
        
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
 
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.TranslateTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the local geometrical transform by the specified dimmensions. This
        ///       method prepends the translation to the transform.
        ///    </para>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy) 
        {
            TranslateTransform(dx, dy, MatrixOrder.Prepend);
        }
        
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.TranslateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the local geometrical transform by the specified dimmensions in
        ///       the specified order.
        ///    </para>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy, MatrixOrder order) 
        {
            int status = SafeNativeMethods.GdipTranslatePathGradientTransform(new HandleRef(this, nativeBrush),
                                                dx, dy, order);
                                                            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
         
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.ScaleTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the specified amounts. This method
        ///       prepends the scaling matrix to the transform.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy) 
        {
            ScaleTransform(sx, sy, MatrixOrder.Prepend);
        }
        
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.ScaleTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the specified amounts in the
        ///       specified order.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy, MatrixOrder order) 
        {
            int status = SafeNativeMethods.GdipScalePathGradientTransform(new HandleRef(this, nativeBrush),
                                                sx, sy, order);
                                                            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
 
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.RotateTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified amount. This method
        ///       prepends the rotation to the transform.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle)
        {
            RotateTransform(angle, MatrixOrder.Prepend);
        }
        
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.RotateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified amount in the
        ///       specified order.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle, MatrixOrder order) 
        {
            int status = SafeNativeMethods.GdipRotatePathGradientTransform(new HandleRef(this, nativeBrush),
                                                angle, order);
                                                            
            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
         
        /**
         * Set/get brush focus scales
         */
        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.FocusScales"]/*' />
        /// <devdoc>
        ///    Gets or sets the focus point for the
        ///    gradient falloff.
        /// </devdoc>
        public PointF FocusScales
        {
            get {
                float[] scaleX = new float[] { 0.0f };
                float[] scaleY = new float[] { 0.0f };

                int status = SafeNativeMethods.GdipGetPathGradientFocusScales(new HandleRef(this, nativeBrush), scaleX, scaleY);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
                
                return new PointF(scaleX[0], scaleY[0]);
            }
            set {
                int status = SafeNativeMethods.GdipSetPathGradientFocusScales(new HandleRef(this, nativeBrush), value.X, value.Y);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /**
         * Set/get brush wrapping mode
         */
        private void _SetWrapMode(WrapMode wrapMode) {
            int status = SafeNativeMethods.GdipSetPathGradientWrapMode(new HandleRef(this, nativeBrush), (int) wrapMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private WrapMode _GetWrapMode() {
            int mode = 0;

            int status = SafeNativeMethods.GdipGetPathGradientWrapMode(new HandleRef(this, nativeBrush), out mode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return (WrapMode) mode;
        }

        /// <include file='doc\PathGradientBrush.uex' path='docs/doc[@for="PathGradientBrush.WrapMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.WrapMode'/> that indicates the wrap mode for this
        ///    <see cref='System.Drawing.Drawing2D.PathGradientBrush'/>. 
        ///    </para>
        /// </devdoc>
        public WrapMode WrapMode
        {
            get { 
                return _GetWrapMode();
            }
            set {
                //validate the WrapMode enum
                if (!Enum.IsDefined(typeof(WrapMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
                }

                _SetWrapMode(value);
            }
        }

        private PathGradientBrush(IntPtr nativeBrush) {
            SetNativeBrush(nativeBrush);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pentype.cs ===
//------------------------------------------------------------------------------
// <copyright file="PenType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PenType.cs
*
* Abstract:
*
*   Native GDI+ Pen Type constants
*
* Revision History:
*
*   3/1/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System;
    using System.Drawing;

    /**
     * PenType Type
     */
    /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of fill a <see cref='System.Drawing.Pen'/> uses to
    ///       fill lines.
    ///    </para>
    /// </devdoc>
    public enum PenType
    {
        /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType.SolidColor"]/*' />
        /// <devdoc>
        ///    Specifies a solid fill.
        /// </devdoc>
        SolidColor       = BrushType.SolidColor,
        /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType.HatchFill"]/*' />
        /// <devdoc>
        ///    Specifies a hatch fill.
        /// </devdoc>
        HatchFill        = BrushType.HatchFill,
        /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType.TextureFill"]/*' />
        /// <devdoc>
        ///    Specifies a bitmap texture fill.
        /// </devdoc>
        TextureFill      = BrushType.TextureFill,
        /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType.PathGradient"]/*' />
        /// <devdoc>
        ///    Specifies a path gradient fill.
        /// </devdoc>
        PathGradient     = BrushType.PathGradient,
        /// <include file='doc\PenType.uex' path='docs/doc[@for="PenType.LinearGradient"]/*' />
        /// <devdoc>
        ///    Specifies a linear gradient fill.
        /// </devdoc>
        LinearGradient   = BrushType.LinearGradient,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\penalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="PenAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PenAlignment.cs
*
* Abstract:
*
*   Pen alignment constants
*
* Revision History:
*
*   11/1/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Drawing;
    using System;

    /**
     * Pen alignment constants
     */
    /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment"]/*' />
    /// <devdoc>
    ///    Specifies the algnment of a <see cref='System.Drawing.Pen'/> in relation
    ///    to the line being drawn.
    /// </devdoc>
    public enum PenAlignment
    {
        /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment.Center"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the <see cref='System.Drawing.Pen'/> is positioned at the center of
        ///       the line being drawn.
        ///    </para>
        /// </devdoc>
        Center      = 0,
        /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment.Inset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the <see cref='System.Drawing.Pen'/> is positioned on the insede of
        ///       the line being drawn.
        ///    </para>
        /// </devdoc>
        Inset       = 1,
        /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment.Outset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the <see cref='System.Drawing.Pen'/> is positioned on the outside
        ///       of the line being drawn.
        ///    </para>
        /// </devdoc>
        Outset      = 2,
        /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the <see cref='System.Drawing.Pen'/> is positioned to the left of
        ///       the line being drawn.
        ///    </para>
        /// </devdoc>
        Left        = 3,
        /// <include file='doc\PenAlignment.uex' path='docs/doc[@for="PenAlignment.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the <see cref='System.Drawing.Pen'/> is positioned to the right of
        ///       the line being drawn.
        ///    </para>
        /// </devdoc>
        Right       = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pixelformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="PixelFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PixelFormat.cs
*
* Abstract:
*
*   Pixel format const types
*
* Revision History:
*
*   9/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /*
     * In-memory pixel data formats:
     *  bits 0-7 = format index
     *  bits 8-15 = pixel size (in bits)
     *  bits 16-23 = flags
     *  bits 24-31 = reserved
     */

    // Suggestion: don't use SlickEdit to format this file -- it does a horrible job.
    // Visual Studio works ok, though.
    //
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // XX                                                                         XX
    // XX  If you modify this file, please update Image.GetColorDepth()           XX
    // XX                                                                         XX
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    //
    /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat"]/*' />
    /// <devdoc>
    ///    Specifies the format of the color data for
    ///    each pixel in the image.
    /// </devdoc>
    public enum PixelFormat
    {
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Indexed"]/*' />
        /// <devdoc>
        ///    Specifies that pixel data contains
        ///    color indexed values which means they are an index to colors in the system color
        ///    table, as opposed to individual color values.
        /// </devdoc>
        Indexed      = 0x00010000,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Gdi"]/*' />
        /// <devdoc>
        ///    Specifies that pixel data contains GDI
        ///    colors.
        /// </devdoc>
        Gdi          = 0x00020000,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Alpha"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel data contains alpha values that are
        ///       not pre-multiplied.
        ///    </para>
        /// </devdoc>
        Alpha        = 0x00040000,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.PAlpha"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format contains pre-multipled alpha values.
        ///    </para>
        /// </devdoc>
        PAlpha       = 0x00080000, // What's this?
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Extended"]/*' />
        /// <devdoc>
        ///    Specifies that
        /// </devdoc>
        Extended     = 0x00100000,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Canonical"]/*' />
        /// <devdoc>
        ///    Specifies that
        /// </devdoc>
        Canonical    = 0x00200000,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Undefined"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is undefined.
        ///    </para>
        /// </devdoc>
        Undefined        =  0,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.DontCare"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is a don't care.
        ///    </para>
        /// </devdoc>
        DontCare         =  0,
        // makes it into devtools, we can change this.
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format1bppIndexed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies thatpixel format is 1 bit per pixel indexed
        ///       color. The color table therefore has two colors in it.
        ///    </para>
        /// </devdoc>
        Format1bppIndexed     =  1 | ( 1 << 8) | (int) Indexed | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format4bppIndexed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 4 bits per pixel indexed
        ///       color. The color table therefore has 16 colors in it.
        ///    </para>
        /// </devdoc>
        Format4bppIndexed     =  2 | ( 4 << 8) | (int) Indexed | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format8bppIndexed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 8 bits per pixel indexed
        ///       color. The color table therefore has 256 colors in it.
        ///    </para>
        /// </devdoc>
        Format8bppIndexed     =  3 | ( 8 << 8) | (int) Indexed | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format16bppGrayScale"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Format16bppGrayScale  =  4 | (16 << 8) | (int) Extended,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format16bppRgb555"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 16 bits per pixel. The
        ///       color information specifies 65536 shades of gray.
        ///    </para>
        /// </devdoc>                              
        Format16bppRgb555     =  5 | (16 << 8) | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format16bppRgb565"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 16 bits per pixel. The
        ///       color information specifies 32768 shades of color of which 5 bits are red, 5
        ///       bits are green and 5 bits are blue.
        ///    </para>
        /// </devdoc>
        Format16bppRgb565     =  6 | (16 << 8) | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format16bppArgb1555"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format
        ///       is 16 bits per pixel. The color information specifies 32768
        ///       shades of color of which 5 bits are red, 5 bits are green, 5
        ///       bits are blue and 1 bit is alpha.
        ///    </para>
        /// </devdoc>
        Format16bppArgb1555   =  7 | (16 << 8) | (int) Alpha | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format24bppRgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 24 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 8 bits are red, 8
        ///       bits are green and 8 bits are blue.
        ///    </para>
        /// </devdoc>
        Format24bppRgb        =  8 | (24 << 8) | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format32bppRgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 24 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 8 bits are red, 8
        ///       bits are green and 8 bits are blue.
        ///    </para>
        /// </devdoc>
        Format32bppRgb        =  9 | (32 << 8) | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format32bppArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 32 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 8 bits are red, 8
        ///       bits are green and 8 bits are blue. The 8 additional bits are alpha bits.
        ///    </para>
        /// </devdoc>
        Format32bppArgb       = 10 | (32 << 8) | (int) Alpha | (int) Gdi | (int) Canonical,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format32bppPArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that
        ///       pixel format is 32 bits per pixel. The color information
        ///       specifies 16777216 shades of color of which 8 bits are red, 8 bits are
        ///       green and 8 bits are blue. The 8 additional bits are pre-multiplied alpha bits. .
        ///    </para>
        /// </devdoc>
        Format32bppPArgb      = 11 | (32 << 8) | (int) Alpha | (int) PAlpha | (int) Gdi,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format48bppRgb"]/*' />
        /// <devdoc>
        ///    Specifies that pixel format is 48 bits per pixel.
        ///    The color information specifies 16777216 shades of color of which 8 bits are
        ///    red, 8 bits are green and 8 bits are blue. The 8 additional bits are alpha bits.
        /// </devdoc>
        Format48bppRgb        = 12 | (48 << 8) | (int) Extended,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format64bppArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies pixel format is 64 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 16 bits are red, 16
        ///       bits are green and 16 bits are blue. The 16 additional bits are alpha bits.
        ///    </para>
        /// </devdoc>
        Format64bppArgb       = 13 | (64 << 8) | (int) Alpha | (int) Canonical | (int) Extended,
        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Format64bppPArgb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 64 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 16 bits are red,
        ///       16 bits are green and 16 bits are blue. The 16 additional bits are
        ///       pre-multiplied alpha bits.
        ///    </para>
        /// </devdoc>
        Format64bppPArgb      = 14 | (64 << 8) | (int) Alpha | (int) PAlpha | (int) Extended,

        /// <include file='doc\PixelFormat.uex' path='docs/doc[@for="PixelFormat.Max"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that pixel format is 64 bits per pixel. The
        ///       color information specifies 16777216 shades of color of which 16 bits are red,
        ///       16 bits are green and 16 bits are blue. The 16 additional bits are alpha bits.
        ///    </para>
        /// </devdoc>
        Max                   = 15,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\playrecordcallback.cs ===
//------------------------------------------------------------------------------
// <copyright file="PlayRecordCallback.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Drawing.Imaging {
      	
    /// <include file='doc\PlayRecordCAllback.uex' path='docs/doc[@for="PlayRecodCallBack"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void PlayRecordCallback(EmfPlusRecordType recordType,
                                            int flags,
                                            int dataSize,
                                            IntPtr recordData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pathdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="PathData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PathData.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ path data objects
*
* Revision History:
*
*   12/22/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Represent the internal data of a path object
     */
    /// <include file='doc\PathData.uex' path='docs/doc[@for="PathData"]/*' />
    /// <devdoc>
    ///    Contains the graphical data that makes up a
    /// <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
    /// </devdoc>
    public sealed class PathData {
        PointF[] points;
        byte[] types;
        
        /// <include file='doc\PathData.uex' path='docs/doc[@for="PathData.PathData"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.Drawing2D.PathData'/> class.
        /// </devdoc>
        public PathData() {
            points = null;
            types = null;
        }

        /// <include file='doc\PathData.uex' path='docs/doc[@for="PathData.Points"]/*' />
        /// <devdoc>
        ///    Contains an array of <see cref='System.Drawing.PointF'/> objects
        ///    that represent the points through which the path is constructed.
        /// </devdoc>
        public PointF[] Points {
            get {
                return points;
            }
            set {
                points = value;
            }
        }

        /// <include file='doc\PathData.uex' path='docs/doc[@for="PathData.Types"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contains an array of <see cref='System.Drawing.Drawing2D.PathPointType'/> objects that represent the types of
        ///       data in the corresponding elements of the <see cref='System.Drawing.Drawing2D.PathData. points'/> array.
        ///    </para>
        /// </devdoc>
        public byte[] Types {
            get {
                return types;
            }
            set {
                types = value;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pathpointtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="PathPointType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PathPointType.cs
*
* Abstract:
*
*   Native GDI+ path point type constants
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /**
     * Path Point Type
     */
    /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of graphical point
    ///       contained at a specific point in a <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
    ///    </para>
    /// </devdoc>
    public enum PathPointType
    {
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.Start"]/*' />
        /// <devdoc>
        ///    Specifies the starting point of a <see cref='System.Drawing.Drawing2D.GraphicsPath'/>.
        /// </devdoc>
        Start           = 0,    // move
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.Line"]/*' />
        /// <devdoc>
        ///    Specifies a line segment.
        /// </devdoc>
        Line            = 1,    // line
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.Bezier"]/*' />
        /// <devdoc>
        ///    Specifies a default Bezier curve.
        /// </devdoc>
        Bezier          = 3,    // default Beizer (= cubic Bezier)
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.PathTypeMask"]/*' />
        /// <devdoc>
        ///    Specifies a mask point.
        /// </devdoc>
        PathTypeMask    = 0x07, // type mask (lowest 3 bits).
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.DashMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the corresponding segment is dashed.
        ///    </para>
        /// </devdoc>
        DashMode        = 0x10, // currently in dash mode.
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.PathMarker"]/*' />
        /// <devdoc>
        ///    Specifies a path marker.
        /// </devdoc>
        PathMarker      = 0x20, // a marker for the path.
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.CloseSubpath"]/*' />
        /// <devdoc>
        ///    Specifies the ending point of a subpath.
        /// </devdoc>
        CloseSubpath    = 0x80, // closed flag

        // Path types used for advanced path.
        
        /// <include file='doc\PathPointType.uex' path='docs/doc[@for="PathPointType.Bezier3"]/*' />
        /// <devdoc>
        ///    Specifies a cubic Bezier curve.
        /// </devdoc>
        Bezier3    = 3,    // cubic Bezier
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pixeloffsetmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="PixelOffsetMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PixelOffsetMode.cs
*
* Abstract:
*
*   PixelOffset mode constants
*
* Revision History:
*
*   05/01/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode"]/*' />
    /// <devdoc>
    ///    Specifies how pixels are offset during
    ///    rendering.
    /// </devdoc>
    public enum PixelOffsetMode
    {
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.Invalid"]/*' />
        /// <devdoc>
        ///    Specifies an invalid mode.
        /// </devdoc>
        Invalid = QualityMode.Invalid,
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.Default"]/*' />
        /// <devdoc>
        ///    Specifies the default mode.
        /// </devdoc>
        Default = QualityMode.Default,
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.HighSpeed"]/*' />
        /// <devdoc>
        ///    Specifies high low quality (high
        ///    performance) mode.
        /// </devdoc>
        HighSpeed = QualityMode.Low,
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.HighQuality"]/*' />
        /// <devdoc>
        ///    Specifies high quality (lower performance)
        ///    mode.
        /// </devdoc>
        HighQuality = QualityMode.High,
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.None"]/*' />
        /// <devdoc>
        ///    Specifies no pixel offset.
        /// </devdoc>
        None,                   // no pixel offset
        /// <include file='doc\PixelOffsetMode.uex' path='docs/doc[@for="PixelOffsetMode.Half"]/*' />
        /// <devdoc>
        ///    Specifies that pixels are offset by -.5
        ///    units both horizontally and vertically for high performance anti-aliasing.
        /// </devdoc>
        Half                    // offset by -0.5, -0.5 for fast anti-alias perf
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\privatefontcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrivateFontCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
* 
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   font.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ font objects
*
* Revision History:
*
*   3/16/2000 yungt [Yung-Jen Tony Tsai]
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PrivateFontCollection.uex' path='docs/doc[@for="PrivateFontCollection"]/*' />
    /// <devdoc>
    ///    Encapsulates a collection of <see cref='System.Drawing.Font'/> objecs.
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public sealed class PrivateFontCollection : FontCollection {

        /// <include file='doc\PrivateFontCollection.uex' path='docs/doc[@for="PrivateFontCollection.PrivateFontCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Text.PrivateFontCollection'/> class.
        ///    </para>
        /// </devdoc>
        public PrivateFontCollection() {
            nativeFontCollection = IntPtr.Zero;

            int status = SafeNativeMethods.GdipNewPrivateFontCollection(out nativeFontCollection);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\PrivateFontCollection.uex' path='docs/doc[@for="PrivateFontCollection.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Cleans up Windows resources for this
        ///    <see cref='System.Drawing.Text.PrivateFontCollection'/> .
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (nativeFontCollection != IntPtr.Zero) {
                int status = SafeNativeMethods.GdipDeletePrivateFontCollection(out nativeFontCollection);

                nativeFontCollection = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\PrivateFontCollection.uex' path='docs/doc[@for="PrivateFontCollection.AddFontFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a font from the specified file to
        ///       this <see cref='System.Drawing.Text.PrivateFontCollection'/>.
        ///    </para>
        /// </devdoc>
        public void AddFontFile (string filename) {
            IntSecurity.DemandReadFileIO(filename);
            int status = SafeNativeMethods.GdipPrivateAddFontFile(new HandleRef(this, nativeFontCollection), filename);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        // CONSIDER: nkramer: Distasteful as it may be to expose a void*,
        // it seems to be the only way -- memory map files are the main scenario here,
        // and I can't see doing that with a byte[].
        // Note also that GDI+ will not copy the memory -- it must stay intact for the duration
        // of the font collection.
        /// <include file='doc\PrivateFontCollection.uex' path='docs/doc[@for="PrivateFontCollection.AddMemoryFont"]/*' />
        /// <devdoc>
        ///    Adds a font contained in system memory to
        ///    this <see cref='System.Drawing.Text.PrivateFontCollection'/>.
        /// </devdoc>
        public void AddMemoryFont (IntPtr memory, int length) {
            IntSecurity.ObjectFromWin32Handle.Demand();

            int status = SafeNativeMethods.GdipPrivateAddMemoryFont(new HandleRef(this, nativeFontCollection), new HandleRef(null, memory), length);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\rectanglef.cs ===
//------------------------------------------------------------------------------
// <copyright file="RectangleF.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing {

    using System.Diagnostics;

    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Internal;
    
    
    /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Stores the location and size of a rectangular region. For
    ///       more advanced region functions use a <see cref='System.Drawing.Region'/>
    ///       object.
    ///    </para>
    /// </devdoc>
    [Serializable]
    public struct RectangleF {

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Empty"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.RectangleF'/>
        ///    class.
        /// </devdoc>
        public static readonly RectangleF Empty = new RectangleF();

        private float x;
        private float y;
        private float width;
        private float height;

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.RectangleF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.RectangleF'/>
        ///       class with the specified location and size.
        ///    </para>
        /// </devdoc>
        public RectangleF(float x, float y, float width, float height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.RectangleF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.RectangleF'/>
        ///       class with the specified location
        ///       and size.
        ///    </para>
        /// </devdoc>
        public RectangleF(PointF location, SizeF size) {
            this.x = location.X;
            this.y = location.Y;
            this.width = size.Width;
            this.height = size.Height;
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.FromLTRB"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Drawing.RectangleF'/> with
        ///       the specified location and size.
        ///    </para>
        /// </devdoc>
        // !! Not in C++ version
        public static RectangleF FromLTRB(float left, float top, float right, float bottom) {
            return new RectangleF(left,
                                 top,
                                 right - left,
                                 bottom - top);
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Location"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the coordinates of the upper-left corner of
        ///       the rectangular region represented by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public PointF Location {
            get {
                return new PointF(X, Y);
            }
            set {
                X = value.X;
                Y = value.Y;
            }
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the size of this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public SizeF Size {
            get {
                return new SizeF(Width, Height);
            }
            set {
                this.Width = value.Width;
                this.Height = value.Height;
            }
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the x-coordinate of the
        ///       upper-left corner of the rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public float X {
            get {
                return x;
            }
            set {
                x = value;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the y-coordinate of the
        ///       upper-left corner of the rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public float Y {
            get {
                return y;
            }
            set {
                y = value;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of the rectangular
        ///       region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public float Width {
            get {
                return width;
            }
            set {
                width = value;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the height of the
        ///       rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public float Height {
            get {
                return height;
            }
            set {
                height = value;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the upper-left corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.RectangleF'/> .
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public float Left {
            get {
                return X;
            }
        }
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the upper-left corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public float Top {
            get {       
                return Y;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the lower-right corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public float Right {
            get {
                return X + Width;
            }
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the lower-right corner of the
        ///       rectangular region defined by this <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public float Bottom {
            get {
                return Y + Height;
            }
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether this <see cref='System.Drawing.RectangleF'/> has a <see cref='System.Drawing.RectangleF.Width'/> or a <see cref='System.Drawing.RectangleF.Height'/> of 0.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return (Width <= 0 )|| (Height <= 0);
            }
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether <paramref name="obj"/> is a <see cref='System.Drawing.RectangleF'/> with the same location and size of this
        ///    <see cref='System.Drawing.RectangleF'/>.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is RectangleF)) 
                return false;
            
            RectangleF comp = (RectangleF)obj;
            
            return (comp.X == this.X) &&
                   (comp.Y == this.Y) &&
                   (comp.Width == this.Width) &&
                   (comp.Height == this.Height);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.RectangleF'/>
        ///       objects have equal location and size.
        ///    </para>
        /// </devdoc>
        public static bool operator ==(RectangleF left, RectangleF right) {
            return (left.X == right.X
                     && left.Y == right.Y
                     && left.Width == right.Width
                     && left.Height == right.Height);
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.RectangleF'/>
        ///       objects differ in location or size.
        ///    </para>
        /// </devdoc>
        public static bool operator !=(RectangleF left, RectangleF right) {
            return !(left == right);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the specfied point is contained within the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(float x, float y) {
            return this.X <= x &&
            x < this.X + this.Width &&
            this.Y <= y &&
            y < this.Y + this.Height;
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Contains1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the specfied point is contained within the
        ///       rectangular region defined by this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(PointF pt) {
            return Contains(pt.X, pt.Y);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Contains2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the rectangular region represented by
        ///    <paramref name="rect"/> is entirely contained within the rectangular region represented by 
        ///       this <see cref='System.Drawing.Rectangle'/> .
        ///    </para>
        /// </devdoc>
        public bool Contains(RectangleF rect) {
            return (this.X <= rect.X) &&
                   ((rect.X + rect.Width) <= (this.X + this.Width)) &&
                   (this.Y <= rect.Y) &&
                   ((rect.Y + rect.Height) <= (this.Y + this.Height));
        }

        // !! Not in C++ version
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.GetHashCode"]/*' />
        /// <devdoc>
        ///    Gets the hash code for this <see cref='System.Drawing.RectangleF'/>.
        /// </devdoc>
        public override int GetHashCode() {
            return (int)((UInt32)X ^
            (((UInt32)Y << 13) | ((UInt32)Y >> 19)) ^
            (((UInt32)Width << 26) | ((UInt32)Width >>  6)) ^
            (((UInt32)Height <<  7) | ((UInt32)Height >> 25)));
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Inflate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inflates this <see cref='System.Drawing.Rectangle'/>
        ///       by the specified amount.
        ///    </para>
        /// </devdoc>
        public void Inflate(float x, float y) {
            this.X -= x;
            this.Y -= y;
            this.Width += 2*x;
            this.Height += 2*y;
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Inflate1"]/*' />
        /// <devdoc>
        ///    Inflates this <see cref='System.Drawing.Rectangle'/> by the specified amount.
        /// </devdoc>
        public void Inflate(SizeF size) { 
            Inflate(size.Width, size.Height);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Inflate2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Drawing.Rectangle'/>
        ///       that is inflated by the specified amount.
        ///    </para>
        /// </devdoc>
        // !! Not in C++
        public static RectangleF Inflate(RectangleF rect, float x, float y) {
            RectangleF r = rect;
            r.Inflate(x, y);
            return r;
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Intersect"]/*' />
        /// <devdoc> Creates a Rectangle that represents the intersection between this Rectangle and rect.
        /// </devdoc>
        public void Intersect(RectangleF rect)
        {
            RectangleF result = RectangleF.Intersect(rect, this);
            
            this.X = result.X;
            this.Y = result.Y;
            this.Width = result.Width;
            this.Height = result.Height;
        }
        
        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Intersect1"]/*' />
        /// <devdoc>
        ///    Creates a rectangle that represents the intersetion between a and
        ///    b. If there is no intersection, null is returned.
        /// </devdoc>
        public static RectangleF Intersect(RectangleF a, RectangleF b) {
            float x1 = Math.Max(a.X, b.X);
            float x2 = Math.Min(a.X + a.Width, b.X + b.Width);
            float y1 = Math.Max(a.Y, b.Y);
            float y2 = Math.Min(a.Y + a.Height, b.Y + b.Height);

            if (x2 >= x1
                && y2 >= y1) {

                return new RectangleF(x1, y1, x2 - x1, y2 - y1);
            }
            return RectangleF.Empty;
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.IntersectsWith"]/*' />
        /// <devdoc>
        ///    Determines if this rectangle intersets with rect.
        /// </devdoc>
        public bool IntersectsWith(RectangleF rect) {
            return (rect.X < this.X + this.Width) && 
                   (this.X < (rect.X + rect.Width)) &&
                   (rect.Y < this.Y + this.Height) &&
                   (this.Y < rect.Y + rect.Height);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Union"]/*' />
        /// <devdoc>
        ///    Creates a rectangle that represents the union between a and
        ///    b.
        /// </devdoc>
        public static RectangleF Union(RectangleF a, RectangleF b) {
            float x1 = Math.Min(a.X, b.X);
            float x2 = Math.Max(a.X + a.Width, b.X + b.Width);
            float y1 = Math.Min(a.Y, b.Y);
            float y2 = Math.Max(a.Y + a.Height, b.Y + b.Height);

            return new RectangleF(x1, y1, x2 - x1, y2 - y1);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Offset"]/*' />
        /// <devdoc>
        ///    Adjusts the location of this rectangle by the specified amount.
        /// </devdoc>
        public void Offset(PointF pos) {
            Offset(pos.X, pos.Y);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.Offset1"]/*' />
        /// <devdoc>
        ///    Adjusts the location of this rectangle by the specified amount.
        /// </devdoc>
        public void Offset(float x, float y) {
            this.X += x;
            this.Y += y;
        }

        /**
         * Convert the current rectangle object into
         * a GDI+ GPRECTF structure.
         */
        internal GPRECTF ToGPRECTF() {
            return new GPRECTF(X, Y, Width, Height);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.operatorRectangleF"]/*' />
        /// <devdoc>
        ///    Converts the specified <see cref='System.Drawing.Rectangle'/> to a
        /// <see cref='System.Drawing.RectangleF'/>.
        /// </devdoc>
        public static implicit operator RectangleF(Rectangle r) {
            return new RectangleF(r.X, r.Y, r.Width, r.Height);
        }

        /// <include file='doc\RectangleF.uex' path='docs/doc[@for="RectangleF.ToString"]/*' />
        /// <devdoc>
        ///    Converts the <see cref='System.Drawing.RectangleF.Location'/> and <see cref='System.Drawing.RectangleF.Size'/> of this <see cref='System.Drawing.RectangleF'/> to a
        ///    human-readable string.
        /// </devdoc>
        public override string ToString() {
            return "{X=" + X.ToString() + ",Y=" + Y.ToString() +
            ",Width=" + Width.ToString() +
            ",Height=" + Height.ToString() + "}";
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\qualitymode.cs ===
//------------------------------------------------------------------------------
// <copyright file="QualityMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   QualityMode.cs  
*
* Abstract:
*
*   Quality mode constants
*
* Revision History:
*
*   05/01/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /// <include file='doc\QualityMode.uex' path='docs/doc[@for="QualityMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the overall quality of rendering
    ///       of graphics shapes.
    ///    </para>
    /// </devdoc>
    public enum QualityMode
    {
        /// <include file='doc\QualityMode.uex' path='docs/doc[@for="QualityMode.Invalid"]/*' />
        /// <devdoc>
        ///    Specifies an invalid mode.
        /// </devdoc>
        Invalid = -1,
        /// <include file='doc\QualityMode.uex' path='docs/doc[@for="QualityMode.Default"]/*' />
        /// <devdoc>
        ///    Specifies the default mode.
        /// </devdoc>
        Default = 0,
        /// <include file='doc\QualityMode.uex' path='docs/doc[@for="QualityMode.Low"]/*' />
        /// <devdoc>
        ///    Specifies low quality, high performance
        ///    rendering.
        /// </devdoc>
        Low = 1,             // for apps that need the best performance
        /// <include file='doc\QualityMode.uex' path='docs/doc[@for="QualityMode.High"]/*' />
        /// <devdoc>
        ///    Specifies high quality, lower performance
        ///    rendering.
        /// </devdoc>
        High = 2             // for apps that need the best rendering quality                                          
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\propertyitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PropertyItem.cs
*
* Abstract:
*
*   Native GDI+ PropertyItem structure.
*
* Revision History:
*
*   3/3/2k ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {
    using System.Runtime.InteropServices;
    using System;    
    using System.Drawing;
                               
    // sdkinc\imaging.h
    /// <include file='doc\PropertyItem.uex' path='docs/doc[@for="PropertyItem"]/*' />
    /// <devdoc>
    ///    Encapsulates a metadata property to be
    ///    included in an image file.
    /// </devdoc>
    public sealed class PropertyItem {
        int id;
        int len;
        short type;
        byte[] value;

        internal PropertyItem() {
        }

        /// <include file='doc\PropertyItem.uex' path='docs/doc[@for="PropertyItem.Id"]/*' />
        /// <devdoc>
        ///    Represents the ID of the property.
        /// </devdoc>
        public int Id {
            get { return id; }
            set { id = value; }
        }
        /// <include file='doc\PropertyItem.uex' path='docs/doc[@for="PropertyItem.Len"]/*' />
        /// <devdoc>
        ///    Represents the length of the property.
        /// </devdoc>
        public int Len {
            get { return len; }
            set { len = value; }
        }
        /// <include file='doc\PropertyItem.uex' path='docs/doc[@for="PropertyItem.Type"]/*' />
        /// <devdoc>
        ///    Represents the type of the property.
        /// </devdoc>
        public short Type {
            get { return type; }
            set { type = value; }
        }
        /// <include file='doc\PropertyItem.uex' path='docs/doc[@for="PropertyItem.Value"]/*' />
        /// <devdoc>
        ///    Contains the property value.
        /// </devdoc>
        public byte[] Value {
            get { return this.value; }
            set { this.value = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\pointf.cs ===
//------------------------------------------------------------------------------
// <copyright file="PointF.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PointF.cs
*
* Abstract:
*
*   Floating-point coordinate point class
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Diagnostics;

    using System.Drawing;
    using System.ComponentModel;
    using System;

    /**
     * Represents a point in 2D coordinate space
     * (float precision floating-point coordinates)
     */
    /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF"]/*' />
    /// <devdoc>
    ///    Represents an ordered pair of x and y coordinates that
    ///    define a point in a two-dimensional plane.
    /// </devdoc>
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(true)]
    public struct PointF {


        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.Empty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the <see cref='System.Drawing.PointF'/> class
        ///       with member data left uninitialized.
        ///    </para>
        /// </devdoc>
        public static readonly PointF Empty = new PointF();
        private float x;
        private float y;
        /**
         * Create a new Point object at the given location
         */
        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.PointF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.PointF'/> class
        ///       with the specified coordinates.
        ///    </para>
        /// </devdoc>
        public PointF(float x, float y) {
            this.x = x;
            this.y = y;
        }


        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this <see cref='System.Drawing.PointF'/> is empty.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return x == 0f && y == 0f;
            }
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of this <see cref='System.Drawing.PointF'/>.
        ///    </para>
        /// </devdoc>
        public float X {
            get {
                return x;
            }
            set {
                x = value;
            }
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of this <see cref='System.Drawing.PointF'/>.
        ///    </para>
        /// </devdoc>
        public float Y {
            get {
                return y;
            }
            set {
                y = value;
            }
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.operator+"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates a <see cref='System.Drawing.PointF'/> by a given <see cref='System.Drawing.Size'/> .
        ///    </para>
        /// </devdoc>
        public static PointF operator +(PointF pt, Size sz) {
            return new PointF(pt.X + sz.Width, pt.Y + sz.Height);
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.operator-"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates a <see cref='System.Drawing.PointF'/> by the negative of a given <see cref='System.Drawing.Size'/> .
        ///    </para>
        /// </devdoc>
        public static PointF operator -(PointF pt, Size sz) {
            return new PointF(pt.X - sz.Width, pt.Y - sz.Height);
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.operator=="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two <see cref='System.Drawing.PointF'/> objects. The result specifies
        ///       whether the values of the <see cref='System.Drawing.PointF.X'/> and <see cref='System.Drawing.PointF.Y'/> properties of the two <see cref='System.Drawing.PointF'/>
        ///       objects are equal.
        ///    </para>
        /// </devdoc>
        public static bool operator ==(PointF left, PointF right) {
            return left.X == right.X && left.Y == right.Y;
        }
        
        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares two <see cref='System.Drawing.PointF'/> objects. The result specifies whether the values
        ///       of the <see cref='System.Drawing.PointF.X'/> or <see cref='System.Drawing.PointF.Y'/> properties of the two
        ///    <see cref='System.Drawing.PointF'/> 
        ///    objects are unequal.
        /// </para>
        /// </devdoc>
        public static bool operator !=(PointF left, PointF right) {
            return !(left == right);
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is PointF)) return false;
            PointF comp = (PointF)obj;
            return
            comp.X == this.X &&
            comp.Y == this.Y &&
            comp.GetType().Equals(this.GetType());
        }

        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }
        
        /// <include file='doc\PointF.uex' path='docs/doc[@for="PointF.ToString"]/*' />
        public override string ToString() {
            return string.Format("{{X={0}, Y={1}}}", x, y);
        }

        /**
         * Offset the current PointF object by the given amount
         */
        internal void Offset(float dx, float dy) {
            X += dx;
            Y += dy;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\radialgradientbrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="RadialGradientBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

// !! Delete this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\regiondata.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegionData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RegionData.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ RegionData objects
*
* Revision History:
*
*   12/18/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System.Runtime.InteropServices;
    using System;

    /// <include file='doc\RegionData.uex' path='docs/doc[@for="RegionData"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Encapsulates the data that makes up a <see cref='System.Drawing.Region'/>.
    ///    </para>
    /// </devdoc>
    public sealed class RegionData {
        byte[] data;

        internal RegionData(byte[] data) {
            this.data = data;
        }

        /// <include file='doc\RegionData.uex' path='docs/doc[@for="RegionData.Data"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An array of characters that contain the data that makes up a <see cref='System.Drawing.Region'/>.
        ///    </para>
        /// </devdoc>
        public byte[] Data {
            get {
                return data;
            }
            set {
                data = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringdigitsubstitute.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringDigitSubstitute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* font style constants (sdkinc\GDIplusEnums.h)
*/

namespace System.Drawing {

    using System;
    using System.Diagnostics;
    
    /// <include file='doc\StringDigitSubstitute.uex' path='docs/doc[@for="StringDigitSubstitute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies style information applied to
    ///       String Digit Substitute.
    ///    </para>
    /// </devdoc>
    public enum StringDigitSubstitute { 
        /// <include file='doc\StringDigitSubstitute.uex' path='docs/doc[@for="StringDigitSubstitute.User"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        User        = 0,  // As NLS setting
        /// <include file='doc\StringDigitSubstitute.uex' path='docs/doc[@for="StringDigitSubstitute.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None        = 1,
        /// <include file='doc\StringDigitSubstitute.uex' path='docs/doc[@for="StringDigitSubstitute.National"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        National    = 2,
        /// <include file='doc\StringDigitSubstitute.uex' path='docs/doc[@for="StringDigitSubstitute.Traditional"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Traditional = 3
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StringAlignment.cs
*
* Abstract:
*
*   StringAlignment constants
*
* Revision History:
*
*  3/1/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Drawing;
    using System;

    /**
     * used for both vertical and horizontal alignment.
     */
    /// <include file='doc\StringAlignment.uex' path='docs/doc[@for="StringAlignment"]/*' />
    /// <devdoc>
    ///    Specifies the alignment of a text string
    ///    relative to its layout rectangle.
    /// </devdoc>
    public enum StringAlignment
    {
        // left or top in English
        /// <include file='doc\StringAlignment.uex' path='docs/doc[@for="StringAlignment.Near"]/*' />
        /// <devdoc>
        ///    Specifies the text be aligned near the
        ///    layout. In a left-to-right layout, the near position is left. In a right-to-left
        ///    layout, the near position is right.
        /// </devdoc>
        Near        = 0,
        
        /// <include file='doc\StringAlignment.uex' path='docs/doc[@for="StringAlignment.Center"]/*' />
        /// <devdoc>
        ///    Specifies that text is aligned in the
        ///    center of the layout rectangle.
        /// </devdoc>
        Center      = 1,
        
        // nkramer -- NO ALTERNATE SPELLINGS!
        // Centre      = 1,
        
        // right or bottom in English
        /// <include file='doc\StringAlignment.uex' path='docs/doc[@for="StringAlignment.Far"]/*' />
        /// <devdoc>
        ///    Specifies that text is aligned far from the
        ///    origin position of the layout rectangle. In a left-to-right layout, the far
        ///    position is right. In a right-to-left layout, the far position is left.
        /// </devdoc>
        Far         = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\smoothingmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="SmoothingMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   SmoothingMode.cs
*
* Abstract:
*
*   Smoothing mode constants
*
* Revision History:
*
*   05/01/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the overall quality of rendering of graphics
    ///       shapes.
    ///    </para>
    /// </devdoc>
    public enum SmoothingMode
    {
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.Invalid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies an invalid mode.
        ///    </para>
        /// </devdoc>
        Invalid = QualityMode.Invalid,
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default mode.
        ///    </para>
        /// </devdoc>
        Default = QualityMode.Default,
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.HighSpeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies low quality, high performance rendering.
        ///    </para>
        /// </devdoc>
        HighSpeed = QualityMode.Low,
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.HighQuality"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies high quality, lower performance rendering.
        ///    </para>
        /// </devdoc>
        HighQuality = QualityMode.High,
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.None"]/*' />
        /// <devdoc>
        ///    Specifies no anti-aliasing.
        /// </devdoc>
        None,
        /// <include file='doc\SmoothingMode.uex' path='docs/doc[@for="SmoothingMode.AntiAlias"]/*' />
        /// <devdoc>
        ///    Specifies anti-aliased rendering.
        /// </devdoc>
        AntiAlias
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\sizef.cs ===
//------------------------------------------------------------------------------
// <copyright file="SizeF.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   SizeF.cs
*
* Abstract:
*
*   Floating-point coordinate size class
*
* Revision History:
*
*   12/14/1998 davidx
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Diagnostics;

    using System;
    using System.IO;
    using Microsoft.Win32;
    using System.ComponentModel;

    /**
     * Represents a dimension in 2D coordinate space
     */
    /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the size of a rectangular region
    ///       with an ordered pair of width and height.
    ///    </para>
    /// </devdoc>
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(true)]
    public struct SizeF {

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.Empty"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.SizeF'/> class.
        /// </devdoc>
        public static readonly SizeF Empty = new SizeF();
        private float width;
        private float height;


        /**
         * Create a new SizeF object from another size object
         */
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.SizeF"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.SizeF'/> class
        ///    from the specified existing <see cref='System.Drawing.SizeF'/>.
        /// </devdoc>
        public SizeF(SizeF size) {
            width = size.width;
            height = size.height;
        }

        /**
         * Create a new SizeF object from a point
         */
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.SizeF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.SizeF'/> class from
        ///       the specified <see cref='System.Drawing.PointF'/>.
        ///    </para>
        /// </devdoc>
        public SizeF(PointF pt) {
            width = pt.X;
            height = pt.Y;
        }

        /**
         * Create a new SizeF object of the specified dimension
         */
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.SizeF2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.SizeF'/> class from
        ///       the specified dimensions.
        ///    </para>
        /// </devdoc>
        public SizeF(float width, float height) {
            this.width = width;
            this.height = height;
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.operator+"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs vector addition of two <see cref='System.Drawing.SizeF'/> objects.
        ///    </para>
        /// </devdoc>
        public static SizeF operator +(SizeF sz1, SizeF sz2) {
            return new SizeF(sz1.Width + sz2.Width, sz1.Height + sz2.Height);
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.operator-"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Contracts a <see cref='System.Drawing.SizeF'/> by another <see cref='System.Drawing.SizeF'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public static SizeF operator -(SizeF sz1, SizeF sz2) {
            return new SizeF(sz1.Width - sz2.Width, sz1.Height - sz2.Height);
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.operator=="]/*' />
        /// <devdoc>
        ///    Tests whether two <see cref='System.Drawing.SizeF'/> objects
        ///    are identical.
        /// </devdoc>
        public static bool operator ==(SizeF sz1, SizeF sz2) {
            return sz1.Width == sz2.Width && sz1.Height == sz2.Height;
        }
        
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.operator!="]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether two <see cref='System.Drawing.SizeF'/> objects are different.
        ///    </para>
        /// </devdoc>
        public static bool operator !=(SizeF sz1, SizeF sz2) {
            return !(sz1 == sz2);
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.operatorPointF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the specified <see cref='System.Drawing.SizeF'/> to a
        ///    <see cref='System.Drawing.PointF'/>.
        ///    </para>
        /// </devdoc>
        public static explicit operator PointF(SizeF size) {
            return new PointF(size.Width, size.Height);
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.IsEmpty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether this <see cref='System.Drawing.SizeF'/> has zero
        ///       width and height.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsEmpty {
            get {
                return width == 0 && height == 0;
            }
        }

        /**
         * Horizontal dimension
         */
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the horizontal component of this
        ///    <see cref='System.Drawing.SizeF'/>.
        ///    </para>
        /// </devdoc>
        public float Width {
            get {
                return width;
            }
            set {
                width = value;
            }
        }

        /**
         * Vertical dimension
         */
        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.Height"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the vertical component of this
        ///    <see cref='System.Drawing.SizeF'/>.
        ///    </para>
        /// </devdoc>
        public float Height {
            get {
                return height;
            }
            set {
                height = value;
            }
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests to see whether the specified object is a
        ///    <see cref='System.Drawing.SizeF'/> 
        ///    with the same dimensions as this <see cref='System.Drawing.SizeF'/>.
        /// </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is SizeF))
                return false;

            SizeF comp = (SizeF)obj;

            return(comp.Width == this.Width) && 
            (comp.Height == this.Height) &&
            (comp.GetType().Equals(GetType()));
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.ToPointF"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PointF ToPointF() {
            return (PointF) this;
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.ToSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Size ToSize() {
            return Size.Truncate(this);
        }

        /// <include file='doc\SizeF.uex' path='docs/doc[@for="SizeF.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a human-readable string that represents this
        ///    <see cref='System.Drawing.SizeF'/>.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "{Width=" + width.ToString() + ", Height=" + height.ToString() + "}";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   String format specification for DrawString and text in C# wrapper
*
* Revision History:
*
*   10/15/1999 YungT
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Drawing;
    using System.ComponentModel;
    using System.Drawing.Text;
    using System.Drawing.Internal;
    using System.Runtime.InteropServices;

    /// <include file='doc\StringFormat.uex' path='docs/doc[@for="CharacterRange"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public struct CharacterRange {


        private int first;
        private int length;

         /**
         * Create a new CharacterRange object
         */
        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="CharacterRange.CharacterRange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.CharacterRange'/> class
        ///       with the specified coordinates.
        ///    </para>
        /// </devdoc>
        public CharacterRange(int First, int Length) {
            this.first = First;
            this.length = Length;
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="CharacterRange.First"]/*' />
        /// <devdoc>
        ///    Gets the First character position of this <see cref='System.Drawing.CharacterRange'/>.
        /// </devdoc>
        public int First {
            get {
                return first;
            }
            set {
                first = value;
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="CharacterRange.Length"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Length of this <see cref='System.Drawing.CharacterRange'/>.
        ///    </para>
        /// </devdoc>
        public int Length {
            get {
                return length;
            }
            set {
                length = value;
            }
        }
    }        

    /**
     * Represent a Stringformat object
     */
    /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat"]/*' />
    /// <devdoc>
    ///    Encapsulates text layout information (such
    ///    as alignment and linespacing), display manipulations (such as ellipsis insertion
    ///    and national digit substitution) and OpenType features.
    /// </devdoc>
    public sealed class StringFormat : MarshalByRefObject, ICloneable, IDisposable {
        internal IntPtr nativeFormat;

        private StringFormat(IntPtr format) {
            nativeFormat = format;
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.StringFormat"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.StringFormat'/>
        ///    class.
        /// </devdoc>
        public StringFormat() : this(0, 0) {
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.StringFormat1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.StringFormat'/>
        ///    class with the specified <see cref='System.Drawing.StringFormatFlags'/>.
        /// </devdoc>
        public StringFormat(StringFormatFlags options) :
        this(options, 0) {
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.StringFormat2"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.StringFormat'/>
        ///    class with the specified <see cref='System.Drawing.StringFormatFlags'/> and language.
        /// </devdoc>
        public StringFormat(StringFormatFlags options, int language) {
            int status = SafeNativeMethods.GdipCreateStringFormat(options, language, out nativeFormat);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.StringFormat3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.StringFormat'/> class from the specified
        ///       existing <see cref='System.Drawing.StringFormat'/>.
        ///    </para>
        /// </devdoc>
        public StringFormat(StringFormat format) {

            if (format == null) {
                throw new ArgumentNullException("format");
            }

            int status = SafeNativeMethods.GdipCloneStringFormat(new HandleRef(format, format.nativeFormat), out nativeFormat);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Dispose"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        